L Prepend(LPVOID pData);

    BOOL Find(LPVOID pData);
    BOOL Remove(LPVOID pData);

    LPVOID Get(void);

    LPVOID Iterate(void);

    void Reset(void) { m_nCurrOffset = CLIST_END_OF_ARRAY_MARK; };
    void Clear(void) { m_cEntries = 0; m_nHeadOffset = 0; m_nCurrOffset = CLIST_END_OF_ARRAY_MARK; };

    UINT GetCount(void) { return m_cEntries; };
    BOOL IsEmpty(void) { return (m_cEntries == 0); };

    LPVOID PeekHead(void) { return (0 != m_cEntries) ? m_aEntries[m_nHeadOffset] : NULL; }

protected:

    void CalcKeyArray(void);

protected:

    ULONG      m_cEntries;
    ULONG      m_cMaxEntries;
    ULONG      m_nHeadOffset;
    ULONG      m_nCurrOffset;
    ULONG      m_cSubItems;    // 1 for CList, 2 for CList2
    BOOL       m_fQueue;       // TRUE for CQueue, FALSE for CList

    LPVOID     *m_aEntries;
    UINT_PTR   *m_aKeys;       // for CList2

private:

    BOOL Expand(void);
    BOOL Init(ULONG cSubItems);
};


#define DEFINE_CLIST(_NewClass_,_PtrItemType_) \
            public: \
            _NewClass_(void) : CList() { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList(cMaxItems) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList((CList *) pSrc) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList((CList *) &Src) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Append(_PtrItemType_ pData) { return CList::Append((LPVOID) pData); } \
            BOOL Prepend(_PtrItemType_ pData) { return CList::Prepend((LPVOID) pData); } \
            BOOL Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            BOOL Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); }

#define DEFINE_CLIST_(_NewClass_,_IntItemType_) \
            public: \
            _NewClass_(void) : CList() { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList(cMaxItems) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList((CList *) pSrc) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList((CList *) &Src) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntItemType_ nData) { return CList::Append((LPVOID) nData); } \
            BOOL Prepend(_IntItemType_ nData) { return CList::Prepend((LPVOID) nData); } \
            BOOL Remove(_IntItemType_ nData) { return CList::Remove((LPVOID) nData); } \
            BOOL Find(_IntItemType_ nData) { return CList::Find((LPVOID) nData); } \
            _IntItemType_ Get(void) { return (_IntItemType_) (UINT_PTR) CList::Get(); } \
            _IntItemType_ PeekHead(void) { return (_IntItemType_) (UINT_PTR) CList::PeekHead(); } \
            _IntItemType_ Iterate(void) { return (_IntItemType_) (UINT_PTR) CList::Iterate(); }


class CList2 : public CList
{
public:

    CList2(ULONG cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList(cMaxItems, 2) { }
    CList2(ULONG cMaxItems, BOOL fQueue)              : CList(cMaxItems, 2, fQueue) { }

    CList2(CList2 *pSrc);

    BOOL Append(UINT_PTR nKey, LPVOID pData);
    BOOL Prepend(UINT_PTR nKey, LPVOID pData);

    // BOOL Remove(LPVOID pData); // inherited from CList
    LPVOID Remove(UINT_PTR nKey);

    // BOOL Find(LPVOID pData); // inherited from CList
    LPVOID Find(UINT_PTR nKey);

    // LPVOID Get(void); // inheirted from CList
    LPVOID Get(UINT_PTR *pnKey);

    // LPVOID Iterate(void); // inherited from CList
    LPVOID Iterate(UINT_PTR *pnKey);

    LPVOID PeekHead(UINT_PTR *pnKey);
};


#define DEFINE_CLIST2(_NewClass_,_PtrItemType_,_IntKeyType_) \
            public: \
            _NewClass_(void) : CList2() { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList2(cMaxItems) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList2((CList2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList2((CList2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Append((UINT_PTR) nKey, (LPVOID) pData); } \
            BOOL Prepend(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Prepend((UINT_PTR) nKey, (LPVOID) pData); } \
            BOOL          Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            _PtrItemType_ Remove(_IntKeyType_ nKey) { return (_PtrItemType_) (UINT_PTR) CList2::Remove((UINT_PTR) nKey); } \
            BOOL          Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Find(_IntKeyType_ nKey) { return (_PtrItemType_) (UINT_PTR) CList2::Find((UINT_PTR) nKey); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) (UINT_PTR) CList::Get(); } \
            _PtrItemType_ Get(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::Get(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) (UINT_PTR) CList::PeekHead(); } \
            _PtrItemType_ PeekHead(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::PeekHead(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) (UINT_PTR) CList::Iterate(); } \
            _PtrItemType_ Iterate(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::Iterate(&n); *pnKey = (_IntKeyType_) n; return p; }

#define DEFINE_CLIST2_(_NewClass_,_PtrItemType_,_ShortKeyType_) \
            DEFINE_CLIST2(_NewClass_,_PtrItemType_,_ShortKeyType_)

#define DEFINE_CLIST2__(_NewClass_,_IntKeyType_) \
            public: \
            _NewClass_(void) : CList2() { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CList2(cMaxItems) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CList2((CList2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CList2((CList2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Append((UINT_PTR) nKey, (LPVOID) nData); } \
            BOOL Prepend(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Prepend((UINT_PTR) nKey, (LPVOID) nData); } \
            _IntKeyType_ Remove(_IntKeyType_ nKey) { return (_IntKeyType_) (UINT_PTR) CList2::Remove((UINT_PTR) nKey); } \
            _IntKeyType_ Find(_IntKeyType_ nKey) { return (_IntKeyType_) (UINT_PTR) CList2::Find((UINT_PTR) nKey); } \
            _IntKeyType_ Get(void) { return (_IntKeyType_) (UINT_PTR) CList::Get(); } \
            _IntKeyType_ Get(_IntKeyType_ *pnKey) { UINT_PTR n; _IntKeyType_ p = (_IntKeyType_) (UINT_PTR) CList2::Get(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _IntKeyType_ PeekHead(void) { return (_IntKeyType_) (UINT_PTR) CList::PeekHead(); } \
            _IntKeyType_ PeekHead(_IntKeyType_ *pnKey) { UINT_PTR n; _IntKeyType_ p = (_IntKeyType_) (UINT_PTR) CList2::PeekHead(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _IntKeyType_ Iterate(void) { return (_IntKeyType_) (UINT_PTR) CList::Iterate(); } \
            _IntKeyType_ Iterate(_IntKeyType_ *pnKey) { UINT_PTR n; _IntKeyType_ p = (_IntKeyType_) (UINT_PTR) CList2::Iterate(&n); *pnKey = (_IntKeyType_) n; return p; }

#define DEFINE_CLIST2___(_NewClass_,_ShortKeyType_) \
            DEFINE_CLIST2__(_NewClass_,_ShortKeyType_)

class CQueue : public CList
{
public:

    CQueue(ULONG cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList(cMaxItems, 1, TRUE) { };
    CQueue(CQueue *pSrc) : CList((CList *) pSrc) { };
};


#define DEFINE_CQUEUE(_NewClass_,_PtrItemType_) \
            public: \
            _NewClass_(void) : CQueue() { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue(cMaxItems) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue((CQueue *) pSrc) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue((CQueue *) &Src) { C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Append(_PtrItemType_ pData) { return CList::Append((LPVOID) pData); } \
            BOOL Prepend(_PtrItemType_ pData) { return CList::Prepend((LPVOID) pData); } \
            BOOL Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            BOOL Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) CList::Get(); } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) CList::PeekHead(); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CList::Iterate(); }

#define DEFINE_CQUEUE_(_NewClass_,_IntItemType_) \
            public: \
            _NewClass_(void) : CQueue() { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue(cMaxItems) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue((CQueue *) pSrc) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue((CQueue *) &Src) { C_ASSERT(sizeof(_IntItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntItemType_ nData) { return CList::Append((LPVOID) nData); } \
            BOOL Prepend(_IntItemType_ nData) { return CList::Prepend((LPVOID) nData); } \
            BOOL Remove(_IntItemType_ nData) { return CList::Remove((LPVOID) nData); } \
            BOOL Find(_IntItemType_ nData) { return CList::Find((LPVOID) nData); } \
            _IntItemType_ Get(void) { return (_IntItemType_) (UINT_PTR) CList::Get(); } \
            _IntItemType_ PeekHead(void) { return (_IntItemType_) (UINT_PTR) CList::PeekHead(); } \
            _IntItemType_ Iterate(void) { return (_IntItemType_) (UINT_PTR) CList::Iterate(); }



class CQueue2 : public CList2
{
public:

    CQueue2(ULONG cMaxItems = CLIST_DEFAULT_MAX_ITEMS) : CList2(cMaxItems, TRUE) { };
    CQueue2(CQueue2 *pSrc) : CList2((CList2 *) pSrc) { };
};


#define DEFINE_CQUEUE2(_NewClass_,_PtrItemType_,_IntKeyType_) \
            public: \
            _NewClass_(void) : CQueue2() { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue2(cMaxItems) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue2((CQueue2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue2((CQueue2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) <= sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) <= sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Append((UINT_PTR) nKey, (LPVOID) pData); } \
            BOOL Prepend(_IntKeyType_ nKey, _PtrItemType_ pData) { return CList2::Prepend((UINT_PTR) nKey, (LPVOID) pData); } \
            BOOL          Remove(_PtrItemType_ pData) { return CList::Remove((LPVOID) pData); } \
            _PtrItemType_ Remove(_IntKeyType_ nKey) { return (_PtrItemType_) (UINT_PTR) CList2::Remove((UINT_PTR) nKey); } \
            BOOL          Find(_PtrItemType_ pData) { return CList::Find((LPVOID) pData); } \
            _PtrItemType_ Find(_IntKeyType_ nKey) { return (_PtrItemType_) (UINT_PTR) CList2::Find((UINT_PTR) nKey); } \
            _PtrItemType_ Get(void) { return (_PtrItemType_) (UINT_PTR) CList::Get(); } \
            _PtrItemType_ Get(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::Get(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _PtrItemType_ PeekHead(void) { return (_PtrItemType_) (UINT_PTR) CList::PeekHead(); } \
            _PtrItemType_ PeekHead(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::PeekHead(&n); *pnKey = (_IntKeyType_) n; return p; } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) (UINT_PTR) CList::Iterate(); } \
            _PtrItemType_ Iterate(_IntKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) (UINT_PTR) CList2::Iterate(&n); *pnKey = (_IntKeyType_) n; return p; }

#define DEFINE_CQUEUE2_(_NewClass_,_PtrItemType_,_ShortKeyType_) \
            DEFINE_CQUEUE2(_NewClass_,_PtrItemType_,_ShortKeyType_)

// both key and item are of the same type
#define DEFINE_CQUEUE2__(_NewClass_,_IntKeyType_) \
            public: \
            _NewClass_(void) : CQueue2() { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            _NewClass_(ULONG cMaxItems) : CQueue2(cMaxItems) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CQueue2((CQueue2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CQueue2((CQueue2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT_PTR)); C_ASSERT(sizeof(_IntKeyType_) == sizeof(LPVOID)); } \
            BOOL Append(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Append((UINT_PTR) nKey, (LPVOID) nData); } \
            BOOL Prepend(_IntKeyType_ nKey, _IntKeyType_ nData) { return CList2::Prepend((UINT_PTR) nKey, (LPVOID) nData); } \
            _IntKeyType_ Remove(_IntKeyType_ nKey) { return (_IntKeyType_) CList2::Remove((UINT_PTR) nKey); } \
            _IntKeyType_ Find(_IntKeyType_ nKey) { return (_IntKeyType_) CList2::Find((UINT_PTR) nKey); } \
            _IntKeyType_ Get(void) { return (_IntKeyType_) CList::Get(); } \
            _IntKeyType_ Get(_IntKeyType_ *pnKey) { return (_IntKeyType_) CList2::Get((UINT_PTR *) pnKey); } \
            _IntKeyType_ PeekHead(void) { return (_IntKeyType_) CList::PeekHead(); } \
            _IntKeyType_ PeekHead(_IntKeyType_ *pnKey) { return (_IntKeyType_) CList2::PeekHead((UINT_PTR *) pnKey); } \
            _IntKeyType_ Iterate(void) { return (_IntKeyType_) CList::Iterate(); } \
            _IntKeyType_ Iterate(_IntKeyType_ *pnKey) { return (_IntKeyType_) CList2::Iterate((UINT_PTR *) pnKey); }


#define HASHED_LIST_DEFAULT_BUCKETS             16

#ifdef ENABLE_HASHED_LIST2

class CHashedList2
{
public:

    CHashedList2(ULONG cBuckets = HASHED_LIST_DEFAULT_BUCKETS, ULONG cInitItemsPerBucket = CLIST_DEFAULT_MAX_ITEMS);
    CHashedList2(CHashedList2 *pSrc);
    ~CHashedList2(void);

    BOOL Insert(UINT nKey, LPVOID pData);

    LPVOID Remove(UINT nKey);
    LPVOID Find(UINT nKey);

    LPVOID Get(void);
    LPVOID Get(UINT *pnKey);

    LPVOID Iterate(UINT *pnKey);
    LPVOID Iterate(void) { UINT n; return Iterate(&n); }

    void Reset(void);
    void Clear(void);

    ULONG GetCount(void) { return m_cEntries; };
    BOOL IsEmpty(void) { return (m_cEntries == 0); };

private:

    ULONG GetHashValue(UINT nKey);

    ULONG       m_cBuckets;
    ULONG       m_cInitItemsPerBucket;
    CList2    **m_aBuckets;
    ULONG       m_cEntries;
    ULONG       m_nCurrBucket;
};

#else // ! ENABLE_HASHED_LIST2

class CHashedList2 : public CList2
{
public:

    CHashedList2(ULONG cBuckets = HASHED_LIST_DEFAULT_BUCKETS, ULONG cInitItemsPerBucket = CLIST_DEFAULT_MAX_ITEMS)
                                     : CList2(cInitItemsPerBucket) { }
    CHashedList2(CHashedList2 *pSrc) : CList2((CList2 *) pSrc) { }

    BOOL Insert(UINT_PTR nKey, LPVOID pData) { return CList2::Append(nKey, pData); }

    LPVOID Get(void) { return CList::Get(); }
    LPVOID Get(UINT_PTR *pnKey) { return CList2::Get(pnKey); }

    LPVOID Iterate(void) { return CList::Iterate(); }
    LPVOID Iterate(UINT_PTR *pnKey) { return CList2::Iterate(pnKey); }
};

#endif // ENABLE_HASHED_LIST2

#define DEFINE_HLIST2(_NewClass_,_PtrItemType_,_IntKeyType_) \
            public: \
            _NewClass_(ULONG cBuckets = HASHED_LIST_DEFAULT_BUCKETS, ULONG cInitItemsPerBucket = CLIST_DEFAULT_MAX_ITEMS) \
                : CHashedList2(cBuckets, cInitItemsPerBucket) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CHashedList2((CHashedList2 *) pSrc) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CHashedList2((CHashedList2 *) &Src) { C_ASSERT(sizeof(_IntKeyType_) == sizeof(UINT)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Insert(_IntKeyType_ nKey, _PtrItemType_ pData) { return CHashedList2::Insert((UINT) nKey, (LPVOID) pData); } \
            _PtrItemType_ Remove(_IntKeyType_ nKey) { return (_PtrItemType_) CHashedList2::Remove((UINT) nKey); } \
            _PtrItemType_ Find(_IntKeyType_ nKey) { return (_PtrItemType_) CHashedList2::Find((UINT) nKey); } \
            _PtrItemType_ Get(_IntKeyType_ *pnKey) { return (_PtrItemType_) CHashedList2::Get((UINT *) pnKey); } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CHashedList2::Iterate(); } \
            _PtrItemType_ Iterate(_IntKeyType_ *pnKey) { return (_PtrItemType_) CHashedList2::Iterate((UINT *) pnKey); }

#define DEFINE_HLIST2_(_NewClass_,_PtrItemType_,_ShortKeyType_) \
            public: \
            _NewClass_(ULONG cBuckets = HASHED_LIST_DEFAULT_BUCKETS, ULONG cInitItemsPerBucket = CLIST_DEFAULT_MAX_ITEMS) \
                : CHashedList2(cBuckets, cInitItemsPerBucket) { C_ASSERT(sizeof(_ShortKeyType_) < sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ *pSrc) : CHashedList2((CHashedList2 *) pSrc) { C_ASSERT(sizeof(_ShortKeyType_) < sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            _NewClass_(_NewClass_ &Src) : CHashedList2((CHashedList2 *) &Src) { C_ASSERT(sizeof(_ShortKeyType_) < sizeof(UINT_PTR)); C_ASSERT(sizeof(_PtrItemType_) == sizeof(LPVOID)); } \
            BOOL Insert(_ShortKeyType_ nKey, _PtrItemType_ pData) { return CHashedList2::Insert((UINT_PTR) nKey, (LPVOID) pData); } \
            _PtrItemType_ Remove(_ShortKeyType_ nKey) { return (_PtrItemType_) CHashedList2::Remove((UINT_PTR) nKey); } \
            _PtrItemType_ Find(_ShortKeyType_ nKey) { return (_PtrItemType_) CHashedList2::Find((UINT_PTR) nKey); } \
            _PtrItemType_ Get(_ShortKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) CHashedList2::Get(&n); *pnKey = (_ShortKeyType_) n; return p; } \
            _PtrItemType_ Iterate(void) { return (_PtrItemType_) CHashedList2::Iterate(); } \
            _PtrItemType_ Iterate(_ShortKeyType_ *pnKey) { UINT_PTR n; _PtrItemType_ p = (_PtrItemType_) CHashedList2::Iterate(&n); *pnKey = (_ShortKeyType_) n; return p; }




typedef LPVOID          BOOL_PTR;
#define TRUE_PTR        ((LPVOID) (UINT_PTR)  1)
#define FALSE_PTR       ((LPVOID) (UINT_PTR) -1)

#define LPVOID_NULL     ((LPVOID) (UINT_PTR) -1)


#endif // _CONTAINED_LIST_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\conflist.h ===
/*
 *	conflist.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CConfDescriptorListContainer.
 *		Instances of this class represent the Conference Descriptor list that is
 *		generated by a call to GCCConferenceQueryRequest.  This class hides most
 *		of the complexity associated with building this list.  It also handles
 *		building the set of conference descriptors used in the
 *		ConferenceQueryResponse PDU	and the conference descriptor list passed 
 *		to the GCC interface.  This class is designed so that a CControlSAP 
 *		object can use it to create	a GCC_CONFERENCE_QUERY_CONFIRM message by 
 *		requesting a pointer to a list of Conference Descriptor pointers from 
 *		it.  Objects of this type only live long enough to service a particular
 *		query request.  After a message	callback has returned or a PDU has been
 *		sent to MCS, the CConfDescriptorListContainer object is deleted.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef _CONFERENCE_DESCRIPTOR_LIST_
#define _CONFERENCE_DESCRIPTOR_LIST_

#include "netaddr.h"

/*
 * This typedef defines the structure used internally by this class to maintain
 * the data associated with an individual conference descriptor.
 */
typedef struct CONF_DESCRIPTOR
{
	CONF_DESCRIPTOR(void);
	~CONF_DESCRIPTOR(void);

	LPSTR					pszNumericConfName;
	LPWSTR					pwszTextConfName;
	LPSTR					pszConfModifier;
	LPWSTR					pwszConfDescription;
	CNetAddrListContainer   *network_address_list;
	BOOL					conference_is_locked;
	BOOL					password_in_the_clear;
}
    CONF_DESCRIPTOR;

/*
 * These typedefs define the Rogue Wave container used to hold the list of 
 * CONF_DESCRIPTOR structures internally and the iterator used for
 * accessing structures in the list.
 */
class CConfDesccriptorList : public CList
{
    DEFINE_CLIST(CConfDesccriptorList, CONF_DESCRIPTOR*)
};


/*
 * Class definition:
 */
class CConfDescriptorListContainer : public CRefCount
{
public:

    CConfDescriptorListContainer(void);
    CConfDescriptorListContainer(PSetOfConferenceDescriptors, PGCCError);

    ~CConfDescriptorListContainer(void);

    GCCError	AddConferenceDescriptorToList(
    						LPSTR					pszNumericConfName,
    						LPWSTR					conference_text_name,
    						LPSTR					pszConfModifier,
    						BOOL					locked_conference,
    						BOOL					password_in_the_clear,
    						LPWSTR					pwszConfDescription,
    						CNetAddrListContainer   *network_address_list);

    GCCError	GetConferenceDescriptorListPDU(PSetOfConferenceDescriptors *);
    void		FreeConferenceDescriptorListPDU(void);

    GCCError	LockConferenceDescriptorList(void);
    void		UnLockConferenceDescriptorList(void);

    void		GetConferenceDescriptorList(PGCCConferenceDescriptor **, UINT *pcDescriptors);

private:

	void		GetConferenceDescriptor(PGCCConferenceDescriptor, CONF_DESCRIPTOR *);

private:

	/*
	 * Instance variables:
	 */
	PGCCConferenceDescriptor	*	m_ppGCCConfDescriptorList;
	PSetOfConferenceDescriptors		m_pSetOfConfDescriptors;
	UINT							m_cDescriptors;
	LPBYTE							m_pDescriptorListMemory;
	CConfDesccriptorList            m_ConfDescriptorList;

	//
	// LONCHANC: m_pNetAddrMemoryPointer points to available space,
	// initially equaling to m_pNetAddrListMemory.
	//
	LPBYTE							m_pNetAddrListMemory;
    LPBYTE                          m_pNetAddrMemoryPointer;
};

/*
 *	Comments explaining the public and private class member functions
 */

/*
 *	CConfDescriptorListContainer ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This is a constructor for the CConfDescriptorListContainer class.  It
 *		initializes instance variables.
 *
 *	Formal Parameters:
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CConfDescriptorListContainer (	PSetOfConferenceDescriptors		conference_list,
 *								PGCCError						gcc_error);
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This is a constructor for the CConfDescriptorListContainer class.  
 *		This constructor builds a list of conference descriptors that can
 *		be passed on to the GCC interface.  This list is built from a set
 *		of conference descriptors which is part of a Query Response PDU.
 *
 *	Formal Parameters:
 *		conference_list		(i) The PDU form of the descriptor list.
 *		gcc_error			(o) Error return parameter.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~CConfDescriptorListContainer ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This is the destructor for the CConfDescriptorListContainer class.  It is
 *		responsible for freeing up any resources allocated during the life of
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		AddConferenceDescriptorToList (
 *								LPSTR					pszNumericConfName,
 *								LPWSTR					conference_text_name,
 *								LPSTR					pszConfModifier,
 *								BOOL					locked_conference,
 *								BOOL					password_in_the_clear,
 *								LPWSTR					pwszConfDescription,
 *								CNetAddrListContainer   *network_address_list);
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to add a single new conference descriptor to the
 *		list of conference descriptors.
 *
 *	Formal Parameters:
 *		conference_numeric_name		(i)	The numeric form of the conference name.
 *		conference_text_name		(i) The text form of the conference name.
 *		pszConfModifier				(i) The conference modifier string.
 *		locked_conference			(i) Flag indicating whether or not the
 *											conference is locked.
 *		password_in_the_clear		(i)	Flag indicating whether the conference 
 *											password is "clear" or is a
 *											"challenge".
 *		pwszConfDescription			(i)	The conference description string.
 *		network_address_list		(i) List of network addresses at the queried
 *											node.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		GetConferenceDescriptorListPDU (
 *								PSetOfConferenceDescriptors	*  conference_list);
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the PDU form of the conference 
 *		descriptor list which is a list of "SetOfConferenceDescriptors"
 *		structures.
 *
 *	Formal Parameters:
 *		conference_list			(o)	The pointer to the list of 
 *										"SetOfConferenceDescriptors" structures
 *										to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeConferenceDescriptorListPDU ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to free up any resources allocated to hold the PDU 
 *		form of the conference descriptor list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		LockConferenceDescriptorList ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the API form of the conference descriptor
 *		list.  The lock count is incremented and the API form of the list
 *		created in preparation for a "GetConferenceDescriptorList" call used to
 *		retrieve the API form of the list.  The memory necessary to hold the
 *		API list is allocated by this routine.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		GCC_NO_ERROR			   -	No error.
 *		GCC_ALLOCATION_FAILURE	   - 	Error creating an object using the "new"
 *											operator or else an	allocation using
 *								   			the memory manager failed.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		GetConferenceDescriptorList (
 *								PGCCConferenceDescriptor **	   conference_list,	
 *								UINT*							number_of_descriptors);
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the API form of the conference 
 *		descriptor list.
 *
 *	Formal Parameters:
 *		conference_list			(o) Pointer to list of GCCConferenceDescriptor
 *										API structures to fill in.
 *		number_of_descriptors	(o) Pointer to the number of descriptors in the
 *										list to fill in.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		UnLockConferenceDescriptorList ();
 *
 *	Public member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeConferenceDescriptorList.  If so, the object will automatically 
 *		delete itself.  If not, any resources allocated to hold the API form
 *		of the decriptor list are freed.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\cmdtar.h ===
/*
 *	cmdtar.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the CommandTarget class.  This
 *		is an abstract base class, meaning that it cannot be directly
 *		instantiated, but rather, exists to be inherited from.  It defines
 *		a set of virtual member functions which will be shared by all classes
 *		that inherit from this one.
 *
 *		These virtual member function can be thought of as a "language" that
 *		is used by CommandTarget objects to communicate with one another
 *		at run-time.  This language contains all "MCS commands" (or just
 *		commands) that are necessary for domain management within an MCS
 *		provider.
 *
 *		The MCS commands that make up this language have a one-to-one
 *		correspondence with the Domain Protocol Data Units (Domain MCSPDUs) that
 *		are defined in T.125.  There are also three additional MCS command that
 *		do not have T.125 counterparts: ChannelLeaveIndication,
 *		TokenReleaseIndication, and MergeDomainIndication.  These are specific
 *		to this implementation, and used for local traffic only (these do NOT
 *		correspond to PDUs that travel over any connection).  See the
 *		description of each command at the end of this interface file to see
 *		what each command does.
 *
 *		The first parameter of all commands is the address of the object
 *		who is sending it (its "this" pointer).  This can be used by the
 *		recipient of the command to track identity of other CommandTargets
 *		in the system.  Since all CommandTarget classes share the same
 *		language, the communication between them is bi-directional.
 *
 *		Any class inheriting from this one that wants to receive and process
 *		a command needs to override the virtual member function corresponding
 *		to that command.  It is only necessary to override those commands that
 *		a given class expects to receive at run-time (for example, the Channel
 *		class would never receive a TokenGrabRequest).
 *
 *		See the description of each class that inherits from this one for a
 *		more complete discussion of how the command language is used.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_COMMANDTARGET_
#define	_COMMANDTARGET_

#include "clists.h"

/*
 *	This enumeration defines the valid types of attachments.  Note that for
 *	most operations, the domain class does not distinguish between user
 *	attachments and MCS connections.  They are both lumped under the term
 *	attachment.  There are, however, a few cases where this identity is
 *	important, so the type is saved as one of the following:
 *
 *	LOCAL_ATTACHMENT
 *		This attachment type refers to a user attachment.
 *	REMOTE_ATTACHMENT
 *		This attachment type refers to an MCS connection (through one or more
 *		transport connections).
 *
 *	Each attachment in the attachment list is identified as one of these two
 *	types.
 */

/*
 *	This is a set of container definitions using templates. All containers
 *	are based on classes in the Rogue Wave Tools.h++ class library.
 *
 *	Each container that is defined here has an associated iterator which is
 *	not explicitly mentioned.  All iterators simply allow the code to walk
 *	through all items in the container in a very efficient manner.
 *
 *	CAttachmentList
 *		This is a dictionary of attachments that are hierarchically below the
 *		current provider.  The key to the dictionary is a pointer to an object
 *		of class CommandTarget.  The value is the attachment type, which is
 *		either local (for user attachments), or remote (for MCS connections).
 *	CChannelIDList
 *		This is a list of channel IDs.  This is used when it is necessary to
 *		keep a list of channels to perform some action on (such as deletion)
 *		that cannot be performed right away.
 *	CUserIDList (aka CUidList)
 *		This is a list of user IDs.  This is for such things as keeping a list
 *		of admitted users in a private channel, and keeping a list of inhibitors
 *		of a token.
 *	CTokenIDList
 *		This is a list of token IDs.  This is used when it is necessary to
 *		keep a list of tokens to perform some action on (such as deletion)
 *		that cannot be performed right away.
 */

/*
 *	These types are used when dealing with MCS channels.
 *
 *	Channel_Type
 *		This type defines the types of channels that are available in MCS.
 *	StaticChannelAttributes
 *		This structure is used to define those attributes that are specific
 *		to static channels.
 *	UserChannelAttributes
 *		This structure is used to define those attributes that are specific
 *		to user channels.
 *	PrivateChannelAttributes
 *		This structure is used to define those attributes that are specific
 *		to private channels.
 *	AssignedChannelAttributes
 *		This structure is used to define those attributes that are specific
 *		to assigned channels.
 *	ChannelAttributes
 *		This structure is used to define the attributes of ANY type of channel.
 *		It contains a channel type, and a union of the above four types.
 *	CChannelAttributesList
 *		This is an S-list of ChannelAttributes structures.
 */
typedef	enum
{
	STATIC_CHANNEL,
	USER_CHANNEL,
	PRIVATE_CHANNEL,
	ASSIGNED_CHANNEL
} Channel_Type;
typedef	Channel_Type *			PChannelType;

typedef	struct
{
	ChannelID			channel_id;
} StaticChannelAttributes;

typedef	struct
{
	DBBoolean			joined;
	UserID				user_id;
} UserChannelAttributes;

typedef	struct
{
	DBBoolean			joined;
	ChannelID			channel_id;
	UserID				channel_manager;
	CUidList           *admitted_list;
} PrivateChannelAttributes;

typedef	struct
{
	ChannelID			channel_id;
} AssignedChannelAttributes;

typedef	struct
{
	Channel_Type		channel_type;
	union
	{
		StaticChannelAttributes		static_channel_attributes;
		UserChannelAttributes		user_channel_attributes;
		PrivateChannelAttributes	private_channel_attributes;
		AssignedChannelAttributes	assigned_channel_attributes;
	} u;
} ChannelAttributes;
typedef	ChannelAttributes *		PChannelAttributes;

class CChannelAttributesList : public CList
{
    DEFINE_CLIST(CChannelAttributesList, PChannelAttributes)
};

/*
 *	These types are used when dealing with MCS tokens.
 *
 *	TokenState
 *		This type specifies which state the token is in at any given time.
 *	GrabbedTokenAttributes
 *		This structure is used to define those attributes that are specific
 *		to grabbed tokens.
 *	InhibitedTokenAttributes
 *		This structure is used to define those attributes that are specific
 *		to inhibited tokens.
 *	GivingTokenAttributes
 *		This structure is used to define those attributes that are specific
 *		to giving tokens.
 *	GivenTokenAttributes
 *		This structure is used to define those attributes that are specific
 *		to given tokens.
 *	TokenAttributes
 *		This structure is used to define the attributes of ANY token.  It
 *		contains a token state, and a union of the above four types.
 *	CTokenAttributesList
 *		This is an S-list of TokenAttributes structures.
 */
typedef	enum
{
	TOKEN_AVAILABLE,
	TOKEN_GRABBED,
	TOKEN_INHIBITED,
	TOKEN_GIVING,
	TOKEN_GIVEN
} TokenState;
typedef	TokenState *			PTokenState;

typedef	struct
{
	TokenID				token_id;
	UserID				grabber;
} GrabbedTokenAttributes;

typedef	struct
{
	TokenID				token_id;
	CUidList           *inhibitors;
} InhibitedTokenAttributes;

typedef	struct
{
	TokenID				token_id;
	UserID				grabber;
	UserID				recipient;
} GivingTokenAttributes;

typedef	struct
{
	TokenID				token_id;
	UserID				recipient;
} GivenTokenAttributes;

typedef	struct
{
	TokenState			token_state;
	union
	{
		GrabbedTokenAttributes		grabbed_token_attributes;
		InhibitedTokenAttributes	inhibited_token_attributes;
		GivingTokenAttributes		giving_token_attributes;
		GivenTokenAttributes		given_token_attributes;
	} u;
} TokenAttributes;
typedef	TokenAttributes *		PTokenAttributes;

class CTokenAttributesList : public CList
{
    DEFINE_CLIST(CTokenAttributesList, PTokenAttributes)
};

/*
 *	The following structure is passed around between CommandTarget
 *	objects representing TokenGive requests and indications.
 */
typedef struct
{
	UserID				uidInitiator;
	TokenID				token_id;
	UserID				receiver_id;
} TokenGiveRecord;
typedef TokenGiveRecord *	PTokenGiveRecord;


/*
 *	These macros define the values used for domain parameters.  The default
 *	numbers are used upon initialization, to provide valid values.  The
 *	minimum and maximum numbers are used during arbitration, to provide a set
 *	of limits that are specific to this implementation.  Note that because
 *	this implementation does not use a table driven approach that requires
 *	up-front allocation of all resources, we do not impose an artificial limit
 *	on resources.  Resources (channels and tokens) will simply be allocated
 *	as-needed until no more can be allocated (or until arbitrated domain
 *	parameters have been reached).
 */
#define	DEFAULT_MAXIMUM_CHANNELS		1024
#define	DEFAULT_MAXIMUM_USERS			1024
#define	DEFAULT_MAXIMUM_TOKENS			1024
#define	DEFAULT_NUMBER_OF_PRIORITIES	3
#define	DEFAULT_NUM_PLUGXPRT_PRIORITIES	1
#define	DEFAULT_MINIMUM_THROUGHPUT		0
#define	DEFAULT_MAXIMUM_DOMAIN_HEIGHT	16
#define	DEFAULT_MAXIMUM_PDU_SIZE		4128
#define	DEFAULT_PROTOCOL_VERSION		2

#define	MINIMUM_MAXIMUM_CHANNELS		1
#define	MINIMUM_MAXIMUM_USERS			1
#define	MINIMUM_MAXIMUM_TOKENS			1
#define	MINIMUM_NUMBER_OF_PRIORITIES	1
#define	MINIMUM_NUM_PLUGXPRT_PRIORITIES	1
#define	MINIMUM_MINIMUM_THROUGHPUT		0
#define	MINIMUM_MAXIMUM_DOMAIN_HEIGHT	1
#define	MINIMUM_MAXIMUM_PDU_SIZE		1056
#define	MINIMUM_PROTOCOL_VERSION		2

#define	MAXIMUM_MAXIMUM_CHANNELS		65535L
#define	MAXIMUM_MAXIMUM_USERS			64535L
#define	MAXIMUM_MAXIMUM_TOKENS			65535L
#define	MAXIMUM_NUMBER_OF_PRIORITIES	4
#define	MAXIMUM_NUM_PLUGXPRT_PRIORITIES	1
#define	MAXIMUM_MINIMUM_THROUGHPUT		0
#define	MAXIMUM_MAXIMUM_DOMAIN_HEIGHT	100 
#define	MAXIMUM_MAXIMUM_PDU_SIZE		(8192 - PROTOCOL_OVERHEAD_X224 - PROTOCOL_OVERHEAD_SECURITY)
#define	MAXIMUM_PROTOCOL_VERSION		2

#define	PROTOCOL_VERSION_BASIC			1
#define	PROTOCOL_VERSION_PACKED			2

/*
 *	This macro is used to determine how many DataPacket objects to allocate.  This class
 *	is the most often created and destroyed during normal CommandTarget
 *	traffic.
 */
#define	ALLOCATE_DATA_PACKET_OBJECTS	128

/*
 *	~CommandTarget ()
 *
 *	Functional Description:
 *		This is a virtual destructor.  It does not actually do anything in this
 *		class.  By declaring it as virtual, we guarantee that all destructors
 *		in derived classes will be executed properly.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	PlumbDomainIndication (
 *					PCommandTarget		originator,
 *					ULong				height_limit)
 *
 *	Functional Description:
 *		This MCS command is used to insure that a cycle has not been created
 *		in an MCS domain.  It is broadcast downward after the creation of
 *		a new MCS connection.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		height_limit (i)
 *			This is the height limit from the originating domain downward.
 *			It is decremented each time the PDU is forwarded down another
 *			level.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ErectDomainRequest (
 *					PCommandTarget		originator,
 *					ULong				height_in_domain,
 *					ULong				throughput_interval)
 *
 *	Functional Description:
 *		This MCS command is used to communicate information upward to the
 *		Top Provider.  That information consists of the height of the current
 *		provider and the throughput enforcement interval.  Only the former is
 *		supported at this time.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		height_in_domain (i)
 *			This is the height of the originator in the domain.
 *		throughput_interval (i)
 *			This is not currently support, and will always be set to 0.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeChannelsRequest (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This command represents a channel being merged upward.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_channel_list (i)
 *			This is list of attributes structures, each of which contains the
 *			attributes of one channel being merged upward.
 *		purge_channel_list (i)
 *			This is a list of channels that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeChannelsConfirm (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This command represents the response to a previous request for a
 *		channel to be merged upward.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_channel_list (i)
 *			This is list of attributes structures, each of which contains the
 *			attributes of one channel that was successfully merged upward.
 *		purge_channel_list (i)
 *			This is a list of channels that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	PurgeChannelsIndication (
 *					PCommandTarget		originator,
 *					CUidList           *purge_user_list,
 *					CChannelIDList     *purge_channel_list)
 *
 *	Functional Description:
 *		This command represents a channel being purged from a lower domain
 *		during a merge operation.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		purge_user_list (i)
 *			This is a list of user IDs representing users being purged from
 *			the lower domain during a merge operation.
 *		purge_channel_list (i)
 *			This is a list of channel IDs representing channels being purged
 *			from the lower domain during a merge operation.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeTokensRequest (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This command represents a token being merged upward.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_token_list (i)
 *			This is list of attributes structures, each of which contains the
 *			attributes of one token being merged upward.
 *		purge_token_list (i)
 *			This is a list of tokens that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeTokensConfirm (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This command represents the response to a previous request for a
 *		token merge.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_token_list (i)
 *			This is list of attributes structures, each of which contains the
 *			attributes of one token being merged upward.
 *		purge_token_list (i)
 *			This is a list of tokens that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	PurgeTokensIndication (
 *					PCommandTarget			originator,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This command represents a token being purged from the lower domain
 *		during a merge operation.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		purge_token_list (i)
 *			This is a list of tokens that are to purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DisconnectProviderUltimatum (
 *					PCommandTarget		originator,
 *					Reason				reason)
 *
 *	Functional Description:
 *		This command represents an attachment into a domain being destroyed.
 *		This can be either a user attachment or an MCS connection.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		reason (i)
 *			The reason for the diconnect.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	RejectUltimatum (
 *					PCommandTarget		originator,
 *					Diagnostic			diagnostic,
 *					PUChar				octet_string_address,
 *					ULong				octet_string_length)
 *
 *	Functional Description:
 *		This MCS command is used to indicate illegal traffic on an MCS
 *		connection.  The default response to this message is to disconnect
 *		the connection that conveyed it.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		diagnostic (i)
 *			One of the diagnostic codes elaborating on the cause of the problem.
 *		octet_string_address (i)
 *			The address of an optional user data field.  This will usually
 *			contain a copy of the packet that was received in error.
 *		octet_string_length (i)
 *			Length of the above field.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	AttachUserRequest (
 *					PCommandTarget		originator)
 *
 *	Functional Description:
 *		This command represents a user request to attach to a domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	AttachUserConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command represents the result of a previous request to attach
 *		to a domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the attach request.
 *		uidInitiator (i)
 *			If the result was successful, this will contain the unique user
 *			ID to be associated with this user.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DetachUserRequest (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents a request to detach from a domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		reason (i)
 *			This is the reason for the detachment.
 *		user_id_list (i)
 *			A list of user IDs of users who are detaching from the domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DetachUserIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents a notification that a user has detached from
 *		the domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		reason (i)
 *			The reason for the detachment.
 *		user_id_list (i)
 *			A list of user IDs of users who are detaching from the domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelJoinRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents a request to join a channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user who initiated the request.
 *		channel_id (i)
 *			The ID of the channel to be joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelJoinConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			requested_id,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to join a
 *		channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the join request.
 *		uidInitiator (i)
 *			The ID of the user who initiated the request.
 *		requested_id (i)
 *			This is the ID of the channel that was originally requested (which
 *			may be 0).
 *		channel_id (i)
 *			The ID of the channel being joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelLeaveRequest (
 *					PCommandTarget		originator,
 *					CChannelIDList     *channel_id_list)
 *
 *	Functional Description:
 *		This command represents a request to leave a channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id_list (i)
 *			A list of channel IDs to be left.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelConveneRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command represents a request to form a new private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This is the initiator of the request.  If the request is
 *			successful, this wil be the channel manager.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelConveneConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to create a
 *		new private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			This indicates whether or not the request was successful.
 *		uidInitiator (i)
 *			This is the User ID of the user who requested the creation of the
 *			new private channel.
 *		channel_id (i)
 *			The ID of the new private channel (if the request was successful).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelDisbandRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents a request to destroy an existing private
 *		channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This is the User ID of the user who is trying to destroy the private
 *			channel.  If this is not the same as the channel manager, the
 *			request will be denied.
 *		channel_id (i)
 *			The ID of the channel to be destroyed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelDisbandIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command represents the destruction of an existing private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id (i)
 *			The ID of the channel to be destroyed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelAdmitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents a request to add new user IDs to an existing
 *		private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This is the User ID of the user that is trying to expand the list
 *			of authorized users.  If this is not the channel manager, the
 *			request will fail.
 *		channel_id (i)
 *			The ID of the private channel to be affected.
 *		user_id_list (i)
 *			This is a container holding the User IDs to be added to the
 *			authorized user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelAdmitIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents the expansion of the authorized user list for a
 *		private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This identifies the channel manager.
 *		channel_id (i)
 *			The ID of the private channel to be affected.
 *		user_id_list (i)
 *			This is a container holding the User IDs to be added to the
 *			authorized user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelExpelRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents a request to remove user IDs from an existing
 *		private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			This is the User ID of the user that is trying to shrink the list
 *			of authorized users.  If this is not the channel manager, the
 *			request will fail.
 *		channel_id (i)
 *			The ID of the private channel to be affected.
 *		user_id_list (i)
 *			This is a container holding the User IDs to be removed from the
 *			authorized user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelExpelIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command represents the shrinkage of the authorized user list for a
 *		private channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id (i)
 *			The ID of the private channel to be affected.
 *		user_id_list (i)
 *			This is a container holding the User IDs to be removed from the
 *			authorized user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataRequest (
 *					PCommandTarget		originator,
 *					UINT				type,
					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command represents non-uniform data travelling upward in the
 *		domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		type (i)
 *			Normal or uniform send data request
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataIndication (
 *					PCommandTarget		originator,
 *					UINT				type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command represents non-uniform data travelling downward in the
 *		domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		type (i)
 *			normal or uniform data indication
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	UniformSendDataRequest (
 *					PCommandTarget		originator,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command represents uniform data travelling upward in the domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to grab a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user attempting to grab the token.
 *		token_id (i)
 *			The ID of the token being grabbed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to grab a
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the grab operation.
 *		uidInitiator (i)
 *			The ID of the user attempting to grab the token.
 *		token_id (i)
 *			The ID of the token being grabbed.
 *		token_status (i)
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenInhibitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to inhibit a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user attempting to inhibit the token.
 *		token_id (i)
 *			The ID of the token being inhibited.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenInhibitConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to inhibit a
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the inhibit operation.
 *		uidInitiator (i)
 *			The ID of the user attempting to inhibit the token.
 *		token_id (i)
 *			The ID of the token being inhibited.
 *		token_status (i)
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveRequest (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command represents a request to give a token to another user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveIndication (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command represents notification that a user is trying to give a
 *		token to someone else.  It is issued by the Top Provider and propagates
 *		downward to the recipient.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveResponse (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				receiver_id,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a response to an offer to give away a token.
 *		It is issued by the recipient of a give offer, and moves upward to
 *		the Top Provider.  It contains the result of the give request.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			This parameter indicates whether or not the token was accepted.
 *			RESULT_SUCCESSFUL means that it was.
 *		receiver_id (i)
 *			The ID of the user that the token is being given to.
 *		token_id (i)
 *			The ID of the token being given.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous call to
 *		TokenGiveRequest.  It flows downward to the original giver letting it
 *		know whether or not the token was accepted.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			This parameter indicates whether or not the token was accepted.
 *			RESULT_SUCCESSFUL means that it was.
 *		uidInitiator (i)
 *			The ID of the user attempting to give away a token.
 *		token_id (i)
 *			The ID of the token being given.
 *		token_status (i)
 *			The status of the token as a result of the give operation.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenPleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to receive a token that is already
 *		owned by one or more other users.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user that wishes to own the token.
 *		token_id (i)
 *			The ID of the token that the user wishes to own.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenPleaseIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request by another user to own the token.
 *		This is issued by the Top Provider and flows downward to all current
 *		owners of the specified token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user that wishes to own the token.
 *		token_id (i)
 *			The ID of the token that the user wishes to own.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to release a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user attempting to release the token.
 *		token_id (i)
 *			The ID of the token being released.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents an indication that a user has lost ownership
 *		of a token during a merge operation.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		reason (i)
 *			This is the reason that the user's ownership of the token is
 *			being taken away.
 *		token_id (i)
 *			The ID of the token being taken away.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to release a
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		result (i)
 *			The result of the release operation.
 *		uidInitiator (i)
 *			The ID of the user attempting to release the token.
 *		token_id (i)
 *			The ID of the token being released.
 *		token_status (i)
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenTestRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command represents a request to test a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user testing the token.
 *		token_id (i)
 *			The ID of the token being tested.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenTestConfirm (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command represents a response to a previous request to test a
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator (i)
 *			The ID of the user testing the token.
 *		token_id (i)
 *			The ID of the token being tested.
 *		token_status (i)
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeDomainIndication (
 *					PCommandTarget		originator,
 *					MergeStatus			merge_status)
 *
 *	Functional Description:
 *		This command indicates that the local provider is either entering or
 *		leaving a domain merge state.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		merge_status (i)
 *			This indicates whether the provider is entering or leaving the merge
 *			state.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		When issued by a domain, it means that no upward traffic should be
 *		sent to the domain until, the merge state is complete.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\connect.h ===
/*
 *	connect.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Connection class.  Instances of
 *		this class are used to connect CommandTarget objects within the local
 *		provider to CommandTarget objects in a remote provider.  This class
 *		inherits from CommandTarget, allowing it to communicate with other
 *		CommandTarget classes using their common MCS command language.
 *
 *		This class can be thought of as providing a Remote Procedure Call (RPC)
 *		facility between CommandTarget objects.  When an MCS command is sent
 *		to a Connection object, it encodes the command as a T.125 Protocol
 *		Data Unit (PDU) and sends it to a remote provider via the transport
 *		services provided by a TransportInterface object.  At the remote side
 *		The PDU is received by a Connection object who decodes the PDU, and
 *		issues the equivalent MCS command to the CommandTarget object that it is
 *		attached to.  The fact that the call crossed a transport connection
 *		in route to its destination is completely transparent to the object
 *		that initiated the command sequence.
 *
 *		The primary responsibility of this class is to convert MCS commands
 *		to T.125 PDUs and back again (as described above).  This class overrides
 *		all of the commands that are defined in class CommandTarget.
 *
 *		A secondary responsibility of this class is to provide flow control
 *		to and from the transport layer.  To do this is keeps a queue of PDUs
 *		that need to be transmitted (actually it keeps 4 queues, one for each
 *		data priority).  During each MCS heartbeat, all Connection objects are
 *		given the opportunity to flush PDUs from the queues.  If the transport
 *		layer returns an error, the PDU in question will be re-tried during
 *		the next heartbeat.  For data coming from the transport layer, this
 *		class provides code to allocate memory.  If an allocation fails, then
 *		an error will be returned to the transport layer, effectively telling
 *		it that it needs to retry that data indication during the next
 *		heartbeat.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_CONNECTION_
#define	_CONNECTION_

/*
 *	These are the owner callback functions that a Connection object can send to
 *	its creator (which is typically the MCS controller).
 *
 *	When a class uses an instance of the Connection class (or any other class
 *	that can issue owner callbacks), it is accepting the responsibility of
 *	receiving and handling these callbacks.
 *
 *	Each owner callback function, along with a description of how its parameters
 *	are packed, is described in the following section.
 */
#define	DELETE_CONNECTION						0
#define	CONNECT_PROVIDER_CONFIRM				1

typedef	struct
{
	PDomainParameters	domain_parameters;
	Result				result;
	PMemory				memory;
} ConnectConfirmInfo;
typedef	ConnectConfirmInfo *		PConnectConfirmInfo;

/*
 *	Owner Callback:	DELETE_CONNECTION
 *	Parameter1:		PDisconnectProviderIndication
 *											disconnect_provider_indication
 *	Parameter2:		Unused
 *
 *	Usage:
 *		This owner callback will be issued if the Connection detects a situation
 *		is which it is no longer valid.  This can happen for several reasons:
 *		transmission or reception of a ConnectResult with a failed result
 *		code; transmission or reception of a DisconnectProviderUltimatum; or
 *		a Disconnect-Indication from the transport layer.
 */

/*
 *	Owner Callback:	CONNECT_PROVIDER_CONFIRM
 *	Parameter1:		PConnectConfirmInfo		connect_confirm_info
 *	Parameter2:		ConnectionHandle		connection_handle
 *
 *	Usage:
 *		This callback is issued when the connection object completes the
 *		building of a new MCS connection that was locally requested.  This is to
 *		inform the requester that the connection is ready for use.
 */

/*
 *	This enumeration dsefines the various states that a transport connection
 *	can be in at any given time.
 */
typedef	enum
{
	TRANSPORT_CONNECTION_UNASSIGNED,
	TRANSPORT_CONNECTION_PENDING,
	TRANSPORT_CONNECTION_READY
} TransportConnectionState;
typedef	TransportConnectionState *	PTransportConnectionState;


/*
 *	This is the class definition for class CommandTarget.
 */
class Connection : public CAttachment
{
public:

	Connection (
				PDomain				attachment,
				ConnectionHandle	connection_handle,
				GCCConfID          *calling_domain,
				GCCConfID          *called_domain,
				PChar				called_address,
				BOOL				fSecure,
				BOOL    			upward_connection,
				PDomainParameters	domain_parameters,
				PUChar				user_data,
				ULong				user_data_length,
				PMCSError			connection_error);
		Connection (
				PDomain				attachment,
				ConnectionHandle	connection_handle,
				TransportConnection	transport_connection,
				BOOL    			upward_connection,
				PDomainParameters	domain_parameters,
				PDomainParameters	min_domain_parameters,
				PDomainParameters	max_domain_parameters,
				PUChar				user_data,
				ULong				user_data_length,
				PMCSError			connection_error);
		~Connection ();

    void		RegisterTransportConnection (
				TransportConnection	transport_connection,
				Priority			priority);

private:

		Void		ConnectInitial (
							GCCConfID          *calling_domain,
							GCCConfID          *called_domain,
							BOOL    			upward_connection,
							PDomainParameters	domain_parameters,
							PDomainParameters	min_domain_parameters,
							PDomainParameters	max_domain_parameters,
							PUChar				user_data,
							ULong				user_data_length);
		Void		ConnectResponse (
							Result				result,
							PDomainParameters	domain_parameters,
							ConnectID			connect_id,
							PUChar				user_data,
							ULong				user_data_length);
		Void		ConnectAdditional (
							ConnectID			connect_id,
							Priority			priority);
		Void		ConnectResult (
							Result				result,
							Priority			priority);
		ULong		ProcessConnectResponse (
							PConnectResponsePDU	pdu_structure);
		Void		ProcessConnectResult (
							PConnectResultPDU	pdu_structure);
		Void		IssueConnectProviderConfirm (
							Result				result);
		Void		DestroyConnection (
							Reason				reason);
		Void		AssignRemainingTransportConnections ();
    TransportError	CreateTransportConnection (
							LPCTSTR				called_address,
							BOOL				fSecure,
							Priority			priority);
    TransportError	AcceptTransportConnection (
							TransportConnection	transport_connection,
							Priority			priority);
		Void		AdjustDomainParameters (
							PDomainParameters	min_domain_parameters,
							PDomainParameters	max_domain_parameters,
							PDomainParameters	domain_parameters);
		BOOL    	MergeDomainParameters (
							PDomainParameters	min_domain_parameters1,
							PDomainParameters	max_domain_parameters1,
							PDomainParameters	min_domain_parameters2,
							PDomainParameters	max_domain_parameters2);
#ifdef DEBUG
		Void		PrintDomainParameters (
							PDomainParameters	domain_parameters);
#endif // DEBUG

public:

		inline TransportConnection GetTransportConnection (UInt priority)
		{
			return (Transport_Connection[priority]);
		}

		virtual Void		PlumbDomainIndication (
									ULong				height_limit);
		Void		ErectDomainRequest (
									UINT_PTR				height_in_domain,
									ULong				throughput_interval);
		Void		RejectUltimatum (
									Diagnostic			diagnostic,
									PUChar				octet_string_address,
									ULong				octet_string_length);
		Void		MergeChannelsRequest (
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
		Void		MergeChannelsConfirm (
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
		virtual	Void		PurgeChannelsIndication (
									CUidList           *purge_user_list,
									CChannelIDList     *purge_channel_list);
		Void		MergeTokensRequest (
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
		Void		MergeTokensConfirm (
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
		virtual	Void		PurgeTokensIndication (
									PDomain             originator,
									CTokenIDList       *purge_token_ids);
		virtual	Void		DisconnectProviderUltimatum (
									Reason				reason);
		Void		AttachUserRequest ( void );
		virtual	Void		AttachUserConfirm (
									Result				result,
									UserID				uidInitiator);
		Void		DetachUserRequest (
									Reason				reason,
									CUidList           *user_id_list);
		virtual	Void		DetachUserIndication (
									Reason				reason,
									CUidList           *user_id_list);
		Void		ChannelJoinRequest (
									UserID				uidInitiator,
									ChannelID			channel_id);
		virtual	Void		ChannelJoinConfirm (
									Result				result,
									UserID				uidInitiator,
									ChannelID			requested_id,
									ChannelID			channel_id);
		Void		ChannelLeaveRequest (
									CChannelIDList     *channel_id_list);
		Void		ChannelConveneRequest (
									UserID				uidInitiator);
		virtual	Void		ChannelConveneConfirm (
									Result				result,
									UserID				uidInitiator,
									ChannelID			channel_id);
		Void		ChannelDisbandRequest (
									UserID				uidInitiator,
									ChannelID			channel_id);
		virtual	Void		ChannelDisbandIndication (
									ChannelID			channel_id);
		Void		ChannelAdmitRequest (
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
		virtual	Void		ChannelAdmitIndication (
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
		Void		ChannelExpelRequest (
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
		virtual	Void		ChannelExpelIndication (
									ChannelID			channel_id,
									CUidList           *user_id_list);
		Void		SendDataRequest ( PDataPacket data_packet )
					{
						QueueForTransmission ((PSimplePacket) data_packet,
											  data_packet->GetPriority());
					};
		virtual	Void		SendDataIndication (
									UINT,
									PDataPacket			data_packet)
								{
									QueueForTransmission ((PSimplePacket) data_packet, 
														  data_packet->GetPriority());
								};
		Void		TokenGrabRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual	Void		TokenGrabConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenInhibitRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual	Void		TokenInhibitConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenGiveRequest (
									PTokenGiveRecord	pTokenGiveRec);
		virtual Void		TokenGiveIndication (
									PTokenGiveRecord	pTokenGiveRec);
		Void		TokenGiveResponse (
									Result				result,
									UserID				receiver_id,
									TokenID				token_id);
		virtual Void		TokenGiveConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenReleaseRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual	Void		TokenReleaseConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenPleaseRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual Void		TokenPleaseIndication (
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenTestRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		virtual	Void		TokenTestConfirm (
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		virtual	Void		MergeDomainIndication (
									MergeStatus			merge_status);

private:

	Void		SendPacket (
						PVoid				pdu_structure,
						int					pdu_type,
						Priority			priority);
	Void		QueueForTransmission (
						PSimplePacket		packet,
						Priority			priority,
						BOOL    			bFlush = TRUE);
	BOOL    	FlushAMessage (
						PSimplePacket		packet,
						Priority			priority);
	Void		MergeChannelsRC (
						ASN1choice_t		choice,
						CChannelAttributesList *merge_channel_list,
						CChannelIDList         *purge_channel_list);
	Void		MergeTokensRC (
						ASN1choice_t		choice,
						CTokenAttributesList   *merge_token_list,
						CTokenIDList           *purge_token_list);
	Void		UserChannelRI (
						ASN1choice_t		choice,
						UINT				reason_userID,
						ChannelID			channel_id,
						CUidList           *user_id_list);

public:

	BOOL    	FlushMessageQueue();
	BOOL    	FlushPriority (
						Priority				priority);
	BOOL    	IsDomainTrafficAllowed() { return Domain_Traffic_Allowed; };

public:

    // the old owner callback
    TransportError  HandleDataIndication(PTransportData, TransportConnection);
    void            HandleBufferEmptyIndication(TransportConnection transport_connection);
    void            HandleConnectConfirm(TransportConnection transport_connection);
    void            HandleDisconnectIndication(TransportConnection transport_connection, ULONG *pnNotify);

    LPSTR       GetCalledAddress(void) { return m_pszCalledAddress; }

private:

	inline ULong	ProcessMergeChannelsRequest (
						PMergeChannelsRequestPDU	pdu_structure);
	inline ULong	ProcessMergeChannelsConfirm (
						PMergeChannelsConfirmPDU	pdu_structure);
	inline Void		ProcessPurgeChannelIndication (
						PPurgeChannelIndicationPDU	pdu_structure);
	inline ULong	ProcessMergeTokensRequest (
						PMergeTokensRequestPDU		pdu_structure);
	inline ULong	ProcessMergeTokensConfirm (
						PMergeTokensConfirmPDU		pdu_structure);
	inline Void		ProcessPurgeTokenIndication (
						PPurgeTokenIndicationPDU	pdu_structure);
	inline Void		ProcessDisconnectProviderUltimatum (
						PDisconnectProviderUltimatumPDU
													pdu_structure);
	inline Void		ProcessAttachUserRequest (
						PAttachUserRequestPDU		pdu_structure);
	inline Void		ProcessAttachUserConfirm (
						PAttachUserConfirmPDU		pdu_structure);
	inline Void		ProcessDetachUserRequest (
						PDetachUserRequestPDU		pdu_structure);
	inline Void		ProcessDetachUserIndication (
						PDetachUserIndicationPDU	pdu_structure);
	inline Void		ProcessChannelJoinRequest (
						PChannelJoinRequestPDU		pdu_structure);
	inline Void		ProcessChannelJoinConfirm (
						PChannelJoinConfirmPDU		pdu_structure);
	inline Void		ProcessChannelLeaveRequest (
						PChannelLeaveRequestPDU		pdu_structure);
	inline Void		ProcessChannelConveneRequest (
						PChannelConveneRequestPDU	pdu_structure);
	inline Void		ProcessChannelConveneConfirm (
						PChannelConveneConfirmPDU	pdu_structure);
	inline Void		ProcessChannelDisbandRequest (
						PChannelDisbandRequestPDU	pdu_structure);
	inline Void		ProcessChannelDisbandIndication (
						PChannelDisbandIndicationPDU
													pdu_structure);
	inline Void		ProcessChannelAdmitRequest (
						PChannelAdmitRequestPDU		pdu_structure);
	inline Void		ProcessChannelAdmitIndication (
						PChannelAdmitIndicationPDU	pdu_structure);
	inline Void		ProcessChannelExpelRequest (
						PChannelExpelRequestPDU		pdu_structure);
	inline Void		ProcessChannelExpelIndication (
						PChannelExpelIndicationPDU	pdu_structure);
	inline Void		ProcessSendDataRequest (
						PSendDataRequestPDU			pdu_structure,
						PDataPacket					packet);
	inline Void		ProcessSendDataIndication (
						PSendDataIndicationPDU		pdu_structure,
						PDataPacket					packet);
	inline Void		ProcessUniformSendDataRequest (
						PUniformSendDataRequestPDU	pdu_structure,
						PDataPacket					packet);
	inline Void		ProcessUniformSendDataIndication (
						PUniformSendDataIndicationPDU
													pdu_structure,
						PDataPacket					packet);
	inline Void		ProcessTokenGrabRequest (
						PTokenGrabRequestPDU		pdu_structure);
	inline Void		ProcessTokenGrabConfirm (
						PTokenGrabConfirmPDU		pdu_structure);
	inline Void		ProcessTokenInhibitRequest (
						PTokenInhibitRequestPDU		pdu_structure);
	inline Void		ProcessTokenInhibitConfirm (
						PTokenInhibitConfirmPDU		pdu_structure);
	inline Void		ProcessTokenReleaseRequest (
						PTokenReleaseRequestPDU		pdu_structure);
	inline Void		ProcessTokenReleaseConfirm (
						PTokenReleaseConfirmPDU		pdu_structure);
	inline Void		ProcessTokenTestRequest (
						PTokenTestRequestPDU		pdu_structure);
	inline Void		ProcessTokenTestConfirm (
						PTokenTestConfirmPDU		pdu_structure);
	inline Void		ProcessRejectUltimatum (
						PRejectUltimatumPDU			pdu_structure);
	inline Void		ProcessTokenGiveRequest (
						PTokenGiveRequestPDU		pdu_structure);
	inline Void		ProcessTokenGiveIndication (
						PTokenGiveIndicationPDU		pdu_structure);
	inline Void		ProcessTokenGiveResponse (
						PTokenGiveResponsePDU		pdu_structure);
	inline Void		ProcessTokenGiveConfirm (
						PTokenGiveConfirmPDU		pdu_structure);
	inline Void		ProcessTokenPleaseRequest (
						PTokenPleaseRequestPDU		pdu_structure);
	inline Void		ProcessTokenPleaseIndication (
						PTokenPleaseIndicationPDU	pdu_structure);
	inline Void		ProcessPlumbDomainIndication (
						PPlumbDomainIndicationPDU	pdu_structure);
	inline Void		ProcessErectDomainRequest (
						PErectDomainRequestPDU		pdu_structure);
	inline ULong 	ValidateConnectionRequest ();

private:

    LPSTR               m_pszCalledAddress;
	UINT        		Encoding_Rules;
	PDomain				m_pDomain;
	PDomain				m_pPendingDomain;
	ConnectionHandle	Connection_Handle;
	DomainParameters	Domain_Parameters;
	PMemory				Connect_Response_Memory;

	TransportConnection	Transport_Connection[MAXIMUM_PRIORITIES];
	int					Transport_Connection_PDU_Type[MAXIMUM_PRIORITIES];
	TransportConnectionState
						Transport_Connection_State[MAXIMUM_PRIORITIES];
	UINT				Transport_Connection_Count;
	CSimplePktQueue		m_OutPktQueue[MAXIMUM_PRIORITIES];

	Reason				Deletion_Reason;
	
	BOOL				Upward_Connection;
	BOOL				m_fSecure;
	BOOL    			Merge_In_Progress;
	BOOL    			Domain_Traffic_Allowed;
	BOOL    			Connect_Provider_Confirm_Pending;
};

/*
 *	ULong	ProcessMergeChannelsRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "MergeChannelsRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline ULong Connection::ProcessMergeChannelsRequest ( 
									PMergeChannelsRequestPDU	pdu_structure)
{
	PChannelAttributes			channel_attributes;
	PSetOfChannelIDs			channel_ids;
	PSetOfUserIDs				user_ids;
	CUidList					admitted_list;
	CChannelAttributesList		merge_channel_list;
	CChannelIDList				purge_channel_list;
	PSetOfPDUChannelAttributes	merge_channels;
	BOOL    					first_set = TRUE;

	/*
	 *	Retrieve values from the decoded PDU structure and fill in the
	 *	parameters lists to be passed into the domain.
	 */
	merge_channels = pdu_structure->merge_channels;
	while (merge_channels != NULL)
	{
		DBG_SAVE_FILE_LINE
		channel_attributes = new ChannelAttributes;

		/*
		 *	Check to make to sure the memory allocation has succeeded.  If
		 *	the memory allocation fails we just return an error code which
		 *	results in the PDU being rejected so that it may be tried again
		 *	at a later time.  If subsequent allocations fail, we must first
		 *	free the memory for the successful allocations and then return.
		 */
		if (channel_attributes == NULL)
		{
			if (first_set)
				return (TRANSPORT_READ_QUEUE_FULL);
			else
			{
				while (NULL != (channel_attributes = merge_channel_list.Get()))
				{
					delete channel_attributes;
				}
				return (TRANSPORT_READ_QUEUE_FULL);
			}
		}

		switch (merge_channels->value.choice)
		{
			case CHANNEL_ATTRIBUTES_STATIC_CHOSEN:
				channel_attributes->channel_type = STATIC_CHANNEL;
				channel_attributes->u.static_channel_attributes.channel_id =
						merge_channels->value.u.
						channel_attributes_static.channel_id;
				break;

			case CHANNEL_ATTRIBUTES_USER_ID_CHOSEN:
				channel_attributes->channel_type = USER_CHANNEL;
				channel_attributes->u.user_channel_attributes.joined =
						merge_channels->value.u.
						channel_attributes_user_id.joined;
				channel_attributes->u.user_channel_attributes.user_id =
						(UShort)merge_channels->value.u.
						channel_attributes_user_id.user_id;
				break;

			case CHANNEL_ATTRIBUTES_PRIVATE_CHOSEN:
				channel_attributes->channel_type = PRIVATE_CHANNEL;
				user_ids = merge_channels->value.u.
						channel_attributes_private.admitted;
				channel_attributes->u.private_channel_attributes.joined =
						merge_channels->value.u.
						channel_attributes_private.joined;
				channel_attributes->u.private_channel_attributes.channel_id=
						(UShort)merge_channels->value.u.
						channel_attributes_private.channel_id;
				channel_attributes->u.private_channel_attributes.
						channel_manager = (UShort)merge_channels->
						value.u.channel_attributes_private.manager;

				/*
				 *	Retrieve all of the user ID's from the PDU structure and
				 *	put them into the list to be passed into the domain.
				 */
				while (user_ids != NULL)
				{
					admitted_list.Append(user_ids->value);
					user_ids = user_ids->next;
				}
				channel_attributes->u.private_channel_attributes.
						admitted_list =	&admitted_list;
				break;

			case CHANNEL_ATTRIBUTES_ASSIGNED_CHOSEN:
				channel_attributes->channel_type = ASSIGNED_CHANNEL;
				channel_attributes->u.assigned_channel_attributes.
						channel_id = (UShort)merge_channels->value.u.
						channel_attributes_assigned.channel_id;
				break;

			default:
				ERROR_OUT(("Connection::ProcessMergeChannelsRequest "
						"Bad channel attributes choice."));
				break;
		}
		/*
		 *	Put the channel attributes structure into the list to be passed
		 *	into the domain.  Retrieve the "next" merge channels structure.
		 */
		merge_channel_list.Append(channel_attributes);
		merge_channels = merge_channels->next;
	}

	/*
	 *	Retrieve all of the purge channel ID's from the PDU structure and
	 *	put them into the list to be passed into the domain.
	 */
	channel_ids = pdu_structure->purge_channel_ids;
	while (channel_ids != NULL)
	{
		purge_channel_list.Append(channel_ids->value);
		channel_ids = channel_ids->next;
	}

	m_pDomain->MergeChannelsRequest(this, &merge_channel_list, &purge_channel_list);

	/*
	 *	Free any memory which was allocated for the channel attributes
	 *	structures by setting up an iterator for the list of channel 
	 *	attributes and freeing the memory associated with each pointer.
	 */
	while (NULL != (channel_attributes = merge_channel_list.Get()))
	{
		delete channel_attributes;
	}
	return (TRANSPORT_NO_ERROR);
}

/*
 *	ULong	ProcessMergeChannelsConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "MergeChannelsConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline ULong	Connection::ProcessMergeChannelsConfirm (
									PMergeChannelsConfirmPDU	pdu_structure)
{
	PChannelAttributes			channel_attributes;
	PSetOfChannelIDs			channel_ids;
	PSetOfUserIDs				user_ids;
	CUidList					admitted_list;
	CChannelAttributesList		merge_channel_list;
	CChannelIDList				purge_channel_list;
	PSetOfPDUChannelAttributes	merge_channels;
	BOOL    					first_set = TRUE;

	/*
	 *	Retrieve values from the decoded PDU structure and fill in the
	 *	parameters lists to be passed into the domain.
	 */
	merge_channels = pdu_structure->merge_channels;
	while (merge_channels != NULL)
	{
		DBG_SAVE_FILE_LINE
		channel_attributes = new ChannelAttributes;

		/*
		 *	Check to make to sure the memory allocation has succeeded.  If
		 *	the memory allocation fails we just return an error code which
		 *	results in the PDU being rejected so that it may be tried again
		 *	at a later time.  If subsequent allocations fail, we must first
		 *	free the memory for the successful allocations and then return.
		 */
		if (channel_attributes == NULL)
		{
			if (first_set)
				return (TRANSPORT_READ_QUEUE_FULL);
			else
			{
				while (NULL != (channel_attributes = merge_channel_list.Get()))
				{
					delete channel_attributes;
				}
				return (TRANSPORT_READ_QUEUE_FULL);
			}
		}

		switch (merge_channels->value.choice)
		{
			case CHANNEL_ATTRIBUTES_STATIC_CHOSEN:
					channel_attributes->channel_type = STATIC_CHANNEL;
					channel_attributes->u.static_channel_attributes.channel_id =
							merge_channels->value.u.
							channel_attributes_static.channel_id;
					break;

			case CHANNEL_ATTRIBUTES_USER_ID_CHOSEN:
					channel_attributes->channel_type = USER_CHANNEL;
					channel_attributes->u.user_channel_attributes.joined =
							merge_channels->value.u.
							channel_attributes_user_id.joined;
					channel_attributes->u.user_channel_attributes.user_id =
							(UShort)merge_channels->value.u.
							channel_attributes_user_id.user_id;
					break;

			case CHANNEL_ATTRIBUTES_PRIVATE_CHOSEN:
					channel_attributes->channel_type = PRIVATE_CHANNEL;
					user_ids = merge_channels->value.u.
							channel_attributes_private.admitted;

					channel_attributes->u.private_channel_attributes.joined =
							merge_channels->value.u.
							channel_attributes_private.joined;
					channel_attributes->u.private_channel_attributes.channel_id=
							(UShort)merge_channels->value.u.
							channel_attributes_private.channel_id;
					channel_attributes->u.private_channel_attributes.
							channel_manager = (UShort)merge_channels->
							value.u.channel_attributes_private.manager;

					/*
					 *	Retrieve all of the user ID's from the PDU structure and
					 *	put them into the list to be passed into the domain.
					 */
					while (user_ids != NULL)
					{
						admitted_list.Append(user_ids->value);
						user_ids = user_ids->next;
					}
					channel_attributes->u.private_channel_attributes.
							admitted_list =	&admitted_list;
					break;

			case CHANNEL_ATTRIBUTES_ASSIGNED_CHOSEN:
					channel_attributes->channel_type = ASSIGNED_CHANNEL;
					channel_attributes->u.assigned_channel_attributes.
							channel_id = (UShort)merge_channels->value.u.
							channel_attributes_assigned.channel_id;
					break;

			default:
					ERROR_OUT(("Connection::ProcessMergeChannelsConfirm "
							"Bad channel attributes choice."));
					break;
		}
		/*
		 *	Put the channel attributes structure into the list to be passed
		 *	into the domain.  Retrieve the "next" merge channels structure.
		 */
		merge_channel_list.Append(channel_attributes);
		merge_channels = merge_channels->next;
	}

	/*
	 *	Retrieve all of the purge channel ID's from the PDU structure and
	 *	put them into the list to be passed into the domain.
	 */
	channel_ids = pdu_structure->purge_channel_ids;
	while (channel_ids != NULL)
	{
		purge_channel_list.Append(channel_ids->value);
		channel_ids = channel_ids->next;
	}

	m_pDomain->MergeChannelsConfirm(this, &merge_channel_list, &purge_channel_list);

	/*
	 *	Free any memory which was allocated for the channel attributes
	 *	structures by setting up an iterator for the list of channel 
	 *	attributes and freeing the memory associated with each pointer.
	 */
	while (NULL != (channel_attributes = merge_channel_list.Get()))
	{
		delete channel_attributes;
	}
	return (TRANSPORT_NO_ERROR);
}

/*
 *	Void	ProcessPurgeChannelIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "PurgeChannelsIndication" PDU's being
 *		received through the transport interface.  The pertinent data is read
 *		from the incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessPurgeChannelIndication (
								PPurgeChannelIndicationPDU	 	pdu_structure)
{
	CUidList				purge_user_list;
	CChannelIDList			purge_channel_list;
	PSetOfChannelIDs		channel_ids;
	PSetOfUserIDs	   		user_ids;

	/*
	 *	Retrieve all of the purge user ID's from the PDU structure and put
	 *	them into the list to be passed into the domain.
	 */
	user_ids = pdu_structure->detach_user_ids;

	while (user_ids != NULL)
	{
		purge_user_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	/*
	 *	Retrieve all of the purge channel ID's from the PDU structure and
	 *	put them into the list to be passed into the domain.
	 */
	channel_ids = pdu_structure->purge_channel_ids;
	while (channel_ids != NULL)
	{
		purge_channel_list.Append(channel_ids->value);
		channel_ids = channel_ids->next;
	}

	m_pDomain->PurgeChannelsIndication(this, &purge_user_list, &purge_channel_list);
}

/*
 *	ULong	ProcessMergeTokensRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "MergeTokenRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline ULong	Connection::ProcessMergeTokensRequest (
								PMergeTokensRequestPDU			pdu_structure)
{
	PTokenAttributes			token_attributes;
	PSetOfTokenIDs				token_ids;
	PSetOfUserIDs				user_ids;
	CUidList					inhibited_list;
	CTokenAttributesList		merge_token_list;
	CTokenIDList				purge_token_list;
	PSetOfPDUTokenAttributes	merge_tokens;
	BOOL    					first_set = TRUE;

	/*
 	 *	Retrieve values from the decoded PDU structure and fill in the
 	 *	parameters lists to be passed into the domain.
 	 */
	merge_tokens = pdu_structure->merge_tokens;

	while (merge_tokens != NULL)
	{
		DBG_SAVE_FILE_LINE
		token_attributes = new TokenAttributes;

		/*
		 *	Check to make to sure the memory allocation has succeeded.  If
		 *	the memory allocation fails we just return an error code which
		 *	results in the PDU being rejected so that it may be tried again
		 *	at a later time.  If subsequent allocations fail, we must first
		 *	free the memory for the successful allocations and then return.
		 */
		if (token_attributes == NULL)
		{
			if (first_set)
				return (TRANSPORT_READ_QUEUE_FULL);
			else
			{
				while (NULL != (token_attributes = merge_token_list.Get()))
				{
					delete token_attributes;
				}
				return (TRANSPORT_READ_QUEUE_FULL);
			}
		}

		switch (merge_tokens->value.choice)
		{
			case GRABBED_CHOSEN:
					token_attributes->token_state = TOKEN_GRABBED;
					token_attributes->u.grabbed_token_attributes.token_id =
							(UShort)merge_tokens->value.u.
							grabbed.token_id;
					token_attributes->u.grabbed_token_attributes.grabber =
							(UShort)merge_tokens->
							value.u.grabbed.grabber;
				  break;

			case INHIBITED_CHOSEN:
					token_attributes->token_state = TOKEN_INHIBITED;
					user_ids = merge_tokens->value.u.
							inhibited.inhibitors;

					token_attributes->u.inhibited_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.inhibited.token_id;
					/*
					 *	Retrieve all of the user ID's from the PDU structure and 
					 *	put them into the list to be passed into the domain.
					 */
					while (user_ids != NULL)
					{
						inhibited_list.Append(user_ids->value);
						user_ids= user_ids->next;
					}
					token_attributes->u.inhibited_token_attributes.
							inhibitors = &inhibited_list;
					break;

			case GIVING_CHOSEN:
					token_attributes->token_state = TOKEN_GIVING;
					token_attributes->u.giving_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.giving.token_id;
					token_attributes->u.giving_token_attributes.grabber =
							(UShort)merge_tokens->
							value.u.giving.grabber;
					token_attributes->u.giving_token_attributes.recipient =
							(UShort)merge_tokens->value.u.giving.
							recipient;
					break;

			case GIVEN_CHOSEN:
					token_attributes->token_state = TOKEN_GIVEN;
					token_attributes->u.given_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.given.token_id;
					token_attributes->u.given_token_attributes.recipient =
							(UShort)merge_tokens->
							value.u.given.recipient;
					break;

			default:
					ERROR_OUT(("Connection::ProcessMergeTokensRequest "
							"Bad token attributes choice."));
					break;
		}
		/*
		 *	Put the token attributes structure into the list to be passed
		 *	into the domain.  We are only doing one channel attributes 
		 *	structures at a time for now.
		 */
		merge_token_list.Append(token_attributes);
		merge_tokens = merge_tokens->next;
	}

	/*
	 *	Retrieve all of the purge token ID's from the PDU structure and put
	 *	them into the list to be passed into the domain.
	 */
	token_ids = pdu_structure->purge_token_ids;
	while (token_ids != NULL)
	{
		purge_token_list.Append(token_ids->value);
		token_ids = token_ids->next;
	}

	m_pDomain->MergeTokensRequest(this, &merge_token_list, &purge_token_list);

	/*
	 *	Free any memory which was allocated for the token attributes
	 *	structures by setting up an iterator for the list of token 
	 *	attributes and freeing the memory associated with each pointer.
	 */
	while (NULL != (token_attributes = merge_token_list.Get()))
	{
		delete token_attributes;
	}
	return (TRANSPORT_NO_ERROR);
}

/*
 *	ULong	ProcessMergeTokensConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "MergeTokenConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline ULong	Connection::ProcessMergeTokensConfirm (
								PMergeTokensConfirmPDU			pdu_structure)
{
	PTokenAttributes			token_attributes;
	PSetOfTokenIDs				token_ids;
	PSetOfUserIDs				user_ids;
	CUidList					inhibited_list;
	CTokenAttributesList		merge_token_list;
	CTokenIDList				purge_token_list;
	PSetOfPDUTokenAttributes	merge_tokens;
	BOOL    					first_set = TRUE;

	/*
 	 *	Retrieve values from the decoded PDU structure and fill in the
 	 *	parameters lists to be passed into the domain.
 	 */
	merge_tokens = pdu_structure->merge_tokens;

	while (merge_tokens != NULL)
	{
		DBG_SAVE_FILE_LINE
		token_attributes = new TokenAttributes;

		/*
		 *	Check to make to sure the memory allocation has succeeded.  If
		 *	the memory allocation fails we just return an error code which
		 *	results in the PDU being rejected so that it may be tried again
		 *	at a later time.  If subsequent allocations fail, we must first
		 *	free the memory for the successful allocations and then return.
		 */
		if (token_attributes == NULL)
		{
			if (first_set)
				return (TRANSPORT_READ_QUEUE_FULL);
			else
			{
				while (NULL != (token_attributes = merge_token_list.Get()))
				{
					delete token_attributes;
				}
				return (TRANSPORT_READ_QUEUE_FULL);
			}
		}

		switch (merge_tokens->value.choice)
		{
			case GRABBED_CHOSEN:
					token_attributes->token_state = TOKEN_GRABBED;
					token_attributes->u.grabbed_token_attributes.token_id =
							(UShort)merge_tokens->value.u.
							grabbed.token_id;
					token_attributes->u.grabbed_token_attributes.grabber =
							(UShort)merge_tokens->
							value.u.grabbed.grabber;
				  break;

			case INHIBITED_CHOSEN:
					token_attributes->token_state = TOKEN_INHIBITED;
					user_ids = merge_tokens->value.u.
							inhibited.inhibitors;

					token_attributes->u.inhibited_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.inhibited.token_id;
					/*
					 *	Retrieve all of the user ID's from the PDU structure and 
					 *	put them into the list to be passed into the domain.
					 */
					while (user_ids != NULL)
					{
						inhibited_list.Append(user_ids->value);
						user_ids = user_ids->next;
					}
					token_attributes->u.inhibited_token_attributes.
							inhibitors = &inhibited_list;
					break;

			case GIVING_CHOSEN:
					token_attributes->token_state = TOKEN_GIVING;
					token_attributes->u.giving_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.giving.token_id;
					token_attributes->u.giving_token_attributes.grabber =
							(UShort)merge_tokens->
							value.u.giving.grabber;
					token_attributes->u.giving_token_attributes.recipient =
							(UShort)merge_tokens->value.u.giving.
							recipient;
					break;

			case GIVEN_CHOSEN:
					token_attributes->token_state = TOKEN_GIVEN;
					token_attributes->u.given_token_attributes.token_id =
							(UShort)merge_tokens->
							value.u.given.token_id;
					token_attributes->u.given_token_attributes.recipient =
							(UShort)merge_tokens->
							value.u.given.recipient;
					break;

			default:
					ERROR_OUT(("Connection::ProcessMergeTokensConfirm "
							"Bad token attributes choice."));
					break;
		}
		/*
		 *	Put the token attributes structure into the list to be passed
		 *	into the domain.  We are only doing one channel attributes 
		 *	structures at a time for now.
		 */
		merge_token_list.Append(token_attributes);
		merge_tokens = merge_tokens->next;
	}

	/*
	 *	Retrieve all of the purge token ID's from the PDU structure and put
	 *	them into the list to be passed into the domain.
	 */
	token_ids = pdu_structure->purge_token_ids;
	while (token_ids != NULL)
	{
		purge_token_list.Append(token_ids->value);
		token_ids = token_ids->next;
	}

	m_pDomain->MergeTokensConfirm(this, &merge_token_list, &purge_token_list);

	/*
	 *	Free any memory which was allocated for the token attributes
	 *	structures by setting up an iterator for the list of token 
	 *	attributes and freeing the memory associated with each pointer.
	 */
	while (NULL != (token_attributes = merge_token_list.Get()))
	{
		delete token_attributes;
	}
	return (TRANSPORT_NO_ERROR);
}

/*
 *	Void	ProcessPurgeTokenIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "PurgeTokenIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessPurgeTokenIndication ( 
									PPurgeTokenIndicationPDU	pdu_structure)
{
	PSetOfTokenIDs			token_ids;
	CTokenIDList			purge_token_list;
	
	/*
	 *	Retrieve all of the purge token ID's from the PDU structure and put
	 *	them into the list to be passed into the domain.
	 */
	token_ids = pdu_structure->purge_token_ids;
	while (token_ids != NULL)
	{
		purge_token_list.Append(token_ids->value);
		token_ids = token_ids->next;
	}

	m_pDomain->PurgeTokensIndication(this, &purge_token_list);
}

/*
 *	Void	ProcessDisconnectProviderUltimatum()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "DisconnectProviderUltimatum" PDU's being
 *		received through the transport interface.  The pertinent data is read
 *		from the incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessDisconnectProviderUltimatum (
						PDisconnectProviderUltimatumPDU			pdu_structure)
{
	TRACE_OUT(("Connection::ProcessDisconnectProviderUltimatum: PDU received"));

	m_pDomain->DisconnectProviderUltimatum(this, (Reason)pdu_structure->reason);
	m_pDomain = NULL;
}

/*
 *	Void	ProcessAttachUserRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "AttachUserRequest" PDU's being received
 *		through the transport interface by forwarding the request on to the
 *		domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessAttachUserRequest (PAttachUserRequestPDU)
{
	m_pDomain->AttachUserRequest(this);
}

/*
 *	Void	ProcessAttachUserConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "AttachUserConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessAttachUserConfirm (
							PAttachUserConfirmPDU		pdu_structure)
{
	m_pDomain->AttachUserConfirm(this, (Result) pdu_structure->result,
	                                   (UserID) pdu_structure->initiator);
}

/*
 *	Void	ProcessDetachUserRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "DetachUserRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessDetachUserRequest (
								PDetachUserRequestPDU			pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->DetachUserRequest(this, (Reason) pdu_structure->reason, &user_id_list);
}

/*
 *	Void	ProcessDetachUserIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "DetachUserIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessDetachUserIndication (
									PDetachUserIndicationPDU	pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->DetachUserIndication(this, (Reason) pdu_structure->reason,
                                          &user_id_list);
}

/*
 *	Void	ProcessChannelJoinRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelJoinRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelJoinRequest (
									PChannelJoinRequestPDU		pdu_structure)
{
	m_pDomain->ChannelJoinRequest(this, (UserID) pdu_structure->initiator,
                                        (ChannelID) pdu_structure->channel_id);
}

/*
 *	Void	ProcessChannelJoinConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelJoinConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelJoinConfirm (
									PChannelJoinConfirmPDU		pdu_structure)
{
	m_pDomain->ChannelJoinConfirm(this, (Result) pdu_structure->result,
                                        (UserID) pdu_structure->initiator,
                                        (ChannelID) pdu_structure->requested,
                                        (ChannelID) pdu_structure->join_channel_id);
}

/*
 *	Void	ProcessChannelLeaveRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelLeaveRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelLeaveRequest (
									PChannelLeaveRequestPDU		pdu_structure)
{
	PSetOfChannelIDs		channel_ids;
	CChannelIDList			channel_id_list;

	/*
	 *	Retrieve the channel ID's from the PDU structure and put them into
	 *	the list to be passed into the domain.
	 */
	channel_ids = pdu_structure->channel_ids;
	while (channel_ids != NULL)
	{
		channel_id_list.Append(channel_ids->value);
		channel_ids = channel_ids->next;
	}

	m_pDomain->ChannelLeaveRequest(this, &channel_id_list);
}

/*
 *	Void	ProcessChannelConveneRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelConveneRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelConveneRequest (
									PChannelConveneRequestPDU	pdu_structure)
{
	m_pDomain->ChannelConveneRequest(this, (UserID) pdu_structure->initiator);
}

/*
 *	Void	ProcessChannelConveneConfirm ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelConveneConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelConveneConfirm (
									PChannelConveneConfirmPDU	pdu_structure)
{
	m_pDomain->ChannelConveneConfirm(this, (Result) pdu_structure->result,
                                           (UserID) pdu_structure->initiator,
                                           (ChannelID) pdu_structure->convene_channel_id);
}

/*
 *	Void	ProcessChannelDisbandRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelDisbandRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelDisbandRequest (
									PChannelDisbandRequestPDU	pdu_structure)
{
	m_pDomain->ChannelDisbandRequest(this, (UserID) pdu_structure->initiator,
                                           (ChannelID) pdu_structure->channel_id);
}

/*
 *	Void	ProcessChannelDisbandIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelDisbandIndication" PDU's being
 *		received through the transport interface.  The pertinent data is read
 *		from the incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelDisbandIndication (
								PChannelDisbandIndicationPDU	pdu_structure)
{
	m_pDomain->ChannelDisbandIndication(this, (ChannelID) pdu_structure->channel_id);
}

/*
 *	Void	ProcessChannelAdmitRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelAdmitRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelAdmitRequest (
									PChannelAdmitRequestPDU		pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->ChannelAdmitRequest(this, (UserID) pdu_structure->initiator,
                                         (ChannelID) pdu_structure->channel_id,
                                         &user_id_list);
}

/*
 *	Void	ProcessChannelAdmitIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelAdmitIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelAdmitIndication (
								PChannelAdmitIndicationPDU		pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->ChannelAdmitIndication(this, (UserID) pdu_structure->initiator,
                                            (ChannelID) pdu_structure->channel_id,
                                            &user_id_list);
}

/*
 *	Void	ProcessChannelExpelRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelExpelRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelExpelRequest (
							PChannelExpelRequestPDU				pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->ChannelExpelRequest(this, (UserID) pdu_structure->initiator,
                                         (ChannelID) pdu_structure->channel_id,
                                         &user_id_list);
}

/*
 *	Void	ProcessChannelExpelIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ChannelExpelIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessChannelExpelIndication (
								PChannelExpelIndicationPDU		pdu_structure)
{
	PSetOfUserIDs		user_ids;
	CUidList			user_id_list;

	/*
	 *	Retrieve the user ID's from the PDU structure and put them into the
	 *	list to be passed into the domain.
	 */
	user_ids = pdu_structure->user_ids;
	while (user_ids != NULL)
	{
		user_id_list.Append(user_ids->value);
		user_ids = user_ids->next;
	}

	m_pDomain->ChannelExpelIndication(this, (ChannelID) pdu_structure->channel_id,
                                            &user_id_list);
}

/*
 *	Void	ProcessSendDataRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "SendDataRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessSendDataRequest (
									PSendDataRequestPDU			pdu_structure,
									PDataPacket					packet)
{	
	m_pDomain->SendDataRequest(this, MCS_SEND_DATA_INDICATION, packet);
}

/*
 *	Void	ProcessSendDataIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "SendDataIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessSendDataIndication (
									PSendDataIndicationPDU		pdu_structure,
									PDataPacket					data_packet)
{	
	m_pDomain->SendDataIndication(this, MCS_SEND_DATA_INDICATION, data_packet);
}

/*
 *	Void	ProcessUniformSendDataRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "UniformSendDataRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessUniformSendDataRequest (
									PUniformSendDataRequestPDU	pdu_structure,
									PDataPacket					packet)
{	
	m_pDomain->SendDataRequest(this, MCS_UNIFORM_SEND_DATA_INDICATION, packet);
}

/*
 *	Void	ProcessUniformSendDataIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "UniformSendDataIndication" PDU's being
 *		received through the transport interface.  The pertinent data is read
 *		from the incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessUniformSendDataIndication (
								PUniformSendDataIndicationPDU	pdu_structure,
								PDataPacket						data_packet)
{	
	m_pDomain->SendDataIndication(this, MCS_UNIFORM_SEND_DATA_INDICATION, data_packet);
}

/*
 *	Void	ProcessTokenGrabRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGrabRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGrabRequest (
									PTokenGrabRequestPDU		pdu_structure)
{
	m_pDomain->TokenGrabRequest(this, (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenGrabConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGrabConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGrabConfirm (
									PTokenGrabConfirmPDU		pdu_structure)
{
	m_pDomain->TokenGrabConfirm(this, (Result) pdu_structure->result,
                                      (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id,
                                      (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessTokenInhibitRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenInhibitRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenInhibitRequest (
									PTokenInhibitRequestPDU		pdu_structure)
{
	m_pDomain->TokenInhibitRequest(this, (UserID) pdu_structure->initiator,
                                         (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenInhibitConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenInhibitConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenInhibitConfirm (
									PTokenInhibitConfirmPDU		pdu_structure)
{
	m_pDomain->TokenInhibitConfirm(this, (Result) pdu_structure->result,
                                         (UserID) pdu_structure->initiator,
                                         (TokenID) pdu_structure->token_id,
                                         (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessTokenReleaseRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenReleaseRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenReleaseRequest (
									PTokenReleaseRequestPDU		pdu_structure)
{
	m_pDomain->TokenReleaseRequest(this, (UserID) pdu_structure->initiator,
                                         (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenReleaseConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenReleaseConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenReleaseConfirm (
									PTokenReleaseConfirmPDU		pdu_structure)
{
	m_pDomain->TokenReleaseConfirm(this, (Result) pdu_structure->result,
                                         (UserID) pdu_structure->initiator,
                                         (TokenID) pdu_structure->token_id,
                                         (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessTokenTestRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenTestRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenTestRequest (
									PTokenTestRequestPDU		pdu_structure)
{
	m_pDomain->TokenTestRequest(this, (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenTestConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenTestConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenTestConfirm (
									PTokenTestConfirmPDU		pdu_structure)
{
	m_pDomain->TokenTestConfirm(this, (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id,
                                      (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessRejectUltimatum()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "RejectUltimatum" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessRejectUltimatum (
									PRejectUltimatumPDU			pdu_structure)
{
	m_pDomain->RejectUltimatum(this,
				pdu_structure->diagnostic,
				pdu_structure->initial_octets.value,
				(ULong) pdu_structure->initial_octets.length);
}

/*
 *	Void	ProcessTokenGiveRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGiveRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGiveRequest (
									PTokenGiveRequestPDU		pdu_structure)
{
		TokenGiveRecord		TokenGiveRec;

	// Fill in the TokenGive record
	TokenGiveRec.uidInitiator = pdu_structure->initiator;
	TokenGiveRec.token_id = pdu_structure->token_id;
	TokenGiveRec.receiver_id = pdu_structure->recipient;
	m_pDomain->TokenGiveRequest(this, &TokenGiveRec);
}

/*
 *	Void	ProcessTokenGiveIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGiveIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGiveIndication (
									PTokenGiveIndicationPDU		pdu_structure)
{
		TokenGiveRecord		TokenGiveRec;

	// Fill in the TokenGive record
	TokenGiveRec.uidInitiator = pdu_structure->initiator;
	TokenGiveRec.token_id = pdu_structure->token_id;
	TokenGiveRec.receiver_id = pdu_structure->recipient;
	m_pDomain->TokenGiveIndication(this, &TokenGiveRec);
}

/*
 *	Void	ProcessTokenGiveResponse()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGiveResponse" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGiveResponse (
									PTokenGiveResponsePDU		pdu_structure)
{
	m_pDomain->TokenGiveResponse(this, (Result) pdu_structure->result,
                                       (UserID) pdu_structure->recipient,
                                       (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenGiveConfirm()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenGiveConfirm" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenGiveConfirm (
									PTokenGiveConfirmPDU		pdu_structure)
{
	m_pDomain->TokenGiveConfirm(this, (Result) pdu_structure->result,
                                      (UserID) pdu_structure->initiator,
                                      (TokenID) pdu_structure->token_id,
                                      (TokenStatus)pdu_structure->token_status);
}

/*
 *	Void	ProcessTokenPleaseRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenPleaseRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenPleaseRequest (
									PTokenPleaseRequestPDU		pdu_structure)
{
	m_pDomain->TokenPleaseRequest(this, (UserID) pdu_structure->initiator,
                                        (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessTokenPleaseIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "TokenPleaseIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessTokenPleaseIndication (
									PTokenPleaseIndicationPDU	pdu_structure)
{
	m_pDomain->TokenPleaseIndication(this, (UserID) pdu_structure->initiator,
                                           (TokenID) pdu_structure->token_id);
}

/*
 *	Void	ProcessPlumbDomainIndication()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "PlumbDomainIndication" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessPlumbDomainIndication (
									PPlumbDomainIndicationPDU	pdu_structure)
{
	m_pDomain->PlumbDomainIndication(this, pdu_structure->height_limit);
}

/*
 *	Void	ProcessErectDomainRequest()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ErectDomainRequest" PDU's being received
 *		through the transport interface.  The pertinent data is read from the
 *		incoming packet and passed on to the domain.
 *
 *	Caveats:
 *		None.
 */
inline Void	Connection::ProcessErectDomainRequest (
									PErectDomainRequestPDU		pdu_structure)
{
	m_pDomain->ErectDomainRequest(this, pdu_structure->sub_height,
                                        pdu_structure->sub_interval);
}

/*
 *	ULong	ValidateConnectionRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to determine if it is valid to process an incoming
 *		request at the current time.  It checks several different conditions
 *		to determine this, as follows:
 *
 *		- If there is a merge in progress, then the request is not valid.
 *		- If this MCS connection is not yet bound to a domain, then the request
 *		  is not valid.
 *		- If there are not enough objects of the Memory, Packet, or UserMessage
 *		  class to handle a reasonable request, then the request is not valid.
 *
 *		Note that the check on number of objects is not an absolute guarantee
 *		that there will be enough to handle a given request, because a request
 *		can result in MANY PDUs and user messages being generated.  For example,
 *		a single channel admit request can result in lots of channel admit
 *		indications being sent.  However, checking against a minimum number
 *		of objects can reduce the possibility of failure to be astronomically
 *		low.  And remember, even if MCS runs out of something while processing
 *		such a request, it WILL handle it properly (by cleanly destroying the
 *		user attachment or MCS connection upon which the failure occurred).  So
 *		there is no chance of MCS crashing as a result of this.
 *
 *	Caveats:
 *		None.
 */
inline ULong	Connection::ValidateConnectionRequest ()
{
	ULong				return_value;

	/*
	 *	Check to see if there is a domain merger in progress.
	 */
	if (Merge_In_Progress == FALSE)
	{
		/*
		 *	Make sure that this MCS connection is bound to a domain.
		 */
		if (m_pDomain != NULL)
		{
			/*
			 *	Everything is okay, so the request is to be permitted.
			 */
			return_value = TRANSPORT_NO_ERROR;
		}
		else
		{
			/*
			 *	We are not yet attached to a domain.
			 */
			TRACE_OUT (("Connection::ValidateConnectionRequest: "
					"not attached to a domain"));
			return_value = TRANSPORT_READ_QUEUE_FULL;
		}
	}
	else
	{
		/*
		 *	There is a domain merge in progress.
		 */
		WARNING_OUT (("Connection::ValidateConnectionRequest: "
				"domain merger in progress"));
		return_value = TRANSPORT_READ_QUEUE_FULL;
	}

	return (return_value);
}

/*
 *	Connection (
 *				PCommandTarget		attachment,
 *				ConnectionHandle	connection_handle,
 *				PUChar				calling_domain,
 *				UINT				calling_domain_length,
 *				PUChar				called_domain,
 *				UINT				called_domain_length,
 *				PChar				calling_address,
 *				PChar				called_address,
 *				BOOL    			upward_connection,
 *				PDomainParameters	domain_parameters,
 *				PUChar				user_data,
 *				ULong				user_data_length,
 *				PMCSError			connection_error)
 *
 *	Functional Description:
 *		This is a constructor for the Connection class.  This constructor
 *		is used for creating outbound connections.  It initializes private
 *		instance variables and calls the transport interface to set up a
 *		transport connection and register this connection object (through a
 *		callback structure) with the transport object.
 *
 *	Formal Parameters:
 *		packet_coder
 *			This is the coder which is used by the connection object to encode
 *			PDU's into, and decode PDU's from, ASN.1 compliant byte streams.
 *		attachment
 *			The Domain to which this connection object is attached.
 *		connection_handle
 *			The handle which uniquely identifies this connection object.
 *		owner_object
 *			This is a pointer to the owner of this connection object (typically
 *			the MCS Controller) which allows this connection to communicate with
 *			the owner through callbacks. 
 *		owner_message_base
 *			This is the base value to which offsets are added to identify which
 *			callback routine in the owner object this connection is calling.
 *		calling_domain
 *			This is a pointer to an ASCII string which contains the name of the
 *			domain to which this connection object is attached.
 *		calling_domain_length
 *			The length of the ASCII string which is the name of domain to which
 *			this connection object is attached.
 *		called_domain
 *			This is a pointer to an ASCII string which contains the name of the
 *			remote domain with which this connection will communicate.
 *		called_domain_length
 *			The length of the ASCII string which is the name of the remote
 *			domain.
 *		calling_address
 *			The transport address of the caller.
 *		called_address
 *			The transport address of the party being called.
 *		upward_connection
 *			This is a boolean flag which indicates whether this is an upward
 *			connection or a downward connection.
 *		domain_parameters
 *			This is the set of parameters which describes the local domain.
 *		user_data
 *			This is a pointer to a buffer containing data which is sent to the
 *			remote provider through the "ConnectInitial" PDU.
 *		user_data_length
 *			The length of the user data described above.
 *		connection_error
 *			A return parameter which indicates any errors which may have 
 *			occurred in construction of the connection object.
 *
 *	Return Value:
 *		MCS_NO_ERROR			The connection was created successfully.
 *		MCS_TRANSPORT_FAILED	An error occurred in creating the transport
 *									connection.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Connection (
 *				PCommandTarget		attachment,
 *				ConnectionHandle	connection_handle,
 *				TransportConnection	transport_connection,
 *				BOOL    			upward_connection,
 *				PDomainParameters	domain_parameters,
 *				PDomainParameters	min_domain_parameters,
 *				PDomainParameters	max_domain_parameters,
 *				PUChar				user_data,
 *				ULong				user_data_length,
 *				PMCSError			connection_error)
 *
 *	Functional Description:
 *		This is a constructor for the Connection class.  This constructor is 
 *		used for creating inbound connections and is called when a transport
 *		connection already exists.  It initializes private instance variables
 *		and calls the transport interface to register this connection object 
 *		(through a callback structure) with the transport object.
 *
 *	Formal Parameters:
 *		attachment
 *			The Domain to which this connection object is attached.
 *		connection_handle
 *			The handle which uniquely identifies this connection object.
 *		owner_object
 *			This is a pointer to the owner of this connection object (typically
 *			the MCS Controller) which allows this connection to communicate with
 *			the owner through callbacks. 
 *		owner_message_base
 *			This is the base value to which offsets are added to identify which
 *			callback routine in the owner object this connection is calling.
 *		transport_connection
 *			This is the object used by this connection to communicate with the
 *			transport layer.
 *		upward_connection
 *			This is a boolean flag which indicates whether this is an upward
 *			connection or a downward connection.
 *		domain_parameters
 *			This is the set of parameters which describes the local domain.
 *		min_domain_parameters
 *			This is the set of parameters which describes the minimum
 *			permissable values for local domain parameters.
 *		max_domain_parameters
 *			This is the set of parameters which describes the maximum
 *			permissable values for local domain parameters.
 *		user_data
 *			This is a pointer to a buffer containing data which is sent to the
 *			remote provider through the "ConnectInitial" PDU.
 *		user_data_length
 *			The length of the user data described above.
 *		connection_error
 *			A return parameter which indicates any errors which may have 
 *			occurred in construction of the connection object.
 *
 *	Return Value:
 *		MCS_NO_ERROR			
 *			The connection was created successfully.
 *		MCS_TRANSPORT_FAILED	
 *			An error occurred in accepting the transport connection.
 *		MCS_BAD_DOMAIN_PARAMETERS
 *			There was no acceptable overlap between the local and remote
 *			domain parameters.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Connection ()
 *
 *	Functional Description:
 *		This is the destructor for the Connection class.  If no connection
 *		deletion is pending, it terminates the current connection by issuing
 *		a DisconnectProviderUltimatum to the domain, transmitting a
 *		"DISCONNECT_PROVIDER_ULTIMATUM" PDU, and issuing a DisconnectRequest
 *		to the transport interface.  The destructor also clears the transmission
 *		queue and frees any allocated memory.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void		RegisterTransportConnection ()
 *
 *	Functional Description:
 *		This routine is called in order to register the transport connection
 *		with the connection object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void		PlumbDomainIndication (
 *						PCommandTarget		originator,
 *						ULong				height_limit)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"PlumbDomainIndication" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		height_limit
 *			This is the number of connections between this user and the
 *			top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ErectDomainRequest (
 *						PCommandTarget		originator,
 *						ULong				height_in_domain,
 *						ULong				throughput_interval)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ErectDomainRequest" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		height_in_domain
 *			This is the number of connections between this user and the
 *			top provider.
 *		throughput_interval
 *			The minimum number of octets per second required.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		RejectUltimatum (
 *						PCommandTarget		originator,
 *						Diagnostic			diagnostic,
 *						PUChar				octet_string_address,
 *						ULong				octet_string_length)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"RejectUltimatum" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		diagnostic
 *			An enumeration indicating the reason for this reject.
 *		octet_string_address
 *			A pointer to the PDU data which resulted in the reject.
 *		octet_string_length
 *			The length of the PDU data which resulted in the reject.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeChannelsRequest (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeChannelsRequest" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_channel_list
 *			This is a list of attributes describing the channels which are to
 *			be merged.
 *		purge_channel_list
 *			This is a list of ID's for the channels that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeChannelsConfirm (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		MergeChannelConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_channel_list
 *			This is a list of attributes describing the channels which are to
 *			be merged.
 *		purge_channel_list
 *			This is a list of ID's for the channels that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PurgeChannelsIndication (
 *					PCommandTarget		originator,
 *					CUidList           *purge_user_list,
 *					CChannelIDList     *purge_channel_list)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"PurgeChannelsIndication" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		purge_user_list
 *			This is a list of IDs of the users being purged.
 *		purge_channel_list
 *			This is a list of IDs of the channels being purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeTokensRequest (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeTokensRequest" PDU through the transport interface.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_token_list
 *			This is a list of attributes describing the tokens which are to
 *			be merged.
 *		purge_token_list
 *			This is a list of ID's for the tokens that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeTokensConfirm (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		MergeTokensConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_token_list
 *			This is a list of attributes describing the tokens which are to
 *			be merged.
 *		purge_token_list
 *			This is a list of ID's for the tokens that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	PurgeTokensIndication (
 *					PCommandTarget		originator,
 *					CTokenIDList       *purge_token_ids)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		PurgeTokenIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		purge_token_ids
 *			This is a list of ID's for the tokens that are to be purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DisconnectProviderUltimatum (
 *					PCommandTarget		originator,
 *					Reason				reason)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		DisconnectProviderUltimatum command to the remote attachment.  Note
 *		that this command automatically causes this Connection object to
 *		destroy itself.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		reason
 *			The reason for the diconnect.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	AttachUserRequest (
 *					PCommandTarget		originator)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		AttachUserRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	AttachUserConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		AttachUserConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the attach request.
 *		uidInitiator
 *			If the result was successful, this will contain the unique user
 *			ID to be associated with this user.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DetachUserRequest (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					UserID				user_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		DetachUserRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		reason
 *			This is the reason for the detachment.
 *		user_id
 *			The ID of the user who wishes to detach.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	DetachUserIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					UserID				user_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		DetachUserIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		reason
 *			The reason for the detachment.
 *		user_id
 *			The ID of the user who has detached.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelJoinRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelJoinRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user who initiated the request.
 *		channel_id
 *			The ID of the channel to be joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelJoinConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			requested_id,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelJoinConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the join request.
 *		uidInitiator
 *			The ID of the user who initiated the request.
 *		requested_id
 *			This ID of the channel that the user attempted to join (which may
 *			be 0).
 *		channel_id
 *			The ID of the channel being joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelLeaveRequest (
 *					PCommandTarget		originator,
 *					CChannelIDList     *channel_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelLeaveRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id_list
 *			The list of IDs of the channels to be left.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelConveneRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelConveneRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to convene a private
 *			channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelConveneConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelConveneConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			This is the result of the previously requested convene operation.
 *		uidInitiator
 *			This is the ID of the user who tried to convene a new channel.
 *		channel_id
 *			If the request was successful, this is the ID of the newly created
 *			private channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelDisbandRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelDisbandRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to disband a private
 *			channel.
 *		channel_id
 *			This is the ID of the channel being disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelDisbandIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelDisbandIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id
 *			This is the ID of the channel being disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelAdmitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelAdmitRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to admit some users to
 *			a private channel.
 *		channel_id
 *			This is the ID of the channel to be affected.
 *		user_id_list
 *			This is a container holding the IDs of the users to be admitted.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelAdmitIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelAdmitIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to admit some users to
 *			a private channel.
 *		channel_id
 *			This is the ID of the channel to be affected.
 *		user_id_list
 *			This is a container holding the IDs of the users to be admitted.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelExpelRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelExpelRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			This is the ID of the user who is trying to expel some users from
 *			a private channel.
 *		channel_id
 *			This is the ID of the channel to be affected.
 *		user_id_list
 *			This is a container holding the IDs of the users to be expelled.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	ChannelExpelIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		ChannelExpelIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		channel_id
 *			This is the ID of the channel to be affected.
 *		user_id_list
 *			This is a container holding the IDs of the users to be expelled.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataRequest (
 *					PCommandTarget		originator,
 *					UINT				type,
					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		SendDataRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the address of the CommandTarget that issued this command.
 *		type (i)
 *			Normal or uniform send data request
 *		pDataPacket (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataIndication (
 *					PCommandTarget		originator,
 *					UINT				type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		SendDataIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		type (i)
 *			normal or uniform data indication
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGrabRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user attempting to grab the token.
 *		token_id
 *			The ID of the token being grabbed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGrabConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the grab operation.
 *		uidInitiator
 *			The ID of the user attempting to grab the token.
 *		token_id
 *			The ID of the token being grabbed.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenInhibitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenInhibitRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user attempting to inhibit the token.
 *		token_id
 *			The ID of the token being inhibited.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenInhibitConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenInhibitConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the inhibit operation.
 *		uidInitiator
 *			The ID of the user attempting to inhibit the token.
 *		token_id
 *			The ID of the token being inhibited.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveRequest (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGiveRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveIndication (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGiveIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveResponse (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				receiver_id,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGiveResponse command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the give operation.
 *		receiver_id
 *			The ID of the user being given the token.
 *		token_id
 *			The ID of the token being given.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGiveConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenGiveConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the give operation.
 *		uidInitiator
 *			The ID of the user being given the token.
 *		token_id
 *			The ID of the token being given.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenReleaseRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user attempting to release the token.
 *		token_id
 *			The ID of the token being released.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenReleaseConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenReleaseConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		result
 *			The result of the release operation.
 *		uidInitiator
 *			The ID of the user attempting to release the token.
 *		token_id
 *			The ID of the token being released.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenPleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenPleaseRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user requesting the token.
 *		token_id
 *			The ID of the token being requested.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenPleaseIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenPleaseIndication command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user requesting the token.
 *		token_id
 *			The ID of the token being requested.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenTestRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenTestRequest command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user testing the token.
 *		token_id
 *			The ID of the token being tested.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenTestConfirm (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is received when the local attachment wishes to send a
 *		TokenTestConfirm command to the remote attachment.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		uidInitiator
 *			The ID of the user testing the token.
 *		token_id
 *			The ID of the token being tested.
 *		token_status
 *			The status of the token after processing the request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	MergeDomainIndication (
 *					PCommandTarget		originator,
 *					MergeStatus			merge_status)
 *
 *	Functional Description:
 *		This command is received when a domain enters or leaves the domain merge
 *		state.  When in a domain merge state, NO commands are to be sent to
 *		the Domain object.
 *
 *	Formal Parameters:
 *		originator
 *			This is the address of the CommandTarget that issued this command.
 *		merge_status
 *			This is the current status of the domain merge.  It indicates
 *			whether the merge is active, or just completed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		All command traffic to the Domain object must halt when the domain is
 *		in the merge state.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	FlushMessageQueue()
 *
 *	Functional Description:
 *		This function is called by the controller during the MCS heartbeat to
 *		allow it to flush its output buffers.  If there is any data waiting
 *		to be transmitted (at any priority), the Connection object will attempt
 *		to send it at this time.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		OwnerCallback (
 *						unsigned int		message,
 *						PVoid				parameter1,
 						TransportConnection	transport_connection)
 *
 *	Functional Description:
 *		This function is used to receive owner callbacks from the Transport
 *		Interface object.  Connection objects sends data and requests to
 *		the Transport Interface object through its public interface, but it
 *		receives data and indications through this owner callback.  For a more
 *		complete description of the callbacks, and how the parameter for each
 *		one are packed, see the interface file for the class TransportInterface
 *		(since it is this class that originates the callbacks).
 *
 *	Formal Parameters:
 *		message
 *			This is the message to be processed.  These are defined in the
 *			interface file of the class issuing the callbacks.
 *		parameter1
 *			The meaning of this parameter varies according to the message
 *			being processed.
 *		transport_connection
 *			The transport connection on which the callback applies.
 *
 *	Return Value:
 *		The meaning of the return value varies according to the message being
 *		processed.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\control.h ===
/*
 *	control.h
 *
 *	Copyright (c) 1993 - 1996 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the MCS Controller class.  There will
 *		be exactly one instance of this class at run-time, whose job it is
 *		to coordinate the creation, deletion, and linking of other objects
 *		in the system.
 *
 *		The controller is primarily responsible for managing five "layers"
 *		of objects in the system at run-time.  These layers can be depicted
 *		as follows:
 *
 *		+---+       +------------------------+
 *		|   | <---> | Application Interfaces |
 *		|   |       +------------------------+
 *		|   |                   |
 *		| C |       +------------------------+
 *		| o | <---> |    User Attachments    |
 *		| n |       +------------------------+
 *		| t |                   |
 *		| r |       +------------------------+
 *		| o | <---> |        Domains         |
 *		| l |       +------------------------+
 *		| l |                   |
 *		| e |       +------------------------+
 *		| r | <---> |    MCS Connections     |
 *		|   |       +------------------------+
 *		|   |                   |
 *		|   |       +------------------------+
 *		|   | <---> |  Transport Interfaces  |
 *		+---+       +------------------------+
 *
 *		The controller is the first object created in the MCS system.  It is
 *		responsible for creating all other objects during initialization.  In
 *		the constructor, the controller creates all necessary application
 *		interface and transport interface objects.  These are the objects
 *		through which MCS communicates with the outside world.  They are
 *		static in that they live throughout the lifetime of MCS itself.
 *
 *		During initialization, the node controller must register itself with
 *		the controller so that the controller knows which application interface
 *		object to use when issuing indications and confirms back to the node
 *		controller.  Note that even though it is possible to have more than
 *		one way to communicate with applications, there is still only one node
 *		controller.
 *
 *		Four of the five layers of objects communicate with the controller
 *		through the owner callback facility.  This mechanism is used to send
 *		requests to the controller.
 *
 *		User attachments (instances of class User) are created when the
 *		controller receives an AttachUserRequest from one of the application
 *		interface objects (with a valid domain selector).  A new user object
 *		is created, who in turn registers with the correct application interface
 *		object to insure proper data flow at run-time.
 *
 *		Domains (instances of class Domain) are created when the controller
 *		receives a CreateDomain from one of the application interface objects.
 *		Since both user attachments and MCS connections identify specific
 *		domains, this must occur before any attaching or connecting can be
 *		done.
 *
 *		MCS connections (instances of class Connection) are created in two
 *		possible ways.  First, when a ConnectProviderRequest is received from
 *		one of the application interface objects (with a valid local domain
 *		selector and a valid transport address).  Second, when a
 *		ConnectProviderResponse is received from one of the application
 *		interface objects in response to a previous connect provider indication.
 *		Either way, a Connection object is created to represent the new MCS
 *		connection.
 *
 *		User attachments are deleted in one of two ways.  First, when a
 *		DetachUserRequest is received from an application interface with a
 *		valid user handle.  Second, if the user attachment is told by the
 *		domain that the attachment is severed.  In the latter case, the user
 *		object asks the controller to delete it using the owner callback
 *		facility.
 *
 *		Domains are deleted when a DeleteDomain is received from an application
 *		interface.
 *
 *		Connections are deleted in one of three ways.  First, when a
 *		DisconnectProviderRequest is received from an application interface
 *		with a valid connection handle.  Second, if the transport interface
 *		detects a loss of the connection at a lower layer.  Third, if the
 *		connection is told by the domain that the connection is to be severed.
 *		In the latter two cases, the connection object asks the controller to
 *		delete it using the owner callback facility.
 *
 *		The primary role of the controller is to create and delete all of these
 *		objects, and to "plug" them together as needed.
 *
 *		During initialization, the controller also creates a single instance
 *		of a memory manager.  This objects is then passed on to all other
 *		objects that require its services (in their constructors).  A possible
 *		way to improve upon this scheme would be to create a memory manager
 *		for each domain, so that traffic in one domain does not influence
 *		traffic in another.
 *
 *	Portable:
 *		Not completely.  During initialization, the constructor "knows"
 *		how to create application interface and transport interface objects
 *		that are specific to the environment.  In the case of the transport
 *		interfaces, it actually reads a windows ".INI" file.  It can also
 *		optionally allocate a windows timer in order have a "heartbeat".  Other
 *		than initialization, everything else is portable.
 *
 *	Caveats:
 *		There can be only one instance of this class in an MCS provider.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_CONTROLLER_
#define	_CONTROLLER_

/*
 *	Include files.
 */
#include "omcscode.h"

/*
 *	This structure is used to hold information about an incoming connection,
 *	while MCS waits for a connect provider response from the node controller.
 */
typedef	struct
{
	TransportConnection		transport_connection;
	BOOL    				upward_connection;
	DomainParameters		domain_parameters;
	DomainParameters		minimum_domain_parameters;
	DomainParameters		maximum_domain_parameters;
} ConnectionPending;
typedef	ConnectionPending *				PConnectionPending;

/*
 *	This is the set of container definitions defined using templates.  All
 *	containers are based on classes in the Rogue Wave Tools.h++ class
 *	library.
 *
 *	The controller keeps a list of objects at each of the five levels, as
 *	follows:
 *
 *	DomainList
 *		This is a dictionary of currently existing domain objects, which is
 *		keyed by DomainSelector.
 *	CConnectionList2
 *		This is a dictionary of currently existing connection objects, which is
 *		keyed by connection handle.
 *	TransportList
 *		This is a dictionary of currently existing transport interface objects,
 *		which is keyed by transport identifier.  Note that the transport
 *		identifier is just a character string.
 *	ConnectionPendingList
 *		This is a dictionary of pending connections.  The key is the connection
 *		handle, and the value is a pointer to a connection pending structure
 *		that "remembers" details about a pending connection that are not
 *		going to be passed back in the connect provider response.
 *	ConnectionPollList
 *		This is a singly-linked list that is used to hold all connection
 *		objects.  This list is used to iterate through the list, granting a time
 *		slice to each object during the heartbeat.
 */
class CConnPendingList2 : public CList2
{
    DEFINE_CLIST2_(CConnPendingList2, PConnectionPending, ConnectionHandle)
};

class CConnPollList : public CList
{
    DEFINE_CLIST(CConnPollList, PConnection)
};

/*
 *	The controller makes extensive use of the owner callback mechanism to
 *	receive requests from the objects that it owns.  In order for the
 *	requests to be differentiated here in the controller, each object must
 *	issue its message using a different message offset.  The required message
 *	offset is given to each object as it is created by the controller.  The
 *	message offsets for the five layers of objects are as follows.
 *
 *	This allows the controller to easily determine what type of object a
 *	given owner callback message is from (see the implementation of the
 *	OwnerCallback member function for details).
 */
#define	APPLICATION_MESSAGE_BASE		0
#define	USER_MESSAGE_BASE				100
#define	DOMAIN_MESSAGE_BASE				200
#define	CONNECTION_MESSAGE_BASE			300
#ifndef TRANSPORT_MESSAGE_BASE
#define	TRANSPORT_MESSAGE_BASE			400
#endif  // !TRANSPORT_MESSAGE_BASE

/*
**	The following are timeout times that are used to set and test the
**	Controller_Wait_Timeout instance variable of a Controller object.
**	When the controller is signalled thru an event to process and send
**	msgs to an application, GCC, etc..., tries to process it. Sometimes
**	the event can't be processed immediately. In these cases, we make
**	the controller timeout in the WaitForMultipleObjects finite, and set
**	the Controller_Event_Mask to store which event we want to re-try
**	later. When the event is processed, the mask is reset.
*/
#define CONTROLLER_THREAD_TIMEOUT				200
#define TRANSPORT_RECEIVE_TIMEOUT				300
#define	TRANSPORT_TRANSMIT_TIMEOUT				10000

/*
**	The following are the indices in the arrays of masks and timeouts.
*/
#define TRANSPORT_RECEIVE_INDEX			0
#define	TRANSPORT_TRANSMIT_INDEX		1
#define GCC_FLUSH_OUTGOING_PDU_INDEX    3

/*
**	The following values are the masks used for checking against
**	the Controller_Event_Mask in the PollMCSDevices() member of the
**	MCS Controller.
*/
#define TRANSPORT_RECEIVE_MASK 			(0x1 << TRANSPORT_RECEIVE_INDEX)
#define	TRANSPORT_TRANSMIT_MASK 		(0x1 << TRANSPORT_TRANSMIT_INDEX)
#define GCC_FLUSH_OUTGOING_PDU_MASK     (0x1 << GCC_FLUSH_OUTGOING_PDU_INDEX)
#define TRANSPORT_MASK					(TRANSPORT_RECEIVE_MASK | TRANSPORT_TRANSMIT_MASK)

/*
 *	These are the owner callback functions that an application interface object
 *	can send to its creator (which is typically the MCS controller).  The
 *	first one allows an application interface object to tell the controller that
 *	it represents the interface to the node controller application.  The rest
 *	are primitives that would generally come from the node controller
 *	application, but must be acted upon internally by the MCS controller.
 *
 *	When an object instantiates an application interface object (or any other
 *	object that uses owner callbacks), it is accepting the responsibility of
 *	receiving and handling those callbacks.  For that reason, any object that
 *	issues owner callbacks will have those callbacks defined as part of the
 *	interface file (since they really are part of a bi-directional interface).
 *
 *	Each owner callback function, along with a description of how its parameters
 *	are packed, is described in the following section.
 */
#define	REGISTER_NODE_CONTROLLER			0
#define	RESET_DEVICE						1
#define	CREATE_DOMAIN						2
#define	DELETE_DOMAIN						3
#define	CONNECT_PROVIDER_REQUEST			4
#define	CONNECT_PROVIDER_RESPONSE			5
#define	DISCONNECT_PROVIDER_REQUEST			6
#define	APPLICATION_ATTACH_USER_REQUEST		7

/*
 *	These are the structures used by some of the owner callback function listed
 *	above (for the case that the parameters to a function cannot fit into two
 *	32-bit parameters).
 */

#ifdef NM_RESET_DEVICE
typedef	struct
{
	PChar					device_identifier;
} ResetDeviceInfo;
typedef	ResetDeviceInfo *		PResetDeviceInfo;
#endif // #ifdef NM_RESET_DEVICE

typedef	struct
{
	TransportAddress		local_address;
	PInt					local_address_length;
} LocalAddressInfo;
typedef	LocalAddressInfo *		PLocalAddressInfo;

typedef	struct
{
	GCCConfID              *calling_domain;
	GCCConfID              *called_domain;
	PChar					calling_address;
	PChar					called_address;
	BOOL					fSecure;
	BOOL    				upward_connection;
	PDomainParameters		domain_parameters;
	PUChar					user_data;
	ULong					user_data_length;
	PConnectionHandle		connection_handle;
} ConnectRequestInfo;
typedef	ConnectRequestInfo *	PConnectRequestInfo;

typedef	struct
{
	ConnectionHandle		connection_handle;
	GCCConfID              *domain_selector;
	PDomainParameters		domain_parameters;
	Result					result;
	PUChar					user_data;
	ULong					user_data_length;
} ConnectResponseInfo;
typedef	ConnectResponseInfo *	PConnectResponseInfo;

typedef	struct
{
	GCCConfID              *domain_selector;
	PUser					*ppuser;
} AttachRequestInfo;
typedef	AttachRequestInfo *		PAttachRequestInfo;

/*
 *	These structures are used to hold information that would not fit into
 *	the one parameter defined as part of an MCS call back function.  In the case
 *	where these structures are used for call backs, the address of the structure
 *	is passed as the only parameter.
 */
// LONCHANC: we dropped calling and called domain selectors here.
typedef struct
{
	ConnectionHandle	connection_handle;
	BOOL    			upward_connection;
	DomainParameters	domain_parameters;
	unsigned char  *	user_data;
	unsigned long		user_data_length;
	BOOL				fSecure;
} ConnectProviderIndication;
typedef	ConnectProviderIndication  *		PConnectProviderIndication;

typedef struct
{
	ConnectionHandle	connection_handle;
	DomainParameters	domain_parameters;
	Result				result;
	unsigned char  *	user_data;
	unsigned long		user_data_length;
	PBYTE               pb_cred;
	DWORD               cb_cred;
} ConnectProviderConfirm;
typedef	ConnectProviderConfirm  *		PConnectProviderConfirm;

/*
 *	This is the class definition for the Controller class.  It is worth
 *	noting that there are only three public member functions defined in the
 *	controller (besides the constructor and the destructor).  The Owner
 *	callback function is used by all "owned" objects to make requests
 *	of the controller (who created them).  The poll routine, which is
 *	called from the windows timer event handler.  This is the heartbeat
 *	of MCS at the current time.
 */
class	Controller : public CRefCount
{
public:
	Controller (
		PMCSError			mcs_error);
	~Controller ();

	Void		CreateTCPWindow ();
	Void		DestroyTCPWindow ();
	Void		EventLoop ();
	BOOL		FindSocketNumber(ConnectionHandle connection_handle, SOCKET * socket_number);
	BOOL    	GetLocalAddress(
						ConnectionHandle	connection_handle,
						TransportAddress	local_address,
						PInt				local_address_length);

    // the old owner callback
    void     HandleTransportDataIndication(PTransportData);
    void     HandleTransportWaitUpdateIndication(BOOL fMoreData);
#ifdef NM_RESET_DEVICE
    MCSError HandleAppletResetDevice(PResetDeviceInfo);
#endif
    MCSError HandleAppletCreateDomain(GCCConfID *domain_selector);
    MCSError HandleAppletDeleteDomain(GCCConfID *domain_selector);
    MCSError HandleAppletConnectProviderRequest(PConnectRequestInfo);
    MCSError HandleAppletConnectProviderResponse(PConnectResponseInfo);
    MCSError HandleAppletDisconnectProviderRequest(ConnectionHandle);
    MCSError HandleAppletAttachUserRequest(PAttachRequestInfo);
    void     HandleConnDeleteConnection(ConnectionHandle);
    void     HandleConnConnectProviderConfirm(PConnectConfirmInfo, ConnectionHandle);
    void     HandleTransportDisconnectIndication(TransportConnection, ULONG *pnNotify);
#ifdef TSTATUS_INDICATION
    void     HandleTransportStatusIndication(PTransportStatus);
#endif


private:

#ifdef NM_RESET_DEVICE
			ULong		ApplicationResetDevice (
								PChar				device_identifier);
#endif // NM_RESET_DEVICE
			MCSError	ApplicationCreateDomain(GCCConfID *domain_selector);
			MCSError	ApplicationDeleteDomain(GCCConfID *domain_selector);
			MCSError	ApplicationConnectProviderRequest (
								PConnectRequestInfo	pcriConnectRequestInfo);
			MCSError	ApplicationConnectProviderResponse (
								ConnectionHandle	connection_handle,
								GCCConfID          *domain_selector,
								PDomainParameters	domain_parameters,
								Result				result,
								PUChar				user_data,
								ULong				user_data_length);
			MCSError	ApplicationDisconnectProviderRequest (
								ConnectionHandle	connection_handle);
			MCSError	ApplicationAttachUserRequest (
								GCCConfID          *domain_selector,
								PUser				*ppUser);
			Void		ConnectionDeleteConnection (
								ConnectionHandle    connection_handle);
			void		ConnectionConnectProviderConfirm (
								ConnectionHandle    connection_handle,
								PDomainParameters	domain_parameters,
								Result				result,
								PMemory				memory);
			Void		TransportDisconnectIndication (
								TransportConnection	transport_connection);
			Void		TransportDataIndication (
								TransportConnection	transport_connection,
								PUChar				user_data,
								ULong				user_data_length);
#ifdef TSTATUS_INDICATION
			Void		TransportStatusIndication (
								PTransportStatus	transport_status);
#endif
			Void		ProcessConnectInitial (
								TransportConnection	transport_connection,
								ConnectInitialPDU *pdu_structure);
			Void		ProcessConnectAdditional (
								TransportConnection	transport_connection,
								ConnectAdditionalPDU *pdu_structure);
			Void		ConnectResponse (
								TransportConnection	transport_connection,
								Result				result,
								PDomainParameters	domain_parameters,
								ConnectID			connect_id,
								PUChar				user_data,
								ULong				user_data_length);
			Void		ConnectResult (
								TransportConnection	transport_connection,
								Result				result);
	ConnectionHandle	AllocateConnectionHandle ();
			Void		PollMCSDevices ();
			Void		UpdateWaitInfo (
								BOOL     			bMoreData,
								UINT        		index);

	ConnectionHandle		Connection_Handle_Counter;
	HANDLE					Transport_Transmit_Event;
	HANDLE					Connection_Deletion_Pending_Event;
	BOOL    				Controller_Closing;
	BOOL					m_fControllerThreadActive;

	CDomainList2			m_DomainList2;
	CConnectionList2		m_ConnectionList2;

	CConnPollList		    m_ConnPollList;
	CConnPendingList2       m_ConnPendingList2;

	CConnectionList2		m_ConnectionDeletionList2;
	BOOL    				Connection_Deletion_Pending;
	BOOL    				Domain_Traffic_Allowed;

	DWORD					Controller_Wait_Timeout;
	DWORD					Controller_Event_Mask;

#ifndef NO_TCP_TIMER
	UINT_PTR       			Timer_ID;
#endif	/* NO_TCP_TIMER */

public:
	HANDLE					Synchronization_Event;
};
typedef	Controller *			PController;

/*
 *	Controller (
 *			UShort					timer_duration,
 *			PMCSError				mcs_error)
 *
 *	Functional Description:
 *		This is the constructor for the MCS controller.  Its primary
 *		duty is to instantiate the application interface and transport
 *		interface objects that will be used by this provider.  These objects
 *		are static in that they are created by the controller constructor
 *		and destroyed by the controller destructor (below).  Unlike other
 *		objects in the system, they are NOT created and destroyed as needed.
 *
 *		The constructor also instantiates the memory manager that will be
 *		used throughout the MCS system.
 *
 *		The constructor also allocates a windows timer that is used to
 *		provide MCS with a "heartbeat".  This is VERY platform specific and
 *		will definitely change before final release.
 *
 *		Note that if anything goes wrong, the mcs_error variable will be
 *		set to the appropriate error.  It is assumed that whoever is creating
 *		the controller will check this return value and destroy the newly
 *		created controller if something is wrong.
 *
 *		Note that it is not possible to use MCS if there is not at least
 *		one application interface object successfully created.  However, it
 *		is possible to use MCS if there are no transport interfaces.  Multiple
 *		user applications could use this to communicate with one another.  On the
 *		other hand, MCS_NO_TRANSPORT_STACKS is considered a fatal error.
 *
 *	Formal Parameters:
 *		timer_duration (i)
 *			If non-zero, this causes the constructor to allocate a timer to
 *			provide the heartbeat, and this variable is in milliseconds.  If
 *			zero, no timer is allocated, and the application is responsible
 *			for providing the heartbeat.
 *		mcs_error (o)
 *			This is the return value for the constructor.  In C++ constructors
 *			cannot directly return a value, but this can be simulated by passing
 *			in the address of a return value variable.  This value should be
 *			checked by whoever creates the controller.  If it is anything but
 *			MCS_NO_ERROR, the controller should be
 *			deleted immediately, as this is a non-recoverable failure.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine, and the controller is ready to be used.
 *		MCS_NO_TRANSPORT_STACKS
 *			The controller initialized okay, but the TCP transport did
 *			not initialize.
 *		MCS_ALLOCATION_FAILURE
 *			MCS was unable to initialize properly due to a memory allocation
 *			failure.  The controller should be deleted immediately.
 *
 *	Side Effects:
 *		The proper initialization of the application interface and transport
 *		interface objects will probably cause device initializations to occur
 *		in readying for communication.
 *
 *	Caveats:
 *		None.
 */
/*
 *	~Controller ();
 *
 *	Functional Description:
 *		This is the controller destructor.  Its primary purpose is to free up
 *		all resources used by this MCS provider.  It attempts to destroy all
 *		objects in a controlled fashion so as to cleanly sever both user
 *		attachments and MCS connections.  It does this by destroying
 *		connections first, and then transport interfaces.  Next it deletes
 *		user attachments, followed by application interfaces.  Only then does
 *		it destroy existing domains (which should be empty as a result of all
 *		the previous destruction).
 *
 *		Note that this is the ONLY place where application interface and
 *		transport interface objects are destroyed.
 *
 *	Formal Parameters:
 *		Destructors have no parameters.
 *
 *	Return Value:
 *		Destructors have no return value.
 *
 *	Side Effects:
 *		All external connections are broken, and devices will be released.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		OwnerCallback (
 *						unsigned int			message,
 *						PVoid					parameter1,
 *						ULong					parameter2)
 *
 *	Functional Description:
 *		This is the owner callback routine for the MCS controller.  This member
 *		function is used when it is necessary for an object created by the
 *		controller to send a message back to it.
 *		Essentially, it allows objects to make requests of their creators
 *		without having to "tightly couple" the two classes by having them
 *		both aware of the public interface of the other.
 *
 *		When an object such as the controller creates an object that expects
 *		to use the owner callback facility, the creator is accepting the
 *		responsibility of handling owner callbacks.  All owner callbacks
 *		are defined as part of the interface specification for the object
 *		that will issue them.
 *
 *		How the controller handles each owner callback is considered an
 *		implementation issue within the controller.  As such, that information
 *		can be found in the controller implementation file.
 *
 *	Formal Parameters:
 *		message (i)
 *			This is the message to processed.  Note that when the controller
 *			creates each object, it gives it a message offset to use for owner
 *			callbacks, so that the controller can differentiate between
 *			callbacks from different classes.
 *		parameter1 (i)
 *			The meaning of this parameter varies according to the message being
 *			processed.  See the interface specification for the class issuing
 *			the owner callback for a detailed explanation.
 *		parameter2 (i)
 *			The meaning of this parameter varies according to the message being
 *			processed.  See the interface specification for the class issuing
 *			the owner callback for a detailed explanation.
 *
 *	Return Value:
 *		Each owner callback returns an unsigned long.  The meaning of this
 *		return value varies according to the message being processed.  See the
 *		interface specification for the class issuing the owner callback for a
 *		detailed explanation.
 *
 *	Side Effects:
 *		Message specific.
 *
 *	Caveats:
 *		None.
 */

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\crc.h ===
/*	crc.h
 *
 *	Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This file contains the CRC class definition.  This class can use either
 *		the table-driven or bit-shifting approach to generate its CRC.
 *
 *	Public Instance Variable:
 *		None
 *
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		Marvin Nicholson
 */

#ifndef _CRC_
#define _CRC_

#include "databeam.h"

#define	CRC_TABLE_SIZE	256

class	CRC
{
	public:
				CRC ();
				~CRC ();

		ULong 	OldCRCGenerator(
					PUChar	block_adr,
					ULong	block_len);
		ULong 	CRCGenerator(
					PUChar	block_adr,
					ULong	block_len);
		DBBoolean CheckCRC(
					PUChar	block_adr,
					ULong	block_len);
		Void	GetOverhead(
					UShort		maximum_packet,
					PUShort		new_maximum_packet);

	private:
		UShort		CRCTableValue(
						Int		Index,
						ULong	poly);
		Void		CRCTableGenerator(
						ULong poly);

        UShort		CRC_Table[CRC_TABLE_SIZE];
		Int			CRC_Width;
        ULong		CRC_Poly;
        ULong		CRC_Init;
        UShort		CRC_Check_Value;
		DBBoolean	Invert;
		UShort		CRC_Register;

};
typedef CRC *	PCRC;

#endif

/*	
 *	CRC::CRC ();
 *
 *	Functional Description
 *		This is the constructor for this class.
 *
 *	Formal Parameters
 *		None.
 *
 *	Return Value
 *		None
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	CRC::~CRC ();
 *
 *	Functional Description
 *		This is the destructor for this class.
 *
 *	Formal Parameters
 *		None.
 *
 *	Return Value
 *		None
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	ULong 	CRC::OldCRCGenerator(
 *					PUChar	block_adr,
 *					ULong	block_len);
 *
 *	Functional Description
 *		This function generates the crc using bit-shifting methods.  This method
 *		is slower than the table-driven approach.
 *
 *	Formal Parameters
 *		block_adr	(i)	-	Address of buffer to generate CRC on.
 *		block_lengh	(i)	-	Length of buffer
 *
 *	Return Value
 *		CRC value
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	ULong 	CRC::CRCGenerator(
 *					PUChar	block_adr,
 *					ULong	block_len);
 *
 *	Functional Description
 *		This function generates the crc using the table-driven method.
 *
 *	Formal Parameters
 *		block_adr	(i)	-	Address of buffer to generate CRC on.
 *		block_lengh	(i)	-	Length of buffer
 *
 *	Return Value
 *		CRC value
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	DBBoolean CRC::CheckCRC(
 *					PUChar	block_adr,
 *					ULong	block_len);
 *
 *	Functional Description
 *		This function generates a CRC based on the block passed in.  It assumes
 *		that the CRC is attached to the end of the block.  It compares the
 *		CRC generated to the CRC at the end of the block and returns TRUE if
 *		the CRC is correct.
 *
 *	Formal Parameters
 *		block_adr	(i)	-	Address of buffer to generate CRC on.
 *		block_lengh	(i)	-	Length of buffer
 *
 *	Return Value
 *		TRUE		-	CRC in the block is correct
 *		FALSE		-	CRC in the block is NOT correct
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	Void	CRC::GetOverhead(
 *					UShort		maximum_packet,
 *					PUShort		new_maximum_packet);
 *
 *	Functional Description
 *		This function is called to determine the overhead that will be added
 *		to the packet by the CRC.
 *
 *	Formal Parameters
 *		maximum_packet		(i)	-	Current max. packet size
 *		new_maximum_packet	(o)	-	Maximum length of packet including CRC.
 *
 *	Return Value
 *		None
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\crostmsg.h ===
/*
 *	crostmsg.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_CONFERENCE_ROSTER_MESSAGE_
#define	_CONFERENCE_ROSTER_MESSAGE_

#include "crost.h"

class CConfRosterMsg : public CRefCount
{
public:

	CConfRosterMsg(CConfRoster *conference_roster);

	~CConfRosterMsg(void);

	GCCError		LockConferenceRosterMessage(void);
	void			UnLockConferenceRosterMessage(void);
	GCCError		GetConferenceRosterMessage(LPBYTE *ppData);

private:

	LPBYTE			m_pMemoryBlock;
	CConfRoster		*m_pConfRoster;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\crostmgr.h ===
/*
 *	crostmgr.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		Instances of this class represent the owner of the Conference Roster 
 *		for a single Conference object at an individual node.  This class will 
 *		create either a single CConfRoster object (referred to as a 
 *		"Global" roster) or two CConfRoster objects (refered to as a 
 *		"Local" and "Global" roster) in its constructor and will return a 
 *		resource error if there is not enough memory to instantiate it.  The 
 *		CConfRosterMgr is mainly responsible for routing Roster 
 *		Updates to and from the CConfRoster object(s) it manages.  This 
 *		includes updates sent to both the Control SAP and Application SAPs as 
 *		well as Updates sent to other nodes via PDUs.  This class makes 
 *		decisions on how to route updates based on whether or not it is at a 
 *		Top Provider node.  It also must make routing decisions based on whether 
 *		the change affects the Local or Global roster being maintained.
 *
 *		The CConfRosterMgr object at every node except the Top Provider 
 *		will maintain two ConferenceRosters, a local one and a global one.  This 
 *		is a very important distinction in that it implies two entirely 
 *		different sets of responsibilities. Conference Roster information is 
 *		distributed over the entire Conference.  Nodes that lie lower in the 
 *		connection hierarchy (subordinate nodes) contain less information than 
 *		higher nodes but all play an important role in maintaining the overall 
 *		roster.  
 *
 *		The "Local" CConfRoster is mainly used to inform parent nodes of 
 *		changes to the Conference Roster that occur at the local node or below 
 *		it in the connection hierarchy.  The Local CConfRoster consist of 
 *		all the Conference Roster Records at its local node and below it.  It is 
 *		not used to deliver Conference Roster Update messages to the various 
 *		SAPs.  Its only input is from either primitive calls at the local node 
 *		or from Roster Update PDUs received from subordinate nodes.  A "Local" 
 *		CConfRoster is only maintained by ConferenceRosterManagers at nodes 
 *		that are not the Top Provider.  
 *
 *		A "Global" CConfRoster maintained by a CConfRosterMgr has 
 *		a dual set of responsibilities depending on if it is at a Top Provider 
 *		node.  A CConfRoster of this type at a Top Provider is responsible 
 *		for maintaining a record entry for every node in the Conference.  It is 
 *		also used to send full conference roster refreshes to all of its 
 *		subordinate nodes when changes to the roster occur.  All "Global" 
 *		ConferenceRosters (regardless of location within the connection 
 *		hierarchy) are used to send Roster Update indications to all the 
 *		appropriate SAPs (Control and Application) via an Owner-Callback call to 
 *		the Conference Object that owns it.  The owner object is informed of the 
 *		roster update through a CONF_ROSTER_MGR_ROSTER_REPORT message.  Included 
 *		in this message is a pointer to a CConfRosterMsg object.  The 
 *		CConfRosterMgr creates a CConfRosterMsg from the 
 *		"Global" CConfRoster object that it maintains.  This 
 *		CConfRosterMsg object contains all the conference roster data 
 *		serialized into a single memory block which is formatted for delivery to 
 *		the appropriate SAPs.  You can think of this as a snapshot in time of 
 *		the CConfRoster being delivered in the roster update message.
 *
 *		A "Global" CConfRoster at a subordinate node is responsible for 
 *		storing full refreshes of the Conference Roster from the Top Provider.  
 *		It is also used to send the Conference Roster Update message to all the 
 *		appropriate SAPs through an Owner-Callback to the Conference object (as 
 *		mentioned above) after processing the full refresh PDU.
 *
 *		All PDUs and messages are delivered when the CConfRosterMgr is 
 *		flushed. This is also true for ApplicationRosterManagers.  This is a 
 *		very important concept in that it allows a CConfRosterMgr to 
 *		process a number of request and PDUs before actually being flushed.  The 
 *		CConfRoster itself will queue up changes to a PDU that can consist 
 *		of either multiple updates or a single refresh and will not free it 
 *		until after it is flushed.  Therefore, when processing a roster update 
 *		PDU that consists of changes to the conference roster as well as 
 *		multiple application rosters, a roster refresh PDU can be held back 
 *		until all the roster managers have had a chance to process their portion 
 *		of the roster update.  Once complete, a single PDU can be built by 
 *		flushing the CConfRosterMgr and all the affected 
 *		ApplicationRosterManagers.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_CONFERENCE_ROSTER_MANAGER_
#define	_CONFERENCE_ROSTER_MANAGER_

#include "mcsuser.h"
#include "clists.h"
#include "crost.h"


class CConf;
class CConfRosterMgr : public CRefCount
{
public:

	CConfRosterMgr(
		PMCSUser				user_object,
		CConf					*pConf,
		BOOL					top_provider,
		PGCCError				roster_error);

	~CConfRosterMgr(void);

	GCCError			AddNodeRecord(PGCCNodeRecord node_record);

	GCCError			UpdateNodeRecord(PGCCNodeRecord node_record);
	
	GCCError			RemoveUserReference(UserID deteched_node_id);
								
	GCCError			RosterUpdateIndication(
							PGCCPDU					roster_update,
							UserID					sender_id);
								
	GCCError			FlushRosterUpdateIndication(PNodeInformation node_information);

	GCCError			GetFullRosterRefreshPDU(PNodeInformation node_information);
								

	CConfRoster		*GetConferenceRosterPointer(void) { return (m_pGlobalConfRoster); }
	BOOL			Contains(UserID uid) { return m_pGlobalConfRoster->Contains(uid); }
	UINT			GetNumberOfNodeRecords(void) { return m_pGlobalConfRoster->GetNumberOfNodeRecords(); }

    BOOL            IsThisNodeParticipant ( GCCNodeID );

private:

	BOOL							m_fTopProvider;
	CConfRoster						*m_pGlobalConfRoster;
	CConfRoster						*m_pLocalConfRoster;
	MCSUser						    *m_pMcsUserObject;
	CConf							*m_pConf;
};

#endif


/*
 *	CConfRosterMgr	(	
 *					PMCSUser				user_object,
 *					UINT        			owner_message_base,
 *					BOOL					top_provider,
 *					PGCCError				roster_error)
 *
 *	Public Function Description
 *		This is the conference roster manager constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *
 *	Formal Parameters:
 *		user_object			-	(i)	Pointer to the user attachment object used
 *									by this class.
 *		owner_object		-	(i)	Pointer to the owner object.
 *		owner_message_base	-	(i)	Message base to add to all the owner 
 *									callbacks.
 *		top_provider		-	(i)	Indicates if this is the top provider node.
 *		roster_error		-	(o)	Pointer to error value to be returned.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No resource error occured.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	~CConfRosterMgr ()
 *
 *	Public Function Description
 *		This is the conference roster destructor. It is responsible for
 *		freeing up all memory allocated by this class.
 *
 *	Formal Parameters:
 *		None.
 *		
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	AddNodeRecord (PGCCNodeRecord			node_record)
 *
 *	Public Function Description
 *		This routine is used to add a new record to the conference roster.
 *		This class makes the decision about which roster the new record goes
 *		into (global or local).
 *
 *	Formal Parameters:
 *		node_record		-	(i)	Pointer to the record to add to the roster.
 *		
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *												an invalid object key.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	UpdateNodeRecord(
 *								PGCCNodeRecord			node_record)
 *
 *	Public Function Description
 *		This routine is used to replace a record in the conference roster with
 *		a new record. This class makes the decision about which roster the new 
 *		record affects (global or local).
 *
 *	Formal Parameters:
 *		node_record		-	(i)	Pointer to the record to replace with.
 *		
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	RemoveUserReference (
 *								UserID					deteched_node_id)
 *
 *	Public Function Description
 *		This routine removes the record associated with the specified node
 *		id.
 *
 *	Formal Parameters:
 *		deteched_node_id		(i)	Node reference to remove.
 *
 *	Return Value:
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_INVALID_PARAMETER		-	No records associated with this node
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RosterUpdateIndication(
 *								PGCCPDU					roster_update,
 *								UserID					sender_id)
 *
 *	Public Function Description
 *		This routine is responsible for processing the decoded PDU data.
 *		It essentially passes the PDU on along to the appropriate roster.
 *
 *	Formal Parameters:
 *		roster_update	-	(i) This is a pointer to a structure that
 *									holds the decoded PDU data.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	FlushRosterUpdateIndication(
 *								PNodeInformation		node_information)
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the conference roster.  It also is responsible for 
 *		flushing a roster update message if necessary.
 *
 *	Formal Parameters:
 *		node_information	-	(o) Pointer to the PDU buffer to fill in.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	GetFullRosterRefreshPDU(
 *								PNodeInformation		node_information)
 *
 *	Public Function Description
 *		This routine is used to access a full conference roster refresh.
 *
 *	Formal Parameters:
 *		node_information	-	(o) Pointer to the PDU buffer to fill in.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL			Contains(UserID		node_record_entry)
 *
 *	Public Function Description
 *		This routine is used to determine if the specified record exists in
 *		the conference roster.
 *
 *	Formal Parameters:
 *		node_record_entry	(i)	Node ID of record to check for
 *
 *	Return Value:
 *		TRUE	-	If the record is contained in the conference roster.
 *		FALSE	-	If the record is not contained in the conference roster.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CConfRoster		*GetConferenceRosterPointer ()
 *
 *	Public Function Description
 *		This routine is used to access a pointer to the conference roster
 *		managed by this conference roster manager.  The global roster
 *		is always returned by this routine.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the Global conference roster.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	USHORT		GetNumberOfNodeRecords ();
 *
 *	Public Function Description
 *		This routine returns the total number of conference roster records
 *		contained in the global conference roster record list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of records in the conference roster list.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\csap.h ===
/*
 *	csap.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CControlSAP.  CControlSAP objects
 *		represent the node controller's Service Access Point to GCC.  This 
 *		class inherits from the SAP class.  The CControlSAP object is 
 *		instantiated when GCCInitialize is called.  From that point forward all
 *		messages to and from the node controller pass through this object.  The
 *		primary responsibility of the CControlSAP object is to route incoming GCC
 *		primitives to their appropriate destination and to convert the 
 *		primitives into a form that is understandable to the objects processing
 *		them. A secondary responsibility of the CControlSAP is to maintain a 
 *		queue for all indication and confirm messages that are eventually sent 
 *		back to the node controller.  
 *
 *		Commands received from the Application Interface (or Node Controller) 
 *		can be routed by the CControlSAP in one of two directions.  Either to the
 *		controller or to a specified conference.  Commands that are passed to 
 *		the controller, are done so using owner callbacks.  Commands that are 
 *		routed to conferences are done so using command target calls and are 
 *		routed based on a Conference ID.  Whenever a new CConf is 
 *		instantiated by the Controller, the CConf informs the CControlSAP 
 *		of its existence by registering its conference ID with it.  The 
 *		CControlSAP maintains a list of command target objects which are indexed
 *		by the conference ID.  
 *
 *	Caveats:
 *		Structures that are passed back to the node controller
 *		are defined in GCC.H.
 *
 *	Author:
 *		blp
 */

#ifndef _GCC_CONTROL_SAP_
#define _GCC_CONTROL_SAP_

/*
 * include files 
 */
#include "sap.h"
#include "password.h"
#include "privlist.h"
#include "conflist.h"

#define GCCNC_DIRECT_INDICATION
#define GCCNC_DIRECT_CONFIRM


/* 
 *	Structure used for passing conference create information from control sap
 *	to the controller.
 */

typedef struct
{
    GCCConfCreateReqCore    Core;
    CPassword               *convener_password;
    CPassword               *password;
    BOOL					fSecure;
    CUserDataListContainer  *user_data_list;
}
    CONF_CREATE_REQUEST;    // internal data structure


typedef struct
{
	GCCNumericString				conference_modifier;
	GCCConfID   					conference_id;
	BOOL							use_password_in_the_clear;
	PDomainParameters 				domain_parameters;
	UINT        					number_of_network_addresses;
	PGCCNetworkAddress 	*			network_address_list;
	CUserDataListContainer		    *user_data_list;
	GCCResult						result;
}
    ConfCreateResponseInfo, *PConfCreateResponseInfo;

typedef struct
{
	GCCNodeType					node_type;
	PGCCAsymmetryIndicator		asymmetry_indicator;
	TransportAddress			calling_address;
	TransportAddress			called_address;
	BOOL                        fSecure;
	CUserDataListContainer      *user_data_list;
	PConnectionHandle			connection_handle;
}
    ConfQueryRequestInfo, *PConfQueryRequestInfo;

typedef struct
{
	GCCResponseTag				query_response_tag;
	GCCNodeType					node_type;
	PGCCAsymmetryIndicator		asymmetry_indicator;
	CUserDataListContainer      *user_data_list;
	GCCResult					result;
}
    ConfQueryResponseInfo, *PConfQueryResponseInfo;

typedef struct
{
	PGCCConferenceName				conference_name;
	GCCNumericString				called_node_modifier;
	GCCNumericString				calling_node_modifier;
	CPassword                       *convener_password;
	CPassword                       *password_challenge;
	LPWSTR							pwszCallerID;
	TransportAddress				calling_address;
	TransportAddress				called_address;
	BOOL							fSecure;
	PDomainParameters 				domain_parameters;
	UINT        					number_of_network_addresses;
	PGCCNetworkAddress			*	local_network_address_list;
	CUserDataListContainer  	    *user_data_list;
	PConnectionHandle				connection_handle;
}
    ConfJoinRequestInfo, *PConfJoinRequestInfo;

typedef struct
{
	GCCConfID   					conference_id;
	CPassword                       *password_challenge;
	CUserDataListContainer  	    *user_data_list;
	GCCResult						result;
	ConnectionHandle				connection_handle;
}
    ConfJoinResponseInfo, *PConfJoinResponseInfo;

typedef struct
{
	UserID						user_id;
	ConnectionHandle			connection_handle;
	GCCConfID   				conference_id;
	BOOL						command_target_call;
}
    JoinResponseStructure, *PJoinResponseStructure;

typedef struct
{
	GCCConfID   			conference_id;
	GCCNumericString		conference_modifier;
	BOOL					fSecure;
	PDomainParameters 		domain_parameters;
	UINT        			number_of_network_addresses;
	PGCCNetworkAddress	*	local_network_address_list;
	CUserDataListContainer  *user_data_list;
	GCCResult				result;
}
    ConfInviteResponseInfo, *PConfInviteResponseInfo;

#ifdef NM_RESET_DEVICE
typedef struct
{
	LPSTR						device_identifier;
}
    ResetDeviceInfo, *PResetDeviceInfo;
#endif // #ifdef NM_RESET_DEVICE

/*
 *	Container used to hold the list of outstanding join response 
 *	structures.
 */
class CJoinResponseTagList2 : public CList2
{
    DEFINE_CLIST2(CJoinResponseTagList2, JoinResponseStructure*, GCCResponseTag)
};



//
//	This structure holds any data that may need to be deleted after a particular
//	GCC message is delivered.
//
typedef struct DataToBeDeleted
{
	LPSTR							pszNumericConfName;
	LPWSTR							pwszTextConfName;
	LPSTR							pszConfNameModifier;
	LPSTR							pszRemoteModifier;
	LPWSTR							pwszConfDescriptor;
	LPWSTR							pwszCallerID;
	LPSTR							pszCalledAddress;
	LPSTR							pszCallingAddress;
	LPBYTE							user_data_list_memory;
	DomainParameters                *pDomainParams;
	GCCConferencePrivileges         *conductor_privilege_list;
	GCCConferencePrivileges         *conducted_mode_privilege_list;
	GCCConferencePrivileges         *non_conducted_privilege_list;
	CPassword                       *convener_password;
	CPassword                       *password;
	CConfDescriptorListContainer    *conference_list;
	CAppRosterMsg					*application_roster_message;
	CConfRosterMsg					*conference_roster_message;
}
    DataToBeDeleted, *PDataToBeDeleted;

//
// Control SAP callback message.
//
typedef GCCMessage      GCCCtrlSapMsg;
typedef struct GCCCtrlSapMsgEx
{
    //
    // Message body
    //
    GCCCtrlSapMsg       Msg;

    //
    // Data to free later.
    //
    LPBYTE              pBuf;
    DataToBeDeleted     *pToDelete;
}
    GCCCtrlSapMsgEx, *PGCCCtrlSapMsgEx;


/*
 *	Class definition:
 */
class CControlSAP : public CBaseSap, public IT120ControlSAP
{
    friend class GCCController;
    friend class CConf;
    friend class CAppRosterMgr; // for AppRosterReportIndication()
    friend class MCSUser; // for ForwardedConfJoinIndication()

    friend LRESULT CALLBACK SapNotifyWndProc(HWND, UINT, WPARAM, LPARAM);

public:

    CControlSAP(void);
    ~CControlSAP(void);

    HWND GetHwnd ( void ) { return m_hwndNotify; }

    //
    // Node Controller (NC conference manager) callback
    //
    void RegisterNodeController ( LPFN_T120_CONTROL_SAP_CB pfn, LPVOID user_defined )
    {
        m_pfnNCCallback = pfn;
        m_pNCData = user_defined;
    }
    void UnregisterNodeController ( void )
    {
        m_pfnNCCallback = NULL;
        m_pNCData = NULL;
    }


    //
    // IT120ControlSAP
    //

    STDMETHOD_(void, ReleaseInterface) (THIS);

    /*
     *  GCCError    ConfCreateRequest()
     *        This routine is a request to create a new conference. Both 
     *        the local node and the node to which the create conference 
     *        request is directed to, join the conference automatically.  
     */
    STDMETHOD_(GCCError, ConfCreateRequest) (THIS_
                    GCCConfCreateRequest *,
                    GCCConfID *);

    /*    
     *  GCCError    ConfCreateResponse()
     *        This procedure is a remote node controller's response to a con-
     *        ference creation request by the convener. 
     */

    STDMETHOD_(GCCError, ConfCreateResponse) (THIS_
                    GCCNumericString            conference_modifier,
                    GCCConfID,
                    BOOL                        use_password_in_the_clear,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    ConfQueryRequest()
     *        This routine is a request to query a node for information about the
     *        conferences that exist at that node.
     */
    STDMETHOD_(GCCError, ConfQueryRequest) (THIS_
                    GCCNodeType                 node_type,
                    GCCAsymmetryIndicator      *asymmetry_indicator,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL                        fSecure,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle);

    STDMETHOD_(void, CancelConfQueryRequest) (THIS_
                    ConnectionHandle);

    /*
     *  GCCError    ConfQueryResponse()
     *        This routine is called in response to a conference query request.
     */
    STDMETHOD_(GCCError, ConfQueryResponse) (THIS_
                    GCCResponseTag              query_response_tag,
                    GCCNodeType                 node_type,
                    GCCAsymmetryIndicator      *asymmetry_indicator,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    AnnouncePresenceRequest()
     *        This routine is invoked by node controller when a node joins a 
     *        conference, to announce the presence of the new node to all
     *        other nodes of the conference. This should be followed by a
     *        GCCConferenceReport indication by the GCC to all nodes.
     */
    STDMETHOD_(GCCError, AnnouncePresenceRequest) (THIS_
                    GCCConfID,
                    GCCNodeType                 node_type,
                    GCCNodeProperties           node_properties,
                    LPWSTR                      pwszNodeName,
                    UINT                        number_of_participants,
                    LPWSTR                     *ppwszParticipantNameList,
                    LPWSTR                      pwszSiteInfo,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **network_address_list,
                    LPOSTR                      alternative_node_id,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list);

    /*
     *  GCCError    ConfJoinRequest()
     *        This routine is invoked by node controller to cause the local
     *        node to join an existing conference.    
     */
    STDMETHOD_(GCCError, ConfJoinRequest) (THIS_
                    GCCConferenceName          *conference_name,
                    GCCNumericString            called_node_modifier,
                    GCCNumericString            calling_node_modifier,
                    GCCPassword                *convener_password,
                    GCCChallengeRequestResponse*password_challenge,
                    LPWSTR                      pwszCallerID,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL						fSecure,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle,
                    GCCConfID                  *pnConfID);

    /*
     *  GCCError    ConfJoinResponse()
     *        This routine is remote node controller's response to conference join 
     *        request by the local node controller.
     */
    STDMETHOD_(GCCError, ConfJoinResponse) (THIS_
                    GCCResponseTag              join_response_tag,
                    GCCChallengeRequestResponse*password_challenge,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    ConfInviteRequest()
     *        This routine is invoked by node controller to invite a node  
     *        to join a conference.
     */
    STDMETHOD_(GCCError, ConfInviteRequest) (THIS_
                    GCCConfID,
                    LPWSTR                      pwszCallerID,
                    TransportAddress            calling_address,
                    TransportAddress            called_address,
                    BOOL						fSecure,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    ConnectionHandle           *connection_handle);

    STDMETHOD_(void, CancelInviteRequest) (THIS_
                    GCCConfID,
                    ConnectionHandle);

    /*
     *  GCCError    ConfInviteResponse()
     *        This routine is invoked by node controller to respond to an
     *        invite indication.
     */
    STDMETHOD_(GCCError, ConfInviteResponse) (THIS_
                    GCCConfID,
                    GCCNumericString            conference_modifier,
                    BOOL						fSecure,
                    DomainParameters           *domain_parameters,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **local_network_address_list,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    ConfAddResponse()
     */
    STDMETHOD_(GCCError, ConfAddResponse) (THIS_
                    GCCResponseTag              app_response_tag,
                    GCCConfID,
                    UserID                      requesting_node,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list,
                    GCCResult);

    /*
     *  GCCError    ConfLockResponse()
     *        This routine is invoked by node controller to respond to a
     *        lock indication.
     */
    STDMETHOD_(GCCError, ConfLockResponse) (THIS_
                    GCCConfID,
                    UserID                      requesting_node,
                    GCCResult);

    /*
     *  GCCError    ConfDisconnectRequest()
     *        This routine is used by a node controller to disconnect itself
     *        from a specified conference. GccConferenceDisconnectIndication
     *        sent to all other nodes of the conference. This is for client 
     *        initiated case.
     */
    STDMETHOD_(GCCError, ConfDisconnectRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConfEjectUserRequest()
     */
    STDMETHOD_(GCCError, ConfEjectUserRequest) (THIS_
                    GCCConfID,
                    UserID                      ejected_node_id,
                    GCCReason);

    /*
     *  GCCError    AppletInvokeRequest()
     */
    STDMETHOD_(GCCError, AppletInvokeRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_app_protcol_entities,
                    GCCAppProtocolEntity      **app_protocol_entity_list,
                    UINT                        number_of_destination_nodes,
                    UserID                     *list_of_destination_nodes);

    /*
     *  GCCError    ConfRosterInqRequest()
     *        This routine is invoked to request a conference roster.  It can be
     *        called by either the Node Controller or the client application.
     */
    STDMETHOD_(GCCError, ConfRosterInqRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConductorGiveResponse()
     */
    STDMETHOD_(GCCError, ConductorGiveResponse) (THIS_
                    GCCConfID,
                    GCCResult);

    /*
     *  GCCError    ConfTimeRemainingRequest()
     */
    STDMETHOD_(GCCError, ConfTimeRemainingRequest) (THIS_
                    GCCConfID,
                    UINT                        time_remaining,
                    UserID                      node_id);



    STDMETHOD_(GCCError, GetParentNodeID) (THIS_
                    GCCConfID,
                    GCCNodeID *);

#ifdef JASPER // ------------------------------------------------
    /*
     *  GCCError    ConfAddRequest()
     */
    STDMETHOD_(GCCError, ConfAddRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_network_addresses,
                    GCCNetworkAddress         **network_address_list,
                    UserID                      adding_node,
                    UINT                         number_of_user_data_members,
                    GCCUserData               **user_data_list);

    /*
     *  GCCError    ConfLockRequest()
     *        This routine is invoked by node controller to lock a conference.
     */
    STDMETHOD_(GCCError, ConfLockRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConfUnlockRequest()
     *        This routine is invoked by node controller to unlock a conference.
     */
    STDMETHOD_(GCCError, ConfUnlockRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConfUnlockResponse()
     *        This routine is invoked by node controller to respond to an
     *        unlock indication.
     */
    STDMETHOD_(GCCError, ConfUnlockResponse) (
                    GCCConfID,
                    UserID                      requesting_node,
                    GCCResult);

    /*
     *  GCCError    ConfTerminateRequest()
     */
    STDMETHOD_(GCCError, ConfTerminateRequest) (THIS_
                    GCCConfID,
                    GCCReason);

    /*
     *  GCCError    ConfTransferRequest()
     */
    STDMETHOD_(GCCError, ConfTransferRequest) (THIS_
                    GCCConfID,
                    GCCConferenceName          *destination_conference_name,
                    GCCNumericString            destination_conference_modifier,
                    UINT                        number_of_destination_addresses,
                    GCCNetworkAddress         **destination_address_list,
                    UINT                        number_of_destination_nodes,
                    UserID                     *destination_node_list,
                    GCCPassword                *password);

    /*
     *  GCCError    ConductorAssignRequest()
     */
    STDMETHOD_(GCCError, ConductorAssignRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConductorReleaseRequest()
     */
    STDMETHOD_(GCCError, ConductorReleaseRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConductorPleaseRequest()
     */
    STDMETHOD_(GCCError, ConductorPleaseRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConductorGiveRequest()
     */
    STDMETHOD_(GCCError, ConductorGiveRequest) (THIS_
                    GCCConfID,
                    UserID                      recipient_user_id);

    /*
     *  GCCError    ConductorPermitAskRequest()
     */
    STDMETHOD_(GCCError, ConductorPermitAskRequest) (THIS_
                            GCCConfID,
                            BOOL                grant_permission);

    /*
     *  GCCError    ConductorPermitGrantRequest()
     */
    STDMETHOD_(GCCError, ConductorPermitGrantRequest) (THIS_
                    GCCConfID,
                    UINT                        number_granted,
                    UserID                     *granted_node_list,
                    UINT                        number_waiting,
                    UserID                     *waiting_node_list);

    /*
     *  GCCError    ConductorInquireRequest()
     */
    STDMETHOD_(GCCError, ConductorInquireRequest) (THIS_
                    GCCConfID);

    /*
     *  GCCError    ConfTimeInquireRequest()
     */
    STDMETHOD_(GCCError, ConfTimeInquireRequest) (THIS_
                    GCCConfID,
                    BOOL                        time_is_conference_wide);

    /*
     *  GCCError    ConfExtendRequest()
     */
    STDMETHOD_(GCCError, ConfExtendRequest) (THIS_
                    GCCConfID,
                    UINT                        extension_time,
                    BOOL                        time_is_conference_wide);

    /*
     *  GCCError    ConfAssistanceRequest()
     */
    STDMETHOD_(GCCError, ConfAssistanceRequest) (THIS_
                    GCCConfID,
                    UINT                        number_of_user_data_members,
                    GCCUserData               **user_data_list);

    /*
     *  GCCError    TextMessageRequest()
     */
    STDMETHOD_(GCCError, TextMessageRequest) (THIS_
                    GCCConfID,
                    LPWSTR                      pwszTextMsg,
                    UserID                      destination_node);
#endif // JASPER // ------------------------------------------------


#ifdef NM_RESET_DEVICE
    GCCError	ResetDevice ( LPSTR device_identifier );
#endif // NM_RESET_DEVICE

protected:

    //
    // These methods are called by GCC Controller.
    //

    GCCError	ConfCreateIndication (
    			PGCCConferenceName			conference_name,
    			GCCConfID   				conference_id,
    			CPassword                   *convener_password,
    			CPassword                   *password,
    			BOOL						conference_is_locked,
    			BOOL						conference_is_listed,
    			BOOL						conference_is_conductible,
    			GCCTerminationMethod		termination_method,
    			PPrivilegeListData			conductor_privilege_list,
    			PPrivilegeListData			conduct_mode_privilege_list,
    			PPrivilegeListData			non_conduct_privilege_list,
    			LPWSTR						pwszConfDescriptor,
    			LPWSTR						pwszCallerID,
    			TransportAddress			calling_address,
    			TransportAddress			called_address,
    			PDomainParameters			domain_parameters,
    			CUserDataListContainer      *user_data_list,
    			ConnectionHandle			connection_handle);

    GCCError	ConfQueryIndication (
    			GCCResponseTag				query_response_tag,
    			GCCNodeType					node_type,
    			PGCCAsymmetryIndicator		asymmetry_indicator,
    			TransportAddress			calling_address,
    			TransportAddress			called_address,
    			CUserDataListContainer      *user_data_list,
    			ConnectionHandle			connection_handle);

    GCCError	ConfQueryConfirm (
    			GCCNodeType					node_type,
    			PGCCAsymmetryIndicator		asymmetry_indicator,
    			CConfDescriptorListContainer *conference_list,
    			CUserDataListContainer      *user_data_list,
    			GCCResult					result,
    			ConnectionHandle			connection_handle);

    GCCError	ConfJoinIndication (
    			GCCConfID   				conference_id,
    			CPassword                   *convener_password,
    			CPassword                   *password_challenge,
    			LPWSTR						pwszCallerID,
    			TransportAddress			calling_address,
    			TransportAddress			called_address,
    			CUserDataListContainer      *user_data_list,
    			BOOL						intermediate_node,
    			ConnectionHandle			connection_handle);

    GCCError	ConfInviteIndication (
    			GCCConfID   			conference_id,
    			PGCCConferenceName		conference_name,
    			LPWSTR					pwszCallerID,
    			TransportAddress		calling_address,
    			TransportAddress		called_address,
		        BOOL					fSecure,
    			PDomainParameters 		domain_parameters,
    			BOOL					clear_password_required,
    			BOOL					conference_is_locked,
    			BOOL					conference_is_listed,
    			BOOL					conference_is_conductible,
    			GCCTerminationMethod	termination_method,
    			PPrivilegeListData		conductor_privilege_list,
    			PPrivilegeListData		conducted_mode_privilege_list,
    			PPrivilegeListData		non_conducted_privilege_list, 
    			LPWSTR					pwszConfDescriptor, 
    			CUserDataListContainer  *user_data_list,
    			ConnectionHandle		connection_handle);

#ifdef TSTATUS_INDICATION
    GCCError	TransportStatusIndication (
    				PTransportStatus		transport_status);

    GCCError	StatusIndication (
    				GCCStatusMessageType	status_message,
    				UINT					parameter);
#endif // TSTATUS_INDICATION

    GCCError	ConnectionBrokenIndication (
    				ConnectionHandle		connection_handle);

    //
    // These methods are called by CConf.
    //

    GCCError	ConfCreateConfirm (
    				PGCCConferenceName	  	conference_name,
    				GCCNumericString		conference_modifier,
    				GCCConfID   			conference_id,
    				PDomainParameters		domain_parameters,
    				CUserDataListContainer  *user_data_list,
    				GCCResult				result,
    				ConnectionHandle		connection_handle);

    GCCError	ConfDisconnectConfirm (
    			GCCConfID   		  			conference_id,
    			GCCResult						result);

    GCCError	ConfPermissionToAnnounce (
    				GCCConfID   			conference_id,
    				UserID					gcc_node_id);

    GCCError	ConfAnnouncePresenceConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConfDisconnectIndication (
    				GCCConfID   			conference_id,
    				GCCReason				reason,
    				UserID					disconnected_node_id);

    GCCError  	ForwardedConfJoinIndication (
    				UserID					sender_id,
    				GCCConfID   			conference_id,
    				CPassword               *convener_password,
    				CPassword               *password_challange,
    				LPWSTR					pwszCallerID,
    				CUserDataListContainer  *user_data_list);

    GCCError  	ConfJoinConfirm (
    				PGCCConferenceName		conference_name,
    				GCCNumericString		remote_modifier,
    				GCCNumericString		local_modifier,
    				GCCConfID   			conference_id,
    				CPassword               *password_challenge,
    				PDomainParameters		domain_parameters,
    				BOOL					password_in_the_clear,
    				BOOL					conference_locked,
    				BOOL					conference_listed,
    				BOOL					conference_conductible,
    				GCCTerminationMethod	termination_method,
    				PPrivilegeListData		conductor_privilege_list,
    				PPrivilegeListData		conduct_mode_privilege_list,
    				PPrivilegeListData		non_conduct_privilege_list,
    				LPWSTR					pwszConfDescription,
    				CUserDataListContainer  *user_data_list,	
    				GCCResult				result,
    				ConnectionHandle		connection_handle,
    				PBYTE                   pbRemoteCred,
    				DWORD                   cbRemoteCred);

    GCCError	ConfInviteConfirm (
    				GCCConfID   			conference_id,
    				CUserDataListContainer  *user_data_list,
    				GCCResult				result,
    				ConnectionHandle		connection_handle);

    GCCError	ConfTerminateIndication (
    				GCCConfID   			conference_id,
    				UserID					requesting_node_id,
    				GCCReason				reason);

    GCCError	ConfLockIndication (
    				GCCConfID   			conference_id,
    				UserID					source_node_id);

    GCCError	ConfEjectUserIndication (
    				GCCConfID   			conference_id,
    				GCCReason				reason,
    				UserID					gcc_node_id);

    GCCError	ConfTerminateConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConductorGiveIndication (
    				GCCConfID   			conference_id);

    GCCError	ConfTimeInquireIndication (
    				GCCConfID   			conference_id,
    				BOOL					time_is_conference_wide,
    				UserID					requesting_node_id);

#ifdef JASPER
    GCCError 	ConfLockReport (
    				GCCConfID   			conference_id,
    				BOOL					conference_is_locked);

    GCCError	ConfLockConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConfUnlockIndication (
    				GCCConfID   			conference_id,
    				UserID					source_node_id);

    GCCError 	ConfUnlockConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConfEjectUserConfirm (
    				GCCConfID   			conference_id,
    				UserID					ejected_node_id,
    				GCCResult				result);

    GCCError	ConductorAssignConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConductorReleaseConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConductorPleaseIndication (
    				GCCConfID   			conference_id,
    				UserID					requester_user_id);

    GCCError	ConductorPleaseConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConductorGiveConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id,
    				UserID					recipient_node);

    GCCError	ConductorPermitAskIndication (
    				GCCConfID   			conference_id,
    				BOOL					grant_flag,
    				UserID					requester_id);

    GCCError	ConductorPermitAskConfirm (
    				GCCResult				result,
    				BOOL					grant_permission,
    				GCCConfID   			conference_id);

    GCCError	ConductorPermitGrantConfirm (
    				GCCResult				result,
    				GCCConfID   			conference_id);

    GCCError	ConfTimeRemainingIndication (
    				GCCConfID   			conference_id,
    				UserID					source_node_id,
    				UserID					node_id,
    				UINT					time_remaining);

    GCCError	ConfTimeRemainingConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConfTimeInquireConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConfExtendIndication (
    				GCCConfID   			conference_id,
    				UINT					extension_time,
    				BOOL					time_is_conference_wide,
    				UserID                  requesting_node_id);

    GCCError 	ConfExtendConfirm (
    				GCCConfID   			conference_id,
    				UINT					extension_time,
    				GCCResult				result);

    GCCError	ConfAssistanceIndication (
    				GCCConfID   			conference_id,
    				CUserDataListContainer  *user_data_list,
    				UserID					source_node_id);

    GCCError	ConfAssistanceConfirm (
    				GCCConfID   	 		conference_id,
    				GCCResult				result);

    GCCError	TextMessageIndication (
    				GCCConfID   			conference_id,
    				LPWSTR					pwszTextMsg,
    				UserID					source_node_id);

    GCCError	TextMessageConfirm (
    				GCCConfID   			conference_id,
    				GCCResult				result);

    GCCError	ConfTransferIndication (
    				GCCConfID   		conference_id,
    				PGCCConferenceName	destination_conference_name,
    				GCCNumericString	destination_conference_modifier,
    				CNetAddrListContainer *destination_address_list,
    				CPassword           *password);

    GCCError	ConfTransferConfirm (
    				GCCConfID   		conference_id,
    				PGCCConferenceName	destination_conference_name,
    				GCCNumericString	destination_conference_modifier,
    				UINT				number_of_destination_nodes,
    				PUserID				destination_node_list,
    				GCCResult			result);
#endif // JASPER

    GCCError	ConfAddIndication (
    				GCCConfID   		conference_id,
    				GCCResponseTag		add_response_tag,
    				CNetAddrListContainer *network_address_list,
    				CUserDataListContainer *user_data_list,
    				UserID				requesting_node);

    GCCError	ConfAddConfirm (
    				GCCConfID   		conference_id,
    				CNetAddrListContainer *network_address_list,
    				CUserDataListContainer *user_data_list,
    				GCCResult			result);

    GCCError	SubInitializationCompleteIndication (
    				UserID				user_id,
    				ConnectionHandle	connection_handle);

    /* ------ pure virtual in CBaseSap (shared with CAppSap) ------ */

    GCCError	ConfRosterInquireConfirm (
    					GCCConfID,
    					PGCCConferenceName,
    					LPSTR           			conference_modifier,
    					LPWSTR						pwszConfDescriptor,
    					CConfRoster *,
    					GCCResult,
    					GCCAppSapMsgEx **);

    GCCError	AppRosterInquireConfirm (
    					GCCConfID,
    					CAppRosterMsg *,
    					GCCResult,
                        GCCAppSapMsgEx **);

    GCCError	ConductorInquireConfirm (
    					GCCNodeID				nidConductor,
    					GCCResult,
    					BOOL					permission_flag,
    					BOOL					conducted_mode,
    					GCCConfID);

    GCCError AppInvokeConfirm (
                        GCCConfID,
                        CInvokeSpecifierListContainer *,
                        GCCResult,
                        GCCRequestTag);

    GCCError AppInvokeIndication (
                        GCCConfID,
                        CInvokeSpecifierListContainer *,
                        GCCNodeID nidInvoker);

    GCCError ConfRosterReportIndication ( GCCConfID, CConfRosterMsg * );

    GCCError AppRosterReportIndication ( GCCConfID, CAppRosterMsg * );


    /* ------ from CBaseSap ------ */

	GCCError	ConductorAssignIndication (
					UserID					conductor_user_id,
					GCCConfID   			conference_id);

	GCCError	ConductorReleaseIndication (
					GCCConfID   			conference_id);

	GCCError	ConductorPermitGrantIndication (
					GCCConfID   			conference_id,
					UINT					number_granted,
					GCCNodeID				*granted_node_list,
					UINT					number_waiting,
					GCCNodeID				*waiting_node_list,
					BOOL					permission_is_granted);

protected:

    void NotifyProc ( GCCCtrlSapMsgEx * );
    void WndMsgHandler ( UINT uMsg, WPARAM wParam, LPARAM lParam );

private:

    GCCCtrlSapMsgEx * CreateCtrlSapMsgEx ( GCCMessageType, BOOL fUseToDelete = FALSE );
    void FreeCtrlSapMsgEx ( GCCCtrlSapMsgEx * );

#if defined(GCCNC_DIRECT_INDICATION) || defined(GCCNC_DIRECT_CONFIRM)
    void SendCtrlSapMsg ( GCCCtrlSapMsg *pCtrlSapMsg );
#endif // GCCNC_DIRECT_INDICATION

    void PostCtrlSapMsg ( GCCCtrlSapMsgEx *pCtrlSapMsgEx );
    void PostConfirmCtrlSapMsg ( GCCCtrlSapMsgEx *pCtrlSapMsgEx ) { PostCtrlSapMsg(pCtrlSapMsgEx); }
    void PostIndCtrlSapMsg ( GCCCtrlSapMsgEx *pCtrlSapMsgEx ) { PostCtrlSapMsg(pCtrlSapMsgEx); }

    void PostAsynDirectConfirmMsg ( UINT uMsg, WPARAM wParam, GCCConfID nConfID )
    {
        ASSERT(NULL != m_hwndNotify);
        ::PostMessage(m_hwndNotify, CSAPCONFIRM_BASE + uMsg, wParam, (LPARAM) nConfID);
    }

    void PostAsynDirectConfirmMsg ( UINT uMsg, GCCResult nResult, GCCConfID nConfID )
    {
        PostAsynDirectConfirmMsg(uMsg, (WPARAM) nResult, nConfID);
    }

    void PostAsynDirectConfirmMsg ( UINT uMsg, GCCResult nResult, GCCNodeID nid, GCCConfID nConfID )
    {
        PostAsynDirectConfirmMsg(uMsg, (WPARAM) MAKELONG(nResult, nid), nConfID);
    }

    void PostAsynDirectConfirmMsg ( UINT uMsg, GCCReason nReason, GCCNodeID nid, GCCConfID nConfID )
    {
        PostAsynDirectConfirmMsg(uMsg, (WPARAM) MAKELONG(nReason, nid), nConfID);
    }

    void PostAsynDirectConfirmMsg ( UINT uMsg, GCCResult nResult, BOOL flag, GCCConfID nConfID )
    {
        flag = ! (! flag);  // to make sure it is either TRUE or FALSE
        ASSERT(flag == TRUE || flag == FALSE);
        PostAsynDirectConfirmMsg(uMsg, (WPARAM) MAKELONG(nResult, flag), nConfID);
    }


    void HandleResourceFailure ( void )
    {
        ERROR_OUT(("CSAPHandleResourceFailure: Resource Error occurred"));
        #ifdef TSTATUS_INDICATION
        StatusIndication(GCC_STATUS_CTL_SAP_RESOURCE_ERROR, 0);
        #endif
    }
    void HandleResourceFailure ( GCCError rc )
    {
        if (GCC_ALLOCATION_FAILURE == rc)
        {
            HandleResourceFailure();
        }
    }

    GCCError		QueueJoinIndication (
    					GCCResponseTag				response_tag,
    					GCCConfID   				conference_id,
    					CPassword                   *convener_password,
    					CPassword                   *password_challenge,
    					LPWSTR						pwszCallerID,
    					TransportAddress			calling_address,
    					TransportAddress			called_address,
    					CUserDataListContainer      *user_data_list,
    					BOOL						intermediate_node,
    					ConnectionHandle			connection_handle);
    					
    BOOL			IsNumericNameValid ( GCCNumericString );

    BOOL			IsTextNameValid ( LPWSTR );

    GCCError		RetrieveUserDataList (
    					CUserDataListContainer  *user_data_list_object,
    					UINT					*number_of_data_members,
    					PGCCUserData 			**user_data_list,
    					LPBYTE                  *ppUserDataMemory);

private:

    //
    // Node Controller (NC conference manager) callback
    //
    LPFN_T120_CONTROL_SAP_CB    m_pfnNCCallback;
    LPVOID                      m_pNCData;

    GCCResponseTag              m_nJoinResponseTag;
    CJoinResponseTagList2       m_JoinResponseTagList2;
};


extern CControlSAP *g_pControlSap;


//
// Some handy utility functions to set up DataToBeDeleted in GCCCtrlSapMsgEx.
//
#ifdef GCCNC_DIRECT_INDICATION

__inline void
CSAP_CopyDataToGCCMessage_ConfName
(
    GCCConfName     *pSrcConfName,
    GCCConfName     *pDstConfName
)
{
    *pDstConfName = *pSrcConfName;
}

__inline void
CSAP_CopyDataToGCCMessage_Modifier
(
    GCCNumericString    pszSrc,
    GCCNumericString    *ppszDst
)
{
    *ppszDst = pszSrc;
}

__inline void
CSAP_CopyDataToGCCMessage_Password
(
    CPassword           *pSrcPassword,
    GCCPassword         **ppDstPassword
)
{
    *ppDstPassword = NULL;
    if (NULL != pSrcPassword)
    {
        pSrcPassword->LockPasswordData();
        pSrcPassword->GetPasswordData(ppDstPassword);
    }
}

__inline void
CSAP_CopyDataToGCCMessage_Challenge
(
    CPassword                       *pSrcPassword,
    GCCChallengeRequestResponse     **ppDstChallenge
)
{
    *ppDstChallenge = NULL;
    if (pSrcPassword != NULL)
    {
        pSrcPassword->LockPasswordData();
        pSrcPassword->GetPasswordChallengeData(ppDstChallenge);
    }
}

__inline void
CSAP_CopyDataToGCCMessage_PrivilegeList
(
    PrivilegeListData       *pSrcPrivilegeListData,
    GCCConfPrivileges       **ppDstPrivileges,
    GCCConfPrivileges       *pDstPlaceHolder
)
{
    if (pSrcPrivilegeListData != NULL)
    {
        *ppDstPrivileges = pDstPlaceHolder;
        *pDstPlaceHolder = *(pSrcPrivilegeListData->GetPrivilegeListData());
    }
    else
    {
        *ppDstPrivileges = NULL;
    }
}

__inline void
CSAP_CopyDataToGCCMessage_IDvsDesc
(
    LPWSTR          pwszSrc,
    LPWSTR          *ppwszDst
)
{
    *ppwszDst = pwszSrc;
}

__inline void
CSAP_CopyDataToGCCMessage_Call
(
    TransportAddress    pszSrcTransportAddr,
    TransportAddress    *ppszDstTransportAddr
)
{
    *ppszDstTransportAddr = pszSrcTransportAddr;
}

__inline void
CSAP_CopyDataToGCCMessage_DomainParams
(
    DomainParameters    *pSrcDomainParams,
    DomainParameters    **ppDstDomainParams,
    DomainParameters    *pDstPlaceHolder
)
{
    if (pSrcDomainParams != NULL)
    {
        *ppDstDomainParams = pDstPlaceHolder;
        *pDstPlaceHolder = *pSrcDomainParams;
    }
    else
    {
        *ppDstDomainParams = NULL;
    }
}

#endif // GCCNC_DIRECT_CALLBACK


void CSAP_CopyDataToGCCMessage_ConfName(
				PDataToBeDeleted		data_to_be_deleted,
				PGCCConferenceName		source_conference_name,
				PGCCConferenceName		destination_conference_name,
				PGCCError				pRetCode);

void CSAP_CopyDataToGCCMessage_Modifier(
				BOOL					fRemoteModifier,
				PDataToBeDeleted		data_to_be_deleted,
				GCCNumericString		source_numeric_string,
				GCCNumericString		*destination_numeric_string,
				PGCCError				pRetCode);

void CSAP_CopyDataToGCCMessage_Password(
				BOOL					fConvener,
				PDataToBeDeleted		data_to_be_deleted,
				CPassword               *source_password,
				PGCCPassword			*destination_password,
				PGCCError				pRetCode);

void CSAP_CopyDataToGCCMessage_Challenge(
				PDataToBeDeleted				data_to_be_deleted,
				CPassword                       *source_password,
				PGCCChallengeRequestResponse	*password_challenge,
				PGCCError						pRetCode);

void CSAP_CopyDataToGCCMessage_PrivilegeList(
				PPrivilegeListData			source_privilege_list_data,
				PGCCConferencePrivileges	*destination_privilege_list,
				PGCCError					pRetCode);

void CSAP_CopyDataToGCCMessage_IDvsDesc(
				BOOL				fCallerID,
				PDataToBeDeleted	data_to_be_deleted,
				LPWSTR				source_text_string,
				LPWSTR				*destination_text_string,
				PGCCError			pRetCode);

void CSAP_CopyDataToGCCMessage_Call(
				BOOL				fCalling,
				PDataToBeDeleted	data_to_be_deleted,
				TransportAddress	source_transport_address,
				TransportAddress	*destination_transport_address,
				PGCCError			pRetCode);

void CSAP_CopyDataToGCCMessage_DomainParams(
				PDataToBeDeleted	data_to_be_deleted,
				PDomainParameters	source_domain_parameters,
				PDomainParameters	*destination_domain_parameters,
				PGCCError			pRetCode);

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CControlSAP (		UINT        				owner_message_base,
 *						UINT						application_messsage_base);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This is the control sap constructor. It is responsible for
 *		registering control sap with the application interface via
 *		an owner callback.
 *
 *	Formal Parameters:
 *		owner_object			(i) The owner of this object (the controller)
 *		owner_message_base		(i) Offset into the controller callback message
 *										base.
 *		application_object		(i) The node controller interface object.
 *		application_messsage_base	(i) Offset into the node controller callback
 *											message base.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~ControlSap ();
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This is the CControlSAP destructor.  It is responsible for 
 *		flushing any pending upward bound messages and freeing all
 *		the resources tied up with pending messages.  Also it clears 
 *		the message queue and the queue of command targets that are registered
 *		with it.  Actually all command targets at this point should 
 *		already have been unregistered but this is just a double check.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfCreateRequest(
 *						PGCCConferenceName			conference_name,
 *						GCCNumericString			conference_modifier,
 *						PGCCPassword				convener_password,
 *						PGCCPassword				password,
 *						BOOL						use_password_in_the_clear,
 *						BOOL						conference_is_locked,
 *						BOOL						conference_is_listed,
 *						BOOL						conference_is_conductible,
 *						GCCTerminationMethod		termination_method,
 *						PGCCConferencePrivileges	conduct_privilege_list,
 *						PGCCConferencePrivileges	conduct_mode_privilege_list,
 *						PGCCConferencePrivileges	non_conduct_privilege_list,
 *						LPWSTR						pwszConfDescriptor,
 *						LPWSTR						pwszCallerID,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						PDomainParameters 			domain_parameters,
 *						UINT        				number_of_network_addresses,
 *						PGCCNetworkAddress 		*	local_network_address_list,
 *						UINT					   	number_of_user_data_members,
 *						PGCCUserData			*	user_data_list,				 
 *						PConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		create request from the node controller.  This function just passes this 
 *		request	to the controller via an owner callback. 
 *
 *	Formal Parameters:
 *		conference_name				(i) Name of the conference.
 *		conference_modifier			(i) Conference modifier numeric string.
 *		convener_password			(i) Password used for convener privileges.
 *		password					(i) Password used for conference create.
 *		use_password_in_the_clear	(i) Flag indicating use clear password.
 *		conference_is_locked		(i) Flag indicating if conference is locked.
 *		conference_is_listed		(i) Flag indicating if conference is listed
 *											in roster.
 *		conference_is_conductible	(i) Flag indicating if conference is
 *											conductable.
 *		termination_method			(i) Method of termination to use.
 *		conduct_privilege_list		(i) List of conductor privileges.
 *		conduct_mode_privilege_list	(i) List of privileges available when in
 *											conducted mode.
 *		non_conduct_privilege_list	(i) List of privileges available when not
 *											in conducted mode.
 *		pwszConfDescriptor			(i) Conference descriptor string.
 *		pwszCallerID				(i) Caller identifier string.
 *		calling_address				(i) Transport address of caller.
 *		called_address				(i) Transport address of party being called.
 *		domain_parameters			(i) Structure holding domain parameters.
 *		number_of_network_addresses	(i) Number of network addresses.
 *		local_network_address_list	(i) List of local network addresses.
 *		number_of_user_data_members	(i) Number of items in user data list.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE_NAME		- Invalid conference name passed in.
 *		GCC_INVALID_CONFERENCE_MODIFIER - Invalid conference modifier passed.
 *		GCC_FAILURE_CREATING_DOMAIN		- Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			- Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	- Bad network address type passed in.
 *		GCC_CONFERENCE_ALREADY_EXISTS	- Conference specified already exists.
 *		GCC_INVALID_TRANSPORT			- Cannot find specified transport.
 *		GCC_INVALID_ADDRESS_PREFIX		- Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Bad transport address
 *		GCC_INVALID_PASSWORD			- Invalid password passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_BAD_CONNECTION_HANDLE_POINTER - Null connection handle ptr passed in
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfCreateResponse (
 *						PGCCConferenceName			conference_name,
 *						GCCNumericString			conference_modifier,
 *						GCCConfID   				conference_id,
 *						BOOL						use_password_in_the_clear,
 *						PDomainParameters 			domain_parameters,
 *						UINT        				number_of_network_addresses,
 *						PGCCNetworkAddress 		*	local_network_address_list,
 *						UINT					   	number_of_user_data_members,
 *						PGCCUserData			*	user_data_list,				 
 *						GCCResult				 	result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		create response from the node controller, to be sent to the provider
 *		that issued the conference create request. This function just passes 
 *		this request to the controller via an owner callback. 
 *
 *	Formal Parameters:
 *		conference_name				(i) Name of conference.
 *		conference_modifier			(i) Conference modifier numeric string.
 *		conference_id				(i) Conference ID.
 *		use_password_in_the_clear	(i) Flag indicating password is clear.
 *		domain_parameters			(i) Structure holding domain parameters.
 *		number_of_network_addresses	(i) Number of local network addresses.
 *		local_network_address_list	(i) List of local network addresses.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list,				(i) List of user data items.
 *		result						(i) Result code for the create.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- An invalid conference was passed in.
 *		GCC_INVALID_CONFERENCE_NAME		- Invalid conference name passed in.
 *		GCC_INVALID_CONFERENCE_MODIFIER - Invalid conference modifier passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		- Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	- Conference specified already exists.
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfQueryRequest (
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						UINT				   		number_of_user_data_members,
 *						PGCCUserData			*	user_data_list,
 *						PConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		query request from the node controller. This function just passes 
 *		this request to the controller via an owner callback.   
 *
 *	Formal Parameters:
 *		node_type					(i)	Type of node (terminal, MCU, both).
 *		asymmetry_indicator			(i) Structure used to indicate caller and
 *											called nodes.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of node being called.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR						- No error occurred.
 *		GCC_ALLOCATION_FAILURE				- A resource error occurred.
 *		GCC_INVALID_ADDRESS_PREFIX			- Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT				- Bad transport address passed in.
 *		GCC_BAD_USER_DATA					- Invalid user data passed in.
 *		GCC_INVALID_TRANSPORT_ADDRESS		- Bad transport address passed in.
 *		GCC_BAD_CONNECTION_HANDLE_POINTER	- Bad connection handle ptr. passed.
 *		GCC_INVALID_NODE_TYPE				- Invalid node type passed in.
 *		GCC_INVALID_ASYMMETRY_INDICATOR		- Asymmetry indicator has invalid
 *													type.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfQueryResponse (
 *						GCCResponseTag				query_response_tag,
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						UINT				   		number_of_user_data_members,
 *						PGCCUserData			*	user_data_list,
 *						GCCResult					result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the DLL interface when it gets a conference 
 *		query response from the node controller.  This function just passes 
 *		this response to the controller via an owner callback.  
 *
 *	Formal Parameters:
 *		query_response_tag			(i) Tag identifying the query response.
 *		node_type					(i) Type of node (terminal, MCU, both).
 *		asymmetry_indicator			(i) Structure used to identify the caller
 *											and called nodes.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result code for query.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_NETWORK_ADDRESS			- Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	- Bad network address type passed in.
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_INVALID_NODE_TYPE			- Invalid node type passed in.
 *		GCC_INVALID_ASYMMETRY_INDICATOR	- Invalid asymmetry indicator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	AnnouncePresenceRequest (
 *						GCCConfID   				conference_id,
 *						GCCNodeType					node_type,
 *						GCCNodeProperties			node_properties,
 *						LPWSTR						node_name,
 *						UINT						number_of_participants,
 *						LPWSTR					*	participant_name_list,
 *						LPWSTR						pwszSiteInfo,
 *						UINT        				number_of_network_addresses,
 *						PGCCNetworkAddress		*	network_address_list,
 *						LPOSTR      				alternative_node_id,
 *						UINT						number_of_user_data_members,
 *						PGCCUserData			*	user_data_list);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets an announce 
 *		presence request from the node controller.  This function passes this
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that control sap maintains. The ConferenceID
 *		passed in is used to index the list of command targets to get the
 *		correct conference.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		node_type					(i) Type of node (terminal, MCU, both).
 *		node_properties				(i) Properties of the node.
 *		node_name					(i) Name of the node.
 *		number_of_participants		(i) Number of participants in the conference
 *		participant_name_list		(i) List of conference participants names.
 *		pwszSiteInfo				(i) Other information about the node.
 *		number_of_network_addresses	(i) Number of local network addresses.
 *		network_address_list		(i) List of local network addresses.
 *		alternative_node_id			(i) ID used to associate announcing node
 *											with an alternative node.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list				(i) List of user data items.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_BAD_NETWORK_ADDRESS			- If an invalid network address is
 *										  		passed in as part of the record.	
 *		GCC_BAD_USER_DATA				- If an invalid user data list is
 *										  		passed in as part of the record.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- Conference object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_NODE_TYPE			- Invalid node type passed in.
 *		GCC_INVALID_NODE_PROPERTIES		- Invalid node properties passed in.
 *		GCC_INVALID_CONFERENCE			- Conference not present.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfJoinRequest (
 *					PGCCConferenceName				conference_name,
 *					GCCNumericString				called_node_modifier,
 *					GCCNumericString				calling_node_modifier,
 *					PGCCPassword					convener_password,
 *					PGCCChallengeRequestResponse	password_challenge,
 *					LPWSTR							pwszCallerID,
 *					TransportAddress				calling_address,
 *					TransportAddress				called_address,
 *					PDomainParameters 				domain_parameters,
 *					UINT        					number_of_network_addresses,
 *					PGCCNetworkAddress			*	local_network_address_list,
 *					UINT						   	number_of_user_data_members,
 *					PGCCUserData				*	user_data_list,
 *					PConnectionHandle				connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		join request from the node controller, to be sent to the top provider
 *		either directly or through a directly connected intermediate provider.
 *	    This function just passes this request to the controller via an owner 
 *		callback.  
 *
 *	Formal Parameters:
 *		conference_name				(i) Name of conference.
 *		called_node_modifier		(i)	Numeric modifier string for called node.
 *		calling_node_modifier		(i) Numeric modifier string for calling node
 *		convener_password			(i) Password used for convener privileges.
 *		password_challenge			(i) Password challenge used for join.
 *		pwszCallerID				(i) Calling node identifier string.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of node being called.
 *		domain_parameters			(i) Structure holding domain parameters.
 *		number_of_network_addresses	(i) Number of local network addresses.
 *		local_network_address_list	(i) List of local network addresses.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list,				(i) List of user data items.
 *		connection_handle			(i)	Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE_NAME		- Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		- Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			- Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	- Bad network address type passed in.
 *		GCC_CONFERENCE_ALREADY_EXISTS	- Conference specified already exists.
 *		GCC_INVALID_ADDRESS_PREFIX		- Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT			- Bad transport address passed in.
 *		GCC_INVALID_PASSWORD			- Invalid password passed in.
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_INVALID_CONFERENCE_MODIFIER	- Invalid conference modifier passed in.
 *		GCC_BAD_CONNECTION_HANDLE_POINTER - Bad connection handle ptr. passed in
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Called address passed in is NULL.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfJoinResponse (
 *					GCCResponseTag					join_response_tag,
 *					PGCCChallengeRequestResponse	password_challenge,
 *					UINT						   	number_of_user_data_members,
 *					PGCCUserData				*	user_data_list,
 *					GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		join response from the node controller.  This routine is responsible
 *		for routing the response to either the conference that made the
 *		request or the controller.  Responses which are routed to a conference
 *		are associated with requests that originate at a subnode that is a
 *		node removed from the Top Provider.
 *
 *	Formal Parameters:
 *		join_response_tag			(i) Tag identifying the join response.
 *		password_challenge			(i) Password challenge structure.
 *		number_of_user_data_members	(i) Number of user data items in list.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result of join.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occurred.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occurred.
 *		GCC_INVALID_JOIN_RESPONSE_TAG	-	No match found for join response tag
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_INVALID_PASSWORD			-	Invalid password passed in.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_INVALID_CONFERENCE			-	Invalid conference ID passed in.
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfInviteRequest (
 *					GCCConfID   					conference_id,
 *					LPWSTR							pwszCallerID,
 *					TransportAddress				calling_address,
 *					TransportAddress				called_address,
 *					UINT						   	number_of_user_data_members,
 *					PGCCUserData				*	user_data_list,
 *					PConnectionHandle				connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		invite request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.  
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		pwszCallerID				(i) Identifier string of calling node.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of node being called. 
 *		number_of_user_data_members	(i) Number of items in user data list.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_INVALID_TRANSPORT_ADDRESS	- Something wrong with transport address
 *		GCC_INVALID_ADDRESS_PREFIX		- Invalid transport address prefix
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_BAD_CONNECTION_HANDLE_POINTER - Connection handle pointer invalid.
 *		GCC_INVALID_CONFERENCE 			- Invalid conference ID passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfInviteResponse (
 *					GCCConfID   					conference_id,
 *					GCCNumericString				conference_modifier,
 *					PDomainParameters 				domain_parameters,
 *					UINT        					number_of_network_addresses,
 *					PGCCNetworkAddress 			*	local_network_address_list,
 *					UINT						   	number_of_user_data_members,
 *					PGCCUserData				*	user_data_list,
 *					GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		invite response from the node controller.  This function passes the
 *		response on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.  
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		conference_modifier			(i) Modifier string for conference.
 *		domain_parameters			(i) Structure holding domain parameters.
 *		number_of_network_addresses	(i) Number of local network addresses.
 *		local_network_address_list	(i) List of local network addresses.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list,				(i) List of user data items.
 *		result						(i)	Result of invitation.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error occurred.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE_NAME		- Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		- Failure creating domain.
 *		GCC_CONFERENCE_ALREADY_EXISTS	- Conference specified already exists.
 *		GCC_BAD_USER_DATA				- Invalid user data passed in.
 *		GCC_INVALID_CONFERENCE			- Invalid conference ID passed in.
 *		GCC_FAILURE_ATTACHING_TO_MCS	- Failure creating MCS user attachment
 *		GCC_INVALID_CONFERENCE_MODIFIER	- Invalid conference modifier passed in.
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfLockRequest (
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		lock request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfLockResponse (
 *						GCCConfID   					conference_id,
 *						UserID							requesting_node,
 *						GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		lock response from the node controller.  This function passes the
 *		response on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		requesting_node				(i) Node ID of the requesting node.
 *		result						(i) Result of conference lock request.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfUnlockRequest (
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		unlock request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfUnlockResponse (
 *						GCCConfID   					conference_id,
 *						UserID							requesting_node,
 *						GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		lock request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		requesting_node				(i) Node ID of the requesting node.
 *		result						(i) Result of conference lock request.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfDisconnectRequest(
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		disconnect request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains. 
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTerminateRequest(
 *						GCCConfID   					conference_id,
 *						GCCReason						reason);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		terminate request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains. 
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		reason						(i) Reason for the termination.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID not valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfDisconnectConfirm (
 *						GCCConfID   		  			conference_id,
 *						GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the Conference when it need to send a 
 *		conference disconnect confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		result						(i) Result of disconnect attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfEjectUserRequest (
 *						GCCConfID   					conference_id,
 *						UserID							ejected_node_id,
 *						GCCReason						reason);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference 
 *		eject user request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains. 
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier.
 *		ejected_node_id				(i) Node ID of node being ejected.
 *		reason						(i) Reason for the ejection.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.	
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_MCS_USER_ID			- Invalid eject node ID.
 *		GCC_INVALID_CONFERENCE			- Invalid conference ID.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorAssignRequest(
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		assign request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorReleaseRequest(
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		release request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPleaseRequest(
 *						GCCConfID   					conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		please request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorGiveRequest(
 *						GCCConfID   					conference_id,
 *						UserID							recipient_user_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		give request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *		recipient_user_id		(i) ID of user to give conductroship to.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_MCS_USER_ID			- Recipient user ID invalid.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorGiveResponse(
 *						GCCConfID   					conference_id,
 *						GCCResult						result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		give response from the node controller.  This function passes the
 *		response on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) The conference identifier.
 *		result					(i) Result of the conductorship give.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_NO_GIVE_RESPONSE_PENDING	- A give indication was never issued.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPermitGrantRequest(
 *						GCCConfID   					conference_id,
 *						UINT							number_granted,
 *						PUserID							granted_node_list,
 *						UINT							number_waiting,
 *						PUserID							waiting_node_list);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conductor
 *		permit grant request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		 conference_id			(i) The conference identifier value.
 *		 number_granted			(i) Number of nodes being granted permission.
 *		 granted_node_list		(i) List of nodes being granted permission.
 *		 number_waiting			(i) Number of nodes waiting for permission.
 *		 waiting_node_list		(i) List of nodes waiting for permission.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_MCS_USER_ID			- Invalid user ID in the granted node
 *												list.
 *		GCC_INVALID_CONFERENCE			- The conference ID is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfTimeRemainingRequest (
 *						GCCConfID   					conference_id,
 *						UINT							time_remaining,
 *						UserID							node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference time
 *		remaining request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id			(i) Conference identifier value.
 *		time_remaining			(i) Time remaining in the conference (in sec.).
 *		node_id					(i) If present, indicates time remaining applies
 *										only to this node.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_MCS_USER_ID			- Invalid node ID.
 *		GCC_INVALID_CONFERENCE			- Invalid conference ID.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfTimeInquireRequest (
 *						GCCConfID   				conference_id,
 *						BOOL						time_is_conference_wide);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference time
 *		inquire request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		time_is_conference_wide		(i) Flag indicating request is for time
 *											remaining in entire conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfExtendRequest (
 *						GCCConfID   				conference_id,
 *						UINT						extension_time,
 *						BOOL						time_is_conference_wide);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		extend request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		extension_time				(i) Amount of time to extend the
 *											conference (in seconds).
 *		time_is_conference_wide		(i) Flag indicating time extension is for
 *											entire conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAssistanceRequest (
 *						GCCConfID   				conference_id,
 *						UINT						number_of_user_data_members,
 *						PGCCUserData		  *		user_data_list);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		assistance request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list				(i) List of user data items.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	TextMessageRequest (
 *						GCCConfID   					conference_id,
 *						LPWSTR							pwszTextMsg,
 *						UserID							destination_node );
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a text message
 *		request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		pwszTextMsg					(i) Text message to send.
 *		destination_node			(i) ID of node to receive text message.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *		GCC_INVALID_MCS_USER_ID			- Destination node invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTransferRequest (
 *						GCCConfID   			conference_id,
 *						PGCCConferenceName		destination_conference_name,
 *						GCCNumericString		destination_conference_modifier,
 *						UINT        			number_of_destination_addresses,
 *						PGCCNetworkAddress		*destination_address_list,
 *						UINT					number_of_destination_nodes,
 *						PUserID					destination_node_list,
 *						PGCCPassword			password);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		transfer request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id					(i) Conference identifier value.
 *		destination_conference_name		(i) Name of conference to transfer to.
 *		destination_conference_modifier	(i) Name modifier of transfer conference
 *		number_of_destination_addresses	(i) Number of optional called addresses
 *												to be included in JoinRequest to
 *												be issued by transferring nodes.
 *		destination_address_list		(i) Optional called address parameter to
 *												be included in Join Request to
 *												be issued by transferring nodes.
 *		number_of_destination_nodes		(i)	Number of nodes to be transferred.
 *		destination_node_list			(i) List of nodes to be transferred.
 *		password						(i) Password to be used for joining
 *												transfer conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_CONFERENCE_NAME		- Conference name is invalid.
 *		GCC_INVALID_CONFERENCE_MODIFIER	- Conference modifier is invalid.
 *		GCC_INVALID_PASSWORD			- Password is invalid.
 *		GCC_INVALID_MCS_USER_ID			- A destination node ID is invalid.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfAddRequest	(
 *						GCCConfID   			conference_id,
 *						UINT        			number_of_network_addresses,
 *						PGCCNetworkAddress	*	network_address_list,
 *						UserID					adding_node,
 *						UINT					number_of_user_data_members,
 *						PGCCUserData		*	user_data_list );
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		add request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		number_of_network_addresses	(i) Number of network addresses in list
 *											of addresses of adding node.
 *		network_address_list		(i) List of addresses of adding node.
 *		adding_node					(i)	Node ID of node to add.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list 				(i) List of user data items.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  		its establishment process.
 *		GCC_INVALID_MCS_USER_ID			- Adding node ID invalid.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfAddResponse (
 *						GCCResponseTag			add_response_tag,
 *						GCCConfID   			conference_id,
 *						UserID					requesting_node,
 *						UINT					number_of_user_data_members,
 *						PGCCUserData		*	user_data_list,
 *						GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		add response from the node controller.  This function passes the
 *		response on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		add_response_tag			(i) Tag identifying the Add request.
 *		conference_id				(i) ID of conference to add node to.
 *		requesting_node				(i) ID of node requesting the Add.
 *		number_of_user_data_members	(i) Number of items in user data list.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result of Add.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- CConf object has not completed 
 *										  its establishment process.
 *		GCC_INVALID_ADD_RESPONSE_TAG	- There was no match of the response tag
 *		GCC_INVALID_MCS_USER_ID			- Adding node ID invalid.
 *		GCC_INVALID_CONFERENCE			- Conference ID invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfCreateIndication (
 *						PGCCConferenceName			conference_name,
 *						GCCConfID   				conference_id,
 *						CPassword                   *convener_password,
 *						CPassword                   *password,
 *						BOOL						conference_is_locked,
 *						BOOL						conference_is_listed,
 *						BOOL						conference_is_conductible,
 *						GCCTerminationMethod		termination_method,
 *						PPrivilegeListData			conductor_privilege_list,
 *						PPrivilegeListData			conduct_mode_privilege_list,
 *						PPrivilegeListData			non_conduct_privilege_list,
 *						LPWSTR						pwszConfDescriptor,
 *						LPWSTR						pwszCallerID,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						PDomainParameters			domain_parameters,
 *						CUserDataListContainer      *user_data_list,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it gets a connect 
 *		provider indication from MCS, carrying a conference create request PDU.
 *		This function fills in all the parameters in the CreateIndicationInfo 
 *		structure. It then adds it to a queue of messages supposed to be sent to
 *		the node controller in the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_name				(i) Name of the conference.
 *		conference_id				(i) ID of the conference.
 *		convener_password			(i) Password used for convener privileges.
 *		password					(i) Password used for access restriction.
 *		conference_is_locked		(i) Flag indicating whether conf. is locked.
 *		conference_is_listed		(i) Flag indicating whether conf. is listed.
 *		conference_is_conductible	(i) Flag indicating whether conference is
 *											conductable.
 *		termination_method			(i)	Type of termination method.
 *		conductor_privilege_list	(i) List of privileges granted to conductor
 *											by the convener.
 *		conduct_mode_privilege_list	(i) List of privileges granted to all nodes
 *											when in conducted mode.
 *		non_conduct_privilege_list	(i) List of privileges granted to all nodes
 *											when not in conducted mode.
 *		pwszConfDescriptor			(i) Conference descriptor string.
 *		pwszCallerID				(i) Caller identifier string.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Tranport address of called node.
 *		domain_parameters			(i) Conference domain parameters.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfQueryIndication (
 *						GCCResponseTag				query_response_tag,
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						CUserDataListContainer      *user_data_list,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		conference query indication to the node controller. It adds the message
 *		to a queue of messages to be sent to the node controller in the next 
 *		heartbeat.
 *
 *	Formal Parameters:
 *		query_response_tag			(i)	Tag identifying this query.
 *		node_type					(i) Type of node (terminal, MCU, both).
 *		asymmetry_indicator			(i) Structure used to identify calling and
 *											called nodes.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of called node.
 *		user_data_list				(i) List of user data items.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfQueryConfirm (
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						CConfDescriptorListContainer *conference_list,
 *						CUserDataListContainer	    *user_data_list,
 *						GCCResult					result,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		conference query confirm to the node controller. It adds the message
 *		to a queue of messages to be sent to the node controller in the next 
 *		heartbeat.
 *
 *	Formal Parameters:
 *		node_type					(i) Type of node (terminal, MCU, both).
 *		asymmetry_indicator			(i) Structure used to identify calling and
 *											called nodes.
 *		conference_list				(i) List of available conferences.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result of query.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfJoinIndication(
 *						GCCConfID   				conference_id,
 *						CPassword                   *convener_password,
 *						CPassword                   *password_challenge,
 *						LPWSTR						pwszCallerID,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						CUserDataListContainer      *user_data_list,
 *						BOOL						intermediate_node,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This join indication is recevied from the owner object. This join
 *		indication is designed to make the join response very flexible at the 
 *		node controller.  The node controller can respond to this indication
 *		by either creating a new conference and moving the joiner into it, 
 *		putting the joiner in the conference requested or putting the joiner
 *		into a different conference that already exist.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		convener_password			(i)	Password used for convener privileges.
 *		password_challenge			(i) Password challenge used for join.
 *		pwszCallerID				(i) Caller identifier string.
 *		calling_address				(i) Transport address of calling node.
 *		called_address				(i) Transport address of called node.
 *		user_data_list				(i) List of user data items.
 *		intermediate_node			(i) Flag indicating if join made at
 *											an intermediate node.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	???GCCConferenceQueryConfirm (
 *						GCCResponseTag				query_response_tag,
 *						GCCNodeType					node_type,
 *						PGCCAsymmetryIndicator		asymmetry_indicator,
 *						TransportAddress			calling_address,
 *						TransportAddress			called_address,
 *						CUserDataListContainer      *user_data_list,
 *						ConnectionHandle			connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the interface when it gets a conference
 *		add request from the node controller.  This function passes the
 *		request on to the appropriate conference object as obtained from
 *		the list of command targets that the control sap maintains.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conference identifier value.
 *		number_of_network_addresses	(i) Number of network addresses in list
 *											of addresses of adding node.
 *		network_address_list		(i) List of addresses of adding node.
 *		adding_node					(i)	Node ID of node to add.
 *		number_of_user_data_members	(i) Number of items in list of user data.
 *		user_data_list 				(i) List of user data items.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfInviteIndication(
 *						GCCConfID   			conference_id,
 *						PGCCConferenceName		conference_name,
 *						LPWSTR					pwszCallerID,			  
 *						TransportAddress		calling_address,			  
 *						TransportAddress		called_address,				  
 *						PDomainParameters 		domain_parameters,			  
 *						BOOL					clear_password_required,
 *						BOOL					conference_is_locked,
 *						BOOL					conference_is_listed,
 *						BOOL					conference_is_conductible,
 *						GCCTerminationMethod	termination_method,
 *						PPrivilegeListData		conductor_privilege_list,	  
 *						PPrivilegeListData		conducted_mode_privilege_list,
 *						PPrivilegeListData		non_conducted_privilege_list, 
 *						LPWSTR					pwszConfDescriptor,		  
 *						CUserDataListContainer  *user_data_list,				  
 *						ConnectionHandle		connection_handle,
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		conference invite indication to the node controller. It adds the message
 *		to a queue of messages to be sent to the node controller in the next 
 *		heartbeat.
 *
 *	Formal Parameters:
 *		conference_id					(i)	Conference identifier value.
 *		conference_name					(i) Name of conference.
 *		pwszCallerID	,			 	(i) Caller identifier value.
 *		calling_address,			 	(i) Transport address of calling node.
 *		called_address,				 	(i) Transport address of called node.
 *		domain_parameters,			 	(i) Conference domain parameters.
 *		clear_password_required			(i) Flag indicating if a clear password
 *												is required.
 *		conference_is_locked			(i) Flag indicating whether conference
 *												is locked.
 *		conference_is_listed			(i)	Flag indicating whether conference
 *												is listed.
 *		conference_is_conductible		(i)	Flag indicating whether conference
 *												is conductable.
 *		termination_method				(i)	Method of conference termination.
 *		conductor_privilege_list		(i) List of privileges granted to 
 *												conductor by the convener.
 *		conduct_mode_privilege_list		(i) List of privileges granted to all 
 *												nodes when in conducted mode.
 *		non_conducted_privilege_list	(i) List of privileges granted to all 
 *												nodes when not in conducted mode
 *		pwszConfDescriptor			 	(i)	Conference descriptor string.
 *		user_data_list				 	(i) List of user data items.
 *		connection_handle				(i) Logical connection handle.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	TransportStatusIndication (
 *							PTransportStatus		transport_status);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		transport status indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		transport_status			(i)	Transport status message.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	StatusIndication (
 *							GCCStatusMessageType	status_message,
 *							UINT					parameter);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		status indication to the node controller. It adds the message to a  
 *		queue of messages to be sent to the node controller in the next 
 *		heartbeat.
 *
 *	Formal Parameters:
 *		status_message					(i)	GCC status message.
 *		parameter						(i) Parameter whose meaning depends 
 *												upon the type of message.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		Note that we do not handle a resource error here to avoid an
 *		endless loop that could occur when this routine is called from the
 *		HandleResourceError() routine.
 */

/*
 *	GCCError	ConnectionBrokenIndication (	
 *							ConnectionHandle		connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		connection broken indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		connection_handle			(i)	Logical connection handle.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfCreateConfirm (
 *							PGCCConferenceName	  	conference_name,
 *							GCCNumericString		conference_modifier,
 *							GCCConfID   			conference_id,
 *							PDomainParameters		domain_parameters,			
 *							CUserDataListContainer  *user_data_list,				
 *							GCCResult				result,
 *							ConnectionHandle		connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference create confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_name				(i) Conference name string.
 *		conference_modifier			(i) Conference modifier string.
 *		conference_id				(i) Conference identifier value.
 *		domain_parameters,			(i) Conference domain parameters.
 *		user_data_list,				(i) List of user data items.
 *		result						(i) Result of creation.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfPermissionToAnnounce (
 *							GCCConfID   			conference_id,
 *							UserID					gcc_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference permission to announce to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id			(i)	Conference identifier value.
 *		gcc_node_id				(i) Node ID of node being given permission.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAnnouncePresenceConfirm (
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference announce presence confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id		(i)	Conference identifier value.
 *		result				(i) Result of announcing presence.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfDisconnectIndication (
 *							GCCConfID   			conference_id,
 *							GCCReason				reason,
 *							UserID					disconnected_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the Conference when it need to send a 
 *		conference disconnect indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i) Conferenc identifier value.
 *		reason						(i) Reason for disconnection.
 *		disconnected_node_id		(i) Node ID of node disconnected.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError  	ConfJoinIndication (
 *							UserID					sender_id,
 *							GCCConfID   			conference_id,
 *							CPassword               *convener_password,
 *							CPassword               *password_challange,
 *							LPWSTR					pwszCallerID,
 *							CUserDataListContainer  *user_data_list);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference join indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		sender_id					(i)	ID of node sending join indication.
 *		conference_id				(i) Conference identifier value.
 *		convener_password			(i) Password used for convener privileges.
 *		password_challange			(i) Password challenge used for join.
 *		pwszCallerID				(i) Caller identifier string.
 *		user_data_list)				(i) List of user data items.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError  	ConfJoinConfirm (
 *							PGCCConferenceName		conference_name,
 *							GCCNumericString		remote_modifier,
 *							GCCNumericString		local_modifier,
 *							GCCConfID   			conference_id,
 *							CPassword               *password_challenge,
 *							PDomainParameters		domain_parameters,
 *							BOOL					password_in_the_clear,
 *							BOOL					conference_locked,
 *							BOOL					conference_listed,
 *							BOOL					conference_conductible,
 *							GCCTerminationMethod	termination_method,
 *							PPrivilegeListData		conductor_privilege_list,
 *							PPrivilegeListData		conduct_mode_privilege_list,
 *							PPrivilegeListData		non_conduct_privilege_list,
 *							LPWSTR					pwszConfDescription,
 *							CUserDataListContainer  *user_data_list,	
 *							GCCResult				result,
 *							ConnectionHandle		connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference join confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_name				(i)	Conference name.
 *		remote_modifier				(i) Conference name modifier at remote node.
 *		local_modifier				(i) Conference name modifier at local node.
 *		conference_id				(i) Conference identifier value.
 *		password_challenge			(i) Password challenge used for join.
 *		domain_parameters			(i) Conference domain parameters.
 *		password_in_the_clear		(i) Flag indicating	password is clear.
 *		conference_locked			(i) Flag indicating conference is locked.
 *		conference_listed			(i) Flag indicating conference is listed.
 *		conference_conductible		(i) Flag indicating conference is 
 *											conductable.
 *		termination_method			(i) Method of termination.
 *		conductor_privilege_list	(i) List of privileges granted the conductor
 *											by the convener.
 *		conduct_mode_privilege_list	(i) List of privileges granted to all nodes
 *											when in conducted mode.
 *		non_conduct_privilege_list	(i)	List of privileges granted to all nodes
 *											when in conducted mode.
 *		pwszConfDescription			(i)	Conference description string.
 *		user_data_list,				(i) List of user data items.
 *		result						(i) Result of conference join.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfInviteConfirm (
 *							GCCConfID   			conference_id,
 *							CUserDataListContainer  *user_data_list,
 *							GCCResult				result,
 *							ConnectionHandle		connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference invite confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		user_data_list,				(i) List of user data items.
 *		result						(i) Result of conference join.
 *		connection_handle			(i) Logical connection handle.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
 
/*
 *	GCCError	ConfTerminateIndication (
 *							GCCConfID   			conference_id,
 *							UserID					requesting_node_id,
 *							GCCReason				reason);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the GCC Controller when it need to send a 
 *		conference terminate indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id					(i)	Conference identifier value.
 *		requesting_node_id				(i) ID of node requesting termination.
 *		reason							(i) Reason for termination.
 *
 *	Return Value:
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError 	ConfLockReport (
 *							GCCConfID   			conference_id,
 *							BOOL					conference_is_locked);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference lock report to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		conference_is_locked		(i) Flag indicating whether conference is
 *											locked.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfLockIndication (
 *							GCCConfID   			conference_id,
 *							UserID					source_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference lock indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		source_node_id				(i) ID of node requesting lock.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfLockConfirm(
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference lock confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conference lock.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfUnlockIndication (
 *							GCCConfID   			conference_id,
 *							UserID					source_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference unlock indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		source_node_id				(i) ID of node requesting unlock.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfUnlockConfirm (
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference unlock confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conference unlock.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfEjectUserIndication (	
 *							GCCConfID   			conference_id,
 *							GCCReason				reason,
 *							UserID					gcc_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference eject user indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		reason						(i) Reason for node ejection.
 *		gcc_node_id					(i) ID of node being ejected.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfEjectUserConfirm (
 *							GCCConfID   			conference_id,
 *							UserID					ejected_node_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference eject user confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		ejected_node_id				(i) ID of node being ejected.
 *		result						(i) Result of ejection attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTerminateConfirm (
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference terminate confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of termination attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorAssignConfirm (
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor assign confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor assign attempt.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorReleaseConfirm (
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor release confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor release attempt.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPleaseIndication (
 *							GCCConfID   			conference_id,
 *							UserID					requester_user_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor please indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		requester_user_id			(i) ID of node requesting conductorship.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPleaseConfirm (	
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor please confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor please attempt.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorGiveIndication (
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor give indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorGiveConfirm (	
 *							GCCResult				result,
 *							GCCConfID   			conference_id,
 *							UserID					recipient_node);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor give confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor assign attempt.
 *		conference_id				(i)	Conference identifier value.
 *		recipient_node				(i) ID of node receiving conductorship.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPermitAskIndication (	
 *							GCCConfID   			conference_id,
 *							BOOL					grant_flag,
 *							UserID					requester_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor permit ask indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		grant_flag					(i) Flag indicating whether conductorship
 *											is to be granted or given up.
 *		requester_id				(i)	ID of node asking for permission.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPermitAskConfirm (
 *							GCCResult				result,
 *							BOOL					grant_permission,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor permit ask confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor permit ask attempt.
 *		grant_permission			(i) Flag indicating whether conductor
 *											permission is granted.
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConductorPermitGrantConfirm (
 *							GCCResult				result,
 *							GCCConfID   			conference_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conductor permit grant confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		result						(i) Result of conductor permit grant attempt
 *		conference_id				(i)	Conference identifier value.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTimeRemainingIndication (
 *							GCCConfID   			conference_id,
 *							UserID					source_node_id,
 *							UserID					node_id,
 *							UINT					time_remaining);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference time remaining indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		source_node_id				(i)	Node ID of the node that issued the
 *											time remaining request..
 *		node_id						(i)	Optional parameter which, if present,
 *											indicates that time remaining 
 *											applies only to node with this ID.
 *		time_remaining				(i)	Time remaining in conference (in sec.).
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTimeRemainingConfirm (
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference time remaining confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of time remaining request.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTimeInquireIndication (
 *							GCCConfID   			conference_id,
 *							BOOL					time_is_conference_wide,
 *							UserID					requesting_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference time inquire indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		time_is_conference_wide		(i) Flag indicating time inquire is for
 *											entire conference.
 *		requesting_node_id			(i) Node ID of node inquiring.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTimeInquireConfirm (
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference time inquire confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of time inquire attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfExtendIndication (
 *							GCCConfID   			conference_id,
 *							UINT					extension_time,
 *							BOOL					time_is_conference_wide,
 *							UserID                  requesting_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference extend indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		extension_time				(i) Amount of time (in sec.) to extend
 *											conference.
 *		time_is_conference_wide		(i) Flag indicating time inquire is for
 *											entire conference.
 *		requesting_node_id			(i) Node ID of node requesting extension.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError 	ConfExtendConfirm (
 *							GCCConfID   			conference_id,
 *							UINT					extension_time,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference extend confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		extension_time				(i) Amount of time (in sec.) to extend
 *											conference.
 *		result						(i) Result of conductor assign attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAssistanceIndication (
 *							GCCConfID   			conference_id,
 *							CUserDataListContainer  *user_data_list,
 *							UserID					source_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference assistance indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		user_data_list				(i) List of user data items.
 *		source_node_id				(i) Node ID of node requesting assistance.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAssistanceConfirm (
 *							GCCConfID   	 		conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf  when it need to send a 
 *		conference assistance confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of conference assistance attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	TextMessageIndication (
 *							GCCConfID   			conference_id,
 *							LPWSTR					pwszTextMsg,
 *							UserID					source_node_id);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		text message indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		pwszTextMsg					(i) Text message being sent.
 *		source_node_id				(i) Node ID of node sending text message.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	TextMessageConfirm ( 	
 *							GCCConfID   			conference_id,
 *							GCCResult				result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		text message confirm to the node controller. It adds the message 
 *		to a queue of messages to be sent to the node controller in the
 *		next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		result						(i) Result of text message send attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTransferIndication (
 *							GCCConfID   		conference_id,
 *							PGCCConferenceName	destination_conference_name,
 *							GCCNumericString	destination_conference_modifier,
 *							CNetAddrListContainer *destination_address_list,
 *							CPassword           *password);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference transfer indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id					(i)	Conference identifier value.
 *		destination_conference_name		(i)	Name of destination conference.
 *		destination_conference_modifier	(i) Name modifier of destination conf.
 *		destination_address_list		(i) List of network addresses for
 *												inclusion in the Join Request to
 *												be made by transferring nodes.
 *		password						(i)	Password to be used in Join	Request
 *												by transferring nodes.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfTransferConfirm (
 *							GCCConfID   		conference_id,
 *							PGCCConferenceName	destination_conference_name,
 *							GCCNumericString	destination_conference_modifier,
 *							UINT				number_of_destination_nodes,
 *			 				PUserID				destination_node_list,
 *							GCCResult			result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference transfer confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id					(i)	Conference identifier value.
 *		destination_conference_name		(i)	Name of destination conference.
 *		destination_conference_modifier	(i) Name modifier of destination conf.
 *		number_of_destination_nodes		(i) Number of nodes being transferred.
 *		destination_node_list			(i) List of nodes being transferred.
 *		result							(i) Result of conference transfer.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAddIndication (
 *							GCCConfID   		conference_id,
 *							GCCResponseTag		add_response_tag,
 *							CNetAddrListContainer *network_address_list,
 *							CUserDataListContainer *user_data_list,
 *							UserID				requesting_node);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference add indication to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		add_response_tag			(i)	Tag used to identify this add event.
 *		network_address_list		(i) Network addresses of node to be added.
 *		user_data_list				(i) List of user data items.
 *		requesting_node				(i) Node ID of node requesting the add.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ConfAddConfirm (
 *							GCCConfID   		conference_id,
 *							CNetAddrListContainer *network_address_list,
 *							CUserDataListContainer *user_data_list,
 *							GCCResult			result);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		conference add confirm to the node controller. It adds the 
 *		message	to a queue of messages to be sent to the node controller in 
 *		the next heartbeat.
 *
 *	Formal Parameters:
 *		conference_id				(i)	Conference identifier value.
 *		network_address_list		(i) Network addresses of node to be added.
 *		user_data_list				(i) List of user data items.
 *		result						(i) Result of Add attempt.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	SubInitializationCompleteIndication (
 *							UserID				user_id,
 *							ConnectionHandle	connection_handle);
 *
 *	Public member function of CControlSAP.
 *
 *	Function Description:
 *		This function is called by the CConf when it need to send a 
 *		sub-initialization complete indication to the node controller. This call
 *		tells this node that a node directly connected to it has initialized.
 *		It adds the message	to a queue of messages to be sent to the node 
 *		controller in the next heartbeat.
 *
 *	Formal Parameters:
 *		user_id						(i) Node ID of the intializing node. 
 *		connection_handle			(i) Logical connection handle for directly
 *											connected node.
 *
 *	Return Value:
 *		GCC_NO_ERROR				- Message successfully queued.
 *		GCC_ALLOCATION_FAILURE		- A resource allocation failure occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif // _GCC_CONTROL_SAP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\domain.h ===
/*
 *	domain.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the domain class.  This class contains
 *		all code necessary to maintain a domain information base within the
 *		MCS system.  When a domain object is first created, it is completely
 *		empty.  That is, it has no user attachments, no MCS connections, and
 *		therefore no outstanding resources, such as channels and tokens.
 *
 *		A word of caution about terminology.  Throughout the MCS documentation
 *		the word "attachment" is used in conjunction with a USER attachment. The
 *		word "connection" is used in conjunction with a TRANSPORT connection. In
 *		this class, the two types of "attachments" are NOT differentiated (most
 *		of the time).  They are both referred to as attachments.  When deleting
 *		an attachment, it is necessary to know the difference, however, and so
 *		there is an enumerated type (AttachmentType) to distinguish.  The type
 *		of each attachment is stored in a dictionary for easy access (see
 *		description of AttachmentType below).
 *
 *		This class keeps a list of "attachments" that are hierarchically below
 *		the local provider within the domain.  It also keeps a pointer to the
 *		one attachment that is hierarchically above the local provider (if any).
 *
 *		Since this class inherits from CommandTarget, it processes MCS commands
 *		as member function calls (see cmdtar.h for a description of how this
 *		mechanism works).  In essence, domain objects are just big command
 *		routers who react to incoming commands according to the contents of the
 *		information base.  That information base, in turn, is modified by the
 *		commands that are handled.
 *
 *		Domain objects keep lists of both channel objects and token objects,
 *		who maintain information about the current state of various channels
 *		and tokens.  Objects of this class are the heart of MCS.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

#ifndef	_DOMAIN_
#define	_DOMAIN_

/*
 *	Interface files.
 */
#include "userchnl.h"
#include "privchnl.h"
#include "token.h"
#include "randchnl.h"
#include "attmnt.h"

/*
 *	This enumeration defines the errors that a domain object can return when
 *	instructed to do something by its creator.
 */
typedef	enum
{
	DOMAIN_NO_ERROR,
	DOMAIN_NOT_HIERARCHICAL,
	DOMAIN_NO_SUCH_CONNECTION,
	DOMAIN_CONNECTION_ALREADY_EXISTS
} DomainError;
typedef	DomainError *		PDomainError;

/*
 *	This enumeration defines the different merge states that a domain can be in
 *	at any given time.  They can be described as follows:
 *
 *	MERGE_INACTIVE
 *		There is no merge operation underway.  This is the normal operational
 *		state.
 *	MERGE_USER_IDS
 *		The domain is currently merging user IDs into the upper domain.
 *	MERGE_STATIC_CHANNELS
 *		The domain is currently merging static channels into the upper domain.
 *	MERGE_ASSIGNED_CHANNELS
 *		The domain is currently merging assigned channels into the upper domain.
 *	MERGE_PRIVATE_CHANNELS
 *		The domain is currently merging private channels into the upper domain.
 *	MERGE_TOKENS
 *		The domain is currently merging tokens into the upper domain.
 *	MERGE_COMPLETE
 *		The merge operation is complete (this is a transitional state).
 */
typedef	enum
{
	MERGE_INACTIVE,
	MERGE_USER_IDS,
	MERGE_STATIC_CHANNELS,
	MERGE_ASSIGNED_CHANNELS,
	MERGE_PRIVATE_CHANNELS,
	MERGE_TOKENS,
	MERGE_COMPLETE
} MergeState;
typedef	MergeState *		PMergeState;

/*
 *	This collection type is used to hold the height of the domain across
 *	various downward attachments.  The Domain object needs to know this in order
 *	to calculate the effect of attachment loss on the height of the domain.
 */
class CDomainHeightList2 : public CList2
{
    DEFINE_CLIST2(CDomainHeightList2, UINT_PTR, PConnection)
};

/*
 *	This is the class definition for the Domain class.
 */
class Domain
{
public:

    Domain ();
    ~Domain ();

    BOOL    IsTopProvider(void) { return (NULL == m_pConnToTopProvider); }

			Void		GetDomainParameters (
									PDomainParameters	domain_parameters,
									PDomainParameters	min_domain_parameters,
									PDomainParameters	max_domain_parameters);
			Void		BindConnAttmnt (
									PConnection         originator,
									BOOL    			upward_connection,
									PDomainParameters	domain_parameters);
			Void		PlumbDomainIndication (
									PConnection         originator,
									ULong				height_limit);
			Void		ErectDomainRequest (
									PConnection         originator,
									ULONG_PTR				height_in_domain,
									ULong				throughput_interval);
			Void		MergeChannelsRequest (
									PConnection             originator,
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
			Void		MergeChannelsConfirm (
									PConnection             originator,
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
			Void		PurgeChannelsIndication (
									PConnection             originator,
									CUidList               *purge_user_list,
									CChannelIDList         *purge_channel_list);
			Void		MergeTokensRequest (
									PConnection             originator,
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
			Void		MergeTokensConfirm (
									PConnection             originator,
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
			Void		PurgeTokensIndication (
									PConnection             originator,
									CTokenIDList           *purge_token_list);
			Void		DisconnectProviderUltimatum (
									CAttachment        *originator,
									Reason				reason);
			Void		RejectUltimatum (
									PConnection         originator,
									Diagnostic			diagnostic,
									PUChar				octet_string_address,
									ULong				octet_string_length);
			Void		AttachUserRequest (
									CAttachment        *originator);
			Void		AttachUserConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator);
			Void		DetachUserRequest (
									CAttachment        *originator,
									Reason				reason,
									CUidList           *user_id_list);
			Void		DetachUserIndication (
									PConnection         originator,
									Reason				reason,
									CUidList           *user_id_list);
			Void		ChannelJoinRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id);
			Void		ChannelJoinConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									ChannelID			requested_id,
									ChannelID			channel_id);
			Void		ChannelLeaveRequest (
									CAttachment        *originator,
									CChannelIDList     *channel_id_list);
			Void		ChannelConveneRequest (
									CAttachment        *originator,
									UserID				uidInitiator);
			Void		ChannelConveneConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									ChannelID			channel_id);
			Void		ChannelDisbandRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id);
			Void		ChannelDisbandIndication (
									PConnection         originator,
									ChannelID			channel_id);
			Void		ChannelAdmitRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
			Void		ChannelAdmitIndication (
									PConnection         originator,
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
			Void		ChannelExpelRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
			Void		ChannelExpelIndication (
									PConnection         originator,
									ChannelID			channel_id,
									CUidList           *user_id_list);
			Void		SendDataRequest (
									CAttachment        *originator,
									UINT				type,
									PDataPacket			data_packet);
			Void		SendDataIndication (
									PConnection         originator,
									UINT				type,
									PDataPacket			data_packet);
			Void		TokenGrabRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenGrabConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
			Void		TokenInhibitRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenInhibitConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
			Void		TokenGiveRequest (
									CAttachment        *originator,
									PTokenGiveRecord	pTokenGiveRec);
			Void		TokenGiveIndication (
									PConnection         originator,
									PTokenGiveRecord	pTokenGiveRec);
			Void		TokenGiveResponse (
									CAttachment        *originator,
									Result				result,
									UserID				receiver_id,
									TokenID				token_id);
			Void		TokenGiveConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
			Void		TokenPleaseRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenPleaseIndication (
									PConnection         originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenReleaseRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenReleaseConfirm (
									PConnection         originator,
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
			Void		TokenTestRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
			Void		TokenTestConfirm (
									PConnection         originator,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);

	private:
				Void		LockDomainParameters (
									PDomainParameters	domain_parameters,
									BOOL    			parameters_locked);
				ChannelID	AllocateDynamicChannel ();
				BOOL    	ValidateUserID (
									UserID				user_id,
									CAttachment         *pOrigAtt);
				Void		PurgeDomain (
									Reason				reason);
				Void		DeleteAttachment (
									CAttachment         *pAtt,
									Reason				reason);
				Void		DeleteUser (
									UserID				user_id);
				Void		DeleteChannel (
									ChannelID			channel_id);
				Void		DeleteToken (
									TokenID				token_id);
				Void		ReclaimResources ();
				Void		MergeInformationBase ();
				Void		SetMergeState (
									MergeState			merge_state);
				Void		AddChannel (
									PConnection             pConn,
									PChannelAttributes	merge_channel,
									CChannelAttributesList *merge_channel_list,
									CChannelIDList         *purge_channel_list);
				Void		AddToken (
									PTokenAttributes	merge_token,
									CTokenAttributesList   *merge_token_list,
									CTokenIDList           *purge_token_list);
				Void		CalculateDomainHeight ();

		MergeState			Merge_State;
		UShort				Outstanding_Merge_Requests;
		UINT				Number_Of_Users;
		UINT				Number_Of_Channels;
		UINT				Number_Of_Tokens;
		DomainParameters	Domain_Parameters;
		BOOL    			Domain_Parameters_Locked;

		PConnection 		m_pConnToTopProvider;
		CAttachmentList     m_AttachmentList;

		CAttachmentQueue    m_AttachUserQueue;
		CConnectionQueue    m_MergeQueue;

		CChannelList2       m_ChannelList2;
		CTokenList2         m_TokenList2;

		UINT_PTR			m_nDomainHeight;
		CDomainHeightList2	m_DomainHeightList2;

		RandomChannelGenerator
							Random_Channel_Generator;
};

/*
 *	Domain ()
 *
 *	Functional Description:
 *		This is the constructor for the domain class.  It initializes the state
 *		of the domain, which at creation is empty.  It also initializes the
 *		domain parameters structure that will be used by this domain for all
 *		future parameters and negotiation.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Domain ()
 *
 *	Functional Description:
 *		This is the destructor for the domain class.  It purges the entire
 *		domain by first sending disconnect provider ultimatums to ALL
 *		attachments (both user attachments and MCS connections).  It then frees
 *		up all resources in use by the domain (which is just objects in its
 *		various containers).
 *
 *		Note that doing this will result in all user attachments and MCS
 *		connections being broken.  Furthermore, all providers that are
 *		hierarchically below this one, will respond by purging their domains
 *		as well.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		The domain from this provider downward is completely eradicated.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL    	IsTopProvider ()
 *
 *	Functional Description:
 *		This function is used to ask the domain if it is the top provider in
 *		the domain that it represents.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE if this is the top provider.  FALSE otherwise.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	GetDomainParameters (
 *					PDomainParameters		domain_parameters,
 *					PDomainParameters		min_domain_parameters,
 *					PDomainParameters		max_domain_parameters)
 *
 *	Functional Description:
 *		This function is used to ask the domain what the minimum and maximum
 *		acceptable values for domain parameters are.  If the domain has no
 *		connections (and therefore has not yet locked its domain parameters),
 *		then it will return min and max values based on what it can handle.
 *		If it has locked its domain parameters, then both the min and max values
 *		will be set to the locked set (indicating that it will not accept
 *		anything else).
 *
 *	Formal Parameters:
 *		domain_parameters (o)
 *			Pointer to a structure to be filled with the current domain
 *			parameters (those that are in use).  Setting this to NULL will
 *			prevent current domain parameters from being returned.
 *		min_domain_parameters (o)
 *			Pointer to a structure to be filled with the minimum domain
 *			parameters.  Setting this to NULL will prevent minimum domain
 *			parameters from being returned.
 *		max_domain_parameters (o)
 *			Pointer to a structure to be filled with the maximum domain
 *			parameters.  Setting this to NULL will prevent maximum domain
 *			parameters from being returned.
 *
 *	Return Value:
 *		None (except as specified in the parameter list above).
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	BindConnAttmnt (
 *					PConnection         originator,
 *					BOOL    			upward_connection,
 *					PDomainParameters	domain_parameters,
 *					AttachmentType		attachment_type)
 *
 *	Functional Description:
 *		This function is used when an attachment wishes to bind itself to the
 *		domain.  This will occur only after the connection has been been
 *		completely and successfully negotiated.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment that wishes to bind.
 *		upward_connection (i)
 *			A boolean flag indicating whether or not this is an upward
 *			connection.
 *		domain_parameters (i)
 *			A pointer to a domain parameters structure that holds the parameters
 *			that were negotiated for the connection.  If the domain has not
 *			already locked its parameters, it will accept and lock these.
 *		attachment_type (i)
 *			What type of attachment is this (local or remote).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PlumbDomainIndication (
 *					PCommandTarget		originator,
 *					ULong				height_limit)
 *
 *	Functional Description:
 *		This member function represents the reception of a plumb domain
 *		indication from the top provider.  If the height limit is zero, then
 *		the connection to the top provder will be severed.  If its not, then
 *		it will be decremented and broadcast to all downward attachments.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		height_limit (i)
 *			This is initially the height limit for the domain.  It is
 *			decremented at each layer in the domain.  When it reaches zero,
 *			the recipient is too far from the top provider, and must
 *			disconnect.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ErectDomainRequest (
 *					PCommandTarget		originator,
 *					ULong				height_in_domain,
 *					ULong				throughput_interval)
 *
 *	Functional Description:
 *		This member function represents the reception of an erect domain request
 *		from one of its downward attachments.  This contains information needed
 *		by higher providers to know what's going on below (such as total
 *		height of domain).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		height_in_domain (i)
 *			This is the height of the domain from the originator down.
 *		throughput_interval (i)
 *			This is not currently supported and will always be zero (0).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeChannelsRequest (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a merge channel
 *		request from one of this domain's attachments.  If this is the top
 *		provider, then the merge request will be processed locally (which
 *		will result in the transmission of merge channel confirms back to
 *		the originating attachment).  If this is not the top provider, then
 *		the command will be forwarded toward the top provider, and this
 *		provider will remember how to route it back.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		merge_channel_list (i)
 *			This is a list of strutures that contains the attributes of channels
 *			that are being merged into the upper domain.
 *		purge_channel_list (i)
 *			This is a list of channel IDs for those channels that are determined
 *			to be invalid even before this request reaches the Top Provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeChannelsConfirm (
 *					PCommandTarget			originator,
 *					CChannelAttributesList *merge_channel_list,
 *					CChannelIDList         *purge_channel_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a merge channel
 *		confirm from the top provider.  If this is the former top provider of
 *		a lower domain, the confirm will contain information indicating
 *		acceptance or rejection of the named channel.  If a channel is rejected,
 *		the former top provider will issue a purge channel indication
 *		downwards.  If this is not the former top provider, then it must be
 *		an intermediate provider. The command will be forwarded downward towards
 *		the former top provider.  The intermediate providers will also add the
 *		channel to their channel lists if it was accepted into the upper
 *		domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		merge_channel_list (i)
 *			This is a list of strutures that contains the attributes of channels
 *			that are being merged into the upper domain.
 *		purge_channel_list (i)
 *			This is a list of channel IDs for those channels that are to be
 *			purged from the lower domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PurgeChannelsIndication (
 *					PCommandTarget		originator,
 *					CUidList           *purge_user_list,
 *					CChannelIDList     *purge_channel_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a purge channel
 *		indication from the top provider.  This will cause the local
 *		provider to remove the channel from the local information base (if
 *		it are there).  It will also broadcast the message downward in the
 *		domain.  Note that this will be translated by user objects into either
 *		a detach user indication or a channel leave indication, depending on
 *		which type of channel is being left.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		purge_user_list (i)
 *			This is a list of users that are being purged from the lower
 *			domain.
 *		purge_channel_list (i)
 *			This is a list of channels that are being purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeTokensRequest (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a merge token
 *		request from one of this domain's attachments.  If this is the top
 *		provider, then the merge request will be processed locally (which
 *		will result in the transmission of merge token confirms back to
 *		the originating attachment).  If this is not the top provider, then
 *		the command will be forwarded toward the top provider, and this provider
 *		will remember how to route it back.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		merge_token_list (i)
 *			This is a list of token attributes structures, each of which
 *			describes one token to be merged.
 *		purge_token_list (i)
 *			This is a list of tokens that are to be purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeTokensConfirm (
 *					PCommandTarget			originator,
 *					CTokenAttributesList   *merge_token_list,
 *					CTokenIDList           *purge_token_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a merge token
 *		confirm from the top provider.  If this is the former top provider of
 *		a lower domain, the confirm will contain information indicating
 *		acceptance or rejection of the named token.  If a token is rejected,
 *		the former top provider will issue a purge token indication
 *		downwards.  If this is not the former top provider, then it must be
 *		an intermediate provider. The command will be forwarded downward towards
 *		the former top provider.  The intermediate providers will also add the
 *		token to their token lists if it was accepted into the upper
 *		domain.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		merge_token_list (i)
 *			This is a list of token attributes structures, each of which
 *			describes one token to be merged.
 *		purge_token_list (i)
 *			This is a list of tokens that are to be purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PurgeTokensIndication (
 *					PCommandTarget		originator,
 *					CTokenIDList       *purge_token_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a purge token
 *		indication  from the top provider.  This will cause the local
 *		provider to remove the token from the local information base (if
 *		it are there).  It will also broadcast the message downward in the
 *		domain.  Note that this will be translated by user objects into a
 *		token release indication.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		purge_token_list (i)
 *			This is a list of tokens that are to be purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DisconnectProviderUltimatum (
 *					PCommandTarget		originator,
 *					Reason				reason)
 *
 *	Functional Description:
 *		This member function represents the reception of a disconnect provider
 *		ultimatum.  The attachment from which this command is received is
 *		automatically terminated.  Any resources that are held by users on
 *		the other side of the attachment are automatically freed by the top
 *		provider (if it was a downward attachment).  If it was an upward
 *		attachment then the domain is purged completely (which means that it
 *		is returned to its initialized state).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		reason (i)
 *			This is the reason for the disconnect.  This will be one of the
 *			reasons defined in "mcatmcs.h".
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		An attachment will be severed, and potentially the entire domain can
 *		be purged.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	RejectUltimatum (
 *					PCommandTarget		originator,
 *					Diagnostic			diagnostic,
 *					PUChar				octet_string_address,
 *					ULong				octet_string_length)
 *
 *	Functional Description:
 *		This command represents the reception of a reject ultimatum.  This
 *		indicates that the remote side was unable to correctly process a PDU
 *		that was sent to them.  At this time we simply sever the connection
 *		that carried the reject.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		diagnostic (i)
 *			This is a diagnostic code describing the nature of the problem.
 *		octet_string_address (i)
 *			This is address of an optional octet string that contains the
 *			bad PDU.
 *		octet_string_length (i)
 *			This is the length of the above octet string.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	AttachUserRequest (
 *					PCommandTarget		originator)
 *
 *	Functional Description:
 *		This member function represents the reception of an attach user request.
 *		If this is the top provider, the domain will attempt to add the
 *		new user into the channel list (as a user channel).  A confirm will
 *		be issued in the direction of the requesting user, letting it know
 *		the outcome of the attach operation (as well as the user ID if the
 *		attach was successful).  If his is not the top provider, then the
 *		request will be forwarded in the direction of the top provider.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	AttachUserConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This member function represents the reception of an attach user confirm.
 *		If this provider has an outstanding attach user request, then it
 *		will forward the confirm in the direction of the requester.  It will
 *		also add the new user channel to the local channel list.  If there
 *		are no outstanding requests (as a result of the requester being
 *		disconnected), then this provider will issue a detach user request
 *		upward to eliminate the user ID that is no longer needed (it will only
 *		do this if the result of the attach was successful).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the attach operation.  Anything but
 *			RESULT_SUCCESSFUL indicates that the attach did not succeed.
 *		uidInitiator (i)
 *			If the attach succeeded, then this field will contain the user ID
 *			of the newly attached user.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DetachUserRequest (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a detach user request.
 *		This causes the user channels associated with all users in the list to
 *		be deleted from the user information base.  If this is not the top
 *		provider, the request will then be forwarded upward.  Additionally,
 *		all resources owned by the detaching users will be reclaimed by all
 *		providers along the way.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		reason (i)
 *			This is the reason for th detachment.
 *		user_id_list (i)
 *			This is a list of the users that are detaching.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DetachUserIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a detach user
 *		indication.  This indication will be repeated to all downward
 *		attachments (both user attachments and MCS connections).  Then, if
 *		the user IDs represent any users in the local sub-tree, those users will
 *		be removed from the information base.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		reason (i)
 *			This is the reason for the detachment.
 *		user_id_list (i)
 *			This is a list of the users that are detaching.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelJoinRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel join request.
 *		If the channel exists in the local information base, then the
 *		domain will attempt to join the requesting attachment to the channel.
 *		A channel join confirm will be sent to the requesting attachment
 *		informing the requester of the result.  If the channel is not already
 *		in the information base, then one of two things will happen.  If this
 *		is the top provider, then the domain will attempt to add the channel
 *		(if it is a static channel).  If this is not the top provider, then
 *		the request will be forwarded upward.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user requesting the join.
 *		channel_id (i)
 *			This is the ID of the channel to be joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelJoinConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			requested_id,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel join confirm.
 *		If the channel has not already been added to the channel, it will
 *		be put there now.  The confirm will then be forwarded in the direction
 *		of the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the join.  Anything but RESULT_SUCCESSFUL
 *			means that the join failed.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel join.
 *			This is used to properly route the confirm.
 *		requested_id (i)
 *			This is the ID of the channel the user originally requested, which
 *			may be 0.
 *		channel_id (i)
 *			This is the ID of the channel that has been joined.  If the original
 *			request was for channel 0, then this field will indicate to the
 *			user which assigned channel was selected by the top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelLeaveRequest (
 *					PCommandTarget		originator,
 *					CChannelIDList     *channel_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel leave
 *		request.  The domain removes the requesting attachment from all channels
 *		in the channel list. If this results in any empty channels, then the
 *		channel leave request will be forwarded to the next higher provider in
 *		the domain (unless this is the top provider).  Furthermore, if a static
 *		or assigned channel is left empty, it is automatically removed from the
 *		channel list.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		channel_id_list (i)
 *			This is a list of channels to be left.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelConveneRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel convene
 *		request.  If this is not the Top Provider, the request will be sent
 *		upward.  If this is the Top Provider, then a new private channel will
 *		be created (if domain parameters allow).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the creation of a
 *			new private channel.  This is used to properly route the confirm.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelConveneConfirm (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel convene
 *		confirm.  This causes the local provider to add the new private channel
 *		to the local information base, and route the confirm on toward the
 *		initiator of the request.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the convene.  Anything but RESULT_SUCCESSFUL
 *			means that the convene failed.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel convene.
 *			This is used to properly route the confirm.
 *		channel_id (i)
 *			This is the ID of the new private channel that has been created.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelDisbandRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel disband
 *		request.  If this is not the Top Provider, then the request will be
 *		forwarded upward.  If this is the Top Provider, then the specified
 *		private channel will be destroyed (after appropriate identity
 *		verification).  This will cause channel disband and channel expel
 *		indications to be sent downward to all admitted users.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel disband.
 *			If this does not correspond to the channel manager, then the request
 *			will be ignored.
 *		channel_id (i)
 *			This is the ID of the channel to be disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelDisbandIndication (
 *						PCommandTarget		originator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel disband
 *		indication.  This causes the specified private channel to be removed
 *		from the information base.  The indication is then forwarded to all
 *		attachments that are either admitted or the channel manager.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		channel_id (i)
 *			This is the ID of the channel being disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelAdmitRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel admit
 *		request.  If this is not the Top Provider, then the request will be
 *		forwarded upward.  If this is the Top Provider, then the user IDs
 *		will be added to the admitted list, and a channel admit indication will
 *		be sent downward toward all attachments that contain an admitted user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel admit.
 *			This must be the channel manager for the admit to succeed.
 *		channel_id (i)
 *			This is the ID of the private channel whose admitted list is to
 *			be expanded.
 *		user_id_list (i)
 *			This is a container holding the user IDs of those users to be
 *			admitted to the private channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelAdmitIndication (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel admit
 *		indication.  If the specified private channel does not yet exist in the
 *		information base, it will be created now.  The users specified will be
 *		added to the admitted list, and this indication will be forwarded to
 *		all attachments that contain an admitted user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the manager of this private channel.
 *		channel_id (i)
 *			This is the ID of the private channel for which this indication
 *			is intended.
 *		user_id_list (i)
 *			This is a container holding the list of user IDs to be added to
 *			the admitted list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelExpelRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel expel
 *		request.  If this is not the Top Provider, then the request will be
 *		forwarded upward.  If this is the Top Provider, then the specifed users
 *		will be removed from the private channel, and an expel indication will
 *		be sent downward to all attachments that contain (or did contain) an
 *		admitted user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user that requested the channel expel.
 *			This must be the channel manager for the expel to succeed.
 *		channel_id (i)
 *			This is the ID of the private channel whose admitted list is to
 *			be reduced.
 *		user_id_list (i)
 *			This is a container holding the user IDs of those users to be
 *			expelled from the private channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelExpelIndication (
 *						PCommandTarget		originator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This member function represents the reception of a channel expel
 *		indication.  The specified users will be removed from the admitted
 *		list of the channel.  If the channel is empty, and the channel manager
 *		is not in the sub-tree of this provider, then the channel will be
 *		removed from the local information base.  The expel indication will
 *		also be forwarded to all attachments that contain (or did contain( an
 *		admitted user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		channel_id (i)
 *			This is the ID of the private channel for which this indication
 *			is intended.
 *		user_id_list (i)
 *			This is a container holding the list of user IDs to be removed
 *			from the admitted list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataRequest (
 *					PCommandTarget		originator,
 *					UINT				type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This member function represents the reception of a send data request.
 *		If this is not the top provider, the request will be repeated
 *		upward toward the top provider.  The data will also be sent downward
 *		to all attachments that are joined to the channel (except for the
 *		originator) in the form of a send data indication.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		type (i)
 *			Normal or uniform send data request.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataIndication (
 *					PCommandTarget		originator,
 *					UINT				type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This member function represents the reception of a send data indication.
 *		This indication will be repeated downward to all attachments that
 *		are joined to the channel.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		type (i)
 *			normal or uniform send data indication
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token grab request.
 *		If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will attempt to grab the token on behalf of the requesting user.
 *		A token grab confirm will be issued to the requesting user informing
 *		it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token grab.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to grab.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGrabConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token grab confirm.
 *		This confirm will simply be forwarded in the direction of the
 *		requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the grab request.  If it is anything but
 *			RESULT_SUCCESSFUL, the grab request failed.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token grab.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to grab.
 *		token_status (i)
 *			This is the state of the token after the grab request was
 *			processed at the top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenInhibitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token inhibit
 *		request.  If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will attempt to inhibit the token on behalf of the requesting
 *		user.  A token inhibit confirm will be issued to the requesting user
 *		informing it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token inhibit.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to inhibit.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenInhibitConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token inhibit
 *		confirm.  This confirm will simply be forwarded in the direction of the
 *		requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the inhibit request.  If it is anything but
 *			RESULT_SUCCESSFUL, the inhibit request failed.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token inhibit.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to inhibit.
 *		token_status (i)
 *			This is the state of the token after the inhibit request was
 *			processed at the top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveRequest (
 *						PCommandTarget		originator,
 *						PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This member function represents the reception of a token give request.
 *		If this is not the top provider, the request will be forwarded upward
 *		towards the top provider.  If this is the top provider, the domain will
 *		issue a token give indication in the direction of the user identified
 *		to receive the token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveIndication (
 *						PCommandTarget		originator,
 *						PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This member function represents the reception of a token give
 *		indication.  This indication will be forwarded toward the user that
 *		is to receive the token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveResponse (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				receiver_id,
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token give response.
 *		If this is not the top provider, the response will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will make the appropriate changes to the state of the token in
 *		the local information base, and then issue a token give confirm to the
 *		user that initiated the give request.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This specifies whether or not the token was accepted.  Anything but
 *			RESULT_SUCCESSFUL indicates that the token was rejected.
 *		receiver_id (i)
 *			This is the ID of the user that has either accepted or rejected the
 *			token.
 *		token_id (i)
 *			This is the ID of the token that the user has been given.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveConfirm (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				uidInitiator,
 *						TokenID				token_id,
 *						TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token give confirm.
 *		This is forwarded toward the user that initiated the give request to
 *		inform it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This parameter specifies whether or not the token was accepted.
 *			Anything but RESULT_SUCCESSFUL indicates that the token was not
 *			accepted.
 *		uidInitiator (i)
 *			This is the ID of the user that originally requested the token
 *			give request.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to give.
 *		token_status (i)
 *			This specifies the status of the token after the give operation
 *			was complete.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenPleaseRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token please
 *		request.  If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will issue a token please indication in the direction of all
 *		users that currently own the token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is asking for the token.
 *		token_id (i)
 *			This is the ID of the token that the user is asking for.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenPleaseIndication (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token please
 *		indication.  This indication is forwarded to all users who currently
 *		own the specified token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is asking for the token.
 *		token_id (i)
 *			This is the ID of the token that the user is asking for.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenReleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token release
 *		request.  If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will attempt to release the token on behalf of the requesting
 *		user.  A token release confirm will be issued to the requesting user
 *		informing it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token release.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to release.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenReleaseConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token release
 *		confirm.  This confirm will simply be forwarded in the direction of the
 *		requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		result (i)
 *			This is the result of the release request.  If it is anything but
 *			RESULT_SUCCESSFUL, the release request failed.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token release.
 *		token_id (i)
 *			This is the ID of the token that the user is attempting to release.
 *		token_status (i)
 *			This is the state of the token after the release request was
 *			processed at the top provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenTestRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This member function represents the reception of a token test request.
 *		If this is not the top provider, the request will be forwarded
 *		upward towards the top provider.  If this is the top provider, the
 *		domain will test the current state of the token.  A token test confirm
 *		will be issued to the requesting user informing it of the outcome.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token test.
 *		token_id (i)
 *			This is the ID of the token that the user is testing.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenTestConfirm (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This member function represents the reception of a token test confirm.
 *		This confirm will simply be forwarded in the direction of the
 *		requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the command originated.
 *		uidInitiator (i)
 *			This is the ID of the user that is requesting the token test.
 *		token_id (i)
 *			This is the ID of the token that the user is testing.
 *		token_status (i)
 *			This is the state of the token at the time of the test.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\datapkt.h ===
/*
 *	datapkt.h
 *
 *	Copyright (c) 1997 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the interface file for the MCS Data Packet class.  Instances of this
 *		class represent MCS Data Protocol Data Units (Data PDUs) as they flow through the
 *		system.  These instances allocate the memory required to hold both
 *		encoded and decoded versions of the PDU, and make sure that no PDU
 *		is ever encoded or decoded more than once.  However, they differ from normal
 *		packets, in that there is only one copy of the user data in the encoded 
 *		and decoded buffers.  The use of lock counts
 *		allows multiple objects in the system to reference and use the same
 *		packet object at the same time.  This class inherits from the SimplePacket
 *		class, which is a pure virtual class.
 *
 *		A data packet object can be created in two different ways.  It can be created
 *		with either decoded data or encoded data.  During instantiation, the
 *		new packet object will include the memory it will need to
 *		hold both the encoded and decoded data
 *		The DataPacket class, however, does not put any data into those buffers.
 *
 *		When a Lock message is sent to the object, it will put encoded
 *		data into the encode buffer.  If the packet was created
 *		with decoded data, then this will entail an encode operation.  However,
 *		if the packet was created with encoded data, then it is smart enough
 *		to just COPY the encoded data into the internal buffer, thus avoiding
 *		the overhead associated with the encode operation.
 *                  
 *		When a Lock message is sent to the object, it will put decoded
 *		data into the pre-allocated decode buffer.  If the packet was created
 *		with encoded data, then this will entail a decode operation.  However,
 *		if the packet was created with decoded data, then it is smart enough
 *		to just COPY the decoded data into the internal buffer, thus avoiding
 *		the overhead associated with the decode operation.
 *
 *		When Unlock messages are received, the lock count is decremented.  When a packet's
 *		lock count is 0, the packet deletes itself (it commits
 *		suicide).  Note that for this reason, no other object should explicitly
 *		delete a packet object.
 *                  
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		Christos Tsollis
 */

#ifndef _DATAPACKET_
#define _DATAPACKET_

#include "mpdutype.h"

/*
 *	 Definition of class DataPacket.
 */

class DataPacket;
typedef DataPacket *		PDataPacket;

class DataPacket : public SimplePacket
{
	public:
		static Void		AllocateMemoryPool (long maximum_objects);
		static Void		FreeMemoryPool ();
		PVoid			operator new (size_t);
		Void			operator delete (PVoid	object);

						DataPacket (ASN1choice_t		choice,
									PUChar				data_ptr,
									ULong				data_length,
									UINT				channel_id,
									Priority			priority,
									Segmentation		segmentation,
									UINT				initiator_id,
									SendDataFlags		flags,
									PMemory				memory,
									PPacketError		packet_error);	
						DataPacket(	PTransportData		pTransportData,
									BOOL				fPacketDirectionUp);	
		virtual			~DataPacket ();
		Void			SetDirection (DBBoolean packet_direction_up);
		virtual PVoid	GetDecodedData(void);
		virtual BOOL	IsDataPacket (void);
		virtual int		GetPDUType (void);
		BOOL			Equivalent (PDataPacket);
		Priority		GetPriority (void) 
						{
							return ((Priority) m_DecodedPDU.u.send_data_request.
												data_priority);
						};
		UserID			GetInitiator (void)
						{
							return (m_DecodedPDU.u.send_data_request.initiator);
						};
		ChannelID		GetChannelID (void)
						{
							return (m_DecodedPDU.u.send_data_request.channel_id);
						};
		Segmentation	GetSegmentation (void)
						{
							return (m_DecodedPDU.u.send_data_request.segmentation);
						};
		LPBYTE			GetUserData (void)
						{
							return ((LPBYTE) m_DecodedPDU.u.send_data_request.user_data.value);
						};
		UINT			GetUserDataLength (void)
						{
							return (m_DecodedPDU.u.send_data_request.user_data.length);
						};
		PMemory			GetMemory (void)
						{
							return (m_Memory);
						};
		BOOL			IsEncodedDataBroken (void)
						{
							return (m_EncodedDataBroken);
						};

        void SetMessageType(UINT nMsgType) { m_nMessageType = nMsgType; }
        UINT GetMessageType(void) { return m_nMessageType; }

	protected:
	
		static PVoid *	Object_Array;
		static long		Object_Count;
		BOOL			fPreAlloc;

		DomainMCSPDU	m_DecodedPDU;	// The decoded data PDU (w/o the user data)
		PMemory			m_Memory;		// Memory object pointing to big buffer which contains the object's buffer.
		BOOL			m_fIncoming;	// Does this packet represent recv data?
		BOOL			m_EncodedDataBroken;
		UINT            m_nMessageType; // for retry in CUser::SendDataIndication
};


/*
 *	Void	AllocateMemoryPool (
 *					long			maximum_objects);
 *
 *	Functional Description:
 *		This is a static member function that should only be called during MCS
 *		initialization (exactly once).  It allocates a memory block that will
 *		be used to hold all instances of this class during the operation of
 *		the system.  This allows us to VERY efficiently allocate and destroy
 *		instances of this class.
 *
 *	Formal Parameters:
 *		maximum_objects
 *			This is the maximum number of objects of this class that can exist
 *			in the system at the same time.  This is used to determine how much
 *			memory to allocate to hold the objects.  Once this number of
 *			objects exist, all calls to "new" will return NULL.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	FreeMemoryPool ();
 *
 *	Functional Description:
 *		This is a static member function that should only be called during a
 *		shutdown of MCS (exactly once).  It frees up the memory pool allocated
 *		to hold all instances of this class.  Note that calling this function
 *		will cause ALL existing instances of this class to be invalid (they
 *		no longer exist, and should not be referenced).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		Any existing instances of this class are no longer valid and should not
 *		be referenced.
 *
 *	Caveats:
 *		None.
 */

/*
 *	PVoid	operator new (
 *					size_t			object_size);
 *
 *	Functional Description:
 *		This is an override of the "new" operator for this class.  Since all
 *		instances of this class come from a single memory pool allocated up
 *		front, this function merely pops the first entry from the list of
 *		available objects.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		Pointer to an object of this class, or NULL if no memory is available.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	operator delete (
 *					PVoid			object);
 *
 *	Functional Description:
 *		This function is used to free up a previously allocated object of this
 *		class.  Note that it is VERY important not to call this function with an
 *		invalid address, because no error checking is performed.  This decision
 *		was made due to speed requirements.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	DataPacket(	PUChar			pEncodedData,
 *				ULong			ulEncodedDataSize,
 *				BOOL			fPacketDirectionUp,
 *				PPacketError	pePktErr)
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Data Packet object
 *		for incomming PDUs when the packet is to be created from an encoded
 *		data stream containing the PDU data to be decoded.
 *
 *	Formal Parameters:
 *		pEncodedData (i)
 *			Pointer to the input encoded PDU.
 *		ulEncodedDataSize (i)
 *			The length in bytes of the input encoded PDU.
 *		fPacketDirectionUp (i)
 *			The packet_direction_up flag indicates the initial orientation of
 *			the packet.  Valid values are:
 *				TRUE -	The packet's direction is up.
 *				FALSE -	The packet's direction is down.
 *		pePktErr (o)
 *			When the constructor returns control to the calling function, this
 *			variable will be set to one of the return values listed below.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */							      

/*
 *	DataPacket (ASN1choice_t	choice,
 *				PUChar			data_ptr,
 *				ULong			data_length,
 *				UINT			channel_id,
 *				Priority		priority,
 *				Segmentation	segmentation,
 *				UINT			initiator_id,
 *				PPacketError	packet_error)
 *
 *	Functional Description:
 *		This constructor is used for outgoing data packets.
 *		It needs to copy the data into the encoded PDU buffer
 *		that will be allocated by this constructor.
 *
 *	Formal Parameters:
 *		choice (i)
 *			Either normal or uniform send data PDU
 *		data_ptr (i)
 *			Pointer to the user data for this data PDU.
 *		data_length (i)
 *			The length of the user data
 *		channel_id (i)
 *			The MCS channel on which the data will be xmitted.
 *		priority (i)
 *			Data priority
 *		segmentation (i)
 *			The segmentation bits for the packet
 *		initiator_id (i)
 *			MCS user id of the user (application) sending the data
 *		packet_error (o)
 *			Ptr to location for storing the success/failure code for the constructor.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */	
/*
 *	~DataPacket ()
 *
 *	Functional Description:
 *		Destructor for the DataPacket class.  The destructor ensures that all 
 *		resources that have been allocated are freed.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedData ()
 *
 *	Functional Description:
 *		The GetDecodedData method returns a pointer to the decoded data
 *		buffer.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the decoded data.  If an decoding error occurs, this
 *		method will return NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetEncodedDataLength ()
 *
 *	Functional Description:
 *		This method returns the encoded data's length.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of bytes in the encoded data.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedDataLength ()
 *
 *	Functional Description:
 *		This method returns the decoded data's length.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of bytes in the decoded data.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\fclasses.h ===
#ifndef __FORWARD_DECL_CLASSES__
#define __FORWARD_DECL_CLASSES__

// Forward declarations of GCC classes

class CAppRoster;
class CAppRosterMgr;
class CAppRosterMsg;

class CConfRoster;
class CConfRosterMgr;
class CConfRosterMsg;

class CConf;

class CBaseSap;
class CAppSap;
class CControlSAP;

// Forward declarations of MCS classes

class Domain;
typedef Domain *PDomain;

class Channel;
typedef Channel *PChannel;

class PrivateChannel;
typedef PrivateChannel *PPrivateChannel;

class UserChannel;
typedef UserChannel *PUserChannel;

class Connection;
typedef Connection *PConnection;

class User;
typedef User *PUser;

class Token;
typedef Token *PToken;

class SimplePacket;
typedef SimplePacket *PSimplePacket;

class CAttachment;

#endif // __FORWARD_DECL_CLASSES__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\crost.h ===
/*
 *	crost.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		Instances of this class represent a single Conference Roster's
 *		information base.  It encapsulates all the functionality required to
 *		maintain the information base which includes the ability to add new
 *		roster records, delete records and update records.  It has the ability
 *		to convert its internal information base into a list of conference
 *		records that can be used in a GCC_ROSTER_UPDATE_INDICATION callback.  It
 *		is also responsible for converting its internal information base into
 *		Conference Roster Update PDUs.  Basically,  this class is responsible
 *		for all operations that require direct access to the records contained
 *		in a Conference Roster.
 *
 *		The Conference Roster class incorporates Rogue Wave list to hold the
 *		roster record information.  Using iterators throughout the class makes
 *		it easy to quickly convert the information contained in the list into
 *		either a PDU or into a list of record pointers (for roster update
 *		indications back to the node controller).
 *
 *		A Conference Roster object has the ability to serialize its roster data
 *		into a single contiguous memory block when it is required to send a
 *		message to the application interface.  This serialization process is
 *		managed externally by the CConfRosterMsg class through calls to
 *		LockConferenceRoster(), UnLockConferenceRoster() and
 *		GetConfRoster().  When a conference roster is to be serialized, a
 *		call is made to LockConferenceRoster() which causes the CConfRoster
 *		object to increment an internal lock count and returns the number of
 *		bytes required to hold the complete roster update.  The Conference
 *		Roster is then serialized into memory through a call to
 *		GetConfRoster().  The CConfRoster is then unlocked to allow
 *		it to be deleted when the free flag gets set through the
 *		FreeConferenceRoster() function.  In the current implementation of GCC,
 *		FreeConferenceRoster() is not used since the CConfRosterMsg
 *		maintains the data used to deliver the message (see a more detailed
 *		description of the lock, free and unlock mechanism in the section
 *		describing the data containers).
 *
 *		The Conference Roster object also is responsible for maintaining
 *		internal PDU data which is updated whenever a change occurs to its
 *		internal information base.  This PDU can be affected by both local
 *		request or by processing incoming PDUs.  Higher level objects access
 *		this PDU data by calling the Conference Roster's flush routine which in
 *		turn causes the PDU to be freed on any subsequent request that affects
 *		the rosters internal information base.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_CONFERENCE_ROSTER_
#define	_CONFERENCE_ROSTER_

#include "netaddr.h"
#include "userdata.h"
#include "clists.h"

/*
**	These enumerations define the different ways the a conference roster list
**	can be updated.  It is used externally to inform a conference roster object
**	what to of send data PDU to build.
*/
typedef enum
{
	ADD_RECORD,
	DELETE_RECORD,
	REPLACE_RECORD,
	FULL_REFRESH
}
	CONF_ROSTER_UPDATE_TYPE;

/*
**	This list is used to keep track of the conference participants.  It is
**	a list of rogue wave pointers to Unicode Strings.
*/
class CParticipantNameList : public CList
{
	DEFINE_CLIST(CParticipantNameList, LPWSTR)
	void DeleteList(void);
};

/*
**	This is the structure used to maintain the conference roster information
**	internally.  Optional paramters use a NULL pointer to indicate that the
**	parameter is not in use.
*/
typedef struct CONF_RECORD
{
	CONF_RECORD(void);
	~CONF_RECORD(void);

	UserID					superior_node;
	NodeType				node_type;
	NodeProperties			node_properties;
	LPWSTR					pwszNodeName;
	CParticipantNameList	*participant_name_list;
	LPWSTR					pwszSiteInfo;
	CNetAddrListContainer   *network_address_list;
	LPOSTR					poszAltNodeID;
	CUserDataListContainer  *user_data_list;
}
	CONF_RECORD;

/*
**	This list is used to hold the pointers to the actual conference record for
**	each node in the conference.  The list is indexed by the Node ID associated
**	with the record.
*/
class CConfRecordList2 : public CList2
{
	DEFINE_CLIST2_(CConfRecordList2, CONF_RECORD*, UserID)
	void CleanList(void);
};


class CConfRoster : public CRefCount
{
public:

	CConfRoster(UserID uidTopProvider, UserID uidSuperiorNode, UserID uidMime,
				BOOL is_top_provider, BOOL is_local_roster, BOOL maintain_pdu_buffer);

	~CConfRoster(void);

	/*
	 * Utilities that operate on roster update PDU strucutures.
	 */
	void				FlushRosterUpdateIndicationPDU(PNodeInformation);
	GCCError			BuildFullRefreshPDU(void);
	GCCError			ProcessRosterUpdateIndicationPDU(PNodeInformation, UserID uidSender);

	/*
	 * Utilities used to generate a roster update message.
	 */
	UINT	    LockConferenceRoster(void);
	void		UnLockConferenceRoster(void);
	UINT		GetConfRoster(PGCCConferenceRoster *, LPBYTE memory_pointer);
	/*
	**	Utilities that operate directly on the conference roster objects
	**	internal databease.
	*/
	GCCError	AddRecord(PGCCNodeRecord, UserID);
	GCCError	ReplaceRecord(PGCCNodeRecord, UserID);
	GCCError	RemoveUserReference(UserID);

	/*
	**	Miscelaneous utilities.
	*/
	void    ResetConferenceRoster(void);

	UINT    GetNumberOfNodeRecords(void) { return m_RecordList2.GetCount(); }
	BOOL	Contains(UserID uidConf) { return m_RecordList2.Find(uidConf) ? TRUE : FALSE; }
	BOOL	HasRosterChanged(void) { return m_fRosterChanged; }

private:

	/*
	 * Utilities used to create a roster update indication PDU.
	 */
	GCCError	BuildRosterUpdateIndicationPDU(CONF_ROSTER_UPDATE_TYPE, UserID);
	GCCError	BuildSetOfRefreshesPDU(void);
	GCCError	BuildSetOfUpdatesPDU(UserID, CONF_ROSTER_UPDATE_TYPE);
	GCCError	BuildParticipantsListPDU(UserID, PParticipantsList *);

	/*
	 * Utilities used to Free a roster update indication PDU.
	 */
	void    FreeRosterUpdateIndicationPDU(void);
	void    FreeSetOfRefreshesPDU(void);
	void    FreeSetOfUpdatesPDU(void);
	void    FreeParticipantsListPDU(PParticipantsList);
    void    CleanUpdateRecordPDU(PSetOfNodeRecordUpdates);

	/*
	 * Utilities used to Process roster update indications.
	 */
	GCCError				ProcessSetOfRefreshesPDU(PSetOfNodeRecordRefreshes);
	GCCError				ProcessSetOfUpdatesPDU(PSetOfNodeRecordUpdates);
	GCCError				ProcessParticipantsListPDU(PParticipantsList, CONF_RECORD *);
								
	/*
	 * Utilities used to operate on conference roster reports.
	 */
	void					ClearRecordList(void);
	
	void					GetNodeTypeAndProperties (
								NodeType			pdu_node_type,
								NodeProperties		pdu_node_properties,
								PGCCNodeType		node_type,
								PGCCNodeProperties	node_properties);

	void					GetPDUNodeTypeAndProperties (
								GCCNodeType			node_type,
								GCCNodeProperties	node_properties,
								PNodeType			pdu_node_type,
								PNodeProperties		pdu_node_properties);
	
	GCCError				DeleteRecord(UserID node_id);

	GCCError				GetNodeSubTree(UserID, CUidList *);

private:

	BOOL					m_fNodesAdded;
	BOOL	 				m_fNodesRemoved;
	BOOL	 				m_fRosterChanged;
	BOOL					m_fTopProvider;
	BOOL					m_fLocalRoster;
	BOOL					m_fMaintainPduBuffer;
	BOOL					m_fPduFlushed;
	UserID					m_uidTopProvider;
	UserID					m_uidSuperiorNode;
	UserID					m_uidMyNodeID;
	UINT					m_nInstanceNumber;
	UINT					m_cbDataMemorySize;
	NodeInformation			m_NodeInformation;
	CConfRecordList2		m_RecordList2;
	PSetOfNodeRecordUpdates	m_pNodeRecordUpdateSet;
};

#endif

/*
 *	CConfRoster(	UserID					top_provider_id,
 *						UserID					superior_node,
 *						BOOL					is_top_provider,
 *						BOOL					is_local_roster,
 *						BOOL					maintain_pdu_buffer,
 *
 *	Public Function Description
 *		This is the conference roster constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *
 *	Formal Parameters:
 *		top_provider_id		-	(i) The Node ID of the Top Provider
 *		superior_node		-	(i) The Node ID of the node that is the parent
 *								to this one. Zero for the top provider.
 *		is_top_provider		-	(i)	Indicates if this is the top provider node.
 *		is_local_roster		-	(i)	Indicates if this roster is a local one.
 *		maintain_pdu_buffer	-	(i)	Indicates if this roster should maintain
 *									a PDU buffer.
 *		
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	~CConfRoster ()
 *
 *	Public Function Description
 *		This is the conference roster destructor. It is responsible for
 *		freeing up all the internal memory used by this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	FlushRosterUpdateIndicationPDU (
 *								PNodeInformation			node_information)
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the conference roster.  PDU data is queued whenever
 *		a request is made to the conference roster that affects its
 *		internal information base.
 *
 *	Formal Parameters:
 *		node_information	-	(o) Pointer to the PDU buffer to fill in.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The PDU data returned by this routine is automatically freed the next
 *		time a request is made to this roster object that affects its internal
 *		databease.
 */

/*
 *	GCCError	BuildFullRefreshPDU (void)
 *
 *	Public Function Description
 *		This routine is responsible for generating a full conference roster
 *		refresh PDU.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ProcessRosterUpdateIndicationPDU (
 *						PNodeInformation			node_information)
 *
 *	Public Function Description
 *		This routine is responsible for processing the decoded PDU data.
 *		It essentially changes the conference roster objects internal database
 *		based on the information in the structure.
 *
 *	Formal Parameters:
 *		node_information	-	(i) This is a pointer to a structure that
 *									holds the decoded PDU data.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	UINT		LockConferenceRoster()
 *
 *	Public Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCConferenceRoster structure
 *		which is filled in on a call to GetConfRoster.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to
 *		GetConfRoster.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCConferenceRoster
 *		structure provided as an output parameter to the GetConfRoster
 *		call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free"
 *		flag as a mechanism for ensuring that this object remains in existance
 *		until all interested parties are through with it.  The object remains
 *		valid (unless explicity deleted) until the lock count is zero and the
 *		"free" flag is set through a call to FreeConferenceRoster.  This allows
 *		other objects to lock this object and be sure that it remains valid
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CConfRoster
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeConferenceRoster call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CConfRoster object will automatically delete itself when
 *		the FreeConferenceRoster call is made.  If, however, any number of
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */

/*
 *	void			UnLockConferenceRoster ();
 *
 *	Public Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine
 *		whether the object has been freed through a call to
 *		FreeConferenceRoster.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks an CConfRoster
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CConfRoster
 *		object,	it should assume the object to be invalid thereafter.
 */

/*
 *  UINT		GetConfRoster(
 *        					PGCCConferenceRoster	FAR * 	conference_roster,
 *                          LPSTR							memory_pointer);
 *
 *	Public Function Description:
 *		This routine is used to retrieve the conference roster data from
 *		the CConfRoster object in the "API" form of a GCCConferenceRoster.
 *
 *	Formal Parameters:
 *		conference_roster	(o)	The GCCConferenceRoster structure to fill in.
 *		memory_pointer		(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError		AddRecord(	PGCCNodeRecord			conference_record,
 *								UserID					node_id)
 *
 *	Public Function Description:
 *		This routine is used to add a single nodes conference record to the
 *		conference roster object's internal list of records.
 *
 *	Formal Parameters:
 *		conference_record	(i)	Pointer to the "API" record	structure to add.
 *		node_id				(i)	Node ID associated with record being added.	
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *												an invalid object key.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RemoveRecord(UserID			node_id)
 *
 *	Public Function Description:
 *		This routine is used to remove a single nodes conference record from the
 *		conference roster object's internal list of records.
 *
 *	Formal Parameters:
 *		node_id				(i)	Node ID of record to be removed.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	ReplaceRecord(		PGCCNodeRecord			conference_record,
 *									UserID					node_id)
 *
 *	Public Function Description:
 *		This routine is used to replace a single nodes conference record in the
 *		conference roster object's internal list of records.
 *
 *	Formal Parameters:
 *		conference_record	(i)	Conference record to use as the replacement.
 *		node_id				(i)	Node ID of record to be replaced.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *		GCC_INVALID_PARAMETER			-	Invalid parameter passed in.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GCCError	RemoveUserReference (
 *							UserID					detached_node)
 *
 *	Public Function Description:
 *		This routine removes the record associated with the specified node
 *		id.
 *
 *	Formal Parameters:
 *		detached_node		(i)	Node reference to remove.
 *
 *	Return Value:
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_INVALID_PARAMETER		-	No records associated with this node
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL			Contains( UserID			conference_node_id )
 *
 *	Public Function Description:
 *		This routine is used to determine if the specified record exists in
 *		the conference roster.
 *
 *	Formal Parameters:
 *		conference_node_id	(i)	Node ID of record to check for
 *
 *	Return Value:
 *		TRUE	-	If the record is contained in the conference roster.
 *		FALSE	-	If the record is not contained in the conference roster.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	USHORT		GetNumberOfNodeRecords ();
 *
 *	Public Function Description:
 *		This routine returns the total number of conference roster records
 *		contained in the objects conference roster record list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of records in the conference roster list.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void		ResetConferenceRoster ()
 *
 *	Public Function Description:
 *		This routine takes care of resetting all the internal flags that are
 *		used to convey the current state of the conference roster.  Should be
 *		called after the roster is flushed and any roster update messages have
 *		been delivered (after a change to the roster occurs).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL			HasRosterChanged ();
 *
 *	Public Function Description:
 *		This routine informs the caller if the roster has changed since the
 *		last time it was reset.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE		-	If roster has changed
 *		FALSE		-	If roster has not changed
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\fsdiag.h ===
// fsdiag.h


#ifndef	_FSDIAG_
#define	_FSDIAG_

#define MULTI_LEVEL_ZONES
#include <mlzdbg.h>

#if defined(_DEBUG)

VOID T120DiagnosticCreate(VOID);
VOID T120DiagnosticDestroy(VOID);

#define TRACE_OUT_EX(z,s)	(MLZ_TraceZoneEnabled(z) || MLZ_TraceZoneEnabled(MLZ_FILE_ZONE))  ? (MLZ_TraceOut s) : 0

#else

#define T120DiagnosticCreate()
#define T120DiagnosticDestroy()
#define DEBUG_FILEZONE(z)

#define TRACE_OUT_EX(z,s)

#endif // _DEBUG


#ifdef _DEBUG

enum
{
    ZONE_T120_MCSNC = BASE_ZONE_INDEX,
    ZONE_T120_GCCNC,    // GCC Provider
    ZONE_T120_MSMCSTCP,
    ZONE_T120_SAP,      // GCC App SAP and Control SAP
    ZONE_T120_APP_ROSTER,
    ZONE_T120_CONF_ROSTER,
    ZONE_T120_REGISTRY, // GCC App Registry
    ZONE_T120_MEMORY,
    ZONE_T120_UTILITY,
    ZONE_GCC_NC,        // GCC Node Controller
    ZONE_GCC_NCI,       // GCC Node Controller Interface INodeController
    ZONE_T120_T123PSTN,
};

extern UINT MLZ_FILE_ZONE;
#define DEBUG_FILEZONE(z)  static UINT MLZ_FILE_ZONE = (z)

#endif // _DEBUG

#endif // _FSDIAG_


// lonchanc: this must be outside the _FSDIAG_ protection.
#if defined(_DEBUG) && defined(INIT_DBG_ZONE_DATA)

static const PSTR c_apszDbgZones[] =
{
	"T.120",				// debug zone module name
	DEFAULT_ZONES
	TEXT("MCS"),			// ZONE_T120_MCSNC
	TEXT("GCC"),			// ZONE_T120_GCCNC
	TEXT("TCP"),			// ZONE_T120_MSMCSTCP
	TEXT("SAP"),			// ZONE_T120_SAP
	TEXT("A-Roster"),		// ZONE_T120_APP_ROSTER
	TEXT("C-Roster"),		// ZONE_T120_CONF_ROSTER
	TEXT("Registry"),		// ZONE_T120_REGISTRY
	TEXT("Memory Tracking"),// ZONE_T120_MEMORY
	TEXT("Common"),			// ZONE_T120_UTILITY
	TEXT("GCC NC"),         // ZONE_GCC_NC
	TEXT("GCC NC Intf"),    // ZONE_GCC_NCI
    TEXT("T123 PSTN"),      // ZONE_T120_T123PSTN
};

UINT MLZ_FILE_ZONE = ZONE_T120_UTILITY;

#endif // _DEBUG && INIT_DBG_ZONE_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\framer.h ===
/*	Framer.h
 *
 *	Copyright (c) 1994-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the packet frame base class.  This class defines the behavior
 *		for other packet framers that inherit from this class.  Some packet
 *		framing definitions can be found in RFC1006 and Q.922
 *	
 *	Caveats:
 *
 *	Authors:
 *		James W. Lawwill
 */

#ifndef _PACKETFRAME_
#define _PACKETFRAME_

#include "databeam.h"

typedef	enum
{
	PACKET_FRAME_NO_ERROR,
	PACKET_FRAME_DEST_BUFFER_TOO_SMALL,
	PACKET_FRAME_PACKET_DECODED,
	PACKET_FRAME_ILLEGAL_FLAG_FOUND,
	PACKET_FRAME_FATAL_ERROR
}	PacketFrameError;

class  PacketFrame
{
	public:

		virtual	PacketFrameError	PacketEncode (
										PUChar		source_address, 
										UShort		source_length,
										PUChar		dest_address,
										UShort		dest_length,
										DBBoolean	prepend_flag,
										DBBoolean	append_flag,
										PUShort		packet_size) = 0;
									
		virtual	PacketFrameError	PacketDecode (
										PUChar		source_address,
										UShort		source_length,
										PUChar		dest_address,
										UShort		dest_length,
										PUShort		bytes_accepted,
										PUShort		packet_size,
										DBBoolean	continue_packet) = 0;
		virtual	Void				GetOverhead (
										UShort		original_packet_size,
										PUShort		max_packet_size) = 0;


};
typedef	PacketFrame	*	PPacketFrame;

#endif


/*	
 *	PacketFrameError	PacketFrame::PacketEncode (
 *										PUChar		source_address, 
 *										UShort		source_length,
 *										PUChar		dest_address,
 *										UShort		dest_length,
 *										DBBoolean	packet_start,
 *										DBBoolean	packet_end,
 *										PUShort		packet_size) = 0;
 *
 *	Functional Description
 *		This function receives takes the source data and encodes it.
 *
 *	Formal Parameters
 *		source_address	- (i)	Address of source buffer
 *		source_length	- (i)	Length of source buffer
 *		dest_address	- (i)	Address of destination buffer.
 *		dest_length		- (i)	Length of destination buffer.
 *		packet_start	- (i)	This is the beginning of a packet.
 *		packet_end		- (i)	This is the end of a packet.
 *		packet_size		- (o)	Size of packet after encoding
 *
 *	Return Value
 *		PACKET_FRAME_NO_ERROR				-	No error
 *		PACKET_FRAME_FATAL_ERROR			-	Fatal error during encode
 *		PACKET_FRAME_DEST_BUFFER_TOO_SMALL	-	Self-explanatory
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */

/*	
 *	PacketFrameError	PacketFrame::PacketDecode (
 *										PUChar		source_address,
 *										UShort		source_length,
 *										PUChar		dest_address,
 *										UShort		dest_length,
 *										PUShort		bytes_accepted,
 *										PUShort		packet_size,
 *										DBBoolean	continue_packet) = 0;
 *
 *	Functional Description
 *		This function takes the stream data passed in and decodes it into a
 *		packet
 *		
 *	Formal Parameters
 *		source_address	- (i)	Address of source buffer.  If this parm is 
 *								NULL, continue using the current address.
 *		source_length	- (i)	Length of source buffer
 *		dest_address	- (i)	Address of destination buffer.  If this address
 *								is NULL, continue using current buffer.
 *		dest_length		- (i)	Length of destination buffer.
 *		bytes_accepted	- (o)	Number of bytes processed before return
 *		packet_size		- (o)	Size of packet after decoding
 *		continue_packet	- (i)	Restart decoding
 *
 *	Return Value
 *		PACKET_FRAME_NO_ERROR				-	No error
 *		PACKET_FRAME_FATAL_ERROR			-	Fatal error during encode
 *		PACKET_FRAME_DEST_BUFFER_TOO_SMALL	-	Self-explanatory
 *		PACKET_FRAME_PACKET_DECODED			-	Self-explanatory
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 *
 */

/*	
 *	Void	PacketFrame::GetOverhead (
 *							UShort	original_packet_size,
 *							PUShort	max_packet_size) = 0;
 *
 *	Functional Description
 *		This returns the new maximum packet size
 *
 *	Formal Parameters
 *		original_packet_size	- (i)
 *		max_packet_size			- (o)	new maximum packet size
 *
 *	Return Value
 *		PACKET_FRAME_NO_ERROR	-	No error
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 *
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\gccpdu.h ===
#ifndef _GCCPDU_Module_H_
#define _GCCPDU_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct WaitingList * PWaitingList;

typedef struct PermissionList * PPermissionList;

typedef struct SetOfDestinationNodes * PSetOfDestinationNodes;

typedef struct SetOfTransferringNodesIn * PSetOfTransferringNodesIn;

typedef struct SetOfTransferringNodesRs * PSetOfTransferringNodesRs;

typedef struct SetOfTransferringNodesRq * PSetOfTransferringNodesRq;

typedef struct ParticipantsList * PParticipantsList;

typedef struct SetOfPrivileges * PSetOfPrivileges;

typedef struct SetOfApplicationRecordUpdates * PSetOfApplicationRecordUpdates;

typedef struct SetOfApplicationRecordRefreshes * PSetOfApplicationRecordRefreshes;

typedef struct SetOfApplicationCapabilityRefreshes * PSetOfApplicationCapabilityRefreshes;

typedef struct SetOfNodeRecordUpdates * PSetOfNodeRecordUpdates;

typedef struct SetOfNodeRecordRefreshes * PSetOfNodeRecordRefreshes;

typedef struct ApplicationProtocolEntityList * PApplicationProtocolEntityList;

typedef struct SetOfApplicationInformation * PSetOfApplicationInformation;

typedef struct SetOfConferenceDescriptors * PSetOfConferenceDescriptors;

typedef struct SetOfExpectedCapabilities * PSetOfExpectedCapabilities;

typedef struct SetOfNonCollapsingCapabilities * PSetOfNonCollapsingCapabilities;

typedef struct SetOfChallengeItems * PSetOfChallengeItems;

typedef struct SetOfUserData * PSetOfUserData;

typedef struct SetOfNetworkAddresses * PSetOfNetworkAddresses;

typedef ASN1uint16_t ChannelID;

typedef ASN1uint16_t StaticChannelID;

typedef ASN1uint16_t DynamicChannelID;

typedef DynamicChannelID UserID;

typedef ASN1uint16_t TokenID;

typedef ASN1uint16_t StaticTokenID;

typedef ASN1uint16_t DynamicTokenID;

typedef ASN1int32_t Time;

typedef ASN1uint32_t Handle;

typedef struct H221NonStandardIdentifier {
    ASN1uint32_t length;
    ASN1octet_t value[255];
} H221NonStandardIdentifier;

typedef ASN1char16string_t TextString;

typedef ASN1char16string_t SimpleTextString;

typedef ASN1char_t SimpleNumericString[256];

typedef ASN1char_t DialingString[17];

typedef ASN1char_t SubAddressString[41];

typedef TextString ExtraDialingString;

typedef SimpleNumericString ConferenceNameModifier;

typedef enum Privilege {
    terminate = 0,
    ejectUser = 1,
    add = 2,
    lockUnlock = 3,
    transfer = 4,
} Privilege;

typedef enum TerminationMethod {
    automatic = 0,
    manual = 1,
} TerminationMethod;

typedef enum NodeType {
    terminal = 0,
    multiportTerminal = 1,
    mcu = 2,
} NodeType;

typedef enum ChannelType {
    ChannelType_static = 0,
    dynamicMulticast = 1,
    dynamicPrivate = 2,
    dynamicUserId = 3,
} ChannelType;

typedef ASN1uint16_t EntityID;

typedef enum RegistryModificationRights {
    owner = 0,
    session = 1,
    RegistryModificationRights_public = 2,
} RegistryModificationRights;

typedef struct ApplicationCapabilitiesList {
    ASN1choice_t choice;
    union {
#	define capability_no_change_chosen 1
#	define application_capability_refresh_chosen 2
	PSetOfApplicationCapabilityRefreshes application_capability_refresh;
    } u;
} ApplicationCapabilitiesList;

typedef struct ApplicationRecordList {
    ASN1choice_t choice;
    union {
#	define application_no_change_chosen 1
#	define application_record_refresh_chosen 2
	PSetOfApplicationRecordRefreshes application_record_refresh;
#	define application_record_update_chosen 3
	PSetOfApplicationRecordUpdates application_record_update;
    } u;
} ApplicationRecordList;

typedef struct HighLayerCompatibility {
    ASN1bool_t telephony3kHz;
    ASN1bool_t telephony7kHz;
    ASN1bool_t videotelephony;
    ASN1bool_t videoconference;
    ASN1bool_t audiographic;
    ASN1bool_t audiovisual;
    ASN1bool_t multimedia;
} HighLayerCompatibility;

typedef struct TransferModes {
    ASN1bool_t speech;
    ASN1bool_t voice_band;
    ASN1bool_t digital_56k;
    ASN1bool_t digital_64k;
    ASN1bool_t digital_128k;
    ASN1bool_t digital_192k;
    ASN1bool_t digital_256k;
    ASN1bool_t digital_320k;
    ASN1bool_t digital_384k;
    ASN1bool_t digital_512k;
    ASN1bool_t digital_768k;
    ASN1bool_t digital_1152k;
    ASN1bool_t digital_1472k;
    ASN1bool_t digital_1536k;
    ASN1bool_t digital_1920k;
    ASN1bool_t packet_mode;
    ASN1bool_t frame_mode;
    ASN1bool_t atm;
} TransferModes;

typedef struct TransportConnectionType {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    struct TransportConnectionType_nsap_address_nsap_address {
	ASN1uint32_t length;
	ASN1octet_t value[20];
    } nsap_address;
#   define transport_selector_present 0x80
    ASN1octetstring_t transport_selector;
} TransportConnectionType;

typedef struct AggregateChannel {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    TransferModes transfer_modes;
    DialingString international_number;
#   define sub_address_present 0x80
    SubAddressString sub_address;
#   define extra_dialing_string_present 0x40
    ExtraDialingString extra_dialing_string;
#   define high_layer_compatibility_present 0x20
    HighLayerCompatibility high_layer_compatibility;
} AggregateChannel;

typedef struct NodeRecordList {
    ASN1choice_t choice;
    union {
#	define node_no_change_chosen 1
#	define node_record_refresh_chosen 2
	PSetOfNodeRecordRefreshes node_record_refresh;
#	define node_record_update_chosen 3
	PSetOfNodeRecordUpdates node_record_update;
    } u;
} NodeRecordList;

typedef struct WaitingList {
    PWaitingList next;
    UserID value;
} WaitingList_Element;

typedef struct PermissionList {
    PPermissionList next;
    UserID value;
} PermissionList_Element;

typedef struct SetOfDestinationNodes {
    PSetOfDestinationNodes next;
    UserID value;
} SetOfDestinationNodes_Element;

typedef struct NodeInformation {
    NodeRecordList node_record_list;
    ASN1uint16_t roster_instance_number;
    ASN1bool_t nodes_are_added;
    ASN1bool_t nodes_are_removed;
} NodeInformation;

typedef struct SetOfTransferringNodesIn {
    PSetOfTransferringNodesIn next;
    UserID value;
} SetOfTransferringNodesIn_Element;

typedef struct SetOfTransferringNodesRs {
    PSetOfTransferringNodesRs next;
    UserID value;
} SetOfTransferringNodesRs_Element;

typedef struct SetOfTransferringNodesRq {
    PSetOfTransferringNodesRq next;
    UserID value;
} SetOfTransferringNodesRq_Element;

typedef struct RegistryEntryOwnerOwned {
    UserID node_id;
    EntityID entity_id;
} RegistryEntryOwnerOwned;

typedef struct ParticipantsList {
    PParticipantsList next;
    TextString value;
} ParticipantsList_Element;

typedef struct Key {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221_non_standard_chosen 2
	H221NonStandardIdentifier h221_non_standard;
    } u;
} Key;

typedef struct NonStandardParameter {
    Key key;
    ASN1octetstring_t data;
} NonStandardParameter;

typedef struct Password {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SimpleNumericString numeric;
#   define password_text_present 0x80
    SimpleTextString password_text;
} Password;

typedef struct PasswordSelector {
    ASN1choice_t choice;
    union {
#	define password_selector_numeric_chosen 1
	SimpleNumericString password_selector_numeric;
#	define password_selector_text_chosen 2
	SimpleTextString password_selector_text;
    } u;
} PasswordSelector;

typedef struct ChallengeResponseItem {
    ASN1choice_t choice;
    union {
#	define password_string_chosen 1
	PasswordSelector password_string;
#	define set_of_response_data_chosen 2
	PSetOfUserData set_of_response_data;
    } u;
} ChallengeResponseItem;

typedef struct ChallengeResponseAlgorithm {
    ASN1choice_t choice;
    union {
#	define algorithm_clear_password_chosen 1
#	define non_standard_algorithm_chosen 2
	NonStandardParameter non_standard_algorithm;
    } u;
} ChallengeResponseAlgorithm;

typedef struct ChallengeItem {
    ChallengeResponseAlgorithm response_algorithm;
    PSetOfUserData set_of_challenge_data;
} ChallengeItem;

typedef struct ChallengeRequest {
    ASN1int32_t challenge_tag;
    PSetOfChallengeItems set_of_challenge_items;
} ChallengeRequest;

typedef struct ChallengeResponse {
    ASN1int32_t challenge_tag;
    ChallengeResponseAlgorithm response_algorithm;
    ChallengeResponseItem response_item;
} ChallengeResponse;

typedef struct ConferenceName {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SimpleNumericString numeric;
#   define conference_name_text_present 0x80
    SimpleTextString conference_name_text;
} ConferenceName;

typedef struct ConferenceNameSelector {
    ASN1choice_t choice;
    union {
#	define name_selector_numeric_chosen 1
	SimpleNumericString name_selector_numeric;
#	define name_selector_text_chosen 2
	SimpleTextString name_selector_text;
    } u;
} ConferenceNameSelector;

typedef struct NodeProperties {
    ASN1bool_t device_is_manager;
    ASN1bool_t device_is_peripheral;
} NodeProperties;

typedef struct AsymmetryIndicator {
    ASN1choice_t choice;
    union {
#	define calling_node_chosen 1
#	define called_node_chosen 2
#	define unknown_chosen 3
	ASN1uint32_t unknown;
    } u;
} AsymmetryIndicator;

typedef struct AlternativeNodeID {
    ASN1choice_t choice;
    union {
#	define h243_node_id_chosen 1
	struct AlternativeNodeID_h243_node_id_h243_node_id {
	    ASN1uint32_t length;
	    ASN1octet_t value[2];
	} h243_node_id;
    } u;
} AlternativeNodeID;

typedef struct ConferenceDescriptor {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceName conference_name;
#   define conference_name_modifier_present 0x80
    ConferenceNameModifier conference_name_modifier;
#   define conference_description_present 0x40
    TextString conference_description;
    ASN1bool_t conference_is_locked;
    ASN1bool_t clear_password_required;
#   define descriptor_net_address_present 0x20
    PSetOfNetworkAddresses descriptor_net_address;
} ConferenceDescriptor;

typedef struct NodeRecord {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define superior_node_present 0x80
    UserID superior_node;
    NodeType node_type;
    NodeProperties node_properties;
#   define node_name_present 0x40
    TextString node_name;
#   define participants_list_present 0x20
    PParticipantsList participants_list;
#   define site_information_present 0x10
    TextString site_information;
#   define record_net_address_present 0x8
    PSetOfNetworkAddresses record_net_address;
#   define alternative_node_id_present 0x4
    AlternativeNodeID alternative_node_id;
#   define record_user_data_present 0x2
    PSetOfUserData record_user_data;
} NodeRecord;

typedef struct SessionKey {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Key application_protocol_key;
#   define session_id_present 0x80
    ChannelID session_id;
} SessionKey;

typedef struct ApplicationRecord {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1bool_t application_is_active;
    ASN1bool_t is_conducting_capable;
#   define record_startup_channel_present 0x80
    ChannelType record_startup_channel;
#   define application_user_id_present 0x40
    UserID application_user_id;
#   define non_collapsing_capabilities_present 0x20
    PSetOfNonCollapsingCapabilities non_collapsing_capabilities;
} ApplicationRecord;

typedef struct CapabilityID {
    ASN1choice_t choice;
    union {
#	define standard_chosen 1
	ASN1uint16_t standard;
#	define capability_non_standard_chosen 2
	Key capability_non_standard;
    } u;
} CapabilityID;

typedef struct CapabilityClass {
    ASN1choice_t choice;
    union {
#	define logical_chosen 1
#	define unsigned_minimum_chosen 2
	ASN1uint32_t unsigned_minimum;
#	define unsigned_maximum_chosen 3
	ASN1uint32_t unsigned_maximum;
    } u;
} CapabilityClass;

typedef struct ApplicationInvokeSpecifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SessionKey session_key;
#   define expected_capability_set_present 0x80
    PSetOfExpectedCapabilities expected_capability_set;
#   define invoke_startup_channel_present 0x40
    ChannelType invoke_startup_channel;
    ASN1bool_t invoke_is_mandatory;
} ApplicationInvokeSpecifier;

typedef struct RegistryKey {
    SessionKey session_key;
    struct RegistryKey_resource_id_resource_id {
	ASN1uint32_t length;
	ASN1octet_t value[64];
    } resource_id;
} RegistryKey;

typedef struct RegistryItem {
    ASN1choice_t choice;
    union {
#	define channel_id_chosen 1
	DynamicChannelID channel_id;
#	define token_id_chosen 2
	DynamicTokenID token_id;
#	define parameter_chosen 3
	struct RegistryItem_parameter_parameter {
	    ASN1uint32_t length;
	    ASN1octet_t value[64];
	} parameter;
#	define vacant_chosen 4
    } u;
} RegistryItem;

typedef struct RegistryEntryOwner {
    ASN1choice_t choice;
    union {
#	define owned_chosen 1
	RegistryEntryOwnerOwned owned;
#	define not_owned_chosen 2
    } u;
} RegistryEntryOwner;

typedef struct UserIDIndication {
    UINT_PTR tag;
} UserIDIndication;

typedef struct SetOfPrivileges {
    PSetOfPrivileges next;
    Privilege value;
} SetOfPrivileges_Element;

typedef struct ConferenceCreateRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceName conference_name;
#   define ccrq_convener_password_present 0x80
    Password ccrq_convener_password;
#   define ccrq_password_present 0x40
    Password ccrq_password;
    ASN1bool_t conference_is_locked;
    ASN1bool_t conference_is_listed;
    ASN1bool_t conference_is_conductible;
    TerminationMethod termination_method;
#   define ccrq_conductor_privs_present 0x20
    PSetOfPrivileges ccrq_conductor_privs;
#   define ccrq_conducted_privs_present 0x10
    PSetOfPrivileges ccrq_conducted_privs;
#   define ccrq_non_conducted_privs_present 0x8
    PSetOfPrivileges ccrq_non_conducted_privs;
#   define ccrq_description_present 0x4
    TextString ccrq_description;
#   define ccrq_caller_id_present 0x2
    TextString ccrq_caller_id;
#   define ccrq_user_data_present 0x1
    PSetOfUserData ccrq_user_data;
} ConferenceCreateRequest;

typedef enum ConferenceCreateResult {
    ConferenceCreateResult_success = 0,
    ConferenceCreateResult_userRejected = 1,
    resourcesNotAvailable = 2,
    rejectedForSymmetryBreaking = 3,
    lockedConferenceNotSupported = 4,
} ConferenceCreateResult;
typedef struct ConferenceCreateResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    UserID node_id;
    UINT_PTR tag;
    ConferenceCreateResult result;
#   define ccrs_user_data_present 0x80
    PSetOfUserData ccrs_user_data;
} ConferenceCreateResponse;

typedef struct ConferenceQueryRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NodeType node_type;
#   define cqrq_asymmetry_indicator_present 0x80
    AsymmetryIndicator cqrq_asymmetry_indicator;
#   define cqrq_user_data_present 0x40
    PSetOfUserData cqrq_user_data;
} ConferenceQueryRequest;

typedef enum ConferenceQueryResult {
    ConferenceQueryResult_success = 0,
    ConferenceQueryResult_userRejected = 1,
} ConferenceQueryResult;
typedef struct ConferenceQueryResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    NodeType node_type;
#   define cqrs_asymmetry_indicator_present 0x80
    AsymmetryIndicator cqrs_asymmetry_indicator;
    PSetOfConferenceDescriptors conference_list;
    ConferenceQueryResult result;
#   define cqrs_user_data_present 0x40
    PSetOfUserData cqrs_user_data;
} ConferenceQueryResponse;

typedef struct ConferenceInviteRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceName conference_name;
    UserID node_id;
    UserID top_node_id;
    UINT_PTR tag;
    ASN1bool_t clear_password_required;
    ASN1bool_t conference_is_locked;
    ASN1bool_t conference_is_listed;
    ASN1bool_t conference_is_conductible;
    TerminationMethod termination_method;
#   define cirq_conductor_privs_present 0x80
    PSetOfPrivileges cirq_conductor_privs;
#   define cirq_conducted_privs_present 0x40
    PSetOfPrivileges cirq_conducted_privs;
#   define cirq_non_conducted_privs_present 0x20
    PSetOfPrivileges cirq_non_conducted_privs;
#   define cirq_description_present 0x10
    TextString cirq_description;
#   define cirq_caller_id_present 0x8
    TextString cirq_caller_id;
#   define cirq_user_data_present 0x4
    PSetOfUserData cirq_user_data;
} ConferenceInviteRequest;

typedef enum ConferenceInviteResult {
    ConferenceInviteResult_success = 0,
    ConferenceInviteResult_userRejected = 1,
} ConferenceInviteResult;
typedef struct ConferenceInviteResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceInviteResult result;
#   define cirs_user_data_present 0x80
    PSetOfUserData cirs_user_data;
} ConferenceInviteResponse;

typedef struct ConferenceAddRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PSetOfNetworkAddresses add_request_net_address;
    UserID requesting_node;
    UINT_PTR tag;
#   define adding_mcu_present 0x80
    UserID adding_mcu;
#   define carq_user_data_present 0x40
    PSetOfUserData carq_user_data;
} ConferenceAddRequest;

typedef enum ConferenceAddResult {
    ConferenceAddResult_success = 0,
    ConferenceAddResult_invalidRequester = 1,
    invalidNetworkType = 2,
    invalidNetworkAddress = 3,
    addedNodeBusy = 4,
    networkBusy = 5,
    noPortsAvailable = 6,
    connectionUnsuccessful = 7,
} ConferenceAddResult;
typedef struct ConferenceAddResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    UINT_PTR tag;
    ConferenceAddResult result;
#   define cars_user_data_present 0x80
    PSetOfUserData cars_user_data;
} ConferenceAddResponse;

typedef struct ConferenceLockRequest {
    char placeholder;
} ConferenceLockRequest;

typedef enum ConferenceLockResult {
    ConferenceLockResult_success = 0,
    ConferenceLockResult_invalidRequester = 1,
    alreadyLocked = 2,
} ConferenceLockResult;
typedef struct ConferenceLockResponse {
    ConferenceLockResult result;
} ConferenceLockResponse;

typedef struct ConferenceLockIndication {
    char placeholder;
} ConferenceLockIndication;

typedef struct ConferenceUnlockRequest {
    char placeholder;
} ConferenceUnlockRequest;

typedef enum ConferenceUnlockResult {
    ConferenceUnlockResult_success = 0,
    ConferenceUnlockResult_invalidRequester = 1,
    alreadyUnlocked = 2,
} ConferenceUnlockResult;
typedef struct ConferenceUnlockResponse {
    ConferenceUnlockResult result;
} ConferenceUnlockResponse;

typedef struct ConferenceUnlockIndication {
    char placeholder;
} ConferenceUnlockIndication;

typedef enum ConferenceTerminateRequestReason {
    ConferenceTerminateRequestReason_userInitiated = 0,
    ConferenceTerminateRequestReason_timedConferenceTermination = 1,
} ConferenceTerminateRequestReason;
typedef struct ConferenceTerminateRequest {
    ConferenceTerminateRequestReason reason;
} ConferenceTerminateRequest;

typedef enum ConferenceTerminateResult {
    ConferenceTerminateResult_success = 0,
    ConferenceTerminateResult_invalidRequester = 1,
} ConferenceTerminateResult;
typedef struct ConferenceTerminateResponse {
    ConferenceTerminateResult result;
} ConferenceTerminateResponse;

typedef enum ConferenceTerminateIndicationReason {
    ConferenceTerminateIndicationReason_userInitiated = 0,
    ConferenceTerminateIndicationReason_timedConferenceTermination = 1,
} ConferenceTerminateIndicationReason;
typedef struct ConferenceTerminateIndication {
    ConferenceTerminateIndicationReason reason;
} ConferenceTerminateIndication;

typedef enum ConferenceEjectRequestReason {
    ConferenceEjectRequestReason_userInitiated = 0,
} ConferenceEjectRequestReason;
typedef struct ConferenceEjectUserRequest {
    UserID node_to_eject;
    ConferenceEjectRequestReason reason;
} ConferenceEjectUserRequest;

typedef enum ConferenceEjectResult {
    ConferenceEjectResult_success = 0,
    ConferenceEjectResult_invalidRequester = 1,
    invalidNode = 2,
} ConferenceEjectResult;
typedef struct ConferenceEjectUserResponse {
    UserID node_to_eject;
    ConferenceEjectResult result;
} ConferenceEjectUserResponse;

typedef enum ConferenceEjectIndicationReason {
    ConferenceEjectIndicationReason_userInitiated = 0,
    higherNodeDisconnected = 1,
    higherNodeEjected = 2,
} ConferenceEjectIndicationReason;
typedef struct ConferenceEjectUserIndication {
    UserID node_to_eject;
    ConferenceEjectIndicationReason reason;
} ConferenceEjectUserIndication;

typedef struct ConferenceTransferRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceNameSelector conference_name;
#   define ctrq_conference_modifier_present 0x80
    ConferenceNameModifier ctrq_conference_modifier;
#   define ctrq_net_address_present 0x40
    PSetOfNetworkAddresses ctrq_net_address;
#   define ctrq_transferring_nodes_present 0x20
    PSetOfTransferringNodesRq ctrq_transferring_nodes;
#   define ctrq_password_present 0x10
    PasswordSelector ctrq_password;
} ConferenceTransferRequest;

typedef enum ConferenceTransferResult {
    ConferenceTransferResult_success = 0,
    ConferenceTransferResult_invalidRequester = 1,
} ConferenceTransferResult;
typedef struct ConferenceTransferResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceNameSelector conference_name;
#   define ctrs_conference_modifier_present 0x80
    ConferenceNameModifier ctrs_conference_modifier;
#   define ctrs_transferring_nodes_present 0x40
    PSetOfTransferringNodesRs ctrs_transferring_nodes;
    ConferenceTransferResult result;
} ConferenceTransferResponse;

typedef struct ConferenceTransferIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ConferenceNameSelector conference_name;
#   define ctin_conference_modifier_present 0x80
    ConferenceNameModifier ctin_conference_modifier;
#   define ctin_net_address_present 0x40
    PSetOfNetworkAddresses ctin_net_address;
#   define ctin_transferring_nodes_present 0x20
    PSetOfTransferringNodesIn ctin_transferring_nodes;
#   define ctin_password_present 0x10
    PasswordSelector ctin_password;
} ConferenceTransferIndication;

typedef struct RosterUpdateIndication {
    ASN1bool_t refresh_is_full;
    NodeInformation node_information;
    PSetOfApplicationInformation application_information;
} RosterUpdateIndication;

typedef struct ApplicationInvokeIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PApplicationProtocolEntityList application_protocol_entity_list;
#   define destination_nodes_present 0x80
    PSetOfDestinationNodes destination_nodes;
} ApplicationInvokeIndication;

typedef struct RegistryRegisterChannelRequest {
    EntityID entity_id;
    RegistryKey key;
    DynamicChannelID channel_id;
} RegistryRegisterChannelRequest;

typedef struct RegistryAssignTokenRequest {
    EntityID entity_id;
    RegistryKey registry_key;
} RegistryAssignTokenRequest;

typedef struct RegistrySetParameterRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EntityID entity_id;
    RegistryKey key;
    struct RegistrySetParameterRequest_registry_set_parameter_registry_set_parameter {
	ASN1uint32_t length;
	ASN1octet_t value[64];
    } registry_set_parameter;
#   define parameter_modify_rights_present 0x80
    RegistryModificationRights parameter_modify_rights;
} RegistrySetParameterRequest;

typedef struct RegistryRetrieveEntryRequest {
    EntityID entity_id;
    RegistryKey key;
} RegistryRetrieveEntryRequest;

typedef struct RegistryDeleteEntryRequest {
    EntityID entity_id;
    RegistryKey key;
} RegistryDeleteEntryRequest;

typedef struct RegistryMonitorEntryRequest {
    EntityID entity_id;
    RegistryKey key;
} RegistryMonitorEntryRequest;

typedef struct RegistryMonitorEntryIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RegistryKey key;
    RegistryItem item;
    RegistryEntryOwner owner;
#   define entry_modify_rights_present 0x80
    RegistryModificationRights entry_modify_rights;
} RegistryMonitorEntryIndication;

typedef struct RegistryAllocateHandleRequest {
    EntityID entity_id;
    ASN1uint16_t number_of_handles;
} RegistryAllocateHandleRequest;

typedef enum RegistryAllocateHandleResult {
    RegistryAllocateHandleResult_successful = 0,
    noHandlesAvailable = 1,
} RegistryAllocateHandleResult;
typedef struct RegistryAllocateHandleResponse {
    EntityID entity_id;
    ASN1uint16_t number_of_handles;
    Handle first_handle;
    RegistryAllocateHandleResult result;
} RegistryAllocateHandleResponse;

typedef enum RegistryResponsePrimitiveType {
    registerChannel = 0,
    assignToken = 1,
    setParameter = 2,
    retrieveEntry = 3,
    deleteEntry = 4,
    monitorEntry = 5,
} RegistryResponsePrimitiveType;
typedef enum RegistryResponseResult {
    RegistryResponseResult_successful = 0,
    belongsToOther = 1,
    tooManyEntries = 2,
    inconsistentType = 3,
    entryNotFound = 4,
    entryAlreadyExists = 5,
    RegistryResponseResult_invalidRequester = 6,
} RegistryResponseResult;
typedef struct RegistryResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    EntityID entity_id;
    RegistryResponsePrimitiveType primitive_type;
    RegistryKey key;
    RegistryItem item;
    RegistryEntryOwner owner;
#   define response_modify_rights_present 0x80
    RegistryModificationRights response_modify_rights;
    RegistryResponseResult result;
} RegistryResponse;

typedef struct ConductorAssignIndication {
    UserID user_id;
} ConductorAssignIndication;

typedef struct ConductorReleaseIndication {
    char placeholder;
} ConductorReleaseIndication;

typedef struct ConductorPermissionAskIndication {
    ASN1bool_t permission_is_granted;
} ConductorPermissionAskIndication;

typedef struct ConductorPermissionGrantIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PPermissionList permission_list;
#   define waiting_list_present 0x80
    PWaitingList waiting_list;
} ConductorPermissionGrantIndication;

typedef struct ConferenceTimeRemainingIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Time time_remaining;
#   define time_remaining_node_id_present 0x80
    UserID time_remaining_node_id;
} ConferenceTimeRemainingIndication;

typedef struct ConferenceTimeInquireIndication {
    ASN1bool_t time_is_node_specific;
} ConferenceTimeInquireIndication;

typedef struct ConferenceTimeExtendIndication {
    Time time_to_extend;
    ASN1bool_t time_is_node_specific;
} ConferenceTimeExtendIndication;

typedef struct ConferenceAssistanceIndication {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define cain_user_data_present 0x80
    PSetOfUserData cain_user_data;
} ConferenceAssistanceIndication;

typedef struct TextMessageIndication {
    TextString message;
} TextMessageIndication;

typedef struct NonStandardPDU {
    NonStandardParameter data;
} NonStandardPDU;

typedef struct ConnectData {
    Key t124_identifier;
    ASN1octetstring_t connect_pdu;
} ConnectData;
#define ConnectData_PDU 0
#define SIZE_GCCPDU_Module_PDU_0 sizeof(ConnectData)

typedef struct IndicationPDU {
    ASN1choice_t choice;
    union {
#	define user_id_indication_chosen 1
	UserIDIndication user_id_indication;
#	define conference_lock_indication_chosen 2
	ConferenceLockIndication conference_lock_indication;
#	define conference_unlock_indication_chosen 3
	ConferenceUnlockIndication conference_unlock_indication;
#	define conference_terminate_indication_chosen 4
	ConferenceTerminateIndication conference_terminate_indication;
#	define conference_eject_user_indication_chosen 5
	ConferenceEjectUserIndication conference_eject_user_indication;
#	define conference_transfer_indication_chosen 6
	ConferenceTransferIndication conference_transfer_indication;
#	define roster_update_indication_chosen 7
	RosterUpdateIndication roster_update_indication;
#	define application_invoke_indication_chosen 8
	ApplicationInvokeIndication application_invoke_indication;
#	define registry_monitor_entry_indication_chosen 9
	RegistryMonitorEntryIndication registry_monitor_entry_indication;
#	define conductor_assign_indication_chosen 10
	ConductorAssignIndication conductor_assign_indication;
#	define conductor_release_indication_chosen 11
	ConductorReleaseIndication conductor_release_indication;
#	define conductor_permission_ask_indication_chosen 12
	ConductorPermissionAskIndication conductor_permission_ask_indication;
#	define conductor_permission_grant_indication_chosen 13
	ConductorPermissionGrantIndication conductor_permission_grant_indication;
#	define conference_time_remaining_indication_chosen 14
	ConferenceTimeRemainingIndication conference_time_remaining_indication;
#	define conference_time_inquire_indication_chosen 15
	ConferenceTimeInquireIndication conference_time_inquire_indication;
#	define conference_time_extend_indication_chosen 16
	ConferenceTimeExtendIndication conference_time_extend_indication;
#	define conference_assistance_indication_chosen 17
	ConferenceAssistanceIndication conference_assistance_indication;
#	define text_message_indication_chosen 18
	TextMessageIndication text_message_indication;
#	define non_standard_indication_chosen 19
	NonStandardPDU non_standard_indication;
    } u;
} IndicationPDU;

typedef struct ApplicationUpdate {
    ASN1choice_t choice;
    union {
#	define application_add_record_chosen 1
	ApplicationRecord application_add_record;
#	define application_replace_record_chosen 2
	ApplicationRecord application_replace_record;
#	define application_remove_record_chosen 3
    } u;
} ApplicationUpdate;

typedef struct RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set {
    CapabilityID capability_id;
    CapabilityClass capability_class;
    ASN1uint32_t number_of_entities;
} RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set;

typedef struct RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set {
    UserID node_id;
    EntityID entity_id;
    ApplicationRecord application_record;
} RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set;

typedef struct RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set {
    UserID node_id;
    EntityID entity_id;
    ApplicationUpdate application_update;
} RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set;

typedef struct NodeUpdate {
    ASN1choice_t choice;
    union {
#	define node_add_record_chosen 1
	NodeRecord node_add_record;
#	define node_replace_record_chosen 2
	NodeRecord node_replace_record;
#	define node_remove_record_chosen 3
    } u;
} NodeUpdate;

typedef struct RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set {
    UserID node_id;
    NodeRecord node_record;
} RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set;

typedef struct RosterUpdateIndication_node_information_node_record_list_node_record_update_Set {
    UserID node_id;
    NodeUpdate node_update;
} RosterUpdateIndication_node_information_node_record_list_node_record_update_Set;

typedef struct SetOfApplicationRecordUpdates {
    PSetOfApplicationRecordUpdates next;
    RosterUpdateIndication_application_information_Set_application_record_list_application_record_update_Set value;
} SetOfApplicationRecordUpdates_Element;

typedef struct SetOfApplicationRecordRefreshes {
    PSetOfApplicationRecordRefreshes next;
    RosterUpdateIndication_application_information_Set_application_record_list_application_record_refresh_Set value;
} SetOfApplicationRecordRefreshes_Element;

typedef struct SetOfApplicationCapabilityRefreshes {
    PSetOfApplicationCapabilityRefreshes next;
    RosterUpdateIndication_application_information_Set_application_capabilities_list_application_capability_refresh_Set value;
} SetOfApplicationCapabilityRefreshes_Element;

typedef struct SetOfNodeRecordUpdates {
    PSetOfNodeRecordUpdates next;
    RosterUpdateIndication_node_information_node_record_list_node_record_update_Set value;
} SetOfNodeRecordUpdates_Element;

typedef struct SetOfNodeRecordRefreshes {
    PSetOfNodeRecordRefreshes next;
    RosterUpdateIndication_node_information_node_record_list_node_record_refresh_Set value;
} SetOfNodeRecordRefreshes_Element;

typedef struct ApplicationRecord_non_collapsing_capabilities_Set {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    CapabilityID capability_id;
#   define application_data_present 0x80
    ASN1octetstring_t application_data;
} ApplicationRecord_non_collapsing_capabilities_Set;

typedef struct ApplicationInvokeSpecifier_expected_capability_set_Set {
    CapabilityID capability_id;
    CapabilityClass capability_class;
} ApplicationInvokeSpecifier_expected_capability_set_Set;

typedef struct RosterUpdateIndication_application_information_Set {
    SessionKey session_key;
    ApplicationRecordList application_record_list;
    ApplicationCapabilitiesList application_capabilities_list;
    ASN1uint16_t roster_instance_number;
    ASN1bool_t peer_entities_are_added;
    ASN1bool_t peer_entities_are_removed;
} RosterUpdateIndication_application_information_Set;

typedef struct ApplicationProtocolEntityList {
    PApplicationProtocolEntityList next;
    ApplicationInvokeSpecifier value;
} ApplicationProtocolEntityList_Element;

typedef struct SetOfApplicationInformation {
    PSetOfApplicationInformation next;
    RosterUpdateIndication_application_information_Set value;
} SetOfApplicationInformation_Element;

typedef struct SetOfConferenceDescriptors {
    PSetOfConferenceDescriptors next;
    ConferenceDescriptor value;
} SetOfConferenceDescriptors_Element;

typedef struct SetOfExpectedCapabilities {
    PSetOfExpectedCapabilities next;
    ApplicationInvokeSpecifier_expected_capability_set_Set value;
} SetOfExpectedCapabilities_Element;

typedef struct SetOfNonCollapsingCapabilities {
    PSetOfNonCollapsingCapabilities next;
    ApplicationRecord_non_collapsing_capabilities_Set value;
} SetOfNonCollapsingCapabilities_Element;

typedef struct NetworkAddress {
    ASN1choice_t choice;
    union {
#	define aggregated_channel_chosen 1
	AggregateChannel aggregated_channel;
#	define transport_connection_chosen 2
	TransportConnectionType transport_connection;
#	define address_non_standard_chosen 3
	NonStandardParameter address_non_standard;
    } u;
} NetworkAddress;

typedef struct ChallengeRequestResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define challenge_request_present 0x80
    ChallengeRequest challenge_request;
#   define challenge_response_present 0x40
    ChallengeResponse challenge_response;
} ChallengeRequestResponse;

typedef struct SetOfChallengeItems {
    PSetOfChallengeItems next;
    ChallengeItem value;
} SetOfChallengeItems_Element;

typedef struct UserData_Set {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Key key;
#   define user_data_field_present 0x80
    ASN1octetstring_t user_data_field;
} UserData_Set;

typedef struct SetOfUserData {
    PSetOfUserData next;
    UserData_Set user_data_element;
} SetOfUserData_Element;

typedef struct PasswordChallengeRequestResponse {
    ASN1choice_t choice;
    union {
#	define challenge_clear_password_chosen 1
	PasswordSelector challenge_clear_password;
#	define challenge_request_response_chosen 2
	ChallengeRequestResponse challenge_request_response;
    } u;
} PasswordChallengeRequestResponse;

typedef struct SetOfNetworkAddresses {
    PSetOfNetworkAddresses next;
    NetworkAddress value;
} SetOfNetworkAddresses_Element;

typedef struct ConferenceJoinRequest {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define conference_name_present 0x80
    ConferenceNameSelector conference_name;
#   define cjrq_conference_modifier_present 0x40
    ConferenceNameModifier cjrq_conference_modifier;
#   define tag_present 0x20
    UINT_PTR tag;
#   define cjrq_password_present 0x10
    PasswordChallengeRequestResponse cjrq_password;
#   define cjrq_convener_password_present 0x8
    PasswordSelector cjrq_convener_password;
#   define cjrq_caller_id_present 0x4
    TextString cjrq_caller_id;
#   define cjrq_user_data_present 0x2
    PSetOfUserData cjrq_user_data;
} ConferenceJoinRequest;

typedef enum ConferenceJoinResult {
    ConferenceJoinResult_success = 0,
    ConferenceJoinResult_userRejected = 1,
    invalidConference = 2,
    invalidPassword = 3,
    invalidConvenerPassword = 4,
    challengeResponseRequired = 5,
    invalidChallengeResponse = 6,
} ConferenceJoinResult;
typedef struct ConferenceJoinResponse {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define cjrs_node_id_present 0x80
    UserID cjrs_node_id;
    UserID top_node_id;
    UINT_PTR tag;
#   define conference_name_alias_present 0x40
    ConferenceNameSelector conference_name_alias;
    ASN1bool_t clear_password_required;
    ASN1bool_t conference_is_locked;
    ASN1bool_t conference_is_listed;
    ASN1bool_t conference_is_conductible;
    TerminationMethod termination_method;
#   define cjrs_conductor_privs_present 0x20
    PSetOfPrivileges cjrs_conductor_privs;
#   define cjrs_conducted_privs_present 0x10
    PSetOfPrivileges cjrs_conducted_privs;
#   define cjrs_non_conducted_privs_present 0x8
    PSetOfPrivileges cjrs_non_conducted_privs;
#   define cjrs_description_present 0x4
    TextString cjrs_description;
#   define cjrs_password_present 0x2
    PasswordChallengeRequestResponse cjrs_password;
    ConferenceJoinResult result;
#   define cjrs_user_data_present 0x1
    PSetOfUserData cjrs_user_data;
} ConferenceJoinResponse;

typedef struct ConnectGCCPDU {
    ASN1choice_t choice;
    union {
#	define conference_create_request_chosen 1
	ConferenceCreateRequest conference_create_request;
#	define conference_create_response_chosen 2
	ConferenceCreateResponse conference_create_response;
#	define conference_query_request_chosen 3
	ConferenceQueryRequest conference_query_request;
#	define conference_query_response_chosen 4
	ConferenceQueryResponse conference_query_response;
#	define connect_join_request_chosen 5
	ConferenceJoinRequest connect_join_request;
#	define connect_join_response_chosen 6
	ConferenceJoinResponse connect_join_response;
#	define conference_invite_request_chosen 7
	ConferenceInviteRequest conference_invite_request;
#	define conference_invite_response_chosen 8
	ConferenceInviteResponse conference_invite_response;
    } u;
} ConnectGCCPDU;
#define ConnectGCCPDU_PDU 1
#define SIZE_GCCPDU_Module_PDU_1 sizeof(ConnectGCCPDU)

typedef struct RequestPDU {
    ASN1choice_t choice;
    union {
#	define conference_join_request_chosen 1
	ConferenceJoinRequest conference_join_request;
#	define conference_add_request_chosen 2
	ConferenceAddRequest conference_add_request;
#	define conference_lock_request_chosen 3
	ConferenceLockRequest conference_lock_request;
#	define conference_unlock_request_chosen 4
	ConferenceUnlockRequest conference_unlock_request;
#	define conference_terminate_request_chosen 5
	ConferenceTerminateRequest conference_terminate_request;
#	define conference_eject_user_request_chosen 6
	ConferenceEjectUserRequest conference_eject_user_request;
#	define conference_transfer_request_chosen 7
	ConferenceTransferRequest conference_transfer_request;
#	define registry_register_channel_request_chosen 8
	RegistryRegisterChannelRequest registry_register_channel_request;
#	define registry_assign_token_request_chosen 9
	RegistryAssignTokenRequest registry_assign_token_request;
#	define registry_set_parameter_request_chosen 10
	RegistrySetParameterRequest registry_set_parameter_request;
#	define registry_retrieve_entry_request_chosen 11
	RegistryRetrieveEntryRequest registry_retrieve_entry_request;
#	define registry_delete_entry_request_chosen 12
	RegistryDeleteEntryRequest registry_delete_entry_request;
#	define registry_monitor_entry_request_chosen 13
	RegistryMonitorEntryRequest registry_monitor_entry_request;
#	define registry_allocate_handle_request_chosen 14
	RegistryAllocateHandleRequest registry_allocate_handle_request;
#	define non_standard_request_chosen 15
	NonStandardPDU non_standard_request;
    } u;
} RequestPDU;

typedef struct FunctionNotSupportedResponse {
    RequestPDU request;
} FunctionNotSupportedResponse;

typedef struct ResponsePDU {
    ASN1choice_t choice;
    union {
#	define conference_join_response_chosen 1
	ConferenceJoinResponse conference_join_response;
#	define conference_add_response_chosen 2
	ConferenceAddResponse conference_add_response;
#	define conference_lock_response_chosen 3
	ConferenceLockResponse conference_lock_response;
#	define conference_unlock_response_chosen 4
	ConferenceUnlockResponse conference_unlock_response;
#	define conference_terminate_response_chosen 5
	ConferenceTerminateResponse conference_terminate_response;
#	define conference_eject_user_response_chosen 6
	ConferenceEjectUserResponse conference_eject_user_response;
#	define conference_transfer_response_chosen 7
	ConferenceTransferResponse conference_transfer_response;
#	define registry_response_chosen 8
	RegistryResponse registry_response;
#	define registry_allocate_handle_response_chosen 9
	RegistryAllocateHandleResponse registry_allocate_handle_response;
#	define function_not_supported_response_chosen 10
	FunctionNotSupportedResponse function_not_supported_response;
#	define non_standard_response_chosen 11
	NonStandardPDU non_standard_response;
    } u;
} ResponsePDU;

typedef struct GCCPDU {
    ASN1choice_t choice;
    union {
#	define request_chosen 1
	RequestPDU request;
#	define response_chosen 2
	ResponsePDU response;
#	define indication_chosen 3
	IndicationPDU indication;
    } u;
} GCCPDU;
#define GCCPDU_PDU 2
#define SIZE_GCCPDU_Module_PDU_2 sizeof(GCCPDU)

extern Key t124identifier;

extern ASN1char32string_t simpleTextFirstCharacter;

extern ASN1char32string_t simpleTextLastCharacter;

extern ASN1module_t GCCPDU_Module;
extern void ASN1CALL GCCPDU_Module_Startup(void);
extern void ASN1CALL GCCPDU_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_WaitingList_ElmFn(ASN1encoding_t enc, PWaitingList val);
    extern int ASN1CALL ASN1Dec_WaitingList_ElmFn(ASN1decoding_t dec, PWaitingList val);
    extern void ASN1CALL ASN1Free_WaitingList_ElmFn(PWaitingList val);
    extern int ASN1CALL ASN1Enc_PermissionList_ElmFn(ASN1encoding_t enc, PPermissionList val);
    extern int ASN1CALL ASN1Dec_PermissionList_ElmFn(ASN1decoding_t dec, PPermissionList val);
    extern void ASN1CALL ASN1Free_PermissionList_ElmFn(PPermissionList val);
    extern int ASN1CALL ASN1Enc_SetOfDestinationNodes_ElmFn(ASN1encoding_t enc, PSetOfDestinationNodes val);
    extern int ASN1CALL ASN1Dec_SetOfDestinationNodes_ElmFn(ASN1decoding_t dec, PSetOfDestinationNodes val);
    extern void ASN1CALL ASN1Free_SetOfDestinationNodes_ElmFn(PSetOfDestinationNodes val);
    extern int ASN1CALL ASN1Enc_SetOfTransferringNodesIn_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesIn val);
    extern int ASN1CALL ASN1Dec_SetOfTransferringNodesIn_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesIn val);
    extern void ASN1CALL ASN1Free_SetOfTransferringNodesIn_ElmFn(PSetOfTransferringNodesIn val);
    extern int ASN1CALL ASN1Enc_SetOfTransferringNodesRs_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesRs val);
    extern int ASN1CALL ASN1Dec_SetOfTransferringNodesRs_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesRs val);
    extern void ASN1CALL ASN1Free_SetOfTransferringNodesRs_ElmFn(PSetOfTransferringNodesRs val);
    extern int ASN1CALL ASN1Enc_SetOfTransferringNodesRq_ElmFn(ASN1encoding_t enc, PSetOfTransferringNodesRq val);
    extern int ASN1CALL ASN1Dec_SetOfTransferringNodesRq_ElmFn(ASN1decoding_t dec, PSetOfTransferringNodesRq val);
    extern void ASN1CALL ASN1Free_SetOfTransferringNodesRq_ElmFn(PSetOfTransferringNodesRq val);
    extern int ASN1CALL ASN1Enc_ParticipantsList_ElmFn(ASN1encoding_t enc, PParticipantsList val);
    extern int ASN1CALL ASN1Dec_ParticipantsList_ElmFn(ASN1decoding_t dec, PParticipantsList val);
    extern void ASN1CALL ASN1Free_ParticipantsList_ElmFn(PParticipantsList val);
    extern int ASN1CALL ASN1Enc_SetOfPrivileges_ElmFn(ASN1encoding_t enc, PSetOfPrivileges val);
    extern int ASN1CALL ASN1Dec_SetOfPrivileges_ElmFn(ASN1decoding_t dec, PSetOfPrivileges val);
    extern void ASN1CALL ASN1Free_SetOfPrivileges_ElmFn(PSetOfPrivileges val);
    extern int ASN1CALL ASN1Enc_SetOfApplicationRecordUpdates_ElmFn(ASN1encoding_t enc, PSetOfApplicationRecordUpdates val);
    extern int ASN1CALL ASN1Dec_SetOfApplicationRecordUpdates_ElmFn(ASN1decoding_t dec, PSetOfApplicationRecordUpdates val);
    extern void ASN1CALL ASN1Free_SetOfApplicationRecordUpdates_ElmFn(PSetOfApplicationRecordUpdates val);
    extern int ASN1CALL ASN1Enc_SetOfApplicationRecordRefreshes_ElmFn(ASN1encoding_t enc, PSetOfApplicationRecordRefreshes val);
    extern int ASN1CALL ASN1Dec_SetOfApplicationRecordRefreshes_ElmFn(ASN1decoding_t dec, PSetOfApplicationRecordRefreshes val);
    extern void ASN1CALL ASN1Free_SetOfApplicationRecordRefreshes_ElmFn(PSetOfApplicationRecordRefreshes val);
    extern int ASN1CALL ASN1Enc_SetOfApplicationCapabilityRefreshes_ElmFn(ASN1encoding_t enc, PSetOfApplicationCapabilityRefreshes val);
    extern int ASN1CALL ASN1Dec_SetOfApplicationCapabilityRefreshes_ElmFn(ASN1decoding_t dec, PSetOfApplicationCapabilityRefreshes val);
    extern void ASN1CALL ASN1Free_SetOfApplicationCapabilityRefreshes_ElmFn(PSetOfApplicationCapabilityRefreshes val);
    extern int ASN1CALL ASN1Enc_SetOfNodeRecordUpdates_ElmFn(ASN1encoding_t enc, PSetOfNodeRecordUpdates val);
    extern int ASN1CALL ASN1Dec_SetOfNodeRecordUpdates_ElmFn(ASN1decoding_t dec, PSetOfNodeRecordUpdates val);
    extern void ASN1CALL ASN1Free_SetOfNodeRecordUpdates_ElmFn(PSetOfNodeRecordUpdates val);
    extern int ASN1CALL ASN1Enc_SetOfNodeRecordRefreshes_ElmFn(ASN1encoding_t enc, PSetOfNodeRecordRefreshes val);
    extern int ASN1CALL ASN1Dec_SetOfNodeRecordRefreshes_ElmFn(ASN1decoding_t dec, PSetOfNodeRecordRefreshes val);
    extern void ASN1CALL ASN1Free_SetOfNodeRecordRefreshes_ElmFn(PSetOfNodeRecordRefreshes val);
    extern int ASN1CALL ASN1Enc_ApplicationProtocolEntityList_ElmFn(ASN1encoding_t enc, PApplicationProtocolEntityList val);
    extern int ASN1CALL ASN1Dec_ApplicationProtocolEntityList_ElmFn(ASN1decoding_t dec, PApplicationProtocolEntityList val);
    extern void ASN1CALL ASN1Free_ApplicationProtocolEntityList_ElmFn(PApplicationProtocolEntityList val);
    extern int ASN1CALL ASN1Enc_SetOfApplicationInformation_ElmFn(ASN1encoding_t enc, PSetOfApplicationInformation val);
    extern int ASN1CALL ASN1Dec_SetOfApplicationInformation_ElmFn(ASN1decoding_t dec, PSetOfApplicationInformation val);
    extern void ASN1CALL ASN1Free_SetOfApplicationInformation_ElmFn(PSetOfApplicationInformation val);
    extern int ASN1CALL ASN1Enc_SetOfConferenceDescriptors_ElmFn(ASN1encoding_t enc, PSetOfConferenceDescriptors val);
    extern int ASN1CALL ASN1Dec_SetOfConferenceDescriptors_ElmFn(ASN1decoding_t dec, PSetOfConferenceDescriptors val);
    extern void ASN1CALL ASN1Free_SetOfConferenceDescriptors_ElmFn(PSetOfConferenceDescriptors val);
    extern int ASN1CALL ASN1Enc_SetOfExpectedCapabilities_ElmFn(ASN1encoding_t enc, PSetOfExpectedCapabilities val);
    extern int ASN1CALL ASN1Dec_SetOfExpectedCapabilities_ElmFn(ASN1decoding_t dec, PSetOfExpectedCapabilities val);
    extern void ASN1CALL ASN1Free_SetOfExpectedCapabilities_ElmFn(PSetOfExpectedCapabilities val);
    extern int ASN1CALL ASN1Enc_SetOfNonCollapsingCapabilities_ElmFn(ASN1encoding_t enc, PSetOfNonCollapsingCapabilities val);
    extern int ASN1CALL ASN1Dec_SetOfNonCollapsingCapabilities_ElmFn(ASN1decoding_t dec, PSetOfNonCollapsingCapabilities val);
    extern void ASN1CALL ASN1Free_SetOfNonCollapsingCapabilities_ElmFn(PSetOfNonCollapsingCapabilities val);
    extern int ASN1CALL ASN1Enc_SetOfChallengeItems_ElmFn(ASN1encoding_t enc, PSetOfChallengeItems val);
    extern int ASN1CALL ASN1Dec_SetOfChallengeItems_ElmFn(ASN1decoding_t dec, PSetOfChallengeItems val);
    extern void ASN1CALL ASN1Free_SetOfChallengeItems_ElmFn(PSetOfChallengeItems val);
    extern int ASN1CALL ASN1Enc_SetOfUserData_ElmFn(ASN1encoding_t enc, PSetOfUserData val);
    extern int ASN1CALL ASN1Dec_SetOfUserData_ElmFn(ASN1decoding_t dec, PSetOfUserData val);
    extern void ASN1CALL ASN1Free_SetOfUserData_ElmFn(PSetOfUserData val);
    extern int ASN1CALL ASN1Enc_SetOfNetworkAddresses_ElmFn(ASN1encoding_t enc, PSetOfNetworkAddresses val);
    extern int ASN1CALL ASN1Dec_SetOfNetworkAddresses_ElmFn(ASN1decoding_t dec, PSetOfNetworkAddresses val);
    extern void ASN1CALL ASN1Free_SetOfNetworkAddresses_ElmFn(PSetOfNetworkAddresses val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _GCCPDU_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\imst123.h ===
#ifndef _T123_TRANSPORT_DRIVER_INTERFACE_H_
#define _T123_TRANSPORT_DRIVER_INTERFACE_H_

#include <basetyps.h>
#include <t120type.h>
#include "iplgxprt.h"

typedef UINT_PTR        LEGACY_HANDLE;
typedef HANDLE          PHYSICAL_HANDLE;


typedef ULONG (CALLBACK *TransportCallback) (ULONG, void *, void *);


/*
 *  This structure is passed back with the TRANSPORT_DATA_INDICATION message.
 */
typedef	struct
{
	UINT_PTR            logical_handle;
	LPBYTE              pbData;
	ULONG               cbDataSize;
}
    LegacyTransportData;


/*
 *  This structure is passed back with the TRANSPORT_CONNECT_INDICATION,
 *  TRANSPORT_CONNECT_CONFIRM, and the TRANSPORT_DISONNECT_INDICATION messages.
 *  This structure contains the transport connection identifier and
 *  physical handle.
 */
typedef struct
{
    LEGACY_HANDLE       logical_handle;
    PHYSICAL_HANDLE     hCommLink;
}
    LegacyTransportID;


#undef  INTERFACE
#define INTERFACE ILegacyTransport
DECLARE_INTERFACE(ILegacyTransport)
{
    STDMETHOD_(void, ReleaseInterface) (THIS) PURE;

    STDMETHOD_(TransportError, TInitialize) (THIS_ TransportCallback, void *user_defined) PURE;
    STDMETHOD_(TransportError, TCleanup) (THIS) PURE;
    STDMETHOD_(TransportError, TCreateTransportStack) (THIS_ BOOL fCaller, HANDLE hCommLink, HANDLE hevtClose, PLUGXPRT_PARAMETERS *pParams) PURE;
    STDMETHOD_(TransportError, TCloseTransportStack) (THIS_ HANDLE hCommLink) PURE;
    STDMETHOD_(TransportError, TConnectRequest) (THIS_ LEGACY_HANDLE *, HANDLE hCommLink) PURE;
    STDMETHOD_(TransportError, TDisconnectRequest) (THIS_ LEGACY_HANDLE, BOOL trash_packets) PURE;
    STDMETHOD_(TransportError, TDataRequest) (THIS_ LEGACY_HANDLE, LPBYTE pbData, ULONG cbDataSize) PURE;
    STDMETHOD_(TransportError, TReceiveBufferAvailable) (THIS) PURE;
    STDMETHOD_(TransportError, TPurgeRequest) (THIS_ LEGACY_HANDLE) PURE;
    STDMETHOD_(TransportError, TEnableReceiver) (THIS) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif

TransportError WINAPI T123_CreateTransportInterface(ILegacyTransport **);
typedef TransportError (WINAPI *LPFN_T123_CreateTransportInterface) (ILegacyTransport **);
#define LPSTR_T123_CreateTransportInterface     "T123_CreateTransportInterface"

#ifdef __cplusplus
}
#endif


#endif // _PSTN_TRANSPORT_DRIVER_INTERFACE_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\hash.h ===
/*	hash.h
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *  Written by:	 Christos Tsollis
 *
 *  Revisions:
 *		
 *	Abstract:
 *
 *	This is the interface to a dictionary data structure.  
 *	Both the key and the value in a dictionary entry are DWORD values.  So, for example, if the 
 *  value is really a pointer it has to be converted into a DWORD before being passed into a 
 *  member dictionary function.
 *
 */


#ifndef _HASH_
#define _HASH_

#include <windows.h>

#define DEFAULT_NUMBER_OF_BUCKETS	3


typedef enum {
	DWORD_DICTIONARY,			/* The key is a 32-bit unsigned value */
	STRING_DICTIONARY,			/* The key is a NULL-terminated string that is being pointed by 
								 * the "key" field in the structure below */
	LENGTH_STRING_DICTIONARY	/* The key is a string with a specific length.  The "key" field
								 * in the structure below, points to memory space containing 
								 * the length and a string of that length. */
} DictionaryType;


typedef struct _dictionary_item {
	DWORD						key;	// The key value, or a pointer to a string (depending on the dictionary type)
	DWORD						value;	// This is always a 32-bit unsigned value
	struct _dictionary_item		*next;	// Pointer to the next structure in the dictionary bucket
} DICTIONARY_ITEM, *PDICTIONARY_ITEM;


class DictionaryClass
{
public:

	DictionaryClass (ULong num_of_buckets = DEFAULT_NUMBER_OF_BUCKETS, DictionaryType dtype = DWORD_DICTIONARY);
	DictionaryClass (const DictionaryClass& original);
	~DictionaryClass ();

	BOOL insert (DWORD new_key, DWORD new_value, ULong length = 0);
	BOOL remove (DWORD Key, ULong length = 0);
	BOOL find (DWORD Key, LPDWORD pValue = NULL, ULong length = 0);
	BOOL isEmpty ();
	void clear ();
	ULong entries () {
		return (3 * NumOfBuckets - ItemCount + NumOfExternItems);
	};
	BOOL iterate (LPDWORD pValue = NULL, LPDWORD pKey = NULL);
	void reset () { pCurrent = NULL; };		// Resets the dictionary iterator

	BOOL Insert(DWORD new_key, LPVOID new_value, UINT length = 0) { ASSERT(new_value != NULL); return insert(new_key, (DWORD) new_value, (ULONG) length); }
	BOOL Remove(DWORD Key, UINT length = 0) { return remove(Key, (ULONG) length); }
	LPVOID Find(DWORD Key, UINT length = 0);
	LPVOID Iterate(LPDWORD pKey = NULL);
	BOOL IsEmpty(void) { return isEmpty(); }
	void Clear(void) { clear(); }
	UINT GetCount(void) { return (UINT) entries(); }
	void Reset(void) { reset(); }


private:

	DWORD hashFunction (DWORD key);
	int LengthStrcmp (DWORD DictionaryKey, DWORD ChallengeKey, ULong length);

	ULong				 NumOfBuckets;		// Number of dictionary buckets.  Specified during object construction.
	DWORD				 dwNormalSize;		// Initial space allocated for the dictionary
	PDICTIONARY_ITEM	*Buckets;			// Address of the Buckets array
	PDICTIONARY_ITEM	*ItemArray;			// Pointer to the array of initially allocated dictionary items
	ULong		 		 ItemCount;			// Number of dictionary items left in the ItemArray
	PDICTIONARY_ITEM	 pCurrent;			// Points to the current dictionary item while we iterate through the dictionary
	ULong				 ulCurrentBucket;	// Id of the current bucket while we iterate
	DictionaryType		 Type;				// Dictionary type
	ULong				 NumOfExternItems;	// Number of external dictionary items

};

typedef DictionaryClass * PDictionaryClass;

#define DEFINE_DICTIONARY_FRIENDLY_METHODS(_ClassName_)			\
	BOOL Insert(DWORD new_key, _ClassName_ *new_value, UINT length = 0) { return DictionaryClass::Insert(new_key, (LPVOID) new_value, length); }	\
	BOOL Remove(DWORD Key, UINT length = 0) { return DictionaryClass::Remove(Key, length); }	\
	_ClassName_ *Find(DWORD Key, UINT length = 0) { return (_ClassName_ *) DictionaryClass::Find(Key, length); }	\
	_ClassName_ *Iterate(LPDWORD pKey = NULL) { return (_ClassName_ *) DictionaryClass::Iterate(pKey); }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\lportmsg.h ===
/*
 *	lportmsg.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Portable:
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_LISTEN_GCC_PORTAL_MESSAGE_
#define	_LISTEN_GCC_PORTAL_MESSAGE_

#define	LISTEN_CREATE_SAP_PORTALS_REQUEST	0
#define	LISTEN_CREATE_SAP_PORTALS_CONFIRM	1

#define	LISTEN_NO_ERROR						0
#define	LISTEN_CREATE_FAILED				1

typedef struct
{
} LPCreateSapPortalsRequest;


typedef struct
{
	ULong		return_value;
	PVoid		blocking_portal_address;
	PVoid		non_blocking_portal_address;
} LPCreateSapPortalsConfirm;

typedef struct
{
} LPCloseSapPortalsRequest;

typedef	struct
{
	unsigned int		message_type;
	union
	{
		LPCreateSapPortalsRequest		create_sap_portals_request;
		LPCreateSapPortalsConfirm		create_sap_portals_confirm;
		LPCloseSapPortalsRequest		close_sap_portals_request;
	} u;
} GccListenPortalMessage;
typedef	GccListenPortalMessage *		PGccListenPortalMessage;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\gcontrol.h ===
#ifndef _GCC_CONTROLLER_
#define _GCC_CONTROLLER_

/*
 *	gcontrol.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		It is the responsibility of the controller to create and destroy many 
 *		of the other objects in the system at run-time.  There is should only 
 *		be one controller in existence at a time per GCC provider.  The 
 *		controller is constructed during system initialization, and not 
 *		destroyed until the provider is shut down.  The controller's primary 
 *		responsibility is to maintain five "layers" of objects in the system at 
 *		run-time.  These include the Application Interface, the SAPs (the
 *		Control SAP as well as the Application SAPs), the Conference objects, 
 *		the MCSUser object (which is actualy created by the conference object),
 *		and the MCS Interface.  It also "plugs" together objects in adjacent 
 *		layers by informing a newly created object of the identity of those 
 *		objects with which it must communicate.  The newly created object can 
 *		then register itself with the appropriate objects in the layers above 
 *		and below.  The controller plays a small role in the passing of 
 *		information during a conference (this is handled by the objects it 
 *		creates).
 *
 *		It is worth noting that the controller is the primary recipient of 
 *		owner callbacks in the GCC system.  Most of the objects in its "object 
 *		stack" are capable of issuing owner callbacks to the controller for 
 *		various events and requests.
 *
 *		The controller is not completely portable.  Since the nature of 
 *		application and MCS interfaces will vary from platform to platform, the 
 *		interface objects that must be created will also vary.  It is necessary 
 *		for the controller to know which objects to create and destroy during 
 *		initialization and cleanup.  Other than this, however, the rest of the 
 *		code in the controller class should port cleanly.
 *
 *		The constructor performs all activity required to prepare GCC for use.  
 *		It creates an instance of the Memory Manager class (and possibly a 
 *		Message Memory Manager class in certain environments), which will be 
 *		used for memory handling by other objects in the system.  It creates the 
 *		GccAppInterface objects that will be used to communicate with all user 
 *		applications (including the node controller).  It creates the MCS 
 *		Interface object that will be used to communicate with MCS.  GCC relies 
 *		on an owner callback from a GccAppInterface object to give it a 
 *		heartbeat.  It is during this heartbeat that the controller does all of 
 *		its work at run-time.
 *
 *		The destructor essentially does the opposite of what the constructor 
 *		does (as you might expect).  It destroys all objects that are "owned" 
 *		by the controller, cleanly shutting everything down.
 *
 *		As mentioned above, the controller is the primary recipient of owner 
 *		callbacks in the GCC system.  To accomplish this it overrides the 
 *		Owner-Callback member function.  It can then pass its "this" pointer to 
 *		objects that it creates, allowing them to issue owner callbacks when 
 *		necessary.  Everything the controller does at run-time is in response 
 *		to these owner callbacks.
 *
 *		The controller is the prime recipient of connect provider indications 
 *		from MCS.  Many of the messages that are passed between GCC and the 
 *		GccAppInterface before a conference is established involve the 
 *		controller.  These include ConferenceCreateIndication,  
 *		ConferenceInviteIndication,  etc.  Also, the controller object is 
 *		exclusively responsible for handling conference queries since it 
 *		maintains a complete list of all the conferences that exist in the 
 *		system.
 *
 *	Portable:
 *		Not Completely (80 % portable)
 *		Member functions which aren't portable:
 *			-	GCCControl()
 *			-	~GCCControl()
 *			-	EventLoop()
 *			-	PollCommDevices()
 *			-	CreateApplicationSap()
 *
 *	Protected Instance Variables:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */

#include "sap.h"
#include "csap.h"
#include "appsap.h"
#include "conf.h"
#include "pktcoder.h"
#include "privlist.h"
#include "mcsdllif.h"
#include "t120app.h"

// #include "gccncif.h"

extern CRITICAL_SECTION     g_csGCCProvider;


/*
**	These are the message bases used by the controller object.  Any
**	owner callback message received from an object that the controller
**	created must have a message base added to it before it is received
**	at the controller.
*/
#define MCS_INTERFACE_MESSAGE_BASE		300   //	Leave room for status

enum
{
    GCTRL_REBUILD_CONF_POLL_LIST    = GCTRLMSG_BASE + 1,
};


// permit to enroll callback list
class CApplet;
class CAppletList : public CList
{
    DEFINE_CLIST(CAppletList, CApplet*)
};

/*
**	The conference information structure is used to temporarily store
**	information needed to create a conference while waiting for a
**	conference create response.
*/
typedef struct PENDING_CREATE_CONF
{
	// a destructor to this data structure
	PENDING_CREATE_CONF(void);
	~PENDING_CREATE_CONF(void);

	LPSTR							pszConfNumericName;
	LPWSTR							pwszConfTextName;
	BOOL							password_in_the_clear;
	BOOL							conference_is_locked;
	BOOL							conference_is_listed;
	BOOL							conference_is_conductible;
	GCCTerminationMethod			termination_method;
	PPrivilegeListData				conduct_privilege_list;
	PPrivilegeListData				conduct_mode_privilege_list;
	PPrivilegeListData				non_conduct_privilege_list;
	LPWSTR							pwszConfDescription;
    ConnectionHandle				connection_handle;
	UserID							parent_node_id;
	UserID							top_node_id;
	TagNumber						tag_number;
}
	PENDING_CREATE_CONF;

/*
**	This defines the template for the list that keeps track of information
**	associated with a conference that is waiting for a response on a 
**	create conference indication.
*/
class CPendingCreateConfList2 : public CList2
{
    DEFINE_CLIST2(CPendingCreateConfList2, PENDING_CREATE_CONF*, GCCConfID)
};


/*
**	The join information structure is used to temporarily store
**	information needed to join a conference after the join response is
**	issued.
*/
typedef struct PENDING_JOIN_CONF
{
	PENDING_JOIN_CONF(void);
	~PENDING_JOIN_CONF(void);

	CPassword               *convener_password;
	CPassword               *password_challenge;
	LPWSTR					pwszCallerID;
	BOOL					numeric_name_present;
	GCCConfID               nConfID;
}
	PENDING_JOIN_CONF;

/*
**	This defines the template for the list that keeps track of information
**	associated with an outstanding join request.
*/
class CPendingJoinConfList2 : public CList2
{
    DEFINE_CLIST2_(CPendingJoinConfList2, PENDING_JOIN_CONF*, ConnectionHandle)
};


//	Holds the list of outstanding query request
class CPendingQueryConfList2 : public CList2
{
    DEFINE_CLIST2_(CPendingQueryConfList2, GCCConfID, ConnectionHandle)
};


extern HANDLE g_hevGCCOutgoingPDU;


class GCCController : public CRefCount
{
public:

	GCCController(PGCCError);
	~GCCController(void);

    void RegisterAppSap(CAppSap *);
    void UnRegisterAppSap(CAppSap *);

    void RegisterApplet(CApplet *);
    void UnregisterApplet(CApplet *);

    CConf *GetConfObject(GCCConfID nConfID) { return m_ConfList2.Find(nConfID); }

	//	Functions initiated from the node controller 
	GCCError ConfCreateRequest(CONF_CREATE_REQUEST *, GCCConfID *);

    void WndMsgHandler ( UINT uMsg );
    BOOL FlushOutgoingPDU ( void );
    void SetEventToFlushOutgoingPDU ( void ) { ::SetEvent(g_hevGCCOutgoingPDU); }

	//	Functions initiated from Control SAP
	GCCError    ConfCreateResponse(PConfCreateResponseInfo);
	GCCError    ConfQueryRequest(PConfQueryRequestInfo);
	GCCError    ConfQueryResponse(PConfQueryResponseInfo);
	GCCError    ConfJoinRequest(PConfJoinRequestInfo, GCCConfID *);
	GCCError    ConfJoinIndResponse(PConfJoinResponseInfo);
	GCCError    ConfInviteResponse(PConfInviteResponseInfo);
    GCCError    FailConfJoinIndResponse(GCCConfID, ConnectionHandle);
    GCCError    FailConfJoinIndResponse(PConfJoinResponseInfo);
    void        RemoveConfJoinInfo(ConnectionHandle hConn);

	//	Functions initiated from Conference object
	GCCError    ProcessConfEstablished(GCCConfID);
	GCCError    ProcessConfTerminated(GCCConfID, GCCReason);

	//	Functions initiated from the MCS Interface
	GCCError	ProcessConnectProviderIndication(PConnectProviderIndication);
	GCCError	ProcessConferenceCreateRequest(PConferenceCreateRequest, PConnectProviderIndication);
	GCCError	ProcessConferenceQueryRequest(PConferenceQueryRequest, PConnectProviderIndication);
	GCCError	ProcessConferenceJoinRequest(PConferenceJoinRequest, PConnectProviderIndication);
	GCCError	ProcessConferenceInviteRequest(PConferenceInviteRequest, PConnectProviderIndication);
	GCCError	ProcessConnectProviderConfirm(PConnectProviderConfirm);
	GCCError	ProcessConferenceQueryResponse(PConferenceQueryResponse, PConnectProviderConfirm);
	GCCError	ProcessDisconnectProviderIndication(ConnectionHandle);
    void        CancelConfQueryRequest(ConnectionHandle);

private:

	/*
	**	Routines called from the Owner-Callback function
	*/

    //	Miscelaneous support functions
	GCCConfID	AllocateConferenceID();
	GCCConfID	AllocateQueryID();

	GCCConfID	GetConferenceIDFromName(
							PGCCConferenceName		conference_name,
							GCCNumericString		conference_modifier);

    void RebuildConfPollList ( void );
    void PostMsgToRebuildConfPollList ( void );

private:

	CPendingCreateConfList2			m_PendingCreateConfList2;
	CPendingJoinConfList2			m_PendingJoinConfList2;
	CPendingQueryConfList2			m_PendingQueryConfList2;

	CConfList           			m_ConfDeleteList;
	CConfList2  					m_ConfList2;

	CAppSapList 				    m_AppSapList;

    BOOL							m_fConfListChangePending;

	GCCConfID   					m_ConfIDCounter;
	GCCConfID   					m_QueryIDCounter;

    BOOL							m_fControllerIsExiting;

	DWORD							m_dwControllerWaitTimeout;
	DWORD							m_dwControllerEventMask;
	
    //	These list are used only for iterating.  Whenever a conference or 
    //	application SAP object is deleted (or created in the case of an
    //	application SAP) it is added to the dictionary list first and
    //	a flag is set which forces the Polled list to get recreated at the
    //	top of the next heartbeat.
	CConfList                       m_ConfPollList;

    // T120 Applet list
    CAppletList                     m_AppletList;

};

extern GCCController *g_pGCCController;

/*
 *	GCCController (PGCCError	gcc_error)
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This is the Windows 32 Bit version of the GCC controller constructor. It 
 *		is responsible for initializing all the instance variables used by this 
 *		class.  It is also responsible for creating the memory manager, the
 *		packet coder, the Node Controller application interface, the Shared 
 *		memory interface used to communicate with enrolled applications, the
 *		Node Controller SAP and the MCS Interface.  It also sets up the 
 *		g_csGCCProvider that protects the core of GCC in the multi-threaded 
 *		Win32 environment.  It also sets up a number of Windows Event objects
 *		used to signal the GCC thread when various events happen at the
 *		interfaces. The last thing it does before returning if no errors have
 *		occured is launch the GCC thread. Fatal errors are returned from this 
 *		constructor in the return value. 
 *
 *	Formal Parameters:
 *		gcc_error	-	(o)	Errors that occur are returned here.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		This constructor launches the GCC thread if no errors occur.
 *
 *	Caveats
 *		This constructor is very specific to the Win32 environment.  When
 *		porting GCC to other platforms, this constructor will have to be
 *		rewritten for the proper platform.
 */

/*
 *	GCCController(	USHORT		timer_duration,
 *					PGCCError	gcc_error)
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This is the Windows 16 Bit version of the GCC controller constructor. It 
 *		is responsible for initializing all the instance variables used by this 
 *		class.  It is also responsible for creating the memory manager, the
 *		packet coder, the Node Controller application interface, the Shared 
 *		memory interface used to communicate with enrolled applications, the
 *		Node Controller SAP and the MCS Interface.  It also sets up the 
 *		internal Windows timer if a timer_interval other than zero is specified.
 *		Fatal errors are returned from this constructor in the return value. 
 *
 *	Formal Parameters:
 *		timer_duration	-	(i)	Timer interval in miliseconds that the
 *								heartbeat will trigger at.
 *		instance_handle	-	(i)	This is the windows instance handle used to
 *								set up the Windows timer.
 *		gcc_error		-	(o)	Errors that occur are returned here.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		This constructor is very specific to the Win16 environment.  When
 *		porting GCC to other platforms, this constructor will have to be
 *		rewritten for the proper platform.
 */

/*
 *	~GCCController();
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This is the Controller destructor.  All platform specific cleanup that
 *		occurs is included in this destructor but is "macro'd" out in 
 *		environments where the cleanup is not necessary (things like
 *		critical sections, and Windows timers).  Deleting the controller
 *		essentially shuts down GCC.  Deleting all the active conferences, SAPs,
 *		and interfaces along with all the GCC support modules (memory manager,
 *		packet coder, etc.).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		This destructor includes platform specific code.  It may be necessary
 *		to include some platform specific code here when porting GCC to 
 *		other platforms.  Macros should be used to isolate this code
 *		where ever possible.
 */

/*
 *	ULONG		Owner-Callback (		UINT        		message,
 *									LPVOID				parameter1,
 *									ULONG				parameter2);
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This function overides the base class function and is used to
 *		receive all owner callback information from the objects the
 *		the controller creates.
 *
 *	Formal Parameters:
 *		message		-		(i)	Message number including base offset.
 *		parameter1	-		(i)	void pointer of message data.
 *		parameter2	-		(i)	Long holding message data.		
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_ALLOCATION_FAILURE			-	Resource error occured.
 *		GCC_INVALID_CONFERENCE_NAME		-	Invalid conference name passed in.
 *		GCC_FAILURE_CREATING_DOMAIN		-	Failure creating domain.
 *		GCC_BAD_NETWORK_ADDRESS			-	Bad network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad network address type passed in.
 *		GCC_CONFERENCE_ALREADY_EXISTS	-	Conference specified already exists.
 *		GCC_INVALID_TRANSPORT			-	Cannot find specified transport.
 *		GCC_INVALID_ADDRESS_PREFIX		-	Bad transport address passed in.
 *		GCC_INVALID_TRANSPORT_ADDRESS	- 	Bad transport address
 *		GCC_BAD_SESSION_KEY				-	Enrolling with invalid session key.
 *		GCC_INVALID_PASSWORD			-	Invalid password passed in.
 *		GCC_BAD_USER_DATA				-	Invalid user data passed in.
 *		GCC_INVALID_JOIN_RESPONSE_TAG	-	No match found for join response tag
 *		GCC_NO_SUCH_APPLICATION			-	Invalid SAP handle passed in.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	-	Request failed because conference
 *											was not established.
 *		GCC_BAD_CAPABILITY_ID			-	Invalid capability ID passed in.
 *		GCC_NO_SUCH_APPLICATION			-	Bad SAP handle passed in.
 *		GCC_DOMAIN_PARAMETERS_UNACCEPTABLE	- Domain parameters were
 *											  unacceptable for this connection.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	EventLoop();
 *
 *	Public member function of Conference
 *
 *	Function Description
 *		This routine is only used for the 32 bit windows platform.  It gets
 *		called whenever an event occurs in this environment.  These include
 *		timer events as well as PDU and message events
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

#endif // _GCC_CONTROLLER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\mcattprt.h ===
/*	MCATTPRT.h
 *
 *	Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the TCP Transport. If an application
 *		is making calls directly to the Transport DLL, this file MUST be
 *		included.  All transports have the same interface.  This makes
 *		programming to the Transports simpler for the user.
 *
 *		This file contains all of the prototypes and defintions needed to use
 *		any of the Transport DLLs.
 *
 *		Transports have 2 modes of operation, either in-band call control or
 *		out-of-band call control.  With in-band call control, the Transport DLL
 *		makes the physical connection when the TConnectRequest() call is made
 *		from MCS.  It also breaks the physical connection when MCS makes a
 *		TDisconnectRequest() call.  This basic mode of operation works well but
 *		we have added the out-of-band call control mode for 2 reasons:
 *
 *			1.  Allow the user to make multiple MCS connections without
 *				breaking the physical connection.  This is needed if the
 *				application is using the GCC Query commands.
 *
 *			2.  Allow the user to use any type of calling mechanism (i.e. TAPI,
 *				TSAPI,...) that they want.
 *		
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James W. Lawwill
 *
 */
#ifndef	_MCATTPRT_
#define	_MCATTPRT_

#include "databeam.h"

/*
 *	These are valid return codes from the Transport DLL.
 *	
 *	TRANSPORT_NO_ERROR
 *		The function executed properly, without error.  This does not mean
 *		that the function is complete.  Some functions are non-blocking
 *		(they don't occur immediately), therefore they could still fail.
 *		A good example of this is the TConnectRequest() function in the
 *		TCP transport.  It takes a few seconds to call the remote site and
 *		establish a link.  If the connection fails or succeeds, a callback
 *		will be sent back to the user to give them the status.
 *	TRANSPORT_INITIALIZATION_FAILED
 *		The TInitialize() function failed.  This can occur for a number of
 *		reasons.
 *	TRANSPORT_NOT_INITIALIZED
 *		The user is attempting to use a function even though the TInitialize()
 *		function failed.
 *	TRANSPORT_NO_SUCH_CONNECTION
 *		The user is attempting a function call with an illegal
 *		TransportConnection handle.
 *	TRANSPORT_WRITE_QUEUE_FULL
 *		The TDataRequest() function failed because its write queue is full
 *	TRANSPORT_READ_QUEUE_FULL
 *		This return value is returned from the TRANSPORT_DATA_INDICATION
 *		callback.  It occurs when the user application can not handle the
 *		data packet because it does not currently have room for it.  This
 *		is a flow control mechanism between the user application and the
 *		Transport DLL.
 *	TRANSPORT_CONNECT_REQUEST_FAILED
 *		The TConnectRequest() function failed because the modem was not
 *		in the proper mode.  As we initialize a modem, it is not possible
 *		to dial out it.  Try the TConnectRequest() later.
 *	TRANSPORT_CONNECT_RESPONSE_FAILED
 *		The TConnectResponse() function failed.  Evidently, the function was
 *		called at the wrong time.
 *	TRANSPORT_NO_CONNECTION_AVAILABLE
 *		The TConnectRequest() function failed because all available modems
 *		are currently in use.
 *	TRANSPORT_NOT_READY_TO_TRANSMIT
 *		The TDataRequest() function failed because it is not ready to send
 *		data.  If you attempt this function before you receive a
 *		TRANSPORT_CONNECT_INDICATION callback, you will receive this value
 *	TRANSPORT_ILLEGAL_COMMAND
 *		TResetDevice() or TProcessCommand() failed because the command submitted
 *		to the function was invalid.
 *	TRANSPORT_CONFIGURATION_ERROR
 *		Return value from TProcessCommand() if the user is enabling a device
 *		that has an illegal configuration setup in the .ini file
 *	TRANSPORT_MEMORY_FAILURE
 *		The function failed because the Transport Stack was not able to allocate
 *		the memory necessary to perform the function.
 */
typedef	unsigned long						TransportError;
typedef	TransportError *					PTransportError;

#define	TRANSPORT_NO_ERROR					0
#define	TRANSPORT_INITIALIZATION_FAILED		1
#define	TRANSPORT_NOT_INITIALIZED			2
#define	TRANSPORT_NO_SUCH_CONNECTION		3
#define	TRANSPORT_WRITE_QUEUE_FULL			4
#define	TRANSPORT_READ_QUEUE_FULL			5
#define	TRANSPORT_CONNECT_REQUEST_FAILED	6
#define TRANSPORT_MEMORY_FAILURE			7
#define	TRANSPORT_NOT_READY_TO_TRANSMIT		8
#define TRANSPORT_CANT_SEND_NOW				9
#define	TRANSPORT_ILLEGAL_COMMAND			10
#define	TRANSPORT_CONFIGURATION_ERROR		12
#define TRANSPORT_CONNECT_RESPONSE_FAILED	13

#define TRANSPORT_SECURITY_FAILED			14

#define TRANSPORT_BUFFER_TOO_SMALL          15
#define TRANSPORT_NO_PLUGGABLE_CONNECTION   16
#define TRANSPORT_WRITE_FILE_FAILED         17
#define TRANSPORT_ALREADY_INITIALIZED       18
#define TRANSPORT_INVALID_PARAMETER         19
#define TRANSPORT_PHYSICAL_LAYER_NOT_FOUND  20
#define TRANSPORT_NO_T123_STACK             21

/*
 *	TransportConnection is the handle used by the Transport DLL
 *	to distinguish one logical connection from another.  The DLL assigns
 *	the transport connection in a TConnectRequest() call or as a
 *	result of a TRANSPORT_CONNECT_INDICATION callback
 */
typedef enum tagTransportType
{
    TRANSPORT_TYPE_WINSOCK          = 0,
    TRANSPORT_TYPE_PLUGGABLE_X224   = 1,
    TRANSPORT_TYPE_PLUGGABLE_PSTN   = 2,
}
    TransportType;

typedef struct tagTransportConnection
{
    TransportType   eType;
    UINT_PTR        nLogicalHandle;
}
    TransportConnection, *PTransportConnection;

#define PACK_XPRTCONN(x)            (MAKELONG((x).nLogicalHandle, (x).eType))
#define UNPACK_XPRTCONN(x,n)        { (x).nLogicalHandle = LOWORD((n)); (x).eType = (TransportType) HIWORD((n)); }

#define IS_SAME_TRANSPORT_CONNECTION(x1,x2) (((x1).eType == (x2).eType) && ((x1).nLogicalHandle == (x2).nLogicalHandle))
#define IS_SOCKET(x)                        (TRANSPORT_TYPE_WINSOCK == (x).eType)
#define IS_PLUGGABLE(x)                     (TRANSPORT_TYPE_WINSOCK != (x).eType)
#define IS_PLUGGABLE_X224(x)                (TRANSPORT_TYPE_PLUGGABLE_X224 == (x).eType)
#define IS_PLUGGABLE_PSTN(x)                (TRANSPORT_TYPE_PLUGGABLE_PSTN == (x).eType)
#define IS_VALID_TRANSPORT_CONNECTION_TYPE(x) (IS_SOCKET(x) || IS_PLUGGABLE_X224(x) || IS_PLUGGABLE_PSTN(x))

#define SET_SOCKET_CONNECTION(x,s)          { (x).eType = TRANSPORT_TYPE_WINSOCK; (x).nLogicalHandle = (s); }


/*
 *	This structure is passed back with the TRANSPORT_DATA_INDICATION message.
 *
 *	Since there is only one callback address passed into the Transport DLL and
 *	there can be many transport connections maintained by this DLL, the
 *	transport_connection number is included in the structure.  This number
 *	tells the user application which connection the data is associated with.
 *
 *	The other two parameters are the data address and data length
 */
typedef	struct
{
	TransportConnection		transport_connection;
	unsigned char *			user_data;
	unsigned long			user_data_length;
	PMemory					memory;
} TransportData;
typedef	TransportData *		PTransportData;


/*
 *	The following section defines the callbacks that can be issued to the
 *	user.
 *
 *	The callback contains three parameters:
 *		The first is the callback message.
 *		The second is specific to the callback message.
 *		The third is the user defined value that is passed in
 *			during TInitialize().
 */

/*
 *	Message:	TRANSPORT_CONNECT_INDICATION
 *	Parameter:	
 *		TransportConnection		transport_connection
 *
 *	Functional Description:
 *		The user receives this message when an incoming call has been
 *		received.  The user can issue a TConnectResponse() to accept the
 *		call or a TDisconnectRequest() to terminate the connection.
 *
 *		The user will never receive this callback message if he originates
 *		the connection.  In that case the user will receive a
 *		TRANSPORT_CONNECT_CONFIRM.
 */

/*
 *	Message:	TRANSPORT_DATA_INDICATION
 *	Parameter:	
 *		PTransportData
 *			This is the address of the transport data structure
 *
 *	Functional Description:
 *		The callback returns this message when it has data for the user.
 *		The message is sent with the address of a TransportData structure,
 *		which contains the transport_connection, the data address, and the
 *		data length.
 */

/*
 *	Message:	TRANSPORT_EXPEDITED_DATA_INDICATION
 *	Parameter:	
 *		PTransportData
 *			This is the address of the transport data structure
 *
 *	Functional Description:
 *		This callback is currently unsupported.
 */

/*
 *	Message:	TRANSPORT_DISCONNECT_INDICATION
 *	Parameter:	
 *		TransportConnection
 *
 *	Functional Description:
 *		The callback returns this message when the transport connection
 *		is broken.  It can result from a TDisconnectRequest() call by the
 *		user, or from an unstable physical connection.
 */

/*
 *	Message:	TRANSPORT_CONNECT_CONFIRM
 *	Parameter:	
 *		TransportConnection
 *
 *	Functional Description:
 *		The callback returns this message when a new transport connection
 *		has been established.
 *
 *		This message is issued in response to the user issuing a
 *		TConnectRequest().  When the Transport Connection is up and
 *		operational, the user will receive this callback message.
 *
 *		If you are called by another user, you will receive a
 *		TRANSPORT_CONNECT_INDICATION.
 */

/*
 *  Message:    TRANSPORT_STATUS_INDICATION
 *  Parameter:
 *      PTransportStatus
 *          Address of the TransportStatus structure
 *
 *  Functional Description:
 *      This callback is sent from a Transport Layer to notify the user of a
 *      change in a physical device.  For example, in the case of the PSTN
 *      Transport Stack, this message will be sent up when the modem detects an
 *      incoming RING or when a connection is established.  Any time the state
 *      of the modem changes, a message will be sent up.  Messages will also be
 *      sent up when an error occurs
 */

#define TRANSPORT_CONNECT_INDICATION            0
#define TRANSPORT_CONNECT_CONFIRM               1
#define TRANSPORT_DATA_INDICATION               2
// #define TRANSPORT_EXPEDITED_DATA_INDICATION     3
#define TRANSPORT_DISCONNECT_INDICATION         4
// #define TRANSPORT_STATUS_INDICATION             5
#define TRANSPORT_BUFFER_EMPTY_INDICATION       6



#ifdef TSTATUS_INDICATION
/*
 *	Physical Device states
 */
typedef enum
{
	TSTATE_NOT_READY,
	TSTATE_NOT_CONNECTED,
	TSTATE_CONNECT_PENDING,
	TSTATE_CONNECTED,
	TSTATE_REMOVED
}  TransportState;

/*
 *	The following structure is passed to ths user via the
 *	TRANSPORT_STATUS_INDICATION callback.
 *
 *
 *		device_identifier 	 -	The device_identifier is only set if a specific
 *								device is referenced (i.e. "COM1").
 *
 *		remote_address 		 -	String specifying the address of the person we
 *								are linked to.
 *
 *		message				 -	This string is filled in to give the user some
 *								type of feedback.  A message may reflect an
 *								error in the configuration file, an incoming
 *								RING from the modem, or a BUSY signal on the
 *								telephone line.
 *
 *		state				 -	Current state of the device.  This is one of
 *								the TransportState enumerations.
 */
typedef struct
{
	char *			device_identifier;
	char *			remote_address;
	char *			message;
	TransportState	state;
}  TransportStatus;
typedef TransportStatus *	PTransportStatus;

#endif // TSTATUS_INDICATION

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\invoklst.h ===
/*
 *	invoklst.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CInvokeSpecifierListContainer.
 *		This class manages the data associated with an Application Invoke 
 *		Request or Indication.  This includes a list of applications to be 
 *		invoked.  The CInvokeSpecifierListContainer data container utilizes a 
 *		CSessKeyContainer container to buffer part of the data associated with each
 *		application invoke specifier.  Each application invoke specifier also 
 *		includes a capability ID whose data is buffered internally by the 
 *		using a CCapIDContainer container.  The list of application 
 *		invoke specifiers is maintained internally by the class through the use
 *		of a Rogue Wave list container.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_APPLICATION_INVOKE_SPECIFIER_LIST_
#define	_APPLICATION_INVOKE_SPECIFIER_LIST_

#include "capid.h"
#include "sesskey.h"
#include "arost.h"

/*
 * This is the internal structure used to hold the data associated with each
 * invoke specifier.
 */
typedef struct
{
	CSessKeyContainer			    *session_key;
	CAppCapItemList             	ExpectedCapItemList;
	MCSChannelType					startup_channel_type;
	BOOL    						must_be_invoked;
}
    INVOKE_SPECIFIER;

/*
 * These are the typedefs for the Rogue Wave list which is used to hold the
 * invoke specifier info structures.
 */
class CInvokeSpecifierList : public CList
{
    DEFINE_CLIST(CInvokeSpecifierList, INVOKE_SPECIFIER*)
};

/*
 * Class definition:
 */
class CInvokeSpecifierListContainer : public CRefCount
{
public:

	CInvokeSpecifierListContainer(UINT cProtEntities, PGCCAppProtocolEntity *, PGCCError);
	CInvokeSpecifierListContainer(PApplicationProtocolEntityList, PGCCError);

	~CInvokeSpecifierListContainer(void);

	UINT		LockApplicationInvokeSpecifierList(void);
	void		UnLockApplicationInvokeSpecifierList(void);

    UINT		GetApplicationInvokeSpecifierList(USHORT *pcProtEntities, LPBYTE memory);
    UINT		GetApplicationInvokeSpecifierList(ULONG *pcProtEntities, LPBYTE pMemory)
    {
        USHORT c;
        UINT nRet = GetApplicationInvokeSpecifierList(&c, pMemory);
        *pcProtEntities = c;
        return nRet;
    }

    GCCError	GetApplicationInvokeSpecifierListPDU(PApplicationProtocolEntityList *);
	void		FreeApplicationInvokeSpecifierListPDU(void);

protected:

	CInvokeSpecifierList			m_InvokeSpecifierList;
	UINT							m_cbDataSize;

	PApplicationProtocolEntityList	m_pAPEListPDU;
	BOOL    						m_fValidAPEListPDU;

private:

	GCCError	SaveAPICapabilities(INVOKE_SPECIFIER *, UINT cCaps, PGCCApplicationCapability *);
	GCCError	SavePDUCapabilities(INVOKE_SPECIFIER *, PSetOfExpectedCapabilities);
	UINT		GetApplicationCapability(APP_CAP_ITEM *, PGCCApplicationCapability, LPBYTE memory);
	GCCError	ConvertInvokeSpecifierInfoToPDU(INVOKE_SPECIFIER *, PApplicationProtocolEntityList);
	GCCError	ConvertExpectedCapabilityDataToPDU(APP_CAP_ITEM *, PSetOfExpectedCapabilities);
};


/*
 *	Comments explaining the public and private class member functions
 */

/*
 *	CInvokeSpecifierListContainer (
 *					USHORT						number_of_protocol_entities,
 *					PGCCAppProtocolEntity *		app_protocol_entity_list,
 *					PGCCError					return_value);
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This is a constructor for the CInvokeSpecifierListContainer class.
 *		This constructor is used to create an CInvokeSpecifierListContainer
 * 		object from a list of "API" application protocol entities.
 *
 *	Formal Parameters:
 *		number_of_protocol_entities		(i) The number of "APE"s in the list.
 *		app_protocol_entity_list		(i) The list of API "APE"s.
 *		return_value					(o) Error return value.
 *
 *	Return Value:
 *		GCC_NO_ERROR			- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE	- A resource allocation error occurred.
 *		GCC_BAD_SESSION_KEY		- An APE contained an invalid session key.
 *		GCC_BAD_CAPABILITY_ID	- An API contained an invalid capability ID.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CInvokeSpecifierListContainer (
 *				PApplicationProtocolEntityList		app_protocol_entity_list,
 *				PGCCError							return_value);
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This is a constructor for the CInvokeSpecifierListContainer class.
 *		This constructor is used to create an CInvokeSpecifierListContainer 
 *		object from	a "PDU" ApplicationProtocolEntityList.
 *
 *	Formal Parameters:
 *		app_protocol_entity_list		(i) The list of PDU "APE"s.
 *		return_value					(o) Error return value.
 *
 *	Return Value:
 *		GCC_NO_ERROR			- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE	- A resource allocation error occurred.
 *		GCC_BAD_SESSION_KEY		- An APE contained an invalid session key.
 *		GCC_BAD_CAPABILITY_ID	- An API contained an invalid capability ID.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CInvokeSpecifierListContainer ();
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This is the destructor for the CInvokeSpecifierListContainer class.
 *		It is responsible for freeing any memory allocated to hold the 
 *		invoke data.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT	LockApplicationInvokeSpecifierList ();
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the list of GCCAppProtocolEntity 
 *		structures which is filled in on a call to GetApplicationInvoke-
 *		SpecifierList.  This is the	value returned by this routine in order to 
 *		allow the calling object to	allocate that amount of memory in 
 *		preparation for the call to GetApplicationInvokeSpecifierList.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory which will be needed to hold "API" data
 *		which is a list of GCCAppProtocolEntity structures.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeApplicationInvokeSpecifierList.
 *		This allows	other objects to lock this object and be sure that it 
 *		remains valid until they call UnLock which will decrement the internal 
 *		lock count.  A typical usage scenerio for this object would be:  An 
 *		CInvokeSpecifierListContainer object is constructed and then passed off
 *		to any interested parties through a function call.  On return from the 
 *		function call, the FreeApplicationInvokeSpecifierList call is made which
 *		will set the internal "free" flag.  If no other parties have locked the 
 *		object with a Lock call, then the CInvokeSpecifierListContainer object
 *		will automatically delete itself when the FreeApplicationInvoke-
 *		SpecifierList call is made.  If, however, any number of other parties 
 *		has locked the object, it will remain in existence until each of them 
 *		has unlocked the object through a call to UnLock.
 */


/*
 *	UINT	GetApplicationInvokeSpecifierList (
 *								PUShort			number_of_protocol_entities,
 *								LPSTR			memory);
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the application invoke specifier list
 *		from the CInvokeSpecifierListContainer object in the "API" form of a 
 *		list of PGCCAppProtocolEntity structures.
 *
 *	Formal Parameters:
 *		number_of_protocol_entities		(o) The number of APEs in the list.
 *		memory							(o)	The memory used to hold the 
 *												APE data.
 *
 *	Return Value:
 *		The amount of memory which will be needed to hold "API" data
 *		which is a list of GCCAppProtocolEntity structures.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void	UnLockApplicationInvokeSpecifierList ();
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeApplicationInvokeSpecifierList.  If so, the object will 
 *		automatically delete itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	GetApplicationInvokeSpecifierListPDU (
 *					PApplicationProtocolEntityList	*  protocol_entity_list);
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the object key data from the
 *		CInvokeSpecifierListContainer object in the "PDU" form of a list of
 *		PApplicationProtocolEntityList structures.
 *
 *	Formal Parameters:
 *		protocol_entity_list		(o)	The list of structures to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR				-	No error.
 *		GCC_ALLOCATION_FAILURE		- 	A resource allocation error occurred.
 *
 *  Side Effects:
 *		The first time this routine is called, data is allocated internally to
 *		hold the PDU form.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void	FreeApplicationInvokeSpecifierListPDU ();
 *
 *	Public member function of CInvokeSpecifierListContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal flag is set to indicate that the PDU form of data no
 *		longer is valid for this object.
 *
 *	Caveats:
 *		None.
 */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\mcsdllif.h ===
/*
 *	mcsdllif.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the MCAT MCS DLL Interface class.
 *
 *		When this class is first instantiated, it initializes MCS.  After
 *		that, the application using this object requests MCS services through
 *		this object. This object is also responsible for receiving and
 *		forwarding cllback messages.  When this object is deleted it calls
 *		MCSCleanupAPI to shut down the MCATMCS DLL.
 *
 *		MCS interface objects represent the Service Access Point (SAP)
 *		between GCC and MCS.  Exactly how the interface works is an
 *		implementation matter for those classes that inherit from this one.
 *		This class defines the public member functions that GCC expects to be
 *		able to call upon to utilize MCS.
 *
 *		The public member functions defined here can be broken into two
 *		categories: those that are part of T.122; and those that are not.
 *		The T.122 functions include connect provider request, connect
 *		provider response, disconnect provider request, create domain, delete
 *		domain, send data request, etc.  All other member functions are
 *		considered a local matter from a standards point-of-view.  These
 *		functions include support for initialization and setup, as well as
 *		functions allowing GCC to poll MCS for activity.
 *
 *		Note that this class also handles the connect provider confirms by
 *		keeping a list of all the objects with outstanding connect provider
 *		request.  These are held in the ConfirmObjectList.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Christos Tsollis
 *
 */
#ifndef	_MCS_DLL_INTERFACE_
#define	_MCS_DLL_INTERFACE_

#include "mcsuser.h"

/*
**	This dictionary keeps up with all the outstanding connect provider
**	request.  When a response is received, this interface class will obtain
**	a pointer to the correct object from this list and will then pass on the
**	response.
*/
class CConnHdlConfList2 : public CList2
{
    DEFINE_CLIST2_(CConnHdlConfList2, CConf*, ConnectionHandle)
};

extern  PController					g_pMCSController;

/*
 *	CONNECT_PROVIDER_INDICATION
 *
 *	Parameter1:
 *		PConnectProviderIndication
 *			This is a pointer to a structure that contains all necessary
 *			information about an incoming connection.
 *	Parameter2: Unused
 *
 *	Functional Description:
 *		This indication is sent to the owner object when an incoming
 *		connection is detected.  The owner object should respond by calling
 *		MCSConnectProviderResponse indicating whether or not the connection
 *		is to be accepted.
 */

/*
 *	CONNECT_PROVIDER_CONFIRM
 *
 *	Parameter1:
 *		PConnectProviderConfirm
 *			This is a pointer to a structure that contains all necessary
 *			information about an outgoing connection.
 *	Parameter2: Unused
 *
 *	Functional Description:
 *		This confirm is sent to the object that made the original connect
 *		provider request.  It informs the requesting object of when the new
 *		connection is available for use, or that the connection could not be
 *		established (or that it was rejected by the	remote site).
 */

/*
 *	DISCONNECT_PROVIDER_INDICATION
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) ConnectionHandle
 *			This is the handle for the connection that was lost.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the disconnect.
 *
 *	Functional Description:
 *		This indication is sent to the owner object whenever a connection
 *		is lost.  This essentially tells the owner object that the contained
 *		connection handle is no longer valid.
 */

/*
 *	GCC_ATTACH_USER_CONFIRM
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) UserID
 *			If the result is success, then this is the newly assigned user ID.
 *			If the result is failure, then this field is undefined.
 *		(HIGHUSHORT) Result
 *			This is the result of the attach user request.
 *
 *	Functional Description:
 *		This confirm is sent to the user object in response to a previous
 *		call to MCS_AttachRequest.  It contains the result of that service
 *		request.  If successful, it also contains the user ID that has been
 *		assigned to that attachment.
 */

/*
 *	GCC_DETACH_USER_INDICATION
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) UserID
 *			This is the user ID of the user that is detaching.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the detachment.
 *
 *	Functional Description:
 *		This indication is sent to the user object whenever a user detaches
 *		from the domain.  This is sent to ALL remaining user objects in the
 *		domain automatically.  Note that if the user ID contained in this
 *		indication is the same as that of the user object receiving it, the
 *		user is	essentially being told that it has been kicked out of the
 *		conference.  The user handle and user ID are no longer valid in this
 *		case.  It is the responsibility of the user object to recognize when
 *		this occurs.
 */

/*
 *	GCC_CHANNEL_JOIN_CONFIRM
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) ChannelID
 *			This is the channel that has been joined.
 *		(HIGHUSHORT) Result
 *			This is the result of the join request.
 *
 *	Functional Description:
 *		This confirm is sent to a user object in response to a previous
 *		call to ChannelJoinRequest.  It lets the user object know if the
 *		join was successful for a particular channel.  Furthermore, if the
 *		join request was for channel 0 (zero), then the ID of the assigned
 *		channel is contained in this confirm.
 */

/*
 *	CHANNEL_LEAVE_INDICATION
 *
 *	Parameter1: Unused
 *	Parameter2:
 *		(LOWUSHORT) ChannelID
 *			This is the channel that has been left or is being told to leave.
 *		(HIGHUSHORT) Reason
 *			This is the reason for the leave.
 *
 *	Functional Description:
 *		This indication is sent to a user object when a domain merger has
 *		caused a channel to be purged from the lower domain.  This informs the
 *		the user that it is no longer joined to the channel.
 */

/*
 *	GCC_SEND_DATA_INDICATION
 *
 *	Parameter1:
 *		PSendData
 *			This is a pointer to a SendData structure that contains all
 *			information about the data received.
 *	Parameter2: Unused
 *
 *	Functional Description:
 *		This indication is sent to a user object when data is received
 *		by the local MCS provider on a channel to which the user is joined.
 */

/*
 *	GCC_UNIFORM_SEND_DATA_INDICATION
 *
 *	Parameter1:
 *		PSendData
 *			This is a pointer to a SendData structure that contains all
 *			information about the data received.
 *	Parameter2: Unused
 *
 *	Functional Description:
 *		This indication is sent to a user object when data is received
 *		by the local MCS provider on a channel to which the user is joined.
 */
/*
 *	TRANSPORT_STATUS_INDICATION
 *
 *	Parameter1:
 *		PTransportStatus
 *			This is a pointer to a TransportStatus structure that contains
 *			information about this indication.  This structure is defined in
 *			"transprt.h".
 *
 *	Functional Description:
 *		A transport stack will issue this indication when it detects a status
 *		change of some sort.  It fills in the TransportStatus structure to
 *		describe the state change and the sends it to MCS.  MCS fills in the
 *		field containing the name of the stack (using the transport identifier),
 *		and forwards it to GCC.
 */

class CConf;
class MCSUser;

class CMCSUserList : public CList
{
    DEFINE_CLIST(CMCSUserList, MCSUser*)
};

class MCSDLLInterface
{
public:

    MCSDLLInterface(PMCSError);
    ~MCSDLLInterface ();

	MCSError 	CreateDomain(GCCConfID *domain_selector)
	{
		ASSERT (g_pMCSController != NULL);
		return g_pMCSController->HandleAppletCreateDomain(domain_selector);
	};

	MCSError 	DeleteDomain(GCCConfID *domain_selector)
	{
		ASSERT (g_pMCSController != NULL);
		return g_pMCSController->HandleAppletDeleteDomain(domain_selector);
	}


	MCSError	ConnectProviderRequest (
							GCCConfID          *calling_domain,
							GCCConfID          *called_domain,
							TransportAddress	calling_address,
							TransportAddress	called_address,
							BOOL				fSecure,
							DBBoolean			upward_connection,
							PUChar				user_data,
							ULong				user_data_length,
							PConnectionHandle	connection_handle,
							PDomainParameters	domain_parameters,
							CConf		        *confirm_object);


	MCSError	ConnectProviderResponse (
							ConnectionHandle	connection_handle,
							GCCConfID          *domain_selector,
							PDomainParameters	domain_parameters,
							Result				result,
							PUChar				user_data,
							ULong				user_data_length);

	MCSError	DisconnectProviderRequest (
							ConnectionHandle	connection_handle);

	MCSError	AttachUserRequest (
							GCCConfID           *domain_selector,
							PIMCSSap 			*ppMCSSap,
							MCSUser		        *user_object);

	MCSError	DetachUserRequest (
							PIMCSSap 			pMCSSap,
							MCSUser 			*pMCSUser);

	MCSError	ChannelJoinRequest (
							ChannelID			channel_id,
							PIMCSSap 			pMCSSap)
				{
					return pMCSSap->ChannelJoin (channel_id);
				};

	MCSError	ChannelLeaveRequest (
							ChannelID			channel_id,
							PIMCSSap 			pMCSSap)
				{
					return pMCSSap->ChannelLeave (channel_id);
				};

	MCSError	SendDataRequest (
							ChannelID			channel_id,
							PIMCSSap 			pMCSSap,
							Priority			priority,
							PUChar				user_data,
							ULong				user_data_length)
				{
					return pMCSSap->SendData (NORMAL_SEND_DATA,
									channel_id,
									priority,
									user_data,
									user_data_length,
									APP_ALLOCATION);
				};

	MCSError	UniformSendDataRequest (	
							ChannelID			channel_id,
							PIMCSSap 			pMCSSap,
							Priority			priority,
							PUChar				user_data,
							ULong				user_data_length)
				{
					return pMCSSap->SendData (UNIFORM_SEND_DATA,
									channel_id,
									priority,
									user_data,
									user_data_length,
									APP_ALLOCATION);
				};

	MCSError	TokenGrabRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id)
				{
					return pMCSSap->TokenGrab (token_id);
				};
							
	MCSError	TokenGiveRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id,
							UserID				receiver_id)
				{
					return pMCSSap->TokenGive (token_id,
									receiver_id);
				};
							
	MCSError	TokenGiveResponse (
							PIMCSSap 			pMCSSap,
							TokenID				token_id,
							Result				result)
				{
					return pMCSSap->TokenGiveResponse (token_id,
									result);
				};

	MCSError	TokenPleaseRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id)
				{
					return pMCSSap->TokenPlease (token_id);
				};
							
	MCSError	TokenReleaseRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id)
				{
					return pMCSSap->TokenRelease (token_id);
				};

	MCSError	TokenTestRequest (
							PIMCSSap 			pMCSSap,
							TokenID				token_id)
				{
					return pMCSSap->TokenTest (token_id);
				};

#ifdef NM_RESET_DEVICE
	MCSError	ResetDevice (
							PChar				device_identifier)
				{
					return MCSResetDevice (device_identifier);
				};
#endif // NM_RESET_DEVICE

	GCCError	TranslateMCSIFErrorToGCCError (MCSError	mcs_error)
				{
					return ((mcs_error <= MCS_SECURITY_FAILED) ?
							(GCCError) mcs_error : GCC_UNSUPPORTED_ERROR);
				};

	void			ProcessCallback (
							unsigned int		message,
							LPARAM				parameter,
							PVoid				object_ptr);
private:
	MCSError	AddObjectToConfirmList (
								CConf		        *confirm_object,
								ConnectionHandle	connection_handle);

	DBBoolean			IsUserAttachmentVaid (
								MCSUser				*user_object)
						{
							return (m_MCSUserList.Find(user_object));
						};
	CConnHdlConfList2   m_ConfirmConnHdlConfList2;
	CMCSUserList        m_MCSUserList;
};
typedef	MCSDLLInterface *			PMCSDLLInterface;


GCCResult TranslateMCSResultToGCCResult ( Result mcs_result );

/*
 *	MCSDLLInterface (	HANDLE				instance_handle,
 *						PMCSError			error_value)
 *
 *	Functional Description:
 *		This is the constructor for the MCS Interface class. It is responsible
 *		for initializing the MCAT MCS DLL.  Any errors that occur during
 *		initialization are returned in the error_value provided.
 *
 *	Formal Parameters:
 *		instance_handle (i)
 *			The windows instance handle is used when creating MCS diagnostics.
 *		error_value (i)
 *			This pointer is used to pass back any errors that may have occured
 *			while initializing the class.  This includes any problems with
 *			initializing the MCAT MCS DLL.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~MCSDLLInterface ()
 *
 *	Functional Description:
 *		This is the destructor for the MCS Interface class. It is responsible
 *		for cleaning up both itself and the MCAT MCS DLL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	CreateDomain (
 *							DomainSelector		domain_selector_string,
 *							UINT				domain_selector_length)
 *
 *	Functional Description:
 *		This function is used to create an MCS domain.
 *
 *	Formal Parameters:
 *		domain_selector_string (i)
 *			This is the name of the domain to be created.
 *		domain_selector_length (i)
 *			This is the length of the domain name in characters.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_DOMAIN_ALREADY_EXISTS
 *			A domain by this name alread exist
 *		MCS_ALLOCATION_FAILURE
 *			A memory failure occured
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	DeleteDomain (
 *							DomainSelector		domain_selector_string,
 *							UINT				domain_selector_length)
 *
 *	Functional Description:
 *		This function an MCS domain which was created using the CreateDomain
 *		call.
 *
 *	Formal Parameters:
 *		domain_selector_string (i)
 *			This is the name of the domain to be deleted.
 *		domain_selector_length (i)
 *			This is the length of the domain name in characters.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_NO_SUCH_DOMAIN
 *			The domain to be deleted does not exist
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ConnectProviderRequest (
 *							DomainSelector		calling_domain,
 *							UINT				calling_domain_length,
 *							DomainSelector		called_domain,
 *							UINT				called_domain_length,
 *							TransportAddress	calling_address,
 *							TransportAddress	called_address,
 *							DBBoolean				upward_connection,
 *							PUChar				user_data,
 *							ULong				user_data_length,
 *							PConnectionHandle	connection_handle,
 *							PDomainParameters	domain_parameters,
 *							CConf		        *confirm_object)
 *
 *	Functional Description:
 *		This T.122 primitive is used to connect two domains. This request
 *		should always be followed by a connect provider confirm.  The
 *		confirm will be sent to be object specified by the confirm object
 *		the is passed into this routine.
 *
 *	Formal Parameters:
 *		calling_domain (i)
 *			This is a pointer to the calling domain selector string.
 *		calling_domain_length (i)
 *			This is the length of the calling domain selector string.
 *		called_domain (i)
 *			This is a pointer to the called domain selector string.
 *		called_domain_length (i)
 *			This is the length of the called domain selector length.
 *		calling_address (i)
 *			This is a pointer to the calling addres (an ASCII string).
 *		called_address (i)
 *			This is a pointer to the address being called (an ASCII string).
 *		upward_connection (i)
 *			This boolean flag denotes the hierarchical direction of the
 *			connection to be created (TRUE means upward, FALSE means downward).
 *		user_data (i)
 *			This is a pointer to the user data to be transmitted during the
 *			creation of this new connection.
 *		user_data_length (i)
 *			This is the length of the user data field mentioned above.
 *		connection_handle (o)
 *			This is set by MCS to a unique handle that can be used to access
 *			this connection on subsequent calls.
 *		domain_parameters (i)
 *			This is a pointer to a structure containing the domain parameters
 *			that the node controller wishes to use for this new connection.
 *		confirm_object (i)
 *			This is a pointer to the object that the connect provider response
 *			is sent to.
 *		object_message_base (i)
 *			This message base is added to the connect provider response
 *			message.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_NO_SUCH_DOMAIN
 *			The domain to connect does not exist
 *		MCS_DOMAIN_NOT_HIERARCHICAL
 *			An upward connection from this domain already exist
 *		MCS_NVALID_ADDRESS_PREFIX
 *			The transport prefix is not recognized
 *		MCS_ALLOCATION_FAILURE
 *			A memory failure occured
 *		MCS_INVALID_PARAMETER
 *			One of the parameters to the request is invalid
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ConnectProviderResponse (
 *							ConnectionHandle	connection_handle,
 *							DomainSelector		domain_selector,
 *							UINT				domain_selector_length,
 *							PDomainParameters	domain_parameters,
 *							Result				result,
 *							PUChar				user_data,
 *							ULong				user_data_length)
 *
 *	Functional Description:
 *		This function is used to respond to a connect provider indication.
 *		This call will result in a connect provider confirm at the remote
 *		node.
 *
 *	Formal Parameters:
 *		connection_handle (i)
 *			This is the handle of the connection that the response is for.
 *		domain_selector (i)
 *			This is a pointer to the domain selector identifying which domain
 *			the inbound connection is to be bound to.
 *		domain_selector_length (i)
 *			This is the length of the above domain selector.
 *		domain_parameters (i)
 *			This is a pointer to a structure containing the domain parameters
 *			that the node controller has agreed to use for the connection
 *			being created.
 *		result (i)
 *			This is the result.  This determines whether an inbound connection
 *			is accepted or rejected.  Anything but RESULT_SUCCESSFUL rejects
 *			the connection.
 *		user_data (i)
 *			This is the address of user data to be sent in the connect response
 *			PDU.
 *		user_data_length (i)
 *			This is the length of the user data mentioned above.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_NO_SUCH_CONNECTION
 *			The connection specified is invalid
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	DisconnectProviderRequest (
 *							ConnectionHandle	connection_handle)
 *
 *	Functional Description:
 *		This function is used to disconnect a node from a particular connection.
 *		This can be either an upward or downward connection
 *
 *	Formal Parameters:
 *		connection_handle (i)
 *			This is the handle of the connection which the node controller wants
 *			to disconnect.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NOT_INITIALIZED
 *			The mcs interface did not initialize properly
 *		MCS_NO_SUCH_CONNECTION
 *			The connection specified is invalid
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	AttachUserRequest (
 *							DomainSelector		domain_selector,
 *							UINT				domain_selector_length,
 *							PIMCSSap 			*ppMCSSap,
 *							PMCSUser			user_object)
 *
 *	Functional Description:
 *		This function is used to create a user attachment to MCS. It will result
 *		in an attach user confirm.
 *
 *	Formal Parameters:
 *		domain_selector (i)
 *			This is the name of the domain to which the user wishes to attach.
 *		domain_selector_length (i)
 *			This is the length of the above domain selector.
 *		ppMCSSap (o)
 *			This is a pointer to a variable where the new user handle will be
 *			stored upon successful completion of this call.
 *		user_object (i)
 *			This is a pointer to the MCSUser object which should receive the callbacks
 *			for this user attachment.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			On success
 *		MCS_NO_SUCH_DOMAIN
 *			The domain to be attached to does not exist
 *		MCS_ALLOCATION_FAILURE
 *			A memory failure occured
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void	ProcessCallback (	UINT				message,
 *								ULong				parameter,
 *								PVoid				object_ptr)
 *
 *	Functional Description:
 *		This routine is called whenever a callback message is received by
 *		the "C" callback routine. It is responsible for both processing
 *		callback messages and forwarding callback messages on to the
 *		appropriate object.
 *
 *	Formal Parameters:
 *		message	(i)
 *			This is the mcs message to be processed
 *		parameter (i)
 *			Varies according to the message. See the MCAT programmers manual
 *		object_ptr (i)
 *			This is the user defined field that was passed to MCS on
 *			initialization.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	MCSDLLInterface::TranslateMCSIFErrorToGCCError ()
 *								MCSError			mcs_error)
 *
 *	Public
 *
 *	Function Description
 *		This routine translate an MCS Interface error into a GCC Error.
 *
 *	Formal Parameters:
 *		mcs_error (i)
 *			This is the error to be translated.
 *
 *	Return Value:
 *		This is the translated GCC error.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\memmgr.h ===
/*
 *	memmgr.h
 *
 *	Copyright (c) 1998 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the header file for the T.120 memory allocation mechanism.  This
 *		file contains the declarations necessary to allocate and distribute memory
 *		in the form of Memory objects within T.120.
 *
 *	This implementation defines priorities of memory allocations.  A lower
 *	priority number implies higher priority.  Priority-0 allocations will be
 *	satisfied, unless the system is out of memory.  Priorities 1 and 2
 *	limit the amount of total memory that can be allocated, but priority 1 (recv priority)
 *	has higher water mark limits than priority 2 (send priority).
 *
 *	Protected Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Christos Tsollis
 */

/*
 *	We define the following 3 memory priorities:
 *		TOP_PRIORITY  (0): 	The allocation will succeed unless the system is out of memory
 *		RECV_PRIORITY (1):	Allocation will succeed only if less than 1 MB has been allocated
 *		SEND_PRIORITY (2):	Allocation will succeed only if less than 0xE0000 bytes have been allocated so far.
 */
#ifndef _T120_MEMORY_MANAGER
#define _T120_MEMORY_MANAGER

#include "memory.h"

// This is the main T.120 allocation routine
PMemory	AllocateMemory (
				PUChar				reference_ptr,
				UINT				length,
				MemoryPriority		priority = HIGHEST_PRIORITY);
// Routine to ReAlloc memory allocated by AllocateMemory().
BOOL ReAllocateMemory (
				PMemory		*pmemory,
				UINT		length);
// Routine to free the memory allocated by AllocateMemory().
void FreeMemory (PMemory	memory);

// To discover how much space is available at a non-TOP priority...
unsigned int GetFreeMemory (MemoryPriority	priority);

// Macro to get to the Memory object from app-requested buffer space
#define GetMemoryObject(p)				((PMemory) ((PUChar) p - (sizeof(Memory) + MAXIMUM_PROTOCOL_OVERHEAD)))
// Macro to get to the Memory object from the coder-alloced buffer space
#define GetMemoryObjectFromEncData(p)	((PMemory) ((PUChar) p - sizeof(Memory)))

// Routines to lock/unlock (AddRef/Release) memory allocated by AllocateMemory()
#define  LockMemory(memory)  			((memory)->Lock())
#define	 UnlockMemory(memory)			(FreeMemory(memory))

// Routines to allocate, realloc and free space without an associated Memory object
#ifdef DEBUG
	PUChar	Allocate (UINT		length);
#else 
#	define Allocate(length)				((PUChar) new BYTE[length])
#endif // DEBUG
#define Free(p)							(delete [] (BYTE *) (p))

#endif // _T120_MEMORY_MANAGER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\mpdutype.h ===
/*
 *	mpdutype.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This file is used to convert from the ASN.1 generated types into types
 *		compliant with the DataBeam coding standard.
 *
 *	Author:
 *		
 *
 *	Caveats:
 *		none
 */

#ifndef	_MCS_PDU_TYPES_
#define	_MCS_PDU_TYPES_

#include "mcspdu.h"

/*
 *	PDU types
 */
#define CONNECT_MCS_PDU   					ConnectMCSPDU_PDU
#define DOMAIN_MCS_PDU    					DomainMCSPDU_PDU
#define DATA_MCS_PDU						(DOMAIN_MCS_PDU + CONNECT_MCS_PDU + 1)

/*
 * Segmentation bits.
 */
#define BEGIN								begin
#define END									end

/*
 *	Typedef for Octet Strings.
 */
typedef	struct	_octet1						OctetString;

/*
 *	PDUChannelAttributes and ChannelIDs
 */
#define CHANNEL_ATTRIBUTES_STATIC_CHOSEN	channel_attributes_static_chosen
#define CHANNEL_ATTRIBUTES_USER_ID_CHOSEN	channel_attributes_user_id_chosen
#define CHANNEL_ATTRIBUTES_PRIVATE_CHOSEN	channel_attributes_private_chosen
#define CHANNEL_ATTRIBUTES_ASSIGNED_CHOSEN	channel_attributes_assigned_chosen

/*
 *	PDUTokenAttributes and TokenIDs
 */
#define GRABBED_CHOSEN			grabbed_chosen
#define INHIBITED_CHOSEN		inhibited_chosen
#define GIVING_CHOSEN			giving_chosen
#define UNGIVABLE_CHOSEN		ungivable_chosen
#define GIVEN_CHOSEN			given_chosen

/*
 * Diagnostics
 */
#define DC_INCONSISTENT_MERGE			dc_inconsistent_merge
#define DC_FORBIDDEN_PDU_DOWNWARD		dc_forbidden_pdu_downward
#define DC_FORBIDDEN_PDU_UPWARD			dc_forbidden_pdu_upward
#define DC_INVALID_BER_ENCODING			dc_invalid_ber_encoding
#define DC_INVALID_PER_ENCODING			dc_invalid_per_encoding
#define DC_MISROUTED_USER				dc_misrouted_user
#define DC_UNREQUESTED_CONFIRM			dc_unrequested_confirm
#define DC_WRONG_TRANSPORT_PRIORITY		dc_wrong_transport_priority
#define DC_CHANNEL_ID_CONFLICT			dc_channel_id_conflict
#define DC_TOKEN_ID_CONFLICT			dc_token_id_conflict
#define DC_NOT_USER_ID_CHANNEL			dc_not_user_id_channel
#define DC_TOO_MANY_CHANNELS			dc_too_many_channels
#define DC_TOO_MANY_TOKENS				dc_too_many_tokens
#define DC_TOO_MANY_USERS				dc_too_many_users

/*
 * AttachUserConfirmPDU
 */
#define INITIATOR_PRESENT		initiator_present

/*
 * ChannelJoinConfirmPDU
 */
#define JOIN_CHANNEL_ID_PRESENT		join_channel_id_present

/*
 * ChannelConveneConfirmPDU
 */
#define CONVENE_CHANNEL_ID_PRESENT		convene_channel_id_present

/*
 * ConnectMCSPDU
 */
#define CONNECT_INITIAL_CHOSEN			connect_initial_chosen
#define CONNECT_RESPONSE_CHOSEN			connect_response_chosen
#define CONNECT_ADDITIONAL_CHOSEN		connect_additional_chosen
#define CONNECT_RESULT_CHOSEN			connect_result_chosen

/*
 * DomainMCSPDU
 */
#define PLUMB_DOMAIN_INDICATION_CHOSEN	plumb_domain_indication_chosen
#define ERECT_DOMAIN_REQUEST_CHOSEN		erect_domain_request_chosen
#define MERGE_CHANNELS_REQUEST_CHOSEN	merge_channels_request_chosen
#define MERGE_CHANNELS_CONFIRM_CHOSEN	merge_channels_confirm_chosen
#define PURGE_CHANNEL_INDICATION_CHOSEN	purge_channel_indication_chosen
#define MERGE_TOKENS_REQUEST_CHOSEN		merge_tokens_request_chosen
#define MERGE_TOKENS_CONFIRM_CHOSEN		merge_tokens_confirm_chosen
#define PURGE_TOKEN_INDICATION_CHOSEN	purge_token_indication_chosen
#define DISCONNECT_PROVIDER_ULTIMATUM_CHOSEN disconnect_provider_ultimatum_chosen
#define REJECT_ULTIMATUM_CHOSEN			reject_user_ultimatum_chosen
#define ATTACH_USER_REQUEST_CHOSEN		attach_user_request_chosen
#define ATTACH_USER_CONFIRM_CHOSEN		attach_user_confirm_chosen
#define DETACH_USER_REQUEST_CHOSEN		detach_user_request_chosen
#define DETACH_USER_INDICATION_CHOSEN	detach_user_indication_chosen
#define CHANNEL_JOIN_REQUEST_CHOSEN		channel_join_request_chosen
#define CHANNEL_JOIN_CONFIRM_CHOSEN		channel_join_confirm_chosen
#define CHANNEL_LEAVE_REQUEST_CHOSEN	channel_leave_request_chosen
#define CHANNEL_CONVENE_REQUEST_CHOSEN	channel_convene_request_chosen
#define CHANNEL_CONVENE_CONFIRM_CHOSEN	channel_convene_confirm_chosen
#define CHANNEL_DISBAND_REQUEST_CHOSEN	channel_disband_request_chosen
#define CHANNEL_DISBAND_INDICATION_CHOSEN channel_disband_indication_chosen
#define CHANNEL_ADMIT_REQUEST_CHOSEN	channel_admit_request_chosen
#define CHANNEL_ADMIT_INDICATION_CHOSEN	channel_admit_indication_chosen
#define CHANNEL_EXPEL_REQUEST_CHOSEN	channel_expel_request_chosen
#define CHANNEL_EXPEL_INDICATION_CHOSEN	channel_expel_indication_chosen
#define SEND_DATA_REQUEST_CHOSEN		send_data_request_chosen
#define SEND_DATA_INDICATION_CHOSEN		send_data_indication_chosen
#define UNIFORM_SEND_DATA_REQUEST_CHOSEN uniform_send_data_request_chosen
#define UNIFORM_SEND_DATA_INDICATION_CHOSEN	uniform_send_data_indication_chosen
#define TOKEN_GRAB_REQUEST_CHOSEN		token_grab_request_chosen
#define TOKEN_GRAB_CONFIRM_CHOSEN		token_grab_confirm_chosen
#define TOKEN_INHIBIT_REQUEST_CHOSEN	token_inhibit_request_chosen
#define TOKEN_INHIBIT_CONFIRM_CHOSEN	token_inhibit_confirm_chosen
#define TOKEN_GIVE_REQUEST_CHOSEN		token_give_request_chosen
#define TOKEN_GIVE_INDICATION_CHOSEN	token_give_indication_chosen
#define TOKEN_GIVE_RESPONSE_CHOSEN		token_give_response_chosen
#define TOKEN_GIVE_CONFIRM_CHOSEN		token_give_confirm_chosen
#define TOKEN_PLEASE_REQUEST_CHOSEN		token_please_request_chosen
#define TOKEN_PLEASE_INDICATION_CHOSEN	token_please_indication_chosen
#define TOKEN_RELEASE_REQUEST_CHOSEN	token_release_request_chosen
#define TOKEN_RELEASE_CONFIRM_CHOSEN	token_release_confirm_chosen
#define TOKEN_TEST_REQUEST_CHOSEN		token_test_request_chosen
#define TOKEN_TEST_CONFIRM_CHOSEN		token_test_confirm_chosen

/*
 * Pointer typedefs
 */
typedef ConnectInitialPDU * 				PConnectInitialPDU;
typedef ConnectResponsePDU * 				PConnectResponsePDU;
typedef ConnectAdditionalPDU * 				PConnectAdditionalPDU;
typedef ConnectResultPDU * 					PConnectResultPDU;
typedef PlumbDomainIndicationPDU * 			PPlumbDomainIndicationPDU;
typedef ErectDomainRequestPDU * 			PErectDomainRequestPDU;
typedef MergeChannelsRequestPDU *			PMergeChannelsRequestPDU;
typedef MergeChannelsConfirmPDU *			PMergeChannelsConfirmPDU;
typedef PurgeChannelIndicationPDU *			PPurgeChannelIndicationPDU;
typedef MergeTokensRequestPDU *				PMergeTokensRequestPDU;
typedef MergeTokensConfirmPDU *				PMergeTokensConfirmPDU;
typedef PurgeTokenIndicationPDU *			PPurgeTokenIndicationPDU;
typedef DisconnectProviderUltimatumPDU *	PDisconnectProviderUltimatumPDU;
typedef RejectUltimatumPDU *				PRejectUltimatumPDU;
typedef AttachUserRequestPDU *				PAttachUserRequestPDU;
typedef AttachUserConfirmPDU *				PAttachUserConfirmPDU;
typedef DetachUserRequestPDU *				PDetachUserRequestPDU;
typedef DetachUserIndicationPDU *			PDetachUserIndicationPDU;
typedef ChannelJoinRequestPDU *				PChannelJoinRequestPDU;
typedef ChannelJoinConfirmPDU *				PChannelJoinConfirmPDU;
typedef ChannelLeaveRequestPDU *			PChannelLeaveRequestPDU;
typedef ChannelConveneRequestPDU *			PChannelConveneRequestPDU;
typedef ChannelConveneConfirmPDU *			PChannelConveneConfirmPDU;
typedef ChannelDisbandRequestPDU *			PChannelDisbandRequestPDU;
typedef ChannelDisbandIndicationPDU *		PChannelDisbandIndicationPDU;
typedef ChannelAdmitRequestPDU *			PChannelAdmitRequestPDU;
typedef ChannelAdmitIndicationPDU *			PChannelAdmitIndicationPDU;
typedef ChannelExpelRequestPDU *			PChannelExpelRequestPDU;
typedef ChannelExpelIndicationPDU *			PChannelExpelIndicationPDU;
typedef SendDataRequestPDU *				PSendDataRequestPDU;
typedef SendDataIndicationPDU *				PSendDataIndicationPDU;
typedef UniformSendDataRequestPDU *			PUniformSendDataRequestPDU;
typedef UniformSendDataIndicationPDU *		PUniformSendDataIndicationPDU;
typedef TokenGrabRequestPDU *				PTokenGrabRequestPDU;
typedef TokenGrabConfirmPDU *				PTokenGrabConfirmPDU;
typedef TokenInhibitRequestPDU *			PTokenInhibitRequestPDU;
typedef TokenInhibitConfirmPDU *			PTokenInhibitConfirmPDU;
typedef TokenGiveRequestPDU *				PTokenGiveRequestPDU;
typedef TokenGiveIndicationPDU *			PTokenGiveIndicationPDU;
typedef TokenGiveResponsePDU *				PTokenGiveResponsePDU;
typedef TokenGiveConfirmPDU *				PTokenGiveConfirmPDU;
typedef TokenPleaseRequestPDU *				PTokenPleaseRequestPDU;
typedef TokenPleaseIndicationPDU *			PTokenPleaseIndicationPDU;
typedef TokenReleaseRequestPDU *			PTokenReleaseRequestPDU;
typedef TokenReleaseConfirmPDU *			PTokenReleaseConfirmPDU;
typedef TokenTestRequestPDU *				PTokenTestRequestPDU;
typedef TokenTestConfirmPDU *				PTokenTestConfirmPDU;

typedef ConnectMCSPDU 	*	PConnectMCSPDU;
typedef DomainMCSPDU 	*	PDomainMCSPDU;

/*
 *	Typedefs for other PDU structures.
 */
typedef PDUDomainParameters *				PPDUDomainParameters;
typedef	Diagnostic *						PDiagnostic;

typedef	struct	SetOfUserIDs				SetOfUserIDs;

typedef	struct	SetOfPDUChannelAttributes	SetOfPDUChannelAttributes;
typedef PDUChannelAttributes * 				PPDUChannelAttributes;

typedef struct	SetOfChannelIDs			    SetOfChannelIDs;

typedef struct	SetOfPDUTokenAttributes	    SetOfPDUTokenAttributes;
typedef PDUTokenAttributes * 				PPDUTokenAttributes;

typedef struct	SetOfTokenIDs				SetOfTokenIDs;

/*
 *	MAXIMUM_PROTOCOL_OVERHEAD
 *		This is used to calculate the maximum size of the user data field within
 *		a send data PDU.  This will be set to the maximum PDU size as set in
 *		the domain parameters, minus this number to allow for protocol overhead.
 *		This number MUST be large enough to handle the worst case overhead
 *		for ONLY the Packed Encoding Rules (PER).
 *		The max overhead consists of 2 parts: MAXIMUM_PROTOCOL_OVERHEAD_MCS
 *		is the max MCS overhead for a Send Data request while 
 *		PROTOCOL_OVERHEAD_X224 is the overhead imposed by X.224.
 *
 *	PROTOCOL_OVERHEAD_SECURITY
 *		This is the max overhead allowed for encryption/decryption of MCS data
 *		packets. That space should be enough for both the trailer and
 *		the header of an encrypted X.224 packet.
 */
#define PROTOCOL_OVERHEAD_SECURITY		64
#define	MAXIMUM_PROTOCOL_OVERHEAD_MCS	8
#define PROTOCOL_OVERHEAD_X224			sizeof(X224_DATA_PACKET)
#define	MAXIMUM_PROTOCOL_OVERHEAD		(MAXIMUM_PROTOCOL_OVERHEAD_MCS + PROTOCOL_OVERHEAD_X224)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\memory.h ===
/*
 *	memory.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Memory class.  Instances of this
 *		class are used to pass data around the system.
 *
 *		Each instance of this class maintains two pointers.  The first is a
 *		pointer to the reference data (or the source data) which this object
 *		is responsible for representing.  The second is a pointer to a copy
 *		buffer, which is a piece of allocated memory that a Memory object
 *		can copy the data into if necessary.
 *
 *		When a Memory object is created, both of these addresses are passed
 *		in to it.  It does not, however, copy the data from the reference
 *		buffer to the copy buffer just yet.  If anyone asks the address of the
 *		buffer, it will simply return the reference pointer.  However, the
 *		first time the buffer is locked, the data will be copied from the
 *		reference buffer to the copy buffer for safe keeping.  In essence,
 *		the lock function tells the Memory object that someone is interested
 *		in the data for longer than the reference buffer will remain valid.
 *
 *		After the object is locked, a call to retrieve a memory pointer will
 *		result in the copy pointer being returned.
 *
 *		Each time the lock function is called, a lock count is incremented.
 *		The copy operation only takes place the first time the buffer is
 *		locked, however.
 *
 *		In addition to maintaining a lock count, this object keeps a flag
 *		indicating whether or not it has been freed by the allocator.  This
 *		freeing really means that the object is enabled to be freed as soon
 *		as the lock count hits zero.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_MEMORY_
#define	_MEMORY_

#include "signatr.h"

#define MEMORY_PRIORITIES		3

typedef enum {
	HIGHEST_PRIORITY		= 0,
	RECV_PRIORITY			= 1,
	SEND_PRIORITY			= 2
} MemoryPriority;

/*
 *	This is the class definition for the Memory class.
 */
class Memory;
typedef	Memory *		PMemory;

class Memory
{	
	public:
						Memory (PUChar			reference_ptr,
								ULong			length,
								PUChar			copy_ptr);
						~Memory ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
						};
		Void			Init (PUChar			reference_ptr,
								ULong			length,
								MemoryPriority	priority,
								PUChar			copy_ptr);
		PUChar			GetPointer ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							return (Copy_Ptr);
						}
		ULong			GetLength ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							return (Length);
						}
		int				GetLockCount ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							return ((int) lLock);
						};
		MemoryPriority	GetMemoryPriority ()
						{
							return m_priority;
						};
		Void			Lock ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							InterlockedIncrement (& lLock);
							TRACE_OUT (("Memory::Lock: buffer at address %p. Lock count: %d",
										(UINT_PTR) Copy_Ptr, lLock));
							ASSERT (lLock > 0);
						};
		long			Unlock ()
						{
							ASSERT(SIGNATURE_MATCH(this, MemorySignature));
							ASSERT (lLock > 0);
							TRACE_OUT (("Memory::UnLock: buffer at address %p. Lock count: %d",
										(UINT_PTR) Copy_Ptr, lLock - 1));
							return (InterlockedDecrement (&lLock));
						}

	private:
		ULong			Length;
		PUChar			Copy_Ptr;
		long			lLock;
		MemoryPriority	m_priority;
/*
 *	NOTEs:
 *		1. The Memory class can not have virtual member functions, because
 *			of the Init() member.
 *		2. sizeof(Memory) should be DWORD-aligned, because of the
 *			AllocateMemory implementation.
 */

#ifndef SHIP_BUILD
	public:
		char			mSignature[SIGNATURE_LENGTH];
#endif // SHIP_BUILD
};


/*
 *	Memory (
 *			PUChar		reference_ptr,
 *			ULong		length,
 *			PUChar		copy_ptr)
 *
 *	Functional Description:
 *		This is the constructor for the Memory class.  All it does is
 *		initialize the instance variable with the passed in values.
 *
 *	Formal Parameters:
 *		reference_ptr (i)
 *			This is a pointer to the data that is to represented by this
 *			Memory object.
 *		length (i)
 *			This is the length of the reference buffer.
 *		copy_ptr (i)
 *			This is the address of an allocated buffer that the Memory object
 *			can use to preserve the contents of the reference buffer if a lock
 *			operation occurs.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Memory ()
 *
 *	Functional Description:
 *		This is the destructor for the Memory class.  It does nothing at this
 *		time.  Note that it is the responsibility of the memory manager that
 *		is using Memory objects to free up the memory.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	ULong		GetLength ()
 *
 *	Functional Description:
 *		This function retrieves the length of the data being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The length of the data.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	PUChar		GetPointer ()
 *
 *	Functional Description:
 *		This function retrieves the buffer being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The buffer pointer.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	int		GetLockCount ()
 *
 *	Functional Description:
 *		This function retrieves the lock counter for the buffer being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The buffer's current lock counter.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		Lock ()
 *
 *	Functional Description:
 *		This function locks the buffer being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	int		Unlock ()
 *
 *	Functional Description:
 *		This function unlocks the buffer being represented by
 *		this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The lock count after the unlock operation.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\mportmsg.h ===
/*
 *	mportmsg.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Portable:
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_LISTEN_MCS_PORTAL_MESSAGE_
#define	_LISTEN_MCS_PORTAL_MESSAGE_

#define	LISTEN_PORTAL_NAME				"MCS Listen Portal"
#define	USER_PORTAL_NAME				"MCS User Portal"

#define	LISTEN_CREATE_PORTAL_REQUEST	0
#define	LISTEN_CREATE_PORTAL_CONFIRM	1

#define	LISTEN_NO_ERROR					0
#define	LISTEN_CREATE_FAILED			1

#define	USER_PORTAL_NAME_LENGTH			32

/*
 *	The following type defines a container that is used to map domain selectors to
 *	portal memory addresses.  This is necessary to find the right in-process
 *	MCS portal for each domain.
 */
typedef struct
{
} LPCreatePortalRequest;

typedef struct
{
	ULong			return_value;
	unsigned int	portal_id;
} LPCreatePortalConfirm;

typedef struct
{
} LPClosePortalRequest;

typedef	struct
{
	unsigned int			message_type;
	union
	{
		LPCreatePortalRequest		create_portal_request;
		LPCreatePortalConfirm		create_portal_confirm;
	} u;
} ListenPortalMessage;
typedef	ListenPortalMessage *		PListenPortalMessage;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\ncmcs.h ===
/*
 *	ncmcs.h
 *
 *	Copyright (c) 1998 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This file defines macros, types, and functions needed to use the Node Controller MCS 
 *		interface.
 *
 *		Basically, the Node Controller (GCC) requests services from MCS by making direct
 *		calls into the DLL (this includes T.122 requests and responses).  MCS
 *		sends information back to the application through a callback (this
 *		includes T.122 indications and confirms).  The callback for the node
 *		controller is specified in the call MCSInitialize.
 *
 *	Author:
 *		Christos Tsollis
 */
#ifndef	_NCMCS_
#define	_NCMCS_

#include "mcspdu.h"

/*
 *	The following structure is used to identify various parameters that apply
 *	only within a given domain.  This information is negotiated between the
 *	first two providers in the domain, and must be accepted by any others
 *	providers that attempt to connect to that domain.
 *
 *	Note that MCS allows up to 4 priorities of data transfer, all of which are
 *	supported by this implementation.
 */
#define	MAXIMUM_PRIORITIES		4
typedef PDUDomainParameters		DomainParameters;
typedef	DomainParameters  *		PDomainParameters;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\mcsuser.h ===
/*
 *	mcsuser.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		An instance of this class represents a Conference object's user 
 *		attachment to MCS.  This is a fairly complex class that handles a lot of 
 *		conference establishment details such as creating a User attachment to 
 *		MCS and joining all the appropriate MCS channels.  After everything is 
 *		established the User object is responsible for encoding and decoding 
 *		certain PDUs as well as management of a data queue which can hold a 
 *		number of outgoing PDUs.  The MCSUser object is designed so that it 
 *		knows very little about any object other than the MCS Interface object 
 *		which it uses to send out PDUs.  This class only deals with data PDUs 
 *		(or GCC PDUs) as opposed to connect PDUs.  These GCC PDUs are sent and 
 *		received through channels joined by the GCC user attachment.
 *
 *		When an MCSUser object is first instantiated it goes through a number of 
 *		steps to establish its links to MCS.  First,  an MCSUser object 
 *		immediately creates an MCS user attachment in its constructor.  After 
 *		the MCS_ATTACH_USER_CONFIRM is received it begins joining all of the 
 *		appropriate channels.  The channels it joins varies depending on the 
 *		node type which is passed in through the MCSUser objects constructor.  
 *		After all channels have been successfully joined, the MCSUser object 
 *		issues an owner callback informing the Conference object that it is 
 *		completely initiated and ready to service requests.  
 *
 *		The MCSUser object can handle a number of different requests that can 
 *		result in PDU traffic being generated.  Therefore,  the user object has 
 *		the ability (within certain requests) to encode outgoing PDUs.  Many of 
 *		the more complex PDUs are handled by the class that contains the 
 *		information needed to build the PDU such as the ConferenceRoster and the 
 *		ApplicationRoster.  All PDU traffic received by an MCSUser object is 
 *		directly decoded by this class and immediately sent back to the owner 
 *		object (a Conference object) through an owner callback.
 *
 *		An MCSUser object has the ability to Terminate itself when an 
 *		unrecoverable resource error occurs.  This is handled through an owner 
 *		callback message informing the Owner Object to do the delete.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef _GCC_MCS_USER_
#define _GCC_MCS_USER_

/** include files **/
#include "mcsdllif.h"
#include "pktcoder.h"
#include "userdata.h"
#include "password.h"
#include "alarm.h"
#include "regkey.h"
#include "regitem.h"
#include "netaddr.h"
#include "invoklst.h"
#include "clists.h"


// was defined in gcmdtar.h
typedef UINT_PTR       TagNumber;


/*
 * Result types for attach user and channel joins performed by the user object
 */
typedef enum
{
	USER_RESULT_SUCCESSFUL,
	USER_ATTACH_FAILURE,
	USER_CHANNEL_JOIN_FAILURE
}UserResultType;


/*
 *	This enum defines all the possible types of nodes that can exists
 *	in a GCC conference.  Note that this is an internal definition and
 *	is not the save the the T.124 node type.
 */
typedef enum
{
	TOP_PROVIDER_NODE,
	CONVENER_NODE,		  
	TOP_PROVIDER_AND_CONVENER_NODE,
	JOINED_NODE,
	INVITED_NODE,
	JOINED_CONVENER_NODE
} ConferenceNodeType;


/*
**	The structures defined below are used to pack the data associated with
**	all the above owner callback messages.  A pointer to one of these
**	structures is passed in the LPVOID parameter of the owner callback.
*/

//	USER_CREATE_CONFIRM data structure
typedef struct
{
	UserID			user_id;
	UserResultType	create_result;
}
    UserCreateConfirmInfo, *PUserCreateConfirmInfo;

//	USER_CONFERENCE_JOIN_REQUEST data structure
typedef struct
{
	CPassword       *convener_password;
	CPassword       *password_challenge;		
	LPWSTR			pwszCallerID;
	CUserDataListContainer *user_data_list;
	UserID			sender_id;
}
    UserJoinRequestInfo, *PUserJoinRequestInfo;

//	USER_CONFERENCE_JOIN_RESPONSE data structure
typedef struct
{
	CPassword           *password_challenge;		
	CUserDataListContainer *user_data_list;
	ConnectionHandle	connection_handle;
	GCCResult			result;
}
    UserJoinResponseInfo, *PUserJoinResponseInfo;

//	USER_TIME_REMAINING_INDICATION data structure
typedef struct
{
	UserID		source_node_id;
	UserID		node_id;
	UINT		time_remaining;
}
    UserTimeRemainingInfo, *PUserTimeRemainingInfo;

//	USER_CONFERENCE_EXTEND_INDICATION data structure
typedef struct
{
	UINT			extension_time;
	BOOL    	time_is_conference_wide;
	UserID		source_node_id;
}
    UserTimeExtendInfo, *PUserTimeExtendInfo;

//	USER_TERMINATE_REQUEST data structure
typedef struct
{
	UserID		requester_id;
	GCCReason	reason;
}
    UserTerminateRequestInfo, *PUserTerminateRequestInfo;

//	USER_NODE_EJECTION_REQUEST data structure
typedef struct
{
	UserID		requester_id;
	UserID		node_to_eject;
	GCCReason	reason;
}
    UserEjectNodeRequestInfo, *PUserEjectNodeRequestInfo;

//	USER_NODE_EJECTION_RESPONSE data structure
typedef struct
{
	UserID		node_to_eject;
	GCCResult	result;
}
    UserEjectNodeResponseInfo, *PUserEjectNodeResponseInfo;

//	USER_REGISTRY_CHANNEL_REQUEST data structure
typedef struct
{
	CRegKeyContainer    *registry_key;
	ChannelID			channel_id;
	EntityID			requester_entity_id;
}
    UserRegistryChannelRequestInfo, *PUserRegistryChannelRequestInfo;

//	USER_REGISTRY_SET_PARAMETER_REQUEST data structure
typedef struct
{
	CRegKeyContainer        *registry_key;
	LPOSTR                  parameter_value;
	GCCModificationRights	modification_rights;
	EntityID				requester_entity_id;
}
    UserRegistrySetParameterRequestInfo, *PUserRegistrySetParameterRequestInfo;

/*
**	Data structure associated with the following: 
**
**	USER_REGISTRY_TOKEN_REQUEST,
**	USER_REGISTRY_RETRIEVE_REQUEST, 
**	USER_REGISTRY_DELETE_REQUEST,
**	USER_REGISTRY_MONITOR_REQUEST.
*/
typedef struct
{
	CRegKeyContainer    *registry_key;
	EntityID			requester_entity_id;
}
    UserRegistryRequestInfo, *PUserRegistryRequestInfo;

//	USER_REGISTRY_RESPONSE data structure
typedef struct
{
	RegistryResponsePrimitiveType	primitive_type;
	CRegKeyContainer                *registry_key;
	CRegItem                        *registry_item;
	GCCModificationRights			modification_rights;
	EntityID						owner_node_id;
	EntityID						owner_entity_id;
	EntityID						requester_entity_id;
	GCCResult						result;
}
    UserRegistryResponseInfo, *PUserRegistryResponseInfo;

//	USER_REGISTRY_MONITOR_INDICATION data structure
typedef struct
{
	CRegKeyContainer                *registry_key;
	CRegItem                        *registry_item;
	GCCModificationRights			modification_rights;
	EntityID						owner_node_id;
	EntityID						owner_entity_id;
}
    UserRegistryMonitorInfo, *PUserRegistryMonitorInfo;

/*
**	Data structure associated with the following:
**
**	USER_REGISTRY_ALLOCATE_HANDLE_REQUEST,
**	USER_REGISTRY_ALLOCATE_HANDLE_RESPONSE.
*/
typedef struct
{
	EntityID						requester_entity_id;
	USHORT							number_of_handles;
	UINT							first_handle;
	GCCResult						result;
}
    UserRegistryAllocateHandleInfo, *PUserRegistryAllocateHandleInfo;

//	USER_CONDUCTOR_PERMIT_GRANT_INDICATION data structure
typedef struct
{
	USHORT			number_granted;
	PUserID			granted_node_list;
	USHORT			number_waiting;
	PUserID			waiting_node_list;
}
    UserPermissionGrantIndicationInfo, *PUserPermissionGrantIndicationInfo;

//	USER_USER_ID_INDICATION data structure
typedef struct
{
	UserID			sender_id;
	TagNumber		tag;
}
    UserIDIndicationInfo, *PUserIDIndicationInfo;

//	USER_TIME_INQUIRE_INDICATION data structure
typedef struct
{
	UserID			sender_id;
	BOOL    		time_is_node_specific;
}
    TimeInquireIndicationInfo, *PTimeInquireIndicationInfo;

//	USER_CONDUCTOR_ASSIGN_INDICATION data structure
typedef struct
{
	UserID			sender_id;
	UserID			conductor_id;
}
    ConductorAssignIndicationInfo, *PConductorAssignIndicationInfo;

//	USER_CONDUCTOR_PERMIT_ASK_INDICATION data structure
typedef struct
{
	UserID			sender_id;
	BOOL    		permission_is_granted;
}
    PermitAskIndicationInfo, *PPermitAskIndicationInfo;

//	USER_DETACH_INDICATION data structure
typedef struct
{
	UserID			detached_user;
	GCCReason		reason;
}
    DetachIndicationInfo, *PDetachIndicationInfo;

/*
**	Data structure associated with the following:
**
**	USER_CONFERENCE_TRANSFER_REQUEST,
**	USER_CONFERENCE_TRANSFER_INDICATION,
**	USER_CONFERENCE_TRANSFER_RESPONSE.
*/
typedef struct
{
	GCCConferenceName		destination_conference_name;
	GCCNumericString		destination_conference_modifier;
	CNetAddrListContainer   *destination_address_list;
	USHORT					number_of_destination_nodes;
	PUserID					destination_node_list;
	CPassword               *password;
	UserID					requesting_node_id;
	GCCResult				result;
}
    TransferInfo, *PTransferInfo;

//	USER_CONFERENCE_ADD_REQUEST data structure
typedef struct
{
	CNetAddrListContainer   *network_address_list;
	CUserDataListContainer  *user_data_list;
	UserID					adding_node;
	TagNumber				add_request_tag;
	UserID					requesting_node;
}
    AddRequestInfo, *PAddRequestInfo;

//	USER_CONFERENCE_ADD_RESPONSE data structure
typedef struct
{
	CUserDataListContainer  *user_data_list;
	TagNumber				add_request_tag;
	GCCResult				result;
}
    AddResponseInfo, *PAddResponseInfo;

/******************** End of callback data structures *********************/


/*
 *	Structure to hold send data information (besides the actual data packet), 
 *	when the send data request is queued to be sent during the heartbeat.
 */
typedef struct
{
	ChannelID				channel_id;
	Priority				priority;
	BOOL    				uniform_send;

	PPacket                 packet;
}
    SEND_DATA_REQ_INFO;

/* 
 *	This structure holds information as to which channels the user object
 *	has joined at a particular instance of time. Also it indicates whether
 *	there has been an error in joining any of these channels or not.
 */
typedef struct
{
	BOOL    				convener_channel_joined;
	BOOL    				user_channel_joined;
	BOOL    				broadcast_channel_joined;
	BOOL    				channel_join_error;
}
    ChannelJoinedFlag, *PChannelJoinedFlag;

/* 
**	Queue of structures (SendDataMessages) to be flushed during a
**	heartbeat.
*/
class COutgoingPDUQueue : public CQueue
{
    DEFINE_CQUEUE(COutgoingPDUQueue, SEND_DATA_REQ_INFO*);
};

/*	
**	List to maintain sequence number in the response with sender's userid
**	to be able to route the response to the correct gcc provider.
*/
class CConfJoinResponseList2 : public CList2
{
    DEFINE_CLIST2_(CConfJoinResponseList2, TagNumber, UserID);
};

/*
**	List to hold the user ids of users in this provider's subtree
**	This list is used to match outstanding user IDs
*/
class CConnHandleUidList2 : public CList2
{
    DEFINE_CLIST2___(CConnHandleUidList2, USHORT)
};

/*
**	This list holds alarms used to disconnect any misbehaving nodes.  If an
**	alarm is placed in this list, the node has a specified amount of time to
**	disconnect before this node will disconnect it.
*/
class CAlarmUidList2 : public CList2
{
    DEFINE_CLIST2_(CAlarmUidList2, PAlarm, UserID)
};


//	The class definition.
class CConf;
class MCSUser : public CRefCount
{
    friend class MCSDLLInterface;

public:

    MCSUser(CConf *,
            GCCNodeID       nidTopProvider,
            GCCNodeID       nidParent,
            PGCCError);

    ~MCSUser(void);

    void		SendUserIDRequest(TagNumber);
	void		SetChildUserIDAndConnection(UserID, ConnectionHandle);

	/* 
	 * Called by conference of intermediate node to send join request
	 * over to the top provider.
	 */
	GCCError	ConferenceJoinRequest(
					CPassword               *convener_password,
					CPassword               *password_challange,
					LPWSTR					pwszCallerID,
					CUserDataListContainer  *user_data_list,
					ConnectionHandle		connection_handle);
			
	/*
	**	Called by conference of top provider to send the response
	**	back to the intermediate node.
	*/
	void		ConferenceJoinResponse(
					UserID					receiver_id,
					BOOL    				password_is_in_the_clear,
					BOOL    				conference_locked,
					BOOL    				conference_listed,
					GCCTerminationMethod	termination_method,
					CPassword               *password_challenge,
					CUserDataListContainer  *user_data_list,
					GCCResult				result);
					
	GCCError SendConferenceLockRequest(void);
	GCCError SendConferenceLockResponse(UserID uidSource, GCCResult);
	GCCError SendConferenceUnlockRequest(void);
	GCCError SendConferenceUnlockResponse(UserID uidSource, GCCResult);
	GCCError SendConferenceLockIndication(BOOL fUniformSend, UserID uidSource);
	GCCError SendConferenceUnlockIndication(BOOL fUniformSend, UserID uidSource);

	//	Calls related to conference termination
	void		ConferenceTerminateRequest(GCCReason);
	void		ConferenceTerminateResponse(UserID uidRequester, GCCResult);
	void		ConferenceTerminateIndication(GCCReason);

    GCCError	EjectNodeFromConference(UserID uidEjected, GCCReason);
	GCCError	SendEjectNodeResponse(UserID uidRequester, UserID uidEject, GCCResult);

	//	Roster related calls
	void		RosterUpdateIndication(PGCCPDU, BOOL send_update_upward);

    //	Registry related calls
	void		RegistryRegisterChannelRequest(CRegKeyContainer *, ChannelID, EntityID);
	void		RegistryAssignTokenRequest(CRegKeyContainer *, EntityID);
	void		RegistrySetParameterRequest(CRegKeyContainer *,
	                                        LPOSTR,
					                        GCCModificationRights,
					                        EntityID);
	void		RegistryRetrieveEntryRequest(CRegKeyContainer *, EntityID);
	void		RegistryDeleteEntryRequest(CRegKeyContainer *, EntityID);
	void		RegistryMonitorRequest(CRegKeyContainer *, EntityID);
   	void		RegistryAllocateHandleRequest(UINT, EntityID);
	void		RegistryAllocateHandleResponse(UINT cHandles, UINT registry_handle,
        					EntityID eidRequester, UserID uidRequester, GCCResult);

    void		RegistryResponse(
					RegistryResponsePrimitiveType	primitive_type,
					UserID  						requester_owner_id,
					EntityID						requester_entity_id,
					CRegKeyContainer	            *registry_key_data,
					CRegItem                        *registry_item_data,
					GCCModificationRights			modification_rights,
					UserID  						entry_owner_id,
					EntityID						entry_entity_id,
					GCCResult						result);

   	void		RegistryMonitorEntryIndication ( 	
					CRegKeyContainer	            *registry_key_data,
					CRegItem                        *registry_item,
					UserID  						entry_owner_id,
					EntityID						entry_entity_id,
					GCCModificationRights			modification_rights);

	GCCError 	AppInvokeIndication(CInvokeSpecifierListContainer *, GCCSimpleNodeList *);

	GCCError 	TextMessageIndication(LPWSTR pwszTextMsg, UserID uidDst);

	GCCError	ConferenceAssistanceIndication(UINT cElements, PGCCUserData *);

	GCCError	ConferenceTransferRequest (
					PGCCConferenceName		destination_conference_name,
					GCCNumericString		destination_conference_modifier,
					CNetAddrListContainer   *destination_address_list,
					UINT					number_of_destination_nodes,
					PUserID					destination_node_list,
					CPassword               *password);

	GCCError	ConferenceTransferIndication (
					PGCCConferenceName		destination_conference_name,
					GCCNumericString		destination_conference_modifier,
					CNetAddrListContainer   *destination_address_list,
					UINT					number_of_destination_nodes,
 					PUserID					destination_node_list,
					CPassword               *password);

	GCCError	ConferenceTransferResponse (
					UserID					requesting_node_id,
					PGCCConferenceName		destination_conference_name,
					GCCNumericString		destination_conference_modifier,
					UINT					number_of_destination_nodes,
 					PUserID					destination_node_list,
					GCCResult				result);
																		 
	GCCError	ConferenceAddRequest(
					TagNumber				conference_add_tag,
					UserID					requesting_node,
					UserID					adding_node,
					UserID					target_node,
					CNetAddrListContainer   *network_address_container,
					CUserDataListContainer  *user_data_container);
		
	GCCError	ConferenceAddResponse(
					TagNumber				add_request_tag,
					UserID					requesting_node,
					CUserDataListContainer  *user_data_container,
					GCCResult				result);
	

	//	Calls related to conductorship
 	GCCError	ConductorTokenGrab(void);
	GCCError	ConductorTokenRelease(void);
   	GCCError	ConductorTokenPlease(void);
	GCCError	ConductorTokenGive(UserID uidRecipient);
   	GCCError	ConductorTokenGiveResponse(Result);
	GCCError	ConductorTokenTest(void);
   	GCCError	SendConductorAssignIndication(UserID uidConductor);
   	GCCError	SendConductorReleaseIndication(void);
	GCCError	SendConductorPermitAsk(BOOL fGranted);

	GCCError	SendConductorPermitGrant(UINT cGranted, PUserID granted_node_list,
					                     UINT cWaiting, PUserID waiting_node_list);

    //	Miscelaneous calls
	GCCError	TimeRemainingRequest(UINT time_remaining, UserID);
	GCCError	TimeInquireRequest(BOOL time_is_conference_wide);	
	GCCError	ConferenceExtendIndication(UINT extension_time, BOOL time_is_conference_wide);
    void        CheckEjectedNodeAlarms(void);
	BOOL    	FlushOutgoingPDU(void);

	GCCNodeID	GetMyNodeID(void) {  return(m_nidMyself); }
	GCCNodeID	GetTopNodeID(void) { return(m_nidTopProvider); }
	GCCNodeID	GetParentNodeID(void) { return(m_nidParent); }

	UserID		GetUserIDFromConnection(ConnectionHandle);
	void		UserDisconnectIndication(UserID);

protected:

	UINT  				ProcessAttachUserConfirm(
							Result					result,
							UserID					user_id);

	UINT				ProcessChannelJoinConfirm(	
							Result					result,
							ChannelID				channel_id);

	UINT				ProcessDetachUserIndication(
							Reason					mcs_reason,
							UserID					detached_user);

	UINT				ProcessSendDataIndication(
							PSendData				send_data_info);

	UINT				ProcessUniformSendDataIndication(	
							PSendData				send_data_info);

	void				ProcessConferenceJoinRequestPDU(
							PConferenceJoinRequest	join_request,
							PSendData				send_data_info);

	void				ProcessConferenceJoinResponsePDU(
							PConferenceJoinResponse	join_response);

	void				ProcessConferenceTerminateRequestPDU(
							PConferenceTerminateRequest	terminate_request,
							PSendData					send_data_info);

	void				ProcessConferenceTerminateResponsePDU(
							PConferenceTerminateResponse
														terminate_response);

	void				ProcessConferenceTerminateIndicationPDU (
							PConferenceTerminateIndication	
													terminate_indication,
							UserID					sender_id);

#ifdef JASPER
	void				ProcessTimeRemainingIndicationPDU (
							PConferenceTimeRemainingIndication	
												time_remaining_indication,
							UserID					sender_id);
#endif // JASPER

#ifdef JASPER
	void				ProcessConferenceAssistanceIndicationPDU(
							PConferenceAssistanceIndication
												conf_assistance_indication,
							UserID					sender_id);
#endif // JASPER

#ifdef JASPER
	void  				ProcessConferenceExtendIndicationPDU(
							PConferenceTimeExtendIndication
												conf_time_extend_indication,
							UserID					sender_id);
#endif // JASPER

	void				ProcessConferenceEjectUserRequestPDU(
							PConferenceEjectUserRequest	
													eject_user_request,
							PSendData				send_data_info);

	void				ProcessConferenceEjectUserResponsePDU(
							PConferenceEjectUserResponse	
													eject_user_request);

	void				ProcessConferenceEjectUserIndicationPDU (
							PConferenceEjectUserIndication	
													eject_user_indication,
							UserID					sender_id);

	void				ProcessRegistryRequestPDU(	
							PGCCPDU					gcc_pdu,
							PSendData				send_data_info);

	void				ProcessRegistryAllocateHandleRequestPDU(
							PRegistryAllocateHandleRequest	
													allocate_handle_request,
							PSendData				send_data_info);

	void				ProcessRegistryAllocateHandleResponsePDU(
							PRegistryAllocateHandleResponse
                        						allocate_handle_response);

	void				ProcessRegistryResponsePDU(	
							PRegistryResponse			registry_response);

	void				ProcessRegistryMonitorIndicationPDU(
							PRegistryMonitorEntryIndication		
														monitor_indication,
							UserID						sender_id);

	void				ProcessTransferRequestPDU (
							PConferenceTransferRequest
											conference_transfer_request,
							PSendData		send_data_info);

#ifdef JASPER
	void				ProcessTransferIndicationPDU (
							PConferenceTransferIndication
											conference_transfer_indication);
#endif // JASPER

#ifdef JASPER
	void				ProcessTransferResponsePDU (
							PConferenceTransferResponse
											conference_transfer_response);
#endif // JASPER

	void				ProcessAddRequestPDU (
							PConferenceAddRequest	conference_add_request,
							PSendData				send_data_info);

	void				ProcessAddResponsePDU (
							PConferenceAddResponse	
												conference_add_response);

	void				ProcessPermissionGrantIndication(
							PConductorPermissionGrantIndication
												permission_grant_indication,
							UserID				sender_id);

	void				ProcessApplicationInvokeIndication(
							PApplicationInvokeIndication	
												invoke_indication,
							UserID				sender_id);

#ifdef JASPER
	GCCError			ProcessTextMessageIndication(
							PTextMessageIndication	text_message_indication,
							UserID					sender_id);
#endif // JASPER

	void				ProcessFunctionNotSupported (
							UINT					request_choice);

    void ProcessTokenGrabConfirm(TokenID, Result);
    void ProcessTokenGiveIndication(TokenID, UserID);
    void ProcessTokenGiveConfirm(TokenID, Result);

#ifdef JASPER
    void ProcessTokenPleaseIndication(TokenID, UserID);
#endif // JASPER

#ifdef JASPER
    void ProcessTokenReleaseConfirm(TokenID, Result);
#endif // JASPER

    void ProcessTokenTestConfirm(TokenID, TokenStatus);

private:

    void                AddToMCSMessageQueue(
                        	PPacket                 packet,
                        	ChannelID				channel_id,
                        	Priority				priority,
                        	BOOL    				uniform_send);

	GCCError			InitiateEjectionFromConference (
      						GCCReason				reason);

	MCSError			JoinUserAndBroadCastChannels();

	MCSError			JoinConvenerChannel();

	BOOL    			AreAllChannelsJoined();

    void ResourceFailureHandler(void);

private:

    CConf                           *m_pConf;

	PIMCSSap 						m_pMCSSap;
	GCCNodeID						m_nidMyself;
	GCCNodeID						m_nidTopProvider;
	GCCNodeID						m_nidParent;

	BOOL    						m_fEjectionPending;
	GCCReason						m_eEjectReason;

	ChannelJoinedFlag				m_ChannelJoinedFlags;
	CConnHandleUidList2             m_ChildUidConnHdlList2;
	COutgoingPDUQueue				m_OutgoingPDUQueue;                
	CConfJoinResponseList2          m_ConfJoinResponseList2;
	CAlarmUidList2                  m_EjectedNodeAlarmList2;
	CUidList    					m_EjectedNodeList;
};
typedef	MCSUser *		PMCSUser;

/*
 *	MCSUser(	UINT        		owner_message_base,
 *				GCCConferenceID		conference_id,
 *				ConferenceNodeType	conference_node_type,
 *				UserID				top_provider,
 *				UserID				parent_user_id,
 *				PGCCError			return_value)
 *
 *	Public Function Description
 *		This is the MCSUser object constructor.  It is responsible for
 *		initializing all the instance variables used by this class.  The
 *		constructor is responsible for establishing the user attachment to
 *		the MCS domain defined by the conference ID.  It also kicks off the
 *		process of joining all the appropriate channels.
 *
 *	Formal Parameters:
 *		conference_id		-	(i)	Conference ID associated with this user also
 *									defines the domain to attach to.	
 *		conference_node_type-	(i)	Internal Node type (see above enumeration).
 *		top_provider		-	(i)	User ID of top provider node. Zero if this
 *									is the top provider.	
 *		parent_user_id		-	(i)	User ID of parent node. Zero if this is the
 *									top provider node.	
 *		return_value		-	(o)	Return value for constructor.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_FAILURE_ATTACHING_TO_MCS	-	Failure to attach to MCS.
 *
 *  Side Effects
 *		The constructor kicks off a sequence of events that culminates in
 *		a USER_CREATE_CONFIRM message being returned to the owner object.
 *		This includes attaching to MCS and joining all the appropriate channels.
 *
 *	Caveats
 *		None.
 */

/*
 *	~MCSUser ()
 *
 *	Public Function Description
 *		This is the MCSUser object destructor.  It is responsible for freeing
 *		up all the internal data allocated by this object.  It also performs
 *		the detach from GCC and leaves all the appropriate channels.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	SendUserIDRequest(
 *						TagNumber			tag_number)
 *
 *	Public Function Description
 *		This routine maps directly to a GCC PDU that delivers the this
 *		nodes user ID to the appropriate node.  The tag number matches the
 *		tag specified by the other node.
 *
 *	Formal Parameters:
 *		tag_number	-	(i)	Tag number that matches the request to the
 *							reponse for the user ID.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_FAILURE_ATTACHING_TO_MCS	-	Failure to attach to MCS.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		SetChildUserIDAndConnection (
 *						UserID				child_user_id,
 *						ConnectionHandle	child_connection_handle)
 *
 *	Public Function Description
 *		This routine is used to set the child user id associated with a
 *		particular logical connection.  This information is saved by the
 *		MCSUser object in an internal list.  This is typical called after 
 *		receiving a user ID indication back from a child node.
 *
 *	Formal Parameters:
 *		child_user_id			-	(i)	User ID associated with child connection
 *		child_connection_handle	-	(i)	Logical connection assoicated with
 *										specified user id.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceJoinRequest(
 *					CPassword               *convener_password,
 *					CPassword               *password_challange,
 *					LPWSTR					pwszCallerID,
 *					CUserDataListContainer  *user_data_list,
 *					ConnectionHandle		connection_handle);
 *
 *	Public Function Description:
 *		This function is used to pass a join request on up to the Top Provider.
 *		It is called by a conference at an intermediate node.  This routine is
 *		not used if the joining node is directly connected to the top 
 *		provider.
 *
 *	Formal Parameters:
 *		convener_password	-	(i)	Convener password included with the
 *									original join request.
 *		password_challenge	-	(i)	Password challenge included with the
 *									original join request.
 *		pwszCallerID		-	(i)	Caller ID used in original join request.
 *		user_data_list		-	(i)	User data included in original join
 *									request.
 *		connection_handle	-	(i)	This is the logical connection handle
 *									on which the original join came in.  It is
 *									used here as a tag to match the request
 *									with the response.  
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		ConferenceJoinResponse(
 *						UserID					receiver_id,
 *						BOOL    				password_is_in_the_clear,
 *						BOOL    				conference_locked,
 *						BOOL    				conference_listed,
 *						GCCTerminationMethod	termination_method,
 *						CPassword               *password_challenge,
 *						CUserDataListContainer  *user_data_list,
 *						GCCResult				result);
 *
 *	Public Function Description:
 *		This routine is used to send a join response back to a node that is
 *		joining through an intermediate nodes.
 *
 *	Formal Parameters:
 *		receiver_id			-	(i)	This is the intermediate node id that made 
 *									the request to the top provider.
 *		password_is_in_the_clear(i)	Flag indicating password in the clear
 *									status of the conference.
 *		conference_locked	-	(i)	Lock state of the conference.
 *		conference_listed	-	(i)	Listed state of the conference.
 *		termination_method	-	(i)	Termination method of the conference.
 *		password_challenge	-	(i)	Password challenge to pass back to the
 *									joining node.
 *		user_data_list		-	(i)	User data to pass back to the joining node.
 *									request.
 *		result				-	(i)	The result of the join request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceLockRequest()
 *
 *	Public Function Description:
 *		This routine is used to issue a conference lock request to the
 *		top provider.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceLockResponse(
 *									UserID		source_node,
 *									GCCResult	result)
 *
 *	Public Function Description:
 *		This routine is used to issue the conference lock response back to the
 *		original requester.
 *
 *	Formal Parameters:
 *		source_node		-	(i)	Node ID of node that made the original request.
 *		result			-	(i)	Result of the lock request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceUnlockRequest()
 *
 *	Public Function Description:
 *		This routine is used to issue a conference unlock request to the
 *		top provider.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceUnlockResponse(
 *									UserID		source_node,
 *									GCCResult	result)
 *
 *	Public Function Description:
 *		This routine is used to issue the conference lock response back to the
 *		original requester.
 *
 *	Formal Parameters:
 *		source_node		-	(i)	Node ID of node that made the original request.
 *		result			-	(i)	Result of the lock request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceLockIndication(
 *									BOOL    	uniform_send,
 *									UserID		source_node)
 *
 *	Public Function Description:
 *		This routine is used by the Top Provider to issue a conference lock 
 *		indication to either everyone in the conference or to a specific node.
 *
 *	Formal Parameters:
 *		uniform_send		-	(i)	Flag indicating whether this indication 
 *									should be sent to everyone or to a
 *									specific node (TRUE for everyone).
 *		source_node			-	(i)	Specific node to send it to.  uniform_send
 *									must equal FALSE to use this.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError SendConferenceUnlockIndication(
 *									BOOL    	uniform_send,
 *									UserID		source_node)
 *
 *	Public Function Description:
 *		This routine is used by the Top Provider to issue a conference unlock 
 *		indication to either everyone in the conference or to a specific node.
 *
 *	Formal Parameters:
 *		uniform_send		-	(i)	Flag indicating whether this indication 
 *									should be sent to everyone or to a
 *									specific node (TRUE for everyone).
 *		source_node			-	(i)	Specific node to send it to.  uniform_send
 *									must equal FALSE to use this.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		ConferenceTerminateRequest(
 *						GCCReason				reason)
 *
 *	Public Function Description:
 *		This routine is used by a node subordinate to the top provider to 
 *		request that the conference by terminated.
 *
 *	Formal Parameters:
 *		reason		-	(i)	Reason for the terminate.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		ConferenceTerminateResponse (	
 *						UserID					requester_id,
 *						GCCResult				result)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to respond to a terminate
 *		request issued by a subordinate node.  The result indicates if the
 *		requesting node had the correct privileges.
 *
 *	Formal Parameters:
 *		requester_id	-	(i)	Node ID of node to send the response back to.
 *		result			-	(i)	Result of terminate request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		ConferenceTerminateIndication (
 *							GCCReason				reason)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send out a terminate 
 *		indication to every node in the conference.
 *
 *	Formal Parameters:
 *		reason		-	(i)	Reason for the terminate.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	EjectNodeFromConference (	
 *						UserID					ejected_node_id,
 *						GCCReason				reason)
 *
 *	Public Function Description:
 *		This routine is used when attempting to eject a node from the
 *		conference.
 *
 *	Formal Parameters:
 *		ejected_node_id	-	(i)	Node ID of node to eject.
 *		reason			-	(i)	Reason for node being ejected.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendEjectNodeResponse (	
 *						UserID					requester_id,
 *						UserID					node_to_eject,
 *						GCCResult				result)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to respond to an eject
 *		user request.
 *
 *	Formal Parameters:
 *		requester_id	-	(i)	Node ID of node that requested the eject.
 *		node_to_eject	-	(i)	Node that was requested to eject.
 *		result			-	(i)	Result of the eject request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RosterUpdateIndication (
 *						PGCCPDU					gcc_pdu,
 *						BOOL    				send_update_upward)
 *
 *	Public Function Description:
 *		This routine is used to forward a roster update indication either
 *		upward to the parent node or downward as a full refresh to all nodes
 *		in the conference.
 *
 *	Formal Parameters:
 *		gcc_pdu				-	(i)	Pointer to the roster update PDU structure 
 *									to send.
 *		send_update_upward	-	(i)	Flag indicating if this indication should
 *									be sent upward to the parent node or
 *									downward to all nodes (TRUE is upward).
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryRegisterChannelRequest (
 *						CRegKeyContainer        *registry_key_data,
 *						ChannelID				channel_id,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a channel in
 *		the application registry.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the channel
 *									to register.
 *		channel_id			-	(i)	Channel ID to add to the registry.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									registering the channel.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryAssignTokenRequest (
 *						CRegKeyContainer        *registry_key_data,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a token in
 *		the application registry.  Note that there is no token ID included in
 *		this request.  The token ID is allocated at the top provider.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the token
 *									to register.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									registering the token.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistrySetParameterRequest (
 *						CRegKeyContainer        *registry_key_data,
 *						LPOSTR      			parameter_value,
 *						GCCModificationRights	modification_rights,
 *						EntityID				entity_id);
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to register a parameter in
 *		the application registry.  Note that parameter to be registered is
 *		included in this request.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the parameter
 *									to register.
 *		parameter_value		-	(i)	The parameter string to register.
 *		modification_rights	-	(i)	The modification rights associated with the
 *									parameter being registered.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									registering the parameter.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryRetrieveEntryRequest (
 *						CRegKeyContainer        *registry_key_data,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to retrieve an registry item
 *		from the registry.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the registry
 *									entry to retrieve.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									requesting the registry entry.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryDeleteEntryRequest (
 *						CRegKeyContainer   	    *registry_key_data,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to delete a registry item
 *		from the registry.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the registry
 *									entry to delete.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									making the delete request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryMonitorRequest (	
 *						CRegKeyContainer        *registry_key_data,
 *						EntityID				entity_id)
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to monitor a registry item
 *		in the registry.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with the registry
 *									entry to monitor.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									making the monitor request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryAllocateHandleRequest ( 	
 *  						USHORT					number_of_handles, 
 *  						EntityID				entity_id )
 *
 *	Public Function Description:
 *		This routine is used when an APE wishes to allocate a number of
 *		handles from the application registry.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles to allocate.
 *		entity_id			-	(i)	Entity ID associated with the APE that is
 *									making the request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryAllocateHandleResponse (
 *						USHORT					number_of_handles,
 *						UINT					registry_handle,
 *						EntityID				requester_entity_id,
 *						UserID					requester_node_id,
 *						GCCResult				result)
 *
 *	Public Function Description:
 *		This routine is used by the Top Provider to respond to an allocate
 *		handle request from an APE at a remote node.  The allocated handles
 *		are passed back here.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles allocated.
 *		registry_handle		-	(i)	The first handle in the list of contiguously
 *									allocated handles.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE that made
 *									the request.
 *		requester_node_id	-	(i)	Node ID of node that made the request.
 *		result				-	(i)	Result of the request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryResponse (
 *						RegistryResponsePrimitiveType	primitive_type,
 *						UserID							requester_owner_id,
 *						EntityID						requester_entity_id,
 *						CRegKeyContainer	            *registry_key_data,
 *						CRegItem                        *registry_item_data,
 *						GCCModificationRights			modification_rights,
 *						UserID							entry_owner_id,
 *						EntityID						entry_entity_id,
 *						GCCResult						result)
 *
 *	Public Function Description:
 *		This routine is used to respond to all the registry request except
 *		allocate handle.  It formulates the response PDU and queues it for
 *		delivery.
 *
 *	Formal Parameters:
 *		primitive_type		-	(i)	This is the type of response being issued.
 *									(i.e. register channel response, register
 *									token response, etc.).
 *		requester_owner_id	-	(i)	Node ID of APE making the original request.
 *		requester_entity_id	-	(i)	Entity ID of APE making the original
 *									request.
 *		registry_key_data	-	(i)	Registry key associated with registry 
 *									entry info being included in the response.
 *		registry_item_data	-	(i)	Registry item data associated with registry 
 *									entry info being included in the response.
 *		modification_rights	-	(i)	Modification rights associated with registry 
 *									entry info being included in the response.
 *		entry_owner_id		-	(i)	Node ID associated with registry entry
 *									info being included in the response.
 *		entry_entity_id		-	(i)	APE Entity ID associated with registry entry
 *									info being included in the response.
 *		result				-	(i)	Result to be sent back in the response.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void	RegistryMonitorEntryIndication ( 	
 *						CRegKeyContainer                *registry_key_data,
 *						CRegItem                        *registry_item,
 *						UserID							entry_owner_id,
 *						EntityID						entry_entity_id,
 *						GCCModificationRights			modification_rights)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to issue a monitor
 *		indication anytime a registry entry that is being monitored changes.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry key associated with registry 
 *									entry being monitored.
 *		registry_item		-	(i)	Registry item data associated with registry 
 *									entry being monitored.
 *		entry_owner_id		-	(i)	Node ID associated with registry entry
 *									info being monitored.
 *		entry_entity_id		-	(i)	APE Entity ID associated with registry entry
 *									info being monitored.
 *		modification_rights	-	(i)	Modification rights associated with registry 
 *									entry info being monitored.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	AppInvokeIndication(
 *						CInvokeSpecifierListContainer *invoke_specifier_list,
 *						USHORT						number_of_destination_nodes,
 *						UserID			*			list_of_destination_nodes)
 *
 *	Public Function Description:
 *		This routine is used to send an application invoke indication to
 *		every node in the conference.
 *
 *	Formal Parameters:
 *		invoke_specifier_list		-	(i)	List of applications to invoke. 
 *		number_of_destination_nodes	-	(i)	Number of nodes in the destination
 *											node list.
 *		list_of_destination_nodes	-	(i)	List of nodes that should process
 *											invoke indication. 
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError 	TextMessageIndication (
 *						LPWSTR						pwszTextMsg,
 *						UserID						destination_node )
 *
 *	Public Function Description:
 *		This routine is used to send a text message to either a specific node
 *		or to every node in the conference.
 *
 *	Formal Parameters:
 *		pwszTextMsg			-	(i)	Text message string to send.
 *		destination_node	-	(i)	Node to receive the text message.  If zero
 *									the text message is sent to every node in 
 *									the conference.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceAssistanceIndication (
 *						USHORT						number_of_user_data_members,
 *						PGCCUserData		*		user_data_list)
 *
 *	Public Function Description:
 *		This routine is used to send a conference assistance indication to
 *		every node in the conference.
 *
 *	Formal Parameters:
 *		number_of_user_data_members	-	(i)	Number of entries in the user data
 *											list passed into this routine.
 *		user_data_list				-	(i)	This list holds pointers to the
 *											user data to send out in the
 *											indication.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceTransferRequest (
 *						PGCCConferenceName		destination_conference_name,
 *						GCCNumericString		destination_conference_modifier,
 *						CNetAddrListContainer   *destination_address_list,
 *						USHORT					number_of_destination_nodes,
 *						PUserID					destination_node_list,
 *						CPassword               *password);
 *
 *	Public Function Description:
 *		This routine is used to send a conference transfer request to the
 *		top provider in the conference.
 *
 *	Formal Parameters:
 *		destination_conference_name	-	(i)	The conference name to transfer to.
 *		destination_conference_modifier (i)	The conference modifier to 
 *											transfer to.
 *		destination_address_list	-	(i)	Network address list used to
 *											determine address of node to 
 *											transfer to.
 *		number_of_destination_nodes	-	(i)	Number of nodes in the list
 *											of nodes that should transfer.
 *		destination_node_list		-	(i)	List of node IDs that should perform
 *											the transfer.
 *		password					-	(i)	Password to use to join the
 *											new conference.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceTransferIndication (
 *						PGCCConferenceName		destination_conference_name,
 *						GCCNumericString		destination_conference_modifier,
 *						CNetAddrListContainer   *destination_address_list,
 *						USHORT					number_of_destination_nodes,
 *						PUserID					destination_node_list,
 *						CPassword               *password)
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send out the transfer
 *		indication to every node in the conference.  It is each nodes
 *		responsiblity to search the destination node list to see if
 *		it should transfer.
 *
 *	Formal Parameters:
 *		destination_conference_name	-	(i)	The conference name to transfer to.
 *		destination_conference_modifier (i)	The conference modifier to 
 *											transfer to.
 *		destination_address_list	-	(i)	Network address list used to
 *											determine address of node to 
 *											transfer to.
 *		number_of_destination_nodes	-	(i)	Number of nodes in the list
 *											of nodes that should transfer.
 *		destination_node_list		-	(i)	List of node IDs that should perform
 *											the transfer.
 *		password					-	(i)	Password to use to join the
 *											new conference.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceTransferResponse (
 *						UserID					requesting_node_id,
 *						PGCCConferenceName		destination_conference_name,
 *						GCCNumericString		destination_conference_modifier,
 *						USHORT					number_of_destination_nodes,
 *						PUserID					destination_node_list,
 *						GCCResult				result)
 *																		     
 *
 *	Public Function Description:
 *		This routine is used by the top provider to send back a response to
 *		the node that made a transfer request.  The info specified in the
 *		request is included in the response to match request to response.
 *
 *	Formal Parameters:
 *		requesting_node_id			-	(i)	The node ID of the node that made
 *											the original transfer request.
 *		destination_conference_name	-	(i)	The conference name to transfer to.
 *		destination_conference_modifier (i)	The conference modifier to 
 *											transfer to.
 *		number_of_destination_nodes	-	(i)	Number of nodes in the list
 *											of nodes that should transfer.
 *		destination_node_list		-	(i)	List of node IDs that should perform
 *											the transfer.
 *		result						-	(i)	Result of the transfer request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceAddRequest(
 *						TagNumber				conference_add_tag,
 *						UserID					requesting_node,
 *						UserID					adding_node,
 *						UserID					target_node,
 *						CNetAddrListContainer   *network_address_container,
 *						CUserDataListContainer  *user_data_container)
 *																		     
 *
 *	Public Function Description:
 *		This routine is used to send a conference add request to the appropriate
 *		node.  This call can be made by the requesting node or by the top
 *		provider to pass the add request on to the adding node.
 *
 *	Formal Parameters:
 *		conference_add_tag			-	(i)	Tag that is returned in the
 *											response to match request and
 *											response.
 *		requesting_node				-	(i)	Node ID of node that made the
 *											original request.
 *		adding_node					-	(i)	Node ID of node that is to do
 *											the invite request to the new node.
 *		target_node					-	(i)	Node ID of node that this request
 *											should be sent to.
 *		network_address_container	-	(i)	Network address list that can be
 *											used when inviting the new node.
 *		user_data_container			-	(i)	User data to pass on to the
 *											adding node.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceAddResponse(
 *						TagNumber				add_request_tag,
 *						UserID					requesting_node,
 *						CUserDataListContainer  *user_data_container,
 *						GCCResult				result)
 *																		     
 *	Public Function Description:
 *		This routine is used to send a conference add request to the appropriate
 *		node.  This call can be made by the requesting node or by the top
 *		provider to pass the add request on to the adding node.
 *
 *	Formal Parameters:
 *		add_request_tag		-	(i)	Tag number that was specified in the
 *									original add request.
 *		requesting_node		-	(i)	Node ID of node that made the original 
 *									request.
 *		user_data_container	-	(i)	User data to pass back to the requesting 
 *									node.
 *		result				-	(i)	Final result of the add request.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenGrab();
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to grab the conductor token.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenRelease();
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to release the conductor token.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenPlease();
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to request the conductor token from
 *		the current conductor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenGive (
 *						UserID					recipient_user_id)
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to give the conductor token to the
 *		specified node.
 *
 *	Formal Parameters:
 *		recipient_user_id	-	(i)	Node ID of node to give the token to.
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenGiveResponse(
 *  						Result					result)
 *																		     
 *	Public Function Description:
 *		This routine makes the MCS calls to respond to a conductor give
 *		request.
 *
 *	Formal Parameters:
 *		result	-	(i)	Did this node accept the token or not?
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConductorTokenTest()
 *																		     
 *	Public Function Description:
 *		This routine is used to test the current state of the conductor token
 *		(is it grabbed or not).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR	-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendConductorAssignIndication(
 *  						UserID					conductor_user_id)
 *																		     
 *	Public Function Description:
 *		This routine sends a conductor assign indication to all the
 *		nodes in the conference.
 *
 *	Formal Parameters:
 *		conductor_user_id	-	(i)	The Node ID of the new Conductor.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendConductorReleaseIndication()
 *																		     
 *	Public Function Description:
 *		This routine sends a conductor release indication to all the
 *		nodes in the conference.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendConductorPermitAsk (
 *						BOOL    				grant_permission)
 *																		     
 *	Public Function Description:
 *		This routine sends a conductor permission ask request directly to the
 *		conductor node.
 *
 *	Formal Parameters:
 *		grant_permission	-	(i)	The flag indicates if permission is
 *									being requested or given up.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	SendConductorPermitGrant (
 *						USHORT					number_granted,
 *						PUserID					granted_node_list,
 *						USHORT					number_waiting,
 *						PUserID					waiting_node_list)
 *																		     
 *	Public Function Description:
 *		This routine sends a conductor permission grant indication to every
 *		node in the conference.  Usually issued when permissions change.
 *
 *	Formal Parameters:
 *		number_granted		-	(i)	Number of nodes in the permission granted 
 *									list.
 *		granted_node_list	-	(i)	List of nodes that have been granted 
 *									permission.
 *		number_waiting		-	(i)	Number of nodes in the list of nodes
 *									waiting to be granted permission.
 *		waiting_node_list	-	(i)	List of nodes waiting. 
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	TimeRemainingRequest (
 *						UINT					time_remaining,
 *						UserID					node_id)
 *																		     
 *	Public Function Description:
 *		This routine sends out an indication to every node in the
 *		conference informing how much time is remaining in the conference.
 *
 *	Formal Parameters:
 *		time_remaining	-	(i)	Time in seconds left in the conference.
 *		node_id			-	(i)	If a value other than zero, it is which node
 *								to send the time remaining indication to.  If
 *								zero send it to every node in the conference.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	TimeInquireRequest (
 *						BOOL    				time_is_conference_wide)
 *																		     
 *	Public Function Description:
 *		This routine sends out a request for a time remaing update.
 *
 *	Formal Parameters:
 *		time_is_conference_wide	-	(i)	Flag indicating if the request is
 *										for the time conference wide.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCError	ConferenceExtendIndication (
 *						UINT					extension_time,
 *						BOOL    				time_is_conference_wide)
 *
 *																		     
 *	Public Function Description:
 *		This routine sends out an indication informing conference participants
 *		of an extension.
 *
 *	Formal Parameters:
 *		extension_time			-	(i)	Amount of time that the conference is
 *										extended.
 *		time_is_conference_wide	-	(i)	Flag indicating if the extension time 
 *										is conference wide.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	ULONG		OwnerCallback (		UINT				message,
 *									PVoid				parameter1,
 *									ULONG				parameter2);
 *
 *	Public Function Description
 *		This function overides the base class function and is used to
 *		receive all owner callback information from the MCS Interface object.
 *
 *	Formal Parameters:
 *		message		-		(i)	Message number including base offset.
 *		parameter1	-		(i)	void pointer of message data.
 *		parameter2	-		(i)	Long holding message data.		
 *
 *	Return Value
 *		GCC_NO_ERROR is always returned from this.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	BOOL    		FlushOutgoingPDU();
 *
 *	Public Function Description
 *		This function gives the user object a chance to flush all the PDUs
 *		queued up for delivery.  GCC PDUs are only delivered during this call.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		TRUE, if there remain un-processed msgs in the MCS message queue
 *		FALSE, if all the msgs in the MCS msg queue were processed.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCNodeID		GetMyNodeID()
 *
 *	Public Function Description
 *		This function returns the Node ID for this node.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		This nodes Node ID.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCNodeID		GetTopNodeID ()
 *
 *	Public Function Description
 *		This function returns the Top Provider's Node ID.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		The Top Providers node ID.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	GCCNodeID		GetParentNodeID ()
 *
 *	Public Function Description
 *		This function returns the Node ID of this nodes Parent Node.
 *		It returns zero if this is the top provider.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		The Parent Node ID or zero if Top Provider.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	UserID		GetUserIDFromConnection(
 *						ConnectionHandle		connection_handle)
 *
 *	Public Function Description
 *		This function returns the Node ID associated with the specified
 *		connection handle.  It returns zero if the connection handle is
 *		not a child connection of this node.
 *
 *	Formal Parameters:
 *		connection_handle	-	(i)	Connection Handle to search on.
 *
 *	Return Value
 *		The Node ID associated with the passed in connection handle or
 *		ZERO if connection is not a child connection.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

/*
 *	void		UserDisconnectIndication (
 *						UserID					disconnected_user)
 *
 *	Public Function Description
 *		This function informs the user object when a Node disconnects from
 *		the conference.  This gives the user object a chance to clean up
 *		its internal information base.
 *
 *	Formal Parameters:
 *		disconnected_user	-	(i)	User ID of user that disconnected.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */

#endif // _MCS_USER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\ms_util.h ===
#ifndef __MS_UTIL_H__
#define __MS_UTIL_H__

extern "C"
{
#include "t120.h"
}

//
// GUI message boxes kill us when we hit an assert or error, because they
// have a message pump that causes messages to get dispatched, making it
// very difficult for us to debug problems when they occur.  Therefore
// we redefine ERROR_OUT and ASSERT
//
#ifdef _DEBUG

__inline void MyDebugBreak(void) { DebugBreak(); }

#endif // _DEBUG




/*
 * Macro used to force values to four byte boundaries.  This macro will need to
 * be considered when portability issues arise.
 */
#define ROUNDTOBOUNDARY(num)	(((UINT)(num) + 0x03) & 0xfffffffcL)


// the following create a dword that will look like "abcd" in debugger
#ifdef SHIP_BUILD
#define MAKE_STAMP_ID(a,b,c,d)     
#else
#define MAKE_STAMP_ID(a,b,c,d)     MAKELONG(MAKEWORD(a,b),MAKEWORD(c,d))
#endif // SHIP_BUILD

class CRefCount
{
public:

#ifdef SHIP_BUILD
    CRefCount(void);
#else
    CRefCount(DWORD dwStampID);
#endif
    virtual ~CRefCount(void) = 0;

    LONG AddRef(void);
    LONG Release(void);

    void ReleaseNow(void);

protected:

    LONG GetRefCount(void) { return m_cRefs; }
    BOOL IsRefCountZero(void) { return (0 == m_cRefs); }

    LONG Lock(void);
    LONG Unlock(BOOL fRelease = TRUE);

    LONG GetLockCount(void) { return m_cLocks; }
    BOOL IsLocked(void) { return (0 == m_cLocks); }

private:

#ifndef SHIP_BUILD
    DWORD       m_dwStampID;// to remove before we ship it
#endif
    LONG        m_cRefs;    // reference count
    LONG        m_cLocks;   // lock count of the essential contents
};


extern HINSTANCE g_hDllInst;

__inline void My_CloseHandle(HANDLE hdl)
{
    if (NULL != hdl)
    {
        CloseHandle(hdl);
    }
}


#if defined(_DEBUG)
LPSTR _My_strdupA(LPCSTR pszSrc, LPSTR pszFileName, UINT nLineNumber);
LPWSTR _My_strdupW(LPCWSTR pszSrc, LPSTR pszFileName, UINT nLineNumber);
LPWSTR _My_strdupW2(UINT cchSrc, LPCWSTR pszSrc, LPSTR pszFileName, UINT nLineNumber);
LPOSTR _My_strdupO2(LPBYTE lpbSrc, UINT cOctets, LPSTR pszFileName, UINT nLineNumber);

#define My_strdupA(pszSrc) _My_strdupA(pszSrc, __FILE__, __LINE__)
#define My_strdupW(pszSrc) _My_strdupW(pszSrc, __FILE__, __LINE__)
#define My_strdupW2(cchSrc,pszSrc) _My_strdupW2(cchSrc, pszSrc, __FILE__, __LINE__)
#define My_strdupO2(lpbSrc,cOctets) _My_strdupO2(lpbSrc, cOctets, __FILE__, __LINE__)
#define My_strdupO(poszSrc) _My_strdupO2(poszSrc->value, poszSrc->length, __FILE__, __LINE__)
#else
LPSTR My_strdupA(LPCSTR pszSrc);
LPWSTR My_strdupW(LPCWSTR pszSrc);
LPWSTR My_strdupW2(UINT cchSrc, LPCWSTR pszSrc); // backward compatible to UnicodeString
LPOSTR My_strdupO2(LPBYTE lpbSrc, UINT cOctets);
__inline LPOSTR My_strdupO(LPOSTR poszSrc) { return My_strdupO2(poszSrc->value, poszSrc->length); }
#endif

UINT My_strlenA(LPCSTR pszSrc);
UINT My_strlenW(LPCWSTR pszSrc);
int My_strcmpW(LPCWSTR pwsz1, LPCWSTR pwsz2);

#ifdef _UNICODE
#define My_strdup			My_strdupW
#define My_strlen			My_strlenW
#define My_strcmp			My_strcmpW
#else
#define My_strdup			My_strdupA
#define My_strlen			My_strlenA
#define My_strcmp			lstrcmpA
#endif

INT My_strcmpO(LPOSTR posz1, LPOSTR posz2);



#endif // __MS_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\netaddr.h ===
/*
 *	netaddr.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Network Address List class.  This  
 *		class manages the data associated with a network address.  Network
 *		addresses can be one of three types: aggregated channel, transport
 *		connection, or non-standard.  A variety of structures, objects, and
 *		Rogue Wave containers are used to buffer the network address data
 *		internally.
 *
 *	Caveats:
 *		A network address may contain an Object Key if it is a non-standard
 *		type.  When created locally with "API" data, checks are made to ensure
 *		that the constraints imposed upon Object Keys are not violated.  Checks
 *		are also performed to validate certain types of strings which may exist
 *		in a network address.  If however, a network address is created from 
 *		"PDU" data received from a remote site no such validation is performed.
 *		We are taking no responsibility for validation of data originated by
 *		other GCC providers.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_NETWORK_ADDRESS_
#define	_NETWORK_ADDRESS_

#include "objkey.h"

/*
 * This structure holds network address information and data.
 */
typedef struct NET_ADDR
{
    NET_ADDR(void);
    ~NET_ADDR(void);

    GCCNetworkAddress	        network_address;
  
	// Variables associated with aggregated channels.
	LPSTR						pszSubAddress;
	LPWSTR						pwszExtraDialing;
    PGCCHighLayerCompatibility	high_layer_compatibility;

    // Variables associated with transport connection addresses.
	LPOSTR						poszTransportSelector;

    // Variables associated with non-standard network addresses.
	LPOSTR						poszNonStandardParam;
	CObjectKeyContainer 	    *object_key;
}
    NET_ADDR;


/*
 * This list is holds the network address information structures.
 */
class CNetAddrList : public CList
{
    DEFINE_CLIST(CNetAddrList, NET_ADDR*)
};


/*
 * Class definition:
 */
class CNetAddrListContainer : public CRefCount
{
public:

	CNetAddrListContainer(UINT cAddrs, PGCCNetworkAddress *, PGCCError);
	CNetAddrListContainer(PSetOfNetworkAddresses, PGCCError);
	CNetAddrListContainer(CNetAddrListContainer *, PGCCError);

    ~CNetAddrListContainer(void);

	UINT		LockNetworkAddressList(void);
	void		UnLockNetworkAddressList(void);

	UINT		GetNetworkAddressListAPI(UINT *pcAddrs, PGCCNetworkAddress **, LPBYTE pMemory);
	GCCError	GetNetworkAddressListPDU(PSetOfNetworkAddresses *);
	GCCError	FreeNetworkAddressListPDU(void);

protected:

	CNetAddrList    		    m_NetAddrItemList;
	UINT						m_cbDataSize;

    PSetOfNetworkAddresses		m_pSetOfNetAddrPDU;
	BOOL						m_fValidNetAddrPDU;

private:

	GCCError	StoreNetworkAddressList(UINT cAddrs, PGCCNetworkAddress *);
	GCCError	ConvertPDUDataToInternal(PSetOfNetworkAddresses);
	GCCError	ConvertNetworkAddressInfoToPDU(NET_ADDR *, PSetOfNetworkAddresses);
    void		ConvertTransferModesToInternal(PTransferModes pSrc, PGCCTransferModes pDst);
	void		ConvertHighLayerCompatibilityToInternal(PHighLayerCompatibility pSrc, PGCCHighLayerCompatibility pDst);
	void		ConvertTransferModesToPDU(PGCCTransferModes pSrc, PTransferModes pDst);
	void		ConvertHighLayerCompatibilityToPDU(PGCCHighLayerCompatibility pSrc,	PHighLayerCompatibility	pDst);

    BOOL		IsDialingStringValid(GCCDialingString);
	BOOL		IsCharacterStringValid(GCCCharacterString);
	BOOL		IsExtraDialingStringValid(PGCCExtraDialingString);
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CNetAddrListContainer (
 *		UINT       			number_of_network_addresses,
 *		PGCCNetworkAddress 	*	network_address_list,
 *		PGCCError				return_value);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This is the constructor for the CNetAddrListContainer class which takes as
 *		input the "API" version of network address data, GCCNetworkAddress.
 *
 *	Formal Parameters:
 *		number_of_network_addresses	(i) The number of addresses in the list.
 *		network_address_list		(i)	The network address data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_NETWORK_ADDRESS			-	Invalid network address passed in.
 *		GCC_BAD_NETWORK_ADDRESS_TYPE	-	Bad "choice" field for address
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CNetAddrListContainer (		
 *			PSetOfNetworkAddresses		network_address_list,
 *			PGCCError					return_value);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This is the constructor for the CNetAddrListContainer class which takes as
 *		input the "PDU" version of network address data, SetOfNetworkAddresses.
 *
 *	Formal Parameters:
 *		network_address_list	(i)	The network address data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CNetAddrListContainer (		
 *				CNetAddrListContainer		*network_address_list,
 *				PGCCError		return_value);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CNetAddrListContainer class which
 *		takes as input another CNetAddrListContainer object.
 *
 *	Formal Parameters:
 *		network_address_list	(i)	The CNetAddrListContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CNetAddrListContainer ();
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This is the destructor for the CNetAddrListContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT	LockNetworkAddressList ();
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the list of GCCNetworkAddress 
 *		structures which is filled in on a call to GetNetworkAddressListAPI.  
 *		This is the	value returned by this routine in order to allow the calling
 *		object to allocate that amount of memory in preparation for the call to 
 *		GetNetworkAddressListAPI.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the list of GCCNetworkAddress
 *		structures provided as an output parameter to the 
 *		GetNetworkAddressListAPI call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeNetworkAddressList. This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CNetAddrListContainer
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeNetworkAddressList call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CNetAddrListContainer object will automatically delete itself when
 *		the FreeNetworkAddressList call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */

/*
 *	UINT			GetNetworkAddressListAPI (	
 *							UINT *			number_of_network_addresses,
 *							PGCCNetworkAddress	**	network_address_list,
 *							LPSTR					memory);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the network address data from the
 *		CNetAddrListContainer object in the "API" form of a list of 
 *		GCCNetworkAddress structures.
 *
 *	Formal Parameters:
 *		number_of_network_addresses	(o) Number of addresses in returned list.
 *		network_address_list		(o)	The pointer to the list of
 *											GCCNetworkAddress structures 
 *											to fill in.
 *		memory						(o)	The memory used to hold any data 
 *											referenced by, but not held in, the 
 *											list of output structures.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		UnLockNetworkAddressList ();
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeNetworkAddressList.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CNetAddrListContainer
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CNetAddrListContainer 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	GCCError		GetNetworkAddressListPDU (	
 *						PSetOfNetworkAddresses	*	set_of_network_addresses);
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the network address data from the
 *		CNetAddrListContainer object in the "PDU" form of a SetOfNetworkAddresses.
 *
 *	Formal Parameters:
 *		set_of_network_addresses	(o)	The address structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError		FreeNetworkAddressListPDU ();
 *
 *	Public member function of CNetAddrListContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a SetOfNetworkAddresses structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeNetworkAddressListPDU has been made.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\omcscode.h ===
/*
 *	omcscode.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the CMCSCoder class.  This
 *		class is used to encode and decode MCS Protocol Data Units (PDU's)
 *		to and from ASN.1 compliant byte streams using the ASN.1 toolkit.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 *
 */
#ifndef	_CMCSCODER_
#define	_CMCSCODER_

#include "pktcoder.h"
#include "mcspdu.h"

/*
 * Macros
 */
#define		PLUMB_DOMAIN_INDICATION	 		0x60
#define		ERECT_DOMAIN_REQUEST		 	0x61
#define		MERGE_CHANNELS_REQUEST	 		0x62
#define		MERGE_CHANNELS_CONFIRM		 	0x63
#define		PURGE_CHANNEL_INDICATION		0x64
#define		MERGE_TOKENS_REQUEST	 		0x65
#define		MERGE_TOKENS_CONFIRM		 	0x66
#define		PURGE_TOKEN_INDICATION		 	0x67
#define		DISCONNECT_PROVIDER_ULTIMATUM	0x68
#define		REJECT_ULTIMATUM			 	0x69
#define		ATTACH_USER_REQUEST		 		0x6a
#define		ATTACH_USER_CONFIRM		 		0x6b
#define		DETACH_USER_REQUEST		 		0x6c
#define		DETACH_USER_INDICATION		 	0x6d
#define		CHANNEL_JOIN_REQUEST		 	0x6e
#define		CHANNEL_JOIN_CONFIRM		 	0x6f
#define		CHANNEL_LEAVE_REQUEST		 	0x70
#define		CHANNEL_CONVENE_REQUEST		 	0x71
#define		CHANNEL_CONVENE_CONFIRM		 	0x72
#define		CHANNEL_DISBAND_REQUEST		 	0x73
#define		CHANNEL_DISBAND_INDICATION		0x74
#define		CHANNEL_ADMIT_REQUEST		 	0x75
#define		CHANNEL_ADMIT_INDICATION		0x76
#define		CHANNEL_EXPEL_REQUEST		 	0x77
#define		CHANNEL_EXPEL_INDICATION		0x78
#define		SEND_DATA_REQUEST		 		0x79
#define		SEND_DATA_INDICATION		 	0x7a
#define		UNIFORM_SEND_DATA_REQUEST		0x7b
#define		UNIFORM_SEND_DATA_INDICATION	0x7c
#define		TOKEN_GRAB_REQUEST		 		0x7d
#define		TOKEN_GRAB_CONFIRM		 		0x7e
#define		MULTIPLE_OCTET_ID	 			0x7f
#define		TOKEN_INHIBIT_REQUEST			0x1f
#define		TOKEN_INHIBIT_CONFIRM			0x20
#define		TOKEN_GIVE_REQUEST				0x21
#define		TOKEN_GIVE_INDICATION			0x22
#define		TOKEN_GIVE_RESPONSE				0x23
#define		TOKEN_GIVE_CONFIRM				0x24
#define		TOKEN_PLEASE_REQUEST			0x25
#define		TOKEN_PLEASE_INDICATION			0x26
#define		TOKEN_RELEASE_REQUEST			0x27
#define		TOKEN_RELEASE_CONFIRM			0x28
#define		TOKEN_TEST_REQUEST				0x29
#define		TOKEN_TEST_CONFIRM				0x2a
#define		CONNECT_INITIAL				 	0x65
#define		CONNECT_RESPONSE				0x66
#define		CONNECT_ADDITIONAL				0x67
#define		CONNECT_RESULT				 	0x68

#define		HIGHEST_BER_SEND_DATA_OVERHEAD		25
#define		LOWEST_BER_SEND_DATA_OVERHEAD		19		
#define		HIGHEST_PER_SEND_DATA_OVERHEAD		9
#define		LOWEST_PER_SEND_DATA_OVERHEAD		7

#define		PER_SEND_DATA_REQUEST				0x64
#define		PER_SEND_DATA_INDICATION			0x68
#define		PER_UNIFORM_SEND_DATA_REQUEST		0x6c
#define		PER_UNIFORM_SEND_DATA_INDICATION	0x70

#define		INITIATOR_LOWER_BOUND				1001

/*
 *	This is the class definition for class CMCSCoder
 */
class	CMCSCoder : public PacketCoder
{
	public:
						CMCSCoder ();
		        BOOL    Init ( void );
		virtual			~CMCSCoder ();
		virtual	BOOL	Encode (LPVOID			pdu_structure,
								int				pdu_type,
								UINT			rules_type,
								LPBYTE			*encoding_buffer,
								UINT			*encoding_buffer_length);

		virtual BOOL	Decode (LPBYTE			encoded_buffer,
								UINT			encoded_buffer_length,
								int				pdu_type,
								UINT			rules_type,
								LPVOID			*pdecoding_buffer,
								UINT			*pdecoding_buffer_length);

		Void			ReverseDirection (LPBYTE		encoded_buffer);
											
		virtual DBBoolean IsMCSDataPacket (	LPBYTE		 encoded_buffer,
											UINT		 rules_type);
		virtual void	FreeEncoded (LPBYTE encoded_buffer);

		virtual void	FreeDecoded (int pdu_type, LPVOID decoded_buffer);

	private:
		void SetEncodingRules				(UINT			rules_type); 
												 
		UINT					Encoding_Rules_Type;
		ASN1encoding_t  m_pEncInfo;    // ptr to encoder info
		ASN1decoding_t  m_pDecInfo;    // ptr to decoder info
};
typedef CMCSCoder *		PCMCSCoder;

/*
 *	CMCSCoder ()
 *
 *	Functional Description:
 *		This is the constructor for the CMCSCoder class.  It initializes the
 *		ASN.1 toolkit and sets the type of encoding rules to Basic Encoding
 *		Rules (BER).  It also initializes some private instance variables.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~CMCSCoder ()
 *
 *	Functional Description:
 *		This is a virtual destructor.  It cleans up after the ASN.1 toolkit.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void Encode (	LPVOID		pdu_structure,
 *					int			pdu_type,
 *					UINT		 rules_type,
 *					LPBYTE		*encoding_buffer,
 *					UINT		*encoding_buffer_length)
 *
 *	Functional Description:
 *		This function encodes Protocol data units (PDU's) into ASN.1 compliant
 *		byte streams.
 *		The coder allocates the buffer space for the encoded data.
 *
 *	Formal Parameters:
 *		pdu_structure (i)		Pointer to structure holding PDU data.
 *		pdu_type (i)			Define indicating Connect or Domain MCS PDU.
 *		rules_type (i)			Type of encoding rules (BER or PER).
 *		encoding_buffer (o)		Pointer to buffer to hold encoded data.
 *		encoding_buffer_length (o) Length of encoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void Decode (	LPBYTE		encoded_buffer,
 *					UINT		encoded_buffer_length,
 *					int			pdu_type,
 *					UINT		rules_type,
 *					LPVOID		decoding_buffer,
 *					UINT		decoding_buffer_length,
 *					UINT		*pulDataOffset)
 *
 *	Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate MCS PDU structures.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding data to decode.
 *		encoded_buffer_length(i) Length of buffer holding encoded data.
 *		pdu_type (i)			Type (Domain or Connect) of MCS PDU.
 *		rules_type (i)			Type of encoding rules (BER or PER).
 *		decoding_buffer (o)		Pointer to buffer to hold the decoded data.
 *		decoding_buffer_length (i) Length of buffer to hold decoded data.
 *		pulDataOffset (o)		Pointer to a value that stores the offset of the data in an encoded MCS data packet.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void	CopyDecodedData (	LPVOID	pdu_source_structure,
 *								LPVOID	pdu_destination_structure,
 *								UINT		 pdu_type)
 *
 *	Functional Description:
 *		This function makes a complete copy of a decoded PDU structure.
 *
 *	Formal Parameters:
 *		pdu_source_structure (i)	Pointer to buffer holding decoded structure.
 *		pdu_destination_structure (i) Pointer to copy buffer.
 *		pdu_type (i) 				Type (Domain or Connect) of PDU.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void ReverseDirection (LPBYTE	encoded_buffer)
 *
 *	Functional Description:
 *		This function alters the identifier of encoded "Send Data" PDU's in 
 * 		order to change back and forth between data requests and indications.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding encoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

 /*
 *	DBBoolean	IsMCSDataPacket ()
 *
 *	Functional Description:
 *		This function determines whether the encoded packet is an MCS Data packet
 *		or not.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding the encoded PDU.
 *		rules_type (i)			The used encoding rules.
 *
 *	Return value:
 *		TRUE, if the packet is an MCS Data packet. FALSE, otherwise.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\ogcccode.h ===
/*
 *	ogcccode.h
 *
 *	Copyright (c) 1994 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the CGCCCoder class.  This
 *		class is used to encode and decode GCC Protocol Data Units (PDU's)
 *		to and from ASN.1 compliant byte streams using the ASN.1 toolkit.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 *
 */
#ifndef	_CGCCCODER_
#define	_CGCCCODER_

#include "pktcoder.h"
#include "pdutypes.h"
#include "gccpdu.h"

/*
 * Macros
 */
#define		MAXIMUM_PDU_SIZE			512
#define		DECODED_ROSTER_PDU_SIZE		1024

#define		USER_ID_INDICATION				0x61
#define		CONFERENCE_CREATE_REQUEST		0x62
#define		CONFERENCE_CREATE_RESPONSE		0x63
#define		CONFERENCE_QUERY_REQUEST		0x64
#define		CONFERENCE_QUERY_RESPONSE		0x65
#define		CONFERENCE_JOIN_REQUEST			0x66
#define		CONFERENCE_JOIN_RESPONSE		0x67
#define		CONFERENCE_INVITE_REQUEST		0x68
#define		CONFERENCE_INVITE_RESPONSE		0x69
#define		ROSTER_UPDATE_INDICATION		0x7e
#define		MULTIPLE_OCTET_ID	 			0x7f
#define		REGISTER_CHANNEL_REQUEST		0xa0
#define		ASSIGN_TOKEN_REQUEST			0xa1
#define		RETRIEVE_ENTRY_REQUEST			0xa3
#define		DELETE_ENTRY_REQUEST			0xa4
#define		REGISTRY_RESPONSE				0xa9


/*
 *	This is the class definition for class CGCCCoder
 */
class	CGCCCoder : public PacketCoder
{
	public:
						CGCCCoder ();
		        BOOL    Init ( void );
		virtual			~CGCCCoder ();
		virtual	BOOL	Encode (LPVOID			pdu_structure,
								int				pdu_type,
								UINT		 	rules_type,
								LPBYTE			*encoding_buffer,
								UINT			*encoding_buffer_length);

		virtual BOOL	Decode (LPBYTE			encoded_buffer,
								UINT			encoded_buffer_length,
								int				pdu_type,
								UINT			rules_type,
								LPVOID			*decoding_buffer,
								UINT			*decoding_buffer_length);
									
		virtual void	FreeEncoded (LPBYTE encoded_buffer);

		virtual void	FreeDecoded (int pdu_type, LPVOID decoded_buffer);

		virtual BOOL     IsMCSDataPacket (	LPBYTE,	UINT		) 
													{ return FALSE; };

	private:
		BOOL    		IsObjectIDCompliant (PKey	t124_identifier);
		ASN1encoding_t  m_pEncInfo;    // ptr to encoder info
		ASN1decoding_t  m_pDecInfo;    // ptr to decoder info
};
typedef CGCCCoder *		PCGCCCoder;

/*
 *	CGCCCoder ()
 *
 *	Functional Description:
 *		This is the constructor for the CGCCCoder class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~CGCCCoder ()
 *
 *	Functional Description:
 *		This is a virtual destructor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void Encode (	LPVOID		pdu_structure,
 *					int			pdu_type,
 *					UINT		rules_type,
 *					LPBYTE		*encoding_buffer,
 *					UINT		*encoding_buffer_length);
 *
 *	Functional Description:
 *		This function encodes Protocol data units (PDU's) into ASN.1 compliant
 *		byte streams.  The Encode happens into an encoder-allocated buffer.
 *
 *	Formal Parameters:
 *		pdu_structure (i)		Pointer to structure holding PDU data.
 *		pdu_type (i)			Define indicating type of GCC PDU.
 *		rules_type (i)			Type (PER or BER) of encoding rules to use.
 *		encoding_buffer (o)		Indirect pointer to buffer to hold encoded data.
 *		encoding_buffer_length(o)	Pointer that receives the Length of buffer for encoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void Decode (	LPBYTE		encoded_buffer,
 *					UINT		encoded_buffer_length,
 *					int			pdu_type,
 *					UINT		rules_type,
 *					LPVOID		decoding_buffer,
 *					UINT		decoding_buffer_length,
 *					PULong);
 *
 *	Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate GCC PDU structures.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding data to decode.
 *		encoded_buffer_length (i)	Length of buffer holding data to decode.
 *		pdu_type (i)			Define indicating type of GCC PDU.
 *		rules_type (i)			Type (PER or BER) of encoding rules to use.
 *		decoding_buffer (o)		Pointer to buffer to hold the decoded data.
 *		decoding_buffer_length(i)	Length of buffer to hold decoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	void	CopyDecodedData (	LPVOID	pdu_source_structure,
 *								LPVOID	pdu_destination_structure,
 *								UShort	pdu_type)
 *
 *	Functional Description:
 *		This function makes a complete copy of a decoded PDU structure.
 *
 *	Formal Parameters:
 *		pdu_source_structure (i)	Pointer to buffer holding decoded structure.
 *		pdu_destination_structure (i) Pointer to copy buffer.
 *		pdu_type (i)				Define indicating type of GCC PDU.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

 /*
 *	BOOL    	IsMCSDataPacket ()
 *
 *	Functional Description:
 *		This function determines whether the encoded packet is an MCS Data packet
 *		or not.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding the encoded PDU.
 *		rules_type (i)			The used encoding rules.
 *
 *	Return value:
 *		Always returns FALSE.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\objkey.h ===
/*
 *	objkey.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CObjectKeyContainer.  This class 
 *		manages the data associated with an Object Key.  Object Key are used 
 *		to identify a particular application protocol, whether it is standard or
 *		non-standard.  When used to identify a standard protocol, the Object Key
 *		takes the form of an Object ID which is a series of non-negative 
 *		integers.  This type of Object Key is maintained internally through the
 *		use of a UnicodeString object.  When used to identify a non-standard 
 *		protocol, the Object Key takes the form of an H221 non-standard ID which
 *		is an octet string of no fewer than four octets and no more than 255 
 *		octets.  In this case the Object Key is maintained internally by using a
 *		Rogue Wave string object.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_OBJECT_KEY_DATA_
#define	_OBJECT_KEY_DATA_


/*
 * Macros used by this class.
 */
#define 	MINIMUM_OBJECT_ID_ARCS				3
#define 	ITUT_IDENTIFIER						0
#define 	ISO_IDENTIFIER						1
#define 	JOINT_ISO_ITUT_IDENTIFIER			2
#define 	MINIMUM_NON_STANDARD_ID_LENGTH		4
#define 	MAXIMUM_NON_STANDARD_ID_LENGTH		255


/*
 * This is the typedef for the structure used to hold the object key data
 * internally.
 */
typedef struct
{
	LPBYTE						object_id_key;
	UINT						object_id_length;
	LPOSTR						poszNonStandardIDKey;
}
    OBJECT_KEY;

/*
 * Class definition:
 */
class CObjectKeyContainer : public CRefCount
{
public:

	CObjectKeyContainer(PGCCObjectKey, PGCCError);
	CObjectKeyContainer(PKey, PGCCError);
	CObjectKeyContainer(CObjectKeyContainer *, PGCCError);

	~CObjectKeyContainer(void);

	UINT		LockObjectKeyData(void);
	void		UnLockObjectKeyData(void);

	UINT		GetGCCObjectKeyData(PGCCObjectKey, LPBYTE memory);
	GCCError	GetObjectKeyDataPDU(PKey);
	void		FreeObjectKeyDataPDU(void);

	friend BOOL operator== (const CObjectKeyContainer&, const CObjectKeyContainer&);

protected:

	OBJECT_KEY  		m_InternalObjectKey;
	UINT				m_cbDataSize;

	Key					m_ObjectKeyPDU;
	BOOL    			m_fValidObjectKeyPDU;

private:

	BOOL		ValidateObjectIdValues(UINT first_arc, UINT second_arc);
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CObjectKeyContainer (	PGCCObjectKey		object_key,
 *					PGCCError			return_value);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CObjectKeyContainer class which takes as
 *		input the "API" version of object key data, GCCObjectKey.
 *
 *	Formal Parameters:
 *		object_key			(i)	The object key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	An invalid object key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CObjectKeyContainer (		PKey				object_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CObjectKeyContainer class which takes as
 *		input the "PDU" version of object key data, Key.
 *
 *	Formal Parameters:
 *		object_key			(i)	The object key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CObjectKeyContainer (		CObjectKeyContainer		    *object_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CObjectKeyContainer class which takes
 *		as input another CObjectKeyContainer object.
 *
 *	Formal Parameters:
 *		object_key			(i)	The CObjectKeyContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	An invalid CObjectKeyContainer passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~ObjectKeyData();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This is the destructor for the CObjectKeyContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT			LockObjectKeyData ();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCObjectKey structure
 *		which is filled in on a call to GetGCCObjectKeyData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCObjectKeyData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCObjectKey structure
 *		provided as an output parameter to the GetGCCObjectKeyData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeObjectKeyData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  An CObjectKeyContainer
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeObjectKeyData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CObjectKeyContainer object will automatically delete itself when
 *		the FreeObjectKeyData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */


/*
 *	UINT			GetGCCObjectKeyData (	
 *							PGCCObjectKey 		object_key,
 *							LPSTR				memory);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the object key data from the
 *		CObjectKeyContainer object in the "API" form of a GCCObjectKey.
 *
 *	Formal Parameters:
 *		object_key			(o)	The GCCObjectKey structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void			UnLockObjectKeyData ();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeObjectKeyData.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks an CObjectKeyContainer
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CObjectKeyContainer 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	void			FreeObjectKeyData ();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "API" data for this object.  This 
 *		will result in the automatic deletion of this object if the object is
 *		not in the "locked" state.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeObjectKeyData has been made.
 */


/*
 *	GCCError		GetObjectKeyDataPDU (	
 *							PKey 		object_key);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the object key data from the
 *		CObjectKeyContainer object in the "PDU" form of a Key.
 *
 *	Formal Parameters:
 *		object_key		(o)	The Key structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	One of the internal pointers has
 *												been corrupted.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeObjectKeyDataPDU ();
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a Key structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal flag is set to indicate that the PDU form of data no
 *		longer is valid for this object.
 *
 *	Caveats:
 *		None.
 */


/*
 *	friend BOOL    	operator== (const CObjectKeyContainer& 		object_key_1, 
 *									const CObjectKeyContainer& 		object_key_2);
 *
 *	Public member function of CObjectKeyContainer.
 *
 *	Function Description:
 *		This routine is used to compare two CObjectKeyContainer objects to determine
 *		whether or not they are equal in value.
 *
 *	Formal Parameters:
 *		object_key_1			(i)	The first CObjectKeyContainer object to compare.
 *		object_key_2			(i)	The other CObjectKeyContainer object to compare.
 *
 *	Return Value:
 *		TRUE				-	The two objects are equal in value.
 *		FALSE				- 	The two objects are not equal in value.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\packet.h ===
/*
 *	packet.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *				  1997 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the interface file for the Packet class.  Instances of this
 *		class represent Protocol Data Units (PDUs) as they flow through the
 *		system.  These instances manage the memory required to hold both
 *		encoded and decoded versions of the PDU, and make sure that no PDU
 *		is ever encoded or decoded more than once.  The use of lock counts
 *		allow multiple objects in the system to reference and use the same
 *		packet object at the same time. This class inherits from the SimplePacket
 *		class (a pure virtual class).
 *
 *		A packet object can be created in 2 different ways.  It can be created
 *		with either decoded data or encoded data.  During instantiation, the
 *		new packet object will calculate how much memory it will need to
 *		hold both the encoded and decoded data, and attempts to allocate that
 *		memory.  If it cannot, then it will report an error, and the newly
 *		created object should be immediately destroyed.  If the allocations are
 *		successful, then the packet will report success, but WILL NOT yet put
 *		any data into those allocated buffers.
 *
 *		When a Lock message is sent to the object, it will put encoded
 *		data into the pre-allocated encode buffer.  If the packet was created
 *		with decoded data, then this will entail an encode operation.  However,
 *		if the packet was created with encoded data, then it is smart enough
 *		to just COPY the encoded data into the internal buffer, thus avoiding
 *		the overhead associated with the encode operation.
 *                  
 *		When a Lock message is sent to the object, it will put decoded
 *		data into the pre-allocated decode buffer.  If the packet was created
 *		with encoded data, then this will entail a decode operation.  However,
 *		if the packet was created with decoded data, then it is smart enough
 *		to just COPY the decoded data into the internal buffer, thus avoiding
 *		the overhead associated with the decode operation.
 *
 *		When Unlock messages are received, the lock count is decremented.  When
 *		the lock count is 0, the packet deletes itself (it commits
 *		suicide).  Note that for this reason, no other object should explicitly
 *		delete a packet object.
 *                  
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		James J. Johnstone IV
 *		Christos Tsollis
 */

#ifndef _PACKET_
#define _PACKET_

#include "pktcoder.h"

/*
 *	 Definition of class Packet.
 */

class Packet;
typedef Packet *		PPacket;

class Packet : public SimplePacket
{
public:

	// outgoing packets
	Packet(PPacketCoder	pPacketCoder,
			UINT			nEncodingRules,
			LPVOID			pInputPduStructure,
			int				nPduType,
			BOOL			fPacketDirectionUp,
			PPacketError	pePktErr,
			BOOL			fLockEncodedData = FALSE);

	// incoming packets
	Packet(PPacketCoder	pPacketCoder,
			UINT			nEncodingRules,
			LPBYTE			pEncodedData,
			UINT			cbEncodedDataSize,
			int				nPduType,
			BOOL			fPacketDirectionUp,
			PPacketError	pePktErr);

	virtual 			~Packet(void);
	
	virtual BOOL		IsDataPacket (void);
	virtual PVoid		GetDecodedData(void);
	UINT				GetDecodedDataLength(void) { return Decoded_Data_Length; };
	virtual int			GetPDUType(void);

protected:
	
	PPacketCoder	Packet_Coder;
	LPVOID			m_Decoded_Data;
	UINT			Decoded_Data_Length;
	int				PDU_Type;
};


/*
 *	Packet (
 *			PPacketCoder	packet_coder,
 *			UINT			encoding_rules,
 *			PVoid			pInputPduStructure,
 *			PMemory			pInputPduStructure_Memory,
 *			int				pdu_type,
 *			DBBoolean		packet_direction_up,
 *			PPacketError	return_value )
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Packet object
 *		for outgoing PDUs when the packet is to be created from a structure
 *		containing the PDU data to be encoded.
 *
 *	Formal Parameters:
 *		packet_coder (i)
 *			Pointer to the packet coder object.  This pointer will be used by
 *			the packet object to encode and decode PDU structures.  This pointer
 *			must not become stale during the life of the packet object.
 *		encoding_rules (i)
 *			This value identifies which set of encoding rules should be used
 *			on the current packet.  This is simply through to the packet coder
 *			during all encode and decode operations.
 *		pInputPduStructure (i)
 *			Pointer to the input PDU structure.
 *		pInputPduStructure_Memory
 *			Pointer to a Memory struct for the buffer containing the pdu structure.
 *			Exactly one of the args pInputPduStructure_Memory and pInputPduStructure
 *			should be non-NULL;
 *		pdu_type (i)
 *			The type of PDU contained in the packet.  This is passed through
 *			to the packet coder specified above.
 *		packet_direction_up (i)
 *			The packet_direction_up flag indicates the initial orientation of
 *			the packet.  Valid values are:
 *				TRUE -	The packet's direction is up.
 *				FALSE -	The packet's direction is down.
 *		return_value (o)
 *			When the constructor returns control to the calling function, this
 *			variable will be set to one of the return values listed below.
 *
 *	Return Value:
 *		PACKET_NO_ERROR
 *			The Packet object was constructed correctly. 
 *		PACKET_MALLOC_FAILURE
 *			The constructor was unable to allocate the memory required to work
 *			properly.  The Packet object should be deleted.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Packet (
 *			PPacketCoder	packet_coder,
 *			UINT			encoding_rules,
 *			PUChar			encoded_data_ptr,
 *			UShort			encoded_data_length,
 *			int				pdu_type,
 *			DBBoolean		packet_direction_up,
 *			PPacketError	return_value )
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Packet object
 *		for incomming PDUs when the packet is to be created from an encoded
 *		data stream containing the PDU data to be decoded.
 *
 *	Formal Parameters:
 *		packet_coder (i)
 *			Pointer to the packet coder object.  This pointer will be used by
 *			the packet object to encode and decode PDU structures.  This pointer
 *			must not become stale during the life of the packet object.
 *		encoding_rules (i)
 *			This value identifies which set of encoding rules should be used
 *			on the current packet.  This is simply through to the packet coder
 *			during all encode and decode operations.
 *		encoded_data_ptr (i)
 *			Pointer to the input encoded PDU.
 *		encoded_data_length (i)
 *			The length in bytes of the input encoded PDU.
 *		pdu_type (i)
 *			The type of PDU contained in the packet.  This is passed through
 *			to the packet coder specified above.
 *		packet_direction_up (i)
 *			The packet_direction_up flag indicates the initial orientation of
 *			the packet.  Valid values are:
 *				TRUE -	The packet's direction is up.
 *				FALSE -	The packet's direction is down.
 *		return_value (o)
 *			When the constructor returns control to the calling function, this
 *			variable will be set to one of the return values listed below.
 *
 *	Return Value:
 *		PACKET_NO_ERROR
 *			The Packet object was constructed correctly. 
 *		PACKET_MALLOC_FAILURE
 *			The constructor was unable to allocate the memory required to work
 *			properly.  The Packet object should be deleted.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */							      				      
/*
 *	~Packet ()
 *
 *	Functional Description:
 *		Destructor for the Packet class.  The destructor ensures that all 
 *		resources that have been allocated are freed.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedData ()
 *
 *	Functional Description:
 *		The GetDecodedData method returns a pointer to the decoded data
 *		buffer.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the decoded data.  If an decoding error occurs, this
 *		method will return NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedDataLength ()
 *
 *	Functional Description:
 *		This method returns the decoded data's length.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The number of bytes in the decoded data.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetPDUType ()
 *
 *	Functional Description:
 *		This method returns the PDU type.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		Either DOMAIN_MCS_PDU or CONNECT_MCS_PDU dependant upon the PDU type.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\password.h ===
/*
 *	password.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CPassword.  This class
 *		manages the data associated with a Password.  Passwords are used to 
 *		restrict access to conferences.  A password can be one of two basic
 *		types.  The simple type consists of either a simple numeric password or
 *		a simple textual password, or both.  The "PDU" type "Password" is a
 *		structure which must contain the numeric form of the password and may
 *		optionally contain the textual part as well.  The "PDU" type
 *		"PasswordSelector" is a union of the numeric and textual forms of a
 *		password and is therefore always one or the other but not both.  When
 *		the password is not the simple type it assumes the form of a
 *		"PasswordChallengeRequestResponse".  This complex structure allows a
 *		challenge-response scheme to be used to control access to conferences.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_PASSWORD_DATA_
#define	_PASSWORD_DATA_

#include "userdata.h"

class CPassword;

/*
 * This is the typedef for the structure used to maintain the challenge 
 * response algorithms internally.
 */
typedef struct
{
	GCCPasswordAlgorithmType	algorithm_type;
	CObjectKeyContainer 	    *object_key;
	LPOSTR						poszOctetString;
} ResponseAlgorithmInfo;
typedef	ResponseAlgorithmInfo * 	PResponseAlgorithmInfo;

/*
 * This is the typedef for the structure used to maintain the challenge items 
 * associated with a challenge request.
 */
typedef struct
{
	ResponseAlgorithmInfo		algorithm;
	CUserDataListContainer      *challenge_data_list;
} ChallengeItemInfo;
typedef	ChallengeItemInfo * 	PChallengeItemInfo;

/*
 * This is the typedef for the structure used to maintain the memory used 
 * to hold the user data and object key data associated with a challenge 
 * request item.
 */
typedef struct
{
	LPBYTE						user_data_list_memory;
	LPBYTE						object_key_memory;
} ChallengeItemMemoryInfo;
typedef	ChallengeItemMemoryInfo * 	PChallengeItemMemoryInfo;

/*
 * This is the typedef for the structure used to maintain the 
 * challenge-reponse items internally.
 */
typedef struct
{
	CPassword                   *password;
	CUserDataListContainer	    *response_data_list;
} ChallengeResponseItemInfo;
typedef	ChallengeResponseItemInfo * 	PChallengeResponseItemInfo;

/*
 * The set of challenge items is maintained internally in a linked List.
 */
class CChallengeItemList : public CList
{
    DEFINE_CLIST(CChallengeItemList, PChallengeItemInfo)
};

/*
 * The memory associated with each challenge item is maintained internally in 
 * linked List.
 */
class CChallengeItemMemoryList : public CList
{
    DEFINE_CLIST(CChallengeItemMemoryList, PChallengeItemMemoryInfo)
};

/*
 * This is the typedef for the structure used to maintain the "Request" 
 * data internally.
 */
typedef struct
{
	GCCResponseTag				challenge_tag;
	CChallengeItemList			ChallengeItemList;
}
    RequestInfo, *PRequestInfo;

/*
 * This is the typedef for the structure used to maintain the "Response" 
 * data internally.
 */
typedef struct
{
	GCCResponseTag						challenge_tag;
	ResponseAlgorithmInfo				algorithm;
	ChallengeResponseItemInfo			challenge_response_item;
}
    ResponseInfo, *PResponseInfo;

/*
 * Class definition:
 */
class CPassword : public CRefCount
{
public:

	CPassword(PGCCPassword, PGCCError);
	CPassword(PGCCChallengeRequestResponse, PGCCError);
	CPassword(PPassword, PGCCError);
	CPassword(PPasswordSelector, PGCCError);
	CPassword(PPasswordChallengeRequestResponse, PGCCError);

    ~CPassword(void);

	GCCError	LockPasswordData(void);
	void		UnLockPasswordData(void);
	GCCError	GetPasswordData(PGCCPassword *);
	GCCError	GetPasswordChallengeData(PGCCChallengeRequestResponse *);
	GCCError	GetPasswordPDU(PPassword);
	GCCError	GetPasswordSelectorPDU(PPasswordSelector);
	GCCError	GetPasswordChallengeResponsePDU(PPasswordChallengeRequestResponse);
	void		FreePasswordChallengeResponsePDU(void);

protected:

    BOOL							m_fSimplePassword;
    BOOL							m_fClearPassword;

    /*
     * Variables and structures used to hold the password data internally.
     */
    LPSTR							m_pszNumeric;
    LPWSTR							m_pwszText;
    PRequestInfo					m_pInternalRequest;
    PResponseInfo					m_pInternalResponse;

    /*
     * Structures used to hold the password data in "API" form.
     */
    PGCCChallengeRequestResponse	m_pChallengeResponse;
    PGCCPassword					m_pPassword;
    LPBYTE							m_pUserDataMemory;
    LPBYTE							m_pChallengeItemListMemory;
    LPBYTE							m_pObjectKeyMemory;
    CChallengeItemMemoryList		m_ChallengeItemMemoryList;

    /*
     * Structure used to hold the password data in "PDU" form.
     */
    PasswordChallengeRequestResponse		m_ChallengeResponsePDU;
    BOOL									m_fValidChallengeResponsePDU;

private:

	GCCError	ConvertAPIChallengeRequest(PGCCChallengeRequest);
	GCCError	ConvertAPIChallengeResponse(PGCCChallengeResponse);
	GCCError	CopyResponseAlgorithm(PGCCChallengeResponseAlgorithm, PResponseAlgorithmInfo);
	GCCError	ConvertPDUChallengeRequest(PChallengeRequest);
	GCCError	ConvertPDUChallengeItem(PChallengeItem);
	GCCError	ConvertPDUChallengeResponse(PChallengeResponse);
	GCCError	ConvertPDUResponseAlgorithm(PChallengeResponseAlgorithm, PResponseAlgorithmInfo);
	GCCError	GetGCCChallengeRequest(PGCCChallengeRequest);
	GCCError	GetGCCChallengeResponse(PGCCChallengeResponse);
	GCCError	GetChallengeRequestPDU(PChallengeRequest);
	GCCError	ConvertInternalChallengeItemToPDU(PChallengeItemInfo, PChallengeItem);
	GCCError	GetChallengeResponsePDU(PChallengeResponse);
	void		FreeChallengeRequestPDU(void);
	void		FreeChallengeResponsePDU(void);
    void		FreeAPIPasswordData(void);
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CPassword (	PGCCPassword		password,
 *					PGCCError			return_value);
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "API" version of password data, GCCPassword.
 *
 *	Formal Parameters:
 *		password			(i)	The password data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CPassword ( 	PGCCChallengeRequestResponse		challenge_response_data,
 *					PGCCError							return_value)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "API" version of password challenge data, 
 *		GCCChallengeRequestResponse.
 *
 *	Formal Parameters:
 *		challenge_response_data	(i)	The password challenge data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CPassword ( 	PPassword				password_pdu,
 *					PGCCError				return_value)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "PDU" version of password data, Password.
 *
 *	Formal Parameters:
 *		password_pdu		(i)	The password data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CPassword(	PPasswordSelector			password_selector_pdu,
 *					PGCCError					return_value)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "PDU" version of password data, PasswordSelector.
 *
 *	Formal Parameters:
 *		password_selector_pdu	(i)	The password selector data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CPassword (	PPasswordChallengeRequestResponse	pdu_challenge_data,
 *					PGCCError							return_value)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the constructor for the CPassword class which takes as
 *		input the "PDU" version of password challenge data, 
 *		PasswordChallengeRequestResponse.
 *
 *	Formal Parameters:
 *		pdu_challenge_data	(i)	The password challenge data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_INVALID_PASSWORD			-	An invalid password passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CPassword();
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This is the destructor for the CPassword class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	LockPasswordData ();
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the appropriate form of the "API" password being stored
 *		internally in preparation for a call to "GetGCCPasswordData" which will
 *		return that data.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreePasswordData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CPassword
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreePasswordData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CPassword object will automatically delete itself when
 *		the FreePasswordData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */


/*
 *	GCCError	GetPasswordData (	PGCCPassword	 *	gcc_password)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password data from the
 *		CPassword object in the "API" form of a GCCPassword.
 *
 *	Formal Parameters:
 *		gcc_password			(o)	The GCCPassword structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	The object was not properly locked
 *												prior to this call.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	GetPasswordChallengeData (
 *					PGCCChallengeRequestResponse	 *	gcc_challenge_password)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password challenge data from the
 *		CPassword object in the "API" form of a GCCChallengeRequestResponse.
 *
 *	Formal Parameters:
 *		gcc_challenge_password		(o)	The GCCChallengeRequestResponse 
 *											structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	The object was not properly locked
 *												prior to this call.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void	UnLockPasswordData ();
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to FreePasswordData.
 *		If so, the object will automatically delete	itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CPassword
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CPassword 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	GCCError	GetPasswordPDU (PPassword		pdu_password)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password data from the
 *		CPassword object in the "PDU" form of a Password.
 *
 *	Formal Parameters:
 *		pdu_password		(o)	The Password structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	The required numeric portion of the
 *												password does not exist.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	GetPasswordSelectorPDU(
 *					PPasswordSelector				password_selector_pdu)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password data from the
 *		CPassword object in the "PDU" form of a PasswordSelector.
 *
 *	Formal Parameters:
 *		password_selector_pdu	(o)	The PasswordSelector structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_INVALID_PASSWORD			- 	Neither the numeric nor the textual
 *												form of the password are valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	GetPasswordChallengeResponsePDU(
 *					PPasswordChallengeRequestResponse	challenge_pdu)
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to retrieve the password challenge data from the
 *		CPassword object in the "PDU" form of a 
 *		PasswordChallengeRequestResponse.
 *
 *	Formal Parameters:
 *		challenge_pdu			(o)	The PasswordChallengeRequestResponse 
 *										structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_INVALID_PARAMETER			-	Invalid attempt to retrieve
 *												challenge data from a simple
 *												password.
 *		GCC_INVALID_PASSWORD			-	The challenge password is "clear"
 *												but no valid data exists.
 *		GCC_ALLOCATION_FAILURE			- 	Neither the numeric nor the textual
 *												form of the password are valid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void	FreePasswordChallengeResponsePDU ()
 *
 *	Public member function of CPassword.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a GCCChallengeRequestResponse structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreePasswordChallengeResponsePDU has been made.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\pdutypes.h ===
/*
 *	pdutypes.h
 *
 *	Copyright (c) 1994, 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This file is used to convert from the ASN.1 generated types into types
 *		compliant with the DataBeam coding standard.
 *
 *	Author:
 *		jbo
 *
 *	Caveats:
 *		none
 */

#ifndef	_GCC_PDU_TYPES_
#define	_GCC_PDU_TYPES_

#include "gccpdu.h"

/*
 *	PDU types
 */
#define CONNECT_DATA_PDU   					ConnectData_PDU
#define CONNECT_GCC_PDU    					ConnectGCCPDU_PDU
#define GCC_PDU            					GCCPDU_PDU 

/*
 *	Key
 */
#define OBJECT_CHOSEN       				object_chosen
#define H221_NON_STANDARD_CHOSEN   			h221_non_standard_chosen

/*
 *	SetOfUserData
 */
#define USER_DATA_FIELD_PRESENT				user_data_field_present

/*
 *	Password
 */
#define PASSWORD_TEXT_PRESENT				password_text_present

/*
 *	PasswordSelector
 */
#define PASSWORD_SELECTOR_NUMERIC_CHOSEN  	password_selector_numeric_chosen
#define PASSWORD_SELECTOR_TEXT_CHOSEN     	password_selector_text_chosen

/*
 *	ChallengeResponseItem
 */
#define PASSWORD_STRING_CHOSEN				password_string_chosen
#define SET_OF_RESPONSE_DATA_CHOSEN			set_of_response_data_chosen

/*
 *	ChallengeResponseAlgorithm
 */
#define ALGORITHM_CLEAR_PASSWORD_CHOSEN		algorithm_clear_password_chosen
#define NON_STANDARD_ALGORITHM_CHOSEN		non_standard_algorithm_chosen

/*
 *	PasswordChallengeRequestResponse
 */
#define CHALLENGE_CLEAR_PASSWORD_CHOSEN		challenge_clear_password_chosen
#define CHALLENGE_REQUEST_RESPONSE_CHOSEN	challenge_request_response_chosen

/*
 *	ChallengeRequestResponse
 */
#define CHALLENGE_REQUEST_PRESENT			challenge_request_present
#define CHALLENGE_RESPONSE_PRESENT			challenge_response_present

/*
 *	ConferenceName
 */
#define CONFERENCE_NAME_TEXT_PRESENT		conference_name_text_present

/*
 *	ConferenceNameSelector
 */
#define NAME_SELECTOR_NUMERIC_CHOSEN  		name_selector_numeric_chosen
#define NAME_SELECTOR_TEXT_CHOSEN     		name_selector_text_chosen


/*
 *	Defines to match Enums for Privileges
 */
#define	NUMBER_OF_PRIVILEGES		5
#define TERMINATE_IS_ALLOWED		terminate
#define	EJECT_USER_IS_ALLOWED		ejectUser
#define	ADD_IS_ALLOWED				add
#define	LOCK_UNLOCK_IS_ALLOWED		lockUnlock
#define	TRANSFER_IS_ALLOWED			transfer


/*
 *	NetworkAddress
 */
#define AGGREGATED_CHANNEL_CHOSEN 			aggregated_channel_chosen
#define TRANSPORT_CONNECTION_CHOSEN 		transport_connection_chosen
#define ADDRESS_NON_STANDARD_CHOSEN			address_non_standard_chosen

/*
 *	AggregateChannel
 */
#define SUB_ADDRESS_PRESENT 				sub_address_present
#define EXTRA_DIALING_STRING_PRESENT 		extra_dialing_string_present
#define HIGH_LAYER_COMPATIBILITY_PRESENT 	high_layer_compatibility_present

/*
 *	TransportConnection
 */
#define TRANSPORT_SELECTOR_PRESENT 			transport_selector_present

/*
 *	AsymmetryIndicator
 */
#define CALLING_NODE_CHOSEN 				calling_node_chosen
#define CALLED_NODE_CHOSEN 					called_node_chosen
#define UNKNOWN_CHOSEN 						unknown_chosen

/*
 *	AlternativeNodeID
 */
#define H243_NODE_ID_CHOSEN 				h243_node_id_chosen

/*
 *	ConferenceDescriptor
 */
#define CONFERENCE_NAME_MODIFIER_PRESENT 	conference_name_modifier_present
#define CONFERENCE_DESCRIPTION_PRESENT 		conference_description_present
#define DESCRIPTOR_NET_ADDRESS_PRESENT 		descriptor_net_address_present

/*
 *	NodeRecord
 */
#define SUPERIOR_NODE_PRESENT 				superior_node_present
#define NODE_NAME_PRESENT 					node_name_present
#define PARTICIPANTS_LIST_PRESENT 			participants_list_present
#define SITE_INFORMATION_PRESENT 			site_information_present
#define RECORD_NET_ADDRESS_PRESENT 			record_net_address_present
#define ALTERNATIVE_NODE_ID_PRESENT 		alternative_node_id_present
#define RECORD_USER_DATA_PRESENT 			record_user_data_present

/*
 *	SessionKey
 */
#define SESSION_ID_PRESENT 					session_id_present

/*
 *	CapabilityID
 */
#define STANDARD_CHOSEN 					standard_chosen
#define CAPABILITY_NON_STANDARD_CHOSEN		capability_non_standard_chosen

/*
 *	ApplicationRecord
 */
#define RECORD_STARTUP_CHANNEL_PRESENT		record_startup_channel_present
#define APPLICATION_USER_ID_PRESENT 		application_user_id_present
#define NON_COLLAPSING_CAPABILITIES_PRESENT	non_collapsing_capabilities_present

/*
 *	SetOfNonCollapsingCapabilities
 */
#define APPLICATION_DATA_PRESENT 			application_data_present

/*
 *	CapabilityClass
 */
#define LOGICAL_CHOSEN 						logical_chosen
#define UNSIGNED_MINIMUM_CHOSEN 			unsigned_minimum_chosen
#define UNSIGNED_MAXIMUM_CHOSEN 			unsigned_maximum_chosen

/*
 *	ApplicationInvokeSpecifier
 */
#define EXPECTED_CAPABILITY_SET_PRESENT 	expected_capability_set_present
#define INVOKE_STARTUP_CHANNEL_PRESENT		invoke_startup_channel_present

/*
 *	RegistryItem
 */
#define CHANNEL_ID_CHOSEN 					channel_id_chosen
#define TOKEN_ID_CHOSEN 					token_id_chosen
#define PARAMETER_CHOSEN 					parameter_chosen
#define VACANT_CHOSEN 						vacant_chosen

/*
 *	RegistryEntryOwner
 */
#define OWNED_CHOSEN 						owned_chosen
#define NOT_OWNED_CHOSEN 					not_owned_chosen

/*
 *	ConferenceCreateRequest
 */
#define CCRQ_CONVENER_PASSWORD_PRESENT 		ccrq_convener_password_present
#define CCRQ_PASSWORD_PRESENT 				ccrq_password_present
#define CCRQ_CONDUCTOR_PRIVS_PRESENT 		ccrq_conductor_privs_present
#define CCRQ_CONDUCTED_PRIVS_PRESENT 		ccrq_conducted_privs_present
#define CCRQ_NON_CONDUCTED_PRIVS_PRESENT 	ccrq_non_conducted_privs_present
#define CCRQ_DESCRIPTION_PRESENT 			ccrq_description_present
#define CCRQ_CALLER_ID_PRESENT 				ccrq_caller_id_present
#define CCRQ_USER_DATA_PRESENT 				ccrq_user_data_present

/*
 *	ConferenceCreateResponse
 */
#define CCRS_USER_DATA_PRESENT				ccrs_user_data_present

/*
 *	ConferenceQueryRequest
 */
#define CQRQ_ASYMMETRY_INDICATOR_PRESENT	cqrq_asymmetry_indicator_present
#define CQRQ_USER_DATA_PRESENT				cqrq_user_data_present

/*
 *	ConferenceQueryResponse
 */
#define CQRS_ASYMMETRY_INDICATOR_PRESENT 	cqrs_asymmetry_indicator_present
#define CQRS_USER_DATA_PRESENT				cqrs_user_data_present

/*
 *	ConferenceJoinRequest
 */
#define CONFERENCE_NAME_PRESENT 			conference_name_present
#define CJRQ_CONFERENCE_MODIFIER_PRESENT 	cjrq_conference_modifier_present
#define TAG_PRESENT 						tag_present
#define CJRQ_PASSWORD_PRESENT 				cjrq_password_present
#define CJRQ_CONVENER_PASSWORD_PRESENT 		cjrq_convener_password_present
#define CJRQ_CALLER_ID_PRESENT 				cjrq_caller_id_present
#define CJRQ_USER_DATA_PRESENT 				cjrq_user_data_present

/*
 *	ConferenceJoinResponse
 */
#define CJRS_NODE_ID_PRESENT 				cjrs_node_id_present
#define CONFERENCE_NAME_ALIAS_PRESENT 		conference_name_alias_present
#define CJRS_CONDUCTOR_PRIVS_PRESENT 		cjrs_conductor_privs_present
#define CJRS_CONDUCTED_PRIVS_PRESENT 		cjrs_conducted_privs_present
#define CJRS_NON_CONDUCTED_PRIVS_PRESENT 	cjrs_non_conducted_privs_present
#define CJRS_DESCRIPTION_PRESENT 			cjrs_description_present
#define CJRS_PASSWORD_PRESENT 				cjrs_password_present
#define CJRS_USER_DATA_PRESENT 				cjrs_user_data_present

/*
 *	ConferenceInviteRequest
 */
#define CIRQ_CONDUCTOR_PRIVS_PRESENT 		cirq_conductor_privs_present
#define CIRQ_CONDUCTED_PRIVS_PRESENT 		cirq_conducted_privs_present
#define CIRQ_NON_CONDUCTED_PRIVS_PRESENT 	cirq_non_conducted_privs_present
#define CIRQ_DESCRIPTION_PRESENT 			cirq_description_present
#define CIRQ_CALLER_ID_PRESENT 				cirq_caller_id_present
#define CIRQ_USER_DATA_PRESENT 				cirq_user_data_present

/*
 *	ConferenceInviteResponse
 */
#define CIRS_USER_DATA_PRESENT				cirs_user_data_present

/*
 *	ConferenceAddRequest
 */
#define ADDING_MCU_PRESENT 					adding_mcu_present
#define CARQ_USER_DATA_PRESENT				carq_user_data_present

/*
 *	ConferenceAddResponse
 */
#define CARS_USER_DATA_PRESENT				cars_user_data_present

/*
 *	ConferenceTransferRequest
 */
#define CTRQ_CONFERENCE_MODIFIER_PRESENT 	ctrq_conference_modifier_present
#define CTRQ_NETWORK_ADDRESS_PRESENT 		ctrq_net_address_present
#define CTRQ_TRANSFERRING_NODES_PRESENT 	ctrq_transferring_nodes_present
#define CTRQ_PASSWORD_PRESENT 				ctrq_password_present

/*
 *	ConferenceTransferResponse
 */
#define CTRS_CONFERENCE_MODIFIER_PRESENT 	ctrs_conference_modifier_present
#define CTRS_TRANSFERRING_NODES_PRESENT 	ctrs_transferring_nodes_present

/*
 *	ConferenceTransferIndication
 */
#define CTIN_CONFERENCE_MODIFIER_PRESENT 	ctin_conference_modifier_present
#define CTIN_NETWORK_ADDRESS_PRESENT 		ctin_net_address_present
#define CTIN_TRANSFERRING_NODES_PRESENT 	ctin_transferring_nodes_present
#define CTIN_PASSWORD_PRESENT 				ctin_password_present

/*
 *	NodeUpdate
 */
#define NODE_ADD_RECORD_CHOSEN 				node_add_record_chosen
#define NODE_REPLACE_RECORD_CHOSEN 			node_replace_record_chosen
#define NODE_REMOVE_RECORD_CHOSEN 			node_remove_record_chosen

/*
 *	NodeRecordList
 */
#define NODE_NO_CHANGE_CHOSEN 				node_no_change_chosen
#define NODE_RECORD_REFRESH_CHOSEN 			node_record_refresh_chosen
#define NODE_RECORD_UPDATE_CHOSEN 			node_record_update_chosen

/*
 *	ApplicationUpdate
 */
#define APPLICATION_ADD_RECORD_CHOSEN 		application_add_record_chosen
#define APPLICATION_REPLACE_RECORD_CHOSEN 	application_replace_record_chosen
#define APPLICATION_REMOVE_RECORD_CHOSEN 	application_remove_record_chosen

/*
 *	ApplicationRecordList
 */
#define APPLICATION_NO_CHANGE_CHOSEN 		application_no_change_chosen
#define APPLICATION_RECORD_REFRESH_CHOSEN 	application_record_refresh_chosen
#define APPLICATION_RECORD_UPDATE_CHOSEN 	application_record_update_chosen

/*
 *	ApplicationCapabilitiesList
 */
#define CAPABILITY_NO_CHANGE_CHOSEN 		capability_no_change_chosen
#define APPLICATION_CAPABILITY_REFRESH_CHOSEN \
										application_capability_refresh_chosen

/*
 *	ApplicationInvokeIndication
 */
#define DESTINATION_NODES_PRESENT 			destination_nodes_present

/*
 *	RegistrySetParameterRequest
 */
#define PARAMETER_MODIFY_RIGHTS_PRESENT		parameter_modify_rights_present

/*
 *	RegistryMonitorEntryIndication
 */
#define ENTRY_MODIFY_RIGHTS_PRESENT 		entry_modify_rights_present

/*
 *	RegistryResponse
 */
#define RESPONSE_MODIFY_RIGHTS_PRESENT 		response_modify_rights_present

/*
 *	ConductorPermissionGrantIndication
 */
#define WAITING_LIST_PRESENT 				waiting_list_present

/*
 *	ConferenceTimeRemainingIndication
 */
#define TIME_REMAINING_NODE_ID_PRESENT		time_remaining_node_id_present

/*
 *	ConferenceAssistanceIndication
 */
#define CAIN_USER_DATA_PRESENT 				cain_user_data_present

/*
 *	RequestPDU
 */
#define CONFERENCE_JOIN_REQUEST_CHOSEN 				\
									conference_join_request_chosen
#define CONFERENCE_JOIN_RESPONSE_CHOSEN 			\
									conference_join_response_chosen
#define CONFERENCE_LOCK_REQUEST_CHOSEN 				\
									conference_lock_request_chosen
#define CONFERENCE_UNLOCK_REQUEST_CHOSEN 			\
									conference_unlock_request_chosen
#define CONFERENCE_TERMINATE_REQUEST_CHOSEN 		\
									conference_terminate_request_chosen
#define CONFERENCE_EJECT_USER_REQUEST_CHOSEN 		\
									conference_eject_user_request_chosen
#define CONFERENCE_TRANSFER_REQUEST_CHOSEN 			\
									conference_transfer_request_chosen
#define	CONFERENCE_ADD_REQUEST_CHOSEN				\
									conference_add_request_chosen
#define REGISTRY_REGISTER_CHANNEL_REQUEST_CHOSEN 	\
									registry_register_channel_request_chosen
#define REGISTRY_ASSIGN_TOKEN_REQUEST_CHOSEN 		\
									registry_assign_token_request_chosen
#define REGISTRY_SET_PARAMETER_REQUEST_CHOSEN 		\
									registry_set_parameter_request_chosen
#define REGISTRY_RETRIEVE_ENTRY_REQUEST_CHOSEN 		\
									registry_retrieve_entry_request_chosen
#define REGISTRY_DELETE_ENTRY_REQUEST_CHOSEN 		\
									registry_delete_entry_request_chosen
#define REGISTRY_MONITOR_ENTRY_REQUEST_CHOSEN 		\
									registry_monitor_entry_request_chosen
#define REGISTRY_ALLOCATE_HANDLE_REQUEST_CHOSEN 	\
									registry_allocate_handle_request_chosen
#define NON_STANDARD_REQUEST_CHOSEN 				\
									non_standard_request_chosen

/*
 *	ConnectGCCPDU
 */
#define CONFERENCE_CREATE_REQUEST_CHOSEN 	conference_create_request_chosen
#define CONFERENCE_CREATE_RESPONSE_CHOSEN 	conference_create_response_chosen
#define CONFERENCE_QUERY_REQUEST_CHOSEN 	conference_query_request_chosen
#define CONFERENCE_QUERY_RESPONSE_CHOSEN 	conference_query_response_chosen
#define CONNECT_JOIN_REQUEST_CHOSEN 		connect_join_request_chosen
#define CONNECT_JOIN_RESPONSE_CHOSEN 		connect_join_response_chosen
#define CONFERENCE_INVITE_REQUEST_CHOSEN 	conference_invite_request_chosen
#define CONFERENCE_INVITE_RESPONSE_CHOSEN 	conference_invite_response_chosen

/*
 *	ResponsePDU
 */
#define CONFERENCE_JOIN_RESPONSE_CHOSEN 			\
									conference_join_response_chosen
#define CONFERENCE_ADD_RESPONSE_CHOSEN 				\
									conference_add_response_chosen
#define CONFERENCE_LOCK_RESPONSE_CHOSEN 			\
									conference_lock_response_chosen
#define CONFERENCE_UNLOCK_RESPONSE_CHOSEN 			\
									conference_unlock_response_chosen
#define CONFERENCE_TERMINATE_RESPONSE_CHOSEN 		\
									conference_terminate_response_chosen
#define CONFERENCE_EJECT_USER_RESPONSE_CHOSEN		\
									conference_eject_user_response_chosen
#define CONFERENCE_TRANSFER_RESPONSE_CHOSEN 		\
									conference_transfer_response_chosen
#define REGISTRY_RESPONSE_CHOSEN 					\
									registry_response_chosen
#define REGISTRY_ALLOCATE_HANDLE_RESPONSE_CHOSEN 	\
									registry_allocate_handle_response_chosen
#define FUNCTION_NOT_SUPPORTED_RESPONSE_CHOSEN 		\
									function_not_supported_response_chosen
#define NON_STANDARD_RESPONSE_CHOSEN 				\
									non_standard_response_chosen

/*
 *	IndicationPDU
 */
#define USER_ID_INDICATION_CHOSEN 						\
									user_id_indication_chosen
#define CONFERENCE_LOCK_INDICATION_CHOSEN 				\
									conference_lock_indication_chosen
#define CONFERENCE_UNLOCK_INDICATION_CHOSEN 			\
									conference_unlock_indication_chosen
#define CONFERENCE_TERMINATE_INDICATION_CHOSEN 			\
									conference_terminate_indication_chosen
#define CONFERENCE_EJECT_USER_INDICATION_CHOSEN 		\
									conference_eject_user_indication_chosen
#define CONFERENCE_TRANSFER_INDICATION_CHOSEN 			\
									conference_transfer_indication_chosen
#define ROSTER_UPDATE_INDICATION_CHOSEN 				\
									roster_update_indication_chosen
#define APPLICATION_INVOKE_INDICATION_CHOSEN 			\
									application_invoke_indication_chosen
#define REGISTRY_MONITOR_ENTRY_INDICATION_CHOSEN 		\
									registry_monitor_entry_indication_chosen
#define CONDUCTOR_ASSIGN_INDICATION_CHOSEN 				\
									conductor_assign_indication_chosen
#define CONDUCTOR_RELEASE_INDICATION_CHOSEN 			\
									conductor_release_indication_chosen
#define CONDUCTOR_PERMISSION_ASK_INDICATION_CHOSEN 		\
									conductor_permission_ask_indication_chosen
#define CONDUCTOR_PERMISSION_GRANT_INDICATION_CHOSEN 	\
									conductor_permission_grant_indication_chosen
#define CONFERENCE_TIME_REMAINING_INDICATION_CHOSEN 	\
									conference_time_remaining_indication_chosen
#define CONFERENCE_TIME_INQUIRE_INDICATION_CHOSEN 		\
									conference_time_inquire_indication_chosen
#define CONFERENCE_TIME_EXTEND_INDICATION_CHOSEN 		\
									conference_time_extend_indication_chosen
#define CONFERENCE_ASSISTANCE_INDICATION_CHOSEN 		\
									conference_assistance_indication_chosen
#define TEXT_MESSAGE_INDICATION_CHOSEN 					\
									text_message_indication_chosen
#define NON_STANDARD_INDICATION_CHOSEN 					\
									non_standard_indication_chosen

/*
 *	GCCPDU
 */
#define REQUEST_CHOSEN 						request_chosen
#define RESPONSE_CHOSEN 					response_chosen
#define INDICATION_CHOSEN 					indication_chosen


/*
 * 	Typedefs for enumerated types generated in "gccpdu.h".
 */

/*
 *	Typedefs for Privilege enumerations.
 */
#define TERMINATE								terminate
#define EJECT_USER								ejectUser
#define ADD										add
#define LOCK_UNLOCK								lockUnlock
#define TRANSFER								transfer

/*
 *	Typedefs for TerminationMethod enumerations.
 */
#define AUTOMATIC								automatic
#define MANUAL									manual

/*
 *	Typedefs for NodeType enumerations.
 */
#define TERMINAL            					terminal
#define MULTIPORT_TERMINAL						multiportTerminal
#define MCU										mcu

/*
 *	Typedefs for ChannelType enumerations.
 */
#define CHANNEL_TYPE_STATIC            			ChannelType_static
#define DYNAMIC_MULTICAST						dynamicMulticast
#define DYNAMIC_PRIVATE							dynamicPrivate
#define DYNAMIC_USER_ID							dynamicUserId

/*
 *	Typedefs for RegistryModificationRights enumerations.
 */
#define OWNER			            		owner
#define SESSION								session
#define REGISTRY_MODIFY_RIGHTS_PUBLIC		RegistryModiFicationRights_public

/*
 *	Typedefs for ConferenceCreateResult enumerations.
 */
#define CCRS_RESULT_SUCCESS	            	ConferenceCreateResult_success
#define CCRS_USER_REJECTED					ConferenceCreateResult_userRejected
#define RESOURCES_NOT_AVAILABLE				resourcesNotAvailable
#define REJECTED_FOR_SYMMETRY_BREAKING		rejectedForSymmetryBreaking
#define LOCKED_CONFERENCE_NOT_SUPPORTED		lockedConferenceNotSupported

/*
 *	Typedefs for ConferenceQueryResult enumerations.
 */
#define CQRS_RESULT_SUCCESS	            	ConferenceQueryResult_success
#define CQRS_USER_REJECTED					ConferenceQueryResult_userRejected

/*
 *	Typedefs for ConferenceJoinResult enumerations.
 */
#define CJRS_RESULT_SUCCESS	            	ConferenceJoinResult_success
#define CJRS_USER_REJECTED					ConferenceJoinResult_userRejected
#define INVALID_CONFERENCE					invalidConference
#define INVALID_PASSWORD					invalidPassword
#define INVALID_CONVENER_PASSWORD			invalidConvenerPassword
#define CHALLENGE_RESPONSE_REQUIRED			challengeResponseRequired
#define INVALID_CHALLENGE_RESPONSE			invalidChallengeResponse

/*
 *	Typedefs for ConferenceInviteResult enumerations.
 */
#define CIRS_RESULT_SUCCESS	            	ConferenceInviteResult_success
#define CIRS_USER_REJECTED					ConferenceInviteResult_userRejected

/*
 *	Typedefs for ConferenceAddResult enumerations.
 */
#define CARS_SUCCESS	            		ConferenceAddResult_success
#define CARS_INVALID_REQUESTER				ConferenceAddResult_invalidRequester
#define INVALID_NETWORK_TYPE				invalidNetworkType
#define INVALID_NETWORK_ADDRESS				invalidNetworkAddress
#define ADDED_NODE_BUSY						addedNodeBusy
#define NETWORK_BUSY						networkBusy
#define NO_PORTS_AVAILABLE					noPortsAvailable
#define CONNECTION_UNSUCCESSFUL				connectionUnsuccessful

/*
 *	Typedefs for ConferenceLockResult enumerations.
 */
#define CLRS_SUCCESS	            		ConferenceLockResult_success
#define CLRS_INVALID_REQUESTER			ConferenceLockResult_invalidRequester
#define CLRS_ALREADY_LOCKED				alreadyLocked

/*
 *	Typedefs for ConferenceUnlockResult enumerations.
 */
#define CURS_SUCCESS	            	ConferenceUnlockResult_success
#define CURS_INVALID_REQUESTER		ConferenceUnlockResult_invalidRequester
#define CURS_ALREADY_UNLOCKED		   alreadyUnlocked

/*
 *	Typedefs for ConferenceTerminateRequestReason enumerations.
 */
#define CTRQ_REASON_USER_INITIATED	 		ConferenceTerminateRequestReason_userInitiated
#define CTRQ_TIMED_CONFERENCE_TERMINATE		ConferenceTerminateRequestReason_timedConferenceTermination

/*
 *	Typedefs for ConferenceTerminateResult enumerations.
 */
#define CTRS_RESULT_SUCCESS	 			ConferenceTerminateResult_success
#define CTRS_INVALID_REQUESTER			ConferenceTerminateResult_invalidRequester

/*
 *	Typedefs for ConferenceTerminateIndicationReason enumerations.
 */
#define CTIN_REASON_USER_INITIATED			ConferenceTerminateIndicationReason_userInitiated
#define CTIN_TIMED_CONFERENCE_TERMINATE		ConferenceTerminateIndicationReason_timedConferenceTermination

/*
 *	Typedefs for ConferenceEjectRequestReason enumerations.
 */
#define CERQ_REASON_USER_INITIATED		ConferenceEjectRequestReason_userInitiated

/*
 *	Typedefs for ConferenceEjectResult enumerations.
 */
#define CERS_RESULT_SUCCESS	 		ConferenceEjectResult_success
#define CERS_INVALID_REQUESTER		ConferenceEjectResult_invalidRequester
#define	CERS_INVALID_NODE			invalidNode

/*
 *	Typedefs for ConferenceEjectIndicationReason enumerations.
 */
#define CEIN_USER_INITIATED			ConferenceEjectIndicationReason_userInitiated
#define HIGHER_NODE_DISCONNECTED	higherNodeDisconnected
#define HIGHER_NODE_EJECTED			higherNodeEjected

/*
 *	Typedefs for ConferenceTransferResult enumerations.
 */
#define CTRANS_RESULT_SUCCESS				ConferenceTransferResult_success
#define CTRANS_RESULT_INVALID_REQUESTER		ConferenceTransferResult_invalidRequester

/*
 *	Typedefs for RegistryAllocateHandleResult enumerations.
 */
#define RARS_RESULT_SUCCESS	 		RegistryAllocateHandleResult_successful
#define NO_HANDLES_AVAILABLE		noHandlesAvailable

/*
 *	Typedefs for RegistryResponsePrimitiveType enumerations.
 */
#define REGISTER_CHANNEL	 		registerChannel
#define ASSIGN_TOKEN				assignToken
#define SET_PARAMETER				setParameter
#define RETRIEVE_ENTRY				retrieveEntry
#define DELETE_ENTRY				deleteEntry
#define MONITOR_ENTRY				monitorEntry

/*
 *	Typedefs for RegistryResponseResult enumerations.
 */
#define RRRS_RESULT_SUCCESSFUL	 		RegistryResponseResult_successful
#define BELONGS_TO_OTHER				belongsToOther
#define TOO_MANY_ENTRIES				tooManyEntries
#define INCONSISTENT_TYPE				inconsistentType
#define ENTRY_NOT_FOUND					entryNotFound
#define ENTRY_ALREADY_EXISTS			entryAlreadyExists
#define RRRS_INVALID_REQUESTER			RegistryResponseResult_invalidRequester


/*
 *	Typedefs for pointers to GCC Connect PDU structures.
 */
typedef	ConferenceCreateRequest			*	PConferenceCreateRequest;
typedef	ConferenceCreateResponse		*	PConferenceCreateResponse;
typedef	ConferenceQueryRequest			*	PConferenceQueryRequest;
typedef	ConferenceQueryResponse			*	PConferenceQueryResponse;
typedef	ConferenceJoinRequest			*	PConferenceJoinRequest;
typedef	ConferenceJoinResponse			*	PConferenceJoinResponse;
typedef	ConferenceInviteRequest			*	PConferenceInviteRequest;
typedef	ConferenceInviteResponse		*	PConferenceInviteResponse;

/*
 *	Typedefs for pointers to GCC Request PDU structures.
 */
typedef	ConferenceTerminateRequest		*	PConferenceTerminateRequest;
typedef	ConferenceEjectUserRequest		*	PConferenceEjectUserRequest;
typedef	ConferenceTransferRequest		*	PConferenceTransferRequest;
typedef ConferenceAddRequest			*	PConferenceAddRequest;


/*
 *	Typedefs for pointers to GCC Response PDU structures.
 */
typedef	ResponsePDU						*	PResponsePDU;
typedef	ConferenceAddResponse			*	PConferenceAddResponse;
typedef	ConferenceLockResponse			*	PConferenceLockResponse;
typedef	ConferenceUnlockResponse		*	PConferenceUnlockResponse;
typedef	ConferenceTerminateResponse		*	PConferenceTerminateResponse;
typedef	ConferenceEjectUserResponse		*	PConferenceEjectUserResponse;
typedef	ConferenceTransferResponse		*	PConferenceTransferResponse;
typedef	RegistryResponse				*	PRegistryResponse;
typedef	RegistryAllocateHandleRequest	*	PRegistryAllocateHandleRequest;
typedef	RegistryAllocateHandleResponse	*	PRegistryAllocateHandleResponse;
typedef	FunctionNotSupportedResponse	*	PFunctionNotSupportedResponse;
typedef	NonStandardPDU					*	PNonStandardPDU;

/*
 *	Typedefs for pointers to GCC Indication PDU structures.
 */
typedef IndicationPDU					*	PIndicationPDU;
typedef	UserIDIndication				*	PUserIDIndication;
typedef	ConferenceLockIndication		*	PConferenceLockIndication;
typedef	ConferenceUnlockIndication		*	PConferenceUnlockIndication;
typedef	ConferenceTerminateIndication	*	PConferenceTerminateIndication;
typedef	ConferenceEjectUserIndication	*	PConferenceEjectUserIndication;
typedef	ConferenceTransferIndication	*	PConferenceTransferIndication;
typedef	RosterUpdateIndication			*	PRosterUpdateIndication;
typedef	ApplicationInvokeIndication		*	PApplicationInvokeIndication;
typedef	RegistryMonitorEntryIndication	*	PRegistryMonitorEntryIndication;
typedef	ConductorAssignIndication		*	PConductorAssignIndication;
typedef	ConductorReleaseIndication		*	PConductorReleaseIndication;
typedef	ConductorPermissionAskIndication
								*	PConductorPermissionAskIndication;
typedef	ConductorPermissionGrantIndication
								*	PConductorPermissionGrantIndication;
typedef	ConferenceTimeRemainingIndication
								*	PConferenceTimeRemainingIndication;
typedef	ConferenceTimeInquireIndication
								*	PConferenceTimeInquireIndication;
typedef	ConferenceTimeExtendIndication	*	PConferenceTimeExtendIndication;
typedef	ConferenceAssistanceIndication	*	PConferenceAssistanceIndication;
typedef	TextMessageIndication			*	PTextMessageIndication;

/*
 *	Typedef for a pointer to the main GCC PDU structure.
 */
typedef	GCCPDU							*	PGCCPDU;
typedef	ConnectGCCPDU					*	PConnectGCCPDU;
typedef ConnectData						*	PConnectData;

/*
 *	Typedef for pointers to password structures.
 */
typedef	Password									*	PPassword;
typedef	PasswordSelector							*	PPasswordSelector;
typedef	PasswordChallengeRequestResponse			
									*	PPasswordChallengeRequestResponse;
typedef	ChallengeRequest							*	PChallengeRequest;
typedef	ChallengeResponse							*	PChallengeResponse;
typedef	ChallengeResponseAlgorithm	*	PChallengeResponseAlgorithm;

/*
 *	Typedefs for other PDU structures.
 */
typedef		ASN1objectidentifier_t              ObjectID;
typedef	    ASN1objectidentifier_s				SetOfObjectID;
typedef		ASN1objectidentifier_t				PSetOfObjectID;
typedef SetOfNodeRecordRefreshes		*		PSetOfNodeRecordRefreshes;
typedef SetOfNodeRecordUpdates			*		PSetOfNodeRecordUpdates;

typedef ParticipantsList				*		PParticipantsList;
typedef NodeType						*		PNodeType;
typedef NodeProperties					*		PNodeProperties;
typedef NodeRecord						*		PNodeRecord;
typedef Key								* 		PKey;
typedef SessionKey						* 		PSessionKey;
typedef ChallengeItem					* 		PChallengeItem;
typedef SetOfChallengeItems		*			PSetOfChallengeItems;

typedef SetOfConferenceDescriptors	*		PSetOfConferenceDescriptors;

typedef NetworkAddress				*		PNetworkAddress;
typedef TransferModes				*		PTransferModes;

typedef HighLayerCompatibility				*		PHighLayerCompatibility;

/*
 * Application related typedefs.
 */
typedef NodeInformation		*					PNodeInformation;

typedef SetOfApplicationRecordRefreshes		* PSetOfApplicationRecordRefreshes;


typedef SetOfApplicationCapabilityRefreshes		*	
										PSetOfApplicationCapabilityRefreshes;

typedef ApplicationRecord				*	PApplicationRecord;

typedef CapabilityID				*	PCapabilityID;

typedef SetOfNonCollapsingCapabilities	*	PSetOfNonCollapsingCapabilities;

typedef RegistryKey				*	PRegistryKey;
typedef RegistryItem			*	PRegistryItem;

typedef PermissionList		*						PPermissionList;

typedef WaitingList		*							PWaitingList;

typedef SetOfDestinationNodes	*	PSetOfDestinationNodes;

typedef ApplicationProtocolEntityList	*		PApplicationProtocolEntityList;
typedef SetOfExpectedCapabilities	*			PSetOfExpectedCapabilities;
												
												
typedef	SetOfTransferringNodesRq	*	PSetOfTransferringNodesRq;

typedef	SetOfTransferringNodesRs	*	PSetOfTransferringNodesRs;

typedef	SetOfTransferringNodesIn	*	PSetOfTransferringNodesIn;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\privchnl.h ===
/*
 *	privchnl.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the PrivateChannel class.  Objects of
 *		this class represent private channels in the MCS environment.  This
 *		class inherits much of its behavior from class Channel.  However,
 *		objects of this class maintain a list of authorized users, and do not
 *		allow any other users to use the channel.  Users that are not part
 *		of the authorized user list may not join the channel, nor may they
 *		even send data on the channel.
 *
 *		Private channels are created as the result of a user issuing a
 *		channel convene request.  This user is known as the channel manager.
 *		Only the channel manager may modify the authorized user list, and
 *		only the channel manager may destroy (disband) the private channel.
 *
 *		The channel adds users to the authorized user list by issuing a
 *		channel admit request.  Users are removed from this list when the
 *		channel manager issues a channel expel request.
 *
 *		Private channel objects will exist in the information base of all
 *		providers who contain either an admitted user or the channel
 *		manager in their sub-tree.  Requests pass upward to the Top Provider
 *		who issues the appropriate indications downward to manage the
 *		information base synchronization process.
 *
 *		Private channel objects restrict the joining of channel by overriding
 *		the join commands.  They restrict the transmission of data by
 *		overriding the send data commands.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_PRIVATECHANNEL_
#define	_PRIVATECHANNEL_


/*
 *	This is the class definition for the PrivateChannel class.
 */
class	PrivateChannel : public Channel
{
public:
	PrivateChannel (
			ChannelID			channel_id,
			UserID				channel_manager,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list);
	PrivateChannel (
			ChannelID			channel_id,
			UserID				channel_manager,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list,
			CUidList           *admitted_list,
			PConnection         pConn);
    virtual					~PrivateChannel ();
		virtual Channel_Type	GetChannelType ();
		virtual	BOOL    		IsValid ();
		virtual CAttachment *GetAttachment(void);
		virtual	Void			IssueMergeRequest ();
		virtual Void			ChannelJoinRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id);
		Void			ChannelDisbandRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id);
		Void			ChannelDisbandIndication (
										ChannelID			channel_id);
		Void			ChannelAdmitRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id,
										CUidList           *user_id_list);
		Void			ChannelAdmitIndication (
										PConnection         originator,
										UserID				uidInitiator,
										ChannelID			channel_id,
										CUidList           *user_id_list);
		Void			ChannelExpelRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id,
										CUidList           *user_id_list);
		Void			ChannelExpelIndication (
										PConnection         originator,
										ChannelID			channel_id,
										CUidList           *user_id_list);
		virtual Void			SendDataRequest (
										CAttachment        *originator,
										UINT				type,
										PDataPacket			data_packet);
	private:
				BOOL    		ValidateUserID (
										UserID				user_id);
				Void			BuildAttachmentLists (
										CUidList            *user_id_list,
										CAttachmentList     *local_attachment_list,
										CAttachmentList     *remote_attachment_list);
				Void			BuildUserIDList (
										CUidList           *user_id_list,
										CAttachment        *attachment,
										CUidList           *user_id_subset);

private:

	UserID					m_uidChannelManager;
	CUidList				m_AuthorizedUserList;
	BOOL    				m_fDisbandRequestPending;
};

/*
 *	PrivateChannel (
 *			ChannelID			channel_id,
 *			UserID				channel_manager,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list)
 *
 *	Functional Description:
 *		This is the normal constructor for the PrivateChannel class.  It simply
 *		initializes the instance variables that identify the channel, the local
 *		provider, the top provider, and the channel manager.  The attachment
 *		list is empty by default (meaning that no users have joined the
 *		channel).  The authorized user list is also empty by default.
 *
 *		Upon successful construction of this object, a channel convene confirm
 *		is automatically issued to the channel manager, if it is in the
 *		sub-tree of this provider.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		channel_manager (i)
 *			This is the user ID of the channel manager.  Only this user is
 *			permitted to expand or reduce the size of the authorized user list.
 *		local_provider (i)
 *			This is the identity of the local provider.  A PrivateChannel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			PrivateChannel object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	PrivateChannel (
 *			ChannelID			channel_id,
 *			UserID				channel_manager,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list,
 *			CUidList           *admitted_list,
 *			PCommandTarget		attachment)
 *
 *	Functional Description:
 *		This is a secondary version of the constructor that is used only during
 *		merge operations.  The only difference between this one and the one
 *		above is that this one allows the specification of an initial
 *		attachment.  This allows a PrivateChannel object to be constructed with
 *		an attachment already joined to the channel.
 *
 *		This version of the constructor will not issue a channel convene confirm
 *		or a channel join confirm to the user.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		channel_manager (i)
 *			This is the user ID of the channel manager.  Only this user is
 *			permitted to expand or reduce the size of the authorized user list.
 *		local_provider (i)
 *			This is the identity of the local provider.  A PrivateChannel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			PrivateChannel object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *		admitted_list (i)
 *			This is a list of users that are admitted to the channel at the
 *			time of the merge.
 *		attachment (i)
 *			This is the initial attachment for the channel.  A channel join
 *			confirm is NOT issued to the attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~PrivateChannel ()
 *
 *	Functional Description:
 *		This is the PrivateChannel class destructor.  It does nothing at this
 *		time.  The base class constructor takes care of clearing the attachment
 *		list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Channel_Type	GetChannelType ()
 *
 *	Functional Description:
 *		This virtual member function returns the type of the channel.  For this
 *		class it will always be PRIVATE_CHANNEL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		PRIVATE_CHANNEL
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	BOOL    	IsValid ()
 *
 *	Functional Description:
 *		This function will return TRUE until the channel is disbanded.  Then
 *		it will return FALSE to indicate that the channel object can be deleted
 *		from the domain infirmation base.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE if channel still valid.
 *		FALSE if the channel has been disbanded.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CAttachment *GetAttachment ()
 *
 *	Functional Description:
 *		This function returns the attachment which leads to the private channel
 *		manager.  If the channel manager is not in the sub-tree of this
 *		provider, it returns NULL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		Attachment that leads to channel manager, or NULL if channel manager is
 *		not in the sub-tree of this provider.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		IssueMergeRequest ()
 *
 *	Functional Description:
 *		This member function causes the PrivateChannel object to issue a merge
 *		request to the top provider.  It will pack the appropriate local
 *		information into the command.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelJoinRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to join the private channel
 *		associated with a PrivateChannel object.  The originator of the request
 *		will only be permitted to join if their user ID is contained in the
 *		authorized user list,  If it does, then the originator will be permitted
 *		to join.
 *
 *		If this provider is not the Top Provider, then the request will be
 *		forwarded upward to the Top Provider.  If this is the Top Provider,
 *		the a channel join confirm will be issued back to the requesting
 *		user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user joining the channel.  This must
 *			be contained in  the authorized user list maintained by the object,
 *			or the request will automatically be rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelDisbandRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to destroy an existing
 *		private channel.  This is only permitted if the operation is invoked
 *		by the manager of the specified private channel.
 *
 *		If this provider is not the Top Provider, then the request will be
 *		forwarded upward to the Top Provider.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user disbanding the channel.  This must
 *			be the same as the user ID of the private channel manager, or the
 *			request will automatically be rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelDisbandIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when the Top Provider determines the need to
 *		destroy a private channel.  This may be done in response to a
 *		disband request from the channel manager, or it may be done for
 *		other reasons (such as the channel manager detaching from the domain).
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelAdmitRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to expand the authorized
 *		user list of a private channel.  This operation will only be permitted
 *		if the uidInitiator is the same as the user ID of the private channel
 *		manager.
 *
 *		If this is the Top Provider, this request will be serviced locally,
 *		resulting in the transmission of a channel admit indication to all
 *		downward attachments that contain an admitted user in their sub-tree.
 *		If this is not the Top Provider, ths request will forwarded toward
 *		the Top Provider once the request has been validated.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user who is attempting to add users to
 *			the authorized user list.  This must be the same as the user ID
 *			represented by the object, or the request will automatically be
 *			rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *		user_id_list (i)
 *			This is a list containing the IDs of the users to added to the
 *			user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelAdmitIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This function is invoked by the Top Provider upon reception of a
 *		channel admit request from the legitimate manager of a private channel.
 *		It travels downward toward any providers that contain an admitted user
 *		in their sub-tree.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user who is attempting to add users to
 *			the authorized user list.  This must be the same as the user ID
 *			represented by the object, or the request will automatically be
 *			rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *		user_id_list (i)
 *			This is a list containing the IDs of the users to added to the
 *			user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelExpelRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to shrink the authorized
 *		user list of a private channel.  This operation will only be permitted
 *		if the uidInitiator is the same as the user ID of the private channel
 *		manager.
 *
 *		If this is the Top Provider, this request will be serviced locally,
 *		resulting in the transmission of a channel admit indication to all
 *		downward attachments that contain an admitted user in their sub-tree.
 *		If this is not the Top Provider, ths request will forwarded toward
 *		the Top Provider once the request has been validated.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user who is attempting to remove users
 *			from the authorized user list.  This must be the same as the user ID
 *			represented by the object, or the request will automatically be
 *			rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *		user_id_list (i)
 *			This is a list containing the IDs of the users to removed from the
 *			user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelExpelIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This function is invoked by the Top Provider upon reception of a
 *		channel expel request from the legitimate manager of a private channel.
 *		It travels downward toward any providers that contain (or used to
 *		contain) an admitted user in their sub-tree.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which this command originated.
 *		uidInitiator (i)
 *			This is the user ID of the user who is attempting to remove users
 *			from the authorized user list.  This must be the same as the user ID
 *			represented by the object, or the request will automatically be
 *			rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *		user_id_list (i)
 *			This is a list containing the IDs of the users to removed from the
 *			user list.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SendDataRequest (
 *						PCommandTarget		originator,
 *						UINT				type,
 *						PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This function is called when it is necessary to send data through the
 *		channel that this PrivateChannel object represents.  The identity of
 *		the requesting user will be validated to make sure the user is allowed
 *		to send data on the private channel.  If so, then the request is
 *		passed to the Channel class SendDataRequest to be processed.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the data came.
 *		type (i)
 *			Normal or uniform send data request.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\privlist.h ===
/*
 *	privlist.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the header file for the class PrivilegeListData.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_PRIVILEGE_LIST_DATA_
#define	_PRIVILEGE_LIST_DATA_


typedef enum
{
	TERMINATE_PRIVILEGE,
	EJECT_USER_PRIVILEGE,
	ADD_PRIVILEGE,
	LOCK_UNLOCK_PRIVILEGE,
	TRANSFER_PRIVILEGE
} ConferencePrivilegeType;
typedef	ConferencePrivilegeType	*	PConferencePrivilegeType;


class 	PrivilegeListData;
typedef	PrivilegeListData 	*	PPrivilegeListData;


class PrivilegeListData
{
public:

	PrivilegeListData(PGCCConferencePrivileges);
	PrivilegeListData(PSetOfPrivileges);
	~PrivilegeListData(void);

	PGCCConferencePrivileges GetPrivilegeListData(void) { return &Privilege_List; }
	void GetPrivilegeListData(PGCCConferencePrivileges *pp) { *pp = &Privilege_List; }

	GCCError	GetPrivilegeListPDU(PSetOfPrivileges *);
	void		FreePrivilegeListPDU(PSetOfPrivileges);
	BOOL    	IsPrivilegeAvailable(ConferencePrivilegeType);

protected:

	GCCConferencePrivileges		Privilege_List;
	BOOL        				Privilege_List_Free_Flag;
};
typedef	PrivilegeListData 	*		PPrivilegeListData;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\pktcoder.h ===
/*
 *	pktcoder.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the PacketCoder class.  This
 *		is an abstract base class which cannot be directly instantiated, but 
 *		rather, exists to be inherited from.  It defines  a set of virtual 
 *		member functions which will be shared by all classes that inherit from 
 *		this one.  This class defines the behaviors necessary to encode, 
 *		decode, and manipulate Protocol Data Unit (PDU) structures.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		John B. O'Nan
 */
#ifndef	_PACKETCODER_
#define	_PACKETCODER_

/*
 * Macros.
 */
#define		BASIC_ENCODING_RULES	0
#define		PACKED_ENCODING_RULES	1

/*
 *	This enumeration defines the various errors that can be returned during
 *	the use of a PacketCoder object.
 */
typedef	enum
{
	PACKET_CODER_NO_ERROR,
	PACKET_CODER_BAD_REVERSE_ATTEMPT,
	PACKET_CODER_INCOMPATIBLE_PROTOCOL
} PacketCoderError;
typedef	PacketCoderError *		PPacketCoderError;


/*
 *	This is the class definition for class PacketCoder
 */
class	PacketCoder
{
	public:
		virtual			~PacketCoder ();
		virtual	BOOL	Encode (LPVOID			pdu_structure,
								int				pdu_type,
								UINT			rules_type,
								LPBYTE			*encoding_buffer,
								UINT			*encoding_buffer_length) = 0;

		virtual BOOL	Decode (LPBYTE			encoded_buffer,
								UINT			encoded_buffer_length,
								int				pdu_type,
								UINT			rules_type,
								LPVOID			*pdecoding_buffer,
								UINT			*pdecoding_buffer_length) = 0;

		virtual DBBoolean IsMCSDataPacket (	LPBYTE			encoded_buffer,
											UINT			rules_type) = 0;
		virtual void	FreeEncoded (LPBYTE encoded_buffer) = 0;

		virtual void	FreeDecoded (int pdu_type, LPVOID decoded_buffer) = 0;

};
typedef PacketCoder *	PPacketCoder;

/*
 *	~PacketCoder ()
 *
 *	Functional Description:
 *		This is a virtual destructor.  It does not actually do anything in this
 *		class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void Encode (	LPVOID		pdu_structure,
 *					int			pdu_type,
 *					LPBYTE		*encoding_buffer,
 *					UINT		*encoding_buffer_length)
 *
 *	Functional Description:
 *		This function encodes Protocol data units (PDU's) into ASN.1 compliant
 *		byte streams.
 *		The coder allocates the buffer space for the encoded data.
 *
 *	Formal Parameters:
 *		pdu_structure (i)		Pointer to structure holding PDU data.
 *		pdu_type (i)			Define indicating type of PDU.
 *		encoding_buffer (o)		Pointer to buffer to hold encoded data.
 *		encoding_buffer_length (o) Pointer to length of buffer for encoded data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void Decode (	LPBYTE		encoded_buffer,
 *					UINT		encoded_buffer_length,
 *					int			pdu_type,
 *					LPVOID		decoding_buffer,
 *					UINT		decoding_buffer_length,
 *					UINT		*pulDataOffset)
 *
 *	Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate PDU structures.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding data to decode.
 *		encoded_buffer_length (i) Length of buffer holding data to decode.
 *		pdu_type (o)			Returns type of PDU.
 *		decoding_buffer (o)		Pointer to buffer to hold the decoded data.
 *		decoding_buffer_length (i) Length of buffer to hold the decoded data.
 *		pulDataOffset (o)		Pointer to a value that stores the offset of the data in an encoded MCS data packet.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void	CopyDecodedData (	LPVOID		pdu_source_structure,
 *								LPVOID		pdu_destination_structure,
 *								int			pdu_type)
 *
 *	Functional Description:
 *		This function makes a copy of the non-encoded PDU structure.  It returns
 *		the length of the structure it has created.  Normally, this will just
 *		be the length of the source structure but the length is returned for
 *		added flexibility later.
 *
 *	Formal Parameters:
 *		pdu_source_structure(i)			Pointer to structure holding PDU data.
 *		pdu_destination_structure(o)	Pointer to structure to hold copy of
 *										PDU data.
 *		pdu_type (i)					The type of PDU to copy.
 *
 *	Return Value:
 *		Size of the destination PDU structure.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	DBBoolean	IsMCSDataPacket ()
 *
 *	Functional Description:
 *		This function determines whether the encoded packet is an MCS Data packet
 *		or not.
 *
 *	Formal Parameters:
 *		encoded_buffer (i)		Pointer to buffer holding the encoded PDU.
 *		rules_type (i)			The used encoding rules.
 *
 *	Return value:
 *		TRUE, if the packet is an MCS Data packet. FALSE, otherwise.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\regitem.h ===
/*
 *	regitem.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CRegItem.  This class 
 *		manages the data associated with a Registry Item.  Registry Items are
 *		used to identify a particular entry in the application registry and
 *		may exist in the form of a Channel ID, a Token ID, or an octet string 
 *		parameter.  A CRegItem object holds the data for the first two 
 *		forms in a ChannelID and a TokeID, respectively.  When the registry item
 *		assumes the octet string parameter form, the data is held internally in
 *		a Rogue Wave string object.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_REGISTRY_ITEM_
#define	_REGISTRY_ITEM_


/*
 * Class definition:
 */
class CRegItem : public CRefCount
{
public:

    CRegItem(PGCCRegistryItem, PGCCError);
    CRegItem(PRegistryItem, PGCCError);
    CRegItem(CRegItem *, PGCCError);
    ~CRegItem(void);

	UINT			GetGCCRegistryItemData(PGCCRegistryItem, LPBYTE memory);

	UINT			LockRegistryItemData(void);
	void			UnLockRegistryItemData(void);

	void    		GetRegistryItemDataPDU(PRegistryItem);
	void			FreeRegistryItemDataPDU(void);

    GCCError        CreateRegistryItemData(PGCCRegistryItem *);

    BOOL IsThisYourTokenID(TokenID nTokenID)
    {
        return ((m_eItemType == GCC_REGISTRY_TOKEN_ID) && (nTokenID == m_nTokenID));
    }

	void			operator= (const CRegItem&);

protected:

	GCCRegistryItemType		m_eItemType;
	ChannelID   			m_nChannelID;
	TokenID					m_nTokenID;
	LPOSTR					m_poszParameter;
    UINT					m_cbDataSize;

    RegistryItem 			m_RegItemPDU;
	BOOL    				m_fValidRegItemPDU;
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CRegItem (	PGCCRegistryItem	registry_item,
 *						PGCCError			return_value);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This is the constructor for the CRegItem class which takes as
 *		input the "API" version of registry item data, GCCRegistryItem.
 *
 *	Formal Parameters:
 *		registry_item		(i)	The registry item data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CRegItem (	PRegistryItem		registry_item,
 *						PGCCError			return_value);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This is the constructor for the CRegItem class which takes as
 *		input the "PDU" version of registry item data, RegistryItem.
 *
 *	Formal Parameters:
 *		registry_item		(i)	The registry item data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CRegItem(CRegItem	*registry_item,
 *			PGCCError	return_value);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This is the copy constructor for the CRegItem class which takes
 *		as input another CRegItem object.
 *
 *	Formal Parameters:
 *		registry_item		(i)	The CRegItem object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	~CRegItem();
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This is the destructor for the CRegItem class.  Since all data
 *		maintained by this class is held in automatic private instance
 *		variables, there is no cleanup needed in this destructor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	UINT			GetGCCRegistryItemData (	
 *							PGCCRegistryItem 	registry_item,
 *							LPSTR				memory);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to retrieve the registry item data from the
 *		CRegItem object in the "API" form of a GCCRegistryItem.
 *
 *	Formal Parameters:
 *		registry_item		(o)	The GCCRegistryItem structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	UINT			LockRegistryItemData ();
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory, if any, will be needed to hold any "API" data which
 *		will be referenced by, but not held in, the GCCRegistryItem structure
 *		which is filled in on a call to GetGCCRegistryItemData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCRegistryItemData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCRegistryItem structure
 *		provided as an output parameter to the GetGCCRegistryItemData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeRegistryItemData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CRegItem
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeRegistryItemData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CRegItem object will automatically delete itself when
 *		the FreeRegistryItemData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */
/*
 *	void			UnLockRegistryItemData ();
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeRegistryItemData.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CRegItem
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CRegItem 
 *		object,	it should assume the object to be invalid thereafter.
 */
/*
 *	void		GetRegistryItemDataPDU (	
 *							PRegistryItem 	registry_item);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to retrieve the registry item data from the
 *		CRegItem object in the "PDU" form of a RegistryItem.
 *
 *	Formal Parameters:
 *		registry_item		(o)	The RegistryItem structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void			FreeRegistryItemDataPDU ();
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data for this object.  For
 *		this object, this means setting a flag to indicate that the "PDU" data
 *		for this object is no longer valid.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeRegistryItemData has been made.
 */
/*
 *	BOOL    		IsThisYourTokenID (	
 *							TokenID				token_id);
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified token ID is
 *		held within this registry item object.
 *
 *	Formal Parameters:
 *		token_id			(i)	The token ID to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified token ID is contained within this
 *									registry item object.
 *		FALSE				-	The specified token ID is not contained within
 *									this registry item object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void			operator= (
 *						const CRegItem&		registry_item_data);	
 *
 *	Public member function of CRegItem.
 *
 *	Function Description:
 *		This routine is used to set this CRegItem object to be equal
 *		in value to the specified CRegItem object.
 *
 *	Formal Parameters:
 *		registry_item_data			(i)	The CRegItem object to copy.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The registry item data values for this object are modified by this call.
 *
 *	Caveats:
 *		The "lock" and "free" states for this object are not affected by
 *		this call.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\randchnl.h ===
/*
 *	randchnl.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the RandomChannelGenerator class.  This
 *		class inherits from the RandomNumberGenerator class.  On instantiation,
 *		instances of this class will internally generate a random number which
 *		falls within the allowable range of dynamic channel values.  Channel
 *		assignments are then generated by incrementing this value each time a
 *		new assignment is requested.  Once the maximum allowable value has been
 *		assigned, the next value to be generated "wraps around" to the minimum
 *		allowable value.
 *
 *		Obviously, this class does not generate completely random channel
 *		values for each request.  With a completely random generator, it is
 *		possible to delete a channel in MCS, and then have the random number
 *		generator assign the same value as the deleted channel before all
 *		components of the system even know that the channel was deleted to
 *		start with, thus causing erratic behavior in the system.  In this
 *		class, no channel can be reassigned until all other possible channels
 *		have been assigned.
 *
 *		This class can be modifed in the future to incorporate additional
 *		"randomness" into the algorithm and still not reassign any channel
 *		numbers before all other possible values are used.  This, however,
 *		would be at the expense of performance and/or memory resources.
 *                  
 *	Caveats:
 *		None.
 *
 *	Author:
 *		Alan D. May
 */
#ifndef _RANDOM_CHANNEL_GENERATOR_
#define _RANDOM_CHANNEL_GENERATOR_

#include "databeam.h"
#include "random.h"

/*
 *	The definition of the RandomChannelGenerator class.
 */
class RandomChannelGenerator
{
	public:
						RandomChannelGenerator ();
		virtual			~RandomChannelGenerator ();
		RandomValue		GetRandomChannel ();

	private:
		ULong			Current_Channel;
};		
typedef RandomChannelGenerator *		PRandomChannelGenerator;

/*
 *	RandomChannelGenerator ()
 *
 *	Functional Description:
 *		The constructor creates a random channel generator object by calling the
 *		constructor for the parent class, RandomNumberGenerator.  This then
 *		automatically seeds the random number generator with the current time.
 *		The default algorithm will be used.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~RandomChannelGenerator ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the RandomChannelGenerator class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomValue		GetRandomChannel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This method returns a valid dynamic channel number.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A RandomValue in the range of valid dynamic channel values.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\registry.h ===
/*
 *	registry.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		Instances of this class represent the application registry for a 
 *		single conference.  This is a dual purpose class that is designed 
 *		to support both a Top Provider node and all other nodes.  The 
 *		information base for the application registry is completely contained at 
 *		the Top Provider node. This information is not distributively held at 
 *		all nodes in the conference like roster information.  It is completely 
 *		managed at the Top Provider.  Therefore all requests to alter 
 *		information in the registry or get information from the registry are 
 *		made to the Top Provider.
 *
 *		When an Application Registry object is instantiated it is informed if it 
 *		is the Top Provider or not.  Application Registry objects that are Top 
 *		Providers are responsible for maintaining the registry information base 
 *		for the entire conference.  It is also responsible for servicing all 
 *		incoming requests and sending out the necessary confirms.  Application 
 *		Registry objects that are not Top Providers are responsible for sending 
 *		all requests to the Top Provider node.  They are also responsible for 
 *		issuing confirms to the CAppSap that made the request after receiving the 
 *		responses back from the Top Provider registry.  All Application Registry 
 *		requests include an Entity ID associated with the APE that made the 
 *		request.  Note that all registry requests are processed in the order 
 *		that they are received.  Therefore, there is no need to include 
 *		sequencing data with each request.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef	_APPLICATION_REGISTRY_
#define	_APPLICATION_REGISTRY_

#include "regkey.h"
#include "regitem.h"
#include "arostmgr.h"

/*
**	This list keeps up with all the APEs that are currently monitoring a 
**	registry entry.
*/
class CMonitoringList : public CList
{
    DEFINE_CLIST_(CMonitoringList, EntityID)
};


//	This structure defines a single registry entry
typedef struct
{
	CRegKeyContainer        *registry_key;
	CRegItem                *entry_item;
	GCCModificationRights	modification_rights;
	CMonitoringList			monitoring_list;
	BOOL    				monitoring_state;
	UserID					owner_id;
	EntityID				entity_id;
}
    REG_ENTRY;


//	This list holds all the registry entries
class CRegEntryList : public CList
{
    DEFINE_CLIST(CRegEntryList, REG_ENTRY*)
};


class CRegistry : public CRefCount
{
public:

    CRegistry(PMCSUser, BOOL top_provider, GCCConfID, CAppRosterMgrList *, PGCCError);
    ~CRegistry(void);

    void		EnrollAPE(EntityID, CAppSap *);
	void		UnEnrollAPE(EntityID);

	GCCError	RegisterChannel(PGCCRegistryKey, ChannelID, EntityID);
	GCCError	AssignToken(PGCCRegistryKey, EntityID);
	GCCError	SetParameter(PGCCRegistryKey, LPOSTR, GCCModificationRights, EntityID);
	GCCError	RetrieveEntry(PGCCRegistryKey, EntityID);
	GCCError	DeleteEntry(PGCCRegistryKey, EntityID);
	GCCError	MonitorRequest(PGCCRegistryKey, BOOL enable_delivery, EntityID);
	GCCError	AllocateHandleRequest(UINT cHandles, EntityID);
	GCCError	ProcessRegisterChannelPDU(CRegKeyContainer *, ChannelID, UserID, EntityID);
	GCCError	ProcessAssignTokenPDU(CRegKeyContainer *, UserID, EntityID);
	GCCError	ProcessSetParameterPDU(CRegKeyContainer *, LPOSTR param, GCCModificationRights, UserID, EntityID);
	void		ProcessRetrieveEntryPDU(CRegKeyContainer *, UserID, EntityID);
	void		ProcessDeleteEntryPDU(CRegKeyContainer *, UserID, EntityID);
	void		ProcessMonitorEntryPDU(CRegKeyContainer *, UserID, EntityID);
	void		ProcessRegistryResponsePDU(RegistryResponsePrimitiveType, CRegKeyContainer *, CRegItem *,
							                GCCModificationRights, EntityID eidRequester,
							                UserID uidOwner, EntityID eidOwner, GCCResult);
	void		ProcessMonitorIndicationPDU(CRegKeyContainer *, CRegItem *, GCCModificationRights,
							                UserID uidOwner, EntityID eidOwner);
	void		ProcessAllocateHandleRequestPDU(UINT cHandles, EntityID eidRequester, UserID uidRequester);
	void		ProcessAllocateHandleResponsePDU(UINT cHandles, UINT first_handle, EntityID, GCCResult);
	void		RemoveNodeOwnership(UserID);
	void		RemoveEntityOwnership(UserID, EntityID);
	void		RemoveSessionKeyReference(CSessKeyContainer *);

private:

    REG_ENTRY       *GetRegistryEntry(CRegKeyContainer *);
    TokenID			GetUnusedToken(void);
	GCCError		AddAPEToMonitoringList(CRegKeyContainer *, EntityID, CAppSap *);
    void			RemoveAPEFromMonitoringList(CRegKeyContainer *, EntityID);
	void			SendMonitorEntryIndicationMessage(REG_ENTRY *);

private:

    PMCSUser						m_pMCSUserObject;
	CRegEntryList				    m_RegEntryList;
	BOOL    						m_fTopProvider;
	TokenID							m_nCurrentTokenID;
	GCCConfID					    m_nConfID;
	CRegItem                        *m_pEmptyRegItem;
	CAppSapEidList2                 m_AppSapEidList2;
	UINT							m_nRegHandle;
	CAppRosterMgrList				*m_pAppRosterMgrList;
};
#endif

/*
 *	CRegistry	(
 *					PMCSUser						user_object,
 *					BOOL    						top_provider,
 *					GCCConfID   					conference_id,
 *					CAppRosterMgrList				*app_roster_manager_list,
 *					PGCCError						return_value )
 *
 *	Public Function Description
 *		This is the Application Registry constructor. It is responsible for
 *		initializing all the instance variables used by this class.  It also
 *		creates an Empty Registry Item to pass back in confirms where a real
 *		registry item does not exists.
 *
 *	Formal Parameters:
 *		user_object			-	(i) Pointer to the MCS User Attachment object.
 *		top_provider		-	(i) Flag indicating if this is the Top Provider
 *									node.
 *		conference_id		-	(i)	The Conference ID associated witht this
 *									registry.
 *		app_roster_manager_list	(i)	List holding all of the application
 *									roster managers assoicated with this
 *									conference.  Needed when verifying if
 *									an requesting APE is truly enrolled.
 *		return_value		-	(o)	Any errors that occur in the constructor
 *									are returned here.
 *		
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 * 	~ApplicationRegistry ()
 *
 *	Public Function Description
 *		This is the Application Registry destructor.  It is responsible for
 *		freeing up all the registry data allocated by this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void EnrollAPE(EntityID		entity_id,
 *					CAppSap		*pAppSap)
 *
 *	Public Function Description
 *		This routine is used to inform the application registry of a newly
 *		enrolling APE and its corresponding command target interface.
 *
 *	Formal Parameters:
 *		entity_id		-	(i)	Entity ID associated with the enrolling APE.
 *		pAppSap     	-	(i)	Command Target pointer associated with the
 *								enrolling APE.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	UnEnrollAPE (	EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used to inform the application registry of an 
 *		APE that is unerolling from the conference.
 *
 *	Formal Parameters:
 *		entity_id		-	(i)	Entity ID associated with the unenrolling APE.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		This routine removes ownership from all the entries currently owned by 
 *		the passed in application entity.  It will also remove any outstanding
 *		request for the SAP that unenrolled.
 */
/*
 *	GCCError		RegisterChannel (
 *							PGCCRegistryKey			registry_key,
 *							ChannelID				channel_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to register an MCS channel with this
 *		conferences application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key to associate with channel being
 *								registered (this is "API" data).
 *		channel_id		-	(i)	Channel ID to register.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_INVALID_REGISTRY_KEY	-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The MCS channel being registerd must be determined before this
 *		routine is called.
 */
/*
 *	GCCError			AssignToken (
 *							PGCCRegistryKey			registry_key,
 *							EntityID				entity_id );
 *
 *	Public Function Description
 *		This routine is used by a local APE to register an MCS Token with this
 *		conferences application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key to associate with token being
 *								registered (this is "API" data).
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		The MCS token being registerd is determined by GCC and is therefore
 *		not included in the request.
 */
/*
 *	GCCError		SetParameter (
 *							PGCCRegistryKey			registry_key,
 *							LPOSTR      			parameter_value,
 *							GCCModificationRights	modification_rights,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to register a  parameter with this
 *		conferences application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key		-	(i)	Registry Key to associate with parameter 
 *									being registered (this is "API" data).
 *		parameter_value		-	(i)	Value of the parameter being registered.
 *		modification_rights	-	(i)	Modification rights associated with
 *									parameter being registered.	
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_INVALID_REGISTRY_ITEM	-	Parameter is not valid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError		RetrieveEntry (
 *							PGCCRegistryKey			registry_key,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to obtain an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key		-	(i)	Registry Key associated with item being
 *									retrieved (this is "API" data).
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError	DeleteEntry (
 *							PGCCRegistryKey			registry_key,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to delete an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key		-	(i)	Registry Key associated with item to delete
 *									(this is "API" data).
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError	MonitorRequest (
 *							PGCCRegistryKey			registry_key,
 *							BOOL    				enable_delivery,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to monitor an item that was 
 *		registered with GCC.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		registry_key		-	(i)	Registry Key associated with item to 
 *									monitor (this is "API" data).
 *		enable_delivery		-	(i)	This flag indicates if monitoring is being
 *									turned on or off.
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError			AllocateHandleRequest (	
 *							UINT					number_of_handles,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by a local APE to allocate a specified number of
 *		handles from the application registry.  If this registry object does NOT 
 *		live at the top provider node this class is responsible for 
 *		forwarding the request on up to the top provider.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles to allocate.
 *		entity_id			-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError		ProcessRegisterChannelPDU (
 *							CRegKeyContainer		            *registry_key,
 *							ChannelID				channel_id,
 *							UserID					requester_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register channel PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key associated with channel to
 *								register (this is "PDU" data).
 *		channel_id		-	(i)	Channel ID to register.
 *		requester_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError	ProcessAssignTokenPDU (
 *							CRegKeyContainer		            *registry_key,
 *							UserID					requester_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register token PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key associated with token to register
 *								(this is "PDU" data).
 *		requester_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	GCCError	ProcessSetParameterPDU(
 *							CRegKeyContainer		*registry_key_data,
 *							LPOSTR      			parameter_value,
 *							GCCModificationRights	modification_rights,
 *							UserID					requester_node_id,
 *							EntityID				requester_entity_id)
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process incomming
 *		register parameter PDUs.  It is responsible for returning any
 *		necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry Key associated with parameter to 
 *									register (this is "PDU" data).
 *		parameter_value		-	(i)	Value of the parameter being registered.
 *		modification_rights	-	(i)	Modification rights associated with the
 *									parameter being registered.
 *		requester_node_id	-	(i)	Node ID associated with the APE making the
 *									request.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE making the
 *									request.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error occured.
 *		GCC_BAD_REGISTRY_KEY		-	Specified registry key is invalid.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	ProcessRetrieveEntryPDU (
 *							CRegKeyContainer        *registry_key,
 *							UserID					requester_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to retrieve a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key associated with item to 
 *								retrieve (this is "PDU" data).
 *		requester_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	ProcessDeleteEntryPDU (
 *							CRegKeyContainer        *registry_key,
 *							UserID					requester_id,
 *							EntityID				entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to delete a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key	-	(i)	Registry Key associated with item to 
 *								delete (this is "PDU" data).
 *		requester_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		entity_id		-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void		ProcessMonitorEntryPDU (
 *							CRegKeyContainer        *registry_key_data,
 *							UserID					requester_node_id,
 *							EntityID				requester_entity_id )
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to monitor a registry entry.  It is responsible for returning 
 *		any necessary responses that must be sent back to the requesting node.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry Key associated with item to 
 *									monitor (this is "PDU" data).
 *		requester_node_id	-	(i)	Node ID associated with the APE making the
 *									request.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE making
 *									the request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	ProcessRegistryResponsePDU(
 *					RegistryResponsePrimitiveType	primitive_type,
 *					CRegKeyContainer                *registry_key_data,
 *					CRegItem                        *registry_item_data,
 *					GCCModificationRights			modification_rights,
 *					EntityID						requester_entity_id,
 *					UserID							owner_node_id,
 *					EntityID						owner_entity_id,
 *					GCCResult						result)
 *
 *	Public Function Description
 *		This routine is used by nodes other than the top provider node to 
 *		process registry responses from the top provider.  It is responsible for 
 *		generating any local messages associated with this response.
 *
 *	Formal Parameters:
 *		primitive_type		-	(i)	This parameter defines what type of
 *									registry response this is.
 *		registry_key_data	-	(i)	Registry Key associated with item in
 *									in the response (this is "PDU" data).
 *		registry_item_data	-	(i)	Registry item returned in the response.
 *		modification_rights	-	(i)	Modification rights associated with item
 *									in response (may not be used).
 *		requester_entity_id	-	(i)	Entity ID associated with the APE that 
 *									made the request that generated the 
 *									response.
 *		owner_node_id		-	(i)	Node ID associated with APE that owns the
 *									registry entry returned in the response.
 *		owner_entity_id		-	(i)	Entity ID associated with APE that owns the
 *									registry entry returned in the response.
 *		result				-	(i)	Result of original request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void		ProcessMonitorIndicationPDU (
 *							CRegKeyContainer        *registry_key_data,
 *							CRegItem                *registry_item_data,
 *							GCCModificationRights	modification_rights,
 *							UserID					owner_node_id,
 *							EntityID				owner_entity_id);
 *
 *	Public Function Description
 *		This routine is used by nodes other than the top provider node to 
 *		process registry monitor indications from the top provider.  It is 
 *		responsible for generating any local messages associated with this 
 *		response.
 *
 *	Formal Parameters:
 *		registry_key_data	-	(i)	Registry Key associated with item being
 *									monitored (this is "PDU" data).
 *		registry_item_data	-	(i)	Registry item being monitored.
 *		modification_rights	-	(i)	Modification rights of registry item being
 *									monitored (may not be used).
 *		owner_node_id		-	(i)	Node ID associated with APE that owns the
 *									registry entry returned in the indication.
 *		owner_entity_id		-	(i)	Entity ID associated with APE that owns the
 *									registry entry returned in the indication.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	ProcessAllocateHandleRequestPDU (
 *							UINT					number_of_handles,
 *							EntityID				requester_entity_id,
 *							UserID					requester_node_id)
 *
 *	Public Function Description
 *		This routine is used by the top provider node to process an incomming
 *		request to allocate a number of handles.  It is responsible for 
 *		returning any necessary responses that must be sent back to the 
 *		requesting node.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles to allocate.
 *		requester_node_id	-	(i)	Node ID associated with the APE making the
 *								request.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE making the
 *								request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void		ProcessAllocateHandleResponsePDU (
 *							UINT					number_of_handles,
 *							UINT					first_handle,
 *							EntityID				requester_entity_id,
 *							GCCResult				result)
 *
 *	Public Function Description
 *		This routine is used by a node other than the top provider node to 
 *		process an allocate handle response.  It is responsible for generating 
 *		any local messages associated with this response.
 *
 *	Formal Parameters:
 *		number_of_handles	-	(i)	Number of handles that were allocated.
 *		first_handle		-	(i)	This is the value of the first handle in
 *									the contiguous list of handles.
 *		requester_entity_id	-	(i)	Entity ID associated with the APE that made
 *									the original allocate handle request.
 *		result				-	(i)	Result of allocate handle request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void		RemoveNodeOwnership (
 *							UserID				node_id )
 *
 *	Public Function Description
 *		This routine removes ownership of all the registry entries associated 
 *		with the specified node ID.  These entries become unowned. This request 
 *		should only be made from the top provider node.  This is a local 
 *		operation.
 *
 *	Formal Parameters:
 *		node_id	-	(i) Node ID of node that owns the registry entries to set
 *						to unowned.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	RemoveEntityOwnership (
 *							UserID					node_id,
 *							EntityID				entity_id)
 *
 *	Public Function Description
 *		This routine removes ownership of all the registry entries associated 
 *		with the specified APE.  These entries become unowned. This request 
 *		should only be made from the top provider node.  This is a local 
 *		operation.
 *
 *	Formal Parameters:
 *		node_id	-	(i) Node ID of node that owns the registry entries to set
 *						to unowned.
 *		entity_id-	(i) Entity ID of node that owns the registry entries to set
 *						to unowned.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
/*
 *	void	RemoveSessionKeyReference(CSessKeyContainer *session_key)
 *
 *	Public Function Description
 *		This routine removes all registry entries associated with the
 *		specified session.  This is a local operation.
 *
 *	Formal Parameters:
 *		session_key	-	(i) Session key associated with all the registry 
 *							entries to delete.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\random.h ===
/*
 *	random.h
 *
 *	Copyright (c) 1993-1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the RandomNumberGenerator class.
 *		Instances of this class can generate random numbers within a specifed
 *		range on demand.  Many of these objects can exist at once, and they
 *		will not interfere with each other.
 *                  
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James J. Johnstone IV
 */
#ifndef _RANDOM_
#define _RANDOM_

/*
 *	The data type of the return value of the RandomNumberGenerator class.
 */

typedef	ULong				RandomValue;

#ifdef USE_RANDOM_CLASS

/*
 *	This typedef is an enumeration of all possible random number generation
 *	algorithms and is used when constructing a new random number generator.
 *	See "Numerical Recipes in 'C'" for details as to the difference between
 *	the various algorithms.
 */
typedef	enum
{
	ALGORITHM_RAN1,
	ALGORITHM_RANQD2,
	ALGORITHM_RAN4
} Algorithm;
typedef	Algorithm * 		PAlgorithm;

/*
 *	The default algorithm for the random number generator object.
 */
#define DEFAULT_ALGORITHM	ALGORITHM_RAN1

/*
 *	If specified as the seed value, a random seed will be generated by the 
 *	random number generator.
 */
#define RANDOM_SEED			0

/*
 *	Defines for ran1() algorithm from "Numerical Recipes in 'C'"
 */
#define IA					16807
#define	IM					2147483647L
#define	AM					(1.0/IM)
#define IQ					127773L
#define IR					2836
#define	NTAB				32
#define	NDIV				(1+(IM-1)/NTAB)
#define	EPS					1.2e-7
#define	RNMX				(1.0-EPS)

/*
 *	Defines for ranqd2() algorithm from "Numerical Recipes in 'C'"
 */
#define RANQD2_A			1664525L
#define RANQD2_C			1013904223L

/*
 *	Defines for ranqd2() and ran4() algorithms from "Numerical Recipes in 'C'"
 */
#define	JFLONE				0x3f800000L
#define JFLMSK				0x007fffffL

/*
 *	Defines for the ran4() algorithm from "Numerical Recipes in 'C'"
 */
#define NITER				4

/*
 *	The definition of the RandomNumberGenerator class.
 */
class RandomNumberGenerator
{
	public:
						RandomNumberGenerator ();
						RandomNumberGenerator (
								ULong			seed);
						RandomNumberGenerator (
								Algorithm		algorithm);
						RandomNumberGenerator (
								Algorithm		algorithm,
								ULong			seed);
		virtual			~RandomNumberGenerator ();
		RandomValue		GetRandomNumber (
								RandomValue		lo_extent,
								RandomValue		hi_extent);
		Void			Reseed ();
		Void			Reseed (
								ULong			seed);

	private:
		Void			GenerateSeed (
								ULong			seed);
		Float			RAN1UniformDeviate ();
		Float			RAN4UniformDeviate ();
		Void 			PseudoDESHashing (
								ULong 			*lword, 
								ULong 			*irword);

		Algorithm		Algorithm_In_Use;
		Long			Running_Random_Number;
};		
typedef RandomNumberGenerator *		PRandomNumberGenerator;

/*
 *	RandomNumberGenerator ()
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random number
 *		generator object that has been automatically seeded with the current
 *		time.  The default algorithm will be used.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomNumberGenerator (
 *			ULong	seed)
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random number
 *		generator object which is seeded with the supplied value.  The default
 *		algorithm will be used.
 *
 *	Formal Parameters:
 *		seed (i)
 *			A value used to seed the random number generator.  If the seed value
 *			is zero, the random number generator object will use a random seed
 *			value based on the time. 
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomNumberGenerator (
 *			Algorithm		algorithm)
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random number
 *		generator object that has been automatically seeded with the current
 *		time.  The algorithm specifies the algorithm to be used.
 *
 *	Formal Parameters:
 *		algorithm (i)
 *			The random number generation algorithm to be used.  The parameter
 *			algorithm must be one of the following:
 *	
 *			ALGORITHM_RAN1
 *				A good general purpose algorithm with a rather long period.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				29+ Kops (thousand operations per second).
 *			ALGORITHM_RANQD2
 *				A quick and dirty algorithm.  Use this algorithm if speed is an
 *				issue and the period of the random sequence is unimportant.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				49+ Kops (thousand operations per second).
 *			ALGORITHM_RAN4
 *				A slow algorithm with an exceptionally long period.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				18+ Kops (thousand operations per second).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomNumberGenerator (
 *			Algorithm		algorithm,
 *			ULong			seed)
 *
 *	Functional Description:
 *		This version of the constructor is used to create a random number
 *		generator object which is seeded with the supplied value.  The algorithm
 *		specified the algorithm to be used.
 *
 *	Formal Parameters:
 *		algorithm (i)
 *			The random number generation algorithm to be used.  The parameter
 *			algorithm must be one of the following:
 *	
 *			ALGORITHM_RAN1
 *				A good general purpose algorithm with a rather long period.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				29+ Kops (thousand operations per second).
 *			ALGORITHM_RANQD2
 *				A quick and dirty algorithm.  Use this algorithm if speed is an
 *				issue and the period of the random sequence is unimportant.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				49+ Kops (thousand operations per second).
 *			ALGORITHM_RAN4
 *				A slow algorithm with an exceptionally long period.
 *				This algorithm was benchmarked on a Gateway 2000 486/33C at
 *				18+ Kops (thousand operations per second).
 *		seed (i)
 *			A value used to seed the random number generator.  If the seed value
 *			is zero, the random number generator object will use a random seed
 *			value based on the time. 
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~RandomNumberGenerator ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the RandomNumberGenerator class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	RandomValue		GetRandomNumber (
 *							RandomValue 	lo_extent,
 *							RandomValue		hi_extent)
 *
 *	Public
 *
 *	Functional Description:
 *		This method is used to generate a random number between the 
 *		specified values.
 *
 *	Formal Parameters:
 *		lo_extent (i)
 *			The lowest number you wish to receive.
 *		hi_extent (i)
 *			The highest number you wish to receive.
 *
 *	Return Value:
 *		A RandomValue in the range specified.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		Reseed ()
 *
 *	Public
 *
 *	Functional Description:
 *		This method is used to reseed the random number generator object using
 *		the system time as the seed value.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	Reseed (
 *					ULong		seed)
 *
 *	Public
 *
 *	Functional Description:
 *		This method is used to reseed the random number generator object using
 *		the specified seed value.
 *
 *	Formal Parameters:
 *		seed (i)
 *			A value used to seed the random number generator.  If the seed value
 *			is zero, the random number generator object will use a random seed
 *			value based on the time. 
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif	// USE_RANDOM_CLASS
#endif	// _RANDOM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\sesskey.h ===
/*
 *	sesskey.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CSessKeyContainer.  This class 
 *		manages the data associated with a Session Key. Session Keys are used
 *		to uniquely identify an Application Protocol Session.  The Application
 *		Protocol is identified by an Object Key and the particular session
 *		identified by an optional session ID.  The CSessKeyContainer class uses an
 *		CObjectKey container to maintain the object key data internally.  An
 *		unsigned short integer is used to hold the optional session ID.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_SESSION_KEY_DATA_
#define	_SESSION_KEY_DATA_

#include "objkey.h"

/*
 * This is the typedef for the structure used to hold the session key data
 * internally.
 */
typedef struct
{
	CObjectKeyContainer		    *application_protocol_key;
	GCCSessionID				session_id;
}
    SESSION_KEY;

/*
 * Class definition:
 */
class CSessKeyContainer : public CRefCount
{

public:

	CSessKeyContainer(PGCCSessionKey, PGCCError);
	CSessKeyContainer(PSessionKey, PGCCError);
	CSessKeyContainer(CSessKeyContainer *, PGCCError);

	~CSessKeyContainer(void);

	UINT		LockSessionKeyData(void);
	void		UnLockSessionKeyData(void);

	UINT		GetGCCSessionKeyData(PGCCSessionKey, LPBYTE memory);

	GCCError	GetSessionKeyDataPDU(PSessionKey);
	void		FreeSessionKeyDataPDU(void);

	BOOL    	IsThisYourApplicationKey(PGCCObjectKey);
	BOOL    	IsThisYourApplicationKeyPDU(PKey);
	BOOL    	IsThisYourSessionKeyPDU(PSessionKey);

#if 0 // LONCHANC: no one use them
	BOOL	IsThisYourSessionID(PSessionKey pSessKey)
	{
		return (m_InternalSessKey.session_id == pSessKey->session_id);
	}
	BOOL	IsThisYourSessionID(PGCCSessionKey pGccSessKey)
	{
		return (m_InternalSessKey.session_id == pGccSessKey->session_id);
	}
	BOOL	IsThisYourSessionID(UINT nSessionID)
	{
		return ((UINT) m_InternalSessKey.session_id == nSessionID);
	}
#endif

friend BOOL     operator== (const CSessKeyContainer&, const CSessKeyContainer&);

protected:

	SESSION_KEY     	m_InternalSessKey;
	UINT				m_cbDataSize;

	SessionKey 			m_SessionKeyPDU;
	BOOL    			m_fValidSessionKeyPDU;
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CSessKeyContainer (	PGCCSessionKey		session_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CSessKeyContainer class which takes as
 *		input the "API" version of session key data, GCCSessionKey.
 *
 *	Formal Parameters:
 *		session_key			(i)	The session key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_SESSION_KEY				-	An invalid session key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CSessKeyContainer (	PSessionKey			session_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CSessKeyContainer class which takes as
 *		input the "PDU" version of session key data, SessionKey.
 *
 *	Formal Parameters:
 *		session_key			(i)	The session key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_SESSION_KEY				-	An invalid session key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CSessKeyContainer(CSessKeyContainer		*session_key,
 *				    PGCCError			return_value);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CSessKeyContainer class which takes
 *		as input another CSessKeyContainer object.
 *
 *	Formal Parameters:
 *		session_key			(i)	The CSessKeyContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_SESSION_KEY				-	An invalid session key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~SessionKeyData();
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This is the destructor for the CSessKeyContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	UINT			LockSessionKeyData ();
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCSessionKey structure
 *		which is filled in on a call to GetGCCSessionKeyData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCSessionKeyData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCSessionKey structure
 *		provided as an output parameter to the GetGCCSessionKeyData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeSessionKeyData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CSessKeyContainer
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeSessionKeyData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CSessKeyContainer object will automatically delete itself when
 *		the FreeSessionKeyData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */


/*
 *	UINT			GetGCCSessionKeyData (	
 *							PGCCSessionKey 		session_key,
 *							LPSTR				memory);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the session key data from the
 *		CSessKeyContainer object in the "API" form of a GCCSessionKey.
 *
 *	Formal Parameters:
 *		session_key			(o)	The GCCSessionKey structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void			UnLockSessionKeyData ();
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeSessionKeyData.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CSessKeyContainer
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CSessKeyContainer 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	GCCError		GetSessionKeyDataPDU (	
 *							PSessionKey 		session_key);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the session key data from the
 *		CSessKeyContainer object in the "PDU" form of a SessionKey.
 *
 *	Formal Parameters:
 *		session_key		(o)	The SessionKey structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeSessionKeyDataPDU ();
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a Key structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeSessionKeyDataPDU has been made.
 */


/*
 *	BOOL    		IsThisYourApplicationKey (	
 *							PGCCObjectKey			application_key);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified application key
 *		is held within this session key object.  The application key is 
 *		provided in "API" form.
 *
 *	Formal Parameters:
 *		application_key		(i)	The application key to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified application key is contained 
 *									within this	session key object.
 *		FALSE				-	The specified application key is not contained 
 *									within this session key object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	BOOL    		IsThisYourApplicationKeyPDU (	
 *							PKey				application_key);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified application key
 *		is held within this session key object.  The application key is 
 *		provided in "PDU" form.
 *
 *	Formal Parameters:
 *		application_key		(i)	The application key to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified application key is contained 
 *									within this	session key object.
 *		FALSE				-	The specified application key is not contained 
 *									within this session key object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	BOOL    		IsThisYourSessionKeyPDU (	
 *							PSessionKey			session_key);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified session key
 *		is equal in value to the session key maintained by this object.
 *
 *	Formal Parameters:
 *		session_key		(i)	The session key to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified session key is equal in value to
 *									the session key maintained by this object.
 *		FALSE				-	The specified session key is not equal in value
 *									to the session key maintained by this 
 *									object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	friend BOOL    	operator== (const CSessKeyContainer& 		session_key_1, 
 *								const CSessKeyContainer& 		session_key_2);
 *
 *	Public member function of CSessKeyContainer.
 *
 *	Function Description:
 *		This routine is used to compare two CSessKeyContainer objects to determine
 *		whether or not they are equal in value.
 *
 *	Formal Parameters:
 *		session_key_1			(i)	The first CSessKeyContainer object to compare.
 *		session_key_2			(i)	The other CSessKeyContainer object to compare.
 *
 *	Return Value:
 *		TRUE				-	The two objects are equal in value.
 *		FALSE				- 	The two objects are not equal in value.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\regkey.h ===
/*
 *	regkey.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CRegKeyContainer.  This class
 *		manages the data associated with a Registry Key.  Registry Key are
 *		used to identify resources held in the application registry and consist
 *		of a Session Key and a resource ID octet string.  The CRegKeyContainer 
 *		class uses a CSessKeyContainer container to maintain the session key data 
 *		internally.  A Rogue Wave string object is used to hold the resource ID
 *		octet string.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_REGISTRY_KEY_DATA_
#define	_REGISTRY_KEY_DATA_

#include "sesskey.h"

/*
 * This is the typedef for the structure used to hold the registry key data
 * internally.
 */
typedef struct
{
	CSessKeyContainer		    *session_key;
	LPOSTR						poszResourceID;
}
    REG_KEY;

/*
 * Class definition:
 */
class CRegKeyContainer : public CRefCount
{
public:

	CRegKeyContainer(PGCCRegistryKey, PGCCError);
	CRegKeyContainer(PRegistryKey, PGCCError);
	CRegKeyContainer(CRegKeyContainer *, PGCCError);

	~CRegKeyContainer(void);

	UINT		LockRegistryKeyData(void);
	void		UnLockRegistryKeyData(void);

	UINT		GetGCCRegistryKeyData(PGCCRegistryKey, LPBYTE memory);
	GCCError	GetRegistryKeyDataPDU(PRegistryKey);
	void		FreeRegistryKeyDataPDU(void);
    GCCError    CreateRegistryKeyData(PGCCRegistryKey *);
	BOOL    	IsThisYourSessionKey(CSessKeyContainer *);

    CSessKeyContainer *GetSessionKey(void) { return m_InternalRegKey.session_key; }

    friend BOOL operator==(const CRegKeyContainer&, const CRegKeyContainer&);

protected:

	REG_KEY     		m_InternalRegKey;
	UINT				m_cbDataSize;

    RegistryKey 		m_RegKeyPDU;
	BOOL    			m_fValidRegKeyPDU;
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CRegKeyContainer (	PGCCRegistryKey		registry_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CRegKeyContainer class which takes as
 *		input the "API" version of registry key data, GCCRegistryKey.
 *
 *	Formal Parameters:
 *		registry_key		(i)	The registry key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_REGISTRY_KEY			-	An invalid registry key passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CRegKeyContainer (	PRegistryKey		registry_key,
 *						PGCCError			return_value);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This is the constructor for the CRegKeyContainer class which takes as
 *		input the "PDU" version of registry key data, RegistryKey.
 *
 *	Formal Parameters:
 *		registry_key		(i)	The registry key data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	CRegKeyContainer(CRegKeyContainer	            *registry_key,
 *			        PGCCError			return_value);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CRegKeyContainer class which takes
 *		as input another CRegKeyContainer object.
 *
 *	Formal Parameters:
 *		registry_key		(i)	The CRegKeyContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~CRegKeyContainer();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This is the destructor for the CRegKeyContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	ULong			LockRegistryKeyData ();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCRegistryKey structure
 *		which is filled in on a call to GetGCCRegistryKeyData.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetGCCRegistryKeyData.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory, if any, which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCRegistryKey structure
 *		provided as an output parameter to the GetGCCRegistryKeyData call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeRegistryKeyData.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CRegKeyContainer
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeRegistryKeyData call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CRegKeyContainer object will automatically delete itself when
 *		the FreeRegistryKeyData call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */


/*
 *	ULong			GetGCCRegistryKeyData (	
 *							PGCCRegistryKey 		registry_key,
 *							LPSTR					memory);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the registry key data from the
 *		CRegKeyContainer object in the "API" form of a GCCRegistryKey.
 *
 *	Formal Parameters:
 *		registry_key		(o)	The GCCRegistryKey structure to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structure.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void			UnLockRegistryKeyData ();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeRegistryKeyData.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CRegKeyContainer
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CRegKeyContainer 
 *		object,	it should assume the object to be invalid thereafter.
 */


/*
 *	GCCError		GetRegistryKeyDataPDU (	
 *							PRegistryKey 		registry_key);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the registry key data from the
 *		CRegKeyContainer object in the "PDU" form of a RegistryKey.
 *
 *	Formal Parameters:
 *		registry_key		(o)	The RegistryKey structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	One of the internal pointers has
 *												been corrupted.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		FreeRegistryKeyDataPDU ();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a RegistryKey structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeRegistryKeyDataPDU has been made.
 */


/*
 *	BOOL    		IsThisYourSessionKey (
 *								CSessKeyContainer		*session_key);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to determine whether the specified session key
 *		is held within this registry key object.  The session key is 
 *		provided in "API" form.
 *
 *	Formal Parameters:
 *		session_key		(i)	The session key to use for comparison.
 *
 *	Return Value:
 *		TRUE				-	The specified session key is contained 
 *									within this	registry key object.
 *		FALSE				-	The specified session key is not contained 
 *									within this registry key object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	CSessKeyContainer *GetSessionKey ();
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the session key held in this registry
 *		key object.  The session key is returned in the form of a
 *		CSessKeyContainer object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the CSessKeyContainer object contained within this
 *		CRegKeyContainer object.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	friend BOOL    	operator== (const CRegKeyContainer& 		registry_key_1, 
 *								const CRegKeyContainer& 		registry_key_2);
 *
 *	Public member function of CRegKeyContainer.
 *
 *	Function Description:
 *		This routine is used to compare two CRegKeyContainer objects to determine
 *		whether or not they are equal in value.
 *
 *	Formal Parameters:
 *		registry_key_1			(i)	The first CRegKeyContainer object to compare.
 *		registry_key_2			(i)	The other CRegKeyContainer object to compare.
 *
 *	Return Value:
 *		TRUE				-	The two objects are equal in value.
 *		FALSE				- 	The two objects are not equal in value.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\signatr.h ===
/*
 *
 *	signatr.h
 *	
 *	This file defines the signatures of various T.120 objects.  These
 *	signatures are used mainly for debugging debug and retail versions
 *	of T.120.
 *
 *	T.120 used to have many many dictionaries where pointers to objects were put using
 *	16-bit values as keys to search the dictionary and get the pointer to
 *	the appropriate object.  These lookups were inefficient for three
 *	reasons:
 *
 *		1. The lookup takes time
 *		2. The dictionaries take space
 *		3. A 16-bit value passed around requires masking to extract in a 
 *			32-bit machine, that is, extra instructions.
 *
 *	To eliminate these efficiency problems, the pointers to the objects are
 *	used as handles to them (unique values identifying the objects).
 *	But, to catch bugs caused by modifications of these handles as they are
 *	passed around, we need to put a signature in each object that lets us
 *	verify whether an object of type X is really an object of type X.  The way
 *	we do this is by specifying a unique signature for type X and putting this
 *	signature into every object of type X.
 *
 *	Each signature contains only 8 significant bytes.
 */

#ifndef	_T120_SIGNATURES
#define _T120_SIGNATURES

// Signature length
#define SIGNATURE_LENGTH		8

#ifdef _DEBUG
// The macro to compare signatures
#define SIGNATURE_MATCH(p, s)		(memcmp ((p)->mSignature, (s), SIGNATURE_LENGTH) == 0)
// The macro to copy signatures
#define SIGNATURE_COPY(s)			(memcpy (mSignature, (s), SIGNATURE_LENGTH))

#else		// _DEBUG
#define SIGNATURE_MATCH(p, s)		(TRUE)

#	ifndef SHIP_BUILD
#	define SIGNATURE_COPY(s)		(memcpy (mSignature, (s), SIGNATURE_LENGTH))
#	else	// SHIP_BUILD
#	define SIGNATURE_COPY(s)
#	endif	// SHIP_BUILD
#endif		// _DEBUG

extern const char *MemorySignature;

#endif	// _T120_SIGNATURES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\sap.h ===
/*
 *	sap.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CBaseSap.  This class is an abstract
 *		base class for objects that act as Service Access Points (SAPs) to 
 *		external applications or the node controller. 
 *
 *		This class has two main responsibilities. First, it handles many of the 
 *		administrative tasks that are common to all types of SAPs.  These 
 *		include handling command target registration responsibilities and 
 *		managing the message queue.  It	also handles all of the primitives that
 *		are common between the Control SAP (CControlSAP class) and Application 
 *		SAPs (CAppSap class).  Since this class inherits from CommandTarget, it 
 *		has the ability to communicate directly with other command targets.  A 
 *		CommandTarget object wishing to	communicate with a CBaseSap object must 
 *		register itself by passing it a CommandTarget pointer and a handle 
 *		(typically a ConferenceID).  This process is identical for both of the 
 *		derived CBaseSap classes.  Note that the CBaseSap object can handle multiple 
 *		registered command targets at the same time.  
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */
#ifndef _SAP_
#define _SAP_

/*
 * include files 
 */
// #include "gcmdtar.h"
#include "password.h"
#include "crost.h"
#include "arost.h"
#include "conflist.h"
#include "sesskey.h"
#include "regkey.h"
#include "regitem.h"
#include "invoklst.h"
#include "arostmsg.h"
#include "crostmsg.h"
#include "privlist.h"
#include "clists.h"


#define MSG_RANGE                       0x0100
enum
{
    // GCCController
    GCTRLMSG_BASE                       = 0x2100,

    // CConf
    CONFMSG_BASE                        = 0x2200,

    // CControlSAP
    CSAPMSG_BASE                        = 0x2300,

    // CControlSAP asyn direct confirm message
    CSAPCONFIRM_BASE                    = 0x2400,

    // CAppSap
    ASAPMSG_BASE                        = 0x2500,
    
    // NCUI
    NCMSG_BASE                          = 0x2600,

    // MCS (Node) Controller
    MCTRLMSG_BASE                       = 0x2700,
};

LRESULT CALLBACK SapNotifyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


typedef struct GCCAppSapMsgEx
{
    GCCAppSapMsgEx(GCCMessageType);
    ~GCCAppSapMsgEx(void);

    GCCAppSapMsg        Msg;
}
    GCCAppSapMsgEx, *PGCCAppSapMsgEx;


/*
 * This macro defines the minimum user ID value allowed by MCS.
 */
#define	MINIMUM_USER_ID_VALUE	1001

/*
 * Structures and enumerations used by the CBaseSap class.
 */


//
// Class definition.
//
class CConf;
class CBaseSap : public CRefCount
{
public:

#ifdef SHIP_BUILD
    CBaseSap();
#else
    CBaseSap(DWORD dwStampID);
#endif
    virtual ~CBaseSap(void) = 0;

    GCCError  ConfRosterInquire(GCCConfID, GCCAppSapMsgEx **);
    GCCError  AppRosterInquire(GCCConfID, GCCSessionKey *, GCCAppSapMsgEx **);
    GCCError  ConductorInquire(GCCConfID);
    GCCError  AppInvoke(GCCConfID, GCCAppProtEntityList *, GCCSimpleNodeList *, GCCRequestTag *);
    BOOL      IsThisNodeTopProvider(GCCConfID);
    GCCNodeID GetTopProvider(GCCConfID);

    virtual GCCError	ConfRosterInquireConfirm(
    					GCCConfID,
    					PGCCConferenceName,
    					LPSTR           	conference_modifier,
    					LPWSTR				pwszConfDescriptor,
    					CConfRoster *,
    					GCCResult,
    					GCCAppSapMsgEx **) = 0;

    virtual GCCError	AppRosterInquireConfirm(
    					GCCConfID,
    					CAppRosterMsg *,
    					GCCResult,
                        GCCAppSapMsgEx **) = 0;

    virtual GCCError AppInvokeConfirm(
                        GCCConfID,
                        CInvokeSpecifierListContainer *,
                        GCCResult,
                        GCCRequestTag) = 0;

    virtual GCCError AppInvokeIndication(
                        GCCConfID,
                        CInvokeSpecifierListContainer *,
                        GCCNodeID nidInvoker) = 0;

    virtual GCCError AppRosterReportIndication(GCCConfID, CAppRosterMsg *) = 0;

    virtual GCCError ConductorInquireConfirm(
    					GCCNodeID			nidConductor,
    					GCCResult,
    					BOOL				permission_flag,
    					BOOL				conducted_mode,
    					GCCConfID) = 0;

    virtual GCCError ConductorPermitGrantIndication(
                        GCCConfID           nConfID,
                        UINT                cGranted,
                        GCCNodeID           *aGranted,
                        UINT                cWaiting,
                        GCCNodeID           *aWaiting,
                        BOOL                fThisNodeIsGranted) = 0;

    virtual GCCError ConductorAssignIndication(
                        GCCNodeID			nidConductor,
                        GCCConfID			conference_id) = 0;

    virtual GCCError ConductorReleaseIndication(
                        GCCConfID			conference_id) = 0;


protected:

    GCCRequestTag GenerateRequestTag(void);

    GCCRequestTag       m_nReqTag;

    HWND                m_hwndNotify;
};



/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CBaseSap();
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This is the CBaseSap constructor.  The hash list used to hold command
 *		target objects is initialized by this constructor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	~Sap ();
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This is the CBaseSap destructor.  All message flushing and queue clearing
 *		is performed by the classes which inherit from CBaseSap.  No work is actually
 *		done by this constructor.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	RegisterConf(CConf *, GCCConfID)
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is used by command target objects (such as Conferences) in
 *		order to register themselves with the CBaseSap object.  This is done in order
 *		to allow the command target object to communicate directly with the CBaseSap. 
 *
 *	Formal Parameters:
 *		cmdtar_object			(i) Pointer to the command target object 
 *										wishing to be registered with the CBaseSap.
 *		handle					(i) Integer value used to index the registering
 *										command target in the list of command
 *										targets (the conference ID for confs).
 *
 *	Return Value:
 *		SAP_NO_ERROR						- Command target object has been
 *													successfully registered.
 *		SAP_CONFERENCE_ALREADY_REGISTERED	- A command target object was 
 *													already registered with the
 *													handle passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	UnRegisterConf (
 *							UINT					handle);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is used by command target objects (such as Conferences) in
 *		order to un-register themselves with the CBaseSap object.  This is done when
 *		the command target object is through communicating with the CBaseSap. 
 *
 *	Formal Parameters:
 *		handle					(i) Integer value used to index the registering
 *										command target in the list of command
 *										targets (the conference ID for confs).
 *
 *	Return Value:
 *		SAP_NO_ERROR				- Command target object has been
 *											successfully un-registered.
 *		SAP_NO_SUCH_CONFERENCE		- No command target object was found 
 *											registered with the	handle passed in
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConfRosterInquire(
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is used to retrieve the conference roster.  This function
 *		just passes this request to the controller via an owner callback.  The 
 *		conference roster is delivered to the requesting command target object
 *		in a Conference Roster inquire confirm. 
 *
 *	Formal Parameters:
 *		conference_id			- ID of conference for desired roster.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource allocation error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- Conference object has not completed 
 *										  		its establishment process.
 *		
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	AppRosterInquire (
 *							GCCConfID			conference_id,
 *							PGCCSessionKey			session_key	);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is used to retrieve a list of application rosters.  This 
 *		function just passes this request to the controller via an owner 
 *		callback.  This	list is delivered to the requesting SAP through an
 *		Application Roster inquire confirm message.
 *
 *	Formal Parameters:
 *		handle					(i) Integer value used to index the registering
 *										command target in the list of command
 *										targets (the conference ID for confs).
 *
 *	Return Value:
 *		GCC_NO_ERROR			- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE	- A resource allocation error occurred.
 *		GCC_INVALID_CONFERENCE	- Conference ID is invalid.
 *		GCC_BAD_SESSION_KEY		- Session key pointer is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorInquire (
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to retrieve conductorship information.
 *		The conductorship information is returned in the confirm.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError 	AppInvoke(
 *							GCCConfID			conference_id,
 *							UINT					number_of_apes,
 *							PGCCAppProtocolEntity *	ape_list,
 *							UINT					number_of_destination_nodes,
 *							UserID			*		list_of_destination_nodes);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to invoke other applications at remote
 *		nodes.  The request is passed on to the appropriate Conference objects.
 *
 *	Formal Parameters:
 *		conference_id				(i) ID of conference.
 *		number_of_apes				(i)	Number of Application Protocol Entities
 *											to be invoked.
 *		ape_list					(i) List of "APE"s to be invoked.
 *		number_of_destination_nodes	(i) Number of nodes where applications are
 *											to be invoked.
 *		list_of_destination_nodes	(i) List of nodes where applications are to
 *											be invoked.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- No error.
 *		GCC_ALLOCATION_FAILURE			- Error creating an object using the
 *										  		"new" operator.
 *		GCC_BAD_SESSION_KEY				- An invalid session key exists in
 *										  		an APE passed in.
 *		GCC_BAD_NUMBER_OF_APES			- Number of APEs passed in as zero.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *		GCC_CONFERENCE_NOT_ESTABLISHED	- Conference object has not completed 
 *										  	its establishment process.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorPermitAskRequest(
 *							GCCConfID			conference_id,
 *							BOOL				grant_permission);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to ask for certain permissions to be 
 *		granted (or not granted) by the conductor.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		grant_permission	(i) Flag indicating whether asking for a certain
 *									permission or giving up that permission.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *		GCC_INVALID_CONFERENCE			- Conference ID is invalid.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	AppRosterInquireConfirm(
 *							GCCConfID				conference_id,
 *							CAppRosterMsg				*roster_message,
 *							GCCResult					result );
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to return a requested list of
 *		application rosters to an application or the node controller.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		roster_message		(i) Roster message object containing the roster data
 *		result				(i) Result code indicating if call is successful.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConfRosterInquireConfirm (
 *							GCCConfID				conference_id,
 *							PGCCConferenceName			conference_name,
 *							LPSTR           			conference_modifier,
 *							LPWSTR						pwszConfDescriptor,
 *							CConfRoster	  				*conference_roster,
 *							GCCResult					result );
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to return a requested conference
 *		roster to an application or the node controller.
 *
 *	Formal Parameters:
 *		conference_id			(i) ID of conference.
 *		conference_name			(i) Name of conference.
 *		conference_modifier		(i) Name modifier for conference.
 *		pwszConfDescriptor		(i) Desciptor string for conference.
 *		conference_roster		(i) The conference roster being returned.
 *		result					(i) Result code indicating result of call.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	AppInvokeConfirm( 	
 *							GCCConfID					conference_id,
 *							CInvokeSpecifierListContainer	*invoke_list,
 *							GCCResult						result);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to confirm a call requesting application
 *		invocation.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		invoke_list			(i) List of APE attempted to be invoked.
 *		result				(i) Result code indicating result of call.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	AppInvokeIndication (
 *							GCCConfID					conference_id,
 *							CInvokeSpecifierListContainer	*invoke_list,
 *							UserID							invoking_node_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for application invocation has been
 *		made.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		invoke_list			(i) List of APE's to be invoked.
 *		invoking_node_id	(i) ID of node requesting the invoke.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorInquireConfirm (
 *							UserID					conductor_node_id,
 *							GCCResult				result,
 *							BOOL				permission_flag,
 *							BOOL				conducted_mode,
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to return conductorship information
 *		which has been requested.
 *
 *	Formal Parameters:
 *		conductor_node_id			(i) Node ID of conducting node.
 *		result						(i) Result of call.
 *		permission_flag				(i) Flag indicating whether or not local
 *											node has conductorship permission.
 *		conducted_mode				(i) Flag indicating whether or not 
 *											conference is in conducted mode.
 *		conference_id				(i) ID of conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorAssignIndication (
 *							UserID					conductor_user_id,
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request has been made to assign conductorship.
 *
 *	Formal Parameters:
 *		conductor_user_id			(i) Node ID of conductor.
 *		conference_id				(i) ID of conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorReleaseIndication (
 *							GCCConfID			conference_id);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for releasing conductorship has been
 *		made.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConductorPermitGrantIndication (	
 *							GCCConfID			conference_id,
 *							UINT					number_granted,
 *							PUserID					granted_node_list,
 *							UINT					number_waiting,
 *							PUserID					waiting_node_list,
 *							BOOL				permission_is_granted);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for permission from the conductor
 *		has been made.
 *
 *	Formal Parameters:
 *		conference_id				(i) ID of conference.
 *		number_granted				(i) Number of nodes permission is requested
 *											for.
 *		granted_node_list			(i) List of node ID's for nodes to be
 *											granted permission.
 *		number_waiting				(i) Number of nodes waiting for permission.
 *		waiting_node_list			(i) List of nodes waiting for permission.
 *		permission_is_granted		(i) Flag indicating whether permission is
 *											granted.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ConfRosterReportIndication (
 *							GCCConfID				conference_id,
 *							CConfRosterMsg				*roster_message);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to indicate to applications and the
 *		node controller that the conference roster has been updated.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		roster_message		(i) Roster message object holding the updated
 *									roster information.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	GCCError	ApplicationRosterReportIndication (
 *							GCCConfID				conference_id,
 *							CAppRosterMsg				*roster_message);
 *
 *	Public member function of CBaseSap.
 *
 *	Function Description:
 *		This routine is called in order to indicate to applications and the
 *		node controller that the list of application rosters has been updated.
 *
 *	Formal Parameters:
 *		conference_id		(i) ID of conference.
 *		roster_message		(i) Roster message object holding the updated
 *									roster information.
 *
 *	Return Value:
 *		GCC_NO_ERROR					- Function completed successfully.
 *		GCC_ALLOCATION_FAILURE			- A resource error occurred.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\socket.h ===
/*	Socket.h
 *
 *	Copyright (c) 1996 by Microsoft Corporation
 *
 *	Abstract:
 *		This is the WinSock interface to a socket.  It can create a 
 *		connection with another machine, transmit and receive data, and shut
 *		down the socket when it is finished.
 *
 */
#ifndef _SOCKET_
#define _SOCKET_

#include "databeam.h"

extern "C"
{
	#include "t120.h"
	#include "winsock2.h"
}
#include "tprtsec.h"

/* States that the socket can be in */
typedef	enum
{
	NOT_CONNECTED,
	WAITING_FOR_CONNECTION,
	SOCKET_CONNECTED,
	X224_CONNECTED,
	WAITING_FOR_DISCONNECT
}	SocketState;

/* Security states that the socket can be in */
typedef enum
{
	SC_UNDETERMINED,
	SC_SECURE,
	SC_NONSECURE
}	SecurityState;

#define	MAXIMUM_IP_ADDRESS_SIZE	32

 /*
 **	This is the port number specified by IMTC
 */
#define	TCP_PORT_NUMBER			1503

typedef enum {
	READ_HEADER,
	READ_DATA,
	DISCONNECT_REQUEST,	/* There are dependencies on this order */
	CONNECTION_CONFIRM,
	CONNECTION_REQUEST,
	DATA_READY
} ReadState;

#define	WM_SOCKET_NOTIFICATION			(WM_APP)
#define	WM_SECURE_SOCKET_NOTIFICATION	(WM_APP+1)
#define	WM_PLUGGABLE_X224               (WM_APP+2)
#define WM_PLUGGABLE_PSTN               (WM_APP+3)

typedef struct _Security_Buffer_Info {
	LPBYTE		lpBuffer;
	UINT		uiLength;
} Security_Buffer_Info;

class CSocket : public CRefCount
{
public:

    CSocket(BOOL *, TransportConnection, PSecurityContext);
    ~CSocket(void);

    void FreeTransportBuffer(void);

public:

	X224_DATA_PACKET 	X224_Header;

	/* global variables */
	// SOCKET				Socket_Number;
	SocketState			State;
	SecurityState		SecState;
	PSecurityContext 	pSC;
	UINT				Max_Packet_Length;
	
	Char				Remote_Address[MAXIMUM_IP_ADDRESS_SIZE];

	/* recv state variables */
	UINT				Current_Length;
	PUChar				Data_Indication_Buffer;
	UINT				Data_Indication_Length;
	ReadState			Read_State;
	UINT				X224_Length;
	BOOL				bSpaceAllocated;
	PMemory				Data_Memory;

	/* send state variables */
	union {
	PDataPacket			pUnfinishedPacket;
	Security_Buffer_Info sbiBufferInfo;
	}					Retry_Info;

	BOOL			fExtendedX224;
	BOOL			fIncomingSecure;

    // plugable transport
    TransportConnection     XprtConn;
};

typedef	CSocket *PSocket;

class CSocketList : public CList
{
    DEFINE_CLIST(CSocketList, PSocket)
    void SafeAppend(PSocket);
    BOOL SafeRemove(PSocket);
    PSocket FindByTransportConnection(TransportConnection, BOOL fNoAddRef = FALSE);
    PSocket RemoveByTransportConnection(TransportConnection);
};

extern CSocketList     *g_pSocketList;


/* Function prototypes */
PSocket newSocket(TransportConnection, PSecurityContext);
PSocket	newPluggableSocket(TransportConnection);
PSocket	newSocketEx(TransportConnection, PSecurityContext);

void freeSocket(PSocket, TransportConnection);
void freeListenSocket(TransportConnection);
void freePluggableSocket(PSocket);
void freeSocketEx(PSocket, TransportConnection /* listen_socket_number */);

SOCKET			CreateAndConfigureListenSocket (VOID);

#endif	/* _SOCKET_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\t120qos.h ===
extern LPIQOS				g_pIQoS;

extern DWORD g_dwLastQoSCB;
extern DWORD g_dwSentSinceLastQoS;

typedef struct _t120rrq
{
	int cResourceRequests;
	RESOURCEREQUEST aResourceRequest[1];
}T120RRQ;

extern T120RRQ g_aRRq;

extern HRESULT CALLBACK QosNotifyDataCB (
		LPRESOURCEREQUESTLIST lpResourceRequestList,
		DWORD dwThis);
extern VOID InitializeQoS( VOID );
extern VOID DeInitializeQoS( VOID );
extern VOID MaybeReleaseQoSResources( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\tprtsec.h ===
/*
 *	tprtsec.h
 *
 *	Copyright (c) 1997 by Microsoft Corp.
 *
 *	Author:
 *		Claus T. Giloi
 */

#ifndef	_TPRTSEC
#define	_TPRTSEC


#define SECURITY_WIN32
#include "sspi.h"
#include "spseal.h"
#include "schnlsp.h"

typedef BOOL (WINAPI *PFN_SSL_EMPTY_CACHE)(VOID);
#define SZ_SSLEMPTYCACHE "SslEmptyCache"

#ifdef UNICODE
#error "Compile time character width conflict"
// Above entry point strings need to be changed to unicode equivalents
// or abstracted.
#endif // UNICODE

/*
 *	This typedef defines the errors that can be returned from calls that are
 *	specific to TransportSecurity classes.
 */
typedef	enum
{
	TPRTSEC_NOERROR,
	TPRTSEC_NODLL,
	TPRTSEC_NOENTRYPT,
	TPRTSEC_SSPIFAIL,
	TPRTSEC_NOMEM,
	TPRTSEC_INVALID_PARAMETER,
	TPRTSEC_INCOMPLETE_CONTEXT,
	TPRTSEC_INVALID_STATE
} TransportSecurityError;

/*
 * This typedef defines the states that a security context object can be
 * in.
 */
typedef enum
{
	SECCTX_STATE_NEW,
	SECCTX_STATE_INIT,
	SECCTX_STATE_ACCEPT,
	SECCTX_STATE_INIT_COMPLETE,
	SECCTX_STATE_ACCEPT_COMPLETE,
	SECCTX_STATE_ERROR
} SecurityContextState;

/*
 *	This is simply a forward reference for the class defined below.  It is used
 *	in the definition of the owner callback structure defined in this section.
 */
class SecurityInterface;
typedef	SecurityInterface *		PSecurityInterface;
class SecurityContext;
typedef	SecurityContext *		PSecurityContext;

#ifdef DEBUG
extern void dumpbytes(PSTR szComment, PBYTE p, int cb);
#endif // DEBUG
extern BOOL InitCertList ( SecurityInterface * pSI, HWND hwnd);
extern BOOL SetUserPreferredCert ( SecurityInterface * pSI, DWORD dwCertID);

class SecurityInterface
{

	friend class SecurityContext;

	public:
								SecurityInterface (BOOL bService);
								~SecurityInterface ();

		TransportSecurityError Initialize ();
		TransportSecurityError InitializeCreds (PCCERT_CONTEXT);
		TransportSecurityError GetLastError(VOID) { return LastError; };

		BOOL GetUserCert(PBYTE pInfo, PDWORD pcbInfo);
		BOOL IsInServiceContext(VOID) { return bInServiceContext; }

	
	private:

		HINSTANCE				hSecurityDll;
		INIT_SECURITY_INTERFACE pfnInitSecurityInterface;
		PSecurityFunctionTable pfnTable;
		PFN_SSL_EMPTY_CACHE pfn_SslEmptyCache;
		

		PBYTE		m_pbEncodedCert;
		DWORD		m_cbEncodedCert;

		BOOL		bInboundCredentialValid;
		BOOL		bOutboundCredentialValid;
		BOOL		bInServiceContext;
		CredHandle hInboundCredential;
		CredHandle hOutboundCredential;
		TimeStamp tsExpiry;
		TransportSecurityError LastError;
};


class SecurityContext
{
	public:

		SecurityContext (PSecurityInterface pSI, LPCSTR szHostName);
		~SecurityContext ();

		TransportSecurityError Initialize (PBYTE pData, DWORD cbData);
		TransportSecurityError Accept (PBYTE pData, DWORD cbData);
		TransportSecurityError Encrypt(LPBYTE pBufIn1, UINT cbBufIn1,
									LPBYTE pBufIn2, UINT cbBufIn2,
									LPBYTE *ppBufOut, UINT *pcbBufOut);
		TransportSecurityError Decrypt( PBYTE pszBuf,
								  DWORD cbBuf);
		PVOID GetTokenBuf(VOID) { return OutBuffers[0].pvBuffer; };
		ULONG GetTokenSiz(VOID) { return OutBuffers[0].cbBuffer; };
		BOOL ContinueNeeded(VOID) { return fContinueNeeded; };
		BOOL StateComplete(VOID) { return
									scstate == SECCTX_STATE_INIT_COMPLETE ||
									scstate == SECCTX_STATE_ACCEPT_COMPLETE; };
		BOOL WaitingForPacket(VOID) { return
									scstate == SECCTX_STATE_NEW ||
									scstate == SECCTX_STATE_ACCEPT ||
									scstate == SECCTX_STATE_INIT; };
		TransportSecurityError AdvanceState(PBYTE pBuf,DWORD cbBuf);
		BOOL EncryptOutgoing(VOID)
			{ return scstate == SECCTX_STATE_INIT_COMPLETE; };
		BOOL DecryptIncoming(VOID)
			{ return scstate == SECCTX_STATE_ACCEPT_COMPLETE; };
		ULONG GetStreamHeaderSize(VOID) { return Sizes.cbHeader; };
		ULONG GetStreamTrailerSize(VOID) { return Sizes.cbTrailer; };
		TransportSecurityError GetLastError(VOID) { return LastError; };
		BOOL GetUserCert(PBYTE pInfo, PDWORD pcbInfo);
		BOOL Verify(VOID);

	private:

		TransportSecurityError InitContextAttributes(VOID);

		PSecurityInterface pSecurityInterface;
		SecurityContextState		scstate;
		CHAR			szTargetName[128]; // Long enough for any dotted-decimal
										  // address, followed by 2 dwords in
										  // hex.
		BOOL			bContextHandleValid;
		CtxtHandle		hContext;
		TimeStamp		Expiration;
		SecPkgContext_StreamSizes Sizes;
		SecBufferDesc	OutputBufferDescriptor;
		SecBufferDesc	InputBufferDescriptor;
		SecBuffer		OutBuffers[1];
		SecBuffer		InBuffers[2];
		ULONG			ContextRequirements;
		ULONG			ContextAttributes;
		BOOL			fContinueNeeded;
		TransportSecurityError LastError;

};

// Codes used for GetSecurityInfo()
#define NOT_DIRECTLY_CONNECTED		-1
		
#endif // _TPRTSEC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\tptif.h ===
/*
 *	tptif.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the TransportInterface class.
 *		This class provides a seamless interface to the TCP	transport stack.
 *	
 *		The public interface of this class includes a member function for each
 *		of the API routines that a user application would need to call.  The
 *		only API routines not directly accessible are those used for
 *		initialization and cleanup (which are automatically executed in the
 *		constructor and destructor, respectively).  When a user application
 *		needs to call one of the available API routines, it merely calls the
 *		equivalent member function within the proper instance of this class.
 *		The API routine will then be invoked using the same parameters.
 *	
 *		The destructor calls the cleanup routine within the DLL for which it is
 *		responsible.
 *
 *		The management plane functions include support for initialization and
 *		setup, as well as functions allowing MCS to poll the transport
 *		interfaces for activity.
 *	
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_TRANSPORTINTERFACE_
#define	_TRANSPORTINTERFACE_

#include "tprtsec.h"

/*
 *	This typedef defines the errors that can be returned from calls that are
 *	specific to TransportInterface classes.  Note that the public member
 *	functions that map to transport stack calls do not return an error of this
 *	type.  Rather, they return an error as defined by the transport API (TRAPI).
 */
typedef	enum
{
	TRANSPORT_INTERFACE_NO_ERROR,
	TRANSPORT_INTERFACE_INITIALIZATION_FAILED,
	TRANSPORT_INTERFACE_ALLOCATION_FAILED,
	TRANSPORT_INTERFACE_NO_SUCH_CONNECTION,
	TRANSPORT_INTERFACE_CONNECTION_ALREADY_EXISTS
} TransportInterfaceError;
typedef	TransportInterfaceError *		PTransportInterfaceError;


class CTransportConnList2 : public CList2
{
    DEFINE_CLIST2(CTransportConnList2, PConnection, UINT)
    void AppendEx(PConnection p, TransportConnection XprtConn)
    {
        UINT nKey = PACK_XPRTCONN(XprtConn);
        Append(nKey, p);
    }
    PConnection FindEx(TransportConnection XprtConn)
    {
        UINT nKey = PACK_XPRTCONN(XprtConn);
        return Find(nKey);
    }
    PConnection RemoveEx(TransportConnection XprtConn)
    {
        UINT nKey = PACK_XPRTCONN(XprtConn);
        return Remove(nKey);
    }
};


/*
 *	These are the owner callback messages that a transport interface object
 *	can send.  They correspond directly to the messages that will be received
 *	from the various transport stacks.
 */
#define	CONNECT_CONFIRM				0
#define	DISCONNECT_INDICATION		1
#define	DATA_INDICATION				2
#define	STATUS_INDICATION			3
#define BUFFER_EMPTY_INDICATION		4
#define	WAIT_UPDATE_INDICATION		5

/*
 *	This is simply a forward reference for the class defined below.  It is used
 *	in the definition of the owner callback structure defined in this section.
 */
class TransportInterface;
typedef	TransportInterface *		PTransportInterface;

/*
 *	Owner Callback:	CONNECT_CONFIRM
 *	Parameter1:		Unused
 *	Parameter2:		TransportConnection		transport_connection
 *
 *	Usage:
 *		This owner callback is sent when a connect confirm is received from
 *		the transport layer.  This is to inform the recipient that a transport
 *		connection is now available for use.  Connect confirm will occur
 *		on outbound connections.  They represent a new transport connection
 *		that has resulted from this system calling a remote one.  As such,
 *		there should always be a registered owner of the transport connection
 *		(registration is a side-effect of the call to ConnectRequest).
 *
 *		So the connect confirm will be routed to the object that is the
 *		registered owner of the transport connection.  That object may now
 *		utilize the connection to transfer data.
 */

/*
 *	Owner Callback:	DISCONNECT_INDICATION
 *	Parameter1:		Unused
 *	Parameter2:		TransportConnection		transport_connection
 *
 *	Usage:
 *		This owner callback is sent when a disconnect indication is received
 *		from the transport layer.  This is to inform the recipient that a
 *		transport connection is no longer available for use.  If an object
 *		has explicitly registered itself as the owner of a transport connection,
 *		then it will receive the disconnect indication.  If there has been no
 *		such registration, then the disconnect indication will be sent to the
 *		default owner callback.
 *
 *		Once a disconnect indication has been issued for a given transport
 *		connection, that connection can no longer be used for anything.
 */

/*
 *	Owner Callback:	DATA_INDICATION
 *	Parameter1:		PDataIndicationInfo		data_indication_info
 *	Parameter2:		TransportConnection		transport_connection
 *
 *	Usage:
 *		This owner callback is sent when a data indication is received from
 *		the transport layer.  The transport data structure contains the address
 *		and length of the user data field that is associated with the data
 *		indication.  If an object in the system has explicitly registered
 *		ownership of the transport connection that carried the data (either
 *		through ConnectRequest or RegisterTransportConnection), then this
 *		callback will be sent to that object.  If no object has registered
 *		this transport connection, then the data will be sent to the default
 *		owner.
 */

/*
 *	Owner Callback:	STATUS_INDICATION
 *	Parameter1:		PTransportStatus		transport_status
 *	Parameter2:		Unused
 *
 *	Usage:
 *		This owner callback is just a pass-through of the status indication
 *		that comes from the transport layer.  It contains a pointer to a
 *		transport status structure that contains status information that
 *		originated from the stack represented by this object.  This is always
 *		passed to the default owner object.
 */

/*
 *	Owner Callback:	BUFFER_EMPTY_INDICATION
 *	Parameter1:		Unused
 *	Parameter2:		TransportConnection		transport_connection
 *
 *	Usage:
 *		This owner callback is a pass-through of the buffer empty indication
 *		that comes from the transport layer.  It is sent to the object that
 *		has registered ownership of the specified transport connection.  This
 *		indication tells that object that the transport layer can now accept
 *		more data.
 */

class Connection;
typedef Connection *PConnection;

/*
 *	This is the class definition for the TransportInterface class.  Remember,
 *	this class contains pure virtual functions which makes it an abstract base
 *	class.  It cannot be instantiated, but rather, exists to be inherited from.
 *	These derived classes will implement the behavior that is specific to a
 *	particular transport stack (or possibly just the interface to a particular
 *	transport stack).
 */
class TransportInterface
{
	public:
								TransportInterface (
									HANDLE			transport_transmit_event,
									PTransportInterfaceError
											transport_interface_error);
								~TransportInterface ();
		TransportInterfaceError RegisterTransportConnection (
									TransportConnection	transport_connection,
									PConnection			owner_object,
									BOOL				bNoNagle);
#ifdef NM_RESET_DEVICE
				TransportError 	ResetDevice (
									PChar				device_identifier);
#endif // NM_RESET_DEVICE
				TransportError 	ConnectRequest (
									TransportAddress	transport_address,
									BOOL				fSecure,
									BOOL				bNoNagle,
									PConnection			owner_object,
									PTransportConnection
														transport_connection);
				void		 	DisconnectRequest (
									TransportConnection	transport_connection);
				void			DataRequestReady () { 
									SetEvent (Transport_Transmit_Event); 
								};
				void		 	ReceiveBufferAvailable ();
				BOOL			GetSecurity( TransportConnection transport_connection );

				PSecurityInterface		pSecurityInterface;
				BOOL					bInServiceContext;
		TransportInterfaceError	CreateConnectionCallback (
									TransportConnection	transport_connection,
									PConnection			owner_object);
				void			ConnectIndication (
									TransportConnection	transport_connection);
				void			ConnectConfirm (
									TransportConnection	transport_connection);
				void			DisconnectIndication (
									TransportConnection	transport_connection,
									ULONG               ulReason);
				TransportError	DataIndication (
									PTransportData		transport_data);
				void			BufferEmptyIndication (
									TransportConnection	transport_connection);

private:

		CTransportConnList2     m_TrnsprtConnCallbackList2;
		HANDLE					Transport_Transmit_Event;
};

/*
 *	TransportInterface (
 *			PTransportInterfaceError	transport_interface_error)
 *
 *	Functional Description:
 *		The constructor initializes the TCP transport code.
 *	
 *		The constructor also includes parameters specifying the default
 *		callback. This callback is used to inform the controller whenever an
 *		unexpected inbound connection is detected.  This gives the controller
 *		the opportunity to assign responsibility for the new connection to some
 *		other object in the system.
 *	
 *		If anything goes wrong in the constructor, the return value (whose
 *		address is passed as a constructor parameter) will be set to one of the
 *		failure codes.  If this happens, it is expected that whoever invoked the
 *		constructor (probably the controller), will immediately delete the
 *		object without using it.  Failure to do this WILL result in unexpected
 *		behavior.
 *
 *	Formal Parameters:
 *		default_owner_object (i)
 *			This is the address of the object that will handle all transport
 *			events for unregistered transport connections.  This includes
 *			connect indication, dicsonnect indication, and data indication.
 *			This object will also receive all state and message indications.
 *		default_owner_message_base (i)
 *			This is the base value to be used for all owner callback messages.
 *		transport_interface_error (o)
 *			This is where the return code will be stored so that the creator of
 *			this object can make sure that everything is okay before using the
 *			new object.  If this value is set to anything but success, the
 *			object should be destroyed immediately, without being used.
 *
 *	Return Value:
 *		Note: the return value is handled as a constructor parameter.
 *		TRANSPORT_INTERFACE_NO_ERROR
 *			Everything worked, and the object is ready for use.
 *		TRANSPORT_INTERFACE_INITIALIZATION_FAILED
 *			The initialization of the transport interface object failed.  It is
 *			therefore necessary to destroy the object without attempting to
 *			use it.
 *
 *	Side Effects:
 *		A DLL will be loaded into memory, for later use.
 *
 *	Caveats:
 */
 
/*
 *	~TransportInterface ()
 *
 *	Functional Description:
 *		The destructor frees up all resources used by the base class.  This
 *		is primarily associated with the callback list (which is maintained by
 *		this class).
 *
 *	Formal Parameters:
 *		Destructors have no parameters.
 *
 *	Return Value:
 *		Destructors have no return value.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	TransportInterfaceError 	RegisterTransportConnection (
 *			TransportConnection		transport_connection,
 *			PConnection				owner_object,
 *			BOOL					bNoNagle)
 *
 *	Functional Description:
 *		When an inbound connection is detected, an entry is created in the
 *		callback list for it using the default owner callback information (that
 *		was specified in the constructor).  This means that all events detected
 *		for the new transport connection will be sent to the default owner
 *		object until another object explicitly registers itself as the owner
 *		of the transport connection.  That is what this routine is used for.
 *
 *		Once an object has registered itself as the owner of a transport
 *		connection, it will receive all events related to that connection.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is the transport connection for which the callback information
 *			is to be associated.
 *		owner_object (i)
 *			This is the address of the Connection object that is to receive all transport
 *			layer events for the specified transport connection.
 *		bNoNagle (i)
 *			Should the connection stop using the Nagle algorithm?
 *
 *	Return Value:
 *		TRANSPORT_INTERFACE_NO_ERROR
 *			The operation completed successfully.
 *		TRANSPORT_INTERFACE_NO_SUCH_CONNECTION
 *			This indicates that the named transport connection does not exist.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	TransportError 	ConnectRequest (
 *			TransportAddress		transport_address,
 *			BOOL					bNoNagle,
 *			PConnection				owner_object,
 *			PTransportConnection	transport_connection)
 *
 *	Functional Description:
 *		This operation is invoked when the user application wishes to establish
 *		an outbound connection.  Assuming that everything is successful, the
 *		owner callback information that is passed in to this operation is saved
 *		for later use.  All events for this transport connection will be routed
 *		to the specified owner rather than the default owner.
 *
 *	Formal Parameters:
 *		transport_address (i)
 *			This is the transport address to be passed to the transport stack
 *			during the connection creation process.  The format of this address
 *			string will vary by transport stack, and cannot be specified here.
 *		bNoNagle (i)
 *			Do we need to disable the Nagle algorithm?
 *		owner_object (i)
 *			This is the address of the object that is to receive all transport
 *			layer events for the new transport connection.
 *		transport_connection (o)
 *			This is the address of the variable that is to receive the transport
 *			connection handle that is associated with this connection.  Note
 *			that this handle is assigned before the connection is actually
 *			established, to allow the application to abort a connection in
 *			progress.
 *
 *	Return Value:
 *		TRANSPORT_NO_ERROR
 *			The operation completed successfully.
 *		TRANSPORT_NOT_INITIALIZED
 *			The transport stack is not initialized.
 *
 *	Side Effects:
 *		An outbound connection establishment process is begun in the background.
 *
 *	Caveats:
 *		None.
 */
/*
 *	TransportError 	DisconnectRequest (
 *			TransportConnection		transport_connection)
 *
 *	Functional Description:
 *		This operation is used to break an existing transport connection.  If
 *		the operation is successful, the transport connection will be removed
 *		from the callback list.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is the transport connection that is to be broken.
 *
 *	Return Value:
 *		TRANSPORT_NO_ERROR
 *			The operation completed successfully.
 *		TRANSPORT_NOT_INITIALIZED
 *			The transport stack is not initialized.
 *		TRANSPORT_NO_SUCH_CONNECTION
 *			This indicates that the specified transport connection does not
 *			exist.
 *
 *	Side Effects:
 *		A transport connection is severed.
 *
 *	Caveats:
 *		None.
 */

/*
 *	TransportError 	PollReceiver ()
 *
 *	Functional Description:
 *		This operation is used to check a transport stack for incoming data (or
 *		other events, such as connect and disconnect indications).  In a single
 *		threaded environment, this call could also be used to provide a
 *		time-slice for the processing of inbound data, as well as other events
 *		(such as the creation of new connections).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRANSPORT_NO_ERROR
 *			The operation completed successfully.
 *
 *	Side Effects:
 *		This can result in callbacks from the transport layer back into this
 *		object.
 *
 *	Caveats:
 *		None.
 */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\token.h ===
/*
 *	token.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the Token class.  Objects of this class
 *		represent tokens in the MCS environment.  Whenever a token is allocated
 *		by a user, one of these objects is created.  Its job is to handle all
 *		requests that are specific to the token ID with which it is associated.
 *
 *		Tokens in the MCS environment are used for critical resource management.
 *		The exact use of tokens is up to the user applications attaching to
 *		MCS.  They are provided as a generic resource.
 *
 *		Tokens can be "owned" by one or more users.  There are two types of
 *		ownership.  There is exclusive ownership, where only one user can
 *		own the token at a time.  That user has "grabbed" the token.  And there
 *		is non-exclusive ownership, where several users can own the token at
 *		the same time.  Those users have "inhibited" the token.  It is not
 *		possible to mix exclusive and non-exclusive ownership.
 *
 *		If a user has grabbed a token, that same user can inhibit the token,
 *		thus converting to non-exclusive ownership.  Similarly, if a user is
 *		the sole inhibitor of a token, that user can grab the token, thus
 *		converting to exclusive ownership.
 *
 *		During a domain merge operation, it is necessary to merge tokens upward
 *		to the new Top Provider of the enlarged domain.  This class also defines
 *		a member function allowing it to be told to issue a merge request with
 *		all of its state contained therein.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_TOKEN_
#define	_TOKEN_

/*
 *	This is the class definition for the Token class.
 */
class	Token
{
public:

	Token (
			TokenID				token_id,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list);
	Token (
			TokenID				token_id,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list,
			TokenState			token_state,
			UserID				grabber,
			CUidList           *inhibitor_list,
			UserID				recipient);
	~Token ();

    void    SetTopProvider(PConnection top_provider) { m_pConnToTopProvider = top_provider; }
    BOOL    IsTopProvider(void) { return (m_pConnToTopProvider == NULL); }

				TokenState	GetTokenState () { return (Token_State); };
				BOOL    	IsValid ();
				Void		IssueMergeRequest ();
		Void		TokenGrabRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenGrabConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenInhibitRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenInhibitConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenGiveRequest (
									CAttachment        *originator,
									PTokenGiveRecord	pTokenGiveRec);
		Void		TokenGiveIndication (
									PTokenGiveRecord	pTokenGiveRec);
		Void		TokenGiveResponse (
									Result				result,
									UserID				receiver_id,
									TokenID				token_id);
		Void		TokenGiveConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenPleaseRequest (
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenPleaseIndication (
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenReleaseRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenReleaseConfirm (
									Result				result,
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);
		Void		TokenTestRequest (
									CAttachment        *originator,
									UserID				uidInitiator,
									TokenID				token_id);
		Void		TokenTestConfirm (
									UserID				uidInitiator,
									TokenID				token_id,
									TokenStatus			token_status);

	private:
				BOOL    	ValidateUserID (
									UserID				user_id);
			CAttachment    *GetUserAttachment (
									UserID				user_id);
				Void		IssueTokenReleaseIndication (
									UserID				user_id);
				Void		BuildAttachmentList (
									CUidList            *user_id_list,
									CAttachmentList     *attachment_list);

		TokenID				Token_ID;
		PDomain             m_pDomain;
		PConnection         m_pConnToTopProvider;
		CChannelList2      *m_pChannelList2;
		CAttachmentList    *m_pAttachmentList;
		TokenState			Token_State;
		UserID				m_uidGrabber;
		CUidList			m_InhibitorList;
		UserID				m_uidRecipient;
};

/*
 *	Token (
 *			TokenID				token_id,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list)
 *
 *	Functional Description:
 *		This is the constructor for the Token class.  It simply initializes
 *		local instance variables with the passed in values.  It also marks
 *		the state of the token as available.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token ID that this token object is associated with.
 *		local_provider (i)
 *			This is a pointer to the local provider.  A Token object will
 *			never actually send a command to the local provider, but it needs
 *			this value to use a parameter when it sends commands to various
 *			attachments (since it is doing so on behalf of the local provider).
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			Token object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by token objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by token
 *			objects to validate joined attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Token (
 *			TokenID				token_id,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list,
 *			TokenState			token_state,
 *			UserID				grabber,
 *			CUidList           *inhibitor_list,
 *			UserID				recipient)
 *
 *	Functional Description:
 *		This is the constructor for the Token class.  It simply initializes
 *		local instance variables with the passed in values.  It also marks
 *		the state of the token as available.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token ID that this token object is associated with.
 *		local_provider (i)
 *			This is a pointer to the local provider.  A Token object will
 *			never actually send a command to the local provider, but it needs
 *			this value to use a parameter when it sends commands to various
 *			attachments (since it is doing so on behalf of the local provider).
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			Token object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by token objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by token
 *			objects to validate joined attachments.
 *		token_state (i)
 *			This is the state of the token being merged.
 *		grabber (i)
 *			This is the user ID of the user who has the token grabbed (this is
 *			only valid if the token state is grabbed or giving).
 *		inhibitor_list (i)
 *			This is a list of the users who have the token inhibited (this is
 *			only valid if the token state is inhibited).
 *		recipient (i)
 *			This is the user ID of the user who is being offered the token
 *			as part of a give operation (this is only valid if the token state
 *			is giving or given).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~Token ()
 *
 *	Functional Description:
 *		This is a virtual destructor defined for the Token class.  It does
 *		nothing at this time.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		SetTopProvider (
 *						PConnection		top_provider)
 *
 *	Functional Description:
 *		This member function is used to change the identity of the Top Provider
 *		in an existing token.  The only time this will really occur is when
 *		a provider that used to be the Top Provider merges into another
 *		domain, and therefore ceases to be the Top Provider.  When the merge
 *		operation has been successfully completed, this function allows the
 *		domain to inform all of its Token objects about the identity of
 *		the new Top Provider.
 *
 *	Formal Parameters:
 *		top_provider (i)
 *			This is a pointer to the new Top Provider.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	TokenState		GetTokenState ()
 *
 *	Functional Description:
 *		This function returns the current state of the token.  This is used
 *		by the caller primarily during a merge operation, when decisions have
 *		to made about what tokens can and cannot be merged.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TOKEN_AVAILABLE if the token is not in use.
 *		TOKEN_GRABBED if the token is currently grabbed.
 *		TOKEN_INHIBITED if the token is currently inhiited.
 *		TOKEN_GIVING if the token is currently in the giving state.
 *		TOKEN_GIVEN if the token is currently in the given state.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL    	IsValid ()
 *
 *	Functional Description:
 *		This function returns TRUE if the token is still valid, or FALSE if the
 *		token needs to be deleted.  A token is valid if it has ANY owners
 *		(grabbers, inhibitors, or recipient).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE if the token is valid.
 *		FALSE if the token needs to be deleted.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			IssueMergeRequest ()
 *
 *	Functional Description:
 *		This function is called during a domain merge operation.  It causes
 *		the token object to pack it state and send it out in a merge token
 *		request to the top provider.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenGrabRequest (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to grab a token.  Depending
 *		on the current state of the token, the request will either succeed or
 *		fail.  Either way, an appropriate token grab confirm will be issued
 *		to the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenGrabConfirm (
 *							PCommandTarget		originator,
 *							Result				result,
 *							UserID				uidInitiator,
 *							TokenID				token_id,
 *							TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called as a result of the top provider answering a
 *		previous grab request.  It tells the user whether or not the request
 *		succeeded.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates
 *			that the token was successfully grabbed.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *		token_status (i)
 *			This is the status of the token after this request is processed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenInhibitRequest (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to inhibit a token.
 *		Depending on the current state of the token, the request will either
 *		succeed or fail.  Either way, an appropriate token inhibit confirm will
 *		be issued to the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenInhibitConfirm (
 *							PCommandTarget		originator,
 *							Result				result,
 *							UserID				uidInitiator,
 *							TokenID				token_id,
 *							TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called as a result of the top provider answering a
 *		previous inhibit request.  It tells the user whether or not the request
 *		succeeded.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates
 *			that the token was successfully inhibited.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *		token_status (i)
 *			This is the status of the token after this request is processed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGiveRequest (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This function is called when a user wishes to give a token to another
 *		user.  Depending on the current state of the token, the request will
 *		either succeed or fail.  Either way, an appropriate token grab confirm
 *		will be issued to the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGiveIndication (
 *					PCommandTarget		originator,
 *					PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This function is called when the top provider wants to indicate to a
 *		user that another user is offering them a token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGiveResponse (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				receiver_id,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called in response to a previous give indication.  It
 *		contains the user's answer as to whether or not the token was
 *		accepted.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates that
 *			the recipient has accepted the token.
 *		token_id (i)
 *			This is the token being acted upon.
 *		receiver_id (i)
 *			This is the ID of the user that is to receive the token.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenGiveConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called to send a confirmation back to a user who
 *		is trying to give away a token.  It lets the user know whether or
 *		not the operation was successful.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates that
 *			the recipient has accepted the token.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *		token_status (i)
 *			This is the status of the token after the operation.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenPleaseRequest (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to ask the current owners
 *		of a token to relinquish it.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenPleaseIndication (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This function is initially called by the top provider in response to
 *		a received token please request.  It is forwarded to all users who
 *		currently own the specified token, asking them to relinquish it.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	BOOL    		TokenReleaseRequest (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to release a token.
 *		Depending on the current state of the token, the request will either
 *		succeed or fail.  Either way, an appropriate token release confirm will
 *		be issued to the requesting user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenReleaseConfirm (
 *							PCommandTarget		originator,
 *							Result				result,
 *							UserID				uidInitiator,
 *							TokenID				token_id,
 *							TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called as a result of the top provider answering a
 *		previous release request.  It tells the user whether or not the request
 *		succeeded.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		result (i)
 *			This is the result of the request.  RESULT_SUCCESSFUL indicates
 *			that the token was successfully released.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *		token_status (i)
 *			This is the status of the token after this request is processed.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenTestRequest (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id)
 *
 *	Functional Description:
 *		This function is called when a user wishes to test the current state
 *		of a token.  The token will issue a token test confirm to the
 *		originating user containing the requested information.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void			TokenTestConfirm (
 *							PCommandTarget		originator,
 *							UserID				uidInitiator,
 *							TokenID				token_id,
 *							TokenStatus			token_status)
 *
 *	Functional Description:
 *		This function is called as a result of the top provider answering a
 *		previous test request.  It tells the user the current state of the
 *		token.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is a pointer to the attachment that leads to the originator
 *			of the request.
 *		uidInitiator (i)
 *			This is the user ID of the user that originated the request.
 *		token_id (i)
 *			This is the token being tested.
 *		token_status (i)
 *			This is the current status of the token.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\spacket.h ===
/*
 *	spacket.h
 *
 *	Copyright (c) 1997-98 by Microsoft Corporation, Redmond, WA
 *
 *	Abstract:
 *		This is the interface file for the SimplePacket class.  Instances of this
 *		class represent Protocol Data Units (PDUs) as they flow through the
 *		system.  Objects of this class can not be instantiated, because it's a 
 *		pure virtual class.  It exists only to be inherited from.  The Packet
 *		and DataPacket classes inherit from this one.  
 *
 *		A packet object can be created in 2 different ways.  It can be created
 *		with either decoded data or encoded data.  During instantiation, the
 *		new packet object will calculate how much memory it will need to
 *		hold both the encoded and decoded data, and attempts to allocate that
 *		memory.  If it cannot, then it will report an error, and the newly
 *		created object should be immediately destroyed.  If the allocations are
 *		successful, then the packet will report success, but WILL NOT yet put
 *		any data into those allocated buffers.
 *
 *		When a Lock message is sent to the object, it will put encoded
 *		data into the pre-allocated encode buffer.  If the packet was created
 *		with decoded data, then this will entail an encode operation.  However,
 *		if the packet was created with encoded data, then it is smart enough
 *		to just COPY the encoded data into the internal buffer, thus avoiding
 *		the overhead associated with the encode operation.
 *                  
 *		When a Lock message is sent to the object, it will put decoded
 *		data into the pre-allocated decode buffer.  If the packet was created
 *		with encoded data, then this will entail a decode operation.  However,
 *		if the packet was created with decoded data, then it is smart enough
 *		to just COPY the decoded data into the internal buffer, thus avoiding
 *		the overhead associated with the decode operation.
 *                  
 *	Caveats:
 *		None.
 *
 *	Authors:
 *		Christos Tsollis
 */

#ifndef _SIMPLE_PACKET_
#define _SIMPLE_PACKET_

/*
 *	This typedef is used to define possible return values from various public
 *	member functions of this class.
 */
typedef	enum
{
	PACKET_NO_ERROR,
	PACKET_MALLOC_FAILURE,
	PACKET_INCOMPATIBLE_PROTOCOL
} PacketError;
typedef	PacketError * 		PPacketError;

/*
 *	 Definition of class Packet.
 */

class SimplePacket
{
public:
							SimplePacket(BOOL fPacketDirectionUp);
	virtual					~SimplePacket(void) = 0;

	Void					Lock(void)
							{
								InterlockedIncrement(&lLock);
								ASSERT (lLock > 0);
							};
	UINT					GetEncodedDataLength(void) 
							{ 
								return (Encoded_Data_Length); 
							};

	void					Unlock(void);
			LPBYTE			GetEncodedData (void) 
							{ 
								ASSERT (m_EncodedPDU);
								return m_EncodedPDU;
							};
	virtual PVoid			GetDecodedData(void) = 0;
	virtual BOOL			IsDataPacket (void) = 0;
	virtual int				GetPDUType (void) = 0;

protected:
	
	long			lLock;
	LPBYTE			m_EncodedPDU;			// The encoded data pdu.
	BOOL			Packet_Direction_Up;
	UINT			Encoded_Data_Length; 	// the size of the whole encoded PDU.
};


/*
 *	SimplePacket ()
 *
 *	Functional Description:
 *		This is the default constructor of a SimplePacket.  It initializes 
 *		the few member variables to default values.
 *
 
/*
 *	~SimplePacket ()
 *
 *	Functional Description:
 *		Destructor for the SimplePacket class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetEncodedData ()
 *
 *	Functional Description:
 *		The GetEncodedData method returns a pointer to the encoded data
 *		buffer.  If the Packet object is oriented differently than desired
 *		by the caller of this method, then the packet coder is called to
 *		reverse the direction of the PDU.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the encoded data.  If an encoding error occurs, this
 *		method will return NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	GetDecodedData ()
 *
 *	Functional Description:
 *		The GetDecodedData method returns a pointer to the decoded data
 *		buffer.  
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the decoded data.  If an decoding error occurs, this
 *		method will return NULL.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\user.h ===
/*
 *	user.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the User class.  Instances of this class
 *		represent attachments between user applications and domains within MCS.
 *
 *		This class inherits from CommandTarget.  This means that all message
 *		traffic between this class and other CommandTarget classes is in MCS
 *		commands.  Not all commands need to be handled (some are not relevant
 *		for user attachments).  For example, a user attachment should never
 *		receive a SendDataRequest.  It should only receive indications,
 *		confirms, and ultimatums.
 *
 *		Messages coming from the application pass through one of these objects,
 *		where they are translated into MCS commands before being sent to the
 *		domain to which this user is attached.  This usually involves adding
 *		the correct user ID, as well as a fair amount of error checking and
 *		parameter validation.
 *
 *		It is worth noting that this class contains two types of public member
 *		functions.  The first type represent messages flowing from the user
 *		application into MCS.  All of these member functions are inherited from the
 *		IMCSSap interface.  These are converted as memntioned above, and sent
 *		into the appropriate domain if everything checks out.  The second type
 *		of public member function represents messages flowing from within MCS
 *		to the user application.  All of these member function are overrides
 *		of virtual functions defined in class CommandTarget, and are not
 *		prefixed with anything.
 *
 *		Messages coming from the domain are translated into T.122 indications
 *		and confirms, and sent to the proper application interface object via
 *		the owner callback mechanism.
 *
 *		A third duty of this class is to post indications and confirms to user
 *		applications using a client window.  The client must dispatch messages
 *		to receive these indications/confirms.  It also
 *		prevents a user application from having to worry about receiving an
 *		indication or confirm before they have even returned from the request
 *		that caused it.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

#ifndef	_USER_
#define	_USER_

/*
 *	Interface files.
 */
#include "pktcoder.h"
#include "imcsapp.h"
#include "attmnt.h"

/*
 *	These types are used to keep track of what users have attached to MCS
 *	within a given process, as well as pertinent information about that
 *	attachment.
 *
 *	BufferRetryInfo
 *		In cases where MCSSendDataRequest and MCSUniformSendDataRequest fail
 *		due to a lack of resources, this structure will be used to capture
 *		appropriate information such that follow-up resource level checks can
 *		be performed during timer events.
 */

typedef struct
{
	ULong					user_data_length;
	UINT_PTR				timer_id;
} BufferRetryInfo;
typedef BufferRetryInfo *		PBufferRetryInfo;

/*
 *	These are the owner callback functions that a user object can send to an
 *	object whose public interface is unknown to it.  The first one is sent to
 *	the controller when a user object detects the need to delete itself.  The
 *	rest are sent to an application interface object as part of communicating
 *	with the user application (the proper application interface object is
 *	identified to this class as one of its constructor parameters).
 *
 *	When an object instantiates a user object (or any other object that uses
 *	owner callbacks), it is accepting the responsibility of receiving and
 *	handling those callbacks.  For that reason, any object that issues owner
 *	callbacks will have those callbacks defined as part of the interface file
 *	(since they really are part of a bi-directional interface).
 *
 *	Each owner callback function, along with a description of how its parameters
 *	are packed, is described in the following section.
 */

/*
 *	This macro is used to pack callback parameters into a single long word
 *	for delivery to the user application.
 */
#define PACK_PARAMETER(l,h)	((ULong) (((UShort) (l)) | \
							(((ULong) ((UShort) (h))) << 16)))

/*
 *	TIMER_PROCEDURE_TIMEOUT
 *		This macro specifies the granularity, in milliseconds, of any timer
 *		which may be created to recheck resource levels following a call to
 *		MCSSendDataRequest or MCSUniformSendDataRequest which returned
 *		MCS_TRANSMIT_BUFFER_FULL.
 *	CLASS_NAME_LENGTH
 *		The class name of the window class for all User-related windows.  These
 *		are the client windows that receive messages related to MCS indications and
 *		confirms that have to be delivered to the client apps.
 */
#define TIMER_PROCEDURE_TIMEOUT			300
#define	CLASS_NAME_LENGTH				35

/*
 *	This is the function signature of the timer procedure.  Timer messages will
 *	be routed to this function as a result of timer events which have been set
 *	up to recheck resource levels.  This would happen following a call to either
 *	SendData or GetBuffer call which resulted in a return
 *	value of MCS_TRANSMIT_BUFFER_FULL.
 */
Void CALLBACK TimerProc (HWND, UINT, UINT, DWORD);

/*	Client window procedure declarations
 *
 *	UserWindowProc
 *		Declaration of the window procedure used to deliver all MCS messages
 *		to MCS apps (clients).  The MCS main thread sends msgs to a client
 *		window with this window procedure.  The window procedure is then
 *		responsible to deliver the callback to the MCS client.
 */
LRESULT CALLBACK	UserWindowProc (HWND, UINT, WPARAM, LPARAM);

// Data packet queue
class CDataPktQueue : public CQueue
{
    DEFINE_CQUEUE(CDataPktQueue, PDataPacket)
};

// timer user object list
class CTimerUserList2 : public CList2
{
    DEFINE_CLIST2(CTimerUserList2, PUser, UINT_PTR) // timerID
};

// memory and buffer list
class CMemoryBufferList2 : public CList2
{
    DEFINE_CLIST2(CMemoryBufferList2, PMemory, LPVOID)
};

/*
 *	This is the actual class definition for the User class.  It inherits from
 *	CommandTarget (which in turn inherits from Object).  It has only one
 *	constructor, which tells the newly created object who it is, who the
 *	controller is, and who the proper application interface object is.  It also
 *	has a destructor, to clean up after itself.  Most importantly, it has
 *	one public member function for each MCS command that it must handle.
 */
class User: public CAttachment, public CRefCount, public IMCSSap
{
	friend Void CALLBACK TimerProc (HWND, UINT, UINT, DWORD);
	friend LRESULT CALLBACK UserWindowProc (HWND, UINT, WPARAM, LPARAM);
	public:
						User (PDomain, PMCSError);
		virtual			~User ();

		static BOOL		InitializeClass (void);
		static void		CleanupClass (void);

		/*	-------  IMCSSap interface --------	*/
		MCSAPI		 	ReleaseInterface(void);

		MCSAPI			GetBuffer (UINT, PVoid *);
		MCSAPI_(void)	FreeBuffer (PVoid);
		MCSAPI			ChannelJoin (ChannelID);
		MCSAPI			ChannelLeave (ChannelID);
		MCSAPI			ChannelConvene ();
		MCSAPI			ChannelDisband (ChannelID);
		MCSAPI			ChannelAdmit (ChannelID, PUserID, UINT);
		MCSAPI			SendData (DataRequestType, ChannelID, Priority, unsigned char *, ULong, SendDataFlags);
		MCSAPI			TokenGrab (TokenID);
		MCSAPI			TokenInhibit (TokenID);
		MCSAPI			TokenGive (TokenID, UserID);
		MCSAPI			TokenGiveResponse (TokenID, Result);
		MCSAPI			TokenPlease (TokenID);
		MCSAPI			TokenRelease (TokenID);
		MCSAPI			TokenTest (TokenID);
				
#ifdef USE_CHANNEL_EXPEL_REQUEST
		MCSError		MCSChannelExpelRequest (ChannelID, PMemory, UINT);
#endif // USE_CHANNEL_EXPEL_REQUEST

				void	SetDomainParameters (PDomainParameters);
        virtual void    PlumbDomainIndication(ULONG height_limit) { };
		virtual	void	PurgeChannelsIndication (CUidList *, CChannelIDList *);
        virtual void    PurgeTokensIndication(PDomain, CTokenIDList *) { };
		virtual void	DisconnectProviderUltimatum (Reason);
		virtual	void	AttachUserConfirm (Result, UserID);
		virtual	void	DetachUserIndication (Reason, CUidList *);
		virtual	void	ChannelJoinConfirm (Result, UserID, ChannelID, ChannelID);
				void	ChannelLeaveIndication (Reason, ChannelID);
		virtual	void	ChannelConveneConfirm (Result, UserID, ChannelID);
		virtual	void	ChannelDisbandIndication (ChannelID);
		virtual	void	ChannelAdmitIndication (UserID, ChannelID, CUidList *);
		virtual	void	ChannelExpelIndication (ChannelID, CUidList *);
		virtual	void	SendDataIndication (UINT, PDataPacket);
		virtual	void	TokenGrabConfirm (Result, UserID, TokenID, TokenStatus);
		virtual	void	TokenInhibitConfirm (Result, UserID, TokenID, TokenStatus);
		virtual	void	TokenGiveIndication (PTokenGiveRecord);
		virtual	void	TokenGiveConfirm (Result, UserID, TokenID, TokenStatus);
		virtual	void	TokenPleaseIndication (UserID, TokenID);
		        void	TokenReleaseIndication (Reason, TokenID);
		virtual	void	TokenReleaseConfirm (Result, UserID, TokenID, TokenStatus);
		virtual	void	TokenTestConfirm (UserID, TokenID, TokenStatus);
		virtual	void	MergeDomainIndication (MergeStatus);
				void	RegisterUserAttachment (MCSCallBack, PVoid, UINT);
				void	IssueDataIndication (UINT, PDataPacket);


	private:
		MCSError		ValidateUserRequest ();
		void			CreateRetryTimer (ULong);
		MCSError		ChannelJLCD (int, ChannelID);
		void			ChannelConfInd (UINT, ChannelID, UINT);
		MCSError		TokenGIRPT (int, TokenID);
		void			TokenConfInd (UINT, TokenID, UINT);
		void			PurgeMessageQueue ();

	// Static member variables
	static CTimerUserList2 *s_pTimerUserList2;
	static HINSTANCE		s_hInstance;
	
		PDomain				m_pDomain;
		UserID				User_ID;
		UserID				m_originalUser_ID;
		BOOL				Merge_In_Progress;
		BOOL				Deletion_Pending;
		ULong				Maximum_User_Data_Length;
		HWND				m_hWnd;

		MCSCallBack			m_MCSCallback;
		PVoid				m_UserDefined;
		BOOL				m_fDisconnectInDataLoss;
		BOOL				m_fFreeDataIndBuffer;
		CDataPktQueue		m_DataPktQueue;
		CDataPktQueue		m_PostMsgPendingQueue;
		CMemoryBufferList2	m_DataIndMemoryBuf2;
		PBufferRetryInfo	m_BufferRetryInfo;
};

/*
 *	User (PCommandTarget		top_provider)
 *
 *	Functional Description:
 *		This is the constructor for the user object.  Its primary purpose is
 *		to "insert" itself into the layered structure built by the controller.
 *		To do this it must register itself with the objects above and below it.
 *
 *		It first registers itself with the application interface object
 *		identified as one of the parameters.  This assures that any traffic
 *		from the application will get to this object correctly.
 *
 *		It then issues an attach user request to the domain object identified
 *		by another of the parameters.  This informs the domain of the users
 *		presence and also kicks off the process of attaching to that domain.
 *		Note that the object is not really attached to the domain until it
 *		receives a successful attach user confirm.
 *
 *	Formal Parameters:
 *		top_provider (i)
 *			This is a pointer to the domain object to which this user should
 *			attach.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~User ()
 *
 *	Functional Description:
 *		This is the destructor for the user class.  It detaches itself from the
 *		objects above and below it, and frees any outstanding resources that
 *		it may holding in conjunction with unsent user messages.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	DetachUser ()
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.  It will also cause the user object to destroy itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelJoin (
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the channel that the user application wishes to join.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelLeave (
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the channel that the user application wishes to leave.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelConvene ()
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelDisband (
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the channel that the user wishes to disband.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelAdmit (
 *						ChannelID			channel_id,
 *						PUserID				user_id_list,
 *						UINT				user_id_count)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the private channel for which the user wishes to expand
 *			the authorized user list.
 *		user_id_list (i)
 *			This is an array containing the user IDs of the users to be added
 *			to the authorized user list.
 *		user_id_count (i)
 *			This is the number of user IDs in the above array.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	ChannelExpel (
 *						ChannelID			channel_id,
 *						PUserID				user_id_list,
 *						UINT				user_id_count)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the private channel for which the user wishes to shrink
 *			the authorized user list.
 *		user_id_list (i)
 *			This is an array containing the user IDs of the users to be removed
 *			from the authorized user list.
 *		user_id_count (i)
 *			This is the number of user IDs in the above array.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	SendData (
 *						ChannelID			channel_id,
 *						Priority			priority,
 *						PUChar				user_data,
 *						ULong				user_data_length)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the channel that the user application wishes to transmit
 *			data on.
 *		priority (i)
 *			This is the priority at which the data is to be transmitted.
 *		user_data (i)
 *			This is the address of the data to be transmitted.
 *		user_data_length (i)
 *			This is the length of the data to be transmitted.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request has failed because the required memory could not be
 *			allocated.  It is the responsibility of the user application to
 *			repeat the request at a later time.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	MCSError	TokenGrab (
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to grab.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenInhibit (
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to inhibit.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenGive (
 *						TokenID				token_id,
 *						UserID				receiver_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to give away.
 *		receiver_id (i)
 *			This is the ID of the user to receive the token.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenGiveResponse (
 *						TokenID				token_id,
 *						Result				result)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token that the user application is either accepting or
 *			rejecting in response to a previous give indication from another
 *			user.
 *		result (i)
 *			This parameter specifies whether or not the token was accepted.
 *			Success indicates acceptance while anything else indicates that the
 *			token was not accepted.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenPlease (
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to ask for.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenRelease (
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to release.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	MCSError	TokenTest(
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This request comes from the application interface object in response
 *		to the same request from a user application.  This object can then
 *		re-package the request as an MCS command and send it to the domain
 *		object.
 *
 *	Formal Parameters:
 *		token_id (i)
 *			This is the token the user application wishes to test the state of.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_TRANSMIT_BUFFER_FULL
 *			The request could not be processed due to a resource shortage
 *			within MCS.  The application is responsible for re-trying the
 *			request at a later time.
 *		MCS_INVALID_PARAMETER
 *			The user attempted to perform an operation on token 0, which is not
 *			a valid token.
 *		MCS_USER_NOT_ATTACHED
 *			The user is not attached to the domain.  This could indicate that
 *			the user application issued a request without waiting for the
 *			attach user confirm.
 *		MCS_DOMAIN_MERGING
 *			This operation could not be performed due to a local merge operation
 *			in progress.  The user application must retry at a later time.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SetDomainParameters (
 *					PDomainParameters	domain_parameters)
 *
 *	Functional Description:
 *		This member function is called whenever the domain parameters change
 *		as the result of accepting a first connection.  It informs the user
 *		object of a change in the maximum PDU size, which is used when creating
 *		outbound data PDUs.
 *
 *	Formal Parameters:
 *		domain_parameters (i)
 *			Pointer to a structure that contains the current domain parameters
 *			(those that are in use).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		PlumbDomainIndication (
 *						PCommandTarget		originator,
 *						ULong				height_limit)
 *
 *	Functional Description:
 *		This command is issued by the domain object during a plumb domain
 *		operation.  This is not relevant to user objects, and should be ignored.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		height_limit (i)
 *			This is height value passed through during the plumb operation.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		PurgeChannelsIndication (
 *						PCommandTarget		originator,
 *						CUidList           *purge_user_list,
 *						CChannelIDList     *purge_channel_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when purging channels
 *		from the lower domain during a domain merge operation.
 *
 *		The user object will issue one MCS_DETACH_USER_INDICATION object for
 *		each user in the user list.  Furthermore, if the user objects finds
 *		its own user ID in the list, it will destroy itself.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		purge_user_list (i)
 *			This is a list of user IDs that are to be purged from the lower
 *			domain.
 *		purge_channel_list (i)
 *			This is a list of channel IDs that are to be purged from the lower
 *			domain.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	PurgeTokensIndication (
 *					PCommandTarget		originator,
 *					CTokenIDList       *token_id_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when purging tokens from
 *		the lower domain during a domain merge operation.  IT is not relevant
 *		to a user object, and is therefore ignored.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		token_id (i)
 *			This is the ID of the token that is being purged.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DisconnectProviderUltimatum (
 *					PCommandTarget		originator,
 *					Reason				reason)
 *
 *	Functional Description:
 *		This command is issued by the domain object when it is necessary to
 *		force a user from the domain.  This usually happens in response to
 *		the purging of an entire domain (either this user was in the bottom
 *		of a disconnected domain or the domain was deleted locally by user
 *		request).
 *
 *		If the user was already attached to the domain, this will result in a
 *		DETACH_USER_INDICATION with the local user ID.  Otherwise this will
 *		result is an ATTACH_USER_CONFIRM with a result of UNSPECIFIED_FAILURE.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		reason (i)
 *			This is the reason parameter to be issued to the local user
 *			application.  See "mcatmcs.h" for a complete list of possible reaons.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	AttachUserConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to the
 *		attach user request issued by this object during construction.  If the
 *		result is successful, then this user is now attached and may request
 *		MCS services through this attachment.
 *
 *		An ATTACH_USER_CONFIRM will be issued to the user application.  If the
 *		result is not successful, this object will delete itself.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the attach request.
 *		uidInitiator (i)
 *			If the result was successful, this is the new user ID associated
 *			with this attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	DetachUserIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when one or more users leave
 *		the domain.
 *
 *		An MCS_DETACH_USER_INDICATION is issued to the user application for each
 *		user in the list.  Furthermore, if the user finds its own ID in the
 *		list, then it will destroy itself.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		reason (i)
 *			This is the reason for the detachment.  Possible values are listed
 *			in "mcatmcs.h".
 *		user_id_list (i)
 *			This is a list user IDs of the users that are leaving.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelJoinConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			requested_id,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		channel join request.
 *
 *		A CHANNEL_JOIN_CONFIRM is issued to the user application.  Note that a
 *		user is not really considered to be joined to a channel until a
 *		successful confirm is received.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result from the join request.  If successful, then the
 *			user is now joined to the channel.
 *		uidInitiator (i)
 *			This is the user ID of the requestor.  It will be the same as the
 *			local user ID (or else this command would not have gotten here).
 *		requested_id (i)
 *			This is the ID of the channel that the user originally requested
 *			to join.  This will differ from the ID of the channel actually
 *			joined only if this ID is 0 (which identifies a request to join an
 *			assigned channel).
 *		channel_id (i)
 *			This is the channel that is now joined.  This is important for
 *			two reasons.  First, it is possible for a user to have more than
 *			one outstanding join request, in which case this parameter
 *			identifies which channel this confirm is for.  Second, if the
 *			request is for channel 0 (zero), then this parameter identifies
 *			which assigned channel the user has successfully joined.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	ChannelLeaveIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object when a user loses its right
 *		to use a channel.
 *
 *		A CHANNEL_LEAVE_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		reason (i)
 *			This is the reason for the lost channel.  Possible values are listed
 *			in "mcatmcs.h".
 *		channel (i)
 *			This is the channel that the user can no longer use.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelConveneConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		channel convene request.
 *
 *		A CHANNEL_CONVENE_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result from the convene request.  If successful, then
 *			a private channel has been created, with this user as the manager.
 *		uidInitiator (i)
 *			This is the user ID of the requestor.  It will be the same as the
 *			local user ID (or else this command would not have gotten here).
 *		channel_id (i)
 *			This is the channel ID for the newly created private channel.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelDisbandIndication (
 *					PCommandTarget		originator,
 *					ChannelID			channel_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object to the manager of a private
 *		channel when MCS determines the need to disband the channel.  This will
 *		usually be done only if the channel is purged during a domain merger.
 *
 *		A CHANNEL_DISBAND_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		channel_id (i)
 *			This is the channel ID of the private channel that is being
 *			disbanded.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelAdmitIndication (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when a user is admitted to
 *		a private channel by the manager of that channel.  It informs the user
 *		that the channel can be used.
 *
 *		A CHANNEL_ADMIT_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		uidInitiator (i)
 *			This is the user ID of the private channel manager.
 *		channel_id (i)
 *			This is the channel ID of the private channel to which the user has
 *			been admitted.
 *		user_id_list (i)
 *			This is a container holding the IDs of the users that have been
 *			admitted.  By the time this reaches a particular user, that user
 *			should be the only one in the list (since the list is broken apart
 *			and forwarded in the direction of the contained users, recursively).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelExpelIndication (
 *						PCommandTarget		originator,
 *						ChannelID			channel_id,
 *						CUidList           *user_id_list)
 *
 *	Functional Description:
 *		This command is issued by the domain object when a user is expelled from
 *		a private channel by the manager of that channel.  It informs the user
 *		that the channel can no longer be used.
 *
 *		A CHANNEL_EXPEL_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		channel_id (i)
 *			This is the channel ID of the private channel from which the user
 *			has been expelled.
 *		user_id_list (i)
 *			This is a container holding the IDs of the users that have been
 *			expelled.  By the time this reaches a particular user, that user
 *			should be the only one in the list (since the list is broken apart
 *			and forwarded in the direction of the contained users, recursively).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	SendDataIndication (
 *					PCommandTarget		originator,
 *					UINT				message_type,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This command is issued by the domain object when non-uniform data
 *		data is received on a channel to which this user is joined.
 *
 *		A SEND_DATA_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		message_type (i)
 *			normal or uniform send data indication
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	TokenGrabConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token grab request.
 *
 *		A TOKEN_GRAB_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the grab request.  If successful, the user
 *			now exclusively owns the token.
 *		uidInitiator (i)
 *			This is the user ID of the user that made the grab request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the grab confirm is for.  It
 *			is possible to have more than one outstanding grab request, so this
 *			parameter tells the user application which request has been
 *			satisfied by this confirm.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the grab request.  This will be SELF_GRABBED if the grab
 *			request was successful.  It will be something else if not (see
 *			"mcatmcs.h" for a list of possible token status values).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenInhibitConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token inhibit request.
 *
 *		A TOKEN_INHIBIT_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the inhibit request.  If successful, the user
 *			now non-exclusively owns the token.
 *		uidInitiator (i)
 *			This is the user ID of the user that made the inhibit request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the inihibit confirm is for.
 *			It is possible to have more than one outstanding inihibit request,
 *			so this parameter tells the user application which request has been
 *			satisfied by this confirm.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the inhibit request.  This will be SELF_INHIBITED if the
 *			inhibit request was successful.  It will be something else if not
 *			(see "mcatmcs.h" for a list of possible token status values).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveIndication (
 *						PCommandTarget		originator,
 *						PTokenGiveRecord	pTokenGiveRec)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a remote
 *		token give request (with the local user listed as the desired receiver).
 *
 *		A TOKEN_GIVE_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		pTokenGiveRec (i)
 *			This is the address of a structure containing the following information:
 *			The ID of the user attempting to give away the token.
 *			The ID of the token being given.
 *			The ID of the user that the token is being given to.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenGiveConfirm (
 *						PCommandTarget		originator,
 *						Result				result,
 *						UserID				uidInitiator,
 *						TokenID				token_id,
 *						TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token give request.
 *
 *		A TOKEN_GIVE_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the give request.  If successful, the user
 *			no longer owns the token.
 *		uidInitiator (i)
 *			This is the user ID of the user that made the give request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the give confirm is for.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the give request.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		TokenPleaseIndication (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						TokenID				token_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object to all owners of a token
 *		when a user issues a token please request for that token.
 *
 *		A TOKEN_PLEASE_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		uidInitiator (i)
 *			This is the user ID of the user that made the please request.
 *		token_id (i)
 *			This is the ID of the token which the please request is for.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenReleaseIndication (
 *					PCommandTarget		originator,
 *					Reason				reason,
 *					TokenID				token_id)
 *
 *	Functional Description:
 *		This command is issued by the domain object when a token is taken
 *		away from its current owner.
 *
 *		A TOKEN_RELEASE_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		reason (i)
 *			This is the reason the token is being taken away.
 *		token_id (i)
 *			This is the ID of the token that is being taken away.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenReleaseConfirm (
 *					PCommandTarget		originator,
 *					Result				result,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token release request.
 *
 *		A TOKEN_RELEASE_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		result (i)
 *			This is the result of the release request.  If successful, the user
 *			no longer owns the token (if it ever did)
 *		uidInitiator (i)
 *			This is the user ID of the user that made the release request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the release confirm is for.
 *			It is possible to have more than one outstanding release request,
 *			so this parameter tells the user application which request has been
 *			satisfied by this confirm.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the release request.  This will be NOT_IN_USE or
 *			OTHER_INHIBITED if the release request was successful.  It will be
 *			something else if not (see "mcatmcs.h" for a list of possible token
 *			status values).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	TokenTestConfirm (
 *					PCommandTarget		originator,
 *					UserID				uidInitiator,
 *					TokenID				token_id,
 *					TokenStatus			token_status)
 *
 *	Functional Description:
 *		This command is issued by the domain object in response to a previous
 *		token test request.
 *
 *		A TOKEN_TEST_CONFIRM is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		uidInitiator (i)
 *			This is the user ID of the user that made the test request.  This
 *			will be the same as the local user ID (or else this command would
 *			not have gotten here).
 *		token_id (i)
 *			This is the ID of the token which the test confirm is for.
 *			It is possible to have more than one outstanding test request,
 *			so this parameter tells the user application which request has been
 *			satisfied by this confirm.
 *		token_status (i)
 *			This is the status of the token at the time the Top Provider
 *			serviced the test request (see "mcatmcs.h" for a list of possible
 *			token status values).
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void	MergeDomainIndication (
 *					PCommandTarget		originator,
 *					MergeStatus			merge_status)
 *
 *	Functional Description:
 *		This command is issued by a domain when it begins a merge operation.
 *		It is issued again when the merge operation is complete.
 *
 *		A MERGE_DOMAIN_INDICATION is issued to the user application.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This identifies the CommandTarget from which the command came (which
 *			should be the domain object).
 *		merge_status (i)
 *			This is the current merge status.  It will indicate either that the
 *			merge operation is in progress, or that it is complete.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		FlushMessageQueue (
 *						Void)
 *
 *	Functional Description:
 *		This function is periodically called by the controller to allocate a
 *		time slice to the user object.  It is during this time slice that this
 *		object will issue its queued messages to the user application.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\translat.h ===
/*
 *	translat.h
 *
 *	Copyright (c) 1993 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo
 */
#ifndef	_REASON_RESULT_TRANSLATOR_
#define	_REASON_RESULT_TRANSLATOR_

#include "gccpdu.h"

GCCResult				TranslateCreateResultToGCCResult (
						ConferenceCreateResult		create_result);

GCCResult				TranslateQueryResultToGCCResult (
						ConferenceQueryResult		query_result);

GCCResult				TranslateJoinResultToGCCResult (
						ConferenceJoinResult		join_result);

GCCResult				TranslateInviteResultToGCCResult (
						ConferenceInviteResult		invite_result);

GCCResult				TranslateRegistryRespToGCCResult(
						RegistryResponseResult		response_result);

ConferenceCreateResult	TranslateGCCResultToCreateResult (
						GCCResult 					gcc_result);

ConferenceQueryResult	TranslateGCCResultToQueryResult (
						GCCResult 					gcc_result);

ConferenceJoinResult	TranslateGCCResultToJoinResult (
						GCCResult 					gcc_result);

ConferenceInviteResult	TranslateGCCResultToInviteResult (
						GCCResult 					gcc_result);

RegistryResponseResult	TranslateGCCResultToRegistryResp(
						GCCResult					gcc_result);

GCCReason				TranslateTerminateRqReasonToGCCReason (
						ConferenceTerminateRequestReason 	reason);

ConferenceTerminateRequestReason	
						TranslateGCCReasonToTerminateRqReason (
						GCCReason 					gcc_reason);

GCCReason				TranslateEjectIndReasonToGCCReason(
						ConferenceEjectIndicationReason	eject_reason);

ConferenceEjectIndicationReason						
						TranslateGCCReasonToEjectInd (
						GCCReason					gcc_reason);

GCCResult				TranslateEjectResultToGCCResult(
						ConferenceEjectResult		eject_result);

ConferenceEjectResult	TranslateGCCResultToEjectResult (
						GCCResult					gcc_result);

GCCReason				TranslateTerminateInReasonToGCCReason (
						ConferenceTerminateIndicationReason	reason);

ConferenceTerminateIndicationReason
						TranslateGCCReasonToTerminateInReason (
						GCCReason							gcc_reason);

ConferenceTerminateResult	
						TranslateGCCResultToTerminateResult (
						GCCResult						gcc_result);

GCCResult				TranslateTerminateResultToGCCResult (
						ConferenceTerminateResult		result);

ConferenceLockResult	TranslateGCCResultToLockResult (
								GCCResult				gcc_result);

GCCResult				TranslateLockResultToGCCResult (
								ConferenceLockResult	result);

ConferenceUnlockResult	TranslateGCCResultToUnlockResult (
								GCCResult				gcc_result);

GCCResult				TranslateUnlockResultToGCCResult (
								ConferenceUnlockResult	result);

ConferenceAddResult		TranslateGCCResultToAddResult (
								GCCResult				gcc_result);

GCCResult				TranslateAddResultToGCCResult (
								ConferenceAddResult		add_result);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\userchnl.h ===
/*
 *	userchnl.h
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the UserChannel class.  Objects of this
 *		class represent user ID channels in the MCS environment.  This class
 *		inherits most of its behavior from class Channel.  In fact, with the
 *		exception of how user channels are joined, and how merge commands are
 *		constructed, this class works exactly the same as class Channel.
 *
 *		When a user attaches to a domain, each provider in the path from the
 *		Top Provider to the user will create an object of this class.  Unlike
 *		static and assigned channels, it is NOT necessary for the user to
 *		be joined to the channel for the channel to exist.  It is perfectly
 *		legal to have a user channel that no one is joined to.
 *
 *		The major distinguishing characteristic of user channels is that they
 *		know the user ID of the user they are associated with.  They will
 *		only allow that user to join the channel.  Furthermore, when the user
 *		leaves the usert channel, the LeaveRequest does not return a value
 *		asking to be deleted.  Anyone can send data on a user ID channel.
 *
 *		The merge channel command is constructed slightly differently for user
 *		channels, so that behavior is overridden here as well.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
#ifndef	_USERCHANNEL_
#define	_USERCHANNEL_

/*
 *	This is the class definition for the UserChannel class.
 */
class	UserChannel : public Channel
{
public:
	UserChannel (
			ChannelID			channel_id,
			CAttachment        *user_attachment,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list);
	UserChannel (
			ChannelID			channel_id,
			CAttachment        *user_attachment,
			PDomain             local_provider,
			PConnection         top_provider,
			CChannelList2      *channel_list,
			CAttachmentList    *attachment_list,
			PConnection         pConn);
    virtual					~UserChannel ();
		virtual Channel_Type	GetChannelType ();
		virtual	BOOL    		IsValid ();
		virtual CAttachment *GetAttachment(void);
		virtual	Void			IssueMergeRequest ();
		virtual Void			ChannelJoinRequest (
										CAttachment        *originator,
										UserID				uidInitiator,
										ChannelID			channel_id);
		virtual Void			SendDataRequest (
										CAttachment        *originator,
										UINT				type,
										PDataPacket			data_packet);

private:

    CAttachment         *m_pUserAttachment;
};
typedef	UserChannel *			PUserChannel;

/*
 *	UserChannel (
 *			ChannelID			channel_id,
 *			PCommandTarget		user_attachment,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list)
 *
 *	Functional Description:
 *		This is the normal constructor for the UserChannel class.  It simply
 *		initializes the instance variables that identify the channel, the local
 *		provider, the top provider, and the user attachment.  The attachment
 *		list is empty by default (meaning that the user is not yet joined to
 *		its channel).
 *
 *		Upon successful construction of this object, an attach user confirm
 *		is automatically issued to the user.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		user_attachment (i)
 *			This is the attachment which leads to the user represented by this
 *			UserChannel object.  It does not matter if it is a local attachment
 *			or a remote attachment.  This is used to issue MCS commands (such
 *			as attach user confirm) to the user.
 *		local_provider (i)
 *			This is the identity of the local provider.  A UserChannel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			UserChannel object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	UserChannel (
 *			ChannelID			channel_id,
 *			PCommandTarget		user_attachment,
 *			PDomain     		local_provider,
 *			PConnection 		top_provider,
 *			PChannelList		channel_list,
 *			PAttachmentList		attachment_list,
 *			PCommandTarget		attachment)
 *
 *	Functional Description:
 *		This is a secondary version of the constructor that is used only during
 *		merge operations.  The only difference between this one and the one
 *		above is that this one allows the specification of an initial
 *		attachment.  This allows a UserChannel object to be constructed with the
 *		user already joined to the channel.  The initial attachment should be
 *		the same as the user attachment.
 *
 *		This version of the constructor will not issue an attach user confirm
 *		or a channel join confirm to the user.
 *
 *	Formal Parameters:
 *		channel_id (i)
 *			This is the ID of the channel object.  By keeping track of this
 *			internally, it doesn't have to be passed in for every operation.
 *		user_attachment (i)
 *			This is the attachment which leads to the user represented by this
 *			UserChannel object.  It does not matter if it is a local attachment
 *			or a remote attachment.  This is used to issue MCS commands (such
 *			as attach user confirm) to the user.
 *		local_provider (i)
 *			This is the identity of the local provider.  A UserChannel object
 *			needs this since it issues MCS commands on behalf of the local
 *			provider.
 *		top_provider (i)
 *			This is a pointer to the top provider.  This is used by the
 *			UserChannel object when it needs to issue a request to the Top
 *			Provider.
 *		channel_list (i)
 *			This is a pointer to the domain's channel list, which identifies
 *			all valid channels in the domain.  This is used by channel objects
 *			to validate user IDs.
 *		attachment_list (i)
 *			This is a pointer to the domain's attachment list, which identifies
 *			all valid attachments in the domain.  This is used by channel
 *			objects to validate joined attachments.
 *		attachment (i)
 *			This is the initial attachment for the channel.  A channel join
 *			confirm is NOT issued to the attachment.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	~UserChannel ()
 *
 *	Functional Description:
 *		This is the UserChannel class destructor.  It does nothing at this time.
 *		The base class constructor takes care of clearing the attachment list.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Channel_Type	GetChannelType ()
 *
 *	Functional Description:
 *		This virtual member function returns the type of the channel.  For this
 *		class it will always be USER_CHANNEL.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		USER_CHANNEL
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	BOOL    	IsValid ()
 *
 *	Functional Description:
 *		This function always returns TRUE since User ID channels are always
 *		valid (as long as the user is still attached).
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		TRUE
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CAttachment *GetAttachment ()
 *
 *	Functional Description:
 *		This function is used to retrieve the attachment associated with the
 *		user represented by this object.  This is used by Domain objects when
 *		it is necessary to send an MCS command to a user, and it needs to know
 *		how to get it there.  That information is currently excapsulated within
 *		this class.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		A pointer to the attachment that leads to the user represented by this
 *		object.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		IssueMergeRequest ()
 *
 *	Functional Description:
 *		This member function causes the UserChannel object to issue a merge
 *		request to the top provider.  It will pack the appropriate local
 *		information into the command.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	Void		ChannelJoinRequest (
 *						PCommandTarget		originator,
 *						UserID				uidInitiator,
 *						ChannelID			channel_id)
 *
 *	Functional Description:
 *		This function is invoked when a user tries to join the channel
 *		associated with a UserChannel object.  The originator of the request
 *		will only be permitted to join if their user ID matches that of the
 *		user with which this UserChannel object is associated.  If it does,
 *		then the originator will be permitted to join.
 *
 *		If this provider is not the Top Provider, then the request will be
 *		forwarded upward to the Top Provider.  If this is the Top Provider,
 *		the a channel join confirm will be issued back to the requesting
 *		user.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment of the user wishing to join the channel.
 *		uidInitiator (i)
 *			This is the user ID of the user joining the channel.  This must
 *			be the same as the user ID represented by the object, or the
 *			request will automatically be rejected.
 *		channel_id (i)
 *			This is the channel being acted upon.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	Void	SendDataRequest (
 *					PCommandTarget		originator,
 *					PDataPacket			data_packet)
 *
 *	Functional Description:
 *		This member function handles a send data request on the channel.  It
 *		determines where to send the data.  This differs from the base class
 *		implementation only in that it is unnecessary to send data upward
 *		if it is known that the user is in the sub-tree of the current
 *		provider.
 *
 *	Formal Parameters:
 *		originator (i)
 *			This is the attachment from which the data originated.
 *		data_packet (i)
 *			This is a pointer to a DataPacket object containing the channel
 *			ID, the User ID of the data sender, segmentation flags, priority of
 *			the data packet and a pointer to the packet to be sent.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\h\userdata.h ===
/*
 *	userdata.h
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the interface file for the class CUserDataListContainer.  CUserDataListContainer
 *		objects are used to maintain user data elements. A user data element
 *		consists of an Object Key and an optional octet string.  The Object
 *		Key data is maintained internally by this class by using an
 *		CObjectKeyContainer container.  The optional octet string data is maintained
 *		internally through the use of a Rogue Wave string container.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */
#ifndef	_USER_DATA_LIST__
#define	_USER_DATA_LIST__

#include "objkey.h"

/*
 * This is the typedef for the structure used to maintain the list of user
 * data internally.
 */
typedef struct USER_DATA
{
	~USER_DATA(void);

    CObjectKeyContainer		    *key;
	LPOSTR						poszOctetString;
}
    USER_DATA;

/*
 * These are the typedefs for the Rogue Wave list which is used to hold the 
 * USER_DATA structures and the iterator for the list.
 */
class CUserDataList : public CList
{
    DEFINE_CLIST(CUserDataList, USER_DATA*)
};

/*
 * Class definition:
 */
class CUserDataListContainer : public CRefCount
{
public:

    CUserDataListContainer(UINT cMembers, PGCCUserData *, PGCCError);
    CUserDataListContainer(CUserDataListContainer *, PGCCError);
    CUserDataListContainer(PSetOfUserData, PGCCError);
    ~CUserDataListContainer(void);

	UINT	    LockUserDataList(void);
	void	    UnLockUserDataList(void);

	UINT	    GetUserDataList(USHORT *pcMembers, PGCCUserData**, LPBYTE pMemory);
	UINT        GetUserDataList(UINT *pcMembers, PGCCUserData** pppUserData, LPBYTE pMemory)
	{
	    *pcMembers = 0;
	    return GetUserDataList((USHORT *) pcMembers, pppUserData, pMemory);
	}

	GCCError	GetUserDataPDU(PSetOfUserData *);
	void		FreeUserDataListPDU(void);

protected:

	CUserDataList   		m_UserDataItemList;
	UINT					m_cbDataSize;

	PSetOfUserData			m_pSetOfUserDataPDU;

private:

	GCCError    CopyUserDataList(UINT cMembers, PGCCUserData *);
	GCCError    UnPackUserDataFromPDU(PSetOfUserData);
	GCCError    ConvertPDUDataToInternal(PSetOfUserData);
	GCCError    ConvertUserDataInfoToPDUUserData(USER_DATA *, PSetOfUserData);
};

/*
 *	Comments explaining the public and protected class member functions
 */

/*
 *	CUserDataListContainer (	UINT					number_of_members,
 *				PGCCUserData	*		user_data_list,
 *				PGCCError				return_value);
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This CUserDataListContainer constructor is used to create a CUserDataListContainer object
 *		from "API" data.  The constructor immediately copies the user data 
 *		passed in as a list of "GCCUserData" structures into it's internal form
 *		where a Rogue Wave container holds the data in the form of 
 *		USER_DATA structures.
 *
 *	Formal Parameters:
 *		number_of_members	(i) The number of elements in the user data list.
 *		user_datalist		(i)	The list holding the user data to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_USER_DATA				-	The user data passed in contained
 *												an invalid object key.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CUserDataListContainer (	PSetOfUserData			set_of_user_data,
 *					PGCCError				return_value);
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This CUserDataListContainer constructor is used to create a CUserDataListContainer object 
 *		from data passed in as a "PDU" SetOfUserData structure.  The user
 *		data is copied into it's internal form where a Rogue Wave container 
 *		holds the data in the form of USER_DATA structures.
 *
 *	Formal Parameters:
 *		set_of_user_data	(i)	The structure holding the "PDU" user data
 *									to store.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator or else an
 *												invalid object key PDU was
 *												received.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */

/*
 *	CUserDataListContainer(CUserDataListContainer *user_data, PGCCError return_value);
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This is the copy constructor for the CUserDataListContainer class which takes
 *		as input another CUserDataListContainer object.
 *
 *	Formal Parameters:
 *		user_data			(i)	The CUserDataListContainer object to copy.
 *		return_value		(o)	The output parameter used to indicate errors.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator.
 *		GCC_BAD_OBJECT_KEY				-	An invalid CUserDataListContainer passed in.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	~CUserDataListContainer();
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This is the destructor for the CUserDataListContainer class.  It is used to
 *		clean up any memory allocated during the life of this object.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	UINT			LockUserDataList ();
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine is used to "lock" the "API" data for this object.  This
 *		results in the lock count for this object being incremented.  When the
 *		lock count transitions from 0 to 1, a calculation is made to determine
 *		how much memory will be needed to hold any "API" data which will
 *		be referenced by, but not held in, the GCCUserData structure
 *		which is filled in on a call to GetUserDataList.  This is the
 *		value returned by this routine in order to allow the calling object to
 *		allocate that amount of memory in preparation for the call to 
 *		GetUserDataList.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The amount of memory which will be needed to hold "API" data
 *		which is referenced by, but not held in, the GCCUserData structure
 *		provided as an output parameter to the GetUserDataList call.
 *
 *  Side Effects:
 *		The internal lock count is incremented.
 *
 *	Caveats:
 *		The internal lock count is used in conjuction with an internal "free" 
 *		flag as a mechanism for ensuring that this object remains in existance 
 *		until all interested parties are through with it.  The object remains 
 *		valid (unless explicity deleted) until the lock count is zero and the 
 *		"free" flag is set through a call to FreeUserDataList.  This allows
 *		other objects to lock this object and be sure that it remains valid 
 *		until they call UnLock which will decrement the internal lock count.  A
 *		typical usage scenerio for this object would be:  A CUserDataListContainer
 *		object is constructed and then passed off to any interested parties
 *		through a function call.  On return from the function call, the
 *		FreeUserDataList call is made which will set the internal "free"
 *		flag.  If no other parties have locked the object with a Lock call,
 *		then the CUserDataListContainer object will automatically delete itself when
 *		the FreeUserDataList call is made.  If, however, any number of 
 *		other parties has locked the object, it will remain in existence until
 *		each of them has unlocked the object through a call to UnLock.
 */
/*
 *	UINT	GetUserDataList (	USHORT					*number_of_members,
 *								PGCCUserData	**		user_data_list,
 *								LPSTR					memory);
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the user data from the
 *		CUserDataListContainer object in the "API" form of a GCCUserData list.
 *
 *	Formal Parameters:
 *		number_of_members	(o) The number of elements in the user data list.
 *		user_data			(o)	The list of GCCUserData structures to fill in.
 *		memory				(o)	The memory used to hold any data referenced by,
 *									but not held in, the output structures.
 *
 *	Return Value:
 *		The amount of data, if any, written into the bulk memory block provided.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void			UnLockUserDataList ();
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine 
 *		whether the object has been freed through a call to 
 *		FreeUserDataList.  If so, the object will automatically delete
 *		itself.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal lock count is decremented.
 *
 *	Caveats:
 *		It is the responsibility of any party which locks a CUserDataListContainer
 *		object by calling Lock to also unlock the object with a call to UnLock.
 *		If the party calling UnLock did not construct the CUserDataListContainer 
 *		object,	it should assume the object to be invalid thereafter.
 */
/*
 *	void			FreeUserDataList ();
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "API" data for this object.  This 
 *		will result in the automatic deletion of this object if the object is
 *		not in the "locked" state.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeUserDataList has been made.
 */
/*
 *	GCCError	GetUserDataPDU (	PSetOfUserData	*		set_of_user_data);
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine is used to retrieve the user data from the
 *		CUserDataListContainer object in the "PDU" form of a SetOfUserData.
 *
 *	Formal Parameters:
 *		set_of_user_data		(o)	The SetOfUserData structure to fill in.
 *
 *	Return Value:
 *		GCC_NO_ERROR					-	No error.
 *		GCC_ALLOCATION_FAILURE			- 	Error creating an object using the
 *												"new" operator or else an
 *												internal pointer has been
 *												corrupted.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
/*
 *	void		FreeUserDataListPDU ();
 *
 *	Public member function of CUserDataListContainer.
 *
 *	Function Description:
 *		This routine is used to "free" the "PDU" data allocated for this object
 *		which is held internally in a SetOfUserData structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		The internal "free" flag is set.
 *
 *	Caveats:
 *		This object should be assumed invalid after a call to 
 *		FreeUserDataListPDU has been made.
 */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\appsap.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_SAP);
/*
 *	appsap.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *
 *	Protected Instance Variables:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */

#include "appsap.h"
#include "conf.h"
#include "gcontrol.h"


GCCError WINAPI GCC_CreateAppSap(IGCCAppSap **ppIAppSap, LPVOID pUserData, LPFN_APP_SAP_CB pfnCallback)
{
    GCCError rc;

    if (NULL != ppIAppSap && NULL != pfnCallback)
    {
        if (NULL != g_pGCCController)
        {
            DBG_SAVE_FILE_LINE
            if (NULL != (*ppIAppSap = (IGCCAppSap *) new CAppSap(pUserData, pfnCallback, &rc)))
            {
                if (GCC_NO_ERROR != rc)
                {
                    (*ppIAppSap)->ReleaseInterface(); // free the interface in case of error
                }
            }
            else
            {
                ERROR_OUT(("GCC_CreateAppSap: can't create IAppSap."));
                rc = GCC_ALLOCATION_FAILURE;
            }
        }
        else
        {
            WARNING_OUT(("GCC_CreateAppSap: GCC Provider is not initialized."));
            rc = GCC_NOT_INITIALIZED;
        }
    }
    else
    {
        ERROR_OUT(("GCC_CreateAppSap: either or both pointers are null"));
        rc = GCC_INVALID_PARAMETER;
    }

    return rc;
}


/*
 * Macros defining the number of handles which may be allocated.
 */
#define		MINIMUM_NUMBER_OF_ALLOCATED_HANDLES		1
#define		MAXIMUM_NUMBER_OF_ALLOCATED_HANDLES		1024

/*
 *	CAppSap()
 *
 *	Public Function Description:
 *		This is the constructor for the CAppSap class.  It initializes instance
 *		variables and registers with the new application.
 */
CAppSap::
CAppSap
(
    LPVOID              pAppData,
    LPFN_APP_SAP_CB     pfnCallback,
    PGCCError           pRetCode
)
:
    CBaseSap(MAKE_STAMP_ID('A','S','a','p')),
    m_pAppData(pAppData),
    m_pfnCallback(pfnCallback)
{
    ASSERT(NULL != pfnCallback);
    ASSERT(NULL != g_pGCCController);

    //
    // We just created a window in the constructor of CBaseSap.
    // Double check the window is created successfully.
    //
    if (NULL != m_hwndNotify)
    {
        //
        // Make sure the gcc provider does not go away randomly.
        //
        ::EnterCriticalSection(&g_csGCCProvider);
        g_pGCCController->AddRef();
        g_pGCCController->RegisterAppSap(this);
        ::LeaveCriticalSection(&g_csGCCProvider);

        *pRetCode = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::CAppSap: can't create window, win32_err=%u", ::GetLastError()));
        *pRetCode = GCC_ALLOCATION_FAILURE;
    }
}


/*
 *	~AppSap ()
 *
 *	Public Function Description:
 *		This is the destructor for the CAppSap class.  It is called when the 
 *		controller marks the CAppSap to be deleted.  This occurs when either
 *		the CAppSap asks to be deleted due to an "unregister request" 
 *		issued from the client application, or when there is an error
 *		condition in the CAppSap.
 */
CAppSap::
~CAppSap ( void )
{
    //
    // LONCHANC: This Release() must be outside of the GCC critical section
    // because the GCC Controller can delete this critical section in
    // its destructor.
    //
    g_pGCCController->Release();
}


void CAppSap::
ReleaseInterface ( void )
{
    ASSERT(NULL != g_pGCCController);

    //
    // It is ok for the gcc provider to go away now.
    //
    ::EnterCriticalSection(&g_csGCCProvider);
    g_pGCCController->UnRegisterAppSap(this);
    ::LeaveCriticalSection(&g_csGCCProvider);

    //
    // Reset the app related data
    //
    m_pAppData = NULL;
    m_pfnCallback = NULL;

    //
    // Remove any message in the queue.
    //
    PurgeMessageQueue();

    //
    // Release this object now.
    //
    Release();
}


void CAppSap::
PostAppSapMsg ( GCCAppSapMsgEx *pAppSapMsgEx )
{
    ASSERT(NULL != m_hwndNotify);
    ::PostMessage(m_hwndNotify,
                  ASAPMSG_BASE + (UINT) pAppSapMsgEx->Msg.eMsgType,
                  (WPARAM) pAppSapMsgEx,
                  (LPARAM) this);
}


/*
 *	AppEnroll()
 *
 *	Public Function Description:
 *		This routine is called when an application wants to enroll in a 
 *		conference.  The controller is notified of the enrollment request.
 */
GCCError CAppSap::
AppEnroll
(
    GCCConfID           nConfID,
    GCCEnrollRequest    *pReq,
    GCCRequestTag       *pnReqTag
)
{
    GCCError    rc;
    CConf       *pConf;

    DebugEntry(CAppSap::AppEnroll);

    // sanity check
    if (NULL == pReq || NULL == pnReqTag)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

    TRACE_OUT_EX(ZONE_T120_APP_ROSTER,
            ("CAppSap::AppEnroll: confID=%u, enrolled?=%u, active?=%u\r\n",
            (UINT) nConfID, (UINT) pReq->fEnroll, (UINT) pReq->fEnrollActively));

    // create the request id
    *pnReqTag = GenerateRequestTag();

    // find the corresponding conference
    if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
    {
        rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

	// check to make sure that the application has a valid uid and
	// session key if it is enrolling.
	if (pReq->fEnroll)
	{
		if (pReq->fEnrollActively)
		{
			if (pReq->nUserID < MINIMUM_USER_ID_VALUE)
			{
				rc = GCC_INVALID_MCS_USER_ID;
				goto MyExit;
			}
		}
		else if (pReq->nUserID < MINIMUM_USER_ID_VALUE)
		{
			// we must make sure that this is zero if it is invalid and
			// the user is enrolling inactively.
			pReq->nUserID = GCC_INVALID_UID;
		}

		if (NULL == pReq->pSessionKey)
		{
			rc = GCC_BAD_SESSION_KEY;
			goto MyExit;
		}
	}

    ::EnterCriticalSection(&g_csGCCProvider);
    rc = pConf->AppEnrollRequest(this, pReq, *pnReqTag);
    ::LeaveCriticalSection(&g_csGCCProvider);

MyExit:

    DebugExitINT(CAppSap::AppEnroll, rc);
    return rc;
}


GCCError CAppSap::
AppInvoke
(
    GCCConfID                 nConfID,
    GCCAppProtEntityList      *pApeList,
    GCCSimpleNodeList         *pNodeList,
    GCCRequestTag             *pnReqTag
)
{
    return CBaseSap::AppInvoke(nConfID, pApeList, pNodeList, pnReqTag);
}


GCCError CAppSap::
AppRosterInquire
(
    GCCConfID                  nConfID,
    GCCSessionKey              *pSessionKey,
    GCCAppSapMsg               **ppMsg
)
{
    return CBaseSap::AppRosterInquire(nConfID, pSessionKey, (GCCAppSapMsgEx **) ppMsg);
}


BOOL CAppSap::
IsThisNodeTopProvider ( GCCConfID nConfID )
{
    return CBaseSap::IsThisNodeTopProvider(nConfID);
}


GCCNodeID CAppSap::
GetTopProvider ( GCCConfID nConfID )
{
    return CBaseSap::GetTopProvider(nConfID);
}


GCCError CAppSap::
ConfRosterInquire(GCCConfID nConfID, GCCAppSapMsg **ppMsg)
{
    return CBaseSap::ConfRosterInquire(nConfID, (GCCAppSapMsgEx **) ppMsg);
}


GCCError CAppSap::
ConductorInquire ( GCCConfID nConfID )
{
    return CBaseSap::ConductorInquire(nConfID);
}


/*
 *	RegisterChannel()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to register a 
 *		channel.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegisterChannel
(
    GCCConfID           nConfID,
    GCCRegistryKey      *pRegKey,
    ChannelID           nChnlID
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegisterChannel);

    if (NULL == pRegKey)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

    /*
	**	If the desired conference exists, call it in order to register the
	**	channel.  Report an error if the desired conference does not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegisterChannel: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
    rc = (nChnlID != 0) ? pConf->RegistryRegisterChannelRequest(pRegKey, nChnlID, this) :
                          GCC_INVALID_CHANNEL;
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegisterChannel: can't register channel, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegisterChannel, rc);
	return rc;
}


/*
 *	RegistryAssignToken()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to assign a 
 *		token.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistryAssignToken
(
    GCCConfID           nConfID,
    GCCRegistryKey      *pRegKey
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegistryAssignToken);

    if (NULL == pRegKey)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to assign the
	**	token.  Report an error if the desired conference does not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistryAssignToken: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
    rc = pConf->RegistryAssignTokenRequest(pRegKey, this);
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegistryAssignToken: can't assign token, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryAssignToken, rc);
	return rc;
}

/*
 *	RegistrySetParameter()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to set a 
 *		parameter.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistrySetParameter
(
    GCCConfID              nConfID,
    GCCRegistryKey         *pRegKey,
    LPOSTR                 poszParameter,
    GCCModificationRights  eRights
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegistrySetParameter);

    if (NULL == pRegKey || NULL == poszParameter)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to set the
	**	parameter.  Report an error if the desired conference does not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistrySetParameter: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    switch (eRights)
    {
    case GCC_OWNER_RIGHTS:
    case GCC_SESSION_RIGHTS:
    case GCC_PUBLIC_RIGHTS:
    case GCC_NO_MODIFICATION_RIGHTS_SPECIFIED:
        ::EnterCriticalSection(&g_csGCCProvider);
        rc = pConf->RegistrySetParameterRequest(pRegKey, poszParameter, eRights, this);
        ::LeaveCriticalSection(&g_csGCCProvider);
        if (GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CAppSap::RegistrySetParameter: can't set param, rc=%u", (UINT) rc));
            // goto MyExit;
        }
        break;
    default:
        rc = GCC_INVALID_MODIFICATION_RIGHTS;
        break;
	}

MyExit:

    DebugExitINT(CAppSap::RegistrySetParameter, rc);
	return rc;
}

/*
 *	RegistryRetrieveEntry()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to retrieve a registry 
 *		entry.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistryRetrieveEntry
(
    GCCConfID           nConfID,
    GCCRegistryKey      *pRegKey
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegistryRetrieveEntry);

    if (NULL == pRegKey)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to retrieve the
	**	registry entry.  Report an error if the desired conference does not 
	**	exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistryRetrieveEntry: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
	rc = pConf->RegistryRetrieveEntryRequest(pRegKey, this);
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegistryRetrieveEntry: can't retrieve entry, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryRetrieveEntry, rc);
	return rc;
}

/*
 *	RegistryDeleteEntry()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to delete a registry 
 *		entry.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistryDeleteEntry
(
    GCCConfID           nConfID,
    GCCRegistryKey      *pRegKey
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(IAppSap::RegistryDeleteEntry);

    if (NULL == pRegKey)
    {
		ERROR_OUT(("CAppSap::RegistryDeleteEntry: null pRegKey"));
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to delete the
	**	desired registry entry.  Report an error if the desired conference does
	**	not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        TRACE_OUT(("CAppSap::RegistryDeleteEntry: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
	rc = pConf->RegistryDeleteEntryRequest(pRegKey, this);
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        WARNING_OUT(("CAppSap::RegistryDeleteEntry: can't delete entry, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryDeleteEntry, rc);
	return rc;
}

/*
 *	RegistryMonitor()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to monitor a 
 *		particular registry entry.  The call is routed to the appropriate 
 *		conference object.
 */
GCCError CAppSap::
RegistryMonitor
(
    GCCConfID           nConfID,
    BOOL                fEnalbeDelivery,
    GCCRegistryKey      *pRegKey
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(IAppSap::RegistryMonitor);

    if (NULL == pRegKey)
    {
        rc = GCC_INVALID_PARAMETER;
        goto MyExit;
    }

	/*
	**	If the desired conference exists, call it in order to monitor the
	**	appropriate registry entry.  Report an error if the desired conference
	**	does not exist.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistryMonitor: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
	rc = pConf->RegistryMonitorRequest(fEnalbeDelivery, pRegKey, this);
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegistryMonitor: can't monitor the registry, rc=%u", (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryMonitor, rc);
	return rc;
}

/*
 *	RegistryAllocateHandle()
 *
 *	Public Function Description:
 *		This routine is called when an application wishes to allocate one or 
 *		more handles.  The call is routed to the appropriate conference object.
 */
GCCError CAppSap::
RegistryAllocateHandle
(
    GCCConfID           nConfID,
    ULONG               cHandles
)
{
	GCCError    rc;
	CConf       *pConf;

    DebugEntry(CAppSap::RegistryAllocateHandle);

	/*
	**	If the desired conference exists, call it in order to allocate the
	**	handle(s).  Report an error if the desired conference does not exist or
	**	if the number of handles wishing to be allocated is not within the
	**	allowable range.
	*/
	if (NULL == (pConf = g_pGCCController->GetConfObject(nConfID)))
	{
        WARNING_OUT(("CAppSap::RegistryAllocateHandle: invalid conf id=%u", (UINT) nConfID));
		rc = GCC_INVALID_CONFERENCE;
        goto MyExit;
    }

    ::EnterCriticalSection(&g_csGCCProvider);
	rc = ((cHandles >= MINIMUM_NUMBER_OF_ALLOCATED_HANDLES) &&
          (cHandles <= MAXIMUM_NUMBER_OF_ALLOCATED_HANDLES)) ?
            pConf->RegistryAllocateHandleRequest(cHandles, this) :
            GCC_BAD_NUMBER_OF_HANDLES;
    ::LeaveCriticalSection(&g_csGCCProvider);
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::RegistryAllocateHandle: can't allocate handles, cHandles=%u, rc=%u", (UINT) cHandles, (UINT) rc));
        // goto MyExit;
    }

MyExit:

    DebugExitINT(CAppSap::RegistryAllocateHandle, rc);
    return rc;
}

/*
 *	The following routines are all Command Target Calls
 */
 
/*
 *	PermissionToEnrollIndication ()
 *
 *	Public Function Description:
 *		This routine is called by the Controller when it wishes to send an
 *		indication to the user application notifying it of a "permission to 
 *		enroll" event.  This does not mean that permission to enroll is
 *		necessarily granted to the application.
 */
GCCError CAppSap::
PermissionToEnrollIndication
(
    GCCConfID           nConfID,
    BOOL                fGranted
)
{
    GCCError rc;

    DebugEntry(CAppSap: PermissionToEnrollIndication);
    TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CAppSap::PermissionToEnrollIndication: "
                    "confID=%u, granted?=%u\r\n",
                    (UINT) nConfID, (UINT) fGranted));

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_PERMIT_TO_ENROLL_INDICATION);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.AppPermissionToEnrollInd.nConfID = nConfID;
        pMsgEx->Msg.AppPermissionToEnrollInd.fPermissionGranted = fGranted;
        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap: PermissionToEnrollIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap: PermissionToEnrollIndication, rc);
    return rc;
}

/*
 *	AppEnrollConfirm ()
 *
 *	Public Function Description:
 *		This routine is called by the CConf object when it wishes
 *		to send an enrollment confirmation to the user application.
 */
GCCError CAppSap::
AppEnrollConfirm ( GCCAppEnrollConfirm *pConfirm )
{
    GCCError rc;

    DebugEntry(CAppSap::AppEnrollConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_ENROLL_CONFIRM);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = pConfirm->nConfID;
        pMsgEx->Msg.AppEnrollConfirm = *pConfirm;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::AppEnrollConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap: AppEnrollConfirm, rc);
    return rc;
}

/*
 *	RegistryConfirm ()
 *
 *	Public Function Description:
 *		This command target routine is called by the CConf object when it
 *		wishes to send an registry confirmation to the user application.
 */
GCCError CAppSap::
RegistryConfirm
(
    GCCConfID               nConfID,
    GCCMessageType          eMsgType,
    CRegKeyContainer        *pRegKey,
    CRegItem                *pRegItem,
    GCCModificationRights   eRights,
    GCCNodeID               nidOwner,
    GCCEntityID             eidOwner,
    BOOL                    fDeliveryEnabled,
    GCCResult               nResult
)
{
    GCCError                rc;

    DebugEntry(CAppSap::RegistryConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(eMsgType);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::RegistryConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }

    pMsgEx->Msg.nConfID = nConfID;

    if (NULL != pRegKey)
    {
        rc = pRegKey->CreateRegistryKeyData(&(pMsgEx->Msg.RegistryConfirm.pRegKey));
        if (GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CAppSap::RegistryConfirm: can't get registry key data, rc=%u", (UINT) rc));
            goto MyExit;
        }
    }

    if (NULL != pRegItem)
    {
        rc = pRegItem->CreateRegistryItemData(&(pMsgEx->Msg.RegistryConfirm.pRegItem));
        if (GCC_NO_ERROR != rc)
        {
            ERROR_OUT(("CAppSap::RegistryConfirm: can't get registry item data, rc=%u", (UINT) rc));
            goto MyExit;
        }
    }

    if (GCC_INVALID_NID != nidOwner)
    {
        pMsgEx->Msg.RegistryConfirm.EntryOwner.entry_is_owned = TRUE;
        pMsgEx->Msg.RegistryConfirm.EntryOwner.owner_node_id = nidOwner;
        pMsgEx->Msg.RegistryConfirm.EntryOwner.owner_entity_id = eidOwner;
    }

    pMsgEx->Msg.RegistryConfirm.nConfID = nConfID;
    pMsgEx->Msg.RegistryConfirm.eRights = eRights;
    pMsgEx->Msg.RegistryConfirm.nResult = nResult;
    pMsgEx->Msg.RegistryConfirm.fDeliveryEnabled = fDeliveryEnabled; // for monitor only

    PostAppSapMsg(pMsgEx);
    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::RegistryConfirm, rc);
    return rc;
}


/*
 *	RegistryMonitorIndication()
 *
 *	Public Function Description
 *		This command target routine is called by the CConf object when it
 *		wishes to send a Registry monitor indication to the user application.
 */


/*
 *	RegistryAllocateHandleConfirm()
 *
 *	Public Function Description:
 *		This command target routine is called by the CConf object when it
 *		wishes to send a handle allocation confirmation to the user application.
 */
GCCError CAppSap::
RegistryAllocateHandleConfirm
(
    GCCConfID       nConfID,
    ULONG           cHandles,
    ULONG           nFirstHandle,
    GCCResult       nResult
)
{
    GCCError                     rc;

    DebugEntry(CAppSap::RegistryAllocateHandleConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_ALLOCATE_HANDLE_CONFIRM);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.RegAllocHandleConfirm.nConfID = nConfID;
        pMsgEx->Msg.RegAllocHandleConfirm.cHandles = cHandles;
        pMsgEx->Msg.RegAllocHandleConfirm.nFirstHandle = nFirstHandle;
        pMsgEx->Msg.RegAllocHandleConfirm.nResult = nResult;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::RegistryAllocateHandleConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::RegistryAllocateHandleConfirm, rc);
    return rc;
}



void CAppSapList::
DeleteList ( void )
{
    CAppSap *pAppSap;
    while (NULL != (pAppSap = Get()))
    {
        pAppSap->Release();
    }
}


void CAppSapEidList2::
DeleteList ( void )
{
    CAppSap *pAppSap;
    while (NULL != (pAppSap = Get()))
    {
        pAppSap->Release();
    }
}


/* 
 *	ConfRosterInquireConfirm()
 *
 *	Public Function Description
 *		This routine is called in order to return a requested conference
 *		roster to an application or the node controller.
 */
GCCError CAppSap::
ConfRosterInquireConfirm
(
    GCCConfID                   nConfID,
    PGCCConferenceName          pConfName,
    LPSTR                       pszConfModifier,
    LPWSTR                      pwszConfDescriptor,
    CConfRoster                 *pConfRoster,
    GCCResult                   nResult,
    GCCAppSapMsgEx              **ppMsgExToRet
)
{
    GCCError  rc;
    BOOL      fLock = FALSE;
    UINT      cbDataSize;

    DebugEntry(CAppSap::ConfRosterInquireConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_ROSTER_INQUIRE_CONFIRM);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::ConfRosterInquireConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }

    pMsgEx->Msg.nConfID = nConfID;

    pMsgEx->Msg.ConfRosterInquireConfirm.nConfID = nConfID;
    pMsgEx->Msg.ConfRosterInquireConfirm.nResult = nResult;
    pMsgEx->Msg.ConfRosterInquireConfirm.ConfName.numeric_string = ::My_strdupA(pConfName->numeric_string);
    pMsgEx->Msg.ConfRosterInquireConfirm.ConfName.text_string = ::My_strdupW(pConfName->text_string);
    pMsgEx->Msg.ConfRosterInquireConfirm.pszConfModifier = ::My_strdupA(pszConfModifier);
    pMsgEx->Msg.ConfRosterInquireConfirm.pwszConfDescriptor = ::My_strdupW(pwszConfDescriptor);

    /*
     * Lock the data for the conference roster.  The lock call will 
     * return the length of the data to be serialized for the roster so
     * add that	length to the total memory block size and allocate the 
     * memory block.
     */
    fLock = TRUE;
    cbDataSize = pConfRoster->LockConferenceRoster();
    if (0 != cbDataSize)
    {
        DBG_SAVE_FILE_LINE
        pMsgEx->Msg.ConfRosterInquireConfirm.pConfRoster = (PGCCConfRoster) new char[cbDataSize];
        if (NULL == pMsgEx->Msg.ConfRosterInquireConfirm.pConfRoster)
        {
            ERROR_OUT(("CAppSap::ConfRosterInquireConfirm: can't create conf roster buffer"));
            rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }

        /*
        * Retrieve the conference roster data from the roster object.
        * The roster object will serialize any referenced data into 
        * the memory block passed in to the "Get" call.
        */
        pConfRoster->GetConfRoster(&(pMsgEx->Msg.ConfRosterInquireConfirm.pConfRoster),
                                   (LPBYTE) pMsgEx->Msg.ConfRosterInquireConfirm.pConfRoster);
    }

    if (NULL != ppMsgExToRet)
    {
        *ppMsgExToRet = pMsgEx;
    }
    else
    {
        PostAppSapMsg(pMsgEx);
    }

    rc = GCC_NO_ERROR;

MyExit:

    if (fLock)
    {
        pConfRoster->UnLockConferenceRoster();
    }

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::ConfRosterInquireConfirm, rc);
    return rc;
}


/*
 *	AppRosterInquireConfirm()
 *
 *	Public Function Description
 *		This routine is called in order to return a requested list of
 *		application rosters to an application or the node controller.
 */
GCCError CAppSap::
AppRosterInquireConfirm
(
    GCCConfID           nConfID,
    CAppRosterMsg       *pAppRosterMsg,
    GCCResult           nResult,
    GCCAppSapMsgEx      **ppMsgEx
)
{
    GCCError    rc;

    DebugEntry(CAppSap::AppRosterInquireConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_APP_ROSTER_INQUIRE_CONFIRM);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::AppRosterInquireConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }
    pMsgEx->Msg.nConfID = nConfID;

    /*
    * Lock the data for the roster message and retrieve the data.
    */
    rc = pAppRosterMsg->LockApplicationRosterMessage();
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::AppRosterInquireConfirm: can't lock app roster message, rc=%u", (UINT) rc));
        goto MyExit;
    }

    rc = pAppRosterMsg->GetAppRosterMsg((LPBYTE *) &(pMsgEx->Msg.AppRosterInquireConfirm.apAppRosters),
                                        &(pMsgEx->Msg.AppRosterInquireConfirm.cRosters));
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::AppRosterInquireConfirm: can't get app roster message, rc=%u", (UINT) rc));
        pAppRosterMsg->UnLockApplicationRosterMessage();
        goto MyExit;
    }

    // fill in the roster information
    pMsgEx->Msg.AppRosterInquireConfirm.pReserved = (LPVOID) pAppRosterMsg;
    pMsgEx->Msg.AppRosterInquireConfirm.nConfID = nConfID;
    pMsgEx->Msg.AppRosterInquireConfirm.nResult = nResult;

    if (NULL != ppMsgEx)
    {
        *ppMsgEx = pMsgEx;
    }
    else
    {
        PostAppSapMsg(pMsgEx);
    }

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::AppRosterInquireConfirm, rc);
    return rc;
}


void CAppSap::
FreeAppSapMsg ( GCCAppSapMsg *pMsg )
{
    GCCAppSapMsgEx *pMsgEx = (GCCAppSapMsgEx *) pMsg;
    ASSERT((LPVOID) pMsgEx == (LPVOID) pMsg);
    delete pMsgEx;
}


/* 
 *	AppInvokeConfirm ()
 *
 *	Public Function Description
 *		This routine is called in order to confirm a call requesting application
 *		invocation.
 */
GCCError CAppSap::
AppInvokeConfirm
(
    GCCConfID                       nConfID,
    CInvokeSpecifierListContainer   *pInvokeList,
    GCCResult                       nResult,
    GCCRequestTag                   nReqTag
)
{
    GCCError                rc;

    DebugEntry(CAppSap::AppInvokeConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_APPLICATION_INVOKE_CONFIRM);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.AppInvokeConfirm.nConfID = nConfID;
        pMsgEx->Msg.AppInvokeConfirm.nResult = nResult;
        pMsgEx->Msg.AppInvokeConfirm.nReqTag = nReqTag;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::AppInvokeConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::AppInvokeConfirm, rc);
    return rc;
}


/* 
 *	AppInvokeIndication()
 *
 *	Public Function Description
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for application invocation has been
 *		made.
 */
GCCError CAppSap::
AppInvokeIndication
(
    GCCConfID                       nConfID,
    CInvokeSpecifierListContainer   *pInvokeList,
    GCCNodeID                       nidInvoker
)
{
    GCCError            rc;
    UINT                cbDataSize;
    BOOL                fLock = FALSE;

    DebugEntry(CAppSap::AppInvokeIndication);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_APPLICATION_INVOKE_INDICATION);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::AppInvokeIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }
    pMsgEx->Msg.nConfID = nConfID;

    fLock = TRUE;
    cbDataSize = pInvokeList->LockApplicationInvokeSpecifierList();
    if (0 != cbDataSize)
    {
        DBG_SAVE_FILE_LINE
        pMsgEx->Msg.AppInvokeInd.ApeList.apApes = (PGCCAppProtocolEntity *) new char[cbDataSize];
        if (NULL == pMsgEx->Msg.AppInvokeInd.ApeList.apApes)
        {
            ERROR_OUT(("CAppSap::AppInvokeIndication: can't create ape list"));
            rc = GCC_ALLOCATION_FAILURE;
            goto MyExit;
        }

        pInvokeList->GetApplicationInvokeSpecifierList(
                            &(pMsgEx->Msg.AppInvokeInd.ApeList.cApes),
                            (LPBYTE) pMsgEx->Msg.AppInvokeInd.ApeList.apApes);
    }

    pMsgEx->Msg.AppInvokeInd.nConfID = nConfID;
    pMsgEx->Msg.AppInvokeInd.nidInvoker = nidInvoker;

    PostAppSapMsg(pMsgEx);

    rc = GCC_NO_ERROR;

MyExit:

    if (fLock)
    {
        pInvokeList->UnLockApplicationInvokeSpecifierList();
    }

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::AppInvokeIndication, rc);
    return rc;
}


/*
 *	AppRosterReportIndication ()
 *
 *	Public Function Description
 *		This routine is called in order to indicate to applications and the
 *		node controller that the list of application rosters has been updated.
 */
GCCError CAppSap::
AppRosterReportIndication
(
    GCCConfID           nConfID,
    CAppRosterMsg       *pAppRosterMsg
)
{
    GCCError    rc;

    DebugEntry(CAppSap::AppRosterReportIndication);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_APP_ROSTER_REPORT_INDICATION);
    if (NULL == pMsgEx)
    {
        ERROR_OUT(("CAppSap::AppRosterReportIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
        goto MyExit;
    }
    pMsgEx->Msg.nConfID = nConfID;

    /*
    * Lock the data for the roster message and retrieve the data.
    */
    rc = pAppRosterMsg->LockApplicationRosterMessage();
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::AppRosterReportIndication: can't lock app roster message, rc=%u", (UINT) rc));
        goto MyExit;
    }

    rc = pAppRosterMsg->GetAppRosterMsg((LPBYTE *) &(pMsgEx->Msg.AppRosterReportInd.apAppRosters),
                                        &(pMsgEx->Msg.AppRosterReportInd.cRosters));
    if (GCC_NO_ERROR != rc)
    {
        ERROR_OUT(("CAppSap::AppRosterReportIndication: can't get app roster message, rc=%u", (UINT) rc));
        pAppRosterMsg->UnLockApplicationRosterMessage();
        goto MyExit;
    }

    // fill in the roster information
    pMsgEx->Msg.AppRosterReportInd.pReserved = (LPVOID) pAppRosterMsg;
    pMsgEx->Msg.AppRosterReportInd.nConfID = nConfID;

    PostAppSapMsg(pMsgEx);

    rc = GCC_NO_ERROR;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::AppRosterReportIndication, rc);
    return rc;
}


/*
 *	ConductorInquireConfirm ()
 *
 *	Public Function Description
 *		This routine is called in order to return conductorship information
 *		which has been requested.
 *
 */
GCCError CAppSap::
ConductorInquireConfirm
(
    GCCNodeID           nidConductor,
    GCCResult           nResult,
    BOOL                fGranted,
    BOOL                fConducted,
    GCCConfID           nConfID
)
{
    GCCError                    rc;

    DebugEntry(CAppSap::ConductorInquireConfirm);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_CONDUCT_INQUIRE_CONFIRM);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.ConductorInquireConfirm.nConfID = nConfID;
        pMsgEx->Msg.ConductorInquireConfirm.fConducted = fConducted;
        pMsgEx->Msg.ConductorInquireConfirm.nidConductor = nidConductor;
        pMsgEx->Msg.ConductorInquireConfirm.fGranted = fGranted;
        pMsgEx->Msg.ConductorInquireConfirm.nResult = nResult;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::ConductorInquireConfirm: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::ConductorInquireConfirm, rc);
    return rc;
}



/* 
 *	ConductorPermitGrantIndication ()
 *
 *	Public Function Description
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for permission from the conductor
 *		has been made.
 */
GCCError CAppSap::
ConductorPermitGrantIndication
(
    GCCConfID           nConfID,
    UINT                cGranted,
    GCCNodeID           *aGranted,
    UINT                cWaiting,
    GCCNodeID           *aWaiting,
    BOOL                fThisNodeIsGranted
)
{
    GCCError                            rc = GCC_NO_ERROR;;
    UINT                                cbDataSize = 0;

    DebugEntry(CAppSap::ConductorPermitGrantIndication);

    cbDataSize = (0 != cGranted || 0 != cWaiting) ?
                    (ROUNDTOBOUNDARY(sizeof(GCCNodeID)) * cGranted) +
                    (ROUNDTOBOUNDARY(sizeof(GCCNodeID)) * cWaiting) :
                    0;

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_CONDUCT_GRANT_INDICATION);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;

        if (cbDataSize > 0)
        {
        	DBG_SAVE_FILE_LINE
            pMsgEx->Msg.ConductorPermitGrantInd.pReserved = (LPVOID) new char[cbDataSize];
            if (NULL == pMsgEx->Msg.ConductorPermitGrantInd.pReserved)
            {
                ERROR_OUT(("CAppSap::ConductorPermitGrantIndication: can't allocate buffer, cbDataSize=%u", (UINT) cbDataSize));
	        rc = GCC_ALLOCATION_FAILURE;
                goto MyExit;
            }
        }

        pMsgEx->Msg.ConductorPermitGrantInd.nConfID = nConfID;
        pMsgEx->Msg.ConductorPermitGrantInd.Granted.cNodes = cGranted;
        if (0 != cGranted)
        {
            pMsgEx->Msg.ConductorPermitGrantInd.Granted.aNodeIDs =
                            (GCCNodeID *) pMsgEx->Msg.ConductorPermitGrantInd.pReserved;
            ::CopyMemory(pMsgEx->Msg.ConductorPermitGrantInd.Granted.aNodeIDs,
                         aGranted,
                         sizeof(GCCNodeID) * cGranted);
        }

        pMsgEx->Msg.ConductorPermitGrantInd.Waiting.cNodes = cWaiting;
        if (0 != cWaiting)
        {
            pMsgEx->Msg.ConductorPermitGrantInd.Waiting.aNodeIDs =
                            (GCCNodeID *) ((LPBYTE) pMsgEx->Msg.ConductorPermitGrantInd.pReserved +
                                           (ROUNDTOBOUNDARY(sizeof(GCCNodeID)) * cGranted));
            ::CopyMemory(pMsgEx->Msg.ConductorPermitGrantInd.Waiting.aNodeIDs,
                         aWaiting,
                         sizeof(GCCNodeID) * cWaiting);
        }
        pMsgEx->Msg.ConductorPermitGrantInd.fThisNodeIsGranted = fThisNodeIsGranted;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::ConductorPermitGrantIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pMsgEx;
    }

    DebugExitINT(CAppSap::ConductorPermitGrantIndication, rc);
    return rc;
}


/*
 *	ConductorAssignIndication ()
 *
 *	Public Function Description
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request has been made to assign conductorship.
 */
GCCError CAppSap::
ConductorAssignIndication
(
    GCCNodeID           nidConductor,
    GCCConfID           nConfID
)
{
    GCCError                 rc;

    DebugEntry(CAppSap::ConductorAssignIndication);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_CONDUCT_ASSIGN_INDICATION);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.ConductorAssignInd.nConfID = nConfID;
        pMsgEx->Msg.ConductorAssignInd.nidConductor = nidConductor;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::ConductorPermitGrantIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::ConductorAssignIndication, rc);
    return rc;
}

/*
 *	ConductorReleaseIndication ()
 *
 *	Public Function Description
 *		This routine is called in order to send an indication to an application
 *		or node controller that a request for releasing conductorship has been
 *		made.
 */
GCCError CAppSap::
ConductorReleaseIndication ( GCCConfID nConfID )
{
    GCCError    rc;

    DebugEntry(CAppSap::ConductorReleaseIndication);

    DBG_SAVE_FILE_LINE
    GCCAppSapMsgEx *pMsgEx = new GCCAppSapMsgEx(GCC_CONDUCT_RELEASE_INDICATION);
    if (NULL != pMsgEx)
    {
        pMsgEx->Msg.nConfID = nConfID;
        pMsgEx->Msg.ConductorReleaseInd.nConfID = nConfID;

        PostAppSapMsg(pMsgEx);
        rc = GCC_NO_ERROR;
    }
    else
    {
        ERROR_OUT(("CAppSap::ConductorReleaseIndication: can't create GCCAppSapMsgEx"));
        rc = GCC_ALLOCATION_FAILURE;
    }

    DebugExitINT(CAppSap::ConductorReleaseIndication, rc);
    return rc;
}


void CAppSap::
NotifyProc ( GCCAppSapMsgEx *pAppSapMsgEx )
{
    if (NULL != m_pfnCallback)
    {
        pAppSapMsgEx->Msg.pAppData = m_pAppData;
        (*m_pfnCallback)(&(pAppSapMsgEx->Msg));
    }
    delete pAppSapMsgEx;
}










//
// The following is for GCCAppSapMsgEx structure
//


GCCAppSapMsgEx::
GCCAppSapMsgEx ( GCCMessageType eMsgType )
{
    ::ZeroMemory(&Msg, sizeof(Msg));
    Msg.eMsgType = eMsgType;
}

GCCAppSapMsgEx::
~GCCAppSapMsgEx ( void )
{
    switch (Msg.eMsgType)
    {
    // 
    // Application Roster related callbacks
    //

    case GCC_PERMIT_TO_ENROLL_INDICATION:
    case GCC_ENROLL_CONFIRM:
    case GCC_APPLICATION_INVOKE_CONFIRM:
        //
        // No need to free anything
        //
        break;

    case GCC_APP_ROSTER_REPORT_INDICATION:
        if (NULL != Msg.AppRosterReportInd.pReserved)
        {
            //
            // App roster report is also sent to control sap.
            //
            ::EnterCriticalSection(&g_csGCCProvider);
            ((CAppRosterMsg *) Msg.AppRosterReportInd.pReserved)->UnLockApplicationRosterMessage();
            ::LeaveCriticalSection(&g_csGCCProvider);
        }
        break;

    case GCC_APP_ROSTER_INQUIRE_CONFIRM:
        if (NULL != Msg.AppRosterInquireConfirm.pReserved)
        {
            ((CAppRosterMsg *) Msg.AppRosterInquireConfirm.pReserved)->UnLockApplicationRosterMessage();
        }
        break;

    case GCC_APPLICATION_INVOKE_INDICATION:
        delete Msg.AppInvokeInd.ApeList.apApes;
        break;

    //
    // Conference Roster related callbacks
    //

    case GCC_ROSTER_INQUIRE_CONFIRM:
        delete Msg.ConfRosterInquireConfirm.ConfName.numeric_string;
        delete Msg.ConfRosterInquireConfirm.ConfName.text_string;
        delete Msg.ConfRosterInquireConfirm.pszConfModifier;
        delete Msg.ConfRosterInquireConfirm.pwszConfDescriptor;
        delete Msg.ConfRosterInquireConfirm.pConfRoster;
        break;

    //
    // Application Registry related callbacks
    //
    
    case GCC_REGISTER_CHANNEL_CONFIRM:
    case GCC_ASSIGN_TOKEN_CONFIRM:
    case GCC_RETRIEVE_ENTRY_CONFIRM:
    case GCC_DELETE_ENTRY_CONFIRM:
    case GCC_SET_PARAMETER_CONFIRM:
    case GCC_MONITOR_INDICATION:
    case GCC_MONITOR_CONFIRM:
        delete Msg.RegistryConfirm.pRegKey;
        delete Msg.RegistryConfirm.pRegItem;
        break;

    case GCC_ALLOCATE_HANDLE_CONFIRM:
        //
        // No need to free anything
        //
        break;

    //
    // Conductorship related callbacks
    //

    case GCC_CONDUCT_ASSIGN_INDICATION:
    case GCC_CONDUCT_RELEASE_INDICATION:
    case GCC_CONDUCT_INQUIRE_CONFIRM:
        //
        // No need to free anything
        //
        break;

    case GCC_CONDUCT_GRANT_INDICATION:
        delete Msg.ConductorPermitGrantInd.pReserved;
        break;

    default:
        ERROR_OUT(("GCCAppSapMsgEx::~GCCAppSapMsgEx: unknown msg type=%u", (UINT) Msg.eMsgType));
        break;
    }
}


void CAppSap::
PurgeMessageQueue(void)
{
    MSG     msg;

    /*
     *	This loop calls PeekMessage to go through all the messages in the thread's
     *	queue that were posted by the main MCS thread.  It removes these
     *	messages and frees the resources that they consume.
     */
    while (PeekMessage(&msg, m_hwndNotify, ASAPMSG_BASE, ASAPMSG_BASE + MSG_RANGE, PM_REMOVE))
    {
        if (msg.message == WM_QUIT)
        {
            // Repost the quit
            PostQuitMessage(0);
            break;
        }

        ASSERT(this == (CAppSap *) msg.lParam);
        delete (GCCAppSapMsgEx *) msg.wParam;
    }

    // Destroy the window; we do not need it anymore
    if (NULL != m_hwndNotify)
    {
        ::DestroyWindow(m_hwndNotify);
        m_hwndNotify = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\alarm.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	alarm.cpp
 *
 *	Copyright (c) 1995 by Databeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Alarm class.  Objects of this
 *		class are used when the creator wishes to make sure that a certain
 *		activity doesn't exceed a certain amount of time.
 *
 *		By convention, an Alarm object is created with the time limitation
 *		passed in as the only parameter to the constructor.  The creator can
 *		then periodically ask the Alarm object if it has expired.  This hides
 *		all time maintenance code from the creator.
 *
 *		Note that the Alarm class is PASSIVE, meaning that it will not call
 *		back into its creator when the specified time is exceeded.  This
 *		capability could be added at a future data. if desirable.  Right now,
 *		the creator MUST call into an Alarm object to ask it if it has expired.
 *
 *	Private Data:
 *		Duration
 *			This refers to the original duration of the alarm.  It is kept
 *			around to allow the creator to reset the alarm without having to
 *			respecify the duration.
 *		Expiration_Time
 *			This is the time (in clock ticks) upon which the alarm will expire.
 *			Whenever the alarm is asked if it has expired, it checks the current
 *			system clock against this value.
 *		Expired
 *			This is a boolean flag that indicates whether or not the alarm has
 *			already expired.  This prevents the object from repeatedly checking
 *			the system clock if the timer has already expired.
 * 
 *	Caveats:
 *		None
 *
 *	Author:  
 *		James P. Galvin, Jr.
 *
 *	Revision History:
 *		09JAN95   jpg	Original
 */

#include "alarm.h"


/*
 *	Alarm ()
 *
 *	Public
 *
 *	Function Description
 *		This is the constructor for the Alarm class.  It calls Set to initialize
 *		all instance variables, and calculate the first expiration time value
 *		based on the specified duration.
 */
CAlarm::CAlarm(UINT nDuration)
{
	Set(nDuration);
}

/*
 *	~Alarm ()
 *
 *	Public
 *
 *	Function Description
 *		This is the destructor for the Alarm class.  It currently does nothing.
 */

/*
 *	void	Set ()
 *
 *	Public
 *
 *	Function Description
 *		This function initializes the alarm duration instance variable and
 *		calls Reset to ready the alarm for use.
 */
void CAlarm::Set(UINT nDuration)
{
	m_nDuration = nDuration;

	/*
	 *	Call Reset to initialize remaining instance variables and ready the
	 *	alarm for use.
	 */
	Reset();
}

/*
 *	void	Reset ()
 *
 *	Public
 *
 *	Function Description
 *		This function calculate an expiration time value based on the specified
 *		duration and marks the alarm as unexpired.
 */
void CAlarm::Reset(void)
{
	/*
	 *	Determine the expiration time by adding the alarm duration to the
	 *	current time.
	 */
	m_nStartTime = (UINT) ::GetTickCount();
	m_fExpired = FALSE;
}

/*
 *	void	Expire ()
 *
 *	Public
 *
 *	Function Description
 *		This function can be used to expire an alarm prematurely.  This might
 *		be useful if the alarm is used to determine whether or not to perform
 *		an action, and the caller decides to inhibit the action for reasons
 *		other than time.
 */

/*
 *	BOOL		IsExpired ()
 *
 *	Public
 *
 *	Function Description
 *		This function is used to check an alarm to see if it has expired.
 */
BOOL CAlarm::IsExpired(void)
{
	/*
	 *	See if the alarm has already expired before checking it again.
	 */
    // LONCHANC: The alarm object is totally bogus. We check for expiration
    // only when we are sending a PDU out. However, when it expires, it is
    // possible that there is no PDU to send. In this case, no one will know
    // this alarm is expired. This means some actions will not be taken in time.
    // Now, make it always expired because it did not work at all before and
    // most of time it returned "expired."
#if 1
    m_fExpired = TRUE;
#else
	if (! m_fExpired)
	{
		if (m_nStartTime + m_nDuration <= (UINT) ::GetTickCount())
		{
			m_fExpired = TRUE;
		}
	}
#endif

	return m_fExpired;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\arostmgr.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_APP_ROSTER);
/*
 *	arostmgr.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Application Roster
 *		Manager Class.
 *
 *		SEE THE INTERFACE FILE FOR A MORE DETAILED DESCRIPION OF THIS CLASS.
 *
 *	Private Instance Variables
 *		m_nConfID
 *			The conference ID associated with this roster manager.  Used
 *			when delivering roster update messages.
 *		m_fTopProvider
 *			Flag indicating if this is a top provider node for this conference.
 *		m_pMcsUserObject
 *			This is the user attachment object associated with this conference.	
 *		m_AppSapEidList2
 *			This list maintains all of the command target pointers for each
 *			of the enrolled APEs.  This list is used to deliver roster 
 *			update messages.
 *		m_pConf
 *			Pointer to object that will receive all owner callback messages
 *			delivered from the application roster manager.
 *		m_GlobalRosterList
 *			This list maintains pointers to all the global application rosters.
 *		m_LocalRosterList
 *			This list maintains pointers to all the local application rosters.
 *			This list will not be used if this is a Top Provider node.
 *		m_RosterDeleteList
 *			This list is used to hold any application rosters that have
 *			been marked to be deleted (usually when they become empty).  We
 *			don't delete immediately to allow messages and PDUs to be processed
 *			before deletion.
 *		m_pSessionKey
 *			This is the session key used to hold the protocol key associated
 *			with this application roster manager.
 *
 *	Caveats:
 *		None
 *
 *	Author:
 *		blp
 */


#include "arostmgr.h"
#include "arostmsg.h"
#include "appsap.h"
#include "csap.h"
#include "conf.h"


/*
 *	CAppRosterMgr	()
 *
 *	Public Function Description
 *	when pGccSessKey is not NULL
 *		This is the application roster manager constructor. It is responsible 
 *		for initializing all the instance variables used by this class.
 *		This constructor is used when the initial roster data that is
 *		availble comes from local API data.
 *
 *	when pSessKey is not NULL
 *		This is the application roster manager constructor. It is responsible 
 *		for initializing all the instance variables used by this class.
 *		This constructor is used when the initial roster data that is
 *		availble comes from remote PDU data.
 *		This constructor handles a number of different possiblities:
 *			For Non Top Providers:
 *				1)	A refresh received from the top provider.
 *				2)	An update from a node below this one.
 *
 *			For the Top Provider:
 *				1)	An Update from a lower node
 */
CAppRosterMgr::CAppRosterMgr(
					PGCCSessionKey			pGccSessKey,
					PSessionKey				pPduSessKey,
					GCCConfID   			nConfID,
					PMCSUser				pMcsUserObject,
					CConf					*pConf,
					PGCCError				pRetCode)
:
    CRefCount(MAKE_STAMP_ID('A','R','M','r')),
	m_nConfID(nConfID),
	// m_fTopProvider(FALSE),
	m_pMcsUserObject(pMcsUserObject),
	m_AppSapEidList2(DESIRED_MAX_APP_SAP_ITEMS),
	m_pConf(pConf)
{
	GCCError rc = GCC_NO_ERROR;

	DebugEntry(CAppRosterMgr::CAppRosterMgr);

	//	Determine if this is a top provider node
	m_fTopProvider = (m_pMcsUserObject->GetTopNodeID() == m_pMcsUserObject->GetMyNodeID());

	/*
	**	Set up this roster managers session key which will be used to 
	**	determine whether or not to process a roster request or update.
	*/
	if (NULL != pGccSessKey)
	{
		ASSERT(NULL == pPduSessKey);
		DBG_SAVE_FILE_LINE
		m_pSessionKey = new CSessKeyContainer(pGccSessKey, &rc);
	}
	else
	if (NULL != pPduSessKey)
	{
		DBG_SAVE_FILE_LINE
		m_pSessionKey = new CSessKeyContainer(pPduSessKey, &rc);
	}
	else
	{
		ERROR_OUT(("CAppRosterMgr::CAppRosterMgr: invalid session key"));
		rc = GCC_BAD_SESSION_KEY;
		goto MyExit;
	}

	if (NULL == m_pSessionKey || GCC_NO_ERROR != rc)
	{
		ERROR_OUT(("CAppRosterMgr::CAppRosterMgr: can't create session key"));
		rc = GCC_ALLOCATION_FAILURE;
		// we do the cleanup in the destructor
		goto MyExit;
    }

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CAppRosterMgr:;CAppRosterMgr, rc);

	*pRetCode = rc;
}

/*
 *	~CAppRosterMgr()
 *
 *	Public Function Description
 *		This is the application roster manager destructor.  It is used to
 *		free up all memory associated with this class.
 */
CAppRosterMgr::~CAppRosterMgr(void)
{
	m_GlobalRosterList.DeleteList();
	m_LocalRosterList.DeleteList();
	m_RosterDeleteList.DeleteList();

	if (NULL != m_pSessionKey)
	{
	    m_pSessionKey->Release();
	}
}


/*
 *	GCCError	EnrollRequest	()
 *
 *	Public Function Description
 *		This routine is called whenever an APE wishes to enroll with the
 *		conference in a specific session.  This routine can be used to
 *		either add a new record or replace a currently existing record.
 */
GCCError CAppRosterMgr::
EnrollRequest(GCCEnrollRequest *pReq, GCCEntityID eid, GCCNodeID nid, CAppSap *pAppSap)
{
	GCCError			rc = GCC_NO_ERROR;
	CAppRoster			*pAppRoster = NULL;
	BOOL				perform_add_record;
	BOOL				maintain_pdu_data;

	DebugEntry(CAppRosterMgr::EnrollRequest);

	/*
	**	First we must make sure that the default version of this session
	**	key matches this application roster manager's
	*/
	if (! IsThisSessionKeyValid(pReq->pSessionKey))
	{
	    rc = GCC_BAD_SESSION_KEY;
	    goto MyExit;
	}

	//	Now save the App SAP so we can send roster report indications
	if (! m_AppSapEidList2.Find(eid))
	{
		m_AppSapEidList2.Append(eid, pAppSap);
		perform_add_record = TRUE;
	}
	else
    {
		perform_add_record = FALSE;
    }

	/*
	**	Next we must make sure that the global application roster (and 
	**	local for non top providers) that matches this session key exist.
	**	If they don't exists then create them here.
	*/
	pAppRoster = GetApplicationRoster(pReq->pSessionKey, &m_GlobalRosterList);
	if (pAppRoster == NULL)
	{
		maintain_pdu_data = m_fTopProvider;

		/*
		**	Here we create the global default application rosters.  If
		**	this is the Top Provider we DO maintain PDU data within the
		**	roster.
		*/
		DBG_SAVE_FILE_LINE
		pAppRoster = new CAppRoster(pReq->pSessionKey,
									NULL,	// pSessKey
									this,	// pOwnerObject
									m_fTopProvider,// fTopProvider
									FALSE,	// fLocalRoster
									maintain_pdu_data,	// fMaintainPduBuffer
									&rc);
		if ((pAppRoster != NULL) && (rc == GCC_NO_ERROR))
		{
			m_GlobalRosterList.Append(pAppRoster);
		}
		else
		{
		    rc = GCC_ALLOCATION_FAILURE;
		    goto MyExit;
		}
	}

	if (! m_fTopProvider)
	{
		pAppRoster = GetApplicationRoster(pReq->pSessionKey, &m_LocalRosterList);
		if (pAppRoster == NULL)
		{
			//	Here we create the local default application rosters.
			DBG_SAVE_FILE_LINE
			pAppRoster = new CAppRoster(pReq->pSessionKey,
										NULL,	// pSessKey
										this,	// pOwnerObject
										m_fTopProvider,// fTopProvider
										TRUE,	// fLocalRoster
										TRUE,	// fMaintainPduBuffer
										&rc);
			if ((pAppRoster != NULL) && (rc == GCC_NO_ERROR))
			{
				m_LocalRosterList.Append(pAppRoster);
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
		}
	}

//
// LONCHANC: Something wrong here. roster_ptr could be either
// the one in the global list or the one in the local list.
// Should we add records to both roster_ptr???
//
// LONCHANC: It seems to me that only the local list has records in non-top provider.
// On the other hand, only the global list has the record in top provider.
// cf. UnEnrollRequest().
//

    if (perform_add_record)
    {
    	//	Add the new record to the roster
    	rc = pAppRoster->AddRecord(pReq, nid, eid);
    	if (GCC_NO_ERROR != rc)
    	{
    		ERROR_OUT(("AppRosterManager::EnrollRequest: can't add record"));
    	}
    }
    else
    {
    	rc = pAppRoster->ReplaceRecord(pReq, nid, eid);
    	if (GCC_NO_ERROR != rc)
    	{
    		ERROR_OUT(("AppRosterManager::EnrollRequest: can't repalce record"));
    	}
    }

    // zero out the roster pointer because it should no be freed
    // in case of adding or replacing a record.
    // because the roster pointer has been added to the list,
    // it will be freed later.
	pAppRoster = NULL;

MyExit:

    if (GCC_NO_ERROR != rc)
    {
		if (pAppRoster != NULL)
        {
			pAppRoster->Release();
        }
    }

	DebugExitINT(CAppRosterMgr::EnrollRequest, rc);
	return rc;
}

/*
 *	GCCError	UnEnrollRequest	()
 *
 *	Public Function Description
 *		This routine is called whenever an APE wishes to unenroll from the
 *		conference (or a specific session).
 */
GCCError		CAppRosterMgr::UnEnrollRequest (
													PGCCSessionKey	session_key,
													EntityID		entity_id)
{
	GCCError				rc = GCC_NO_ERROR;
	CAppRoster				*application_roster = NULL;
	CAppRosterList			*roster_list;

	DebugEntry(CAppRosterMgr::UnEnrollRequest);

	//	Is this a valid session key for the application roster manager
	if (IsThisSessionKeyValid (session_key) == FALSE)
		rc = GCC_INVALID_PARAMETER;
	else if (m_AppSapEidList2.Remove(entity_id))
	{
		//	Now find the affected roster
		roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;
 
		application_roster = GetApplicationRoster (	session_key, roster_list);
		//	Now unenroll from the specified roster 
		if (application_roster != NULL)
		{
			rc = application_roster->RemoveRecord(
												m_pMcsUserObject->GetMyNodeID(),
								 				entity_id);
		}
		else
			rc = GCC_BAD_SESSION_KEY;
	}
	else
		rc = GCC_APP_NOT_ENROLLED;

	DebugExitINT(CAppRosterMgr::UnEnrollRequest, rc);

    return rc;
}

/*
 *	GCCError	ProcessRosterUpdateIndicationPDU ()
 *
 *	Public Function Description
 *		This routine processes an incomming roster update PDU.  It is
 *		responsible for passing the PDU on to the right application roster.
 */
GCCError	CAppRosterMgr::ProcessRosterUpdateIndicationPDU(
					PSetOfApplicationInformation	set_of_application_info,
					UserID							sender_id)
{
	GCCError				rc = GCC_NO_ERROR;
	CAppRosterList			*roster_list;
	CAppRoster				*application_roster;
	BOOL					maintain_pdu_buffer;
	BOOL					is_local_roster;

	DebugEntry(CAppRosterMgr::ProcessRosterUpdateIndicationPDU);

	/*
	**	First make sure that the session key contained in the current
	**	set of application information is valid for this application roster 
	**	manager.
	*/ 
	if (IsThisSessionKeyPDUValid(&set_of_application_info->value.session_key))
	{
		/*
		**	Now search for the appropriate application roster.  If it is not 
		**	found we must create it here.
		*/

        //
		// LONCHANC:
		// (1) If top provider, add default application roster to the global roster list.
		// (2) If non-top provider, we do not create both the local and global version of the 
		// application roster for this particular session key.
		// instead, We create only the appropriate one here 
		// and wait until we receive either a refresh from the 
		// top provider or an update from a node below this one 
		// in the connection hierarchy (or an application 
		// enroll) before creating the other.
		// (3) If this PDU was sent from below this node it 
		// must be an update of the local roster so save 
		// the roster in the local roster list.
        //
		roster_list = (m_fTopProvider || (sender_id == m_pMcsUserObject->GetTopNodeID())) ?
						&m_GlobalRosterList : &m_LocalRosterList;
 
		application_roster = GetApplicationRosterFromPDU (
									&set_of_application_info->value.session_key,
									roster_list);
		if (application_roster != NULL)
		{
			rc = application_roster->
								ProcessRosterUpdateIndicationPDU(
												set_of_application_info,
												sender_id);
		}
		else
		{
			//	First determine the characteristics of this roster
			if (m_fTopProvider)
			{
				maintain_pdu_buffer = TRUE;
				is_local_roster = FALSE;
			}
			else if (sender_id == m_pMcsUserObject->GetTopNodeID())
			{
				maintain_pdu_buffer = FALSE;
				is_local_roster = FALSE;
			}
			else
			{
				maintain_pdu_buffer = TRUE;
				is_local_roster = TRUE;
			}

			//	Create the application roster from the passed in PDU.	
			DBG_SAVE_FILE_LINE
			application_roster = new CAppRoster(NULL,	// pGccSessKey
												&set_of_application_info->value.session_key,	// pSessKey
												this,	// pOwnerObject
												m_fTopProvider,// fTopProvider
												is_local_roster,// fLocalRoster
												maintain_pdu_buffer,// fMaintainPduBuffer
												&rc);
			if ((application_roster != NULL) && (rc == GCC_NO_ERROR))
			{
				//	Process the PDU with the created application roster.
				rc = application_roster->
								ProcessRosterUpdateIndicationPDU(
							        					set_of_application_info,
							                            sender_id);
				if (rc == GCC_NO_ERROR)
				{
					roster_list->Append(application_roster);
				}
			}
			else 
			{
				if (application_roster != NULL)
                {
					application_roster->Release();
                }
				else
                {
					rc = GCC_ALLOCATION_FAILURE;
                }
			}
		}
	}
	else
	{
		ERROR_OUT(("AppRosterManager::ProcessRosterUpdateIndicationPDU:"
					"ASSERTION: Application Information is not valid"));
		rc = GCC_INVALID_PARAMETER;
	}

	DebugExitINT(CAppRosterMgr::ProcessRosterUpdateIndicationPDU, rc);

	return rc;
}

/*
 *	PSetOfApplicationInformation	FlushRosterUpdateIndication ()
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the application rosters managed by this application
 *		roster manager.  It also is responsible for flushing any queued 
 *		roster update messages if necessary.
 */
PSetOfApplicationInformation
CAppRosterMgr::FlushRosterUpdateIndication(
						PSetOfApplicationInformation *	set_of_information,
						PGCCError						rc)
{
	PSetOfApplicationInformation	pOld = NULL, pCurr;
	CAppRosterList					*roster_list;
	CAppRoster						*lpAppRoster;

	DebugEntry(CAppRosterMgr::FlushRosterUpdateIndication);

	/*
	**	First we deal with flushing the PDU data. We iterate through the
	**	appropriate list (Global if the Top Provider and Local if not the
	**	Top Provider) and get any PDU data associated with each of these.
	**	Note that some of these may not contain any PDU data.
	*/
	*rc = GCC_NO_ERROR;
	*set_of_information = NULL;

	roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;

	roster_list->Reset();
	while (NULL != (lpAppRoster = roster_list->Iterate()))
	{
		lpAppRoster->FlushRosterUpdateIndicationPDU(&pCurr);
		if (pCurr != NULL)
		{
			if (*set_of_information == NULL)
				*set_of_information = pCurr;
			else
			{
				if(pOld)
				{
					pOld->next = pCurr;
				}
			}

			(pOld = pCurr)->next = NULL;
		}
	}

	/*
	**	Next we deal with delivering the application roster update messages.
	**	We first check to see if any of the global rosters have changed.  If
	**	none have changed, we will not deliver a roster update indication.
	*/
	m_GlobalRosterList.Reset();
	while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
	{
		if (lpAppRoster->HasRosterChanged())
		{
			TRACE_OUT(("AppRosterManager::FlushRosterUpdateIndication:Roster HAS Changed"));
			*rc = SendRosterReportMessage ();
			break;
		}
	}

	/*
	**	Cleanup and reset any application rosters after the above flush is 
	**	completed.  This takes care of removing any rosters that have become
	**	empty.  It also resets the rosters which takes care of resetting all
	**	the internal instance variables to their appropriate initial state.
	*/
	CleanupApplicationRosterLists ();

	DebugExitPTR(CAppRosterMgr::FlushRosterUpdateIndication, pOld);

//
// LONCHANC: Yes, we need to return the last item in the list such that
// we can continue to grow the list.
// In fact, the next call to FlushRosterUpdateIndication() will have
// &pOld as the input argument.
// It is quite tricky.
//
// Please note that pOld is initialized to NULL.
//

	return (pOld); 
}

/*
 *	PSetOfApplicationInformation	GetFullRosterRefreshPDU ()
 *
 *	Public Function Description
 *		This routine is used to obtain a complete roster refresh of all the
 *		rosters maintained by this roster manger.
 */
PSetOfApplicationInformation
				CAppRosterMgr::GetFullRosterRefreshPDU (
						PSetOfApplicationInformation	*	set_of_information,
						PGCCError							rc)
{
	PSetOfApplicationInformation	new_set_of_information = NULL;

	DebugEntry(CAppRosterMgr::GetFullRosterRefreshPDU);

	if (m_fTopProvider)
	{
		CAppRoster			*lpAppRoster;

		*rc = GCC_NO_ERROR;
		*set_of_information = NULL;

		/*
		**	First we must tell all the application rosters to build the
		**	a full refresh PDU internally.
		*/
		m_GlobalRosterList.Reset();
		while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
		{
			*rc = lpAppRoster->BuildFullRefreshPDU();
			if (GCC_NO_ERROR != *rc)
			{
				return NULL;
			}
		}

		/*
		**	Now we flush all the refreshes.  Note that this also takes care
		**	of delivering any queued application roster update messages.
		*/	
		new_set_of_information = FlushRosterUpdateIndication (set_of_information, rc);
	}
	else
		*rc = GCC_INVALID_PARAMETER;

	DebugExitPTR(CAppRosterMgr::GetFullRosterRefreshPDU, new_set_of_information);

	return (new_set_of_information); 
}

/*
 *	Boolean	IsThisYourSessionKey ()
 *
 *	Public Function Description
 *		This routine is used to determine if the specified "API" session key is
 *		associated with this application roster manager.
 */


/*
 *	Boolean	IsThisYourSessionKeyPDU ()
 *
 *	Public Function Description
 *		This routine is used to determine if the specified "PDU" session key is
 *		associated with this application roster manager.
 */


/*
 *	GCCError	RemoveEntityReference ()
 *
 *	Public Function Description
 *		This routine is used to remove the specified APE entity from the 
 *		session it is enrolled with.  Note that this routine is only used
 *		to remove local entity references.
 */								
GCCError	CAppRosterMgr::RemoveEntityReference(EntityID entity_id)
{
	GCCError				rc = GCC_NO_ERROR;
	CAppRosterList			*roster_list;

	DebugEntry(CAppRosterMgr::RemoveEntityReference);

	/*
	**	First remove this entity from the command target list if it is valid.
	**	We then iterate through all the rosters until we determine which
	**	roster holds the record associated with this entity.
	*/
	if (m_AppSapEidList2.Remove(entity_id))
	{
		CAppRoster			*lpAppRoster;

		/*
		**	Now get the affected roster.  Note that if this is not the
		**	top provider we wait for the full refresh to update the
		**	global roster.
		*/
		roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;

		/*
		**	Try to delete this record from every roster in the list.
		**	Break when the correct roster is found.
		*/
		roster_list->Reset();
		while (NULL != (lpAppRoster = roster_list->Iterate()))
		{
			rc = lpAppRoster->RemoveRecord(m_pMcsUserObject->GetMyNodeID(), entity_id);
			if (rc == GCC_NO_ERROR)
				break;
		}
	}
	else
		rc = GCC_APP_NOT_ENROLLED;

	DebugExitINT(CAppRosterMgr::RemoveEntityReference, rc);

	return rc;
}

/*
 *	GCCError	RemoveUserReference	()
 *
 *	Public Function Description
 *		This routine is used to remove all references associated with the
 *		node defined by the detached user.
 */								
GCCError	CAppRosterMgr::RemoveUserReference(
									UserID				detached_user)
{
	GCCError				rc = GCC_NO_ERROR;
	GCCError				error_value;
	CAppRosterList			*roster_list;
	CAppRoster				*lpAppRoster;

	DebugEntry(CAppRosterMgr::RemoveUserReference);

	/*
	**	Now get the affected roster.  Note that if this is not the
	**	top provider we wait for the full refresh to update the
	**	global roster.
	*/
	roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;

	//	Try to delete this user from every roster in the list
	roster_list->Reset();
	while (NULL != (lpAppRoster = roster_list->Iterate()))
	{
		error_value = lpAppRoster->RemoveUserReference (detached_user);
		if ((error_value != GCC_NO_ERROR) && 
			(error_value != GCC_INVALID_PARAMETER))
		{
			rc = error_value;
			WARNING_OUT(("AppRosterManager::RemoveUserReference:"
						"FATAL error occured while removing user reference."));
			break;
		}
	}

	DebugExitINT(CAppRosterMgr::RemoveUserReference, rc);

	return rc;
}

/*
 *	Boolean	IsEntityEnrolled ()
 *
 *	Public Function Description
 *		This routine informs the caller if the specified entity is enrolled
 *		with any sessions managed by this application roster manager.
 */
BOOL	CAppRosterMgr::IsEntityEnrolled(EntityID application_entity)
{
	BOOL						rc = TRUE;
	CAppRosterList				*application_roster_list;
	CAppRoster					*lpAppRoster;

	DebugEntry(CAppRosterMgr::IsEntityEnrolled);

	application_roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;

	application_roster_list->Reset();
	while (NULL != (lpAppRoster = application_roster_list->Iterate()))
	{
		if (lpAppRoster->DoesRecordExist(m_pMcsUserObject->GetMyNodeID(), application_entity))
		{
			rc = TRUE;
			break;
		}
	}

	DebugExitBOOL(AppRosterManager:IsEntityEnrolled, rc);

	return rc;
}

/*
 *	GCCError	ApplicationRosterInquire	()
 *
 *	Public Function Description
 *		This routine fills in an application roster message with either
 *		a single roster (if a session other than the default is specified)
 *		or the complete list of "Global" rosters contained by this roster
 *		manager (if the specified session key is NULL or the session ID is
 *		zero.
 */
GCCError	CAppRosterMgr::ApplicationRosterInquire (
						PGCCSessionKey			session_key,
						CAppRosterMsg			*roster_message)
{
	GCCError				rc = GCC_NO_ERROR;
	CAppRoster				*application_roster = NULL;
	CSessKeyContainer       *pSessKeyData;

	DebugEntry(CAppRosterMgr::ApplicationRosterInquire);

	if (session_key != NULL)
	{
		if (session_key->session_id != 0)
		{
			/*
			**	Here we try to find the specific application roster that was
			**	requested.
			*/
			DBG_SAVE_FILE_LINE
			pSessKeyData = new CSessKeyContainer(session_key, &rc);
			if ((pSessKeyData != NULL) && (rc == GCC_NO_ERROR))
			{
				CAppRoster *lpAppRoster;
				m_GlobalRosterList.Reset();
				while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
				{
					CSessKeyContainer *pTempSessKeyData = lpAppRoster->GetSessionKey();
					if (*pTempSessKeyData == *pSessKeyData)
					{
						application_roster = lpAppRoster;
						break;
					}
				}
			}

			if (pSessKeyData != NULL)
			{
				pSessKeyData->Release();
				if (application_roster == NULL)
				{
					rc = GCC_NO_SUCH_APPLICATION;
				}
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
	}

	if (rc == GCC_NO_ERROR)
	{
		if (application_roster != NULL)
		{
			roster_message->AddRosterToMessage(application_roster);
		}
		else
		{
			CAppRoster *lpAppRoster;
			m_GlobalRosterList.Reset();
			while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
			{
				roster_message->AddRosterToMessage(lpAppRoster);
			}
		}
	}

	DebugExitINT(AppRosterManager:ApplicationRosterInquire, rc);
	return rc;
}

/*
 *	BOOL		IsAPEEnrolled	()
 *
 *	Public Function Description
 *		This function determines if the specified APE is enrolled with
 *		any session in the list.  It does not worry about a specific
 *		session.
 */
BOOL		CAppRosterMgr::IsAPEEnrolled(
						UserID							node_id,
						EntityID						entity_id)
{
	BOOL				rc = FALSE;
	CAppRoster			*lpAppRoster;

	DebugEntry(CAppRosterMgr::IsAPEEnrolled);

	/*
	**	First get a single session key.  Note that it makes no difference
	**	where the key comes from because we are only goin to be comparing
	**	the base object key.
	*/
	m_GlobalRosterList.Reset();
	while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
	{
		if (lpAppRoster->DoesRecordExist (node_id, entity_id))
		{
			rc = TRUE;
			break;
		}
	}

	DebugExitBOOL(AppRosterManager:IsAPEEnrolled, rc);

	return rc;
}

/*
 *	BOOL		IsAPEEnrolled	()
 *
 *	Public Function Description
 *		This function determines if the specified APE is enrolled with
 *		a specific session in the list.
 */
BOOL		CAppRosterMgr::IsAPEEnrolled(
						CSessKeyContainer   		    *session_key_data,
						UserID							node_id,
						EntityID						entity_id)
{
	BOOL				rc = FALSE;
	CAppRoster			*lpAppRoster;

	DebugEntry(CAppRosterMgr::IsAPEEnrolled);

	/*
	**	First get a single session key.  Note that it makes no difference
	**	where the key comes from because we are only goin to be comparing
	**	the base object key.
	*/
	m_GlobalRosterList.Reset();
	while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
	{
		//	We are looking for a session key match
		if (*(lpAppRoster->GetSessionKey()) == *session_key_data)
		{
			//	If a match was found check to see if record exist
			rc = lpAppRoster->DoesRecordExist (node_id, entity_id);
		}
	}

	DebugExitBOOL(AppRosterManager:IsAPEEnrolled, rc);

	return rc;
}

/*
 *	GCCError	IsEmpty	()
 *
 *	Public Function Description
 *		This routine determines if this application roster managfer contains
 *		any application rosters.
 */
BOOL CAppRosterMgr::IsEmpty(void)
{
	return (m_GlobalRosterList.IsEmpty() && m_LocalRosterList.IsEmpty()) ?
					TRUE : FALSE;
}

/*
 *	GCCError	SendRosterReportMessage	()
 *
 *	Private Function Description
 *		This routine is responsible for sending the application roster
 *		update indications to the application SAPs.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR 			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		We send indications for all rosters. Even roster that don't currently
 *		contain records.  
 */
GCCError CAppRosterMgr::
SendRosterReportMessage(void)
{
	GCCError					rc = GCC_NO_ERROR;
	CAppRosterMsg				*roster_message;

	DebugEntry(CAppRosterMgr::SendRosterReportMessage);

	if (! m_GlobalRosterList.IsEmpty())
	{
		//	First allocate the roster message
		DBG_SAVE_FILE_LINE
		roster_message = new CAppRosterMsg();
		if (roster_message != NULL)
		{
			CAppRoster			*lpAppRoster;

			m_GlobalRosterList.Reset();
			while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
			{
				roster_message->AddRosterToMessage(lpAppRoster);
			}

			/*
			**	Here we iterate through the complete list of application 
			**	saps to send the roster report indication.  Note that
			**	we used the sent list to avoid sending the same roster
			**	update to a single SAP more than once.  Note that since
			**	this sent list is defined as a local instance variable,
			**	it automatically is cleaned up after each roster update.
			**
			**	Note also that we iterate on a temporary list here in case
			**	an application unenrolls (usually due to a resource error)
			**	during this callback.  We must protect the rogue wave 
			**	iterator.
			*/
			CAppSap *pAppSap;
			CAppSapList SentList;
			CAppSapEidList2 ToSendList(m_AppSapEidList2);
			ToSendList.Reset();
			while (NULL != (pAppSap = ToSendList.Iterate()))
			{
				if (! SentList.Find(pAppSap))
				{
					/*
					**	Hold on to this sap so that we don't send to it 
					**	again for this update.
					*/
					SentList.Append(pAppSap);

					//	Here we actually deliver the roster update.
					pAppSap->AppRosterReportIndication(m_nConfID, roster_message);
				}
			}

			/*
			**	Here we send the roster report indication to the
			**	controler sap.
			*/
			g_pControlSap->AppRosterReportIndication(m_nConfID, roster_message);

			/*
			**	Here we free up the roster message.  Note that if this
			**	message got locked in the roster report indication calls
			**	this free will not delete the roster memory.
			*/
			roster_message->Release();
		}
		else
			rc = GCC_ALLOCATION_FAILURE;
	}

	DebugExitINT(AppRosterManager::SendRosterReportMessage, rc);

	return rc;
}

/*
 *	CAppRoster *GetApplicationRoster ()
 *
 *	Private Function Description
 *		This routine is responsible for returning the application pointer
 *		associated with the specified session key.
 *
 *	Formal Parameters:
 *		session_key	-	Session key associated with roster to return.
 *		roster_list	-	Roster list to search.
 *
 *	Return Value
 *		Either NULL	if roster does not exists in list or a pointer to
 *		the appropriate application roster.
 *		
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		None.
 */
CAppRoster * CAppRosterMgr::GetApplicationRoster (	
						PGCCSessionKey			session_key,
						CAppRosterList			*roster_list)
{
	GCCError				rc;
	CAppRoster				*application_roster = NULL;
	CAppRoster				*lpAppRoster;
	CSessKeyContainer	    *pTempSessKeyData;

	DebugEntry(CAppRosterMgr::GetApplicationRoster);

	//	First create a temporary session key for comparison purposes
	DBG_SAVE_FILE_LINE
	pTempSessKeyData = new CSessKeyContainer(session_key, &rc);
	if (pTempSessKeyData != NULL && GCC_NO_ERROR == rc)
	{
		//	Now find the affected roster

		//
		// LONCHANC: The following line is totally wrong!!!
		// we passed in roster_list, but now we overwrite it right here???
		// Commented out the following line.
		//      roster_list = m_fTopProvider ? &m_GlobalRosterList : &m_LocalRosterList;
		//

		roster_list->Reset();
		while (NULL != (lpAppRoster = roster_list->Iterate()))
		{
			if(*lpAppRoster->GetSessionKey() == *pTempSessKeyData)
			{
				application_roster = lpAppRoster;
				break;
			}
		}
	}

    if (pTempSessKeyData != NULL)
		pTempSessKeyData->Release();

	DebugExitPTR(AppRosterManager::GetApplicationRoster, application_roster);
	return (application_roster);
}

/*
 *	CAppRoster * GetApplicationRosterFromPDU ()
 *
 *	Private Function Description
 *		This routine is responsible for returning the application pointer
 *		associated with the specified session key PDU.
 *
 *	Formal Parameters:
 *		session_key	-	Session key PDU associated with roster to return.
 *		roster_list	-	Roster list to search.
 *
 *	Return Value
 *		Either NULL	if roster does not exists in list or a pointer to
 *		the appropriate application roster.
 *		
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		None.
 */
CAppRoster * CAppRosterMgr::GetApplicationRosterFromPDU (	
						PSessionKey				session_key,
						CAppRosterList			*roster_list)
{
	CSessKeyContainer		    *session_key_data;
	CAppRoster					*pAppRoster;

	DebugEntry(CAppRosterMgr::GetApplicationRosterFromPDU);

	roster_list->Reset();
	while (NULL != (pAppRoster = roster_list->Iterate()))
	{
		session_key_data = pAppRoster->GetSessionKey();
		if (session_key_data->IsThisYourSessionKeyPDU (session_key))
		{
			break;
		}
	}

	DebugExitPTR(CAppRosterMgr::GetApplicationRosterFromPDU, pAppRoster);

	return pAppRoster;
}

/*
 *	BOOL IsThisSessionKeyValid ()
 *
 *	Private Function Description
 *		This routine is responsible for determining if the specified
 *		session key's application protocol key matches this application
 *		roster manager's. This routine works on API data.
 *
 *	Formal Parameters:
 *		session_key	-	Session key to check.
 *
 *	Return Value
 *		TRUE	-	If we have a match.
 *		FALSE	-	If we do NOT have a match.
 *		
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	BOOL IsThisSessionKeyPDUValid ()
 *
 *	Private Function Description
 *		This routine is responsible for determining if the specified
 *		session key's application protocol key matches this application
 *		roster manager's.  This routine works on PDU data.
 *
 *	Formal Parameters:
 *		session_key	-	Session key to check.
 *
 *	Return Value
 *		TRUE	-	If we have a match.
 *		FALSE	-	If we do NOT have a match.
 *		
 *  Side Effects
 *		None.
 *
 *	Caveats:
 *		None.
 */


/*
 *	void		CleanupApplicationRosterLists ()
 *
 *	Private Function Description
 *		This routine is responsible for cleaning up any empty application
 *		rosters.  It also resets all the application rosters back to their
 *		neutral state so that any new updates will be handled  correctly.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *		
 *  Side Effects
 *		An owner callback will occur when the roster becomes empty.
 *
 *	Caveats:
 *		This routine does not actually delete the empty rosters until it
 *		is placed in the delete list.  Instead it places the rosters into the
 *		list of deleted rosters which causes them to be deleted the next time
 *		this routine is called (or when the object is destructed).
 */
void	CAppRosterMgr::CleanupApplicationRosterLists(void)
{
	CAppRoster			*lpAppRoster;

	DebugEntry(CAppRosterMgr::CleanupApplicationRosterLists);

	/*
	**	First we iterate through the list of deleted rosters and delete
	**	each entry in it.
	*/
	m_RosterDeleteList.DeleteList();

	/*
	**	Next we iterate through all the rosters and remove any that
	**	contain no application records. Here instead of deleting the
	**	roster we move the roster into the delete list.  We cannot do
	**	the delete here because it is possible that PDU data owned by the
	**	roster being deleted may be used after the Flush is called (or 
	**	after this routine is called).  Therefore, we save it in the delete
	**	list and delete it next time we enter this routine.
	*/

	//	Start with the Global Application Roster List
	m_GlobalRosterList.Reset();
	while (NULL != (lpAppRoster = m_GlobalRosterList.Iterate()))
	{
		if (lpAppRoster->GetNumberOfApplicationRecords() == 0)
		{
            //
            // Here we clean up any "dangling" entries in the application
            // registry by removing all the entries that contain the
            // session key associated with the roster that is being deleted.
            // Note that this is only done when a Global roster list is
            //removed.
            //
            CRegistry *pAppReg = m_pConf->GetRegistry();
            pAppReg->RemoveSessionKeyReference(lpAppRoster->GetSessionKey());

			m_GlobalRosterList.Remove(lpAppRoster);
			m_RosterDeleteList.Append(lpAppRoster);

			TRACE_OUT(("AppRosterMgr: Cleanup: Deleting Global Roster"));

			/*
			**	Since you can not delete a list entry while iterating on it
			**	we must reset the iterator every time an entry is removed.
			*/
			m_GlobalRosterList.Reset();
		}
		else
		{
			/*
			**	Here we reset the application roster to its neutral state.
			**	This affects the nodes added and nodes removed flags.
			*/
			lpAppRoster->ResetApplicationRoster();
		}
	}

	//	Next deal with the Local Application Roster List
	if (! m_fTopProvider)
	{
		m_LocalRosterList.Reset();
		while (NULL != (lpAppRoster = m_LocalRosterList.Iterate()))
		{
			if (lpAppRoster->GetNumberOfApplicationRecords() == 0)
			{
				m_LocalRosterList.Remove(lpAppRoster);
				m_RosterDeleteList.Append(lpAppRoster);

				TRACE_OUT(("AppRosterMgr: Cleanup: Deleting Local Roster"));

				/*
				**	Since you can not delete a list entry while iterating on it
				**	we must reset the iterator every time an entry is removed.
				*/
				m_LocalRosterList.Reset();
			}
			else
			{
				/*
				**	Here we reset the application roster to its neutral state.
				**	This affects the nodes added and nodes removed flags.
				*/
				lpAppRoster->ResetApplicationRoster();
			}
		}
	}
	
	DebugExitVOID(CAppRosterMgr::CleanupApplicationRosterLists);
}

/*
 *	void DeleteRosterRecord ()
 *
 *	Public Function Description
 *		This function overides the base class function and is used to
 *		receive all owner callback information from the application
 *		rosters owned by this object.
 */
void CAppRosterMgr::
DeleteRosterRecord
(
    GCCNodeID       nidRecordToDelete,
    GCCEntityID     eidRecordToDelete
)
{
    //
    // Here we remove ownership from any registry entries associated
    // with the record that was deleted.  Note that since the entity
    // id must be unique for all the APEs at a node (as stated by
    // T.124) there is no need to include the session key to determine
    // which registry entries to clean up.
    //
    CRegistry *pAppReg = m_pConf->GetRegistry();
    pAppReg->RemoveEntityOwnership(nidRecordToDelete, eidRecordToDelete);
}


void CAppRosterMgrList::DeleteList(void)
{
    CAppRosterMgr *pAppRosterMgr;
    while (NULL != (pAppRosterMgr = Get()))
    {
        pAppRosterMgr->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\arost.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_APP_ROSTER);
/*
 *	arost.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Application Roster Class. This
 *		class maintains the application roster, builds roster update and
 *		refresh PDUs and manages the capabilities list which is part of the
 *		application roster.
 *
 *		This class makes use of a number of Rogue Wave lists to maintain the
 *		roster entries and the capabilities list.  The lists are organized in
 *		such a way that the heirarchy of the conference can be maintained.  This
 *		is important to perform the necessary operations required by the T.124
 *		specification.  In general, there is a main "Roster_Record_List" that
 *		maintains a list of "AppRosterRecords". The list is indexed by the
 *		GCC user ID where each record in the list holds a list of application
 *		records (or entities) at that node, a list of capabilities for each
 *		"entity" and a list of sub-nodes (the GCC user IDs of all the nodes
 *		below this one in the connection hierarchy).  The Roster_Record_List
 *		only holds entries for immediately connected nodes.
 *
 *		SEE INTERFACE FILE FOR A MORE DETAILED ABSTRACT
 *
 *	Private Instance Variables:
 *		m_pAppRosterMgr
 *			Pointer to the object that will receive all owner callbacks.
 *		m_cbDataMemory
 *			This is the number of bytes required to hold the data associated
 *			with a roster update message.  This is calculated on a lock.
 *		m_fTopProvider
 *			Flag indicating if the node where this roster lives is the top
 *			provider.
 *		m_fLocalRoster
 *			Flag indicating if the roster data is associated with a local
 *			roster (maintaining intermediate node data) or global roster (
 *			(maintaining roster data for the whole conference).
 *		m_pSessionKey
 *			Pointer to a session key object that holds the session key
 *			associated with this roster.
 *		m_nInstance
 *			The current instance of the roster.  This number will change
 *			whenever the roster is updated.
 *		m_fRosterHasChanged
 *			Flag indicating if the roster has changed since the last reset.
 *		m_fPeerEntitiesAdded
 *			Flag indicating if any APE records have been added to the
 *			application roster since the last reset.
 *		m_fPeerEntitiesRemoved
 *			Flag indicating if any APE records have been deleted from the
 *			application roster since the last reset.
 *		m_fCapabilitiesHaveChanged
 *			Flag indicating if the capabilities has changed since the last
 *			reset.
 *		m_NodeRecordList2
 *			List which contains all the application roster's node records.
 *		m_CollapsedCapListForAllNodes
 *			List which contains all the application roster's collapsed
 *			capabilities.
 *		m_fMaintainPduBuffer
 *			Flag indicating if it is necessary for this roster object to
 *			maintain internal PDU data.  Won't be necessary for global rosters
 *			at subordinate nodes.
 *		m_fPduIsFlushed
 *			Flag indicating if the PDU that currently exists has been flushed.
 *		m_SetOfAppInfo
 *			Pointer to internal PDU data.
 *		m_pSetOfAppRecordUpdates
 *			This instance variable keeps up with the current record update so
 *			that it will not be necessary to search the entire list updates
 *			each a new update is added to the internal PDU.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */

#include "arost.h"
#include "arostmgr.h"
#include "clists.h"


/*
**	The maximum length the application data for a non-collapsed capablity
**	can be.
*/
#define	MAXIMUM_APPLICATION_DATA_LENGTH				255

/*
 *	AppRosterRecord	()
 *
 *	Public Function Description
 *		Constructor definition to instantiate the hash list dictionaries that
 *		are used in an AppRosterRecord.  This constructor is needed to allow
 *		the AppRosterRecord structure to be directly instantiated with hash
 *		list.
 */
APP_NODE_RECORD::APP_NODE_RECORD(void) :
	AppRecordList(DESIRED_MAX_APP_RECORDS),
	ListOfAppCapItemList2(DESIRED_MAX_CAP_LISTS),
	SubNodeList2(DESIRED_MAX_NODES)
{}


/*
 *	CAppRoster	()
 *
 *	Public Function Description
 *	When pGccSessKey is not NULL
 *		This constructor is used to create an empty application roster. Note
 *		that the session key for the roster must be passed in to the
 *		constructor.
 *
 *	When pSessKey is not NULL
 *		This constructor builds a roster based on an indication pdu.
 *		Application Roster objects may exist at nodes which do not have
 *		applications to perform the necessary operations required by T.124
 */
CAppRoster::CAppRoster (	
			PGCCSessionKey				pGccSessKey,// create an empty app roster
			PSessionKey					pPduSessKey,// build an app roster based on an indication pdu
			CAppRosterMgr				*pAppRosterMgr,
			BOOL						fTopProvider,
			BOOL						fLocalRoster,
			BOOL						fMaintainPduBuffer,
			PGCCError					pRetCode)
:
    CRefCount(MAKE_STAMP_ID('A','R','s','t')),
	m_nInstance(0),
	m_pAppRosterMgr(pAppRosterMgr),
	m_cbDataMemory(0),
	m_fTopProvider(fTopProvider),
	m_fLocalRoster(fLocalRoster),
	m_pSessionKey(NULL),
	m_fRosterHasChanged(FALSE),
	m_fPeerEntitiesAdded(FALSE),
	m_fPeerEntitiesRemoved(FALSE),
	m_fCapabilitiesHaveChanged(FALSE),
	m_NodeRecordList2(DESIRED_MAX_NODES),
	m_fMaintainPduBuffer(fMaintainPduBuffer),
	m_fPduIsFlushed(FALSE),
	m_pSetOfAppRecordUpdates(NULL)
{
	DebugEntry(CAppRoster::CAppRoster);

	GCCError rc = GCC_NO_ERROR;

	ZeroMemory(&m_SetOfAppInfo, sizeof(m_SetOfAppInfo));

	/*
	**	Here we store the session key of the roster.
	*/
	if (NULL != pGccSessKey)
	{
		ASSERT(NULL == pPduSessKey);
		DBG_SAVE_FILE_LINE
		m_pSessionKey = new CSessKeyContainer(pGccSessKey, &rc);
	}
	else
	if (NULL != pPduSessKey)
	{
		DBG_SAVE_FILE_LINE
		m_pSessionKey = new CSessKeyContainer(pPduSessKey, &rc);
	}
	else
	{
		ERROR_OUT(("CAppRoster::CAppRoster: invalid session key"));
		rc = GCC_BAD_SESSION_KEY;
		goto MyExit;
	}

	if (NULL == m_pSessionKey || GCC_NO_ERROR != rc)
	{
		ERROR_OUT(("CAppRoster::CAppRoster: can't create session key"));
		rc = GCC_ALLOCATION_FAILURE;
		// we do the cleanup in the destructor
		goto MyExit;
	}

	//	Initialize the PDU structure to be no change.
	m_SetOfAppInfo.value.application_record_list.choice = APPLICATION_NO_CHANGE_CHOSEN;
	m_SetOfAppInfo.value.application_capabilities_list.choice = CAPABILITY_NO_CHANGE_CHOSEN;

	/*
	**	Here we go ahead and set up the session key portion of the
	**	PDU so we don't have to worry about it later.
	*/
	if (m_fMaintainPduBuffer)
	{
		rc = m_pSessionKey->GetSessionKeyDataPDU(&m_SetOfAppInfo.value.session_key);
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CAppRoster:;CAppRoster, rc);

	*pRetCode = rc;
}


/*
 *	~CAppRoster	()
 *
 *	Public Function Description:
 *		The destructor for the CAppRoster class is used to clean up
 *		any memory allocated during the life of the object.
 */
CAppRoster::~CAppRoster(void)
{
	/*
	 * Free up all memory associated with the roster record list.
	 */
	ClearNodeRecordList();

	//	Clear the Collapsed Capabilities List.
	m_CollapsedCapListForAllNodes.DeleteList();

	/*
	 * Free up any outstanding PDU data.
	 */
	if (m_fMaintainPduBuffer)
	{
		FreeRosterUpdateIndicationPDU();
	}

	/*
	 * Free any memory associated with the session key..
	 */
	if (NULL != m_pSessionKey)
	{
	    m_pSessionKey->Release();
	}
}


/*
 * Utilities that operate on roster update PDU strucutures.
 */

/*
 *	GCCError	FlushRosterUpdateIndicationPDU ()
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the application roster.  PDU data is queued whenever
 *		a request is made to the application roster that affects its
 *		internal information base.
 */
void CAppRoster::FlushRosterUpdateIndicationPDU(PSetOfApplicationInformation *pSetOfAppInfo)
{
	DebugEntry(CAppRoster::FlushRosterUpdateIndicationPDU);

	/*
	**	If this roster has already been flushed we will NOT allow the same
	**	PDU to be flushed again.  Instead we delete the previously flushed
	**	PDU and set the flag back to unflushed.  If another flush comes in
	**	before a PDU is built NULL will be returned in the application
	**	information pointer.
	*/	
	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU();
		m_fPduIsFlushed = FALSE;
	}

	if ((m_SetOfAppInfo.value.application_record_list.choice != APPLICATION_NO_CHANGE_CHOSEN) ||
		(m_SetOfAppInfo.value.application_capabilities_list.choice != CAPABILITY_NO_CHANGE_CHOSEN))
	{
		if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_NO_CHANGE_CHOSEN)
		{
			TRACE_OUT(("CAppRoster::FlushRosterUpdateIndicationPDU:"
						"Sending APPLICATION_NO_CHANGE_CHOSEN PDU"));
		}

		/*
		**	This section of the code sets up all the variables that don't
		**	pertain to the record list or the caps list.  Note that the
		**	session key PDU data was set up in the constructor.  Also note that
		**	the record list data and capabilities list data should be set up
		**	before this routine is called if there is any PDU traffic to issue.	
		*/
		m_SetOfAppInfo.next = NULL;
		m_SetOfAppInfo.value.roster_instance_number = (USHORT) m_nInstance;
		m_SetOfAppInfo.value.peer_entities_are_added = (ASN1bool_t)m_fPeerEntitiesAdded;
		m_SetOfAppInfo.value.peer_entities_are_removed = (ASN1bool_t)m_fPeerEntitiesRemoved;

		/*
		**	Here we set up the pointer to the whole PDU structure associated
		**	with this application roster.
		*/
		*pSetOfAppInfo = &m_SetOfAppInfo;

		/*
		**	Setting this to true will cause the PDU data to be freed up the
		**	next time the roster object is entered insuring that new PDU
		**	data will be created.
		*/
		m_fPduIsFlushed = TRUE;
	}
	else
	{
		*pSetOfAppInfo = NULL;
	}
}


/*
 *	GCCError	BuildFullRefreshPDU ()
 *
 *	Public Function Description
 *		This routine is responsible for generating a full application roster
 *		refresh PDU.
 */
GCCError CAppRoster::BuildFullRefreshPDU(void)
{
	GCCError	rc;

	DebugEntry(CAppRoster::BuildFullRefreshPDU);

	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	rc = BuildApplicationRecordListPDU (APP_FULL_REFRESH, 0, 0);
	if (rc == GCC_NO_ERROR)
	{
		BuildSetOfCapabilityRefreshesPDU ();
	}

	return rc;
}


/*
 *	GCCError	BuildApplicationRecordListPDU ()
 *
 *	Private Function Description
 *		This routine creates an application roster update indication
 *		PDU based on the passed in parameters. Memory used after this
 *		routine is called is still owned by this object and will be
 *		freed the next time this objects internal information base is
 *		modified.
 *
 *	Formal Parameters:
 *		update_type		-	What type of update are we building.
 *		user_id			-	node id of record to update.
 *		entity_id		-	entity id of record to update.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_INVALID_PARAMETER	-	Parameter passed in is invalid.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CAppRoster::BuildApplicationRecordListPDU (
						APP_ROSTER_UPDATE_TYPE			update_type,
						UserID							user_id,
						EntityID						entity_id)
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CAppRoster::BuildApplicationRecordListPDU);

	if (m_fMaintainPduBuffer)
	{
		/*
		**	Note here that the top provider node always sends a full refresh
		**	PDU so there is no need to pay any attention to update type in
		**	this case.
		*/
		if ((update_type == APP_FULL_REFRESH) || m_fTopProvider)
		{
			/*
			**	First check to see if a refresh was already processed since the
			**	last PDU was flushed.  If so we must free up the last refresh in
			**	preperation for the new one built here.  Otherwise, if we have
			**	already started building an update this is not currently
			**	supported and is considered an error here.
			*/
			if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_RECORD_REFRESH_CHOSEN)
			{
				FreeSetOfRefreshesPDU();
			}
			else
			if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_RECORD_UPDATE_CHOSEN)
			{
				ERROR_OUT(("CAppRoster::BuildApplicationRecordListPDU:"
							"ASSERTION: building refresh when update exists"));
				return GCC_INVALID_PARAMETER;
			}

			//	This routine fills in the complete record list at this node.
			rc = BuildSetOfRefreshesPDU();
			if (rc == GCC_NO_ERROR)
			{
				m_SetOfAppInfo.value.application_record_list.choice = APPLICATION_RECORD_REFRESH_CHOSEN;
			}
		}
		else
		if (update_type != APP_NO_CHANGE)
		{
			/*
			**	Here if there has already been a refresh PDU built we flag this
			**	as an error since we do not support both types of application
			**	information at the same time.
			*/
			if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_RECORD_REFRESH_CHOSEN)
			{
				ERROR_OUT(("CAppRoster::BuildApplicationRecordListPDU:"
							"ASSERTION: building update when refresh exists"));
				return GCC_INVALID_PARAMETER;
			}

			//	This routine fills in the specified update.
			rc = BuildSetOfUpdatesPDU(update_type, user_id, entity_id);
			if (rc == GCC_NO_ERROR)
			{
				/*
				**	If the first set of updates has not been used yet we
				**	initialize it here with the first update.
				*/
				if (m_SetOfAppInfo.value.application_record_list.choice == APPLICATION_NO_CHANGE_CHOSEN)
				{
					ASSERT(NULL != m_pSetOfAppRecordUpdates);
					m_SetOfAppInfo.value.application_record_list.u.application_record_update =
								m_pSetOfAppRecordUpdates;
					m_SetOfAppInfo.value.application_record_list.choice = APPLICATION_RECORD_UPDATE_CHOSEN;
				}
			}
		}
	}

	return rc;
}


/*
 *	GCCError	BuildSetOfRefreshesPDU	()
 *
 *	Private Function Description
 *		This member function fills in the PDU with the entire set of roster
 *		entries at this node.  This is typically called when the Top Provider is
 *		broadcasting a full refresh of the application roster.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATION_FAILURE - On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::BuildSetOfRefreshesPDU(void)
{
	GCCError							rc = GCC_ALLOCATION_FAILURE;
	PSetOfApplicationRecordRefreshes	pNewAppRecordRefreshes;
	PSetOfApplicationRecordRefreshes	pOldAppRecordRefreshes = NULL;
	APP_NODE_RECORD						*lpAppNodeRecord;
	APP_RECORD  					    *lpAppRecData;
	CAppRecordList2						*lpAppRecDataList;
	UserID								uid, uid2;
	EntityID							eid;

	DebugEntry(CAppRoster::BuildSetOfRefreshesPDU);

	m_SetOfAppInfo.value.application_record_list.u.application_record_refresh = NULL;

	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRecord = m_NodeRecordList2.Iterate(&uid)))
	{
		/*
		**	First we iterate through this nodes application record list. This
		**	encodes all the records local to this node. After this, all the
		**	sub nodes within this roster record will be encoded.
		*/
		lpAppNodeRecord->AppRecordList.Reset();
		while (NULL != (lpAppRecData = lpAppNodeRecord->AppRecordList.Iterate(&eid)))
		{
			DBG_SAVE_FILE_LINE
			pNewAppRecordRefreshes = new SetOfApplicationRecordRefreshes;
			if (NULL == pNewAppRecordRefreshes)
			{
				goto MyExit;
			}

			if (m_SetOfAppInfo.value.application_record_list.u.application_record_refresh == NULL)
			{
				m_SetOfAppInfo.value.application_record_list.u.application_record_refresh = pNewAppRecordRefreshes;
			}
			else
			{
				pOldAppRecordRefreshes->next = pNewAppRecordRefreshes;
			}
	
			(pOldAppRecordRefreshes = pNewAppRecordRefreshes)->next = NULL;
			pNewAppRecordRefreshes->value.node_id = uid;
			pNewAppRecordRefreshes->value.entity_id = eid;

			//	Fill in the application record.
			rc = BuildApplicationRecordPDU(lpAppRecData,
	            			&pNewAppRecordRefreshes->value.application_record);
			if (GCC_NO_ERROR != rc)
			{
				goto MyExit;
			}
		}

		//	This section of the code copies the sub node records.
		lpAppNodeRecord->SubNodeList2.Reset();
		while (NULL != (lpAppRecDataList = lpAppNodeRecord->SubNodeList2.Iterate(&uid2)))
		{
			lpAppRecDataList->Reset();
			while (NULL != (lpAppRecData = lpAppRecDataList->Iterate(&eid)))
			{
				DBG_SAVE_FILE_LINE
				pNewAppRecordRefreshes = new SetOfApplicationRecordRefreshes;
				if (NULL == pNewAppRecordRefreshes)
				{
					goto MyExit;
				}

				/*
				**	We must again check for null because it is possible
				**	to have an application roster with sub node records
				**	but no application records.
				*/
				if (m_SetOfAppInfo.value.application_record_list.u.application_record_refresh == NULL)
				{
					m_SetOfAppInfo.value.application_record_list.u.application_record_refresh = pNewAppRecordRefreshes;
				}
				else
				{
					pOldAppRecordRefreshes->next = pNewAppRecordRefreshes;
				}
		
				(pOldAppRecordRefreshes = pNewAppRecordRefreshes)->next = NULL;
				pNewAppRecordRefreshes->value.node_id = uid2;
				pNewAppRecordRefreshes->value.entity_id = eid;

				//	Fill in the application record.
				rc = BuildApplicationRecordPDU (lpAppRecData,
	                	&pNewAppRecordRefreshes->value.application_record);
				if (GCC_NO_ERROR != rc)
				{
					goto MyExit;
				}
			}
		}
	}

	rc = GCC_NO_ERROR;

MyExit:

	return rc;
}


/*
 *	GCCError	BuildSetOfUpdatesPDU	()
 *
 *	Private Function Description
 *		This routine builds a single update based on the update type specified
 *		in the passed in parameter.
 *
 *	Formal Parameters
 *		update_type - 	(i)	Either APP_REPLACE_RECORD, APP_DELETE_RECORD, or
 *							APP_ADD_RECORD.
 *		node_id -		(i)	The node id of the update PDU record to build.
 *		entity_id 		(i) The entity id of the update PDU record to build.
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATION_FAILURE - On resource failure
 *		GCC_NO_SUCH_APPLICATION - If the specified record doesn't exist
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::BuildSetOfUpdatesPDU(
						APP_ROSTER_UPDATE_TYPE				update_type,
						UserID								node_id,
						EntityID							entity_id)
{
	GCCError					rc = GCC_NO_ERROR;
	CAppRecordList2				*pAppRecordList;
	APP_RECORD  			    *pAppRecord = NULL;
	APP_NODE_RECORD				*node_record;

	DebugEntry(CAppRoster::BuildSetOfUpdatesPDU);

	/*
	**	We must first determine the pointer to the application record
	**	specified by the passed in user id and entity_id. We only do
	**	this search if the update type is not APP_DELETE_RECORD.
	*/
	if (update_type != APP_DELETE_RECORD)
	{
		if (NULL != (node_record = m_NodeRecordList2.Find(node_id)))
		{
			//	Get a pointer to the application record from the entity id.
			pAppRecord = node_record->AppRecordList.Find(entity_id);
		}
		else
		{
			//	Here we iterate through the sub-node list looking for the record
			m_NodeRecordList2.Reset();
			while(NULL != (node_record = m_NodeRecordList2.Iterate()))
			{
				if (NULL != (pAppRecordList = node_record->SubNodeList2.Find(node_id)))
				{
					pAppRecord = pAppRecordList->Find(entity_id);
					break;
				}
			}
		}
	}

	/*
	**	Now if the application record was found or the update type is delete
	**	record we go ahead and encode the PDU here.
	*/
	if ((pAppRecord != NULL) || (update_type == APP_DELETE_RECORD))
	{
		/*
		**	Here the record update will be NULL if it is the first record
		**	update being encoded. Otherwise we must bump the record to the
		**	next set of updates.
		*/
		DBG_SAVE_FILE_LINE
		PSetOfApplicationRecordUpdates pUpdates = new SetOfApplicationRecordUpdates;
		if (NULL == pUpdates)
		{
			return GCC_ALLOCATION_FAILURE;
		}
		pUpdates->next = NULL;

		if (m_pSetOfAppRecordUpdates == NULL)
		{
			m_pSetOfAppRecordUpdates = pUpdates;
		}
		else
		{
		    //
			// LONCHANC: right now, append the new one.
			// but, can we prepend the new one???
			//
			PSetOfApplicationRecordUpdates p;
			for (p = m_pSetOfAppRecordUpdates; NULL != p->next; p = p->next)
				;
			p->next = pUpdates;
		}

		/*
		 * This routine only returns one record.
		 */
		pUpdates->value.node_id = node_id;
		pUpdates->value.entity_id = entity_id;

		switch (update_type)
		{
		case APP_ADD_RECORD:
			pUpdates->value.application_update.choice = APPLICATION_ADD_RECORD_CHOSEN;

			BuildApplicationRecordPDU(pAppRecord,
					&(pUpdates->value.application_update.u.application_add_record));
			break;
		case APP_REPLACE_RECORD:
			pUpdates->value.application_update.choice = APPLICATION_REPLACE_RECORD_CHOSEN;

			rc = BuildApplicationRecordPDU(pAppRecord,
					&(pUpdates->value.application_update.u.application_replace_record));
			break;
		default:
			/*
			 * The record does not have to be filled in for this case.
			 */
			pUpdates->value.application_update.choice = APPLICATION_REMOVE_RECORD_CHOSEN;
			break;
		}
	}
	else
	{
		WARNING_OUT(("CAppRoster::BuildSetOfUpdatesPDU: Assertion:"
					"No applicaton record found for PDU"));
		rc = GCC_NO_SUCH_APPLICATION;
	}

	return rc;
}


/*
 *	GCCError	BuildApplicationRecordPDU ()
 *
 *	Private Function Description
 *		This routine build a single application record for a PDU. A pointer to
 *		the record is passed in to the routine.
 *
 *	Formal Parameters
 *		application_record - 		(i)	Record to be encoded.
 *		application_record_pdu -	(i)	PDU to fill in.
 *
 *	Return Value
 *		GCC_NO_ERROR 			- On Success
 *		GCC_ALLOCATION_FAILURE	- A resource error occured.
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::BuildApplicationRecordPDU(
							APP_RECORD  		    *pAppRecord,
							PApplicationRecord		pAppRecordPdu)
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CAppRoster::BuildApplicationRecordPDU);

	pAppRecordPdu->bit_mask = 0;

	if (! pAppRecord->non_collapsed_caps_list.IsEmpty())
	{
		pAppRecordPdu->bit_mask |= NON_COLLAPSING_CAPABILITIES_PRESENT;
		
		rc = BuildSetOfNonCollapsingCapabilitiesPDU(
								&pAppRecordPdu->non_collapsing_capabilities,
								&pAppRecord->non_collapsed_caps_list);
		if (GCC_NO_ERROR != rc)
		{
			goto MyExit;
		}
	}

	//	Fill in the startup channel type if it is specified
	if (pAppRecord->startup_channel_type != MCS_NO_CHANNEL_TYPE_SPECIFIED)
	{
		pAppRecordPdu->bit_mask |= RECORD_STARTUP_CHANNEL_PRESENT;
		pAppRecordPdu->record_startup_channel = (ChannelType) pAppRecord->startup_channel_type;
	}

	//	Fill in the application user id if one is specified
	if (pAppRecord->application_user_id	!= 0)
	{
		pAppRecordPdu->bit_mask |= APPLICATION_USER_ID_PRESENT;
		pAppRecordPdu->application_user_id = pAppRecord->application_user_id;
	}

	//	Fill in the required fields
	pAppRecordPdu->application_is_active = (ASN1bool_t)pAppRecord->is_enrolled_actively;
	pAppRecordPdu->is_conducting_capable = (ASN1bool_t)pAppRecord->is_conducting_capable;

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	return rc;
}


/*
 *	GCCError	BuildSetOfCapabilityRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine builds a PDU structure with the complete set of
 *		capabilities maintained at this node.
 *
 *	Formal Parameters
 *		None
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATIONFAILURE - On resource failure
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		The standard allows us to send a zero length set of capabilities when
 *		an application leaves that previously had capabilites.
 */
GCCError CAppRoster::BuildSetOfCapabilityRefreshesPDU(void)
{
	GCCError								rc = GCC_ALLOCATION_FAILURE;
	PSetOfApplicationCapabilityRefreshes	pNew;
	PSetOfApplicationCapabilityRefreshes	pOld = NULL;

	DebugEntry(CAppRoster::BuildSetOfCapabilityRefreshesPDU);

	if (m_fMaintainPduBuffer)
	{
		APP_CAP_ITEM		*lpAppCapData;
		/*
		**	We must first free up any previously built PDU data associated
		**	with a capability refresh.
		*/
		if (m_SetOfAppInfo.value.application_capabilities_list.choice == APPLICATION_CAPABILITY_REFRESH_CHOSEN)
		{
			FreeSetOfCapabilityRefreshesPDU ();
		}

		m_SetOfAppInfo.value.application_capabilities_list.choice = APPLICATION_CAPABILITY_REFRESH_CHOSEN;
		m_SetOfAppInfo.value.application_capabilities_list.u.application_capability_refresh = NULL;

		//	Iterate through the complete list of capabilities.
		m_CollapsedCapListForAllNodes.Reset();
		while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
		{
			DBG_SAVE_FILE_LINE
			pNew = new SetOfApplicationCapabilityRefreshes;
			if (NULL == pNew)
			{
				goto MyExit;
			}

			/*
			**	If the set of capability refreshes pointer is equal to NULL
			**	we are at the first capability. Here we need to save the
			**	pointer to the first capability.
			*/
			if (m_SetOfAppInfo.value.application_capabilities_list.u.
					application_capability_refresh == NULL)
			{
				m_SetOfAppInfo.value.application_capabilities_list.u.
					application_capability_refresh = pNew;
			}
			else
			{
				pOld->next = pNew;
			}

			/*
			**	This is used to set the next pointer if another record
			**	exists after this one.
			*/
			/*
			 * This will get filled in later if there is another record.
			 */
			(pOld = pNew)->next = NULL;

			//	Fill in the capability identifier
			rc = lpAppCapData->pCapID->GetCapabilityIdentifierDataPDU(
							&pNew->value.capability_id);
			if (GCC_NO_ERROR != rc)
			{
				goto MyExit;
			}
		
			//	Fill in the capability choice from the GCC capability class.
			pNew->value.capability_class.choice = (USHORT) lpAppCapData->eCapType;

			//	Note that nothing is filled in for a logical capability.
			if (lpAppCapData->eCapType == GCC_UNSIGNED_MINIMUM_CAPABILITY)
			{
				pNew->value.capability_class.u.unsigned_minimum =
						lpAppCapData->nUnsignedMinimum;
			}
			else if (lpAppCapData->eCapType == GCC_UNSIGNED_MAXIMUM_CAPABILITY)
			{
				pNew->value.capability_class.u.unsigned_maximum =
						lpAppCapData->nUnsignedMaximum;
			}

			//	Fill in number of entities regardless of capability type.
			pNew->value.number_of_entities = lpAppCapData->cEntries;
		}
	}

	rc = GCC_NO_ERROR;

MyExit:

	return rc;
}


/*
 *	ApplicationRosterError	BuildSetOfNonCollapsingCapabilitiesPDU ()
 *
 *	Private Function Description
 *		This routine builds a PDU structure for the non collapsing capabilities
 *		list associated passed in.
 *
 *	Formal Parameters
 *		pSetOfCaps				-	(o)	PDU structure to fill in
 *		capabilities_list		-	(i)	Source non-collapsing capabilities.
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATIONFAILURE - On resource failure
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		None
 */
GCCError CAppRoster::BuildSetOfNonCollapsingCapabilitiesPDU(
				PSetOfNonCollapsingCapabilities	*pSetOfCaps,
				CAppCapItemList					*pAppCapItemList)
{
	GCCError							rc = GCC_ALLOCATION_FAILURE;
	PSetOfNonCollapsingCapabilities		new_set_of_capabilities;
	PSetOfNonCollapsingCapabilities		old_set_of_capabilities;
	APP_CAP_ITEM						*lpAppCapData;

	DebugEntry(CAppRoster::BuildSetOfNonCollapsingCapabilitiesPDU);

	*pSetOfCaps = NULL;
	old_set_of_capabilities = NULL;	//	Setting this to NULL removes warning

	/*
	 * Iterate through the complete list of capabilities.
	 */
	pAppCapItemList->Reset();
	while (NULL != (lpAppCapData = pAppCapItemList->Iterate()))
	{
		DBG_SAVE_FILE_LINE
		new_set_of_capabilities = new SetOfNonCollapsingCapabilities;
		if (NULL == new_set_of_capabilities)
		{
			goto MyExit;
		}

		/*
		**	If the passed in pointer is equal to NULL we are at the first
		**	capability. Here we need to save the pointer to the first
		**	capability in the passed in pointer.
		*/
		if (*pSetOfCaps == NULL)
		{
			*pSetOfCaps = new_set_of_capabilities;
		}
		else
		{
			if(old_set_of_capabilities != NULL)
			{
				old_set_of_capabilities->next = new_set_of_capabilities;
			}
		}

		/*
		**	This is used to set the next pointer if another record exists
		**	after this one.
		*/
		old_set_of_capabilities = new_set_of_capabilities;

		/*
		 * This will get filled in later if there is another record.
		 */
		new_set_of_capabilities->next = NULL;

		new_set_of_capabilities->value.bit_mask = 0;

		//	Fill in the capability identifier									
		rc = lpAppCapData->pCapID->GetCapabilityIdentifierDataPDU(
							&new_set_of_capabilities->value.capability_id);
		if (GCC_NO_ERROR != rc)
		{
			goto MyExit;
		}

		if ((lpAppCapData->poszAppData != NULL) && (rc == GCC_NO_ERROR))
		{
			new_set_of_capabilities->value.bit_mask |= APPLICATION_DATA_PRESENT;

			new_set_of_capabilities->value.application_data.length =
					lpAppCapData->poszAppData->length;

			new_set_of_capabilities->value.application_data.value =
					lpAppCapData->poszAppData->value;
		}
	}

	rc = GCC_NO_ERROR;

MyExit:

    if(rc != GCC_NO_ERROR)
    {
	FreeSetOfNonCollapsingCapabilitiesPDU(*pSetOfCaps);
	*pSetOfCaps = NULL;
    }

    return rc;
}


/*
 * These routines are used to free up a roster update indication PDU.
 */

/*
 *	void	FreeRosterUpdateIndicationPDU ()
 *
 *	Private Function Description
 *		This routine frees up all the internal data allocated to hold the roster
 *		update PDU.
 *
 *	Formal Parameters
 *		None
 *
 *	Return Value
 *		None
 *
 *	Side Effects
 *		None
 *
 *	Caveats
 *		Note that the session key PDU data is not freed.  Since this data will
 *		not change through out the life of this application roster object
 *		we just use the same session id PDU data for every roster update
 *		indication.
 */
void CAppRoster::FreeRosterUpdateIndicationPDU(void)
{
	DebugEntry(CAppRoster::FreeRosterUpdateIndicationPDU);

	switch (m_SetOfAppInfo.value.application_record_list.choice)
	{
	case APPLICATION_RECORD_REFRESH_CHOSEN:
		FreeSetOfRefreshesPDU ();
		break;
	case APPLICATION_RECORD_UPDATE_CHOSEN:
		FreeSetOfUpdatesPDU ();
		break;
	}

	//	Free the PDU data associated with the capability list if one exists.
	if (m_SetOfAppInfo.value.application_capabilities_list.choice == APPLICATION_CAPABILITY_REFRESH_CHOSEN)
	{
		FreeSetOfCapabilityRefreshesPDU ();
	}
	
	m_SetOfAppInfo.value.application_record_list.choice = APPLICATION_NO_CHANGE_CHOSEN;
	m_SetOfAppInfo.value.application_capabilities_list.choice = CAPABILITY_NO_CHANGE_CHOSEN;
	m_pSetOfAppRecordUpdates = NULL;
}


/*
 *	void	FreeSetOfRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine Frees all the memory associated with a set
 *		of application record refreshes.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
void CAppRoster::FreeSetOfRefreshesPDU(void)
{
	PSetOfApplicationRecordRefreshes		pCurr, pNext;

	DebugEntry(CAppRoster::FreeSetOfRefreshesPDU);

	for (pCurr = m_SetOfAppInfo.value.application_record_list.u.application_record_refresh;
			NULL != pCurr;
			pCurr = pNext)
	{
		pNext = pCurr->next;

		//	Free up any non-collapsing capabilities data
		if (pCurr->value.application_record.bit_mask & NON_COLLAPSING_CAPABILITIES_PRESENT)
		{
			FreeSetOfNonCollapsingCapabilitiesPDU(pCurr->value.application_record.non_collapsing_capabilities);
		}

		//	Delete the actual record refresh
		delete pCurr;
	}
	m_SetOfAppInfo.value.application_record_list.u.application_record_refresh = NULL;
}


/*
 *	void	FreeSetOfUpdatesPDU	()
 *
 *	Private Function Description
 *		This routine frees the memory associated with a complete set
 *		application roster updates.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
void CAppRoster::FreeSetOfUpdatesPDU(void)
{
	PSetOfApplicationRecordUpdates		pCurr, pNext;
	PApplicationRecord					application_record;

	DebugEntry(CAppRoster::FreeSetOfUpdatesPDU);

	for (pCurr = m_SetOfAppInfo.value.application_record_list.u.application_record_update;
			NULL != pCurr;
			pCurr = pNext)
	{
		// remember the next one because we will free the current one
		pNext = pCurr->next;

		//	Free up any non-collapsing capabilities data
		switch(pCurr->value.application_update.choice)
		{
		case APPLICATION_ADD_RECORD_CHOSEN:
			application_record = &pCurr->value.application_update.u.application_add_record;
			break;
		case APPLICATION_REPLACE_RECORD_CHOSEN:
			application_record = &pCurr->value.application_update.u.application_replace_record;
			break;
		default:
			application_record = NULL;
			break;
		}

		if (application_record != NULL)
		{
			if (application_record->bit_mask & NON_COLLAPSING_CAPABILITIES_PRESENT)
			{
				FreeSetOfNonCollapsingCapabilitiesPDU(application_record->non_collapsing_capabilities);
			}
		}

		//	Delete the actual update structure
		delete pCurr;
	}
    m_SetOfAppInfo.value.application_record_list.u.application_record_update = NULL;
}


/*
 *	void	FreeSetOfCapabilityRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine frees all the memory associated with the capability PDU.
 *
 *	Formal Parameters
 *		capability_refresh -	(i)	Capabilities to be freed.
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		Note that the capability id PDU data is not freed here.  Since this
 *		data should not change through out the life of this object we don't
 *		bother freeing and regenerating it.
 */
void CAppRoster::FreeSetOfCapabilityRefreshesPDU(void)
{
	PSetOfApplicationCapabilityRefreshes		pCurr, pNext;

	for (pCurr = m_SetOfAppInfo.value.application_capabilities_list.u.application_capability_refresh;
			NULL != pCurr;
			pCurr = pNext)
	{
		pNext = pCurr->next;
		delete pCurr;
	}
}


/*
 *	void	FreeSetOfNonCollapsingCapabilitiesPDU	()
 *
 *	Private Function Description
 *		This routine frees all the memory associated with the
 *		non-collapsed capability PDU.
 *
 *	Formal Parameters
 *		capability_refresh -	(i)	Non-Collapsed Capabilities to be freed.
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		Note that the capability id PDU data is not freed here.  Since this
 *		data should not change through out the life of this object we don't
 *		bother freeing and regenerating it.
 */
void CAppRoster::FreeSetOfNonCollapsingCapabilitiesPDU (
						PSetOfNonCollapsingCapabilities		capability_refresh)
{
	PSetOfNonCollapsingCapabilities		pCurr, pNext;

	for (pCurr = capability_refresh; NULL != pCurr; pCurr = pNext)
	{
		pNext = pCurr->next;
		delete pCurr;
	}
}


/*
 * These routines process roster update indication PDUs.
 */

/*
 *	ApplicationRosterError	ProcessRosterUpdateIndicationPDU	()
 *
 *	Public Function Description
 *		This routine is responsible for processing the decoded PDU data.
 *		It essentially changes the application roster object's internal database
 *		based on the information in the structure.
 */
GCCError CAppRoster::ProcessRosterUpdateIndicationPDU (
						PSetOfApplicationInformation  	application_information,
                        UserID							sender_id)
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CAppRoster::ProcessRosterUpdateIndicationPDU);

	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	/*
	**	Now check the application key to make sure we have a match. If
	**	not, return with no change.
	*/
	if (! m_pSessionKey->IsThisYourSessionKeyPDU(&application_information->value.session_key))
	{
		WARNING_OUT(("CAppRoster::ProcessRosterUpdateIndicationPDU:GCC_BAD_SESSION_KEY"));
		rc = GCC_BAD_SESSION_KEY;
		goto MyExit;
	}

	/*
	**	If this is a roster update and refresh is chosen we must
	**	clear out the entire list and rebuild it.
	*/
	if (application_information->value.application_record_list.choice != APPLICATION_NO_CHANGE_CHOSEN)
	{
		//	The roster is about to change
		m_fRosterHasChanged = TRUE;

		/*
		**	If this node is the top provider or this roster is local and
		**	only used to propogate PDUs up toward the top provider,
		**	we increment the instance number. If it is not we get the
		**	instance number out of the PDU.
		*/
		if (m_fTopProvider || m_fLocalRoster)
		{
			m_nInstance++;
		}
		else
		{
			m_nInstance = application_information->value.roster_instance_number;
		}
		
		/*
		**	Here if either of these booleans is already TRUE we do not
		**	want to write over them with this PDU data.  Therefore, we
		**	check for FALSE before we do anything with them.
		*/
		if (! m_fPeerEntitiesAdded)
		{
			m_fPeerEntitiesAdded = application_information->value.peer_entities_are_added;
		}

		if (! m_fPeerEntitiesRemoved)
		{
			m_fPeerEntitiesRemoved = application_information->value.peer_entities_are_removed;
		}

		if (application_information->value.application_record_list.choice == APPLICATION_RECORD_REFRESH_CHOSEN)
		{
			TRACE_OUT(("CAppRoster::ProcessRosterUpdateIndicationPDU:ProcessSetOfRefreshesPDU"));
			rc = ProcessSetOfRefreshesPDU(
							application_information->value.application_record_list.u.application_record_refresh,
							sender_id);
		}
		else
		{
			TRACE_OUT(("CAppRoster::ProcessRosterUpdateIndicationPDU:ProcessSetOfUpdatesPDU"));
			rc = ProcessSetOfUpdatesPDU(
							application_information->value.application_record_list.u.application_record_update,
							sender_id);
		}
		if (GCC_NO_ERROR != rc)
		{
			goto MyExit;
		}
	}
	else
	{
		ERROR_OUT(("AppRoster::ProcessRosterUpdateIndicationPDU:ASSERTION: NO Change PDU received"));
	}

	//	Process the capabilities list portion of the PDU.
	if (application_information->value.application_capabilities_list.choice == APPLICATION_CAPABILITY_REFRESH_CHOSEN)
	{
		//	Set flag to show that change has occured.
		m_fCapabilitiesHaveChanged = TRUE;

		/*
		**	We will store the new capabilities in the roster record
		**	associated with the sender id.  Note that it is possible for
		**	this roster record to contain an empty application record list
		**	if the sending node has no enrolled applications.
		*/
		rc = ProcessSetOfCapabilityRefreshesPDU(
						application_information->value.application_capabilities_list.u.application_capability_refresh,
						sender_id);
	}
	else
	{
		ASSERT(GCC_NO_ERROR == rc);
	}

MyExit:

	return rc;
}


/*
 *	GCCError	ProcessSetOfRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine processes a set of record refreshes. It is responsible
 *		for managing the creation (or update) of all affected application
 *		records. The roster list built from a refresh PDU does not maintain the
 *		hierarchy of the conference since it is not important at this point.
 *		Refreshes are issued as broacast from the Top Provider down to the
 *		sub-ordinate nodes.
 *
 *	Formal Parameters
 *		record_refresh 	-	(i) Set of record refresh PDUs to be processed.
 *		sender_id		-	(i)	Node id of node that sent the update.
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATION_FAILURE - On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveate
 *		none
 */
GCCError CAppRoster::ProcessSetOfRefreshesPDU(
							PSetOfApplicationRecordRefreshes	record_refresh,
							UserID								sender_id)
{
	GCCError							rc = GCC_ALLOCATION_FAILURE;
	PSetOfApplicationRecordRefreshes	pCurr;
	APP_RECORD  					    *app_record;
	APP_NODE_RECORD						*node_record = NULL;
	CAppRecordList2						*record_list=NULL;
	UserID								node_id;
	EntityID							entity_id;

	DebugEntry(CAppRoster::ProcessSetOfRefreshesPDU);

	if (record_refresh != NULL)
	{
		//	Clear out the node record for the sender id	
		ClearNodeRecordFromList (sender_id);

		/*
		** 	Create the node record for the sender id passed into this routine.
		**	Note that if the sender of this refresh is the Top Provider
		**	all nodes below the top provider are contained in the sub node
		**	list of the Top Provider's node record.	
		*/
		DBG_SAVE_FILE_LINE
		node_record = new APP_NODE_RECORD;
		if (NULL == node_record)
		{
			goto MyExit;
		}

		if(!m_NodeRecordList2.Append(sender_id, node_record))
		{
		    goto MyExit;
		}

		for (pCurr = record_refresh; NULL != pCurr; pCurr = pCurr->next)
		{
			node_id = pCurr->value.node_id;
			entity_id = pCurr->value.entity_id;

			if (sender_id != node_id)
			{
				//	Get or create the sub node record list	
				if (NULL == (record_list = node_record->SubNodeList2.Find(node_id)))
				{
					DBG_SAVE_FILE_LINE
					record_list = new CAppRecordList2(DESIRED_MAX_APP_RECORDS);
					if (NULL == record_list)
					{
						goto MyExit;
					}
					node_record->SubNodeList2.Append(node_id, record_list);
				}
			}
			else
			{
				/*
				**	Here we set up the pointer to the record list.  This
				**	list is the node records application list which
				**	means that this list contains the application records
				**	associated with the sender's node.
				*/
				record_list = &node_record->AppRecordList;
			}

			//	Now	create and fill in the new application record.
			DBG_SAVE_FILE_LINE
			app_record = new APP_RECORD;
			if (NULL == app_record)
			{
				goto MyExit;
			}

			rc = ProcessApplicationRecordPDU(app_record, &pCurr->value.application_record);
			if (GCC_NO_ERROR != rc)
			{
				goto MyExit;
			}

			record_list->Append(entity_id, app_record);
		} // for
	}
	else
	{
		//	This roster no longer contains any entries so clear the list!!!
		ClearNodeRecordList ();
	}

	/*
	**	Build a full refresh PDU here if no errors occured while processing
	**	the refresh PDU.									
	*/
	rc = BuildApplicationRecordListPDU (APP_FULL_REFRESH, 0, 0);

MyExit:

        if(rc ==GCC_ALLOCATION_FAILURE)
        {
            if(node_record)
            {
                delete node_record;
            }
        }
	return rc;
}


/*
 *	GCCError	ProcessSetOfUpdatesPDU	()
 *
 *	Private Function Description
 *		This routine processes a set of roster updates.  It iterates through
 *		the complete list of updates making all necessary changes to the
 *		internal information base and building the appropriate PDU.
 *
 *	Formal Parameters
 *		record_update -	(i) set of updates PDU to be processed
 *		sender_id -		(i)	gcc user id of node that sent the update
 *
 *	Return Value
 *		APP_ROSTER_NO_ERROR - On Success
 *		APP_ROSTER_RESOURCE_ERROR - On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveate
 *		none
 */
GCCError CAppRoster::ProcessSetOfUpdatesPDU(
					  		PSetOfApplicationRecordUpdates		record_update,
					  		UserID								sender_id)
{
	GCCError							rc = GCC_ALLOCATION_FAILURE;
	PSetOfApplicationRecordUpdates		pCurr;
	UserID								node_id;
	EntityID							entity_id;
	PApplicationRecord					pdu_record;
	APP_RECORD  					    *application_record = NULL;
	APP_NODE_RECORD						*node_record;
	CAppRecordList2						*record_list;
	APP_ROSTER_UPDATE_TYPE				update_type;

	DebugEntry(CAppRoster::ProcessSetOfUpdatesPDU);

	if (record_update != NULL)
	{
		for (pCurr = record_update; NULL != pCurr; pCurr = pCurr->next)
		{
			node_id = pCurr->value.node_id;
			entity_id = pCurr->value.entity_id;

			switch(pCurr->value.application_update.choice)
			{
			case APPLICATION_ADD_RECORD_CHOSEN:
				pdu_record = &(pCurr->value.application_update.u.application_add_record);
				update_type = APP_ADD_RECORD;
				break;
			case APPLICATION_REPLACE_RECORD_CHOSEN:
				DeleteRecord (node_id, entity_id, FALSE);
				pdu_record = &(pCurr->value.application_update.u.application_replace_record);
				update_type = APP_REPLACE_RECORD;
				break;
			default: //	Remove record
				/*
				**	Inform the owner that a record was delete while processing
				**	this PDU so that it can perform any necessary cleanup.
				*/
				m_pAppRosterMgr->DeleteRosterRecord(node_id, entity_id);

				DeleteRecord (node_id, entity_id, TRUE);
				pdu_record = NULL;
				update_type = APP_DELETE_RECORD;
				break;
			}

			/*
			**	First get the roster record and if one does not exist for this
			**	app record create it. After that we will create the application
			**	record and put it into the correct slot in the application
			**	roster record.
			*/
			if (pdu_record != NULL)
			{
				/*
				**	First find the correct node record and if it does not
				**	exist create it.
				*/
				if (NULL == (node_record = m_NodeRecordList2.Find(sender_id)))
				{
					DBG_SAVE_FILE_LINE
					node_record = new APP_NODE_RECORD;
					if (NULL == node_record)
					{
						goto MyExit;
					}

					m_NodeRecordList2.Append(sender_id, node_record);
				}

				/*
				**	If the user and sender id is the same then the record
				**	will be contained in the app_record_list. Otherwise, it
				**	will be maintained in the sub-node list.
				*/

				/*
				**	If the sender_id equals the node id being processed
				**	use the application record list instead of the sub
				**	node list.
				*/
				if (sender_id != node_id)
				{
					/*	
					**	Find the correct node list and create it if it does
					**	not exists. This list holds lists of all the
					**	application	peer entities at a node.
					*/
					if (NULL == (record_list = node_record->SubNodeList2.Find(node_id)))
					{
						DBG_SAVE_FILE_LINE
						record_list = new CAppRecordList2(DESIRED_MAX_APP_RECORDS);
						if (NULL == record_list)
						{
							goto MyExit;
						}

						node_record->SubNodeList2.Append(node_id, record_list);
					}
				}
				else
				{
					record_list = &node_record->AppRecordList;
				}

				//	Now fill in the application record
				DBG_SAVE_FILE_LINE
				application_record = new APP_RECORD;
				if (NULL == application_record)
				{
					goto MyExit;
				}

				record_list->Append(entity_id, application_record);
				rc = ProcessApplicationRecordPDU(application_record, pdu_record);
				if (GCC_NO_ERROR != rc)
				{
					goto MyExit;
				}
			} // if
			
			/*
			**	Here we add this update to our PDU and jump to the next update
			**	in the PDU currently being processed.
			*/
			rc = BuildApplicationRecordListPDU (	update_type,
															node_id,
															entity_id);
			if (rc != GCC_NO_ERROR)
			{
				goto MyExit;
			}

			/*
			**	If the capabilities changed during the above processing
			**	we must	create a new collapsed capabilities list and
			**	build a new capability refresh PDU.
			*/
			if (m_fCapabilitiesHaveChanged)
			{
				MakeCollapsedCapabilitiesList();
				rc = BuildSetOfCapabilityRefreshesPDU ();
				if (rc != GCC_NO_ERROR)
				{
					goto MyExit;
				}
			}
		} // for
	} // if

	rc = GCC_NO_ERROR;

MyExit:

	return rc;
}


/*
 *	GCCError	ProcessApplicationRecordPDU ()
 *
 *	Private Function Description
 *		This routine is responsible for decoding the Application Record
 *		portion of the roster update pdu.
 *
 *	Formal Parameters
 *		application_record -	This is the internal destination app record.
 *		pdu_record - 			Source PDU data
 *
 *	Return Value
 *		GCC_NO_ERROR - On Success
 *		GCC_ALLOCATION_FAILURE - On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::ProcessApplicationRecordPDU (
									APP_RECORD  	        *application_record,
									PApplicationRecord		pdu_record)
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CAppRoster::ProcessApplicationRecordPDU);

	application_record->is_enrolled_actively = pdu_record->application_is_active;
	application_record->is_conducting_capable = pdu_record->is_conducting_capable;

	if (pdu_record->bit_mask & RECORD_STARTUP_CHANNEL_PRESENT)
	{
		application_record->startup_channel_type =
						(MCSChannelType)pdu_record->record_startup_channel;
	}
	else
		application_record->startup_channel_type= MCS_NO_CHANNEL_TYPE_SPECIFIED;

	if (pdu_record->bit_mask & APPLICATION_USER_ID_PRESENT)
	{
		application_record->application_user_id =
												pdu_record->application_user_id;
	}
	else
		application_record->application_user_id = 0;

	if (pdu_record->bit_mask & NON_COLLAPSING_CAPABILITIES_PRESENT)
	{
		rc = ProcessNonCollapsingCapabilitiesPDU (
								&application_record->non_collapsed_caps_list,
								pdu_record->non_collapsing_capabilities);
	}

	return rc;
}


/*
 *	GCCError	ProcessSetOfCapabilityRefreshesPDU	()
 *
 *	Private Function Description
 *		This routine is responsible for decoding the capabilities portion
 *		of an roster update PDU.
 *
 *	Formal Parameters
 *		capability_refresh -	(i) set of capabilities PDU to be processed
 *		sender_id -				(i)	gcc user id of node that sent the update
 *
 *	Return Value
 *		GCC_NO_ERROR 			- On Success
 *		GCC_ALLOCATION_FAILURE 	- On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		This routine does handle NULL for the capability refresh which means
 *		that the capabilities delivered no longer exists.
 */
GCCError CAppRoster::ProcessSetOfCapabilityRefreshesPDU(
						PSetOfApplicationCapabilityRefreshes	capability_refresh,
                   		UserID									sender_id)
{
	GCCError								rc = GCC_NO_ERROR;
	PSetOfApplicationCapabilityRefreshes	pCurr;
	CAppCapItemList							*pAppCapList;
	APP_CAP_ITEM							*pAppCapItem;
	APP_NODE_RECORD							*node_record;

	DebugEntry(CAppRoster::ProcessSetOfCapabilityRefreshesPDU);

	if (NULL == (node_record = m_NodeRecordList2.Find(sender_id)))
	{
		DBG_SAVE_FILE_LINE
		node_record = new APP_NODE_RECORD;
		if (NULL == node_record)
		{
			return GCC_ALLOCATION_FAILURE;
		}

		if(!m_NodeRecordList2.Append(sender_id, node_record))
		{
		    delete node_record;
                  return GCC_ALLOCATION_FAILURE;
		}
	}

	// get collapsed cap list ptr
	pAppCapList = &node_record->CollapsedCapList;

	//	Clear out all the old capabilities from this list.
	pAppCapList->DeleteList();

	//	Begin processing the PDU.
	for (pCurr = capability_refresh; NULL != pCurr; pCurr = pCurr->next)
	{
		ASSERT(GCC_NO_ERROR == rc);

		//	Create and fill in the new capability.
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType) pCurr->value.capability_class.choice);
		if (NULL == pAppCapItem)
		{
			return GCC_ALLOCATION_FAILURE;
		}

		//	Create the capability ID
		DBG_SAVE_FILE_LINE
		pAppCapItem->pCapID = new CCapIDContainer(&pCurr->value.capability_id, &rc);
		if (NULL == pAppCapItem->pCapID)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		if (GCC_NO_ERROR != rc)
		{
			delete pAppCapItem;
			return rc;
		}

		// append this cap to the collapsed cap list
		pAppCapList->Append(pAppCapItem);

		/*	
		**	Note that a logical type's value is maintained as
		**	number of entities.
		*/
		if (pCurr->value.capability_class.choice == UNSIGNED_MINIMUM_CHOSEN)
		{
			pAppCapItem->nUnsignedMinimum = pCurr->value.capability_class.u.unsigned_minimum;
		}
		else
		if (pCurr->value.capability_class.choice == UNSIGNED_MAXIMUM_CHOSEN)
		{
			pAppCapItem->nUnsignedMaximum = pCurr->value.capability_class.u.unsigned_maximum;
		}

		pAppCapItem->cEntries = pCurr->value.number_of_entities;
	} // for

	//	This forces a new capabilities list to be calculated.
	MakeCollapsedCapabilitiesList();

	/*
	**	Here we build the new PDU data associated with this refresh of the
	**	capability list.
	*/
	return BuildSetOfCapabilityRefreshesPDU();
}


/*
 *	GCCError	ProcessNonCollapsingCapabilitiesPDU	()
 *
 *	Private Function Description
 *		This routine is responsible for decoding the non-collapsing capabilities
 *		portion of a roster record PDU.
 *
 *	Formal Parameters
 *		non_collapsed_caps_list -	(o) Pointer to list to fill in with new
 *										non-collapsed caps.
 *		pSetOfCaps -		(i)	non-collapsed PDU data
 *
 *	Return Value
 *		GCC_NO_ERROR 			- On Success
 *		GCC_ALLOCATION_FAILURE 	- On resource failure
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::ProcessNonCollapsingCapabilitiesPDU (
					CAppCapItemList						*non_collapsed_caps_list,
					PSetOfNonCollapsingCapabilities		pSetOfCaps)
{
	GCCError						rc = GCC_NO_ERROR;
	PSetOfNonCollapsingCapabilities	pCurr;
	APP_CAP_ITEM					*pAppCapItem;

	DebugEntry(CAppRoster::ProcessNonCollapsingCapsPDU);

	for (pCurr = pSetOfCaps; NULL != pCurr; pCurr = pCurr->next)
	{
	    //
		// LONCHANC: The following cap data does not have a type???
		// for now, set it to zero.
		//
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType)0);
		if (NULL == pAppCapItem)
		{
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

		DBG_SAVE_FILE_LINE
		pAppCapItem->pCapID = new CCapIDContainer(&pCurr->value.capability_id, &rc);
		if (NULL == pAppCapItem->pCapID)
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		if (rc != GCC_NO_ERROR)
		{
			goto MyExit;
		}

		if (pCurr->value.bit_mask & APPLICATION_DATA_PRESENT)
		{
			if (NULL == (pAppCapItem->poszAppData = ::My_strdupO2(
									pCurr->value.application_data.value,
									pCurr->value.application_data.length)))
			{
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
		}

		if( !non_collapsed_caps_list->Append(pAppCapItem) )
        {
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
        }
	} // for

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        if( NULL != pAppCapItem )
           delete pAppCapItem;
    }

	return rc;
}


/*
 * Utilities that operate on conference records.
 */

/*
 *	UINT	LockApplicationRoster	()
 *
 *	Public Function Description
 *		This routine is used to lock a GCCApplicationRoster and to determine the
 *		amount of memory necessary to hold the data referenced by the "API"
 *		application roster structure.  The GCCApplicationRoster is used in
 *		indications to applications at the local node.
 */
UINT CAppRoster::LockApplicationRoster(void)
{
	UINT						number_of_records = 0;
	UINT						number_of_capabilities = 0;
	APP_NODE_RECORD				*lpAppNodeRecord;
	APP_RECORD  			    *lpAppRecData;
	APP_CAP_ITEM				*lpAppCapData;
	CAppRecordList2				*lpAppRecDataList;

	DebugEntry(CAppRoster::LockApplicationRoster);

	/*
	 * If this is the first time this routine is called, determine the size of
	 * the memory required to hold the data referenced by the application
	 * roster structure.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Lock the data for the session key held within the roster.  This lock
		 * call returns the size of the memory required to hold the session key
		 * data, rounded to an even multiple of four-bytes.
		 */
		m_cbDataMemory = m_pSessionKey->LockSessionKeyData();

		/*
	     * First calculate the total number of records. This count is used to
		 * determine the space necessary to hold the records. Note that we must
		 * count both the application record list and the sub-node list.
	     */
		m_NodeRecordList2.Reset();
	 	while (NULL != (lpAppNodeRecord = m_NodeRecordList2.Iterate()))
		{
			/*
			 * Add the application records at this node to the count.
			 */
			number_of_records += lpAppNodeRecord->AppRecordList.GetCount();
		
			/*
			 * Next count the sub node records.
			 */
			if (! lpAppNodeRecord->SubNodeList2.IsEmpty())
			{
				lpAppNodeRecord->SubNodeList2.Reset();
				while (NULL != (lpAppRecDataList = lpAppNodeRecord->SubNodeList2.Iterate()))
				{
					number_of_records += lpAppRecDataList->GetCount();
				}
			}
		}

		/*
		 * Now determine the amount of memory necessary to hold all of the
		 * pointers to the application records as well as the actual
		 * GCCApplicationRecord structures.
		 */
		m_cbDataMemory += number_of_records *
				(sizeof(PGCCApplicationRecord) +
				ROUNDTOBOUNDARY( sizeof(GCCApplicationRecord)) );
		
		m_NodeRecordList2.Reset();
	   	while (NULL != (lpAppNodeRecord = m_NodeRecordList2.Iterate()))
		{
			/*
			 * Iterate through this node's record list, determining the amount
			 * of memory necessary to hold the pointers to the non-collapsing
			 * capabilities as well as the capability ID data and octet string
			 * data associated with each non-collapsing capability.
			 */
			lpAppNodeRecord->AppRecordList.Reset();
			while (NULL != (lpAppRecData = lpAppNodeRecord->AppRecordList.Iterate()))
			{
				/*
				 * Set up an iterator for the list of non-collapsing
				 * capabilities held within each application roster.
				 */
				lpAppRecData->non_collapsed_caps_list.Reset();
				number_of_capabilities += lpAppRecData->non_collapsed_caps_list.GetCount();

				while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
				{
					/*
					 * Lock the data for each capability ID.  The lock call
					 * returns the length of the data referenced by each
					 * capability ID rounded to occupy an even multiple of
					 * four-bytes.
					 */
					m_cbDataMemory += lpAppCapData->pCapID->LockCapabilityIdentifierData();

					/*
					 * Add up the space required to hold the application data
					 * octet strings if they are present.  Make sure there is
					 * enough space for each octet string to occupy an even
					 * multiple of four bytes.  Add room to hold the actual
					 * octet string structure also since the capability
					 * structure only contains a pointer to a OSTR.
					 */
					if (lpAppCapData->poszAppData != NULL)
					{
						m_cbDataMemory += ROUNDTOBOUNDARY(sizeof(OSTR));
						m_cbDataMemory += ROUNDTOBOUNDARY(lpAppCapData->poszAppData->length);
					}
				}
			}

			/*
			 * Iterate through this node's sub-node record list, determining the
			 * amount of memory necessary to hold the pointers to the
			 * non-collapsing capabilities as well as the capability ID data and
			 * octet string	data associated with each non-collapsing capability.
			 */
			lpAppNodeRecord->SubNodeList2.Reset();
			while (NULL != (lpAppRecDataList = lpAppNodeRecord->SubNodeList2.Iterate()))
			{
				lpAppRecDataList->Reset();
				while (NULL != (lpAppRecData = lpAppRecDataList->Iterate()))
				{
					/*
					 * Set up an iterator for the list of non-collapsing
					 * capabilities held within each application roster.
					 */
					number_of_capabilities += lpAppRecData->non_collapsed_caps_list.GetCount();

					lpAppRecData->non_collapsed_caps_list.Reset();
					while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
					{
						/*
						 * Lock the data for each capability ID.  The lock call
						 * returns the length of the data referenced by each
						 * capability ID fixed up to occupy an even multiple of
						 * four-bytes.
						 */
						m_cbDataMemory += lpAppCapData->pCapID->LockCapabilityIdentifierData();
					
						/*
						 * Add up the space required to hold the application
						 * data octet strings if they are present.  Make sure
						 * there is	enough space for each octet string to occupy
						 * an even multiple of four bytes.  Add room to hold the
						 * actual octet string structure also since the
						 * capability structure only contains a pointer to a OSTR
						 */
						if (lpAppCapData->poszAppData != NULL)
						{
							m_cbDataMemory += ROUNDTOBOUNDARY(sizeof(OSTR));
							m_cbDataMemory += ROUNDTOBOUNDARY(lpAppCapData->poszAppData->length);
						}
					}
				}
			}
		}

		/*
		 * Determine the amount of memory necessary to hold all of the pointers
		 * to the non-collapsing capabilities as well as the actual
		 * GCCNonCollapsingCapability structures.
		 */
		m_cbDataMemory += number_of_capabilities *
				(sizeof (PGCCNonCollapsingCapability) +
				ROUNDTOBOUNDARY( sizeof(GCCNonCollapsingCapability)) );

		/*
		 * Add the amount of memory necessary to hold the string data associated
		 * with each capability ID.
		 */
		m_CollapsedCapListForAllNodes.Reset();
		while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
		{
			m_cbDataMemory += lpAppCapData->pCapID->LockCapabilityIdentifierData();
		}

		/*
		 * Add the memory to hold the application capability pointers
		 * and structures.
		 */
		number_of_capabilities = m_CollapsedCapListForAllNodes.GetCount();

		m_cbDataMemory += number_of_capabilities *
				(sizeof (PGCCApplicationCapability) +
				ROUNDTOBOUNDARY( sizeof(GCCApplicationCapability)) );
	}

	return m_cbDataMemory;
}


/*
 *	UINT	GetAppRoster()
 *
 *	Public Function Description
 *		This routine is used to obtain a pointer to the GCCApplicatonRoster.
 *		This routine should not be called before LockApplicationRoster is
 *		called. LockApplicationRoster will create the GCCApplicationRoster in
 *		the memory provided.  The GCCApplicationRoster is what is delivered to
 * 		the end user Application SAP.
 */
UINT CAppRoster::GetAppRoster(
						PGCCApplicationRoster		pGccAppRoster,
						LPBYTE						pData)
{
	UINT rc;

	DebugEntry(CAppRoster::GetAppRoster);

	if (GetLockCount() > 0)
	{
        UINT data_length;

	    /*
	     * Fill in the output length parameter which indicates how much data
	     * referenced outside the structure will be written.
	     */
        rc = m_cbDataMemory;

        /*
		 * Get the data associated with the roster's session key and save
		 * the length of the data written into memory.
		 */
		data_length = m_pSessionKey->GetGCCSessionKeyData(&pGccAppRoster->session_key, pData);

		/*
		 * Move the memory pointer past the data associated with the
		 * session key.
		 */
		pData += data_length;

		/*
		 * Fill in other roster structure elements.
		 */
		pGccAppRoster->application_roster_was_changed = m_fRosterHasChanged;
		pGccAppRoster->instance_number = (USHORT) m_nInstance;
		pGccAppRoster->nodes_were_added = m_fPeerEntitiesAdded;
		pGccAppRoster->nodes_were_removed = m_fPeerEntitiesRemoved;
		pGccAppRoster->capabilities_were_changed = m_fCapabilitiesHaveChanged;

		/*
		 * Fill in the full set of application roster records.
		 */
		data_length = GetApplicationRecords(pGccAppRoster,	pData);

		/*
		 * Move the memory pointer past the application records and their
		 * associated data.  Get the full set of application capabilities.
		 */
		pData += data_length;

		data_length = GetCapabilitiesList(pGccAppRoster, pData);
	}
	else
	{
		ERROR_OUT(("CAppRoster::GetAppRoster: Error data not locked"));
        rc = 0;
	}

	return rc;
}


/*
 *	void	UnLockApplicationRoster	()
 *
 *	Public Function Description
 *		This member function is responsible for unlocking the data locked for
 *		the "API" application roster after the lock count goes to zero.
 */
void CAppRoster::UnLockApplicationRoster()
{
	DebugEntry(CAppRoster::UnLockApplicationRoster);

    if (Unlock(FALSE) == 0)
	{
        // reset the size
        m_cbDataMemory = 0;

        // free up all the memory locked for "API" data.
	    APP_NODE_RECORD				*lpAppNodeRecord;
	    APP_RECORD  			    *lpAppRecData;
	    APP_CAP_ITEM				*lpAppCapData;
	    CAppRecordList2				*lpAppRecDataList;

        // unlock session key data
        m_pSessionKey->UnLockSessionKeyData();

        // iterate through all the node records
	    m_NodeRecordList2.Reset();
	    while (NULL != (lpAppNodeRecord = m_NodeRecordList2.Iterate()))
	    {
		    // iterate through this node's record list
		    lpAppNodeRecord->AppRecordList.Reset();
		    while (NULL != (lpAppRecData = lpAppNodeRecord->AppRecordList.Iterate()))
		    {
			    // set up an iterator for the list of non-collapsing
			    // capabilities held within each application roster.
			    lpAppRecData->non_collapsed_caps_list.Reset();
			    while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
			    {
				    lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
			    }
		    }

		    // iterate through this node's sub-node record list
		    lpAppNodeRecord->SubNodeList2.Reset();
		    while (NULL != (lpAppRecDataList = lpAppNodeRecord->SubNodeList2.Iterate()))
		    {
			    lpAppRecDataList->Reset();
			    while (NULL != (lpAppRecData = lpAppRecDataList->Iterate()))
			    {
				    // set up an iterator for the list of non-collapsing
				    // capabilities held within each application roster.
				    lpAppRecData->non_collapsed_caps_list.Reset();
				    while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
				    {
					    lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
				    }
			    }
		    }
	    }

        // iterate through collapsed caps
	    m_CollapsedCapListForAllNodes.Reset();
	    while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
	    {
		    lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
	    }
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}


/*
 *	UINT	GetApplicationRecords	()
 *
 *	Private Function Description
 *		This routine inserts the complete set of application roster records
 *		into the passed in application roster structure.
 *
 *	Formal Parameters
 *		gcc_roster 	-	(o) GCCApplicationRoster to be filled in.
 *		memory		-	(o) Location in memory to begin writing records.
 *
 *	Return Value
 *		The total amount of data written into memory.
 *
 *	Side Effects
 *		The memory pointer passed in will be advanced by the amount of memory
 *		necessary to hold the application records and their data.
 *
 *	Caveats
 *		none
 */
UINT CAppRoster::GetApplicationRecords(
						PGCCApplicationRoster		gcc_roster,
						LPBYTE						memory)
{
	UINT							data_length = 0;
	UINT							record_count = 0;
	PGCCApplicationRecord			gcc_record;
	UINT							capability_data_length;
	APP_NODE_RECORD					*lpAppNodeRec;
	CAppRecordList2					*lpAppRecDataList;
	APP_RECORD  				    *lpAppRecData;
    UserID                          uid, uid2;
	EntityID						eid;

	DebugEntry(CAppRoster::GetApplicationRecords);

	/*
	 * Initialize the number of records in the roster to zero.
	 */
	gcc_roster->number_of_records = 0;

	/*
     * First calculate the total number of records. This count is used to
	 * allocate the space necessary to hold the record pointers. Note that we
	 * must count both the application record list and the sub-node list.
     */
	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate()))
	{
		/*
		 * Add the number of application records at this node to the count.
		 */
		gcc_roster->number_of_records += (USHORT) (lpAppNodeRec->AppRecordList.GetCount());

		/*
		 * Next add the number of sub node entries.
		 */
		if (! lpAppNodeRec->SubNodeList2.IsEmpty())
		{
			lpAppNodeRec->SubNodeList2.Reset();
			while (NULL != (lpAppRecDataList = lpAppNodeRec->SubNodeList2.Iterate()))
			{
				gcc_roster->number_of_records += (USHORT) (lpAppRecDataList->GetCount());
			}
		}
	}

	if (gcc_roster->number_of_records != 0)
	{
		/*
		 * Fill in the roster's pointer to the list of application record
		 * pointers.  The pointer list will begin at the memory location passed
		 * into this routine.
		 */
		gcc_roster->application_record_list = (PGCCApplicationRecord *)memory;

		/*
		 * Move the memory pointer past the list of record pointers.  This is
		 * where the first application record will be written.
		 */
		memory += gcc_roster->number_of_records * sizeof(PGCCApplicationRecord);

		/*
		 * Add to the data length the amount of memory necessary to hold the
		 * application record pointers.  Go ahead and add the amount of memory
		 * necessary to hold all of the GCCApplicationRecord structures.
		 */
		data_length += gcc_roster->number_of_records *
				            (sizeof(PGCCApplicationRecord) +
                             ROUNDTOBOUNDARY(sizeof(GCCApplicationRecord)));
		
		record_count = 0;
		m_NodeRecordList2.Reset();
	   	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate(&uid)))
		{
			/*
			 * Iterate through this node's record list, building an "API"
			 * application record for each record in the list.
			 */
			lpAppNodeRec->AppRecordList.Reset();
			while (NULL != (lpAppRecData = lpAppNodeRec->AppRecordList.Iterate(&eid)))
			{
				/*
				 * Set the application record pointer equal to the location in
				 * memory where it will be written.
				 */
				gcc_record = (PGCCApplicationRecord)memory;

				/*
				 * Save the pointer to the application record in the roster's
				 * list of record pointers.
				 */
				gcc_roster->application_record_list[record_count] = gcc_record;

				/*
				 * Get the GCC node ID from the node iterator.
				 */
				gcc_record->node_id = uid;

				/*
				 * Get the Entity ID from the record iterator.
				 */
				gcc_record->entity_id = eid;

				/*
				 * Fill in other application record elements.
				 */
				gcc_record->is_enrolled_actively = lpAppRecData->is_enrolled_actively;
				gcc_record->is_conducting_capable =	lpAppRecData->is_conducting_capable;
				gcc_record->startup_channel_type = lpAppRecData->startup_channel_type;
				gcc_record->application_user_id = lpAppRecData->application_user_id;

				/*
				 * Advance the memory pointer past the application record
				 * structure.  This is where the list of non-collapsing
				 * capabilities pointers will begin.  Round the memory location
				 * off to fall on an even four-byte boundary.
				 */
				memory += ROUNDTOBOUNDARY(sizeof(GCCApplicationRecord));

				/*
				 * Fill in the non-collapsing capabilities for this application
				 * record.
				 */
				capability_data_length = GetNonCollapsedCapabilitiesList(
											gcc_record,
											&lpAppRecData->non_collapsed_caps_list,
											memory);

				/*
				 * Add the amount of memory necessary to hold the list of
				 * capabilities and associated data to the overall length and
				 * move the memory pointer past the capabilities data.
				 */
				memory += capability_data_length;
				data_length += capability_data_length;

				/*
				 * Increment the record list array counter.
				 */
				record_count++;
			}
			
			/*
			 * Iterate through this node's sub-node record list, building an
			 * "API" application record for each record in the list.
			 */
			lpAppNodeRec->SubNodeList2.Reset();
			while (NULL != (lpAppRecDataList = lpAppNodeRec->SubNodeList2.Iterate(&uid2)))
			{
				/*
				 * Iterate through this node's record list.
				 */
				lpAppRecDataList->Reset();
				while (NULL != (lpAppRecData = lpAppRecDataList->Iterate(&eid)))
				{
					/*
					 * Set the application record pointer equal to the location
					 * in memory where it will be written.
					 */
					gcc_record = (PGCCApplicationRecord)memory;

					/*
					 * Save the pointer to the application record in the
					 * roster's list of record pointers.
					 */
					gcc_roster->application_record_list[record_count] = gcc_record;

					/*
					 * Get the node ID from the sub_node_iterator.
					 */
					gcc_record->node_id = uid2;

					/*
					 * Get the entity ID from the record_iterator.
					 */
					gcc_record->entity_id = eid;

					/*
					 * Fill in other application record elements.
					 */
					gcc_record->is_enrolled_actively = lpAppRecData->is_enrolled_actively;
					gcc_record->is_conducting_capable = lpAppRecData->is_conducting_capable;
					gcc_record->startup_channel_type = lpAppRecData->startup_channel_type;
					gcc_record->application_user_id = lpAppRecData->application_user_id;

					/*
					 * Advance the memory pointer past the application record
					 * structure.  This is where the list of non-collapsing
					 * capabilities pointers will begin.  Round the memory
					 * location	off to fall on an even four-byte boundary.
					 */
					memory += ROUNDTOBOUNDARY(sizeof(GCCApplicationRecord));

					/*
					 * Fill in the non-collapsing capabilities for this
					 * application record.  The memory pointer will be advanced
					 * past the capabilities list and data.
					 */
					capability_data_length = GetNonCollapsedCapabilitiesList(
													gcc_record,
													&lpAppRecData->non_collapsed_caps_list,
													memory);

					/*
					 * Add the amount of memory necessary to hold the list of
					 * capabilities and associated data to the overall length.
					 */
					memory += capability_data_length;
					data_length += capability_data_length;

					/*
					 * Increment the record list array counter.
					 */
					record_count++;
				}
			}
		}
	}
	else
	{
		/*
		 * There were no application records so set the pointer to the list
		 * of records to NULL and the data_length return value to zero.
		 */
		gcc_roster->application_record_list = NULL;
		data_length = 0;
	}

	return (data_length);
}


/*
 *	UINT	GetCapabilitiesList	()
 *
 *	Private Function Description
 *		This routine fills in the capabilities portion of the
 *		GCCAppicationRoster structure.
 *
 *	Formal Parameters
 *		gcc_roster -	(o) GCCApplicationRoster to be filled in
 *		memory		-	(o) Location in memory to begin writing records.
 *
 *	Return Value
 *		The total amount of data written into memory.
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
UINT CAppRoster::GetCapabilitiesList(
						PGCCApplicationRoster	gcc_roster,
						LPBYTE					memory)
{
	UINT								data_length = 0;
	UINT								capability_id_data_length = 0;
	UINT								capability_count;
	PGCCApplicationCapability			gcc_capability;
	APP_CAP_ITEM						*lpAppCapData;

	DebugEntry(CAppRoster::GetCapabilitiesList);

	/*
	 * Retrieve the number of capabilities for this roster and fill in any that
	 * are present.
	 */
	gcc_roster->number_of_capabilities = (USHORT) m_CollapsedCapListForAllNodes.GetCount();

	if (gcc_roster->number_of_capabilities != 0)
	{
		/*
		 * Fill in the roster's pointer to the list of application capability
		 * pointers.  The pointer list will begin at the memory location passed
		 * into this routine.
		 */
		gcc_roster->capabilities_list = (PGCCApplicationCapability *)memory;

		/*
		 * Move the memory pointer past the list of capability pointers.  This
		 * is where the first application capability structure will be written.
		 */
		memory += (Int)(gcc_roster->number_of_capabilities *
				sizeof(PGCCApplicationCapability));

		/*
		 * Add to the data length the amount of memory necessary to hold the
		 * application capability pointers.  Go ahead and add the amount of
		 * memory necessary to hold all of the GCCApplicationCapability
		 * structures.
		 */
		data_length += gcc_roster->number_of_capabilities *
				(sizeof(PGCCApplicationCapability) +
				ROUNDTOBOUNDARY ( sizeof(GCCApplicationCapability)) );

		capability_count = 0;
		m_CollapsedCapListForAllNodes.Reset();
	   	while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
		{
			/*
			 * Set the application capability pointer equal to the
			 * location in memory where it will be written.
			 */
			gcc_capability = (PGCCApplicationCapability)memory;
				
			/*
			 * Save the pointer to the application capability in the roster's
			 * list of application capability pointers.
			 */
			gcc_roster->capabilities_list[capability_count] =
													gcc_capability;
			
			/*
			 * Advance the memory pointer past the application capability
			 * structure.  This is where the string data for the capability ID
			 * will be written.  Ensure that the memory pointer falls on an
			 * even four-byte boundary.
			 */
			memory += (Int)(ROUNDTOBOUNDARY(sizeof(GCCApplicationCapability)));

			/*
			 * Retrieve the capability ID information from the internal
			 * CapabilityIDData object.  The length returned by this call will
			 * have already been rounded to an even multiple of four bytes.
			 */
			capability_id_data_length = lpAppCapData->pCapID->GetGCCCapabilityIDData(
												&gcc_capability->capability_id,
												memory);

			/*
			 * Advance the memory pointer past the string data written into
			 * memory by the capability ID object.  Add the length of the string
			 * data to the overall capability length.
			 */
			memory += (Int)capability_id_data_length;
			data_length += capability_id_data_length;

			/*
			 * Now fill in the rest of the capability.
			 */
			gcc_capability->capability_class.eType =lpAppCapData->eCapType;

			if (gcc_capability->capability_class.eType ==
									GCC_UNSIGNED_MINIMUM_CAPABILITY)
			{
				gcc_capability->capability_class.nMinOrMax = lpAppCapData->nUnsignedMinimum;
			}
			else if (gcc_capability->capability_class.eType == GCC_UNSIGNED_MAXIMUM_CAPABILITY)
			{
				gcc_capability->capability_class.nMinOrMax = lpAppCapData->nUnsignedMaximum;
			}

			gcc_capability->number_of_entities = lpAppCapData->cEntries;

			/*
			 * Increment the capability ID array counter.
			 */
			capability_count++;
		}
	}
	else
	{
		gcc_roster->capabilities_list = NULL;
	}

	return (data_length);
}


/*
 *	UINT	GetNonCollapsedCapabilitiesList	()
 *
 *	Private Function Description:
 *		This routine is used to fill in the "API" non-collapsing capabilities
 * 		portion of a GCCApplicationRoster from the data which is stored
 *		internally by this class.
 *
 *	Formal Parameters
 *		gcc_record	-		(o)		The application record to be filled in.
 *		pAppCapItemList 	(i)		The internal capabilities data.
 *		memory				(i/o)	The memory location to begin writing data.
 *
 *	Return Value
 *		The total amount of data written into memory.
 *
 *	Side Effects
 *		The memory pointer passed in will be advanced by the amount of memory
 *		necessary to hold the capabilities and their data.
 *
 *	Caveats
 *		none
 */
UINT CAppRoster::GetNonCollapsedCapabilitiesList(
					PGCCApplicationRecord				gcc_record,
					CAppCapItemList    					*pAppCapItemList,
					LPBYTE								memory)
{
	UINT								capability_count;
	PGCCNonCollapsingCapability			gcc_capability;
	APP_CAP_ITEM						*lpAppCapData;
	UINT								capability_id_length = 0;
	UINT								capability_data_length = 0;

	DebugEntry(CAppRoster::GetNonCollapsedCapabilitiesList);

	/*
	 * Get the number of non-collapsed capabilities.
	 */
	gcc_record->number_of_non_collapsed_caps = (USHORT) pAppCapItemList->GetCount();

	if (gcc_record->number_of_non_collapsed_caps != 0)
	{
		/*
		 * Fill in the record's pointer to the list of non-collapsing
		 * capabilities	pointers.  The pointer list will begin at the memory
		 * location passed into this routine.
		 */
		gcc_record->non_collapsed_caps_list = (PGCCNonCollapsingCapability *)memory;

		/*
		 * Move the memory pointer past the list of capability pointers.  This
		 * is where the first capability structure will be written.
		 */
		memory += (Int)(gcc_record->number_of_non_collapsed_caps *
				sizeof(PGCCNonCollapsingCapability));

		/*
		 * Add to the data length the amount of memory necessary to hold the
		 * capability pointers.  Go ahead and add the amount of memory necessary
		 * to hold all of the GCCNonCollapsingCapability structures.
		 */
		capability_data_length = gcc_record->number_of_non_collapsed_caps *
				(sizeof(PGCCNonCollapsingCapability) +
				ROUNDTOBOUNDARY(sizeof (GCCNonCollapsingCapability)));

		/*
		 * Iterate through this record's capabilities list, building an "API"
		 * non-collapsing capability for each capability in the list.
		 */
		capability_count = 0;
		pAppCapItemList->Reset();
		while (NULL != (lpAppCapData = pAppCapItemList->Iterate()))
		{
			/*
			 * Set the capability pointer equal to the location in memory where
			 * it will be written.
			 */
			gcc_capability = (PGCCNonCollapsingCapability)memory;

			/*
			 * Save the pointer to the capability in the record's list of
			 * capability pointers.
			 */
			gcc_record->non_collapsed_caps_list[capability_count] = gcc_capability;

			/*
			 * Move the memory pointer past the capability ID structure.  This
			 * is where the data associated with the structure will be written.
			 * Retrieve the capability ID data from the internal object, saving
			 * it in the "API" capability ID structure.
			 */
			memory += (Int)ROUNDTOBOUNDARY(sizeof(GCCNonCollapsingCapability));

			capability_id_length = lpAppCapData->pCapID->GetGCCCapabilityIDData(
							&gcc_capability->capability_id,	memory);

			/*
			 * Add to the data length the amount of memory necessary to hold the
			 * capability ID data.
			 */
			capability_data_length += capability_id_length;

			/*
			 * Move the memory pointer past the data filled in for the
			 * capability ID.  This is where the application data OSTR
			 * contained in the non-collapsing capability will be written, if
			 * one exists.  Note that the capability contains a pointer to a
			 * OSTR and therefore the OSTR structure as well
			 * as the string data must be written into memory.
			 */
			memory += capability_id_length;

			if (lpAppCapData->poszAppData != NULL)
			{
				/*
				 * Set the application data structure pointer equal to the
				 * location in memory where	it will be written.
				 */
				gcc_capability->application_data = (LPOSTR) memory;
				gcc_capability->application_data->length = lpAppCapData->poszAppData->length;

				/*
				 * Move the memory pointer past the OSTR structure
				 * and round it off to an even four-byte boundary.  This is
				 * where the actual string data will be written so set the
				 * structure string pointer equal to that location.
				 */
				memory += ROUNDTOBOUNDARY(sizeof(OSTR));
				gcc_capability->application_data->value =(LPBYTE)memory;

				/*
				 * Copy the actual application string data into memory.
				 */
				::CopyMemory(gcc_capability->application_data->value,
							lpAppCapData->poszAppData->value,
							lpAppCapData->poszAppData->length);

				/*
				 * Add to the data length the amount of memory necessary to
				 * hold the	application data structure and string.  The lengths
				 * will need to be aligned on a four-byte boundary	before
				 * adding them to the total length.
				 */
				capability_data_length += ROUNDTOBOUNDARY(sizeof(OSTR));
				capability_data_length += ROUNDTOBOUNDARY(gcc_capability->application_data->length);

				/*
				 * Move the memory pointer past the application string data.
				 * The memory pointer is then fixed up to ensure that it falls
				 * on an even four-byte boundary.
				 */
				memory += ROUNDTOBOUNDARY(lpAppCapData->poszAppData->length);
			}
			else
			{
				gcc_capability->application_data = NULL;
			}

			/*
			 * Increment the capability array counter.
			 */
			capability_count++;
		}
	}
	else
	{
		gcc_record->non_collapsed_caps_list = NULL;
		capability_data_length = 0;
	}

	return (capability_data_length);
}


/*
 *	void	FreeApplicationRosterData	()
 *
 *	Private Function Description:
 *		This routine is used to free up any data which was locked for an "API"
 *		application roster.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
void CAppRoster::FreeApplicationRosterData(void)
{
	APP_NODE_RECORD			*lpAppNodeRec;
	APP_RECORD  		    *lpAppRecData;
	APP_CAP_ITEM			*lpAppCapData;
	CAppRecordList2			*lpAppRecDataList;

	DebugEntry(CAppRoster::FreeApplicationRosterData);

	m_pSessionKey->UnLockSessionKeyData();

	/*
	 * Unlock the data associated with each non-collapsed capability by
	 * iterating through the list of application records at each node as well as
	 * the list of sub-node records at each node, calling "UnLock" for each
	 * CapabilityIDData associated with each cabability.
	 */
	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate()))
	{
		lpAppNodeRec->AppRecordList.Reset();
		while (NULL != (lpAppRecData = lpAppNodeRec->AppRecordList.Iterate()))
		{
			lpAppRecData->non_collapsed_caps_list.Reset();
			while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
			{
				lpAppCapData->pCapID->UnLockCapabilityIdentifierData ();
			}
		}

		lpAppNodeRec->SubNodeList2.Reset();
		while (NULL != (lpAppRecDataList = lpAppNodeRec->SubNodeList2.Iterate()))
		{
			lpAppRecDataList->Reset();
			while (NULL != (lpAppRecData = lpAppRecDataList->Iterate()))
			{
				lpAppRecData->non_collapsed_caps_list.Reset();
				while (NULL != (lpAppCapData = lpAppRecData->non_collapsed_caps_list.Iterate()))
				{
					lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
				}
			}
		}
	}

	/*
	 * Iterate through the list of collapsed capabilities, unlocking the data
	 * for each CapabilityIDData object associated with each capability.
	 */
	m_CollapsedCapListForAllNodes.Reset();
	while (NULL != (lpAppCapData = m_CollapsedCapListForAllNodes.Iterate()))
	{
		lpAppCapData->pCapID->UnLockCapabilityIdentifierData();
	}
}


/*
 *	GCCError	AddRecord ()
 *
 *	Public Function Description
 *		This member function is responsible for inserting a new application
 *		record into the Roster. This routine will return a failure if the
 *		application record already exist.
 *
 *	Caveats
 *		Note that it is possible for a roster record (not application record)
 *		to already exist at this node if this is the second application
 *		entity to enroll at this node.
 */
GCCError CAppRoster::
AddRecord(GCCEnrollRequest *pReq, GCCNodeID nid, GCCEntityID eid)
{
	GCCError							rc = GCC_NO_ERROR;
	APP_NODE_RECORD						*node_record;
	APP_RECORD  					    *pAppRecord;
	CAppCapItemList						*pAppCapItemList;

	DebugEntry(CAppRoster::AddRecord);

	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	/*
	 * First create a roster entry for this user ID if one does not exists.
	 */
	if (NULL == (node_record = m_NodeRecordList2.Find(nid)))
	{
		DBG_SAVE_FILE_LINE
		node_record = new APP_NODE_RECORD;
		if (node_record != NULL)
		{
			m_NodeRecordList2.Append(nid, node_record);
		}
		else
		{
			ERROR_OUT(("CAppRoster: AddRecord: Resource Error Occured"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}
	}
	else
	{
		WARNING_OUT(("CAppRoster: AddRecord: Node Record is found"));
	}

	/*
	 * Check to make sure that the application record does not already exist..
	 */
	if ((NULL != node_record->AppRecordList.Find(eid)) ||
		(NULL != node_record->ListOfAppCapItemList2.Find(eid)))
	{
		WARNING_OUT(("AppRoster: AddRecord: Record already exists"));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

	//	Next create a record entry in the roster's app_record_list.
	DBG_SAVE_FILE_LINE
	pAppRecord = new APP_RECORD;
	if (NULL == pAppRecord)
	{
	    ERROR_OUT(("CAppRoster: AddRecord: can't create APP_RECORD"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	/*
	**	Here we must determine if an entry already exists at this
	**	node.  If so, only one entry can be conducting capable at a
	**	node.  Therefore, we set this variable based on this.  We use
	**	the "was_conducting_capable" variable to keep up with the
	**	original state incase the conducting capable node leaves the
	**	conference.
	*/
	pAppRecord->is_conducting_capable = pReq->fConductingCapable;

	APP_RECORD *p;
	node_record->AppRecordList.Reset();
	while (NULL != (p = node_record->AppRecordList.Iterate()))
	{
		if (p->is_conducting_capable)
		{
			pAppRecord->is_conducting_capable = FALSE;
			break;
		}
	}

	pAppRecord->was_conducting_capable = pReq->fConductingCapable;
	pAppRecord->is_enrolled_actively = pReq->fEnrollActively;
	pAppRecord->startup_channel_type = pReq->nStartupChannelType;
	pAppRecord->application_user_id = pReq->nUserID;

	if (pReq->cNonCollapsedCaps != 0)
	{
		rc = AddNonCollapsedCapabilities (
					&pAppRecord->non_collapsed_caps_list,
					pReq->cNonCollapsedCaps,
					pReq->apNonCollapsedCaps);
	    if (GCC_NO_ERROR != rc)
	    {
	        ERROR_OUT(("CAppRoster::AddRecord: can't add non collapsed caps, rc=%u", (UINT) rc));
	        delete pAppRecord;
	        goto MyExit;
	    }
	}

	//	Add the new record to the list of records at this node
	node_record->AppRecordList.Append(eid, pAppRecord);

    // from now on, we cannot free pAppRecord in case of error,
    // because it is now in the app record list.

	//	Increment the instance number.
	m_nInstance++;
	m_fPeerEntitiesAdded = TRUE;
	m_fRosterHasChanged = TRUE;

	//	Add an update to the PDU.
	rc = BuildApplicationRecordListPDU(APP_ADD_RECORD, nid, eid);
	if (GCC_NO_ERROR != rc)
	{
        ERROR_OUT(("CAppRoster::AddRecord: can't build app record list, rc=%u", (UINT) rc));
        goto MyExit;
	}

	if (pReq->cCollapsedCaps != 0)
	{
		/*
		**	Create a new capabilities list and insert it into the roster
		**	record list of capabilities.
		*/
		DBG_SAVE_FILE_LINE
		pAppCapItemList = new CAppCapItemList;
		if (NULL == pAppCapItemList)
		{
		    ERROR_OUT(("CAppRoster::AddRecord: can't create CAppCapItemList"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

		rc = AddCollapsableCapabilities(pAppCapItemList,
										pReq->cCollapsedCaps,
										pReq->apCollapsedCaps);
		if (GCC_NO_ERROR != rc)
		{
		    ERROR_OUT(("CAppRoster::AddRecord: can't add collapsable caps, rc=%u", (UINT) rc));
		    delete pAppCapItemList;
		    goto MyExit;
		}

		//	Add list of capabilities to list at this node
		node_record->ListOfAppCapItemList2.Append(eid, pAppCapItemList);
		m_fCapabilitiesHaveChanged = TRUE;

        // from now on, we cannot free pAppCapItemList in case of error,
        // because it is now in the app cap item list

		//	Rebuild the collapsed capabilities list.
		MakeCollapsedCapabilitiesList();

		//	Build the capabilities refresh portion of the PDU.
		rc = BuildSetOfCapabilityRefreshesPDU();
		if (GCC_NO_ERROR != rc)
		{
		    ERROR_OUT(("CAppRoster::AddRecord: can't build set of cap refresh, rc=%u", (UINT) rc));
		    goto MyExit;
		}
	}

MyExit:

	DebugExitINT(CAppRoster::AddRecord, rc);
	return rc;
}


/*
 *	GCCError	AddCollapsableCapabilities ()
 *
 *	Private Function Description
 *		This routine takes API collapsed capabilities list data passed in
 *		through a local request and converts it to internal collapsed
 *		capabillities.
 *
 *	Formal Parameters
 *		pAppCapItemList     	-	(o)	Pointer to internal capabilites list
 *										to fill in.
 *		number_of_capabilities	-	(i)	Number of capabilities in the source
 *										list.
 *		capabilities_list		-	(i)	Pointer to source capabilities list.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *	Side Effects
 *		The collapsed capabilities will be recalculated at this node after
 *		all the new caps are added.
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::AddCollapsableCapabilities (
		CAppCapItemList				*pAppCapItemList,
		UINT						number_of_capabilities,
		PGCCApplicationCapability	*capabilities_list)
{
	GCCError			rc = GCC_NO_ERROR;
	APP_CAP_ITEM		*pAppCapItem;
	UINT				i;
	BOOL    			capability_already_exists;

	DebugEntry(CAppRoster::AddCollapsableCapabilities);

	for (i = 0; i < number_of_capabilities; i++)
	{
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType)
							capabilities_list[i]->capability_class.eType);
		if (pAppCapItem != NULL)
		{
			DBG_SAVE_FILE_LINE
			pAppCapItem->pCapID = new CCapIDContainer(&capabilities_list[i]->capability_id, &rc);
			if ((pAppCapItem->pCapID != NULL) && (rc == GCC_NO_ERROR))
			{
				APP_CAP_ITEM		*lpAppCapData;
				/*
				**	Here we check to make sure that this capability id does
				**	not alreay exists in the list.
				*/
				capability_already_exists = FALSE;
				pAppCapItemList->Reset();
				while (NULL != (lpAppCapData = pAppCapItemList->Iterate()))
				{
					if (*lpAppCapData->pCapID == *pAppCapItem->pCapID)
					{
						capability_already_exists = TRUE;
						delete pAppCapItem;
						break;
					}
				}

				if (capability_already_exists == FALSE)
				{	
					if (capabilities_list[i]->capability_class.eType ==
											GCC_UNSIGNED_MINIMUM_CAPABILITY)
					{
						pAppCapItem->nUnsignedMinimum =
								capabilities_list[i]->capability_class.nMinOrMax;
					}
					else if	(capabilities_list[i]->capability_class.eType
										== GCC_UNSIGNED_MAXIMUM_CAPABILITY)
					{
						pAppCapItem->nUnsignedMaximum = capabilities_list[i]->capability_class.nMinOrMax;
					}

					//	Since we have yet to collapse the capabilities set to 1
					pAppCapItem->cEntries = 1;

					//	Add this capability to the list
					pAppCapItemList->Append(pAppCapItem);
				}
			}
			else if (pAppCapItem->pCapID == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
			else
			{
			    goto MyExit;
			}
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}
	}

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        delete pAppCapItem;
    }

	return rc;
}

/*
 *	GCCError	AddNonCollapsedCapabilities ()
 *
 *	Private Function Description
 *		This routine takes API non-collapsed capabilities list data passed in
 *		through a local request and converts it to internal non-collapsed
 *		capabillities.
 *
 *	Formal Parameters
 *		pAppCapItemList     	-	(o)	Pointer to internal non-collapsed
 *										capabilites list to fill in.
 *		number_of_capabilities	-	(i)	Number of non-collapsed capabilities in
 *										the source list.
 *		capabilities_list		-	(i)	Pointer to source non-collapsed
 *										capabilities list.
 *
 *	Return Value
 *		GCC_NO_ERROR					-	No error occured.
 *		GCC_INVALID_NON_COLLAPSED_CAP	-	Invalid non-collapsed capability.
 *		GCC_ALLOCATION_FAILURE			-	A resource error occured.
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::AddNonCollapsedCapabilities (
				CAppCapItemList				*pAppCapItemList,
				UINT						number_of_capabilities,
				PGCCNonCollapsingCapability	*capabilities_list)
{
	GCCError			rc = GCC_NO_ERROR;
	APP_CAP_ITEM		*pAppCapItem = NULL;
	UINT				i;

	DebugEntry(CAppRoster::AddNonCollapsedCapabilities);

	for (i = 0; i < number_of_capabilities; i++)
	{
	    //
		// LONCHANC: Cap type is not set here.
		// for now, it is zero.
		//
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM((GCCCapabilityType) 0);
		if (pAppCapItem != NULL)
		{
			DBG_SAVE_FILE_LINE
			pAppCapItem->pCapID = new CCapIDContainer(&capabilities_list[i]->capability_id, &rc);
			if (pAppCapItem->pCapID != NULL)
			{
				if (capabilities_list[i]->application_data != NULL)
				{
					if (NULL == (pAppCapItem->poszAppData = ::My_strdupO2(
							capabilities_list[i]->application_data->value,
							capabilities_list[i]->application_data->length)))
					{
						rc = GCC_ALLOCATION_FAILURE;
						goto MyExit;
					}
					else if (pAppCapItem->poszAppData->length > MAXIMUM_APPLICATION_DATA_LENGTH)
					{
						rc = GCC_INVALID_NON_COLLAPSED_CAP;
						goto MyExit;
					}
				}

				//	Add this capability to the list if no errors
                if( !pAppCapItemList->Append(pAppCapItem) )
                {
				    rc = GCC_ALLOCATION_FAILURE;
				    goto MyExit;
                }
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
	    }
	}

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        if(pAppCapItem != NULL)
        {
            delete pAppCapItem;
        }
    }

	return rc;
}


/*
 *	GCCError	RemoveRecord ()
 *
 *	Public Function Description
 *		This member function completely removes the specified record from the
 *		application roster.  This includes any capabilities associated with
 *		this record. It also takes care of keeping the Instance number and
 *		added and removed flags up to date.
 */
GCCError CAppRoster::RemoveRecord(GCCNodeID nid, GCCEntityID eid)
{
	GCCError				rc;
	APP_RECORD  		    *pAppRecord;
	APP_NODE_RECORD			*node_record;

	DebugEntry(CAppRoster::RemoveRecord);

	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	//	First see if the record is contained in the Roster_Record_List.
	if (NULL == (node_record = m_NodeRecordList2.Find(nid)))
	{
	    TRACE_OUT(("CAppRoster::RemoveRecord: can't find node record, nid=%u", (UINT) nid));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

	if (NULL == (pAppRecord = node_record->AppRecordList.Find(eid)))
	{
	    TRACE_OUT(("CAppRoster::RemoveRecord: can't find app record, eid=%u", (UINT) eid));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

	/*
	**	Here we must determine if any of the remaining APEs at this
	**	node should become conducting capable based on their role
	**	at the time they enrolled.  We only do this if the record
	**	that is being deleted was conducting capabile.
	*/
	if (pAppRecord->is_conducting_capable)
	{
		APP_RECORD  *p;
		EntityID    eid2;

		node_record->AppRecordList.Reset();
		while (NULL != (p = node_record->AppRecordList.Iterate(&eid2)))
		{
			/*
			**	Here we only deal with record entries other than the
			**	one being removed.
			*/
			if (eid2 != eid)
			{
				if (p->was_conducting_capable)
				{
					p->is_conducting_capable = TRUE;
					/*
					**	Set up the update PDU for this conducting
					**	capable change.
					*/
					rc = BuildApplicationRecordListPDU(APP_REPLACE_RECORD, nid, eid2);
					if (GCC_NO_ERROR != rc)
					{
                        ERROR_OUT(("CAppRoster::RemoveRecord: can't build app record list, rc=%u", (UINT) rc));
					    goto MyExit;
					}
					break;
				}
			}
		}
	}

	//	Now delete the record
	rc = DeleteRecord(nid, eid, TRUE);
	if (GCC_NO_ERROR != rc)
	{
	    WARNING_OUT(("CAppRoster::RemoveRecord: can't delete record, rc=%u", (UINT) rc));
        goto MyExit;
	}

	//	Increment the instance number.
	m_nInstance++;
	m_fPeerEntitiesRemoved = TRUE;
	m_fRosterHasChanged = TRUE;

	//	Add an update to the PDU.
	rc = BuildApplicationRecordListPDU(APP_DELETE_RECORD, nid, eid);
	if (GCC_NO_ERROR != rc)
	{
	    ERROR_OUT(("CAppRoster::RemoveRecord: can't build app record list, rc=%u", (UINT) rc));
        goto MyExit;
	}

	/*
	**	If the capabilities changed during the above processing
	**	we must	create a new collapsed capabilities list and
	**	build a new capability refresh PDU.
	*/
	if (m_fCapabilitiesHaveChanged)
	{
		MakeCollapsedCapabilitiesList();
		rc = BuildSetOfCapabilityRefreshesPDU();
		if (GCC_NO_ERROR != rc)
		{
    	    ERROR_OUT(("CAppRoster::RemoveRecord: can't build set of cap refreshes, rc=%u", (UINT) rc));
            goto MyExit;
		}
	}

MyExit:

	DebugExitINT(CAppRoster::RemoveRecord, rc);
	return rc;
}


/*
 *	GCCError	ReplaceRecord	()
 *
 *	Public Function Description
 *		This routine completely replaces the specified record's parameters
 *		with the new parameters passed in.  This includes the capabilities.
 */
GCCError CAppRoster::
ReplaceRecord(GCCEnrollRequest *pReq, GCCNodeID nid, GCCEntityID eid)
{
	GCCError				rc = GCC_NO_ERROR;
	BOOL    				capable_node_found;
	APP_NODE_RECORD			*node_record;
	APP_RECORD  		    *pAppRecord, *p;
	APP_CAP_ITEM			*lpAppCapData;
	CAppCapItemList         NonCollCapsList;

	DebugEntry(CAppRoster::ReplaceRecord);

	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	/*
	**	First determine if the node record does actually already exists. If not
	**	we return an error here.
	*/
	if (NULL == (node_record = m_NodeRecordList2.Find(nid)))
	{
	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't find the node record for nid=%u", (UINT) nid));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

    // make sure the app record exists. if not, return an error
	if (NULL == (pAppRecord = node_record->AppRecordList.Find(eid)))
	{
	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't find the app record for eid=%u", (UINT) eid));
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

	/*
	**	First check to make sure that we can build the new record before
	**	replacing the old record.  The only entry we need to wory about
	**	here are the non-collapsing capabilities.
	*/
	if (pReq->cNonCollapsedCaps != 0)
	{
		rc = AddNonCollapsedCapabilities(&NonCollCapsList,
		                                pReq->cNonCollapsedCaps,
                                        pReq->apNonCollapsedCaps);
		if (GCC_NO_ERROR != rc)
		{
    	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't add non collapsed caps, rc=%u", (UINT) rc));
    		goto MyExit;
		}
	}

	//	Now replace the record entries.
	pAppRecord->is_enrolled_actively = pReq->fEnrollActively;
	pAppRecord->was_conducting_capable = pReq->fConductingCapable;
	pAppRecord->startup_channel_type = pReq->nStartupChannelType;
	pAppRecord->application_user_id = pReq->nUserID;

	/*
	**	If the is conducting capable flag that was passed in was set
	**	to FALSE we can go ahead and set the internal is conducting
	**	capable flag to FALSE regardless of what the previous
	**	setting was.  If it was passed in TRUE we leave the previous
	**	setting alone.
	*/
	if (pAppRecord->was_conducting_capable == FALSE)
	{
		pAppRecord->is_conducting_capable = FALSE;
	}

	/*
	**	Here we delete the old non-collapsed capabilites and then
	**	add the new ones.
	*/
	if (! pAppRecord->non_collapsed_caps_list.IsEmpty())
	{
		pAppRecord->non_collapsed_caps_list.DeleteList();
		pAppRecord->non_collapsed_caps_list.Clear();
	}

	//	Copy the new non collapsed capabilities if any exists.
	if (pReq->cNonCollapsedCaps != 0)
	{
        while (NULL != (lpAppCapData = NonCollCapsList.Get()))
        {
            pAppRecord->non_collapsed_caps_list.Append(lpAppCapData);
        }
	}

    //
    // handling collapsing cap list
    //

	m_nInstance++;
	m_fRosterHasChanged = TRUE;
	rc = BuildApplicationRecordListPDU(APP_REPLACE_RECORD, nid, eid);
	if (rc != GCC_NO_ERROR)
	{
	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't build app record list, rc=%u", (UINT) rc));
	    goto MyExit;
	}

	/*
	**	Here we must make sure that at least one of the APEs is
	**	Conducting Capable.  We do this by first scanning the
	**	list to see if anyone is it.  If one is not found, the
	**	same list is scanned for an APE that "was" previously
	**	capable.  The first one found that was previously
	**	capable is now it.  If none are found then no one is
	**	capable.
	*/
	capable_node_found = FALSE;
	node_record->AppRecordList.Reset();
	while (NULL != (p = node_record->AppRecordList.Iterate()))
	{
		if (p->is_conducting_capable)
		{
			capable_node_found = TRUE;
			break;
		}
	}

	if (! capable_node_found)
	{
    	GCCEntityID  eid2;
		node_record->AppRecordList.Reset();
		while (NULL != (p = node_record->AppRecordList.Iterate(&eid2)))
		{
			if (p->was_conducting_capable)
			{
				p->is_conducting_capable = TRUE;

				/*
				**	Set up the update PDU for this conducting
				**	capable change.
				*/
				rc = BuildApplicationRecordListPDU(APP_REPLACE_RECORD, nid, eid2);
				if (GCC_NO_ERROR != rc)
				{
            	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't build app record list, rc=%u", (UINT) rc));
            	    goto MyExit;
				}
				break;
			}
		}
	}

	/*
	**	This section of code deals with the collapsable capabilities.
	**	First we determine if the capabilities passed in are different
	**	from the previously existing capabilities.  If so, we must
	**	delete the old set of caps and add back in the new ones.
	*/
	TRACE_OUT(("ApplicatonRoster:ReplaceRecord: Check to see if caps match"));
	if (! DoCapabilitiesListMatch(nid, eid, pReq->cCollapsedCaps, pReq->apCollapsedCaps))
	{
    	CAppCapItemList *pCollCapsList, *q;

		TRACE_OUT(("ApplicatonRoster:ReplaceRecord: Capabilities match"));
		m_fCapabilitiesHaveChanged = TRUE;

		/*
		**	Delete the old capabilities list since it does not match the
		**	new capabilities list.
		*/
		if (NULL != (q = node_record->ListOfAppCapItemList2.Find(eid)))
		{
			q->DeleteList();
			delete q;
			node_record->ListOfAppCapItemList2.Remove(eid);
		}

		/*
		**	Here we add back in the new capabilities. Create a new
		**	capabilities list and insert it into the roster	record list of
		**	capabilities.
		*/
		if (pReq->cCollapsedCaps != 0)
		{
			DBG_SAVE_FILE_LINE
			pCollCapsList = new CAppCapItemList;
			if (NULL == pCollCapsList)
			{
          	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't create CAppCapItemList"));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}

			rc = AddCollapsableCapabilities(pCollCapsList,
											pReq->cCollapsedCaps,
											pReq->apCollapsedCaps);
			if (rc != GCC_NO_ERROR)
			{
          	    ERROR_OUT(("CAppRoster::ReplaceRecord: can't add collapsed caps, rc=%u", (UINT) rc));
			    delete pCollCapsList;
			    goto MyExit;
			}

			//	Add list of capabilities to list at this node
			node_record->ListOfAppCapItemList2.Append(eid, pCollCapsList);
		}

		//	Rebuild the collapsed capabilities list.
		MakeCollapsedCapabilitiesList();

		//	Build the capabilities refresh portion of the PDU.
		rc = BuildSetOfCapabilityRefreshesPDU();
		if (GCC_NO_ERROR != rc)
		{
		    ERROR_OUT(("CAppRoster::ReplaceRecord: can't build set of cap refreshes, rc=%u", (UINT) rc));
		    goto MyExit;
		}
	}
	else
	{
		TRACE_OUT(("CAppRoster:ReplaceRecord:Capabilities match with previous record"));
	}

MyExit:

	DebugExitINT(CAppRoster::ReplaceRecord, rc);
	return rc;
}


/*
 *	GCCError	DeleteRecord ()
 *
 *	Private Function Description
 *		This member function completely removes the specified record from the
 *		application roster.  This includes any capabilities associated with
 *		this record.
 *
 *	Formal Parameters
 *		node_id				-	(i)	Node ID of record to delete.
 *		entity_id			-	(i)	Entity ID of record to delete.
 *		clear_empty_records	-	(i)	This flag indicates whether or not to
 *									clear out the node record if it no-longer
 *									holds data.  When replacing a record we
 *									do NOT want to do this so that we don't
 *									lose any "unchanged" capabilities.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_INVALID_PARAMETER	-	Record specified to delete does not exists.
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::DeleteRecord(UserID			node_id,
									EntityID		entity_id,
									BOOL			clear_empty_records)
{
	GCCError						rc = GCC_NO_ERROR;
	APP_RECORD  				    *application_record;
	CAppCapItemList					*pAppCapItemList;
	CAppRecordList2					*pAppRecordList;
	UserID							node_to_check;
	APP_NODE_RECORD					*node_record;
	//APP_CAP_ITEM					*lpAppCapData;
	APP_NODE_RECORD					*lpAppNodeRec;

	DebugEntry(CAppRoster::DeleteRecord);

	//	First see if the record is contained in the Roster_Record_List.
	if (NULL != (node_record = m_NodeRecordList2.Find(node_id)))
	{
		//	Set up node id to check at bottom for empty record
		node_to_check = node_id;
		
		//	Delete the application record.
		if (NULL != (application_record = node_record->AppRecordList.Find(entity_id)))
		{
			TRACE_OUT(("AppRoster: DeleteRecord: Delete AppRecord"));

			//	Delete the data associated with the application record
			DeleteApplicationRecordData (application_record);
			
			//	Remove record from application record list
			node_record->AppRecordList.Remove(entity_id);

			/*
			**	Delete the associated capabilities list.  Note that this list
			**	only exists for records of local nodes.  The collapsed
			**	capabilities list at the root node record take create of
			**	subordniate nodes and is deleted some where else.
			*/
			if (NULL != (pAppCapItemList = node_record->ListOfAppCapItemList2.Find(entity_id)))
			{
				m_fCapabilitiesHaveChanged = TRUE;
				pAppCapItemList->DeleteList();
				TRACE_OUT(("AppRoster: DeleteRecord: Delete Capabilities"));
				delete pAppCapItemList;
				node_record->ListOfAppCapItemList2.Remove(entity_id);
			}
		}
		else
		{
		    WARNING_OUT(("AppRoster: DeleteRecord: can't find this eid=%u", (UINT) entity_id));
			rc = GCC_INVALID_PARAMETER;
		}
	}
	else
	{
		UserID  uid2;
		/*
		**	Here we search through all the sub node list trying to find the
		**	record.  Set return value to record does not exist here and
		**	after the record is found set it back to no error.
		*/
		rc = GCC_INVALID_PARAMETER;
		m_NodeRecordList2.Reset();
		while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate(&uid2)))
		{
			//	Delete the sub_node list if it exists
			if (NULL != (pAppRecordList = lpAppNodeRec->SubNodeList2.Find(node_id)))
			{
				//	Delete the app_record_list entry.
				if (NULL != (application_record = pAppRecordList->Find(entity_id)))
				{
					//	Delete the data associated with the application record
					DeleteApplicationRecordData (application_record);

					pAppRecordList->Remove(entity_id);

					if (pAppRecordList->IsEmpty())
					{
						TRACE_OUT(("AppRoster: DeleteRecord: Deleting Sub-Node"));
						delete pAppRecordList;
						lpAppNodeRec->SubNodeList2.Remove(node_id);
					}

					//	Set up node id to check at bottom for empty record
					node_to_check = uid2;

					rc = GCC_NO_ERROR;
				}
				break;
			}
		}
	}

	/*
	**	If the record list is empty and the sub node list is empty
	**	we can remove this entire record from the application roster.
	**	If the record list is empty but the sub node list is not we
	**	must keep the roster record around to maintain the sub node list.
	*/
	if ((rc == GCC_NO_ERROR) && clear_empty_records)
    {
		if (NULL != (node_record = m_NodeRecordList2.Find(node_to_check)) &&
			node_record->AppRecordList.IsEmpty() &&
			node_record->SubNodeList2.IsEmpty())
		{
			if (! node_record->CollapsedCapList.IsEmpty())
			{
				m_fCapabilitiesHaveChanged = TRUE;
				
				//	Delete the collapsed capabilities list.
				node_record->CollapsedCapList.DeleteList();
			}

			delete node_record;
			m_NodeRecordList2.Remove(node_to_check);
		}
    }

	return rc;
}


/*
 *	GCCError		RemoveUserReference	()
 *
 *	Public Function Description
 *		This routine will only remove the application record and its sub nodes
 *		if the node being removed is directly connected to this node.
 *		Otherwise, we wait to receive the update from either the sub node or
 *		the Top Provider.
 */
GCCError CAppRoster::RemoveUserReference(UserID detached_node)
{
	GCCError					rc = GCC_NO_ERROR;

	DebugEntry(CAppRoster::RemoveUserReference);

	//	Clear out any previously allocated PDUs
	if (m_fPduIsFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduIsFlushed = FALSE;
	}

	/*
	**	First Try to remove the node record if one exist.  If it does not
	**	exist we return immediately.  If it does exists we will build the
	**	appropriate PDU and update the instance variables.
	*/
	rc = ClearNodeRecordFromList (detached_node);

	if (rc == GCC_NO_ERROR)
	{
		//	Increment the instance number.
		m_nInstance++;
		m_fPeerEntitiesRemoved = TRUE;
		m_fRosterHasChanged = TRUE;

		/*
		**	Go ahead and do the full refresh here since we do not know the
		**	specifics about who was deleted.
		*/
		rc = BuildApplicationRecordListPDU(APP_FULL_REFRESH, 0, 0);

		if (m_fCapabilitiesHaveChanged && (rc == GCC_NO_ERROR))
		{
			//	Create a new collapsed capabilities list.
			MakeCollapsedCapabilitiesList();

			//	Build the capabilities refresh portion of the PDU.
			rc = BuildSetOfCapabilityRefreshesPDU ();
		}
	}

	return rc;
}


/*
 *	void	DeleteApplicationRecordData	()
 *
 *	Private Function Description
 *		This routine internal application record data.
 *
 *	Formal Parameters
 *		application_record	-	Pointer to the application record data to
 *								delete.
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
void CAppRoster::DeleteApplicationRecordData(APP_RECORD *pAppRec)
{
	pAppRec->non_collapsed_caps_list.DeleteList();
	delete pAppRec;
}


/*
 *	USHORT		GetNumberOfApplicationRecords	()
 *
 *	Public Function Description
 *		This routine returns the total number of application records that exist
 *		in this application roster.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		Number of application roster records
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
UINT CAppRoster::GetNumberOfApplicationRecords(void)
{
	UINT						cRecords = 0;
	APP_NODE_RECORD				*lpAppNodeRec;
	CAppRecordList2				*lpAppRecDataList;

	DebugEntry(CAppRoster::GetNumberOfApplicationRecords);

	/*
	**	First calculate the total number of records. This count is used to
	**	allocate the space necessary to hold the records. Note that we must
	**	count both the application record list and the sub-node list.
	*/
	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate()))
	{
		//	Add the application records at this node to the count.
		cRecords += lpAppNodeRec->AppRecordList.GetCount();

		//	Next count the sub node entries.
		if (! lpAppNodeRec->SubNodeList2.IsEmpty())
		{
			lpAppNodeRec->SubNodeList2.Reset();
			while (NULL != (lpAppRecDataList = lpAppNodeRec->SubNodeList2.Iterate()))
			{
				cRecords += lpAppRecDataList->GetCount();
			}
		}
	}

	return cRecords;
}


/*
 *	PGCCSessionKey		GetSessionKey	()
 *
 *	Public Function Description
 *		This routine returns the session key associated with this
 *		application roster.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		PGCCSessionKey -	the application key associated with this roster
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */


/*
 *	void	ResetApplicationRoster	()
 *
 *	Public Function Description
 *		This routine takes care of resetting all the internal flags that are
 *		used to convey the current state of the application roster.  Should be
 *		called after the roster is flushed and any roster update messages have
 *		been delivered (after a change to the roster occurs).
 */
void CAppRoster::ResetApplicationRoster(void)
{
	m_fCapabilitiesHaveChanged = FALSE;
	m_fRosterHasChanged = FALSE;
	m_fPeerEntitiesRemoved = FALSE;
	m_fPeerEntitiesAdded = FALSE;
}


/*
 *	BOOL	DoesRecordExist	()
 *
 *	Public Function Description
 *		This routine informs the caller if the specified application record
 *		exists or not.
 */
BOOL CAppRoster::DoesRecordExist(UserID node_id, EntityID entity_id)
{
	BOOL    						rc = FALSE;
	APP_NODE_RECORD					*node_record;
	CAppRecordList2					*record_list;

	DebugEntry(CAppRoster::DoesRecordExist);

	if (NULL != (node_record = m_NodeRecordList2.Find(node_id)))
	{
		if (node_record->AppRecordList.Find(entity_id))
			rc = TRUE;
	}
	else
	{
		m_NodeRecordList2.Reset();
		while (NULL != (node_record = m_NodeRecordList2.Iterate()))
		{
			if (NULL != (record_list = node_record->SubNodeList2.Find(node_id)))
			{
				if (record_list->Find(entity_id))
					rc = TRUE;
			}
		}
	}
	
	return rc;
}


/*
 *	BOOL	HasRosterChanged	()
 *
 *	Public Function Description
 *		This routine informs the caller if the roster has changed since the
 *		last time it was reset.
 */


/*
 *	GCCError	ClearNodeRecordFromList	()
 *
 *	Private Function Description
 *		This routine clears out all the application records that exists at
 *		the specified node or below it in the connection hierarchy.
 *
 *	Formal Parameters
 *		node_id - 	Node ID of node to clear from Node Record list
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured
 *		GCC_INVALID_PARAMETER	-	The specified node ID is not associated
 *									with any records.
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::ClearNodeRecordFromList(	UserID		node_id)
{
	GCCError					rc = GCC_NO_ERROR;
	APP_NODE_RECORD				*node_record;
	APP_RECORD  			    *lpAppRecData;
	//APP_CAP_ITEM				*lpAppCapData;
	CAppRecordList2				*lpAppRecDataList;

	DebugEntry(CAppRoster::ClearNodeRecordFromList);

	if (NULL != (node_record = m_NodeRecordList2.Find(node_id)))
	{
		//	Delete all the app_record_list entries.
		node_record->AppRecordList.Reset();
		while (NULL != (lpAppRecData = node_record->AppRecordList.Iterate()))
		{
			DeleteApplicationRecordData (lpAppRecData);
		}

		/*
		**	Delete the ListOfAppCapItemList2 entries.  Note that this
		**	list should not exists for detached nodes if the local applications
		**	cleanly unenroll with GCC.  This list should only exists for
		**	locally enrolled APEs.  We still check here just to make sure.
		*/
		if (! node_record->ListOfAppCapItemList2.IsEmpty())
		{
			//CAppCapItemList *lpAppCapDataList;

			m_fCapabilitiesHaveChanged = TRUE;

			node_record->ListOfAppCapItemList2.DeleteList();
		}
		
		//	Delete the sub_node list.
		node_record->SubNodeList2.Reset();
		while (NULL != (lpAppRecDataList = node_record->SubNodeList2.Iterate()))
		{
			//	Delete all the app_record_list entries.
			lpAppRecDataList->Reset();
			while (NULL != (lpAppRecData = lpAppRecDataList->Iterate()))
			{
				DeleteApplicationRecordData (lpAppRecData);
			}

			delete lpAppRecDataList;
		}
		
		//	Delete the collapsed capabilities list.
		if (! node_record->CollapsedCapList.IsEmpty())
		{
			m_fCapabilitiesHaveChanged = TRUE;
			node_record->CollapsedCapList.DeleteList();
		}

		//	Delete the rogoue wave reference to this roster record.
		delete node_record;
		m_NodeRecordList2.Remove(node_id);
	}
	else
		rc = GCC_INVALID_PARAMETER;
		
	return rc;
}


/*
 *	ApplicationRosterError	ClearNodeRecordList	()
 *
 *	Private Function Description
 *		This routine complete frees all memory associated with the roster
 *		record list and clears the list of all its entries.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		none
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		Currently this routine does not handle standard identifiers.
 */
void CAppRoster::ClearNodeRecordList(void)
{
	APP_NODE_RECORD					*lpAppNodeRec;
	APP_RECORD  				    *lpAppRecData;
	CAppRecordList2					*lpAppRecDataList;
	//APP_CAP_ITEM					*lpAppCapData;
	//CAppCapItemList					*lpAppCapDataList;

	DebugEntry(CAppRoster::ClearNodeRecordList);

	//	Delete all the records in the application roster.
	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate()))
	{
		//	First delete all the app records at this node.
		lpAppNodeRec->AppRecordList.Reset();
		while (NULL != (lpAppRecData = lpAppNodeRec->AppRecordList.Iterate()))
		{
			DeleteApplicationRecordData(lpAppRecData);
		}

		//	Next delete all the sub node record list.
		lpAppNodeRec->SubNodeList2.Reset();
		while (NULL != (lpAppRecDataList = lpAppNodeRec->SubNodeList2.Iterate()))
		{
			lpAppRecDataList->Reset();
			while (NULL != (lpAppRecData = lpAppRecDataList->Iterate()))
			{
				DeleteApplicationRecordData(lpAppRecData);
			}
				
			//	Delete the rogue wave list holding the lists of sub nodes.
			delete lpAppRecDataList;
		}

		//	Delete the collapsed capabilities list.
		lpAppNodeRec->CollapsedCapList.DeleteList();

		//	Delete the list of capabilities list.
		lpAppNodeRec->ListOfAppCapItemList2.DeleteList();
		
		//	Now delete the node record
		delete	lpAppNodeRec;
	}
	
	m_NodeRecordList2.Clear();
}


/*
 *	GCCError		MakeCollapsedCapabilitiesList	()
 *
 *	Private Function Description
 *		This routine is responsible for applying the T.124 capabilities
 *		rules to create the collapsed capabilities list at this node.
 *		It iterates through all the capabilities at this node to create this
 *		collapsed list.
 *
 *	Formal Parameters
 *		none
 *
 *	Return Value
 *		GCC_NO_ERROR -	On success
 *		GCC_ALLOCATION_FAILURE - On resource error
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		Currently this routine does not handle standard identifiers.
 */
GCCError CAppRoster::MakeCollapsedCapabilitiesList(void)
{
	GCCError						rc = GCC_NO_ERROR;
	APP_CAP_ITEM					*lpAppCapData;
	APP_NODE_RECORD					*lpAppNodeRec;
	CAppCapItemList					*lpAppCapDataList;

	DebugEntry(CAppRoster::MakeCollapsedCapabilitiesList);

	//	First clear out the old capabilities list.
	m_CollapsedCapListForAllNodes.DeleteList();

	/*
	**	We now iterate through the capabilities at each node to create the
	**	new capabilities list. Note that we have to check for the collapsed
	**	capabilities list at each node as well as the list of capabilities list
	**	that represents all the different capabilities for each entity at a
	**	node.  Note that in this implementation it is not possible to have both
	**	a list of capabilities list and a collapsed capabilities list in the
	**	same roster record.
	*/
	m_NodeRecordList2.Reset();
	while (NULL != (lpAppNodeRec = m_NodeRecordList2.Iterate()))
	{
		/*
		**	First check the collapsed capabilities list. If entries exists
		**	then we don't have to worry about the list of list.
		*/
		if (! lpAppNodeRec->CollapsedCapList.IsEmpty())
		{
			lpAppNodeRec->CollapsedCapList.Reset();
			while (NULL != (lpAppCapData = lpAppNodeRec->CollapsedCapList.Iterate()))
			{
				rc = AddCapabilityToCollapsedList(lpAppCapData);
				if (GCC_NO_ERROR != rc)
				{
					goto MyExit; // break;
				}
			}
		}
		else
		if (! lpAppNodeRec->ListOfAppCapItemList2.IsEmpty())
		{
			//	Here we check the list of capabilities list.
			lpAppNodeRec->ListOfAppCapItemList2.Reset();
			while (NULL != (lpAppCapDataList = lpAppNodeRec->ListOfAppCapItemList2.Iterate()))
			{
				lpAppCapDataList->Reset();
				while (NULL != (lpAppCapData = lpAppCapDataList->Iterate()))
				{
					rc = AddCapabilityToCollapsedList(lpAppCapData);
					if (GCC_NO_ERROR != rc)
					{
						goto MyExit;
					}
				}
			}
		}
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	return rc;
}


/*
 *	GCCError		AddCapabilityToCollapsedList	()
 *
 *	Private Function Description
 *		This is the routine that performs the rules that allow the capability
 *		to be collapsed into the collapsed list.
 *
 *	Formal Parameters
 *		new_capability		-	(i)	Add this capability to the collapsed list.
 *
 *	Return Value
 *		GCC_NO_ERROR	-	On success
 *		GCC_ALLOCATION_FAILURE - On resource error
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
GCCError CAppRoster::AddCapabilityToCollapsedList(APP_CAP_ITEM *new_capability)
{
	GCCError			rc = GCC_NO_ERROR;
	APP_CAP_ITEM		*pAppCapItem;

	DebugEntry(CAppRoster::AddCapabilityToCollapsedList);

	/*
	**	First determine if the capability already exists in the list.
	**	We must iterate through the complete list to determine if there
	**	is a matching capability id.
	*/
	m_CollapsedCapListForAllNodes.Reset();
	while (NULL != (pAppCapItem = m_CollapsedCapListForAllNodes.Iterate()))
	{
		if (*pAppCapItem->pCapID == *new_capability->pCapID)
		{
			pAppCapItem->cEntries += new_capability->cEntries;
			break;
		}
	}

	if (pAppCapItem == NULL)
	{
		DBG_SAVE_FILE_LINE
		pAppCapItem = new APP_CAP_ITEM(new_capability, &rc);
		if (NULL == pAppCapItem)
		{
			return GCC_ALLOCATION_FAILURE;
		}
		if (GCC_NO_ERROR != rc)
		{
			delete pAppCapItem;
			return rc;
		}

		m_CollapsedCapListForAllNodes.Append(pAppCapItem);
	}

	/*
	**	If the unsigned minimum or unsigned maximum rule is used perform the
	**	operation here.
	*/
	ASSERT(GCC_NO_ERROR == rc);
	if (new_capability->eCapType == GCC_UNSIGNED_MINIMUM_CAPABILITY)
	{
		if (new_capability->nUnsignedMinimum < pAppCapItem->nUnsignedMinimum)
		{
			pAppCapItem->nUnsignedMinimum = new_capability->nUnsignedMinimum;
		}
	}
	else if (new_capability->eCapType == GCC_UNSIGNED_MAXIMUM_CAPABILITY)
	{
		if (new_capability->nUnsignedMaximum > pAppCapItem->nUnsignedMaximum)
		{
			pAppCapItem->nUnsignedMaximum = new_capability->nUnsignedMaximum;
		}
	}

	return rc;
}


/*
 *	BOOL		DoCapabilitiesListMatch	()
 *
 *	Private Function Description
 *		This routine determines if the set of capabilities that were passed in
 *		match the set of internal capabilities associated with the record.
 *
 *	Formal Parameters
 *		node_id					-	(i)	Node ID of record that contains the
 *										capabilities to check.
 *		entity_id				-	(i)	Entity ID of record that contains the
 *										capbilities to check.
 *		number_of_capabilities	-	(i)	Number of capabilities in list to check.
 *		capabilities_list		-	(i)	"API" capabillities list to check
 *
 *	Return Value
 *		TRUE 	-	If capabillities list match
 *		FALSE 	- 	If capabillities list do NOT match
 *
 *	Side Effects
 *		none
 *
 *	Caveats
 *		none
 */
BOOL CAppRoster::DoCapabilitiesListMatch (	
							UserID						node_id,
							EntityID					entity_id,
							UINT						number_of_capabilities,
							PGCCApplicationCapability	* capabilities_list)
{
	BOOL    							rc = FALSE;
	CAppCapItemList						*pAppCapItemList;
	GCCError							error_value;
	APP_NODE_RECORD						*node_record;
	UINT								i;
	CCapIDContainer	                    *capability_id;

	DebugEntry(CAppRoster::DoCapabilitiesListMatch);

	if (NULL == (node_record = m_NodeRecordList2.Find(node_id)))
		return (FALSE);

	if (NULL == (pAppCapItemList = node_record->ListOfAppCapItemList2.Find(entity_id)))
	{
		/*
		**	If the record shows no capabilities and the number of passed
		**	in capabilities is zero than we got a match.
		*/
		return ((number_of_capabilities == 0) ? TRUE : FALSE);
	}
	else if (pAppCapItemList->GetCount() != number_of_capabilities)
	{
		return (FALSE);
	}


	/*
	**	If we have gotten this far we must iterate through the entire list to
	**	see if all the capabilities match.
	*/
	for (i = 0; i < number_of_capabilities; i++)
	{
		/*
		**	First we create a temporary ID to compare to the other
		**	capability IDs.
		*/
        DBG_SAVE_FILE_LINE
        capability_id = new CCapIDContainer(&capabilities_list[i]->capability_id, &error_value);
		if ((capability_id != NULL) && (error_value == GCC_NO_ERROR))
		{
			APP_CAP_ITEM			*lpAppCapData;

			//	Start with the return value equal to FALSE
			rc = FALSE;

			/*
			**	Now iterate through the complate internal capability
			**	list looking for a matching capability.
			*/
			pAppCapItemList->Reset();
			while (NULL != (lpAppCapData = pAppCapItemList->Iterate()))
			{
				if (*capability_id == *lpAppCapData->pCapID)
				{
					if (lpAppCapData->eCapType == capabilities_list[i]->capability_class.eType)
					{
						if (capabilities_list[i]->capability_class.eType ==
								GCC_UNSIGNED_MINIMUM_CAPABILITY)
						{
							if (capabilities_list[i]->capability_class.nMinOrMax ==
										lpAppCapData->nUnsignedMinimum)
							{
								rc = TRUE;
							}
						}
						else if (capabilities_list[i]->capability_class.eType ==
									GCC_UNSIGNED_MAXIMUM_CAPABILITY)
						{
							if (capabilities_list[i]->capability_class.nMinOrMax ==
										lpAppCapData->nUnsignedMaximum)
							{
								rc = TRUE;
							}
						}
						else
							rc = TRUE;
					}
					break;
				}
			}

			//	Delete the capability ID data
			capability_id->Release();

			if (rc == FALSE)
				break;
		}
		else
		{
		    if (NULL != capability_id)
		    {
		        capability_id->Release();
		    }
			break;
		}
	}

	return rc;
}

void CAppRosterList::DeleteList(void)
{
    CAppRoster *pAppRoster;
    while (NULL != (pAppRoster = Get()))
    {
        pAppRoster->Release();
    }
}



void CListOfAppCapItemList2::DeleteList(void)
{
    CAppCapItemList  *pAppCapItemList;
    while (NULL != (pAppCapItemList = Get()))
    {
        pAppCapItemList->DeleteList();
        delete pAppCapItemList;
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\arostmsg.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_APP_ROSTER);
/* 
 *	arostmsg.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Application Roster Message 
 *		Class. This	class maintains a list of application rosters, and is able
 *		to "serialize" the list into a block of memory.  It utilizes a 
 *		"Lock - UnLock" facility to ensure that the roster list memory remains
 *		valid until all interested parties are through using the object.
 *
 *	Protected Instance Variables:
 *
 *	Private Member Functions:
 *
 *	Caveats:
 *		This message container holds a list of application rosters that is very
 *		temporary.  This list should not be accessed after Free is called.  It
 *		is important for the users of this class to understand that lock should
 *		be called at least once before any of the application rosters contained
 *		in this list are deleted.
 *
 *	Author:
 *		jbo/blp
 */

#include "arostmsg.h"

/*
 *	CAppRosterMsg()
 *
 *	Public Function Description
 *		This constructor is used to create an empty Application Roster
 *		Message.
 */
CAppRosterMsg::CAppRosterMsg(void)
:
    CRefCount(MAKE_STAMP_ID('A','R','M','g')),
    m_pMsgData(NULL)
{
}
 
/*
 *	~CAppRosterMsg()
 *
 *	Public Function Description:
 *		The destructor for the CAppRosterMsg class will clean up
 *		any memory allocated during the life of the object.
 */
CAppRosterMsg::~CAppRosterMsg(void)
{
    delete m_pMsgData;
}

/*
 *	GCCError	LockApplicationRosterMessage	()
 *
 *	Public Function Description
 *		This routine is used to lock an CAppRosterMsg.  The memory
 *		necessary to hold the list of rosters is allocated and the rosters are
 *		"serialized" into the allocated memory block.
 */
GCCError CAppRosterMsg::LockApplicationRosterMessage(void)
{  
	GCCError						rc = GCC_NO_ERROR;
	PGCCApplicationRoster 		*	roster_list;
	DWORD							i;
	UINT							roster_data_length;
	LPBYTE							memory_pointer;
	UINT							number_of_rosters;

	DebugEntry(CAppRosterMsg::LockApplicationRosterMessage);

	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the list of application rosters and go ahead
	 * and serialize the data.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		CAppRoster *lpAppRoster;

		ASSERT(NULL == m_pMsgData);

		//	Here we are determining the size of the memory block.
		number_of_rosters = m_AppRosterList.GetCount();

		roster_data_length = number_of_rosters * 
				(sizeof(PGCCApplicationRoster) + ROUNDTOBOUNDARY(sizeof(GCCApplicationRoster)));
 
		m_AppRosterList.Reset();
		while (NULL != (lpAppRoster = m_AppRosterList.Iterate()))
		{
			roster_data_length += lpAppRoster->LockApplicationRoster();
		}

		/*
		 * Allocate space to hold the list of GCCApplicationRoster pointers
		 * as well as rosters and all associated data.  
		 */
		if (roster_data_length != 0)
		{
		    DBG_SAVE_FILE_LINE
			if (NULL != (m_pMsgData = new BYTE[roster_data_length]))
			{
                ::ZeroMemory(m_pMsgData, roster_data_length);
				/*
				 * Retrieve the memory pointer and save it in the list of
				 * GCCApplicationRoster pointers.
				 */
				memory_pointer = m_pMsgData;
				roster_list = (PGCCApplicationRoster *)memory_pointer;

				/*
				 * Initialize all of the roster list pointers to NULL.  Move
				 * the memory pointer past the list of pointers.  This is where
				 * the first application roster will be written.
				 */
				for (i = 0; i < number_of_rosters; i++)
				{
					roster_list[i] = NULL;
				}
				memory_pointer += number_of_rosters * sizeof(PGCCApplicationRoster);

				/*
				 * Retrieve all of the data for each application roster.
				 */
				i = 0;
				m_AppRosterList.Reset();
				while (NULL != (lpAppRoster = m_AppRosterList.Iterate()))
				{
					/*
					 * Save the pointer to the roster structure in the list.
					 */
					roster_list[i] = (PGCCApplicationRoster)memory_pointer;

					/*
					 * Move the memory pointer past the actual roster structure.
					 */
					memory_pointer += ROUNDTOBOUNDARY(sizeof(GCCApplicationRoster));

					/*
					 * Fill in the roster structure and all associated data.
					 */
					roster_data_length = lpAppRoster->GetAppRoster(roster_list[i], memory_pointer);

					/*
					 * Move the memory pointer past the roster data.  This where
					 * the next roster structure will begin.
					 */
					memory_pointer += roster_data_length;

					//	Increment the counter
					i++;
				}
			}
			else
            {
                ERROR_OUT(("CAppRosterMsg::LockApplicationRosterMessage: "
                            "can't allocate memory, size=%u", (UINT) roster_data_length));
				rc = GCC_ALLOCATION_FAILURE;
            }
		}

		/*
		**	Since we do not need the application rosters anymore it is
		**	OK to unlock them here.
		*/		
		m_AppRosterList.Reset();
		while (NULL != (lpAppRoster = m_AppRosterList.Iterate()))
		{
			lpAppRoster->UnLockApplicationRoster();
		}
	}

	if (rc != GCC_NO_ERROR)
	{
        Unlock();
	}

	return (rc);
}

/*
 *	GCCError	GetAppRosterMsg	()
 *
 *	Public Function Description
 *		This routine is used to obtain a pointer to the Application Roster
 *		list memory block used to deliver messages.
 *		This routine should not be called before LockApplicationRosterMessage is
 *		called. 
 */
GCCError	CAppRosterMsg::GetAppRosterMsg(LPBYTE *ppRosterData, ULONG *pcRosters)
{
	GCCError	rc;

	DebugEntry(CAppRosterMsg::GetAppRosterMsg);

	if (GetLockCount() > 0)
	{
		if (((m_pMsgData != NULL) && (m_AppRosterList.GetCount() != 0)) ||
			(m_AppRosterList.GetCount() == 0))
		{
			*ppRosterData = m_pMsgData;
			*pcRosters = m_AppRosterList.GetCount();
			rc = GCC_NO_ERROR;
		}
	}
	else
	{
		ERROR_OUT(("CAppRosterMsg::GetAppRosterMsg: app roster msg is not locked"));
        rc = GCC_ALLOCATION_FAILURE;
	}

	DebugExitINT(CAppRosterMsg::GetAppRosterMsg, rc);
	return rc;
}


/*
 *	void	UnLockApplicationRosterMessage	()
 *
 *	Public Function Description
 *		This member function is responsible for unlocking the data locked for 
 *		the "API" application roster after the lock count goes to zero.
 */
void CAppRosterMsg::UnLockApplicationRosterMessage(void)
{
	DebugEntry(CAppRosterMsg::UnLockApplicationRosterMessage);

	if (Unlock(FALSE) == 0)
	{
		/*
		 * Free up the memory block allocated to hold the roster
		 */
		delete m_pMsgData;
		m_pMsgData = NULL;
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}


/*
 *	GCCError	AddRosterToMessage ()
 *
 *	Public Function Description
 *		This function adds an application roster pointer to the internal list
 *		of app roster pointers.  Note that this list is very temporary and
 *		should not be accessed after the free flag is set.
 */
void CAppRosterMsg::AddRosterToMessage(CAppRoster *pAppRoster)
{
	m_AppRosterList.Append(pAppRoster);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\channel.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	channel.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for class Channel.  It contains the
 *		code necessary to implement static and assigned channels in the
 *		MCS system.
 *
 *		This is also to be the base class for other classes that represent
 *		channels in the system.  Therefore, there will be times when some
 *		of these member functions are overridden to provide different
 *		behavior.  These derived classes may or may not invoke the operations
 *		in this class.
 *
 *	Protected Instance Variables:
 *		Channel_ID
 *			This instance variable contains the channel ID that is associated
 *			with a given instance of this class.
 *		m_pDomain
 *			This is a pointer to the local provider.  Note that no messages
 *			ever sent to this provider.  This pointer is used as a parameter
 *			whenever other MCS commands are issued, since this class acts on
 *			behalf of the local provider.
 *		m_pConnToTopProvider
 *			This is a pointer to the Top Provider.  This is used when it is
 *			necessary to send requests to the Top Provider.
 *		m_pChannelList2
 *			This is a reference to the channel list that is owned and maintained
 *			by the parent domain.  It is NEVER modified by this class.
 *		m_JoinedAttachmentList
 *			This is a container that contains the list of attachments currently
 *			joined to the channel.
 *
 *	Private Member Functions:
 *		None.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */
/*
 *	Channel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the primary constructor for the Channel class.  It simply
 *		initializes the instance variable to valid values.  It leaves the
 *		attachment list empty.
 */
Channel::Channel (
        ChannelID			channel_id,
        PDomain             local_provider,
        PConnection         top_provider,
        CChannelList2      *channel_list,
        CAttachmentList    *attachment_list)
:
    Channel_ID (channel_id),
    m_pDomain(local_provider),
    m_pConnToTopProvider(top_provider),
    m_pChannelList2(channel_list),
    m_pAttachmentList(attachment_list)
{
}

/*
 *	Channel ()
 *
 *	Public
 *
 *	Functional Description:
 *		This version of the constructor is used to create a Channel object
 *		with an existing attachment.  It is otherwise the same as the primary
 *		constructor above.
 */
Channel::Channel (
        ChannelID			channel_id,
        PDomain             local_provider,
        PConnection         top_provider,
        CChannelList2      *channel_list,
        CAttachmentList    *attachment_list,
        PConnection         pConn)
:
    Channel_ID (channel_id),
    m_pDomain(local_provider),
    m_pConnToTopProvider(top_provider),
    m_pChannelList2(channel_list),
    m_pAttachmentList(attachment_list)
{
	/*
	 *	Add the initial attachment to the attachment list.
	 */
	if (pConn != NULL)
		m_JoinedAttachmentList.Append(pConn);
}

/*
 *	~Channel ()
 *
 *	Public
 *
 *	Functional Description:
 *		If the object is destroyed before the attachment list is empty, it is
 *		the responsibility of this destructor to issue channel leave indications
 *		to all locally joined users.
 */
Channel::~Channel ()
{
	CAttachment        *pAtt;
	//DWORD				type;

	/*
	 *	Iterate through the joined attachment list sending channel leave
	 *	indications to all users who are locally attached to this provider.
	 */
	m_JoinedAttachmentList.Reset();
	while (NULL != (pAtt = m_JoinedAttachmentList.Iterate()))
	{
		if (m_pAttachmentList->Find(pAtt) && pAtt->IsUserAttachment())
		{
		    PUser pUser = (PUser) pAtt;
			pUser->ChannelLeaveIndication(REASON_CHANNEL_PURGED, Channel_ID);
		}
	}
}

/*
 *	Channel_Type		GetChannelType ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function returns the type of the channel.  For a Channel object,
 *		this will always be either STATIC_CHANNEL or ASSIGNED_CHANNEL, depending
 *		on the value of the channel ID.
 */
Channel_Type Channel::GetChannelType ()
{
	/*
	 *	T.125 specifies that channels from 1 to 1000 are static.  The rest
	 *	are dynamic (for this type of Channel object, that equates to
	 *	assigned).
	 */
	return (Channel_ID <= 1000) ? STATIC_CHANNEL : ASSIGNED_CHANNEL;
}

/*
 *	BOOL	IsValid ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function returns TRUE if the Channel object is still valid, or
 *		FALSE if it is ready to be deleted.
 */
BOOL	Channel::IsValid ()
{
	CAttachment        *pAtt;
	CAttachmentList     deletion_list;

	/*
	 *	Iterate through the joined attachment list, building a list of those
	 *	attachments in the list that are no longer valid.
	 */
	m_JoinedAttachmentList.Reset();
	while (NULL != (pAtt = m_JoinedAttachmentList.Iterate()))
	{
		if (m_pAttachmentList->Find(pAtt) == FALSE)
			deletion_list.Append(pAtt);
	}

	/*
	 *	Iterate through the deletion list, removing all those attachments that
	 *	were found to be invalid above.
	 */
	while (NULL != (pAtt = deletion_list.Get()))
	{
		m_JoinedAttachmentList.Remove(pAtt);
	}

	return (! m_JoinedAttachmentList.IsEmpty());
}

/*
 *	Void	IssueMergeRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is used to cause the Channel object to issue a
 *		merge request to the pending top provier.
 */
Void	Channel::IssueMergeRequest ()
{
	Channel_Type			channel_type;
	ChannelAttributes		channel_attributes;
	CChannelAttributesList	merge_channel_list;
	CChannelIDList			purge_channel_list;

	if (m_pConnToTopProvider != NULL)
	{
		/*
		 *	Fill in the fields of the channel attributes structure so that it
		 *	accurately describes this channel.  Then put the structure into the
		 *	merge channel list.
		 */
		channel_type = GetChannelType ();
		channel_attributes.channel_type = channel_type;
		switch (channel_type)
		{
			case STATIC_CHANNEL:
				channel_attributes.u.static_channel_attributes.channel_id =
						Channel_ID;
				break;

			case ASSIGNED_CHANNEL:
				channel_attributes.u.assigned_channel_attributes.channel_id =
						Channel_ID;
				break;
		}
		merge_channel_list.Append(&channel_attributes);

		/*
		 *	Send the merge request to the indicated provider.
		 */
		m_pConnToTopProvider->MergeChannelsRequest(&merge_channel_list, &purge_channel_list);
	}
}

/*
 *	Void	ChannelJoinRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to add a new attachment to the attachment list.
 *		If the user ID is valid, this routine will also issue an automatic
 *		join confirm to the user.
 */
Void	Channel::ChannelJoinRequest (
				CAttachment        *pOrigAtt,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	/*
	 *	Make sure the attachment isn't already in the list before adding it.
	 */
	if (m_JoinedAttachmentList.Find(pOrigAtt) == FALSE)
	{
		TRACE_OUT (("Channel::ChannelJoinRequest: "
				"user %04X joining channel %04X", (UINT) uidInitiator, (UINT) Channel_ID));

		m_JoinedAttachmentList.Append(pOrigAtt);
	}

	/*
	 *	If the user ID is valid, then send a join confirm to the initiating
	 *	attachment.  Note that setting the user ID to 0 is a way of disabling
	 *	this behavior.  This is sometimes useful when adding attachments during
	 *	a domain merge.
	 */
	if (uidInitiator != 0)
	{
		pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, channel_id, Channel_ID);
    }
}

/*
 *	Void	ChannelJoinConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function performs the same operation as JoinRequest above.
 */
Void	Channel::ChannelJoinConfirm (
				CAttachment        *pOrigAtt,
				Result,
				UserID				uidInitiator,
				ChannelID			requested_id,
				ChannelID)
{
	/*
	 *	Make sure the attachment isn't already in the list before adding it.
	 */
	if (m_JoinedAttachmentList.Find(pOrigAtt) == FALSE)
	{
		TRACE_OUT (("Channel::ChannelJoinConfirm: "
				"user %04X joining channel %04X", (UINT) uidInitiator, (UINT) Channel_ID));

		m_JoinedAttachmentList.Append(pOrigAtt);
	}

	/*
	 *	Send a join confirm to the initiating attachment.
	 */
	pOrigAtt->ChannelJoinConfirm(RESULT_SUCCESSFUL, uidInitiator, requested_id, Channel_ID);
}

/*
 *	Void	ChannelLeaveRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to remove an attachment from the attachment list.
 *		A leave request will also be issued upward (unless this is the Top
 *		Provider).
 */
Void	Channel::ChannelLeaveRequest (
				CAttachment     *pOrigAtt,
				CChannelIDList *)
{
	CChannelIDList		channel_leave_list;

	/*
	 *	Make sure the attachment is in the list before trying to remove it.
	 */
	if (m_JoinedAttachmentList.Remove(pOrigAtt))
	{
		TRACE_OUT (("Channel::ChannelLeaveRequest: leaving channel %04X", Channel_ID));

		/*
		 *	Remove the attachment from the list.
		 */

		/*
		 *	If this results in an empty list, then we have more work to do.
		 */
		if (m_JoinedAttachmentList.IsEmpty())
		{
			/*
			 *	If this is not the Top Provider, send a leave request upward
			 *	to the Top Provider.
			 */
			if (! IsTopProvider())
			{
				TRACE_OUT (("Channel::ChannelLeaveRequest: "
						"sending ChannelLeaveRequest to Top Provider"));

				channel_leave_list.Append(Channel_ID);
				m_pConnToTopProvider->ChannelLeaveRequest(&channel_leave_list);
			}
		}
	}
}

/*
 *	Void	SendDataRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to send data through the channel.
 */
Void	Channel::SendDataRequest (
				CAttachment        *pOrigAtt,
				UINT				type,
				PDataPacket			data_packet)
{
	CAttachment *pAtt;

	ASSERT (Channel_ID == data_packet->GetChannelID());
	/*
	 *	If this is not the Top Provider, forward the data upward.
	 */
	if (m_pConnToTopProvider != NULL)
		m_pConnToTopProvider->SendDataRequest(data_packet);

	/*
	 *	Iterate through the attachment list, sending the data to all
	 *	the attachments (except for one from whence the data came).
	 */
	m_JoinedAttachmentList.Reset();
	while (NULL != (pAtt = m_JoinedAttachmentList.Iterate()))
	{
		if ((pAtt != pOrigAtt) || (type != MCS_SEND_DATA_INDICATION))
		{
			pAtt->SendDataIndication(type, data_packet);
		}
	}
}

/*
 *	Void	SendDataIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is used to send data through the channel.
 */
Void	Channel::SendDataIndication (
				PConnection,
				UINT				type,
				PDataPacket			data_packet)
{
	CAttachment *pAtt;

	ASSERT (Channel_ID == data_packet->GetChannelID());
	/*
	 *	Iterate through the attachment list, sending the data to all
	 *	the attachments.
	 */
	m_JoinedAttachmentList.Reset();
	while (NULL != (pAtt = m_JoinedAttachmentList.Iterate()))
	{
		pAtt->SendDataIndication(type, data_packet);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\appldr.cpp ===
//
//  User or remote site invokes applet
//

#include "precomp.h"
#include "appldr.h"
#include "cuserdta.hpp"
#include "csap.h"

#define count_of(array)		(sizeof(array) / sizeof(array[0]))


static  CRITICAL_SECTION  g_csAppLdrInfo;
static  AppLoaderInfo  g_aAppLoaderInfo[APPLET_LAST];
static  BOOL   g_fAppLdrInitialized = FALSE;

const static CHAR *g_fnAppletDLL[APPLET_LAST] = {"nmwb.dll", "nmft.dll", "nmchat.dll"};

// Chat session key
static const GUID guidNM2Chat = { 0x340f3a60, 0x7067, 0x11d0,
						 { 0xa0, 0x41, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0 } };
#define  CHAT_KEY_SIZE  25
extern struct Key CHAT_APP_PROTO_KEY;


// NetMeeting/UI,  T.120
T120Error  WINAPI  T120_LoadApplet
(
    APPLET_ID       nAppId,
    BOOL            flocal,
    T120ConfID      nConfId,
    BOOL            fNoUI,
    LPSTR           pszCmdLine
)
{
	T120Error   rc = T120_NO_ERROR;
	LPFN_CREATE_APPLET_LOADER_INTERFACE		pfnCreateInterface;

	if (nAppId >= APPLET_LAST)
	{
		ERROR_OUT(("T120_LoadApplet: invalid applet ID=%u", nAppId));
		return T120_INVALID_PARAMETER;
	}

    //
    // Check policies.  Launch & auto-launch not allowed if corp has
    // disabled applet.
    //
    RegEntry    rePol(POLICIES_KEY, HKEY_CURRENT_USER);
    switch (nAppId)
    {
        case APPLET_ID_WB:
            if (rePol.GetNumber(REGVAL_POL_NO_NEWWHITEBOARD, DEFAULT_POL_NO_NEWWHITEBOARD))
            {
                WARNING_OUT(("New WB disabled by policy, not starting"));
	            return GCC_NO_SUCH_APPLICATION;
            }
            break;

        case APPLET_ID_FT:
            if (rePol.GetNumber(REGVAL_POL_NO_FILETRANSFER_SEND, DEFAULT_POL_NO_FILETRANSFER_SEND) &&
                rePol.GetNumber(REGVAL_POL_NO_FILETRANSFER_RECEIVE, DEFAULT_POL_NO_FILETRANSFER_RECEIVE))
            {
                WARNING_OUT(("FT disabled by policy, not starting"));
                return GCC_NO_SUCH_APPLICATION;
            }
            break;

        case APPLET_ID_CHAT:
            if (rePol.GetNumber(REGVAL_POL_NO_CHAT, DEFAULT_POL_NO_CHAT))
            {
                WARNING_OUT(("Chat disabled by policy, not starting"));
                return GCC_NO_SUCH_APPLICATION;
            }
            break;
    }

	::EnterCriticalSection(&g_csAppLdrInfo);

	if (NULL != g_aAppLoaderInfo[nAppId].hLibApplet)
	{
		switch (g_aAppLoaderInfo[nAppId].eStatus)
		{
		case APPLET_CLOSING:
		case APPLET_WORK_THREAD_EXITED:
			WARNING_OUT(("T120_LoadApplet: applet is closing or work thread exited"));
			rc = GCC_APPLET_EXITING;
			break;
		default:
			if (APPLDR_NO_ERROR == g_aAppLoaderInfo[nAppId].pIAppLoader->AppletInvoke(flocal, nConfId, pszCmdLine))
			{
			    g_aAppLoaderInfo[nAppId].cLoads++;
			}
			// rc = T120_NO_ERROR;
			break;
		}
		goto MyExit;
	}

	g_aAppLoaderInfo[nAppId].hLibApplet = NmLoadLibrary(g_fnAppletDLL[nAppId],FALSE);
	if (NULL != g_aAppLoaderInfo[nAppId].hLibApplet)
	{
		pfnCreateInterface = (LPFN_CREATE_APPLET_LOADER_INTERFACE)
					::GetProcAddress(g_aAppLoaderInfo[nAppId].hLibApplet,
									CREATE_APPLET_LOADER_INTERFACE);
		if (NULL != pfnCreateInterface)
		{
			//g_aAppLoaderInfo[nAppId].pIAppLoader = (IAppletLoader*)(*pfnCreateInterface)();
			(*pfnCreateInterface)(&g_aAppLoaderInfo[nAppId].pIAppLoader);
			if (NULL != g_aAppLoaderInfo[nAppId].pIAppLoader)
			{
				if (APPLDR_NO_ERROR == g_aAppLoaderInfo[nAppId].pIAppLoader->AppletStartup(fNoUI))
				{
					if (APPLDR_NO_ERROR == g_aAppLoaderInfo[nAppId].pIAppLoader->AppletInvoke(flocal, nConfId, pszCmdLine))
					{
						g_aAppLoaderInfo[nAppId].cLoads++;
						// rc = T120_NO_ERROR;
						goto MyExit;
					}
					else
					{
						ERROR_OUT(("T120_LoadApplet: cannot invoke applet(%s), flocal=%u, nConfID=%u",
							g_fnAppletDLL[nAppId], flocal, nConfId));
					}
				}
				else
				{
					ERROR_OUT(("T120_LoadApplet: cannot start applet(%s)", g_fnAppletDLL[nAppId]));
				}

				g_aAppLoaderInfo[nAppId].pIAppLoader->ReleaseInterface();
				g_aAppLoaderInfo[nAppId].pIAppLoader = NULL;
			}
			else
			{
				ERROR_OUT(("T120_LoadApplet: Entry function of %s  failed.\n", g_fnAppletDLL[nAppId]));
			}
		}
		else
		{
			WARNING_OUT(("T120_LoadApplet: Can't find entry point of %s.\n", g_fnAppletDLL[nAppId]));
		}

		::FreeLibrary(g_aAppLoaderInfo[nAppId].hLibApplet);
		g_aAppLoaderInfo[nAppId].hLibApplet = NULL;
	}
	else
	{
		ERROR_OUT(("T120_LoadApplet: Can't open DLL %s,  err %d.\n", g_fnAppletDLL[nAppId], GetLastError()));
	}

	rc = GCC_NO_SUCH_APPLICATION;
	
MyExit:

	::LeaveCriticalSection(&g_csAppLdrInfo);
	return rc;
}


//  NetMeeting/UI shutdown
T120Error WINAPI 
T120_CloseApplet(APPLET_ID  nAppId, BOOL fNowRegardlessRefCount, BOOL fSync, DWORD dwTimeout)
{
	if (nAppId< APPLET_LAST)
	{
		if (g_fAppLdrInitialized)
		{
			::EnterCriticalSection(&g_csAppLdrInfo);
			IAppletLoader *pIAppLdr = g_aAppLoaderInfo[nAppId].pIAppLoader;
			if (NULL != pIAppLdr)
			{
				ASSERT(g_aAppLoaderInfo[nAppId].cLoads > 0);
				g_aAppLoaderInfo[nAppId].cLoads --;
				if ((! fNowRegardlessRefCount) && g_aAppLoaderInfo[nAppId].cLoads > 0)
				{
					pIAppLdr = NULL; // do not free the library
				}
			}
			::LeaveCriticalSection(&g_csAppLdrInfo);

			if (NULL != pIAppLdr)
			{
                // AppletCleanup() must be outside of the critical section
                // because applet worker thread will call AppletStatus() before
                // exiting its worker thread.
                switch (pIAppLdr->AppletCleanup(5000)) // always synchronous shutdown
                {
                case APPLDR_NO_ERROR :
                    // we are closing this applet
					g_aAppLoaderInfo[nAppId].eStatus = APPLET_CLOSING;

                    // it is safe to unload the library
   					::FreeLibrary(g_aAppLoaderInfo[nAppId].hLibApplet);
   					g_aAppLoaderInfo[nAppId].hLibApplet = NULL;
					break;

			    case APPLDR_CANCEL_EXIT:
					//
					// The app didn't want to be unloaded
					//
					::EnterCriticalSection(&g_csAppLdrInfo);
					g_aAppLoaderInfo[nAppId].cLoads++;
					g_aAppLoaderInfo[nAppId].pIAppLoader = pIAppLdr;
					::LeaveCriticalSection(&g_csAppLdrInfo);
    				return GCC_APPLET_CANCEL_EXIT;

			    default:
			        break;
				}
			}
		}
		return T120_NO_ERROR;
	}
	else
	{
		ERROR_OUT(("T120_CloseApplet: invalid applet ID=%u", nAppId));
	}
	return T120_INVALID_PARAMETER;
}


T120Error WINAPI 
T120_QueryApplet(APPLET_ID  nAppId, APPLET_QUERY_ID eQueryId)
{
	if (nAppId< APPLET_LAST)
	{
		if (g_fAppLdrInitialized)
		{
			::EnterCriticalSection(&g_csAppLdrInfo);
			IAppletLoader *pIAppLdr = g_aAppLoaderInfo[nAppId].pIAppLoader;
			::LeaveCriticalSection(&g_csAppLdrInfo);
			if (NULL != pIAppLdr)
			{
				if (APPLET_QUERY_NM2xNODE == eQueryId)
				{
					pIAppLdr->OnNM2xNodeJoin();
				}
				else if (APPLDR_CANCEL_EXIT == pIAppLdr->AppletQuery(eQueryId))
				{
                    return GCC_APPLET_CANCEL_EXIT;
                }
			}
		}
	    return		T120_NO_ERROR;
	}
	else
	{
		ERROR_OUT(("T120_CloseApplet: invalid applet ID=%u", nAppId));
	}
	return T120_INVALID_PARAMETER;
}


// Applet itself
T120Error WINAPI 
T120_AppletStatus(APPLET_ID  nAppId, APPLET_STATUS  status)
{
	if (nAppId < APPLET_LAST)
	{
		if (g_fAppLdrInitialized)
		{
			::EnterCriticalSection(&g_csAppLdrInfo);

			g_aAppLoaderInfo[nAppId].eStatus = status;

			switch (status)
			{
			case APPLET_WORK_THREAD_EXITED:
				if (NULL != g_aAppLoaderInfo[nAppId].pIAppLoader)
				{
					g_aAppLoaderInfo[nAppId].pIAppLoader->ReleaseInterface();
					g_aAppLoaderInfo[nAppId].pIAppLoader = NULL;
				}
				break;
			case APPLET_LIBRARY_FREED:
				// clean up this entry
				::ZeroMemory(&g_aAppLoaderInfo[nAppId], sizeof(g_aAppLoaderInfo[0]));
				break;
			}

			::LeaveCriticalSection(&g_csAppLdrInfo);
		}
		return T120_NO_ERROR;
	}
	else
	{
		ERROR_OUT(("T120_AppletStatus: invalid applet ID=%u", nAppId));
	}
	return T120_INVALID_PARAMETER;
}


T120Error AppLdr_Initialize(void)
{ 
	ASSERT(count_of(g_aAppLoaderInfo) == APPLET_LAST);

	::InitializeCriticalSection(&g_csAppLdrInfo);
	
	// clean all entries
	::ZeroMemory(g_aAppLoaderInfo, sizeof(g_aAppLoaderInfo));

	::CreateH221AppKeyFromGuid(CHAT_APP_PROTO_KEY.u.h221_non_standard.value,
								(GUID *)&guidNM2Chat );
	CHAT_APP_PROTO_KEY.choice = h221_non_standard_chosen;
	CHAT_APP_PROTO_KEY.u.h221_non_standard.length = CHAT_KEY_SIZE;

	g_fAppLdrInitialized = TRUE;
	return T120_NO_ERROR;
}


void AppLdr_Shutdown(void)
{
	g_fAppLdrInitialized = FALSE;

	for (ULONG i = 0; i < APPLET_LAST; i++)
	{
		if (NULL != g_aAppLoaderInfo[i].pIAppLoader)
		{
			APPLDR_RESULT rc = g_aAppLoaderInfo[i].pIAppLoader->AppletCleanup(5000); // always synchronous shutdown
			ASSERT(APPLDR_NO_ERROR == rc);

            // it is safe to unload the library
            ::FreeLibrary(g_aAppLoaderInfo[i].hLibApplet);
            g_aAppLoaderInfo[i].hLibApplet = NULL;
		}
	}

	// clean all entries
	::ZeroMemory(g_aAppLoaderInfo, sizeof(g_aAppLoaderInfo));

	::DeleteCriticalSection(&g_csAppLdrInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\cnpcoder.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MSMCSTCP);
/*
 *	cnpcoder.cpp
 *	
 *	Copyright (c) 1999 by Microsoft Corporation
 *
 *	Abstract:
 *		This is the implementation file for the CCNPCoder class.  This class
 *		is responsible for encoding and decoding CNP (T.123 annex B) PDU's using ASN.1 
 *		encoding rules via the ASN.1 toolkit.  This class is also capable
 *		of determining the size of both the encoded and decoded PDU's. 
 *
 *	Static Variables:
 *
 *	Caveats:
 *		Only one instance of this class should be in existance at any one time
 *		due to the static variable.
 *
 *	Author:
 *		Xin Liu
 */

/*
 *	External Interfaces
 */
#include <string.h>
#include "cnpcoder.h"

/*
 *	This is a global variable that has a pointer to the one CNP coder
 */
CCNPCoder	*g_CNPCoder = NULL;

/*
 *	CCNPCoder ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the CCNPCoder class.  It initializes
 *		the ASN.1 encoder/decoder and sets the encoding rules to the
 *		Packed-Aligned variant.
 */
CCNPCoder::CCNPCoder ()
        :m_pEncInfo(NULL),
         m_pDecInfo(NULL)
{
}

BOOL CCNPCoder::Init ( void )
{
    BOOL fRet = FALSE;
    CNPPDU_Module_Startup();
    if (CNPPDU_Module != NULL)
    {
        if (ASN1_CreateEncoder(
            CNPPDU_Module,	// ptr to mdule
            &m_pEncInfo,	// ptr to encoder info
            NULL,			// buffer ptr
            0,				// buffer size
            NULL)			// parent ptr
            == ASN1_SUCCESS)
        {
            ASSERT(m_pEncInfo != NULL);
            fRet = (ASN1_CreateDecoder(CNPPDU_Module,	// ptr to mdule
                                       &m_pDecInfo,	// ptr to decoder info
                                       NULL,			// buffer ptr
                                       0,				// buffer size
                                       NULL)			// parent ptr
                    == ASN1_SUCCESS);
            ASSERT(fRet && m_pDecInfo != NULL);
        }
    }
    ASSERT(fRet);
    return fRet;
}

/*
 *	~CCNPCoder ()
 *
 *	Public Functional Description:
 *		This is a virtual destructor.  It is used to clean up after ASN.1.
 */
CCNPCoder::~CCNPCoder ()
{
    if (CNPPDU_Module != NULL)
    {
        ASN1_CloseEncoder(m_pEncInfo);
        ASN1_CloseDecoder(m_pDecInfo);
        CNPPDU_Module_Cleanup();
    }
}

/*
 *	Encode ()
 *
 *	Public Functional Description:
 *		This function encodes CNP Protocol Data Units (PDU's) into ASN.1 
 *		compliant byte streams using the ASN.1 toolkit.
 *		The coder allocates the buffer space for the encoded data.
 */
BOOL	CCNPCoder::Encode(LPVOID		pdu_structure,
                          int			pdu_type,
                          UINT                  nEncodingRule_not_used,
                          LPBYTE		*encoding_buffer,
                          UINT                  *encoding_buffer_length)
{
    BOOL                  fRet = FALSE;
    int                   return_value;
    
    return_value = ASN1_Encode(m_pEncInfo,	// ptr to encoder info
                               pdu_structure,	// pdu data structure
                               pdu_type,        // pdu id
                               ASN1ENCODE_ALLOCATEBUFFER, // flags
                               NULL,			// do not provide buffer
                               0);			// buffer size if provided

    if (ASN1_FAILED(return_value))
    {
        ERROR_OUT(("CCNPCoder::Encode: ASN1_Encode failed, err=%d .",
                   return_value));
        ASSERT(FALSE);
        fRet = FALSE;
        goto MyExit;
    }
    ASSERT(return_value == ASN1_SUCCESS);
    fRet = TRUE;
    // len of encoded data in buffer
    *encoding_buffer_length = m_pEncInfo->len;
    // buffer to encode into
    *encoding_buffer = m_pEncInfo->buf;
    
 MyExit:
      
    return fRet;
}

/*
 *	Decode ()
 *
 *	Public Functional Description:
 *		This function decodes ASN.1 compliant byte streams into the
 *		appropriate CNP PDU structures using the ASN.1 toolkit.
 */
BOOL	CCNPCoder::Decode(LPBYTE		encoded_buffer,
                          UINT		        encoded_buffer_length,
                          int			pdu_type,
                          UINT		        nEncodingRule_not_used,
                          LPVOID		*pdecoding_buffer,
                          UINT		        *pdecoding_buffer_length)
{
    BOOL	          fRet = FALSE;   
    int		          return_value;
    ASN1optionparam_s     OptParam;

    return_value = ASN1_Decode(m_pDecInfo,	// ptr to decoder info
                               pdecoding_buffer,			// destination buffer
                               pdu_type,					// pdu type
                               ASN1DECODE_SETBUFFER,		// flags
                               encoded_buffer,				// source buffer
                               encoded_buffer_length);		// source buffer size
    if (ASN1_FAILED(return_value))
    {
        ERROR_OUT(("CNPCoder::Decode: ASN1_Decode failed, err=%d", return_value));
        ASSERT(FALSE);
        goto MyExit;
    }
      
    OptParam.eOption = ASN1OPT_GET_DECODED_BUFFER_SIZE;
    return_value = ASN1_GetDecoderOption(m_pDecInfo, &OptParam);
    if (ASN1_FAILED(return_value))
    {
        ERROR_OUT(("CCNPCoder::Decode: ASN1_GetDecoderOption failed, err=%d", return_value));
        ASSERT(FALSE);
        goto MyExit;
    }
    *pdecoding_buffer_length = OptParam.cbRequiredDecodedBufSize;
      
    ASSERT(return_value == ASN1_SUCCESS);
    ASSERT(*pdecoding_buffer_length > 0);
      
    fRet = TRUE;
      
 MyExit:

    return fRet;
}

void CCNPCoder::FreeEncoded (PUChar encoded_buffer)
{
    ASN1_FreeEncoded(m_pEncInfo, encoded_buffer);
}

void CCNPCoder::FreeDecoded (int pdu_type, LPVOID decoded_buffer)
{
    ASN1_FreeDecoded(m_pDecInfo, decoded_buffer, pdu_type);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\cnppdu.h ===
/* Copyright (C) Microsoft Corporation, 1999. All rights reserved. */
/* ASN.1 definitions for Connection Negotiation Protocol (GNP) */

#ifndef _CNPPDU_Module_H_
#define _CNPPDU_Module_H_

#include "msper.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct CNP_TransportAddress_ipSourceRoute_route * PCNP_TransportAddress_ipSourceRoute_route;

typedef struct CNP_TransportAddress_ipAddress_nonStandardParameters * PCNP_TransportAddress_ipAddress_nonStandardParameters;

typedef struct CNP_TransportAddress_ipSourceRoute_nonStandardParameters * PCNP_TransportAddress_ipSourceRoute_nonStandardParameters;

typedef struct CNP_TransportAddress_ipxAddress_nonStandardParameters * PCNP_TransportAddress_ipxAddress_nonStandardParameters;

typedef struct CNP_TransportAddress_ip6Address_nonStandardParameters * PCNP_TransportAddress_ip6Address_nonStandardParameters;

typedef struct CNP_NonStandardPDU_nonStandardParameters * PCNP_NonStandardPDU_nonStandardParameters;

typedef struct ErrorPDU_nonStandardParameters * PErrorPDU_nonStandardParameters;

typedef struct DisconnectRequestPDU_nonStandardParameters * PDisconnectRequestPDU_nonStandardParameters;

typedef struct ConnectConfirmPDU_nonStandardParameters * PConnectConfirmPDU_nonStandardParameters;

typedef struct ConnectRequestPDU_nonStandardParameters * PConnectRequestPDU_nonStandardParameters;

typedef struct ConnectRequestPDU_unreliableSecurityProtocols * PConnectRequestPDU_unreliableSecurityProtocols;

typedef struct ConnectRequestPDU_reliableTransportProtocols * PConnectRequestPDU_reliableTransportProtocols;

typedef struct UnreliableTransportProtocol_nonStandardParameters * PUnreliableTransportProtocol_nonStandardParameters;

typedef struct ReliableTransportProtocol_nonStandardParameters * PReliableTransportProtocol_nonStandardParameters;

typedef struct PrivatePartyNumber_nonStandardParameters * PPrivatePartyNumber_nonStandardParameters;

typedef struct PublicPartyNumber_nonStandardParameters * PPublicPartyNumber_nonStandardParameters;

typedef struct DisconnectRequestPDU_destinationAddress * PDisconnectRequestPDU_destinationAddress;

typedef struct ConnectRequestPDU_destinationAddress * PConnectRequestPDU_destinationAddress;

typedef struct ConnectRequestPDU_unreliableTransportProtocols * PConnectRequestPDU_unreliableTransportProtocols;

typedef struct ConnectRequestPDU_reliableSecurityProtocols * PConnectRequestPDU_reliableSecurityProtocols;

typedef struct CNP_TransportAddress_ipSourceRoute_route_Seq {
    ASN1uint32_t length;
    ASN1octet_t value[4];
} CNP_TransportAddress_ipSourceRoute_route_Seq;

typedef ASN1char_t NumberDigits[129];

typedef ASN1uint16_t TPDUSize;

typedef ASN1uint16_t CNP_Priority;

typedef ASN1objectidentifier_t ProtocolIdentifier;

typedef struct CNP_TransportAddress_ipSourceRoute_route {
    PCNP_TransportAddress_ipSourceRoute_route next;
    CNP_TransportAddress_ipSourceRoute_route_Seq value;
} CNP_TransportAddress_ipSourceRoute_route_Element;

typedef struct CNP_TransportAddress_ip6Address {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    struct CNP_TransportAddress_ip6Address_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[16];
    } ip;
    ASN1uint16_t port;
#   define CNP_TransportAddress_ip6Address_nonStandardParameters_present 0x80
    PCNP_TransportAddress_ip6Address_nonStandardParameters nonStandardParameters;
} CNP_TransportAddress_ip6Address;

typedef struct CNP_TransportAddress_ipxAddress {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    struct CNP_TransportAddress_ipxAddress_node_node {
	ASN1uint32_t length;
	ASN1octet_t value[6];
    } node;
    struct CNP_TransportAddress_ipxAddress_netnum_netnum {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } netnum;
    struct CNP_TransportAddress_ipxAddress_port_port {
	ASN1uint32_t length;
	ASN1octet_t value[2];
    } port;
#   define CNP_TransportAddress_ipxAddress_nonStandardParameters_present 0x80
    PCNP_TransportAddress_ipxAddress_nonStandardParameters nonStandardParameters;
} CNP_TransportAddress_ipxAddress;

typedef struct CNP_TransportAddress_ipAddress {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    struct CNP_TransportAddress_ipAddress_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
#   define CNP_TransportAddress_ipAddress_nonStandardParameters_present 0x80
    PCNP_TransportAddress_ipAddress_nonStandardParameters nonStandardParameters;
} CNP_TransportAddress_ipAddress;

typedef struct H221NonStandard {
    ASN1uint16_t t35CountryCode;
    ASN1uint16_t t35Extension;
    ASN1uint16_t manufacturerCode;
} H221NonStandard;

typedef struct NonStandardIdentifier {
    ASN1choice_t choice;
    union {
#	define object_chosen 1
	ASN1objectidentifier_t object;
#	define h221NonStandard_chosen 2
	H221NonStandard h221NonStandard;
    } u;
} NonStandardIdentifier;

typedef struct CNP_NonStandardParameter {
    NonStandardIdentifier nonStandardIdentifier;
    ASN1octetstring_t data;
} CNP_NonStandardParameter;

typedef struct PublicTypeOfNumber {
    ASN1choice_t choice;
    union {
#	define PublicTypeOfNumber_unknown_chosen 1
#	define internationalNumber_chosen 2
#	define nationalNumber_chosen 3
#	define networkSpecificNumber_chosen 4
#	define subscriberNumber_chosen 5
#	define PublicTypeOfNumber_abbreviatedNumber_chosen 6
#	define nonStandardPublicTypeOfNumber_chosen 7
	CNP_NonStandardParameter nonStandardPublicTypeOfNumber;
    } u;
} PublicTypeOfNumber;

typedef struct PublicPartyNumber {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PublicTypeOfNumber publicTypeOfNumber;
    NumberDigits publicNumberDigits;
#   define PublicPartyNumber_nonStandardParameters_present 0x80
    PPublicPartyNumber_nonStandardParameters nonStandardParameters;
} PublicPartyNumber;

typedef struct PrivateTypeOfNumber {
    ASN1choice_t choice;
    union {
#	define PrivateTypeOfNumber_unknown_chosen 1
#	define level2RegionalNumber_chosen 2
#	define level1RegionalNumber_chosen 3
#	define pISNSpecificNumber_chosen 4
#	define localNumber_chosen 5
#	define PrivateTypeOfNumber_abbreviatedNumber_chosen 6
#	define nonStandardPrivateTypeOfNumber_chosen 7
	CNP_NonStandardParameter nonStandardPrivateTypeOfNumber;
    } u;
} PrivateTypeOfNumber;

typedef struct PrivatePartyNumber {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    PrivateTypeOfNumber privateTypeOfNumber;
    NumberDigits privateNumberDigits;
#   define PrivatePartyNumber_nonStandardParameters_present 0x80
    PPrivatePartyNumber_nonStandardParameters nonStandardParameters;
} PrivatePartyNumber;

typedef struct PartyNumber {
    ASN1choice_t choice;
    union {
#	define publicNumber_chosen 1
	PublicPartyNumber publicNumber;
#	define dataPartyNumber_chosen 2
	NumberDigits dataPartyNumber;
#	define telexPartyNumber_chosen 3
	NumberDigits telexPartyNumber;
#	define privateNumber_chosen 4
	PrivatePartyNumber privateNumber;
#	define nationalStandardPartyNumber_chosen 5
	NumberDigits nationalStandardPartyNumber;
#	define nonStandardPartyNumber_chosen 6
	CNP_NonStandardParameter nonStandardPartyNumber;
    } u;
} PartyNumber;

typedef struct ReliableTransportProtocolType {
    ASN1choice_t choice;
    union {
#	define cnp_chosen 1
#	define x224_chosen 2
#	define map_chosen 3
#	define ReliableTransportProtocolType_nonStandardTransportProtocol_chosen 4
	CNP_NonStandardParameter nonStandardTransportProtocol;
    } u;
} ReliableTransportProtocolType;

typedef struct ReliableTransportProtocol {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ReliableTransportProtocolType type;
    TPDUSize maxTPDUSize;
#   define ReliableTransportProtocol_nonStandardParameters_present 0x80
    PReliableTransportProtocol_nonStandardParameters nonStandardParameters;
} ReliableTransportProtocol;

typedef struct UnreliableTransportProtocolType {
    ASN1choice_t choice;
    union {
#	define x234_chosen 1
#	define UnreliableTransportProtocolType_nonStandardTransportProtocol_chosen 2
	CNP_NonStandardParameter nonStandardTransportProtocol;
    } u;
} UnreliableTransportProtocolType;

typedef struct UnreliableSecurityProtocol {
    ASN1choice_t choice;
    union {
#	define UnreliableSecurityProtocol_none_chosen 1
#	define UnreliableSecurityProtocol_ipsecIKEKeyManagement_chosen 2
#	define UnreliableSecurityProtocol_ipsecManualKeyManagement_chosen 3
#	define UnreliableSecurityProtocol_physical_chosen 4
#	define UnreliableSecurityProtocol_nonStandardSecurityProtocol_chosen 5
	CNP_NonStandardParameter nonStandardSecurityProtocol;
    } u;
} UnreliableSecurityProtocol;

typedef struct X274WithSAIDInfo {
    ASN1octetstring_t localSAID;
    ASN1octetstring_t peerSAID;
} X274WithSAIDInfo;

typedef struct ConnectRequestPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
    ASN1bool_t reconnectRequested;
#   define priority_present 0x80
    CNP_Priority priority;
#   define reliableTransportProtocols_present 0x40
    PConnectRequestPDU_reliableTransportProtocols reliableTransportProtocols;
#   define reliableSecurityProtocols_present 0x20
    PConnectRequestPDU_reliableSecurityProtocols reliableSecurityProtocols;
#   define unreliableTransportProtocols_present 0x10
    PConnectRequestPDU_unreliableTransportProtocols unreliableTransportProtocols;
#   define unreliableSecurityProtocols_present 0x8
    PConnectRequestPDU_unreliableSecurityProtocols unreliableSecurityProtocols;
#   define ConnectRequestPDU_destinationAddress_present 0x4
    PConnectRequestPDU_destinationAddress destinationAddress;
#   define ConnectRequestPDU_nonStandardParameters_present 0x2
    PConnectRequestPDU_nonStandardParameters nonStandardParameters;
} ConnectRequestPDU;

typedef struct DisconnectReason {
    ASN1choice_t choice;
    union {
#	define unacceptableVersion_chosen 1
#	define incompatibleParameters_chosen 2
#	define securityDenied_chosen 3
#	define destinationUnreachable_chosen 4
#	define userRejected_chosen 5
#	define userInitiated_chosen 6
#	define protocolError_chosen 7
#	define unspecifiedFailure_chosen 8
#	define routeToAlternate_chosen 9
#	define nonStandardDisconnectReason_chosen 10
	CNP_NonStandardParameter nonStandardDisconnectReason;
    } u;
} DisconnectReason;

typedef struct RejectCause {
    ASN1choice_t choice;
    union {
#	define unrecognizedPDU_chosen 1
#	define invalidParameter_chosen 2
#	define causeUnspecified_chosen 3
#	define nonStandardRejectCause_chosen 4
	CNP_NonStandardParameter nonStandardRejectCause;
    } u;
} RejectCause;

typedef struct ErrorPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    RejectCause rejectCause;
    ASN1octetstring_t rejectedPDU;
#   define ErrorPDU_nonStandardParameters_present 0x80
    PErrorPDU_nonStandardParameters nonStandardParameters;
} ErrorPDU;

typedef struct CNP_NonStandardPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define CNP_NonStandardPDU_nonStandardParameters_present 0x80
    PCNP_NonStandardPDU_nonStandardParameters nonStandardParameters;
} CNP_NonStandardPDU;

typedef struct CNP_TransportAddress_ipAddress_nonStandardParameters {
    PCNP_TransportAddress_ipAddress_nonStandardParameters next;
    CNP_NonStandardParameter value;
} CNP_TransportAddress_ipAddress_nonStandardParameters_Element;

typedef struct CNP_TransportAddress_ipSourceRoute_nonStandardParameters {
    PCNP_TransportAddress_ipSourceRoute_nonStandardParameters next;
    CNP_NonStandardParameter value;
} CNP_TransportAddress_ipSourceRoute_nonStandardParameters_Element;

typedef struct CNP_TransportAddress_ipSourceRoute_routing {
    ASN1choice_t choice;
    union {
#	define strict_chosen 1
#	define loose_chosen 2
#	define nonStandardRouting_chosen 3
	CNP_NonStandardParameter nonStandardRouting;
    } u;
} CNP_TransportAddress_ipSourceRoute_routing;

typedef struct CNP_TransportAddress_ipxAddress_nonStandardParameters {
    PCNP_TransportAddress_ipxAddress_nonStandardParameters next;
    CNP_NonStandardParameter value;
} CNP_TransportAddress_ipxAddress_nonStandardParameters_Element;

typedef struct CNP_TransportAddress_ip6Address_nonStandardParameters {
    PCNP_TransportAddress_ip6Address_nonStandardParameters next;
    CNP_NonStandardParameter value;
} CNP_TransportAddress_ip6Address_nonStandardParameters_Element;

typedef struct CNP_NonStandardPDU_nonStandardParameters {
    PCNP_NonStandardPDU_nonStandardParameters next;
    CNP_NonStandardParameter value;
} CNP_NonStandardPDU_nonStandardParameters_Element;

typedef struct ErrorPDU_nonStandardParameters {
    PErrorPDU_nonStandardParameters next;
    CNP_NonStandardParameter value;
} ErrorPDU_nonStandardParameters_Element;

typedef struct DisconnectRequestPDU_nonStandardParameters {
    PDisconnectRequestPDU_nonStandardParameters next;
    CNP_NonStandardParameter value;
} DisconnectRequestPDU_nonStandardParameters_Element;

typedef struct ConnectConfirmPDU_nonStandardParameters {
    PConnectConfirmPDU_nonStandardParameters next;
    CNP_NonStandardParameter value;
} ConnectConfirmPDU_nonStandardParameters_Element;

typedef struct ConnectRequestPDU_nonStandardParameters {
    PConnectRequestPDU_nonStandardParameters next;
    CNP_NonStandardParameter value;
} ConnectRequestPDU_nonStandardParameters_Element;

typedef struct ConnectRequestPDU_unreliableSecurityProtocols {
    PConnectRequestPDU_unreliableSecurityProtocols next;
    UnreliableSecurityProtocol value;
} ConnectRequestPDU_unreliableSecurityProtocols_Element;

typedef struct ConnectRequestPDU_reliableTransportProtocols {
    PConnectRequestPDU_reliableTransportProtocols next;
    ReliableTransportProtocol value;
} ConnectRequestPDU_reliableTransportProtocols_Element;

typedef struct UnreliableTransportProtocol_nonStandardParameters {
    PUnreliableTransportProtocol_nonStandardParameters next;
    CNP_NonStandardParameter value;
} UnreliableTransportProtocol_nonStandardParameters_Element;

typedef struct ReliableTransportProtocol_nonStandardParameters {
    PReliableTransportProtocol_nonStandardParameters next;
    CNP_NonStandardParameter value;
} ReliableTransportProtocol_nonStandardParameters_Element;

typedef struct PrivatePartyNumber_nonStandardParameters {
    PPrivatePartyNumber_nonStandardParameters next;
    CNP_NonStandardParameter value;
} PrivatePartyNumber_nonStandardParameters_Element;

typedef struct PublicPartyNumber_nonStandardParameters {
    PPublicPartyNumber_nonStandardParameters next;
    CNP_NonStandardParameter value;
} PublicPartyNumber_nonStandardParameters_Element;

typedef struct CNP_TransportAddress_ipSourceRoute {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    struct CNP_TransportAddress_ipSourceRoute_ip_ip {
	ASN1uint32_t length;
	ASN1octet_t value[4];
    } ip;
    ASN1uint16_t port;
    PCNP_TransportAddress_ipSourceRoute_route route;
    CNP_TransportAddress_ipSourceRoute_routing routing;
#   define CNP_TransportAddress_ipSourceRoute_nonStandardParameters_present 0x80
    PCNP_TransportAddress_ipSourceRoute_nonStandardParameters nonStandardParameters;
} CNP_TransportAddress_ipSourceRoute;

typedef struct CNP_TransportAddress {
    ASN1choice_t choice;
    union {
#	define ipAddress_chosen 1
	CNP_TransportAddress_ipAddress ipAddress;
#	define ipSourceRoute_chosen 2
	CNP_TransportAddress_ipSourceRoute ipSourceRoute;
#	define ipxAddress_chosen 3
	CNP_TransportAddress_ipxAddress ipxAddress;
#	define ip6Address_chosen 4
	CNP_TransportAddress_ip6Address ip6Address;
#	define netBios_chosen 5
	struct CNP_TransportAddress_netBios_netBios {
	    ASN1uint32_t length;
	    ASN1octet_t value[16];
	} netBios;
#	define nsap_chosen 6
	struct CNP_TransportAddress_nsap_nsap {
	    ASN1uint32_t length;
	    ASN1octet_t value[20];
	} nsap;
#	define nonStandardTransportAddress_chosen 7
	CNP_NonStandardParameter nonStandardTransportAddress;
    } u;
} CNP_TransportAddress;

typedef struct AliasAddress {
    ASN1choice_t choice;
    union {
#	define e164Address_chosen 1
	NumberDigits e164Address;
#	define name_chosen 2
	ASN1char16string_t name;
#	define url_chosen 3
	ASN1char_t url[513];
#	define transportAddress_chosen 4
	CNP_TransportAddress transportAddress;
#	define emailAddress_chosen 5
	ASN1char_t emailAddress[513];
#	define partyNumber_chosen 6
	PartyNumber partyNumber;
#	define nonStandardAliasAddress_chosen 7
	CNP_NonStandardParameter nonStandardAliasAddress;
    } u;
} AliasAddress;

typedef struct ReliableSecurityProtocol {
    ASN1choice_t choice;
    union {
#	define ReliableSecurityProtocol_none_chosen 1
#	define tls_chosen 2
#	define ssl_chosen 3
#	define ReliableSecurityProtocol_ipsecIKEKeyManagement_chosen 4
#	define ReliableSecurityProtocol_ipsecManualKeyManagement_chosen 5
#	define x274WithoutSAID_chosen 6
#	define x274WithSAID_chosen 7
	X274WithSAIDInfo x274WithSAID;
#	define ReliableSecurityProtocol_physical_chosen 8
#	define gssApiX224_chosen 9
#	define ReliableSecurityProtocol_nonStandardSecurityProtocol_chosen 10
	CNP_NonStandardParameter nonStandardSecurityProtocol;
    } u;
} ReliableSecurityProtocol;

typedef struct UnreliableTransportProtocol {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    UnreliableTransportProtocolType type;
    TPDUSize maxTPDUSize;
    CNP_TransportAddress sourceAddress;
#   define sourceTSAP_present 0x80
    ASN1octetstring_t sourceTSAP;
#   define UnreliableTransportProtocol_nonStandardParameters_present 0x40
    PUnreliableTransportProtocol_nonStandardParameters nonStandardParameters;
} UnreliableTransportProtocol;

typedef struct ConnectConfirmPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ProtocolIdentifier protocolIdentifier;
#   define ConnectConfirmPDU_reliableTransportProtocol_present 0x80
    ReliableTransportProtocol reliableTransportProtocol;
#   define ConnectConfirmPDU_reliableSecurityProtocol_present 0x40
    ReliableSecurityProtocol reliableSecurityProtocol;
#   define ConnectConfirmPDU_unreliableTransportProtocol_present 0x20
    UnreliableTransportProtocol unreliableTransportProtocol;
#   define ConnectConfirmPDU_unreliableSecurityProtocol_present 0x10
    UnreliableSecurityProtocol unreliableSecurityProtocol;
#   define ConnectConfirmPDU_nonStandardParameters_present 0x8
    PConnectConfirmPDU_nonStandardParameters nonStandardParameters;
} ConnectConfirmPDU;

typedef struct DisconnectRequestPDU {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    DisconnectReason disconnectReason;
#   define DisconnectRequestPDU_reliableTransportProtocol_present 0x80
    ReliableTransportProtocol reliableTransportProtocol;
#   define DisconnectRequestPDU_reliableSecurityProtocol_present 0x40
    ReliableSecurityProtocol reliableSecurityProtocol;
#   define DisconnectRequestPDU_unreliableTransportProtocol_present 0x20
    UnreliableTransportProtocol unreliableTransportProtocol;
#   define DisconnectRequestPDU_unreliableSecurityProtocol_present 0x10
    UnreliableSecurityProtocol unreliableSecurityProtocol;
#   define DisconnectRequestPDU_destinationAddress_present 0x8
    PDisconnectRequestPDU_destinationAddress destinationAddress;
#   define DisconnectRequestPDU_nonStandardParameters_present 0x4
    PDisconnectRequestPDU_nonStandardParameters nonStandardParameters;
} DisconnectRequestPDU;

typedef struct CNPPDU {
    ASN1choice_t choice;
    union {
#	define connectRequest_chosen 1
	ConnectRequestPDU connectRequest;
#	define connectConfirm_chosen 2
	ConnectConfirmPDU connectConfirm;
#	define disconnectRequest_chosen 3
	DisconnectRequestPDU disconnectRequest;
#	define error_chosen 4
	ErrorPDU error;
#	define nonStandardCNPPDU_chosen 5
	CNP_NonStandardPDU nonStandardCNPPDU;
    } u;
} CNPPDU;
#define CNPPDU_PDU 0
#define SIZE_CNPPDU_Module_PDU_0 sizeof(CNPPDU)

typedef struct DisconnectRequestPDU_destinationAddress {
    PDisconnectRequestPDU_destinationAddress next;
    AliasAddress value;
} DisconnectRequestPDU_destinationAddress_Element;

typedef struct ConnectRequestPDU_destinationAddress {
    PConnectRequestPDU_destinationAddress next;
    AliasAddress value;
} ConnectRequestPDU_destinationAddress_Element;

typedef struct ConnectRequestPDU_unreliableTransportProtocols {
    PConnectRequestPDU_unreliableTransportProtocols next;
    UnreliableTransportProtocol value;
} ConnectRequestPDU_unreliableTransportProtocols_Element;

typedef struct ConnectRequestPDU_reliableSecurityProtocols {
    PConnectRequestPDU_reliableSecurityProtocols next;
    ReliableSecurityProtocol value;
} ConnectRequestPDU_reliableSecurityProtocols_Element;

extern ASN1objectidentifier_t t123AnnexBProtocolId;

extern ASN1module_t CNPPDU_Module;
extern void ASN1CALL CNPPDU_Module_Startup(void);
extern void ASN1CALL CNPPDU_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */
    extern int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_route val);
	extern void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_route_ElmFn(PCNP_TransportAddress_ipSourceRoute_route val);
    extern int ASN1CALL ASN1Enc_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipAddress_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipAddress_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn(PCNP_TransportAddress_ipAddress_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn(PCNP_TransportAddress_ipSourceRoute_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipxAddress_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipxAddress_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn(PCNP_TransportAddress_ipxAddress_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ip6Address_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ip6Address_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn(PCNP_TransportAddress_ip6Address_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_CNP_NonStandardPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_NonStandardPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_CNP_NonStandardPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_NonStandardPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_CNP_NonStandardPDU_nonStandardParameters_ElmFn(PCNP_NonStandardPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ErrorPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PErrorPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ErrorPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PErrorPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ErrorPDU_nonStandardParameters_ElmFn(PErrorPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_DisconnectRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDisconnectRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_DisconnectRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDisconnectRequestPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_DisconnectRequestPDU_nonStandardParameters_ElmFn(PDisconnectRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ConnectConfirmPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConnectConfirmPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ConnectConfirmPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConnectConfirmPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ConnectConfirmPDU_nonStandardParameters_ElmFn(PConnectConfirmPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ConnectRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ConnectRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ConnectRequestPDU_nonStandardParameters_ElmFn(PConnectRequestPDU_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_unreliableSecurityProtocols val);
    extern int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_unreliableSecurityProtocols val);
	extern void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn(PConnectRequestPDU_unreliableSecurityProtocols val);
    extern int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableTransportProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_reliableTransportProtocols val);
    extern int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableTransportProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_reliableTransportProtocols val);
	extern void ASN1CALL ASN1Free_ConnectRequestPDU_reliableTransportProtocols_ElmFn(PConnectRequestPDU_reliableTransportProtocols val);
    extern int ASN1CALL ASN1Enc_UnreliableTransportProtocol_nonStandardParameters_ElmFn(ASN1encoding_t enc, PUnreliableTransportProtocol_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_UnreliableTransportProtocol_nonStandardParameters_ElmFn(ASN1decoding_t dec, PUnreliableTransportProtocol_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_UnreliableTransportProtocol_nonStandardParameters_ElmFn(PUnreliableTransportProtocol_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_ReliableTransportProtocol_nonStandardParameters_ElmFn(ASN1encoding_t enc, PReliableTransportProtocol_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_ReliableTransportProtocol_nonStandardParameters_ElmFn(ASN1decoding_t dec, PReliableTransportProtocol_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_ReliableTransportProtocol_nonStandardParameters_ElmFn(PReliableTransportProtocol_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_PrivatePartyNumber_nonStandardParameters_ElmFn(ASN1encoding_t enc, PPrivatePartyNumber_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_PrivatePartyNumber_nonStandardParameters_ElmFn(ASN1decoding_t dec, PPrivatePartyNumber_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_PrivatePartyNumber_nonStandardParameters_ElmFn(PPrivatePartyNumber_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_PublicPartyNumber_nonStandardParameters_ElmFn(ASN1encoding_t enc, PPublicPartyNumber_nonStandardParameters val);
    extern int ASN1CALL ASN1Dec_PublicPartyNumber_nonStandardParameters_ElmFn(ASN1decoding_t dec, PPublicPartyNumber_nonStandardParameters val);
	extern void ASN1CALL ASN1Free_PublicPartyNumber_nonStandardParameters_ElmFn(PPublicPartyNumber_nonStandardParameters val);
    extern int ASN1CALL ASN1Enc_DisconnectRequestPDU_destinationAddress_ElmFn(ASN1encoding_t enc, PDisconnectRequestPDU_destinationAddress val);
    extern int ASN1CALL ASN1Dec_DisconnectRequestPDU_destinationAddress_ElmFn(ASN1decoding_t dec, PDisconnectRequestPDU_destinationAddress val);
	extern void ASN1CALL ASN1Free_DisconnectRequestPDU_destinationAddress_ElmFn(PDisconnectRequestPDU_destinationAddress val);
    extern int ASN1CALL ASN1Enc_ConnectRequestPDU_destinationAddress_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_destinationAddress val);
    extern int ASN1CALL ASN1Dec_ConnectRequestPDU_destinationAddress_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_destinationAddress val);
	extern void ASN1CALL ASN1Free_ConnectRequestPDU_destinationAddress_ElmFn(PConnectRequestPDU_destinationAddress val);
    extern int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableTransportProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_unreliableTransportProtocols val);
    extern int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableTransportProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_unreliableTransportProtocols val);
	extern void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableTransportProtocols_ElmFn(PConnectRequestPDU_unreliableTransportProtocols val);
    extern int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableSecurityProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_reliableSecurityProtocols val);
    extern int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableSecurityProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_reliableSecurityProtocols val);
	extern void ASN1CALL ASN1Free_ConnectRequestPDU_reliableSecurityProtocols_ElmFn(PConnectRequestPDU_reliableSecurityProtocols val);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _CNPPDU_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\connect.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	connect.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for class Connection.  It contains
 *		all code necessary to encode MCS commands as T.125 PDUs, and to
 *		decode T.125 back into MCS commands.
 *
 *		The primary responsibility of this class is to act as a Remote
 *		Procedure Call facility for MCS commands.  A CommandTarget object
 *		uses a Connection object to encode an MCS command as a PDU, and send it
 *		across to a remote Connection object.  That Connection object will
 *		decode the PDU back into an MCS command, at which time it will send
 *		it to the attached CommandTarget object on that side.  The intervening
 *		transport layer is transparent to the CommandTargets utilizing
 *		Connection class services.
 *
 *		A secondary responsibility of this class is to provide a layer of
 *		flow control between the attached CommandTarget object and the
 *		transport layer.  PDUs are queued until the transport layer can take
 *		them.
 *
 *	Private Instance Variables:
 *		Encoding_Rules
 *			This is a variable which holds a value indicating what type of
 *			rules (Basic or Packed) are used for encoding and decoding the PDUs.
 *		m_pDomain
 *			This is a pointer to the domain to which this connection is bound.
 *		m_pPendingDomain
 *			This is a pointer to the domain to which this connection will be
 *			bound upon successful completion of the	connection process.
 *		Connection_Handle
 *			This is the handle for the current transport connection.  It allows
 *			callback functions to be associated with the current transport
 *			connection so that any events which occur on this transport
 *			connection will be routed to any object that has registered its
 *			callbacks.
 *		m_pszCalledAddress
 *			The transport address of the party being called.
 *		Upward_Connection
 *			This is a boolean flag which indicates whether or not this is
 *			an upward connection.
 *		Domain_Parameters
 *			This is a structure which holds the set of domain parameters
 *			associated with this connection.
 *		Connect_Response_Memory
 *			This is a pointer to a memory object which is used to hold any
 *			user data contained within a ConnectResponse PDU.
 *		Merge_In_Progress
 *			This is a boolean flag that indicates whether or not the attached
 *			Domain object is in the merge state.  When in the merge state it
 *			is invalid to send it any MCS commands.
 *		Domain_Traffic_Allowed
 *			This is a boolean flag used to indicate when this connection object
 *			has been successfully created and bound to the domain, thus allowing
 *			PDU traffic to commence.
 *		Connect_Provider_Confirm_Pending
 *			This is a boolean flag used to dictate the behavior if this
 *			connection becomes invalid.  If a connect provider confirm is
 *			pending when the connection becomes invalid, then a failed confirm
 *			is issued to the controller.  If there is not a confirm pending,
 *			then we simply issue a delete connection to the controller.
 *		Transport_Connection
 *			This is an array used to hold handles for the transport connections
 *			available for use by this connection object.  There is a transport
 *			connection associated with each of the four data priorities.
 *		Transport_Connection_PDU_Type
 *			This is an array which holds values indicating what type of PDU
 *			(Connect or Domain) is expected for each priority level.
 *		Transport_Connection_State
 *			This is an array which holds values indicating the state of the
 *			transport connection associated with each prioriy level.
 *		Transport_Connection_Count
 *			This is a counter which keeps track of the number of transport
 *			connections.
 *		m_OutPktQueue
 *			This is a queue used to hold data units to be transmitted.
 *
 *	Private Member Functions:
 *		ConnectInitial
 *			This routine is called by the domain when a connection is being
 *			created.  It places the necessary domain information into a data
 *			packet and queues the data to be transmitted through the transport
 *			interface.
 *		ConnectResponse
 *			This routine is called when issuing a response to a	
 *			"ConnectInitial" PDU.  The result of the attempted connection, the
 *			connection ID, the domain parameters, and any user data are all put
 *			into the packet and queued for transmission through the transport
 *			interface.  If the result of the attempted connection is negative,
 *			the controller and transport interface are notified.
 *		ConnectAdditional
 *			This routine is called after successfully processing a
 *			"ConnectResponse" PDU in order to create any addition necessary
 *			transport connections.
 *		ConnectResult
 *			This routine is called indirectly when issuing a positive response
 *			to a "ConnectAdditional" PDU.  The "ConnectAdditional" PDUs are
 *			processed by the controller and therefore any negative
 *			"ConnectResult" PDU will be issued by the controller.
 *		ProcessConnectResponse
 *			This routine processes "Connect Response" PDU's coming from the
 *			transport interface.  Domain parameters are retrieved and the
 *			PDU sent on to the proper domain.
 *		ProcessConnectResult
 *			This routine processes "Connect Result" PDU's coming from the
 *			transport interface.  For successful "Connect Result" PDU's this
 *			connection is bound to the domain and a positive Connect Provider
 *			Confirm issued to the controller.  If unsuccessful, a negative
 *			Connect Provider Confirm is issued to the controller.
 *		IssueConnectProviderConfirm
 *			This routine is called in order to send a "Connect Provider Confirm"
 *			to the controller through a callback.
 *		DestroyConnection
 *			This routine is called in order to delete this connection because it
 *			has become invalid.  This is done by issuing a failed confirm to the
 *			controller or, if no confirm is pending, by issuing a delete
 *			connection to the controller.
 *		AssignRemainingTransportConnections
 *			This routine is called when there are no more transport connections
 *			to create in order to copy the lowest priority transport connection
 *			into all unassigned priorities.
 *		CreateTransportConnection
 *			This routine is called in order to create new transport connections.
 *		AcceptTransportConnection
 *			This routine is called in order to register this connection object
 *			with the transport interface.
 *		AdjustDomainParameters
 *			This routine is called in order to adjust the domain parameters so
 *			that they fall within the allowable range.
 *		MergeDomainParameters
 *			This routine is called in order to calculate the optimum overlap
 *			between the local and remote domain parameters.  If there is no
 *			overlap, this routine will return a value causing this connection
 *			to be destroyed.
 *		PrintDomainParameters
 *			This routine is used for debug purposes in order to print out the
 *			current set of domain parameters.
 *		SendPacket
 *			This routine is called in order to create a packet which will hold
 *			the PDU to be sent to the remote provider.  The packet will be
 *			queued up for transmission through the transport interface.
 *		QueueForTransmission
 *			This routine places data units into the transmission queue so
 *			they can be transmitted through the transport interface when
 *			possible.
 *		ProcessMergeChannelsRequest
 *			This routine processes "Merge Channel Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessMergeChannelsConfirm
 *			This routine processes "Merge Channel Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessPurgeChannelsIndication
 *			This routine processes "Purge Channel Indication" PDU's coming from
 *			the transport interface by retrieving any necessary information from
 *			the	packet and sending the PDU on to the proper domain.
 *		ProcessMergeTokenRequest
 *			This routine processes "Merge Token Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessMergeTokenConfirm
 *			This routine processes "Merge Token Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessPurgeTokenIndication
 *			This routine processes "Purge Token Indication" PDU's coming from
 *			the transport interface by retrieving any necessary information from
 *			the	packet and sending the PDU on to the proper domain.
 *		ProcessDisconnectProviderUltimatum
 *			This routine processes "Disconnect Provider Ultimatum" PDU's coming
 *			from the transport interface by retrieving any necessary information
 *			from the packet and sending the PDU on to the proper domain.
 *		ProcessAttachUserRequest
 *			This routine processes "Attach User Request" PDU's coming from the
 *			transport interface by sending the PDU on to the proper domain.
 *		ProcessAttachUserConfirm
 *			This routine processes "Attach User Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessDetachUserRequest
 *			This routine processes "Detach User Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessDetachUserIndication
 *			This routine processes "Detach User Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessChannelJoinRequest
 *			This routine processes "Channel Join Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessChannelJoinConfirm
 *			This routine processes "Channel Join Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessChannelLeaveRequest
 *			This routine processes "Channel Leave Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessChannelConveneRequest
 *			This routine processes the "ChannelConveneRequest" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessChannelConveneConfirm
 *			This routine processes the "ChannelConveneConfirm" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessChannelDisbandRequest
 *			This routine processes the "ChannelDisbandRequest" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessChannelDisbandIndication
 *			This routine processes the "ChannelDisbandIndication" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessChannelAdmitRequest
 *			This routine processes the "ChannelAdmitRequest" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessChannelAdmitIndication
 *			This routine processes the "ChannelAdmitIndication" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessChannelExpelRequest
 *			This routine processes the "ChannelExpelRequest" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessChannelExpelIndication
 *			This routine processes the "ChannelExpelIndication" PDU's being
 *			received through the transport interface.  The pertinent data is
 *			read from the incoming packet and passed on to the domain.
 *		ProcessSendDataRequest
 *			This routine processes "Send Data Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet, allocating any memory needed, and sending the PDU on to the
 *			proper domain.
 *		ProcessSendDataIndication
 *			This routine processes "Send Data Indication" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet, allocating any memory needed, and sending the PDU on to the
 *			proper domain.
 *		ProcessUniformSendDataRequest
 *			This routine processes "Uniform Send Data Indication" PDU's coming
 *			from the transport interface by retrieving any necessary information
 *			from the packet, allocating any memory needed, and sending the PDU
 *			on to the proper domain.
 *		ProcessUniformSendDataIndication
 *			This routine processes "Uniform Send Data Indication" PDU's coming
 *			from the transport interface by retrieving any necessary information
 *			from the packet, allocating any memory needed, and sending the PDU
 *			on to the proper domain.
 *		ProcessTokenGrabRequest
 *			This routine processes "Token Grab Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenGrabConfirm
 *			This routine processes "Token Grab Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenInhibitRequest
 *			This routine processes "Token Inhibit Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenInhibitConfirm
 *			This routine processes "Token Inhibit Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenReleaseRequest
 *			This routine processes "Token Release Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenReleaseConfirm
 *			This routine processes "Token Release Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenTestRequest
 *			This routine processes "Token Test Request" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenTestConfirm
 *			This routine processes "Token Test Confirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessRejectUltimatum
 *			This routine processes "RejectUltimatum" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenGiveRequest
 *			This routine processes "TokenGiveRequest" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenGiveIndication
 *			This routine processes "TokenGiveIndication" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenGiveResponse
 *			This routine processes "TokenGiveResponse" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenGiveConfirm
 *			This routine processes "TokenGiveConfirm" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenPleaseRequest
 *			This routine processes "TokenPleaseRequest" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessTokenPleaseIndication
 *			This routine processes "TokenPleaseIndication" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessPlumbDomainIndication
 *			This routine processes "PlumbDomainIndication" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ProcessErectDomainRequest
 *			This routine processes "ErectDomainRequest" PDU's coming from the
 *			transport interface by retrieving any necessary information from the
 *			packet and sending the PDU on to the proper domain.
 *		ValidateConnectionRequest
 *			This function is used to determine if it is valid to process an
 *			incoming request at the current time.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 *		John B. O'Nan
 */

/*
 *	External Interfaces
 */
#include "omcscode.h"
#include "tprtntfy.h"
#include "plgxprt.h"

/*
 *	This is a global variable that has a pointer to the one MCS coder that
 *	is instantiated by the MCS Controller.  Most objects know in advance
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CMCSCoder	*g_MCSCoder;

// The external MCS Controller object
extern PController	g_pMCSController;

// The global TransportInterface pointer (for transport access)
extern PTransportInterface g_Transport;

/*
 *	Connection ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is a constructor for the Connection class.  This constructor
 *		is used for creating outbound connections.  It initializes private
 *		instance variables and calls the transport interface to set up a
 *		transport connection and register this connection object (through a
 *		callback structure) with the transport object.
 *
 *	Caveats:
 *		None.
 */
Connection::Connection
(
    PDomain				attachment,
    ConnectionHandle	connection_handle,
    GCCConfID          *calling_domain,
    GCCConfID          *called_domain,
    PChar				called_address,
    BOOL				fSecure,
    BOOL    			upward_connection,
    PDomainParameters	domain_parameters,
    PUChar				user_data,
    ULong				user_data_length,
    PMCSError			connection_error
)
:
    CAttachment(CONNECT_ATTACHMENT),
    Encoding_Rules (BASIC_ENCODING_RULES),
    m_pDomain(NULL),
    m_pPendingDomain(attachment),
    Connection_Handle (connection_handle),
    Upward_Connection (upward_connection),
    Deletion_Reason (REASON_USER_REQUESTED),
    Connect_Response_Memory (NULL),
    Merge_In_Progress (FALSE),
    Domain_Traffic_Allowed (FALSE),
    Connect_Provider_Confirm_Pending (TRUE),
    m_fSecure(fSecure)
{
	UINT					priority;
	TransportError			transport_error;
	DomainParameters		min_domain_parameters;
	DomainParameters		max_domain_parameters;

    BOOL fPluggableTransport = ::GetPluggableTransportConnID((LPCSTR) called_address);

	/*
	 *	If the passed in pointer is valid, then set the local domain
	 *	parameters to the values contained therein.  Otherwise, use
	 *	defaults for everything.
	 */
	if (domain_parameters != NULL)
		Domain_Parameters = *domain_parameters;
	else
	{
		/*
		 *	Use default values for all domain parameters.
		 */
		Domain_Parameters.max_channel_ids = DEFAULT_MAXIMUM_CHANNELS;
		Domain_Parameters.max_user_ids = DEFAULT_MAXIMUM_USERS;
		Domain_Parameters.max_token_ids = DEFAULT_MAXIMUM_TOKENS;
		Domain_Parameters.number_priorities = DEFAULT_NUMBER_OF_PRIORITIES;
		Domain_Parameters.min_throughput = DEFAULT_MINIMUM_THROUGHPUT;
		Domain_Parameters.max_height = DEFAULT_MAXIMUM_DOMAIN_HEIGHT;
		Domain_Parameters.max_mcspdu_size = DEFAULT_MAXIMUM_PDU_SIZE;
		Domain_Parameters.protocol_version = DEFAULT_PROTOCOL_VERSION;

		if (fPluggableTransport || g_fWinsockDisabled)
		{
    		Domain_Parameters.number_priorities = DEFAULT_NUM_PLUGXPRT_PRIORITIES;
		}
	}

	/*
	 *	Initialize the arrays indicating that the transport connections
	 *	are not yet valid, and that none of the queues have data in them
	 *	yet.
	 */
	for (priority = 0; priority < MAXIMUM_PRIORITIES; priority++)
	{
		Transport_Connection_State[priority] = TRANSPORT_CONNECTION_UNASSIGNED;
	}
	Transport_Connection_Count = 0;

	if (NULL == (m_pszCalledAddress = ::My_strdupA(called_address)))
	{
		ERROR_OUT(("Connection::Connection: can't create called address"));
		*connection_error = MCS_ALLOCATION_FAILURE;
		return;
	}

	/*
	 *	Send a connect request to the transport layer to create the Top
	 *	Priority transport connection.
	 */
	transport_error = CreateTransportConnection (m_pszCalledAddress, m_fSecure, TOP_PRIORITY);

	if (transport_error == TRANSPORT_NO_ERROR)
	{
		/*
		 *	Call upon the domain to find out the appropriate minimum and
		 *	maximum domain parameter values.  Then call a private member
		 *	function to adjust the target parameters to fit into that range.
		 */
		m_pPendingDomain->GetDomainParameters(NULL, &min_domain_parameters,
                                                    &max_domain_parameters);
		AdjustDomainParameters (&min_domain_parameters, &max_domain_parameters,
				&Domain_Parameters);

#ifdef DEBUG
		TRACE_OUT (("Connection::Connection: CONNECT_INITIAL target parameters"));
		PrintDomainParameters (&Domain_Parameters);
		TRACE_OUT (("Connection::Connection: CONNECT_INITIAL minimum parameters"));
		PrintDomainParameters (&min_domain_parameters);
		TRACE_OUT (("Connection::Connection: CONNECT_INITIAL maximum parameters"));
		PrintDomainParameters (&max_domain_parameters);
#endif // DEBUG

		/*
		 *	Issue the ConnectInitial on the newly created transport
		 *	connection.  Note that the queue will not actually try to
		 *	send the data until the confirm is received from the
		 *	transport layer.
		 */
		ConnectInitial (calling_domain, called_domain, Upward_Connection,
				&Domain_Parameters, &min_domain_parameters,
				&max_domain_parameters, user_data, user_data_length);

		*connection_error = MCS_NO_ERROR;
	}
	else
	{
		WARNING_OUT (("Connection::Connection: transport ConnectRequest failed"));

		/*
		 *	Set the return code according to the nature of the failure.
		 */
		switch (transport_error)
		{
			case TRANSPORT_MEMORY_FAILURE:
				*connection_error = MCS_ALLOCATION_FAILURE;
				break;
					
			case TRANSPORT_SECURITY_FAILED:
				*connection_error = MCS_SECURITY_FAILED;
				break;

			default:
				*connection_error = MCS_TRANSPORT_NOT_READY;
				break;
		}
	}
}

/*
 *	Connection ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is a constructor for the Connection class.  This constructor is
 *		used for creating inbound connections and is called when a transport
 *		connection already exists.  It initializes private instance variables
 *		and calls the transport interface to register this connection object
 *		(through a callback structure) with the transport object.
 *
 *	Caveats:
 *		None.
 */
Connection::Connection (
		PDomain				attachment,
		ConnectionHandle	connection_handle,
		TransportConnection	transport_connection,
		BOOL    			upward_connection,
		PDomainParameters	domain_parameters,
		PDomainParameters	min_domain_parameters,
		PDomainParameters	max_domain_parameters,
		PUChar				user_data,
		ULong				user_data_length,
		PMCSError			connection_error)
:
    CAttachment(CONNECT_ATTACHMENT),
    m_pszCalledAddress(NULL),
    Encoding_Rules (BASIC_ENCODING_RULES),
    m_pDomain(NULL),
    m_pPendingDomain(attachment),
    Connection_Handle (connection_handle),
    Upward_Connection (upward_connection),
    Deletion_Reason (REASON_USER_REQUESTED),
    Connect_Response_Memory (NULL),
    Merge_In_Progress (FALSE),
    Domain_Traffic_Allowed (FALSE),
    Connect_Provider_Confirm_Pending (FALSE)
{
	UINT				priority;
	TransportError		transport_error;
	DomainParameters	local_min_domain_parameters;
	DomainParameters	local_max_domain_parameters;

	//
	// BUGBUG: set m_fSecure from transport connection?
	//

	/*
	 *	If the passed in pointer is valid, then set the local domain
	 *	parameters to the values contained therein.  Otherwise, use
	 *	defaults for everything.
	 */
	if (domain_parameters != NULL)
		Domain_Parameters = *domain_parameters;
	else
	{
		/*
		 *	Use default values for all domain parameters.
		 */
		Domain_Parameters.max_channel_ids = DEFAULT_MAXIMUM_CHANNELS;
		Domain_Parameters.max_user_ids = DEFAULT_MAXIMUM_USERS;
		Domain_Parameters.max_token_ids = DEFAULT_MAXIMUM_TOKENS;
		Domain_Parameters.number_priorities = DEFAULT_NUMBER_OF_PRIORITIES;
		Domain_Parameters.min_throughput = DEFAULT_MINIMUM_THROUGHPUT;
		Domain_Parameters.max_height = DEFAULT_MAXIMUM_DOMAIN_HEIGHT;
		Domain_Parameters.max_mcspdu_size = DEFAULT_MAXIMUM_PDU_SIZE;
		Domain_Parameters.protocol_version = DEFAULT_PROTOCOL_VERSION;

		if (IS_PLUGGABLE(transport_connection) || g_fWinsockDisabled)
		{
    		Domain_Parameters.number_priorities = DEFAULT_NUM_PLUGXPRT_PRIORITIES;
		}
	}

	/*
	 *	Initialize the arrays indicating that the transport connections
	 *	are not yet valid, and that none of the queues have data in them
	 *	yet.
	 */
	for (priority=0; priority < MAXIMUM_PRIORITIES; priority++)
	{
		Transport_Connection_State[priority] = TRANSPORT_CONNECTION_UNASSIGNED;
	}
	Transport_Connection_Count = 0;

	transport_error = AcceptTransportConnection (transport_connection,
			TOP_PRIORITY);

	if (transport_error == TRANSPORT_NO_ERROR)
	{
		/*
		 *	Call the domain object to find out the local minimum and maximum
		 *	permissible values for the domain parameters.
		 */
		m_pPendingDomain->GetDomainParameters (NULL, &local_min_domain_parameters,
		                                             &local_max_domain_parameters);

		/*
		 *	Now call a private member function to calculate the optimum overlap
		 *	between the local and remote domain parameters.  Note that if there
		 *	is no overlap, this connection will be destroyed.
		 */
		if (MergeDomainParameters (min_domain_parameters, max_domain_parameters,
				&local_min_domain_parameters, &local_max_domain_parameters))
		{
			/*
			 *	The merge of the domain parameters was acceptable, so now we
			 *	must adjust the target parameters to fit within the agreed
			 *	upon range.
			 */
			AdjustDomainParameters (&local_min_domain_parameters,
					&local_max_domain_parameters, &Domain_Parameters);

#ifdef DEBUG
			TRACE_OUT (("Connection::Connection: CONNECT_RESPONSE parameters"));
			PrintDomainParameters (&Domain_Parameters);
#endif // DEBUG

			/*
			 *	Issue the ConnectResponse on the new transport connection.
			 */
			ConnectResponse (RESULT_SUCCESSFUL, &Domain_Parameters,
					Connection_Handle, user_data, user_data_length);

			/*
			 *	Check to see if this completes the list of transport
			 *	connections that will be used in this MCS connection.
			 */
			if (Transport_Connection_Count == Domain_Parameters.number_priorities)
			{
				/*
				 *	There are no more transport connections to accept.  We must
				 *	now assign the lowest priority TC to all unassigned
				 *	priorities.
				 */
				AssignRemainingTransportConnections ();
			}
			else
			{
				/*
				 *	Issue a ConnectResult for each remaining priority.  Note
				 *	that these TCs have not been created yet, so the PDUs will
				 *	remain in the queue until they are created.  They are put in
				 *	the queue here to assure that they are the first PDUs
				 *	transmitted over a given TC.
				 */
				for (priority = Transport_Connection_Count;
						priority < Domain_Parameters.number_priorities;
						priority++)
					ConnectResult (RESULT_SUCCESSFUL, (Priority) priority);
			}

			/*
			 *	Now that we know what the domain parameters will be for this
			 *	connection, we can determine what type of encoding rules will
			 *	be used for domain PDUs (basic or packed).
			 */
#if 0
			if (Domain_Parameters.protocol_version == PROTOCOL_VERSION_BASIC)
			{
				TRACE_OUT(("Connection::Connection: using basic encoding rules"));
				Encoding_Rules = BASIC_ENCODING_RULES;
			}
			else
#endif  // 0
			{
				TRACE_OUT (("Connection::Connection: using packed encoding rules"));
				Encoding_Rules = PACKED_ENCODING_RULES;
			}


			/*
			 *	Bind the pending attachment to the domain.  Note that this
			 *	is necessary on the called provider in order to allow access
			 *	to domain services immediately after the return from
			 *	MCSConnectProviderResponse (which is what got us here).
			 */
			TRACE_OUT (("Connection::Connection: binding MCS connection to domain"));
			m_pDomain = m_pPendingDomain;
			m_pDomain->BindConnAttmnt(this, Upward_Connection, &Domain_Parameters);

			*connection_error = MCS_NO_ERROR;
		}
		else
		{
			/*
			 *	Issue the ConnectResponse informing the remote side that the
			 *	domain parameters are unacceptable.  We must flush the message
			 *	queue from here to force the response packet to be transmitted.
			 *	This is because this object will be deleted by the controller
			 *	as soon as this call returns.
			 */
			WARNING_OUT (("Connection::Connection: "
					"unacceptable domain parameters"));
			ConnectResponse (RESULT_PARAMETERS_UNACCEPTABLE, &Domain_Parameters,
					Connection_Handle, user_data, user_data_length);
			FlushMessageQueue ();
			*connection_error = MCS_DOMAIN_PARAMETERS_UNACCEPTABLE;
		}
	}
	else
	{
		WARNING_OUT (("Connection::Connection: "
				"register transport connection failed"));
		*connection_error = MCS_NO_SUCH_CONNECTION;
	}
}

/*
 *	~Connection ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the Connection class.  If no connection
 *		deletion is pending, it terminates the current connection by issuing
 *		a DisconnectProviderUltimatum to the domain, transmitting a
 *		"DISCONNECT_PROVIDER_ULTIMATUM" PDU, and issuing a DisconnectRequest
 *		to the transport interface.  The destructor also clears the transmission
 *		queue and frees any allocated memory.
 *
 *	Caveats:
 *		None.
 */
Connection::~Connection ()
{
	DomainMCSPDU		disconnect_provider_ultimatum_pdu;
	PSimplePacket		packet;
	PacketError			packet_error;
	UShort				priority;

	/*
	 *	If we still have an upward attachment, then issue a disconnect
	 *	provider ultimatum to terminate it.
	 */
	if (m_pDomain != NULL)
		m_pDomain->DisconnectProviderUltimatum(this, Deletion_Reason);

	/*
	 *	Check to see if the Top Priority transport connection is still valid.
	 *	If so, we need to try and send a disconnect ultimatum PDU through it
	 *	before hanging up.
	 */
	if (Transport_Connection_State[TOP_PRIORITY] == TRANSPORT_CONNECTION_READY)
	{
		/*
		 *	We must first purge all packets that are waiting in the transport
		 *	queue, to expediate the disconnect process.
		 */
		::PurgeRequest (Transport_Connection[TOP_PRIORITY]);
		
		/*
		 *	If there are any remaining data units in the queue for this
		 *	priority, walk through the list releasing all memory associated
		 *	with them.
		 */
		while (NULL != (packet = m_OutPktQueue[TOP_PRIORITY].Get()))
		{
			packet->Unlock();
		}

		if (Domain_Traffic_Allowed)
		{
				PPacket		disconnect_packet;
			/*
			 *	Fill in the PDU structure to be encoded.
			 */
			disconnect_provider_ultimatum_pdu.choice =
					DISCONNECT_PROVIDER_ULTIMATUM_CHOSEN;
			disconnect_provider_ultimatum_pdu.u.
					disconnect_provider_ultimatum.reason =
					(PDUReason)Deletion_Reason;

			/*
			 *	Create a packet which will be used to hold the data to be sent
			 *	through the transport interface.  If the packet creation fails it
			 *	doesn't matter since this connection is being deleted anyway.
			 */
			DBG_SAVE_FILE_LINE
			disconnect_packet = new Packet (
								 		(PPacketCoder) g_MCSCoder,
										Encoding_Rules,
										(PVoid) &disconnect_provider_ultimatum_pdu,
										DOMAIN_MCS_PDU,
										Upward_Connection,
										&packet_error);

			if (disconnect_packet != NULL)
			{
				if (packet_error == PACKET_NO_ERROR)
				{
					/*
					 *	Lock the encoded PDU data and queue the packet up for
					 *	transmission through the transport interface.
					 */
					QueueForTransmission ((PSimplePacket) disconnect_packet,
											TOP_PRIORITY);
					
					/*
					 *	Attempt to flush the message queue.  Since this is the
					 *	object destructor, this is the last chance we will get to
					 *	send queued up PDUs (including the disconnect PDU that we
					 *	just put there).
					 */
					FlushMessageQueue ();
				}
				disconnect_packet->Unlock ();
			}
		} // Domain_Traffic_Allowed == TRUE

		/*
		 *	Issue a disconnect request to the top priority transport connection,
		 *	telling it to wait until the disconnect provider ultimatum has
		 *	cleared the transmitter.
		 */
		ASSERT(g_Transport != NULL);
		g_Transport->DisconnectRequest (Transport_Connection[TOP_PRIORITY]);
		Transport_Connection_State[TOP_PRIORITY] =
				TRANSPORT_CONNECTION_UNASSIGNED;
	}

	/*
	 *	Clear the transmission queue and free any allocated memory.
	 */
	for (priority = 0; priority < MAXIMUM_PRIORITIES; priority++)
	{
		/*
		 *	If we are holding a valid connection handle for this priority, then
		 *	it is necessary to issue a disconnect.
		 */
		if (Transport_Connection_State[priority] !=
				TRANSPORT_CONNECTION_UNASSIGNED)
		{
			ASSERT(g_Transport != NULL);
			g_Transport->DisconnectRequest (
					Transport_Connection[priority]);
		}

		/*
		 *	If there are any remaining data units in the queue for this
		 *	priority, walk through the list releasing all memory associated
		 *	with them.
		 */
		while (NULL != (packet = m_OutPktQueue[priority].Get()))
		{
			packet->Unlock();
		}
	}

	/*
	 *	If there is a memory block holding the user data field of a pending
	 *	connect provider confirm, then free it.
	 */
	FreeMemory (Connect_Response_Memory);

	delete m_pszCalledAddress;
}

/*
 *	void	RegisterTransportConnection ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called in order to register the transport connection
 *		with the connection object.
 */
void Connection::RegisterTransportConnection (
						TransportConnection	transport_connection,
						Priority			priority)
{
	TransportError		transport_error;

	/*
	 *	Make sure that the specified priority is one of those outstanding.
	 */
	if (Transport_Connection_State[priority] != TRANSPORT_CONNECTION_READY)
	{
		/*
		 *	Register this connection object as the owner of the new
		 *	transport connection.
		 */
		transport_error = AcceptTransportConnection (transport_connection,
				priority);

		if (transport_error == TRANSPORT_NO_ERROR)
		{
			TRACE_OUT (("Connection::RegisterTransportConnection: "
					"transport connection accepted"));

			/*
			 *	Check to see if this completes the list of transport
			 *	connections that will be used in this MCS connection.
			 */
			if (Transport_Connection_Count == Domain_Parameters.number_priorities)
			{
				/*
				 *	There are no more transport connections to accept.  We must
				 *	now assign the lowest priority TC to all unassigned
				 *	priorities.
				 */
				AssignRemainingTransportConnections ();
			}
		}
		else
		{
			/*
			 *	The transport connection must be invalid or already assigned
			 *	to another connection object.  We therefore cannot use it.
			 */
			ERROR_OUT (("Connection::RegisterTransportConnection: "
					"register transport connection failed"));
		}
	}
	else
	{
		/*
		 *	A transport connection is not pending for this priority level.
		 *	Reject the registration.
		 */
		ERROR_OUT (("Connection::RegisterTransportConnection: "
				"priority already assigned"));
	}
}

/*
 *	Void	ConnectInitial ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called by the domain when a connection is being created.
 *		It places the necessary domain information into a data packet and
 *		queues the data to be transmitted through the transport interface.
 *
 *	Caveats:
 *		None.
 */
// LONCHANC: we send out calling and called domain selectors but
// at the receiver side, we ignore them completely.
Void	Connection::ConnectInitial (
				GCCConfID          *calling_domain,
				GCCConfID          *called_domain,
				BOOL    			upward_connection,
				PDomainParameters	domain_parameters,
				PDomainParameters	min_domain_parameters,
				PDomainParameters	max_domain_parameters,
				PUChar				user_data,
				ULong				user_data_length)
{
	ConnectMCSPDU		connect_initial_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	connect_initial_pdu.choice = CONNECT_INITIAL_CHOSEN;
	connect_initial_pdu.u.connect_initial.calling_domain_selector.length = sizeof(GCCConfID);
	connect_initial_pdu.u.connect_initial.calling_domain_selector.value = (LPBYTE) calling_domain;
	connect_initial_pdu.u.connect_initial.called_domain_selector.length = sizeof(GCCConfID);
	connect_initial_pdu.u.connect_initial.called_domain_selector.value = (LPBYTE) called_domain;

	connect_initial_pdu.u.connect_initial.upward_flag = (ASN1bool_t)upward_connection;

	memcpy (&(connect_initial_pdu.u.connect_initial.target_parameters),
			domain_parameters, sizeof (PDUDomainParameters));

	memcpy (&(connect_initial_pdu.u.connect_initial.minimum_parameters),
			min_domain_parameters, sizeof(PDUDomainParameters));
	
	memcpy (&(connect_initial_pdu.u.connect_initial.maximum_parameters),
			max_domain_parameters, sizeof(PDUDomainParameters));

	connect_initial_pdu.u.connect_initial.user_data.length = user_data_length;
	connect_initial_pdu.u.connect_initial.user_data.value =	user_data;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &connect_initial_pdu, CONNECT_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	ConnectResponse ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called when issuing a response to a	 "ConnectInitial"
 *		PDU.  The result of the attempted connection, the connection ID, the
 *		domain parameters, and any user data are all put into the packet and
 *		queued for transmission through the transport interface.  If the result
 *		of the attempted connection is negative, the controller and transport
 *		interface are notified.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ConnectResponse (
				Result				result,
				PDomainParameters	domain_parameters,
				ConnectID			connect_id,
				PUChar				user_data,
				ULong				user_data_length)
{
	ConnectMCSPDU		connect_response_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	connect_response_pdu.choice = CONNECT_RESPONSE_CHOSEN;
	connect_response_pdu.u.connect_response.result = (PDUResult)result;
	connect_response_pdu.u.connect_response.called_connect_id = connect_id;
	
	memcpy (&(connect_response_pdu.u.connect_response.domain_parameters),
			domain_parameters, sizeof(PDUDomainParameters));

	connect_response_pdu.u.connect_response.user_data.length = user_data_length;
	connect_response_pdu.u.connect_response.user_data.value = user_data;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &connect_response_pdu, CONNECT_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	ConnectAdditional ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called after successfully processing a"ConnectResponse"
 *		PDU in order to create any addition necessary transport connections.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ConnectAdditional (
				ConnectID			connect_id,
				Priority			priority)
{
	ConnectMCSPDU		connect_additional_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	connect_additional_pdu.choice = CONNECT_ADDITIONAL_CHOSEN;
	connect_additional_pdu.u.connect_additional.called_connect_id = connect_id;
	connect_additional_pdu.u.connect_additional.data_priority =
			(PDUPriority)priority;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &connect_additional_pdu, CONNECT_MCS_PDU, priority);
}

/*
 *	Void	ConnectResult ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called indirectly when issuing a positive response
 *		to a "ConnectAdditional" PDU.  The "ConnectAdditional" PDUs are
 *		processed by the controller and therefore any negative
 *		"ConnectResult" PDU will be issued by the controller.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ConnectResult (
				Result				result,
				Priority			priority)
{
	ConnectMCSPDU		connect_result_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	connect_result_pdu.choice = CONNECT_RESULT_CHOSEN;
	connect_result_pdu.u.connect_result.result = (PDUResult)result;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &connect_result_pdu, CONNECT_MCS_PDU, priority);
}

/*
 *	ULong	ProcessConnectResponse()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes the "ConnectResponse" PDU's being received
 *		through the transport interface.  The result of the connection attempt,
 *		the connection ID, and the domain parameters are read from the packet
 *		and the domain notified of the connection response.
 *
 *	Caveats:
 *		None.
 */
ULong	Connection::ProcessConnectResponse (PConnectResponsePDU	pdu_structure)
{
	TransportError		return_value=TRANSPORT_NO_ERROR;
	UINT				priority;
	TransportError		transport_error;

	/*
	 *	Allocate any memory needed to pass user data on to the domain.
	 */
	if (pdu_structure->user_data.length != 0)
	{
		DBG_SAVE_FILE_LINE
		Connect_Response_Memory = AllocateMemory (
				pdu_structure->user_data.value,
				pdu_structure->user_data.length);

		if (Connect_Response_Memory == NULL)
		{
			 ("Connection::ProcessConnectResponse: "
					"memory allocation failed");
			return_value = TRANSPORT_READ_QUEUE_FULL;
		}
	}
	else
		Connect_Response_Memory = NULL;

	/*
	 *	If everything is okay, then process the PDU.  Note that the only way
	 *	for there to be a problem at this point, is if the memory allocation
	 *	above has failed.  If this is the case, returning an error without
	 *	processing the PDU will cause the transport layer to retry the PDU
	 *	at a future time.
	 */
	if (return_value == TRANSPORT_NO_ERROR)
	{
		/*
		 *	Was the connection accepted by the remote side?  If so, then begin
		 *	the process of creating additional TCs (if necessary).
		 */
		if (pdu_structure->result == RESULT_SUCCESSFUL)
		{
			/*
			 *	Get the domain parameters that are to be used for this MCS
			 *	connection.
			 */
			memcpy (&Domain_Parameters, &(pdu_structure->domain_parameters),
					sizeof(PDUDomainParameters));

			/*
			 *	Now that we know what the domain parameters will be for this
			 *	connection, we can determine what type of encoding rules will
			 *	be used for domain PDUs (basic or packed).
			 *	NOTE: The Teles ASN.1 coder assumes the use of packed encoding rules.
			 */
			ASSERT (Domain_Parameters.protocol_version != PROTOCOL_VERSION_BASIC);
			TRACE_OUT (("Connection::ProcessConnectResponse: "
						"using packed encoding rules"));
			Encoding_Rules = PACKED_ENCODING_RULES;

			/*
			 *	Increment the number of transport connections that are now ready
			 *	for domain MCSPDU traffic.
			 */
			Transport_Connection_Count++;

			/*
			 *	If there is at least one additional TC required, then it is
			 *	necessary to create it before this connection can be bound to
			 *	the local domain.
			 */
			if (Transport_Connection_Count < Domain_Parameters.number_priorities)
			{
				/*
				 *	Loop through, creating the proper number of additional
				 *	transport connections.
				 */
				for (priority = Transport_Connection_Count;
						priority < Domain_Parameters.number_priorities;
						priority++)
				{
					/*
					 *	Attempt to create an outbound transport connection.
					 */
					transport_error = CreateTransportConnection (m_pszCalledAddress,
							m_fSecure,
							(Priority) priority);

					if (transport_error == TRANSPORT_NO_ERROR)
					{
						/*
						 *	If we were able to successfully request a new TC,
						 *	then queue up a connect additional, which will
						 *	automatically be sent when the TC becomes valid.
						 */
						ConnectAdditional (
								(UShort) pdu_structure->called_connect_id,
								(Priority) priority);
					}
					else
					{
						/*
						 *	If we were not able to create one of the required
						 *	TCs, then this MCS connection is invalid.  Issue
						 *	a failed connect provider confirm.
						 */
						IssueConnectProviderConfirm (
								RESULT_UNSPECIFIED_FAILURE);

						/*
						 *	Its pointless to try and create any more TCs, so
						 *	break out of this loop.
						 */
						break;
					}
				}
			}
			else
			{
				/*
				 *	If there are no more TCs to create, then copy the lowest
				 *	priority TC into all unassigned priorities.
				 */
				AssignRemainingTransportConnections ();

				/*
				 *	Bind this MCS connection to the domain, now that it is
				 *	ready for use.
				 */
				TRACE_OUT (("Connection::ProcessConnectResponse: "
						"binding MCS connection to domain"));
				m_pDomain = m_pPendingDomain;
				m_pDomain->BindConnAttmnt(this, Upward_Connection, &Domain_Parameters);

				/*
				 *	Issue a successful connect provider confirm to the node
				 *	controller.
				 */
				IssueConnectProviderConfirm (RESULT_SUCCESSFUL);
			}
		}
		else
		{
			/*
			 *	This connection was rejected by the remote side.  It is
			 *	therefore necessary to issue a failed connect provider confirm.
			 */
			IssueConnectProviderConfirm ((Result)pdu_structure->result);
		}
	}

	return ((ULong) return_value);
}

/*
 *	Void	ProcessConnectResult ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine processes "Connect Result" PDU's coming from the
 *		transport interface.  For successful "Connect Result" PDU's this
 *		connection is bound to the domain and a positive Connect Provider
 *		Confirm issued to the controller.  If unsuccessful, a negative
 *		Connect Provider Confirm is issued to the controller.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ProcessConnectResult (PConnectResultPDU		pdu_structure)
{
	Result				result;

	result = (Result)pdu_structure->result;

	/*
	 *	Was the transport connection accepted by the remote system?
	 */
	if (result == RESULT_SUCCESSFUL)
	{
		/*
		 *	Increment the number of transport connections that are now ready
		 *	for domain MCSPDU traffic.
		 */
		Transport_Connection_Count++;

		/*
		 *	Do we now have all transport connections accounted for?
		 */
		if (Transport_Connection_Count == Domain_Parameters.number_priorities)
		{
			/*
			 *	If there are no more TCs to create, then copy the lowest
			 *	priority TC into all unassigned priorities.
			 */
			AssignRemainingTransportConnections ();

			/*
			 *	Bind this MCS connection to the domain, now that it is
			 *	ready for use.
			 */
			TRACE_OUT (("Connection::ProcessConnectResult: "
					"binding MCS connection to domain"));
			m_pDomain = m_pPendingDomain;
			m_pDomain->BindConnAttmnt(this, Upward_Connection, &Domain_Parameters);

			/*
			 *	Issue a successful connect provider confirm to the node
			 *	controller.
			 */
			IssueConnectProviderConfirm (RESULT_SUCCESSFUL);
		}
	}
	else
	{
		/*
		 *	This connection was rejected by the remote side.  It is
		 *	therefore necessary to issue a failed connect provider confirm.
		 */
		IssueConnectProviderConfirm (result);
	}
}

/*
 *	Void	IssueConnectProviderConfirm ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called in order to send a "Connect Provider Confirm"
 *		to the controller through a callback.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::IssueConnectProviderConfirm (
				Result				result)
{
	ConnectConfirmInfo		connect_confirm_info;

	/*
	 *	Make sure there is a confirm pending before issuing one to the
	 *	controller.
	 */
	if (Connect_Provider_Confirm_Pending)
	{
		/*
		 *	Pack the information into the structure for passing in the owner
		 *	callback.
		 */
		ASSERT (g_Transport != NULL);
		connect_confirm_info.domain_parameters = &Domain_Parameters;
		connect_confirm_info.result = result;
		connect_confirm_info.memory = Connect_Response_Memory;

		/*
		 *	Issue the callback to the controller.
		 */
		TRACE_OUT (("Connection::IssueConnectProviderConfirm: "
				"sending CONNECT_PROVIDER_CONFIRM"));
		g_pMCSController->HandleConnConnectProviderConfirm(&connect_confirm_info, Connection_Handle);

		/*
		 *	If there was user data associated with this confirm, free the memory
		 *	block that contained it.
		 */
		if (Connect_Response_Memory != NULL)
		{
			FreeMemory (Connect_Response_Memory);
			Connect_Response_Memory = NULL;
		}

		/*
		 *	Reset the confirm pending flag, to prevent this object from sending
		 *	a second confirm to the controller.
		 */
		Connect_Provider_Confirm_Pending = FALSE;
	}
}

/*
 *	Void	DestroyConnection ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called in order to delete this connection because it has
 *		become invalid.  This is done by issuing a failed confirm to the
 *		controller or, if no confirm is pending, by issuing a delete connection
 *		to the controller.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::DestroyConnection (
				Reason			reason)
{
	Result  result = RESULT_UNSPECIFIED_FAILURE;
	/*
	 *	Modify the Deletion_Reason to reflect why this connection is being
	 *	destroyed.
	 */
	Deletion_Reason = reason;
	
	/*
	 *	Something catastrophic has occurred, so we must ask the controller to
	 *	delete this object.  There are two possible ways of doing this
	 *	(depending on circumstances).  If a connect provider confirm is still
	 *	pending, then we issue a failed confirm to the controller (who will
	 *	forward it to the node controller and destroy this object).  If there
	 *	is not a confirm pending, then we simply issue a delete connection to
	 *	the controller (who will issue a disconnect provider indication to the
	 *	node controller and destroy this object).
	 */
	if (Connect_Provider_Confirm_Pending)
	{
		/*
		 *	Send the failed confirm to the controller.
		 */
		switch (reason)
	  	{
	  	case REASON_REMOTE_NO_SECURITY :
			result = RESULT_REMOTE_NO_SECURITY;
			break;
	  	case REASON_REMOTE_DOWNLEVEL_SECURITY :
			result = RESULT_REMOTE_DOWNLEVEL_SECURITY;
			break;
	  	case REASON_REMOTE_REQUIRE_SECURITY :
	  		result = RESULT_REMOTE_REQUIRE_SECURITY;
	  		break;
		case REASON_AUTHENTICATION_FAILED :
			result = RESULT_AUTHENTICATION_FAILED;
			break;
	  	default :
			result = RESULT_UNSPECIFIED_FAILURE;
			break;
	  }
	  IssueConnectProviderConfirm (result);
	}
	else
	{
		ASSERT (g_Transport != NULL);

		/*
		 *	Issue a delete connection callback to the controller.  When the
		 *	controller deletes this object, it will correctly disconnect itself
		 *	from the layers above and below, and clean up all outstanding
		 *	resources.
		 */
		TRACE_OUT (("Connection::DestroyConnection: sending DELETE_CONNECTION"));
		g_pMCSController->HandleConnDeleteConnection(Connection_Handle);
	}
}

/*
 *	Void	AssignRemainingTransportConnections ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called when there are no more transport connections to
 *		create in order to copy the lowest priority transport connection into
 *		all unassigned priorities.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::AssignRemainingTransportConnections ()
{
	unsigned int			priority;
	TransportConnection		transport_connection;

	/*
	 *	Verify that this MCS connection is in the initializing state before
	 *	proceeding with this request.
	 */
	if (Transport_Connection_State[TOP_PRIORITY] == TRANSPORT_CONNECTION_READY)
	{
		/*
		 *	Loop through for each priority, copying transport connections from
		 *	higher priorities into lower priorities that do not have a
		 *	transport connection assigned.
		 */
		for (priority=0; priority < MAXIMUM_PRIORITIES; priority++)
		{
			if (Transport_Connection_State[priority] ==
					TRANSPORT_CONNECTION_READY)
				transport_connection = Transport_Connection[priority];
			else
			{
				Transport_Connection[priority] = transport_connection;
				Transport_Connection_PDU_Type[priority] = DOMAIN_MCS_PDU;
				Transport_Connection_State[priority] =
						TRANSPORT_CONNECTION_READY;
			}
		}

		/*
		 *	Set the flag indicating that the transmission of domain PDUs is
		 *	now permitted on this MCS connection. Also, flush any queued msgs
		 *	in case they were prevented earlier.
		 *	bugbug: the FlushMessageQueue may fail.
		 */
		Domain_Traffic_Allowed = TRUE;
		FlushMessageQueue ();
	}
	else
	{
		/*
		 *	We have no valid transport connections.  It is therefore not
		 *	possible to bind to the domain.
		 */
		WARNING_OUT (("Connection::AssignRemainingTransportConnections: "
				"no valid transport connections"));
	}
}

/*
 *	TransportError	CreateTransportConnection ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called in order to create new transport connections.
 *
 *	Caveats:
 *		None.
 */
TransportError	Connection::CreateTransportConnection (
						LPCTSTR			called_address,
						BOOL			fSecure,
						Priority		priority)
{
	TransportConnection	transport_connection;
	TransportError		transport_error;

	/*
	 *	Send a connect request to the transport layer to create the transport
	 *	connection.
	 */
	ASSERT(g_Transport != NULL);
	transport_error = g_Transport->ConnectRequest (
			(PChar) called_address, fSecure, priority < MEDIUM_PRIORITY, this,
			&transport_connection);

	if (transport_error == TRANSPORT_NO_ERROR)
	{
		/*
		 *	Mark the transport connection as pending, which indicates that
		 *	it has been assigned, but is not yet ready for use.  This will
		 *	be set to ready when a successsful confirm is received from the
		 *	transport layer.
		 */
		Transport_Connection[priority] = transport_connection;
		Transport_Connection_PDU_Type[priority] = CONNECT_MCS_PDU;
		Transport_Connection_State[priority] = TRANSPORT_CONNECTION_PENDING;
	}
	else
	{
		/*
		 *	The call to the transport layer failed.  Report the error to the
		 *	diagnostic window, and let the error fall through.
		 */
		WARNING_OUT (("Connection::CreateTransportConnection: "
				"connect request failed"));
	}

	return (transport_error);
}

/*
 *	TransportError	AcceptTransportConnection ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called in order to register this connection object
 *		with the transport interface.
 *
 *	Caveats:
 *		None.
 */
TransportError	Connection::AcceptTransportConnection (
						TransportConnection		transport_connection,
						Priority				priority)
{
	TransportError		transport_error;

	/*
	 *	Attempt to register this object with the transport interface.  If
	 *	successful, all indications associated with this transport connection
	 *	will be sent directly to this object.
	 */
	ASSERT(g_Transport != NULL);
	transport_error = g_Transport->RegisterTransportConnection (
			transport_connection, this, priority < MEDIUM_PRIORITY);

	if (transport_error == TRANSPORT_NO_ERROR)
	{
		/*
		 *	Save the transport connection handle that we are supposed to use
		 *	for top priority data transfer.  Also, since this is an inbound
		 *	request, the top priority transport connection IS valid.  Mark
		 *	it as such, allowing data transfer to occur immediately.
		 */
		Transport_Connection[priority] = transport_connection;
		Transport_Connection_PDU_Type[priority] = DOMAIN_MCS_PDU;
		Transport_Connection_State[priority] = TRANSPORT_CONNECTION_READY;
		Transport_Connection_Count++;
	}
	else
	{
		/*
		 *	The call to the transport layer failed.  Report the error to the
		 *	diagnostic window, and let the error fall through.
		 */
		WARNING_OUT (("Connection::AcceptTransportConnection: "
				"invalid transport connection"));
	}

	return (transport_error);
}

/*
 *	Void	AdjustDomainParameters ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called in order to adjust the domain parameters so that
 *		they fall within the allowable range.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::AdjustDomainParameters (
				PDomainParameters	min_domain_parameters,
				PDomainParameters	max_domain_parameters,
				PDomainParameters	domain_parameters)
{
	/*
	 *	Adjust the maximum number of channels to fall within the range.
	 */
	if (domain_parameters->max_channel_ids <
			min_domain_parameters->max_channel_ids)
		domain_parameters->max_channel_ids =
			min_domain_parameters->max_channel_ids;
	else if (domain_parameters->max_channel_ids >
			max_domain_parameters->max_channel_ids)
		domain_parameters->max_channel_ids =
			max_domain_parameters->max_channel_ids;

	/*
	 *	Adjust the maximum number of users to fall within the range.
	 */
	if (domain_parameters->max_user_ids <
			min_domain_parameters->max_user_ids)
		domain_parameters->max_user_ids =
			min_domain_parameters->max_user_ids;
	else if (domain_parameters->max_user_ids >
			max_domain_parameters->max_user_ids)
		domain_parameters->max_user_ids =
			max_domain_parameters->max_user_ids;

	/*
	 *	Adjust the maximum number of tokens to fall within the range.
	 */
	if (domain_parameters->max_token_ids <
			min_domain_parameters->max_token_ids)
		domain_parameters->max_token_ids =
			min_domain_parameters->max_token_ids;
	else if (domain_parameters->max_token_ids >
			max_domain_parameters->max_token_ids)
		domain_parameters->max_token_ids =
			max_domain_parameters->max_token_ids;

	/*
	 *	Adjust the number of priorities to fall within the range.
	 */
	if (domain_parameters->number_priorities <
			min_domain_parameters->number_priorities)
		domain_parameters->number_priorities =
			min_domain_parameters->number_priorities;
	else if (domain_parameters->number_priorities >
			max_domain_parameters->number_priorities)
		domain_parameters->number_priorities =
			max_domain_parameters->number_priorities;

	/*
	 *	Adjust the minimum throughput to fall within the range.
	 */
	if (domain_parameters->min_throughput <
			min_domain_parameters->min_throughput)
		domain_parameters->min_throughput =
			min_domain_parameters->min_throughput;
	else if (domain_parameters->min_throughput >
			max_domain_parameters->min_throughput)
		domain_parameters->min_throughput =
			max_domain_parameters->min_throughput;

	/*
	 *	Adjust the maximum domain height to fall within the range.
	 */
	if (domain_parameters->max_height <
			min_domain_parameters->max_height)
		domain_parameters->max_height =
			min_domain_parameters->max_height;
	else if (domain_parameters->max_height >
			max_domain_parameters->max_height)
		domain_parameters->max_height =
			max_domain_parameters->max_height;

	/*
	 *	Adjust the maximum PDU size to fall within the range.
	 */
	if (domain_parameters->max_mcspdu_size <
			min_domain_parameters->max_mcspdu_size)
		domain_parameters->max_mcspdu_size =
			min_domain_parameters->max_mcspdu_size;
	else if (domain_parameters->max_mcspdu_size >
			max_domain_parameters->max_mcspdu_size)
		domain_parameters->max_mcspdu_size =
			max_domain_parameters->max_mcspdu_size;

	/*
	 *	Adjust the protocol version to fall within the range.
	 */
	if (domain_parameters->protocol_version <
			min_domain_parameters->protocol_version)
		domain_parameters->protocol_version =
			min_domain_parameters->protocol_version;
	else if (domain_parameters->protocol_version >
			max_domain_parameters->protocol_version)
		domain_parameters->protocol_version =
			max_domain_parameters->protocol_version;
}

/*
 *	BOOL    MergeDomainParameters ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called in order to calculate the optimum overlap
 *		between the local and remote domain parameters.  If there is no overlap,
 *		this routine will return a value causing this connection to be
 *		destroyed.
 *
 *	Caveats:
 *		None.
 */
BOOL    Connection::MergeDomainParameters (
				PDomainParameters	min_domain_parameters1,
				PDomainParameters	max_domain_parameters1,
				PDomainParameters	min_domain_parameters2,
				PDomainParameters	max_domain_parameters2)
{
	BOOL    	valid=TRUE;

	/*
	 *	Determine the overlap for maximum number of channels.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->max_channel_ids <
			min_domain_parameters1->max_channel_ids)
		min_domain_parameters2->max_channel_ids =
			min_domain_parameters1->max_channel_ids;
	if (max_domain_parameters2->max_channel_ids >
			max_domain_parameters1->max_channel_ids)
		max_domain_parameters2->max_channel_ids =
			max_domain_parameters1->max_channel_ids;
	if (min_domain_parameters2->max_channel_ids >
			max_domain_parameters2->max_channel_ids)
		valid = FALSE;

	/*
	 *	Determine the overlap for maximum number of users.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->max_user_ids <
			min_domain_parameters1->max_user_ids)
		min_domain_parameters2->max_user_ids =
			min_domain_parameters1->max_user_ids;
	if (max_domain_parameters2->max_user_ids >
			max_domain_parameters1->max_user_ids)
		max_domain_parameters2->max_user_ids =
			max_domain_parameters1->max_user_ids;
	if (min_domain_parameters2->max_user_ids >
			max_domain_parameters2->max_user_ids)
		valid = FALSE;

	/*
	 *	Determine the overlap for maximum number of tokens.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->max_token_ids <
			min_domain_parameters1->max_token_ids)
		min_domain_parameters2->max_token_ids =
			min_domain_parameters1->max_token_ids;
	if (max_domain_parameters2->max_token_ids >
			max_domain_parameters1->max_token_ids)
		max_domain_parameters2->max_token_ids =
			max_domain_parameters1->max_token_ids;
	if (min_domain_parameters2->max_token_ids >
			max_domain_parameters2->max_token_ids)
		valid = FALSE;

	/*
	 *	Determine the overlap for number of priorities.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->number_priorities <
			min_domain_parameters1->number_priorities)
		min_domain_parameters2->number_priorities =
			min_domain_parameters1->number_priorities;
	if (max_domain_parameters2->number_priorities >
			max_domain_parameters1->number_priorities)
		max_domain_parameters2->number_priorities =
			max_domain_parameters1->number_priorities;
	if (min_domain_parameters2->number_priorities >
			max_domain_parameters2->number_priorities)
		valid = FALSE;

	/*
	 *	Determine the overlap for minimum throughput.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->min_throughput <
			min_domain_parameters1->min_throughput)
		min_domain_parameters2->min_throughput =
			min_domain_parameters1->min_throughput;
	if (max_domain_parameters2->min_throughput >
			max_domain_parameters1->min_throughput)
		max_domain_parameters2->min_throughput =
			max_domain_parameters1->min_throughput;
	if (min_domain_parameters2->min_throughput >
			max_domain_parameters2->min_throughput)
		valid = FALSE;

	/*
	 *	Determine the overlap for maximum domain height.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->max_height <
			min_domain_parameters1->max_height)
		min_domain_parameters2->max_height =
			min_domain_parameters1->max_height;
	if (max_domain_parameters2->max_height >
			max_domain_parameters1->max_height)
		max_domain_parameters2->max_height =
			max_domain_parameters1->max_height;
	if (min_domain_parameters2->max_height >
			max_domain_parameters2->max_height)
		valid = FALSE;

	/*
	 *	Determine the overlap for maximum PDU size.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->max_mcspdu_size <
			min_domain_parameters1->max_mcspdu_size)
		min_domain_parameters2->max_mcspdu_size =
			min_domain_parameters1->max_mcspdu_size;
	if (max_domain_parameters2->max_mcspdu_size >
			max_domain_parameters1->max_mcspdu_size)
		max_domain_parameters2->max_mcspdu_size =
			max_domain_parameters1->max_mcspdu_size;
	if (min_domain_parameters2->max_mcspdu_size >
			max_domain_parameters2->max_mcspdu_size)
		valid = FALSE;

	/*
	 *	Determine the overlap for protocol version.  If there is no
	 *	overlap, set the valid flag to FALSE.
	 */
	if (min_domain_parameters2->protocol_version <
			min_domain_parameters1->protocol_version)
		min_domain_parameters2->protocol_version =
			min_domain_parameters1->protocol_version;
	if (max_domain_parameters2->protocol_version >
			max_domain_parameters1->protocol_version)
		max_domain_parameters2->protocol_version =
			max_domain_parameters1->protocol_version;
	if (min_domain_parameters2->protocol_version >
			max_domain_parameters2->protocol_version)
		valid = FALSE;

	return (valid);
}

/*
 *	Void	PrintDomainParameters ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is used for debug purposes in order to print out the
 *		current set of domain parameters.
 *
 *	Caveats:
 *		None.
 */
#ifdef	DEBUG
Void	Connection::PrintDomainParameters (
				PDomainParameters	domain_parameters)
{
	TRACE_OUT (("    Maximum Channels = %ld",
			(ULong) domain_parameters->max_channel_ids));
	TRACE_OUT (("    Maximum Users = %ld",
			(ULong) domain_parameters->max_user_ids));
	TRACE_OUT (("    Maximum Tokens = %ld",
			(ULong) domain_parameters->max_token_ids));
	TRACE_OUT (("    Number of Priorities = %ld",
			(ULong) domain_parameters->number_priorities));
	TRACE_OUT (("    Minimum Throughput = %ld",
			(ULong) domain_parameters->min_throughput));
	TRACE_OUT (("    Maximum Domain Height = %ld",
			(ULong) domain_parameters->max_height));
	TRACE_OUT (("    Maximum PDU Size = %ld",
			(ULong) domain_parameters->max_mcspdu_size));
	TRACE_OUT (("    Protocol Version = %ld",
			(ULong) domain_parameters->protocol_version));
}
#endif // DEBUG


/*
 *	Void	PlumbDomainIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"PlumbDomainIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::PlumbDomainIndication (
				ULong			height_limit)
{
	DomainMCSPDU		plumb_domain_indication_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	plumb_domain_indication_pdu.choice = PLUMB_DOMAIN_INDICATION_CHOSEN;
	plumb_domain_indication_pdu.u.plumb_domain_indication.height_limit =
			height_limit;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &plumb_domain_indication_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	ErectDomainRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ErectDomainRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ErectDomainRequest (
				UINT_PTR             	height_in_domain,
				ULong			throughput_interval)
{
	DomainMCSPDU		erect_domain_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	erect_domain_request_pdu.choice = ERECT_DOMAIN_REQUEST_CHOSEN;
	erect_domain_request_pdu.u.erect_domain_request.sub_height =
			height_in_domain;
	erect_domain_request_pdu.u.erect_domain_request.sub_interval =
			throughput_interval;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &erect_domain_request_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	RejectUltimatum ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"RejectUltimatum" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::RejectUltimatum (
				Diagnostic		diagnostic,
				PUChar			octet_string_address,
				ULong			octet_string_length)
{
	DomainMCSPDU		reject_ultimatum_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	reject_ultimatum_pdu.choice = REJECT_ULTIMATUM_CHOSEN;
	reject_ultimatum_pdu.u.reject_user_ultimatum.diagnostic = diagnostic;
	reject_ultimatum_pdu.u.reject_user_ultimatum.initial_octets.length =
			(UShort) octet_string_length;
	reject_ultimatum_pdu.u.reject_user_ultimatum.initial_octets.value =
			octet_string_address;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &reject_ultimatum_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	MergeChannelsRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeChannelsRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::MergeChannelsRequest (
				CChannelAttributesList *merge_channel_list,
				CChannelIDList         *purge_channel_list)
{
	MergeChannelsRC (MERGE_CHANNELS_REQUEST_CHOSEN, merge_channel_list, purge_channel_list);
}


/*
 *	Void	MergeChannelsConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeChannelsConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::MergeChannelsConfirm (
				CChannelAttributesList *merge_channel_list,
				CChannelIDList         *purge_channel_list)
{
	MergeChannelsRC (MERGE_CHANNELS_CONFIRM_CHOSEN, merge_channel_list, purge_channel_list);
}


/*
 *	Void	MergeChannelsRC ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeChannelsRequest" or a "MergeChannelsConfirm" PDU
 *		through the transport interface.
 *
 *	IMPORTANT:
 *		Since the code is used for both PDUs the DomainMCSPDU's
 *		merge_channels_request and merge_channels_confirm fields should
 *		be identical structures.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::MergeChannelsRC (
				ASN1choice_t			choice,
				CChannelAttributesList *merge_channel_list,
				CChannelIDList         *purge_channel_list)
{

	BOOL    					memory_error = FALSE;
	DomainMCSPDU				merge_channels_pdu;
	DWORD						channel_attributes_count;
	PSetOfPDUChannelAttributes	setof_channel_attributes;
	PChannelAttributes			channel_attributes;
	PSetOfUserIDs				user_ids_pointer;
	DWORD						purge_channel_count;
	PSetOfChannelIDs			channel_ids_pointer;
	DWORD						dwMemoryToAlloc;
	CUidList                   *user_admit_list;

	/*
	 *	Set the type of PDU to be encoded.
	 */
	merge_channels_pdu.choice = choice;

	/*
	 *	Determine how many channel attributes entries there are in the lists.
	 *	If there are any entries, allocate memory to hold the associated
	 *	structures.
	 */
	channel_attributes_count = merge_channel_list->GetCount();
	purge_channel_count = purge_channel_list->GetCount();

	if ((channel_attributes_count != 0) || (purge_channel_count != 0)) {
		// Determine how much memory we need to allocate
		dwMemoryToAlloc = channel_attributes_count * sizeof (SetOfPDUChannelAttributes) +
							purge_channel_count * sizeof (SetOfChannelIDs);
		merge_channel_list->Reset();
		while (NULL != (channel_attributes = merge_channel_list->Iterate()))
		{
			if (PRIVATE_CHANNEL == channel_attributes->channel_type) {
				dwMemoryToAlloc += sizeof (SetOfUserIDs) *
							(channel_attributes->u.
							private_channel_attributes.admitted_list)->GetCount();
			}
		}

		// Allocate the needed amount of memory.
		DBG_SAVE_FILE_LINE
		setof_channel_attributes = (PSetOfPDUChannelAttributes) Allocate (dwMemoryToAlloc);

		if (setof_channel_attributes == NULL) {
			memory_error = TRUE;
		}
	}
	else {
		setof_channel_attributes = NULL;
	}

	if (setof_channel_attributes == NULL) {
		merge_channels_pdu.u.merge_channels_request.purge_channel_ids = NULL;
		merge_channels_pdu.u.merge_channels_request.merge_channels = NULL;
	}
	else {
		/*
		 *	Get the base address of the array of SetOfChannelIDs structures.
		 */
		channel_ids_pointer = (PSetOfChannelIDs) (((PUChar) setof_channel_attributes) +
					channel_attributes_count * sizeof (SetOfPDUChannelAttributes));
							
		if (channel_attributes_count != 0) {
			/*
			 *	Get the base address of the array of SetOfPDUChannelAttributes
			 *	structures.  Put it into the PDU structure.
			 */
			merge_channels_pdu.u.merge_channels_request.merge_channels =
													setof_channel_attributes;

			/*
			 *	Get the base address of the array of SetOfUserIDs structures.
			 */
			user_ids_pointer = (PSetOfUserIDs) (((PUChar) channel_ids_pointer) +
							purge_channel_count * sizeof (SetOfChannelIDs));

			/*
			 *	Set up an iterator for the list of channel attributes.  Retrieve
			 *	the channel attributes structures from the list and construct the
			 *	PDU structure.
			 */
			merge_channel_list->Reset();
			while (NULL != (channel_attributes = merge_channel_list->Iterate()))
			{
				/*
				 *	Use the channel type to determine what information to include in
				 *	the PDU structure.
				 */
				switch (channel_attributes->channel_type)
				{
					case STATIC_CHANNEL:
						setof_channel_attributes->value.choice =
								CHANNEL_ATTRIBUTES_STATIC_CHOSEN;

						setof_channel_attributes->value.u.
								channel_attributes_static.channel_id =
								channel_attributes->u.
								static_channel_attributes.channel_id;
						break;
	
					case USER_CHANNEL:
						setof_channel_attributes->value.choice =
								CHANNEL_ATTRIBUTES_USER_ID_CHOSEN;

						setof_channel_attributes->value.u.
								channel_attributes_user_id.joined =
								(ASN1bool_t)channel_attributes->u.
								user_channel_attributes.joined;

						setof_channel_attributes->value.u.
								channel_attributes_user_id.user_id =
								channel_attributes->u.
								user_channel_attributes.user_id;
						break;

					case PRIVATE_CHANNEL:
						setof_channel_attributes->value.choice =
								CHANNEL_ATTRIBUTES_PRIVATE_CHOSEN;

						setof_channel_attributes->value.u.
								channel_attributes_private.joined =
								(ASN1bool_t)channel_attributes->u.
								private_channel_attributes.joined;

						setof_channel_attributes->value.u.
								channel_attributes_private.channel_id =
								channel_attributes->u.
								private_channel_attributes.channel_id;

						setof_channel_attributes->value.u.
								channel_attributes_private.manager =
								channel_attributes->u.
								private_channel_attributes.channel_manager;

						/*
						 *	Get the number of the User IDs in the list of user ID's
						 */
						if ((channel_attributes->u.private_channel_attributes.				
											admitted_list)->GetCount() > 0)
						{
							/*
							 *	Get the base address of the array of SetOfUserIDs
							 *	structures.  Put it into the channel attributes
							 *	structure.
							 */
							setof_channel_attributes->value.u.channel_attributes_private.admitted =
														user_ids_pointer;
	
							/*
							 *	Iterate through the set of user ids, filling in the
							 *	PDU structure.
							 */
							user_admit_list = channel_attributes->u.private_channel_attributes.admitted_list;
							user_admit_list->BuildExternalList(&user_ids_pointer);
						}
						else
						{
							/*
							 *	There are either no users admitted to this channel,
							 *	or a memory allocation error occurred above.
							 *	Either way, we need to set the admitted array
							 *	address to NULL.
							 */
							setof_channel_attributes->value.u.
										channel_attributes_private.admitted = NULL;
						}
						break;
	
					case ASSIGNED_CHANNEL:
						setof_channel_attributes->value.choice =
								CHANNEL_ATTRIBUTES_ASSIGNED_CHOSEN;

						setof_channel_attributes->value.u.
								channel_attributes_assigned.channel_id =
								channel_attributes->u.
								assigned_channel_attributes.channel_id;
						break;

					default:
						WARNING_OUT(("Connection::MergeChannelsRC: "
								"ERROR - bad channel type"));
						break;
				}

				/*
				 *	Set the next pointer to point to the next element of the
				 *	PDU channel attributes structure array.  Then increment the
				 *	pointer.
				 */
				setof_channel_attributes->next = setof_channel_attributes + 1;
				setof_channel_attributes++;
			}

			/*
			 *	Decrement the pointer in order to set the last "next" pointer to
			 *	NULL.
			 */
			(setof_channel_attributes - 1)->next = NULL;
		}
		else {
			/*	There are no channels to merge. We need to set the structure
			 *	array address to NULL.
			 */
			merge_channels_pdu.u.merge_channels_request.merge_channels = NULL;
		}

		// Work on the purged channels.
		if (purge_channel_count != 0) {

			/*
			 *	Get the base address of the array of SetOfChannelIDs structures.
			 *	Put it into the PDU structure.
			 */
			merge_channels_pdu.u.merge_channels_request.purge_channel_ids = channel_ids_pointer;
            purge_channel_list->BuildExternalList(&channel_ids_pointer);
		}
		else
		{
			/*
			 *	There are either no channels to purge or a memory allocation
			 *	failure occurred above.  Either way, we need to set the structure
			 *	array address to NULL.
			 */
			merge_channels_pdu.u.merge_channels_request.purge_channel_ids = NULL;
		}
	}

	/*
	 *	Send the packet to the remote provider.
	 */
	if (memory_error == FALSE)
		SendPacket ((PVoid) &merge_channels_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
	else
	{
		/*
		 *	A memory allocation failure occurred somewhere above.  Report the
		 *	error and destroy this faulty connection.
		 */
		ERROR_OUT (("Connection::MergeChannelsRC: memory allocation failure"));
		DestroyConnection (REASON_PROVIDER_INITIATED);
	}

	/*
	 *	Free up the memory block that was allocated to build this PDU
	 *	structure.
	 */
	Free(setof_channel_attributes - channel_attributes_count);
}


/*
 *	Void	PurgeChannelsIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"PurgeChannelsIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::PurgeChannelsIndication (
				CUidList           *purge_user_list,
				CChannelIDList     *purge_channel_list)
{
	BOOL    			memory_error = FALSE;
	DomainMCSPDU		purge_channel_indication_pdu;
	ULong				user_id_count;
	PSetOfUserIDs		user_ids_pointer;
	DWORD				purge_channel_count;
	PSetOfChannelIDs	channel_ids_pointer;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	purge_channel_indication_pdu.choice = PURGE_CHANNEL_INDICATION_CHOSEN;
	
	/*
	 *	Allocate memory to hold the list of user ID's and the list
	 *	of purged channels.  If the allocation
	 *	fails, set the flag which will result in a callback to the
	 *	controller requesting that this connection be deleted.
	 */
	user_id_count = purge_user_list->GetCount();
	purge_channel_count = purge_channel_list->GetCount();

	if (user_id_count != 0 || purge_channel_count != 0)
	{
		DBG_SAVE_FILE_LINE
		user_ids_pointer = (PSetOfUserIDs) Allocate (user_id_count * sizeof (SetOfUserIDs) +
											purge_channel_count * sizeof (SetOfChannelIDs));

		if (user_ids_pointer == NULL) {
			memory_error = TRUE;
		}
	}
	else
		user_ids_pointer = NULL;

	if (user_ids_pointer == NULL) {
		purge_channel_indication_pdu.u.purge_channel_indication.detach_user_ids = NULL;
		purge_channel_indication_pdu.u.purge_channel_indication.purge_channel_ids = NULL;
	}
	else {
		if (user_id_count != 0) {
			/*
			 *	Fill in the structure's pointer to the set of user ID's.
			 */
			purge_channel_indication_pdu.u.purge_channel_indication.detach_user_ids = user_ids_pointer;
            purge_user_list->BuildExternalList(&user_ids_pointer);
		}
		else
		{
			/*
			 *	Either there are no user IDs to purge or a memory allocation
			 *	failed above.  Either way, put NULL into the PDU structure to
			 *	indicate that there is no list of IDs.
			 */
			purge_channel_indication_pdu.u.purge_channel_indication.
												detach_user_ids = NULL;
		}

		if (purge_channel_count != 0) {
			/*
			 *	Fill in the structure's pointer to the set of purge channel ID's.
			 */
			channel_ids_pointer = (PSetOfChannelIDs) user_ids_pointer;
			purge_channel_indication_pdu.u.purge_channel_indication.purge_channel_ids = channel_ids_pointer;
            purge_channel_list->BuildExternalList(&channel_ids_pointer);
		}
		else
		{
			/*
			 *	Either there are no channel IDs to purge or a memory allocation
			 *	failed above.  Either way, put NULL into the PDU structure to
			 *	indicate that there is no list of IDs.
			 */
			purge_channel_indication_pdu.u.purge_channel_indication.purge_channel_ids = NULL;
		}
	}

	/*
	 *	Send the packet to the remote provider.
	 */
	if (memory_error == FALSE)
		SendPacket ((PVoid) &purge_channel_indication_pdu, DOMAIN_MCS_PDU,
				TOP_PRIORITY);
	else
	{
		/*
		 *	A memory allocation failure occurred somewhere above.  Report the
		 *	error and destroy this faulty connection.
		 */
		ERROR_OUT (("Connection::PurgeChannelsIndication: "
				"memory allocation failure"));
		DestroyConnection (REASON_PROVIDER_INITIATED);
	}

	/*
	 *	Free all memory allocated above.
	 */
	Free(user_ids_pointer - user_id_count);
}

/*
 *	Void	MergeTokenRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeTokensRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::MergeTokensRequest (
				CTokenAttributesList       *merge_token_list,
				CTokenIDList               *purge_token_list)
{
	MergeTokensRC (MERGE_TOKENS_REQUEST_CHOSEN, merge_token_list, purge_token_list);
}

/*
 *	Void	MergeTokenConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeTokenConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::MergeTokensConfirm (
				CTokenAttributesList       *merge_token_list,
				CTokenIDList               *purge_token_list)
{
	MergeTokensRC (MERGE_TOKENS_CONFIRM_CHOSEN, merge_token_list, purge_token_list);
}


/*
 *	Void	MergeTokenRC ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"MergeTokenConfirm" PDU or a "MergeTokenRequest" PDU through
 *		the transport interface.
 *
 *	IMPORTANT:
 *		Since the code is used for both PDUs the DomainMCSPDU's
 *		merge_tokens_request and merge_tokens_confirm fields should
 *		be identical structures.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::MergeTokensRC (
				ASN1choice_t				choice,
				CTokenAttributesList       *merge_token_list,
				CTokenIDList               *purge_token_list)

{
	BOOL    					memory_error = FALSE;
	DomainMCSPDU				merge_tokens_pdu;
	DWORD						token_attributes_count;
	PSetOfPDUTokenAttributes	setof_token_attributes;
	PTokenAttributes			token_attributes;
	PSetOfUserIDs				user_ids_pointer;
	DWORD						purge_token_count;
	PSetOfTokenIDs				token_ids_pointer;
	DWORD						dwMemoryToAlloc;
	CUidList                   *user_inhibit_list;

	merge_tokens_pdu.choice = choice;

	/*
	 *	Determine how many tokens are being merged with this PDU.  This is
	 *	used to allocate a buffer for big enough for all of the needed token
	 *	attributes structures.
	 */
	token_attributes_count = merge_token_list->GetCount();
	purge_token_count = purge_token_list->GetCount();

	if ((token_attributes_count != 0) || (purge_token_count != 0)) {
		// Determine how much memory we need to allocate
		dwMemoryToAlloc = token_attributes_count * sizeof (SetOfPDUTokenAttributes) +
							purge_token_count * sizeof (SetOfTokenIDs);
		merge_token_list->Reset();
		while (NULL != (token_attributes = merge_token_list->Iterate()))
		{
			if (TOKEN_INHIBITED == token_attributes->token_state) {
				dwMemoryToAlloc += sizeof (SetOfUserIDs) *
							token_attributes->u.inhibited_token_attributes.
							inhibitors->GetCount();
			}
		}

		// Allocate the needed amount of memory.
		DBG_SAVE_FILE_LINE
		setof_token_attributes = (PSetOfPDUTokenAttributes) Allocate (dwMemoryToAlloc);

		if (setof_token_attributes == NULL) {
			memory_error = TRUE;
		}
	}
	else {
		setof_token_attributes = NULL;
	}

	if (setof_token_attributes == NULL) {
		merge_tokens_pdu.u.merge_tokens_confirm.merge_tokens = NULL;
		merge_tokens_pdu.u.merge_tokens_confirm.purge_token_ids = NULL;
	}
	else {

		/*
		 *	Compute where the set of purged token IDs will start from in the
		 *	memory previously allocated.
		 */
		token_ids_pointer = (PSetOfTokenIDs) ((PUChar) setof_token_attributes +
							token_attributes_count * sizeof (SetOfPDUTokenAttributes));

		if (token_attributes_count != 0) {
			/*
			 *	Get the base address of the array of SetOfPDUTokenAttributes
			 *	structures.  Put it into the PDU structure.
			 */
			merge_tokens_pdu.u.merge_tokens_confirm.merge_tokens =
													setof_token_attributes;

			/*
			 *	Compute the base address of the arrays of SetOfUserIDs structures.
			 */
			user_ids_pointer = (PSetOfUserIDs) ((PUChar) token_ids_pointer +
							purge_token_count * sizeof (SetOfTokenIDs));

			/*
			 *	Set up an iterator for the list of token attributes.  Retrieve
			 *	the token attributes structures from the list and construct the
			 *	PDU structure.
			 */
			merge_token_list->Reset();
			while (NULL != (token_attributes = merge_token_list->Iterate()))
			{
				/*
				 *	Use the token state to determine what information to include in
				 *	the PDU structure.
				 */
				switch (token_attributes->token_state)
				{
				case TOKEN_GRABBED:
					setof_token_attributes->value.choice = GRABBED_CHOSEN;

					setof_token_attributes->value.u.grabbed.token_id =
							token_attributes->u.
							grabbed_token_attributes.token_id;
					setof_token_attributes->value.u.grabbed.grabber =
							token_attributes->u.
							grabbed_token_attributes.grabber;
					break;

				case TOKEN_INHIBITED:
					setof_token_attributes->value.choice = INHIBITED_CHOSEN;

					setof_token_attributes->value.u.inhibited.token_id =
							token_attributes->u.
							inhibited_token_attributes.token_id;

					if ((token_attributes->u.inhibited_token_attributes.
											inhibitors)->GetCount() > 0)
					{
						/*
						 *	Get the base address of the array of SetOfUserIDs
						 *	structures.  Put it into the channel attributes
						 *	structure.
						 */
						setof_token_attributes->value.u.inhibited.inhibitors =
								user_ids_pointer;

						/*
						 *	Iterate through the User ID list, adding each user
						 *	to the PDU.
						 */
						user_inhibit_list = token_attributes->u.inhibited_token_attributes.inhibitors;
						user_inhibit_list->BuildExternalList(&user_ids_pointer);
					}
					else
					{
						/*
						 *	Either there were no inhibitors of this token, or
						 *	a memory allocation failure occurred above.  Either
						 *	way, put a NULL into the PDU structure to indicate
						 *	that this field is unused.
						 */
						setof_token_attributes->value.u.inhibited.inhibitors =
								NULL;
					}
					break;

				case TOKEN_GIVING:
					setof_token_attributes->value.choice = GIVING_CHOSEN;

					/*
					 *	IMPORTANT:
					 *	The two structs involved in this memcpy should have
					 *	same-type fields.
					 *	Original code is included below.
					 */
					memcpy (&(setof_token_attributes->value.u.giving),
							&(token_attributes->u.giving_token_attributes),
							sizeof (Giving));
/*
					setof_token_attributes->value.u.giving.token_id =
							token_attributes->u.
							giving_token_attributes.token_id;

					setof_token_attributes->value.u.giving.grabber =
							token_attributes->u.
							giving_token_attributes.grabber;

					setof_token_attributes->value.u.giving.recipient =
							token_attributes->u.
							giving_token_attributes.recipient;
*/
					break;

				case TOKEN_GIVEN:
					setof_token_attributes->value.choice = GIVEN_CHOSEN;

					setof_token_attributes->value.u.given.token_id =
							token_attributes->u.
							given_token_attributes.token_id;

					setof_token_attributes->value.u.given.recipient =
							token_attributes->u.
							given_token_attributes.recipient;
					break;

				default:
					WARNING_OUT(("Connection::MergeTokensRC: bad channel type"));
					break;
				}

				/*
				 *	Set the next pointer to point to the next element of the
				 *	PDU token attributes structure array.  Then increment the
				 *	pointer.
				 */
				setof_token_attributes->next = setof_token_attributes + 1;
				setof_token_attributes++;
			}

			/*
			 *	Decrement the pointer in order to set the last "next" pointer to
			 *	NULL.
			 */
			(setof_token_attributes - 1)->next = NULL;
		}
		else
		{
			/*
			 *	Either there are no tokens to merge, or a memory allocation failure
			 *	occurred above.  Either way put a NULL into the PDU structure to
			 *	indicate that this field is unused.
			 */
			merge_tokens_pdu.u.merge_tokens_confirm.merge_tokens = NULL;
		}

		if (purge_token_count != 0)
		{

			/*
			 *	Fill in the MergeTokensRequest structure's pointer to the set of
			 *	purge token ID's.
			 */
			merge_tokens_pdu.u.merge_tokens_confirm.purge_token_ids = token_ids_pointer;
            purge_token_list->BuildExternalList(&token_ids_pointer);
		}
		else
		{
			/*
			 *	Either there are no tokens to be purged, or a memory allocation
			 *	failure occurred above.  Either way, put a NULL into the PDU
			 *	structure to indicate that this field is unused.
			 */
			merge_tokens_pdu.u.merge_tokens_confirm.purge_token_ids = NULL;
		}
	}

	/*
	 *	Send the packet to the remote provider.
	 */
	if (memory_error == FALSE)
		SendPacket ((PVoid) &merge_tokens_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
	else
	{
		/*
		 *	A memory allocation failure occurred somewhere above.  Report the
		 *	error and destroy this faulty connection.
		 */
		ERROR_OUT (("Connection::MergeTokensRC: memory allocation failure"));
		DestroyConnection (REASON_PROVIDER_INITIATED);
	}

	/*
	 *	Release all memory allocated above.
	 */
	Free(setof_token_attributes - token_attributes_count);
}

/*
 *	Void	PurgeTokensIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"PurgeTokenIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::PurgeTokensIndication (
				PDomain,
				CTokenIDList        *purge_token_list)
{
	BOOL    			memory_error=FALSE;
	DomainMCSPDU		purge_token_indication_pdu;
	DWORD				purge_token_count;
	PSetOfTokenIDs		token_ids_pointer;
    //TokenID             tid;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	purge_token_indication_pdu.choice = PURGE_TOKEN_INDICATION_CHOSEN;
	
	/*
	 *	Allocate memory to hold the list of purge tokens.  If the allocation
	 *	fails, set the flag which will result in a callback to the
	 *	controller requesting that this connection be deleted.
	 */
	purge_token_count = purge_token_list->GetCount();

	if (purge_token_count != 0)
	{
		DBG_SAVE_FILE_LINE
		token_ids_pointer = (PSetOfTokenIDs) Allocate (purge_token_count *
														sizeof (SetOfTokenIDs));

		if (token_ids_pointer == NULL)
			memory_error = TRUE;
	}
	else
		token_ids_pointer = NULL;

	if (token_ids_pointer!= NULL)	
	{
		/*
		 *	Fill in the structure's pointer to the set of purge token ID's.
		 */
		purge_token_indication_pdu.u.purge_token_indication.purge_token_ids = token_ids_pointer;
        purge_token_list->BuildExternalList(&token_ids_pointer);
	}
	else
	{
		/*
		 *	Either there are no tokens to purge or a memory allocation failure
		 *	occurred above.  Either way, put a NULL into the PDU structure to
		 *	indicate that this field is unused.
		 */
		purge_token_indication_pdu.u.purge_token_indication.purge_token_ids = NULL;
	}

	/*
	 *	Send the packet to the remote provider.
	 */
	if (memory_error == FALSE)
		SendPacket ((PVoid) &purge_token_indication_pdu, DOMAIN_MCS_PDU,
				TOP_PRIORITY);
	else
	{
		/*
		 *	A memory allocation failure occurred somewhere above.  Report the
		 *	error and destroy this faulty connection.
		 */
		ERROR_OUT (("Connection::PurgeTokensIndication: memory allocation failure"));
		DestroyConnection (REASON_PROVIDER_INITIATED);
	}

	/*
	 *	If memory was successfully allocated to hold the set of token ID's,
	 *	then free it here.
	 */
	Free(token_ids_pointer - purge_token_count);
}

/*
 *	Void	DisconnectProviderUltimatum ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"DisconnectProviderUltimatum" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::DisconnectProviderUltimatum (
				Reason				reason)
{
	/*
	 *	Set attachment to NULL to prevent any attempt to send a command to
	 *	the attachment that just disconnected us.
	 */
	m_pDomain = NULL;

	/*
	 *	Issue an owner callback to ask for deletion.  An attempt will be made
	 *	to send a DisconnectProviderUltimatum PDU through the transport
	 *	interface from the Connection's destructor.
	 */
	DestroyConnection (reason);
}

/*
 *	Void	AttachUserRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"AttachUserRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::AttachUserRequest ( void )
{
	DomainMCSPDU		attach_user_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	attach_user_request_pdu.choice = ATTACH_USER_REQUEST_CHOSEN;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &attach_user_request_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	AttachUserConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"AttachUserConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::AttachUserConfirm (
				Result				result,
				UserID				uidInitiator)
{
	DomainMCSPDU		attach_user_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	attach_user_confirm_pdu.choice = ATTACH_USER_CONFIRM_CHOSEN;
	if (result == RESULT_SUCCESSFUL)
		attach_user_confirm_pdu.u.attach_user_confirm.bit_mask =
				INITIATOR_PRESENT;
	else
		attach_user_confirm_pdu.u.attach_user_confirm.bit_mask = 0x00;
	attach_user_confirm_pdu.u.attach_user_confirm.result = (PDUResult)result;
	attach_user_confirm_pdu.u.attach_user_confirm.initiator = uidInitiator;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &attach_user_confirm_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	DetachUserRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"DetachUserRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::DetachUserRequest (
				Reason				reason,
				CUidList           *user_id_list)
{
	UserChannelRI (DETACH_USER_REQUEST_CHOSEN, (UINT) reason, 0, user_id_list);
}


/*
 *	Void	UserChannelRI ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"DetachUserRequest", "DetachUserIndication", "ChannelAdmitRequest",
 *		"ChannelAdmitIndication", "ChannelExpelRequest" or
 *		"ChannelExpelIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::UserChannelRI (
				ASN1choice_t		choice,
				UINT				reason_userID,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	BOOL    			memory_error = FALSE;
	DomainMCSPDU		domain_pdu;
	DWORD				user_ids_count;
	PSetOfUserIDs		user_ids_pointer;
    //UserID              uid;

	/*
	 *	Allocate memory to hold the list of users.  If the allocation
	 *	fails, set the flag which will result in a callback to the
	 *	controller requesting that this connection be deleted.
	 */
	user_ids_count = user_id_list->GetCount();

	if (user_ids_count != 0)
	{
		DBG_SAVE_FILE_LINE
		user_ids_pointer = (PSetOfUserIDs) Allocate (user_ids_count *
													sizeof (SetOfUserIDs));

		if (user_ids_pointer == NULL)
			memory_error = TRUE;
	}
	else
		user_ids_pointer = NULL;

	/*
	 *	Fill in the PDU structure to be encoded. Also,
	 *	get the base address of the SetOfUserIDs structure and put it into
	 *	the PDU structure.
	 */
	domain_pdu.choice = choice;
	switch (choice) {
		case DETACH_USER_REQUEST_CHOSEN:
		case DETACH_USER_INDICATION_CHOSEN:
			/*
			 *	IMPORTANT:
			 *		The detach_user_request and detach_user_indication structs
			 *		in DomainMCSPDU must be identical.
			 */
			domain_pdu.u.detach_user_request.reason = (PDUReason) reason_userID;
			domain_pdu.u.detach_user_request.user_ids = user_ids_pointer;
			break;

		case CHANNEL_ADMIT_REQUEST_CHOSEN:
		case CHANNEL_ADMIT_INDICATION_CHOSEN:
		case CHANNEL_EXPEL_REQUEST_CHOSEN:
			/*
			 *	IMPORTANT:
			 *		The channel_admit_request, channel_admit_indication
			 *		and channel_expel_request structs
			 *		in DomainMCSPDU must be identical.
			 */
			domain_pdu.u.channel_admit_request.initiator = (UserID) reason_userID;
			domain_pdu.u.channel_admit_request.channel_id = channel_id;
			domain_pdu.u.channel_admit_request.user_ids = user_ids_pointer;
			break;

		case CHANNEL_EXPEL_INDICATION_CHOSEN:
			domain_pdu.u.channel_expel_indication.channel_id = channel_id;
			domain_pdu.u.channel_expel_indication.user_ids = user_ids_pointer;
			break;

		default:
			ASSERT(FALSE);
			ERROR_OUT (("Connection::UserChannelRI: PDU should not be formed by this method."));
			break;
	}

    user_id_list->BuildExternalList(&user_ids_pointer);

	/*
	 *	Send the packet to the remote provider.
	 */
	if (memory_error == FALSE)
		SendPacket ((PVoid) &domain_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
	else
	{
		/*
		 *	A memory allocation failure occurred somewhere above.  Report the
		 *	error and destroy this faulty connection.
		 */
		ERROR_OUT (("Connection::UserChannelRI: memory allocation failure"));
		DestroyConnection (REASON_PROVIDER_INITIATED);
	}

	/*
	 *	If memory was successfully allocated to hold the set of user ID's,
	 *	then free it here.
	 */
	Free(user_ids_pointer - user_ids_count);
}

/*
 *	Void	DetachUserIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"DetachUserIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::DetachUserIndication (
				Reason				reason,
				CUidList           *user_id_list)
{
	UserChannelRI (DETACH_USER_INDICATION_CHOSEN, (UINT) reason, 0, user_id_list);
}


/*
 *	Void	ChannelJoinRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelJoinRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelJoinRequest (
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	DomainMCSPDU		channel_join_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	channel_join_request_pdu.choice = CHANNEL_JOIN_REQUEST_CHOSEN;
	channel_join_request_pdu.u.channel_join_request.initiator = uidInitiator;
	channel_join_request_pdu.u.channel_join_request.channel_id = channel_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &channel_join_request_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	ChannelJoinConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelJoinConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelJoinConfirm (
				Result				result,
				UserID				uidInitiator,
				ChannelID			requested_id,
				ChannelID			channel_id)
{
	DomainMCSPDU		channel_join_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	channel_join_confirm_pdu.choice = CHANNEL_JOIN_CONFIRM_CHOSEN;
	if (result == RESULT_SUCCESSFUL)
		channel_join_confirm_pdu.u.channel_join_confirm.bit_mask =
				JOIN_CHANNEL_ID_PRESENT;
	else
		channel_join_confirm_pdu.u.channel_join_confirm.bit_mask = 0x00;
	channel_join_confirm_pdu.u.channel_join_confirm.result = (PDUResult)result;
	channel_join_confirm_pdu.u.channel_join_confirm.initiator = uidInitiator;
	channel_join_confirm_pdu.u.channel_join_confirm.requested = requested_id;
	channel_join_confirm_pdu.u.channel_join_confirm.join_channel_id =
			channel_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &channel_join_confirm_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	ChannelLeaveRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelLeaveRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelLeaveRequest (
				CChannelIDList  *channel_id_list)
{
	BOOL    			memory_error=FALSE;
	DomainMCSPDU		channel_leave_request_pdu;
	DWORD				channel_ids_count;
	PSetOfChannelIDs	channel_ids_pointer;
    PSetOfChannelIDs    pToFree;
    //ChannelID           chid;

	/*
	 *	Fill in the elements of the PDU structure.
	 */
	channel_leave_request_pdu.choice = CHANNEL_LEAVE_REQUEST_CHOSEN;

	/*
	 *	Allocate memory to hold the list of channels.  If the allocation
	 *	fails, set the flag which will result in a callback to the
	 *	controller requesting that this connection be deleted.
	 */
	channel_ids_count = channel_id_list->GetCount();

	if (channel_ids_count != 0)
	{
		DBG_SAVE_FILE_LINE
		channel_ids_pointer = (PSetOfChannelIDs) Allocate (channel_ids_count *
													sizeof (SetOfChannelIDs));
		if (channel_ids_pointer == NULL)
			memory_error = TRUE;
	}
	else
		channel_ids_pointer = NULL;

    pToFree = channel_ids_pointer;

    /*
	 *	Get the base address of the array fo SetOfChannelIDs structure and
	 *	put it into the PDU structure.
	 */
	channel_leave_request_pdu.u.channel_leave_request.channel_ids = channel_ids_pointer;
    channel_id_list->BuildExternalList(&channel_ids_pointer);

	/*
	 *	Send the packet to the remote provider.
	 */
	if (memory_error == FALSE)
		SendPacket ((PVoid) &channel_leave_request_pdu, DOMAIN_MCS_PDU,
				TOP_PRIORITY);
	else
	{
		/*
		 *	A memory allocation failure occurred somewhere above.  Report the
		 *	error and destroy this faulty connection.
		 */
		ERROR_OUT (("Connection::ChannelLeaveRequest: memory allocation failure"));
		DestroyConnection (REASON_PROVIDER_INITIATED);
	}

	/*
	 *	If memory was successfully allocated to hold the set of channel ID's,
	 *	then free it here.
	 */
	Free(pToFree);
}

/*
 *	Void	ChannelConveneRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelConveneRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelConveneRequest (
				UserID				uidInitiator)
{
	DomainMCSPDU		channel_convene_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	channel_convene_request_pdu.choice = CHANNEL_CONVENE_REQUEST_CHOSEN;
	channel_convene_request_pdu.u.channel_convene_request.initiator =
			uidInitiator;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &channel_convene_request_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	ChannelConveneConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelConveneConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelConveneConfirm (
				Result				result,
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	DomainMCSPDU		channel_convene_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	channel_convene_confirm_pdu.choice = CHANNEL_CONVENE_CONFIRM_CHOSEN;
	if (result == RESULT_SUCCESSFUL)
		channel_convene_confirm_pdu.u.channel_convene_confirm.bit_mask =
			CONVENE_CHANNEL_ID_PRESENT;
	else
		channel_convene_confirm_pdu.u.channel_convene_confirm.bit_mask = 0x00;
	channel_convene_confirm_pdu.u.channel_convene_confirm.result =
			(PDUResult)result;
	channel_convene_confirm_pdu.u.channel_convene_confirm.initiator =
			uidInitiator;
	channel_convene_confirm_pdu.u.channel_convene_confirm.convene_channel_id =
			channel_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &channel_convene_confirm_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	ChannelDisbandRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelDisbandRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelDisbandRequest (
				UserID				uidInitiator,
				ChannelID			channel_id)
{
	DomainMCSPDU		channel_disband_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	channel_disband_request_pdu.choice = CHANNEL_DISBAND_REQUEST_CHOSEN;
	channel_disband_request_pdu.u.channel_disband_request.initiator =
			uidInitiator;
	channel_disband_request_pdu.u.channel_disband_request.channel_id =
			channel_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &channel_disband_request_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	ChannelDisbandIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelDisbandIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelDisbandIndication (
				ChannelID			channel_id)
{
	DomainMCSPDU		channel_disband_indication_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	channel_disband_indication_pdu.choice = CHANNEL_DISBAND_INDICATION_CHOSEN;
	channel_disband_indication_pdu.u.channel_disband_indication.channel_id =
			channel_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &channel_disband_indication_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	ChannelAdmitRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelAdmitRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelAdmitRequest (
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	UserChannelRI (CHANNEL_ADMIT_REQUEST_CHOSEN, (UINT) uidInitiator, channel_id,
					user_id_list);
}

/*
 *	Void	ChannelAdmitIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelAdmitIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelAdmitIndication (
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	UserChannelRI (CHANNEL_ADMIT_INDICATION_CHOSEN, (UINT) uidInitiator, channel_id,
					user_id_list);
}

/*
 *	Void	ChannelExpelRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelExpelRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelExpelRequest (
				UserID				uidInitiator,
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	UserChannelRI (CHANNEL_EXPEL_REQUEST_CHOSEN, (UINT) uidInitiator, channel_id,
					user_id_list);
}

/*
 *	Void	ChannelExpelIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"ChannelExpelIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::ChannelExpelIndication (
				ChannelID			channel_id,
				CUidList           *user_id_list)
{
	UserChannelRI (CHANNEL_EXPEL_INDICATION_CHOSEN, 0, channel_id,
					user_id_list);
}


/*
 *	Void	TokenGrabRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenGrabRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenGrabRequest (
				UserID				uidInitiator,
				TokenID				token_id)
{
	DomainMCSPDU		token_grab_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_grab_request_pdu.choice = TOKEN_GRAB_REQUEST_CHOSEN;
	token_grab_request_pdu.u.token_grab_request.initiator = uidInitiator;
	token_grab_request_pdu.u.token_grab_request.token_id = token_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_grab_request_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	TokenGrabConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenGrabConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenGrabConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	DomainMCSPDU		token_grab_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_grab_confirm_pdu.choice = TOKEN_GRAB_CONFIRM_CHOSEN;
	token_grab_confirm_pdu.u.token_grab_confirm.result = (PDUResult)result;
	token_grab_confirm_pdu.u.token_grab_confirm.initiator = uidInitiator;
	token_grab_confirm_pdu.u.token_grab_confirm.token_id = token_id;
	token_grab_confirm_pdu.u.token_grab_confirm.token_status =
			(PDUTokenStatus)token_status;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_grab_confirm_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	TokenInhibitRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenInhibitRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenInhibitRequest (
				UserID				uidInitiator,
				TokenID				token_id)
{
	DomainMCSPDU		token_inhibit_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_inhibit_request_pdu.choice = TOKEN_INHIBIT_REQUEST_CHOSEN;
	token_inhibit_request_pdu.u.token_inhibit_request.initiator = uidInitiator;
	token_inhibit_request_pdu.u.token_inhibit_request.token_id = token_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_inhibit_request_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	TokenInhibitConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenInhibitConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenInhibitConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	DomainMCSPDU		token_inhibit_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_inhibit_confirm_pdu.choice = TOKEN_INHIBIT_CONFIRM_CHOSEN;
	token_inhibit_confirm_pdu.u.token_inhibit_confirm.result =
			(PDUResult)result;
	token_inhibit_confirm_pdu.u.token_inhibit_confirm.initiator = uidInitiator;
	token_inhibit_confirm_pdu.u.token_inhibit_confirm.token_id = token_id;
	token_inhibit_confirm_pdu.u.token_inhibit_confirm.token_status =
			(PDUTokenStatus)token_status;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_inhibit_confirm_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	TokenGiveRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenGiveRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenGiveRequest (
				PTokenGiveRecord	pTokenGiveRec)
{
	DomainMCSPDU		token_give_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_give_request_pdu.choice = TOKEN_GIVE_REQUEST_CHOSEN;
	token_give_request_pdu.u.token_give_request.initiator = pTokenGiveRec->uidInitiator;
	token_give_request_pdu.u.token_give_request.token_id = pTokenGiveRec->token_id;
	token_give_request_pdu.u.token_give_request.recipient = pTokenGiveRec->receiver_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_give_request_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	TokenGiveIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenGiveIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenGiveIndication (
				PTokenGiveRecord	pTokenGiveRec)
{
	DomainMCSPDU		token_give_indication_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_give_indication_pdu.choice = TOKEN_GIVE_INDICATION_CHOSEN;
	token_give_indication_pdu.u.token_give_indication.initiator = pTokenGiveRec->uidInitiator;
	token_give_indication_pdu.u.token_give_indication.token_id = pTokenGiveRec->token_id;
	token_give_indication_pdu.u.token_give_indication.recipient = pTokenGiveRec->receiver_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_give_indication_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	TokenGiveResponse ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenGiveResponse" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenGiveResponse (
				Result				result,
				UserID				receiver_id,
				TokenID				token_id)
{
	DomainMCSPDU		token_give_response_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_give_response_pdu.choice = TOKEN_GIVE_RESPONSE_CHOSEN;
	token_give_response_pdu.u.token_give_response.result =
			(PDUResult)result;
	token_give_response_pdu.u.token_give_response.recipient = receiver_id;
	token_give_response_pdu.u.token_give_response.token_id = token_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_give_response_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	TokenGiveConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenGiveConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenGiveConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	DomainMCSPDU		token_give_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_give_confirm_pdu.choice = TOKEN_GIVE_CONFIRM_CHOSEN;
	token_give_confirm_pdu.u.token_give_confirm.result =
			(PDUResult)result;
	token_give_confirm_pdu.u.token_give_confirm.initiator = uidInitiator;
	token_give_confirm_pdu.u.token_give_confirm.token_id = token_id;
	token_give_confirm_pdu.u.token_give_confirm.token_status =
			(PDUTokenStatus)token_status;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_give_confirm_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	TokenPleaseRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenPleaseRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenPleaseRequest (
				UserID				uidInitiator,
				TokenID				token_id)
{
	DomainMCSPDU		token_please_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_please_request_pdu.choice = TOKEN_PLEASE_REQUEST_CHOSEN;
	token_please_request_pdu.u.token_please_request.initiator = uidInitiator;
	token_please_request_pdu.u.token_please_request.token_id = token_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_please_request_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	TokenPleaseIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenPleaseIndication" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenPleaseIndication (
				UserID				uidInitiator,
				TokenID				token_id)
{
	DomainMCSPDU		token_please_indication_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_please_indication_pdu.choice = TOKEN_PLEASE_INDICATION_CHOSEN;
	token_please_indication_pdu.u.token_please_request.initiator = uidInitiator;
	token_please_indication_pdu.u.token_please_request.token_id = token_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_please_indication_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	TokenReleaseRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenReleaseRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenReleaseRequest (
				UserID				uidInitiator,
				TokenID				token_id)
{
	DomainMCSPDU		token_release_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_release_request_pdu.choice = TOKEN_RELEASE_REQUEST_CHOSEN;
	token_release_request_pdu.u.token_release_request.initiator = uidInitiator;
	token_release_request_pdu.u.token_release_request.token_id = token_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_release_request_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	TokenReleaseConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenReleaseConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenReleaseConfirm (
				Result				result,
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	DomainMCSPDU		token_release_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_release_confirm_pdu.choice = TOKEN_RELEASE_CONFIRM_CHOSEN;
	token_release_confirm_pdu.u.token_release_confirm.result =
			(PDUResult)result;
	token_release_confirm_pdu.u.token_release_confirm.initiator = uidInitiator;
	token_release_confirm_pdu.u.token_release_confirm.token_id = token_id;
	token_release_confirm_pdu.u.token_release_confirm.token_status =
			(PDUTokenStatus)token_status;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_release_confirm_pdu, DOMAIN_MCS_PDU,
			TOP_PRIORITY);
}

/*
 *	Void	TokenTestRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenTestRequest" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenTestRequest (
				UserID				uidInitiator,
				TokenID				token_id)
{
	DomainMCSPDU		token_test_request_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_test_request_pdu.choice = TOKEN_TEST_REQUEST_CHOSEN;
	token_test_request_pdu.u.token_test_request.initiator = uidInitiator;
	token_test_request_pdu.u.token_test_request.token_id = token_id;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_test_request_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	TokenTestConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine is called by the domain in order to send a
 *		"TokenTestConfirm" PDU through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::TokenTestConfirm (
				UserID				uidInitiator,
				TokenID				token_id,
				TokenStatus			token_status)
{
	DomainMCSPDU		token_test_confirm_pdu;

	/*
	 *	Fill in the PDU structure to be encoded.
	 */
	token_test_confirm_pdu.choice = TOKEN_TEST_CONFIRM_CHOSEN;
	token_test_confirm_pdu.u.token_test_confirm.initiator = uidInitiator;
	token_test_confirm_pdu.u.token_test_confirm.token_id = token_id;
	token_test_confirm_pdu.u.token_test_confirm.token_status =
			(PDUTokenStatus)token_status;

	/*
	 *	Send the packet to the remote provider.
	 */
	SendPacket ((PVoid) &token_test_confirm_pdu, DOMAIN_MCS_PDU, TOP_PRIORITY);
}

/*
 *	Void	MergeDomainIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function is called when the attached domain enters or leaves the
 *		merge state.
 */
Void	Connection::MergeDomainIndication (
				MergeStatus			merge_status)
{
	/*
	 *	If this indication shows that a domain merger is in progress, set the
	 *	boolean flag that prevents the sending of MCS commands to the domain.
	 *	Otherwise, reset it.
	 */
	if (merge_status == MERGE_DOMAIN_IN_PROGRESS)
	{
		TRACE_OUT (("Connection::MergeDomainIndication: entering merge state"));
		Merge_In_Progress = TRUE;
	}
	else
	{
		TRACE_OUT (("Connection::MergeDomainIndication: leaving merge state"));
		Merge_In_Progress = FALSE;
	}
}

/*
 *	Void	SendPacket ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine is called in order to create a packet which will hold
 *		the PDU to be sent to the remote provider.  The packet will be queued
 *		up for transmission through the transport interface.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::SendPacket (
				PVoid				pdu_structure,
				int					pdu_type,
				Priority			priority)
{
	unsigned int	encoding_rules;
	PPacket			packet;
	PacketError		packet_error;
	BOOL    		bFlush;

	/*
	 *	Set the appropriate encoding rules for this PDU according to what type
	 *	it is.
	 */
	if (pdu_type == CONNECT_MCS_PDU) {
		encoding_rules = BASIC_ENCODING_RULES;
		bFlush = FALSE;
//		TRACE_OUT(("Connect SendPacket: PDU type: %d", (UINT) ((ConnectMCSPDU *) pdu_structure)->choice));
	}
	else {
		encoding_rules = Encoding_Rules;
		bFlush = TRUE;
//		TRACE_OUT(("Domain SendPacket: PDU type: %d", (UINT) ((DomainMCSPDU *) pdu_structure)->choice));
	}

	/*
	 *	Create a packet which will be used to hold the data to be sent
	 *	through the transport interface.	 Check to make sure the packet is
	 *	successfully created.  Issue a callback to the controller requesting
	 *	deletion of this connection if the packet is not successfully created.
	 */
	 DBG_SAVE_FILE_LINE
	 packet = new Packet (
	 		(PPacketCoder) g_MCSCoder,
			encoding_rules,
			pdu_structure,
			(int) pdu_type,
			Upward_Connection,
			&packet_error);

	if (packet != NULL)
	{
		if (packet_error == PACKET_NO_ERROR)
		{
			/*
			 *	Lock the encoded PDU data and queue the packet up for
			 *	transmission through the transport interface.
			 */
			QueueForTransmission ((PSimplePacket) packet, priority, bFlush);
		}
		else
		{
			/*
			 *	The packet creation has failed due to an internal error so
			 *	issue an owner callback to ask for deletion.
			 */
			DestroyConnection (REASON_PROVIDER_INITIATED);
		}

		/*
		 *	The packet is freed here so that it will be deleted when it's lock
		 *	count reaches zero.
		 */
		packet->Unlock ();
	}
	else
	{
		/*
		 *	The packet creation has failed so issue an owner callback
		 *	to ask for deletion.
		 */
		DestroyConnection (REASON_PROVIDER_INITIATED);
	}
}

/*
 *	Void	QueueForTransmission()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine encodes a PDU and places data units into the transmission queue so
 *		they can be transmitted through the transport interface when possible.
 *		An attempt is made to flush the queue and the transmitter is polled
 *		in order to go ahead and send the data immediately, if possible, instead
 *		of waiting for a timer event to occur.
 *
 *	Caveats:
 *		None.
 */
Void	Connection::QueueForTransmission (
				PSimplePacket		packet,
				Priority			priority,
				BOOL    			bFlush)
{

		int			 p;
	
	ASSERT (g_Transport != NULL);
	packet->Lock();

	/*
	 *	Attempt to set the packet directly to the transport without queueing it.
	 *	If this is done, it can eliminate queueing time and a thread switch.
	 *	For this to be possible, all higher priorities must have no pending
	 *	packets and the bFlush parameter should be TRUE.
	 */
	if (bFlush) {
		for (p = (int) TOP_PRIORITY; p <= (int) priority; p++) {
			if (m_OutPktQueue[p].GetCount() > 0)
				break;
		}

		if (p > priority) {
			/*
			 * There are no packets queued up for higher priorities. We can attempt
			 * to send the packet directly, by-passing the queue.
			 */
			if (FlushAMessage (packet, priority)) {
				return;
			}
		}
	}
				
	/*
	 *	Place the data unit in the proper queue. Increment the counter for that
	 *	queue and increment the transmission counter.
	 */
	m_OutPktQueue[priority].Append(packet);

	/*
	 *	If this is the first packet queued up for the specified priority,
	 *	then we must send a DataRequestReady to the transport interface
	 *	object.  Note that if other packets are already queued up, then it
	 *	is not necessary to inform the transport interface object, since it
	 *	already knows it has at least one).
	 */
	if (m_OutPktQueue[priority].GetCount() == 1)
		g_Transport->DataRequestReady ();
}

/*
 *	BOOL    FlushAMessage()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine will only flush one MCS PDU to the transport layer.
 *
 *	Parameters:
 *		packet: the packet to send.
 *		priority: the packet's priority
 *
 *	Return value:
 *		TRUE, if the message was successfully sent. FALSE, otherwise.
 *
 */
BOOL    Connection::FlushAMessage (PSimplePacket packet, Priority priority)
{	
	if (Domain_Traffic_Allowed == FALSE && packet->GetPDUType () == DOMAIN_MCS_PDU) {
		return FALSE;
	}

	if (packet->IsDataPacket())
		((PDataPacket) packet)->SetDirection (Upward_Connection);
			
	/*
	 *	Send the PDU to the transport interface.
	 */
	 if (DataRequest (Transport_Connection[priority], packet) != TRANSPORT_WRITE_QUEUE_FULL) {
		packet->Unlock();
		return TRUE;
	}

	return FALSE;
}

/*
 *	Void	FlushMessageQueue()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine flushes the transmit queue by copying the data unit
 *		into the output buffer and calling into the transport interface to
 *		give it a chance to accept the data.
 *
 *	Return value:
 *		TRUE, if there remain un-processed msgs in the connection message queue
 *		FALSE, if all the msgs in the connection msg queue were processed.
 *
 *	Caveats:
 *		None.
 */
BOOL    Connection::FlushMessageQueue()
{
	int				priority;
	BOOL    		return_value = FALSE;

	ASSERT (g_Transport != NULL);
		
	/*
	 *	Loop through all four priority levels of transmission queues.
	 */
	for (priority = 0; priority < MAXIMUM_PRIORITIES; priority++) {
		if (m_OutPktQueue[priority].GetCount() > 0) {
			return_value |= FlushPriority ((Priority) priority);
		}
	}

	return (return_value);
}

/*
 *	BOOL    FlushPriority ()
 *
 *	Private
 *
 *	Functional Description:
 *
 *	Return value:
 *		TRUE, if there remain un-processed msgs in the connection message queue
 *		FALSE, if all the msgs in the connection msg queue were processed.
 *
 *	Caveats:
 *		None.
 */
BOOL    Connection::FlushPriority (
				Priority		priority)
{
	PSimplePacket	packet;
	BOOL    		return_value = FALSE;

	/*
	 *	Check to see if the transport connection for this priority is
	 *	ready.  If not, skip it for now.
	 */
	if (Transport_Connection_State[priority] == TRANSPORT_CONNECTION_READY)
	{
		/*
		 *	If there is no packet in the queue, we may be here to send the
		 *	remainder of a packet that has been accepted by transport earlier.
		 *	We need to flush this remainder of the packet.
		 */
		if (m_OutPktQueue[priority].IsEmpty()) {
			if (DataRequest (Transport_Connection[priority], NULL) == TRANSPORT_WRITE_QUEUE_FULL) {
				return_value = TRUE;
			}
		}
		else {
			/*
			 *	While data exists in this queue and the transport interface is
			 *	able to accept it, retrieve the next packet from the queue and
			 *	send the data to the transport interface.
			 */
			while (NULL != (packet = m_OutPktQueue[priority].Get()))
			{
				if (! FlushAMessage (packet, priority))
				{
					/*
					 *	If the transport layer has rejected the PDU, then it is
					 *	necessary to leave it in the queue (at the front).
					 *	Then break out of the loop to prevent additional
					 *	attempts to transmit data at this priority.
					 */
					return_value = TRUE;
					if (packet != NULL) {
						m_OutPktQueue[priority].Prepend(packet);
					}
					break;
				}
			}
		}
	}
	else
		return_value = TRUE;

	return (return_value);
}

/*
 *	ULong	OwnerCallback()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine allows the transport interface to call into the connection
 *		in order to notify the connection of data reception.  This routine
 *		decodes the incoming data, notifies the controller if necessary and/or
 *		makes the necessary calls into the domain.
 *
 *	Caveats:
 *		None.
 */

TransportError Connection::HandleDataIndication
(
    PTransportData          pTransport_data,
    TransportConnection     transport_connection
)
{
    int             priority;
    TransportError  rc = TRANSPORT_NO_ERROR;

    /*
     *	Data is being received through the transport interface.  Determine
     *	what priority this data is arriving at.  This will be used to see
     *	what type of PDU this is supposed to be (CONNECT or DOMAIN).
     */
    for (priority = 0; priority < MAXIMUM_PRIORITIES; priority++)
    {
        if (IS_SAME_TRANSPORT_CONNECTION(Transport_Connection[priority], transport_connection))
        {
            break;
        }
    }

    /*
     *	Make sure that this transport connection was somewhere in the the
     *	transport connection list before processing the PDU.  If it was not,
     *	then report an error and ignore the PDU.
     */
    if (priority < MAXIMUM_PRIORITIES)
    {
        int						pdu_type;
        unsigned int			encoding_rules;
        PSimplePacket			packet;
        PacketError				packet_error;
        PVoid					pdu_structure;
        /*
         *	Determine what type of PDU this should be.
         */
        pdu_type = Transport_Connection_PDU_Type[priority];

        /*
         *	Set the appropriate encoding rules for this PDU according to
         *	what type it is.
         */
        encoding_rules = (pdu_type == CONNECT_MCS_PDU) ? BASIC_ENCODING_RULES :
                                                         Encoding_Rules;

        /*
         *	Get the pointer to the data indication structure from the the
         *	parameter list.  Then construct a packet object to represent
         *	this inbound data.
         */

        /*
         *	Crete a Packet or a DataPacket, depending on whether this
         *	is an MCS data packet.
         */
        if (g_MCSCoder->IsMCSDataPacket (
        					pTransport_data->user_data + PROTOCOL_OVERHEAD_X224,
        					encoding_rules))
        {
        	ASSERT (encoding_rules == PACKED_ENCODING_RULES);
        	
        	DBG_SAVE_FILE_LINE
        	packet = (PSimplePacket) new DataPacket (pTransport_data,
        										! Upward_Connection);
        	packet_error = PACKET_NO_ERROR;
        }
        else
        {
        	DBG_SAVE_FILE_LINE
        	packet = (PSimplePacket) new Packet (
        			(PPacketCoder) g_MCSCoder,
        			encoding_rules,
        			pTransport_data->user_data + PROTOCOL_OVERHEAD_X224,
        			pTransport_data->user_data_length - PROTOCOL_OVERHEAD_X224,
        			pdu_type, ! Upward_Connection,
        			&packet_error);
        }
        if (packet != NULL)
        {
            if (packet_error == PACKET_NO_ERROR)
            {
                /*
                 *	Retrieve a pointer to the decoded data
                 */
                pdu_structure = packet->GetDecodedData ();

                /*
                 *	Process the PDU according to what type it is.
                 */
                if (pdu_type == CONNECT_MCS_PDU)
                {
                    switch (((PConnectMCSPDU) pdu_structure)->choice)
                    {
                    case CONNECT_RESPONSE_CHOSEN:
                    	rc = ProcessConnectResponse (
                    			&((PConnectMCSPDU) pdu_structure)->
                    			u.connect_response);

                    	/*
                    	 *	Now that we have received and processed a
                    	 *	connect PDU over this transport connection,
                    	 *	we must indicate that the next PDU received
                    	 *	must be a domain PDU.
                    	 */
                    	Transport_Connection_PDU_Type[priority] =
                    			DOMAIN_MCS_PDU;
                    	break;

                    case CONNECT_RESULT_CHOSEN:
                    	ProcessConnectResult (
                    			&((PConnectMCSPDU) pdu_structure)->
                    			u.connect_result);

                    	/*
                    	 *	Now that we have received and processed a
                    	 *	connect PDU over this transport connection,
                    	 *	we must indicate that the next PDU received
                    	 *	must be a domain PDU.
                    	 */
                    	Transport_Connection_PDU_Type[priority] =
                    			DOMAIN_MCS_PDU;
                    	break;

                    default:
                    	/*
                    	 *	We have received a PDU that should not have
                    	 *	been received.  Ignore it.
                    	 */
                    	ERROR_OUT (("Connection::HandleDataIndication: Unknown ConnectMCSPDU Rxd"));
                    	break;
                    }
                }
                else
                {
                    /*
                    *	Verify that current conditions are appropriate for a request to be
                    *	accepted from a transport connection.
                    */
                    rc = ValidateConnectionRequest ();
                    if (rc == TRANSPORT_NO_ERROR)
                    {
                        switch (((PDomainMCSPDU) pdu_structure)->choice)
                        {
                        case SEND_DATA_REQUEST_CHOSEN:
                        	ProcessSendDataRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		send_data_request, (PDataPacket) packet);
                        	break;

                        case SEND_DATA_INDICATION_CHOSEN:
                        	ProcessSendDataIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		send_data_indication, (PDataPacket) packet);
                        	break;

                        case UNIFORM_SEND_DATA_REQUEST_CHOSEN:
                        	ProcessUniformSendDataRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		uniform_send_data_request, (PDataPacket) packet);
                        	break;

                        case UNIFORM_SEND_DATA_INDICATION_CHOSEN:
                        	ProcessUniformSendDataIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		uniform_send_data_indication, (PDataPacket) packet);
                        	break;

                        case PLUMB_DOMAIN_INDICATION_CHOSEN:
                        	ProcessPlumbDomainIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		plumb_domain_indication);
                        	break;

                        case ERECT_DOMAIN_REQUEST_CHOSEN:
                        	ProcessErectDomainRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		erect_domain_request);
                        	break;

                        case MERGE_CHANNELS_REQUEST_CHOSEN:
                        	rc = ProcessMergeChannelsRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		merge_channels_request);
                        	break;

                        case MERGE_CHANNELS_CONFIRM_CHOSEN:
                        	rc = ProcessMergeChannelsConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		merge_channels_confirm);
                        	break;

                        case PURGE_CHANNEL_INDICATION_CHOSEN:
                        	ProcessPurgeChannelIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		purge_channel_indication);
                        	break;

                        case MERGE_TOKENS_REQUEST_CHOSEN:
                        	rc = ProcessMergeTokensRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		merge_tokens_request);
                        	break;

                        case MERGE_TOKENS_CONFIRM_CHOSEN:
                        	rc = ProcessMergeTokensConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		merge_tokens_confirm);
                        	break;

                        case PURGE_TOKEN_INDICATION_CHOSEN:
                        	ProcessPurgeTokenIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		purge_token_indication);
                        	break;

                        case DISCONNECT_PROVIDER_ULTIMATUM_CHOSEN:
                        	ProcessDisconnectProviderUltimatum (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		disconnect_provider_ultimatum);
                        	break;

                        case REJECT_ULTIMATUM_CHOSEN:
                        	ProcessRejectUltimatum (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		reject_user_ultimatum);
                        	break;

                        case ATTACH_USER_REQUEST_CHOSEN:
                        	ProcessAttachUserRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		attach_user_request);
                        	break;

                        case ATTACH_USER_CONFIRM_CHOSEN:
                        	ProcessAttachUserConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		attach_user_confirm);
                        	break;

                        case DETACH_USER_REQUEST_CHOSEN:
                        	ProcessDetachUserRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		detach_user_request);
                        	break;

                        case DETACH_USER_INDICATION_CHOSEN:
                        	ProcessDetachUserIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		detach_user_indication);
                        	break;

                        case CHANNEL_JOIN_REQUEST_CHOSEN:
                        	ProcessChannelJoinRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_join_request);
                        	break;

                        case CHANNEL_JOIN_CONFIRM_CHOSEN:
                        	ProcessChannelJoinConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_join_confirm);
                        	break;

                        case CHANNEL_LEAVE_REQUEST_CHOSEN:
                        	ProcessChannelLeaveRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_leave_request);
                        	break;

                        case CHANNEL_CONVENE_REQUEST_CHOSEN:
                        	ProcessChannelConveneRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_convene_request);
                        	break;

                        case CHANNEL_CONVENE_CONFIRM_CHOSEN:
                        	ProcessChannelConveneConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_convene_confirm);
                        	break;

                        case CHANNEL_DISBAND_REQUEST_CHOSEN:
                        	ProcessChannelDisbandRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_disband_request);
                        	break;

                        case CHANNEL_DISBAND_INDICATION_CHOSEN:
                        	ProcessChannelDisbandIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_disband_indication);
                        	break;

                        case CHANNEL_ADMIT_REQUEST_CHOSEN:
                        	ProcessChannelAdmitRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_admit_request);
                        	break;

                        case CHANNEL_ADMIT_INDICATION_CHOSEN:
                        	ProcessChannelAdmitIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_admit_indication);
                        	break;

                        case CHANNEL_EXPEL_REQUEST_CHOSEN:
                        	ProcessChannelExpelRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_expel_request);
                        	break;

                        case CHANNEL_EXPEL_INDICATION_CHOSEN:
                        	ProcessChannelExpelIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		channel_expel_indication);
                        	break;

                        case TOKEN_GRAB_REQUEST_CHOSEN:
                        	ProcessTokenGrabRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_grab_request);
                        	break;

                        case TOKEN_GRAB_CONFIRM_CHOSEN:
                        	ProcessTokenGrabConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_grab_confirm);
                        	break;

                        case TOKEN_INHIBIT_REQUEST_CHOSEN:
                        	ProcessTokenInhibitRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_inhibit_request);
                        	break;

                        case TOKEN_INHIBIT_CONFIRM_CHOSEN:
                        	ProcessTokenInhibitConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_inhibit_confirm);
                        	break;

                        case TOKEN_GIVE_REQUEST_CHOSEN:
                        	ProcessTokenGiveRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_give_request);
                        	break;

                        case TOKEN_GIVE_INDICATION_CHOSEN:
                        	ProcessTokenGiveIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_give_indication);
                        	break;

                        case TOKEN_GIVE_RESPONSE_CHOSEN:
                        	ProcessTokenGiveResponse (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_give_response);
                        	break;

                        case TOKEN_GIVE_CONFIRM_CHOSEN:
                        	ProcessTokenGiveConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_give_confirm);
                        	break;

                        case TOKEN_PLEASE_REQUEST_CHOSEN:
                        	ProcessTokenPleaseRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_please_request);
                        	break;

                        case TOKEN_PLEASE_INDICATION_CHOSEN:
                        	ProcessTokenPleaseIndication (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_please_indication);
                        	break;

                        case TOKEN_RELEASE_REQUEST_CHOSEN:
                        	ProcessTokenReleaseRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_release_request);
                        	break;

                        case TOKEN_RELEASE_CONFIRM_CHOSEN:
                        	ProcessTokenReleaseConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_release_confirm);
                        	break;

                        case TOKEN_TEST_REQUEST_CHOSEN:
                        	ProcessTokenTestRequest (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_test_request);
                        	break;

                        case TOKEN_TEST_CONFIRM_CHOSEN:
                        	ProcessTokenTestConfirm (
                        		&((PDomainMCSPDU) pdu_structure)->u.
                        		token_test_confirm);
                        	break;

                        default:
                        	ERROR_OUT (("Connection::HandleDataIndication: Unknown DomainMCSPDU Rxd"));
                        	break;
                        }
                    }
                    else
                    {
                        ASSERT (TRANSPORT_READ_QUEUE_FULL == rc);
                        if (packet->IsDataPacket())
                        {
                            /*
                             * We are returning TRANSPORT_READ_QUEUE_FULL to the transport.
                             * The transport will attempt to deliver the data again later.
                             * However, we have to delete the DataPacket we created here, which
                             * will attempt to free the buffer that will be delivered again
                             * later.  So, let's lock it now.
                             */
                            LockMemory (pTransport_data->memory);
                        }
                    }
                }

                /* If this was a non-data PDU, we need to free up the transport
                 *	buffer with the original data.
                 */
                if ((! packet->IsDataPacket()) && (rc == TRANSPORT_NO_ERROR))
                    FreeMemory (pTransport_data->memory);

                /*
                 *	Free the packet.  This will result in the destruction of the
                 *	packet unless it is a "Send Data" packet which has been
                 *	locked by someone else.
                 */
                packet->Unlock ();

            }
            else
            {
                /*
                 *	Although the construction of the packet object itself
                 *	was successful, an error was generated in its
                 *	constructor.  We must therefore reject the packet.
                 */
                WARNING_OUT (("Connection::HandleDataIndication: packet constructor failure"));
                delete packet;
                rc = TRANSPORT_READ_QUEUE_FULL;
            }
        }
        else
        {
            /*
             *	We were not able to construct a packet object to represent
             *	the inbound data.  It is therefore necessary to reject the
             *	data from the transport layer, so that it can be retried
             *	later.
             */
            WARNING_OUT (("Connection::HandleDataIndication: packet allocation failure"));
            rc = TRANSPORT_READ_QUEUE_FULL;
        }
    }
    else
    {
        /*
         *	This transport connection is not listed as one of the ones being
         *	used by this MCS connection.  It is therefore necessary to
         *	ignore the PDU.
         */
        WARNING_OUT (("Connection::HandleDataIndication: unknown transport connection"));
    }
    return rc;
}

void Connection::HandleBufferEmptyIndication
(
    TransportConnection     transport_connection
)
{
    /*
    *	Determine what priority this indication is associated with.
    */
    for (int priority = 0; priority < MAXIMUM_PRIORITIES; priority++)
    {
        if (IS_SAME_TRANSPORT_CONNECTION(Transport_Connection[priority], transport_connection))
        /*
         *	Try to flush existing data downward.
         */
        FlushPriority ((Priority) priority);
    }
}

void Connection::HandleConnectConfirm
(
    TransportConnection     transport_connection
)
{
    /*
    *	A confirm has been received as the result of an outbound connect
    *	request.  This tells us that the request was successful.
    */
    TRACE_OUT (("Connection::HandleConnectConfirm: received CONNECT_CONFIRM"));

    for (int priority = 0; priority < MAXIMUM_PRIORITIES; priority++)
    {
        if (IS_SAME_TRANSPORT_CONNECTION(Transport_Connection[priority], transport_connection) &&
            (Transport_Connection_State[priority] == TRANSPORT_CONNECTION_PENDING))
        {
            Transport_Connection_State[priority] = TRANSPORT_CONNECTION_READY;
        }
    }
}

void Connection::HandleDisconnectIndication
(
    TransportConnection     transport_connection,
    ULONG                  *pnNotify
)
{
    Reason reason;
    /*
     *	A disconnection indication has been received through the transport
     *	interface.  Notify the controller and the domain and set the flag
     *	indicating a connection deletion is pending.
     */
    TRACE_OUT (("Connection::HandleDisconnectIndication: received DISCONNECT_INDICATION"));

    /*
     *	For each priority level that is using that disconnected
     *	transport connection, mark it as unassigned.  This serves two
     *	purposes.  First, it prevents any attempt to send data on the
     *	transport connection that is no longer valid.  Second, it
     *	prevents the destructor of this object from sending a
     *	disconnect request.
     */
    for (int priority = 0; priority < MAXIMUM_PRIORITIES; priority++)
    {
        if (IS_SAME_TRANSPORT_CONNECTION(Transport_Connection[priority], transport_connection))
        {
            Transport_Connection_State[priority] = TRANSPORT_CONNECTION_UNASSIGNED;
        }
    }

    /*
     *	Losing ANY of its transport connections is fatal to an MCS
     *	connection.  Therefore, this connection object must delete
     *	itself.
     */
    ASSERT(pnNotify);
    switch (*pnNotify)
    {
    case TPRT_NOTIFY_REMOTE_NO_SECURITY :
    	reason = REASON_REMOTE_NO_SECURITY;
    	break;
    case TPRT_NOTIFY_REMOTE_DOWNLEVEL_SECURITY :
    	reason = REASON_REMOTE_DOWNLEVEL_SECURITY;
    	break;

	case TPRT_NOTIFY_REMOTE_REQUIRE_SECURITY :
		reason = REASON_REMOTE_REQUIRE_SECURITY;
		break;

	case TPRT_NOTIFY_AUTHENTICATION_FAILED:
		reason = REASON_AUTHENTICATION_FAILED;
		break;
	
    default :
    	reason = REASON_DOMAIN_DISCONNECTED;
    	break;
    }
    DestroyConnection (reason);
}


void CChannelIDList::BuildExternalList(PSetOfChannelIDs *ppChannelIDs)
{
    PSetOfChannelIDs p = *ppChannelIDs;
    ChannelID chid;
    if (p != NULL)
    {
        /*
         *	Iterate through the set of channel ids, filling in the PDU
         *	structure.
         */
        for (Reset(); NULL != (chid = Iterate()); p++)
        {
            p->value = chid;
            p->next = p + 1;
        }

        /*
         *	Decrement the pointer in order to set the last "next"
         *	pointer to NULL.
         */
        (p - 1)->next = NULL;
        *ppChannelIDs = p;
    }
}


void CTokenIDList::BuildExternalList(PSetOfTokenIDs *ppTokenIDs)
{
    PSetOfTokenIDs p = *ppTokenIDs;
    TokenID tid;
    if (p != NULL)
    {
        /*
         *	Iterate through the set of token ids, filling in the PDU
         *	structure.
         */
        for (Reset(); NULL != (tid = Iterate()); p++)
        {
            p->value = tid;
            p->next = p + 1;
        }

        /*
         *	Decrement the pointer in order to set the last "next"
         *	pointer to NULL.
         */
        (p - 1)->next = NULL;
        *ppTokenIDs = p;
    }
}


void CUidList::BuildExternalList(PSetOfUserIDs *ppUserIDs)
{
    PSetOfUserIDs p = *ppUserIDs;
    UserID uid;
    if (p != NULL)
    {
        /*
         *	Iterate through the set of user ids, filling in the PDU
         *	structure.
         */
        for (Reset(); NULL != (uid = Iterate()); p++)
        {
            p->value = uid;
            p->next = p + 1;
        }

        /*
         *	Decrement the pointer in order to set the last "next"
         *	pointer to NULL.
         */
        (p - 1)->next = NULL;
        *ppUserIDs = p;
    }
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\conf2.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	conf2.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the second part of the imlementation file for the CConf
 *		Class. The conference class is the heart of GCC.  It maintains all the
 *		information basses for a single conference including conference and
 *		application rosters as well as registry information.  It also
 *		routes, encodes and decodes various PDU's and primitives supported
 *		by GCC.
 *
 *		This second part of the implementation file deals mainly with the
 *		command target calls and any callbacks received by the Owner Callback
 *		function.  It also contains many of the utility functions used by the
 *		conference object.
 *
 *		FOR A MORE DETAILED EXPLANATION OF THIS CLASS SEE THE INTERFACE FILE.
 *
 *
 *	Private Instance Variables
 *
 *		ALL PRIVATE INSTANCE VARIABLES ARE DEFINED IN CONF.CPP
 *
 *	Portable:
 *		Yes
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp
 */

#include "conf.h"
#include "gcontrol.h"
#include "translat.h"
#include "ogcccode.h"
#include "string.h"
#include <iappldr.h>


#define FT_VERSION_STR	"MS FT Version"
#define WB_VERSION_STR	"MS WB Version"
#define CHAT_VERSION_STR	"MS CHAT Version"


OSTR FT_VERSION_ID = {sizeof(FT_VERSION_STR), (unsigned char*)FT_VERSION_STR};
OSTR WB_VERSION_ID = {sizeof(WB_VERSION_STR), (unsigned char*)WB_VERSION_STR};
OSTR CHAT_VERSION_ID = {sizeof(CHAT_VERSION_STR), (unsigned char*)CHAT_VERSION_STR};


#define	TERMINATE_TIMER_DURATION		10000	//	Duration in milliseconds

static const struct ASN1objectidentifier_s WB_ASN1_OBJ_IDEN[6] = {
    { (ASN1objectidentifier_t) &(WB_ASN1_OBJ_IDEN[1]), 0 },
    { (ASN1objectidentifier_t) &(WB_ASN1_OBJ_IDEN[2]), 0 },
    { (ASN1objectidentifier_t) &(WB_ASN1_OBJ_IDEN[3]), 20 },
    { (ASN1objectidentifier_t) &(WB_ASN1_OBJ_IDEN[4]), 126 },
    { (ASN1objectidentifier_t) &(WB_ASN1_OBJ_IDEN[5]), 0 },
    { NULL, 1 }
};

static const struct Key WB_APP_PROTO_KEY = {
	1, (ASN1objectidentifier_t)&WB_ASN1_OBJ_IDEN};


static const struct ASN1objectidentifier_s FT_ASN1_OBJ_IDEN[6] = {
    { (ASN1objectidentifier_t) &(FT_ASN1_OBJ_IDEN[1]), 0 },
    { (ASN1objectidentifier_t) &(FT_ASN1_OBJ_IDEN[2]), 0 },
    { (ASN1objectidentifier_t) &(FT_ASN1_OBJ_IDEN[3]), 20 },
    { (ASN1objectidentifier_t) &(FT_ASN1_OBJ_IDEN[4]), 127 },
    { (ASN1objectidentifier_t) &(FT_ASN1_OBJ_IDEN[5]), 0 },
    { NULL, 1 }
};

static const struct Key FT_APP_PROTO_KEY = {
	1, (ASN1objectidentifier_t)&FT_ASN1_OBJ_IDEN};


struct Key CHAT_APP_PROTO_KEY;


/*
 *	This is a global variable that has a pointer to the one GCC coder that
 *	is instantiated by the GCC Controller.  Most objects know in advance
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CGCCCoder	*g_GCCCoder;

extern MCSDLLInterface		*g_pMCSIntf;

/*
**	These are GCCCommandTarget Calls. The only command targets that
**	conference is connected to are Application SAPs and the Control SAP, so
**	these Public member functions are only called from above.
*/

/*
 *	CConf::ConfJoinReqResponse()
 *
 *	Public Function Description
 *		This routine is called when a node controller responds to a join
 *		request that was issued by a join from a node connected to a subnode.
 */
GCCError CConf::
ConfJoinReqResponse
(	
	UserID					receiver_id,
	CPassword               *password_challenge,
	CUserDataListContainer  *user_data_list,
	GCCResult				result
)
{
	DebugEntry(CConf::ConfJoinReqResponse);

	/*
	**	Since the joining node is not directly connected to this
	**	node we send the response back through the user channel.
	**	It is the user attachment objects responsibility to
	**	encode this PDU.
	*/
	if (m_pMcsUserObject != NULL)
	{
		m_pMcsUserObject->ConferenceJoinResponse(
							receiver_id,
							m_fClearPassword,
							m_fConfLocked,
							m_fConfListed,
							m_eTerminationMethod,
							password_challenge,
							user_data_list,
							result);	
	}

	DebugExitINT(CConf::ConfJoinReqResponse, GCC_NO_ERROR);
	return (GCC_NO_ERROR);
}

/*
 *	CConf::ConfInviteRequest()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a
 *		ConfInviteRequest primitive needs to be processed.
 */
GCCError CConf::
ConfInviteRequest
(
	LPWSTR					pwszCallerID,
	TransportAddress		calling_address,
	TransportAddress		called_address,
	BOOL					fSecure,
	CUserDataListContainer  *user_data_list,
	PConnectionHandle		connection_handle
)
{
	GCCError					rc = GCC_NO_ERROR;
	PUChar						encoded_pdu;
	UINT						encoded_pdu_length;
	MCSError					mcs_error;
	ConnectGCCPDU				connect_pdu;
	INVITE_REQ_INFO			    *invite_request_info;

	DebugEntry(CConf::ConfInviteRequest);

	if (! m_fConfIsEstablished)
	{
		ERROR_OUT(("CConf::ConfInviteRequest: Conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
		goto MyExit;
	}

	/*
	**	If the conference is locked, we only allow invite request if there
	**	are outstanding adds.  T.124 states that when a conference is
	**	locked you can only use ADD to bring in new nodes to the conference.
	*/
	if (m_fConfLocked && m_AddResponseList.IsEmpty())
	{
		WARNING_OUT(("CConf::ConfInviteRequest: Conference is locked"));
		rc = GCC_INVALID_CONFERENCE;
		goto MyExit;
	}

	//	Create the ConfInviteRequest PDU here.
	connect_pdu.choice = CONFERENCE_INVITE_REQUEST_CHOSEN;

	connect_pdu.u.conference_invite_request.bit_mask = 0;

	/*
	**	First get the numeric and text (if it exists) portion of the
	**	conference name.
	*/
	connect_pdu.u.conference_invite_request.conference_name.bit_mask =0;

	::lstrcpyA(connect_pdu.u.conference_invite_request.conference_name.numeric,
			m_pszConfNumericName);

	if (m_pwszConfTextName != NULL)
	{
		connect_pdu.u.conference_invite_request.conference_name.bit_mask |=
							CONFERENCE_NAME_TEXT_PRESENT;
		connect_pdu.u.conference_invite_request.conference_name.conference_name_text.value =
							m_pwszConfTextName;
		connect_pdu.u.conference_invite_request.conference_name.conference_name_text.length =
							::lstrlenW(m_pwszConfTextName);
	}

	//	Now set up the privilege list PDU data
	if (m_pConductorPrivilegeList != NULL)
	{
		rc = m_pConductorPrivilegeList->GetPrivilegeListPDU(
					&connect_pdu.u.conference_invite_request.cirq_conductor_privs);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfInviteRequest: can't get conductor privilege list, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.conference_invite_request.bit_mask |= CIRQ_CONDUCTOR_PRIVS_PRESENT;
	}

	if (m_pConductModePrivilegeList != NULL)
	{
		rc = m_pConductModePrivilegeList->GetPrivilegeListPDU(
					&connect_pdu.u.conference_invite_request.cirq_conducted_privs);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfInviteRequest: can't get conduct mode privilege list, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.conference_invite_request.bit_mask |= CIRQ_CONDUCTED_PRIVS_PRESENT;
	}


	if (m_pNonConductModePrivilegeList != NULL)
	{
		rc = m_pNonConductModePrivilegeList->GetPrivilegeListPDU(
					&connect_pdu.u.conference_invite_request.cirq_non_conducted_privs);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfInviteRequest: can't get non-conduct mode privilege list, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.conference_invite_request.bit_mask |= CIRQ_NON_CONDUCTED_PRIVS_PRESENT;
	}

	if (m_pwszConfDescription != NULL)
	{
		connect_pdu.u.conference_invite_request.cirq_description.value =
						m_pwszConfDescription;
		connect_pdu.u.conference_invite_request.cirq_description.length =
						::lstrlenW(m_pwszConfDescription);

		connect_pdu.u.conference_invite_request.bit_mask |= CIRQ_DESCRIPTION_PRESENT;
	}

	if (pwszCallerID != NULL)
	{
		connect_pdu.u.conference_invite_request.cirq_caller_id.value = pwszCallerID;
		connect_pdu.u.conference_invite_request.cirq_caller_id.length = ::lstrlenW(pwszCallerID);
		connect_pdu.u.conference_invite_request.bit_mask |= CIRQ_CALLER_ID_PRESENT;
	}

	if (user_data_list != NULL)
	{
		rc = user_data_list->GetUserDataPDU(
					&connect_pdu.u.conference_invite_request.cirq_user_data);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfInviteRequest: can't get user data, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.conference_invite_request.bit_mask |= CIRQ_USER_DATA_PRESENT;
	}

	connect_pdu.u.conference_invite_request.node_id = m_pMcsUserObject->GetMyNodeID();
	connect_pdu.u.conference_invite_request.top_node_id = m_pMcsUserObject->GetTopNodeID();
	connect_pdu.u.conference_invite_request.tag = GetNewUserIDTag();
	connect_pdu.u.conference_invite_request.clear_password_required = (ASN1bool_t)m_fClearPassword;
	connect_pdu.u.conference_invite_request.conference_is_locked = (ASN1bool_t)m_fConfLocked;
	connect_pdu.u.conference_invite_request.conference_is_conductible = (ASN1bool_t)m_fConfConductible;
	connect_pdu.u.conference_invite_request.conference_is_listed = (ASN1bool_t)m_fConfListed;
	connect_pdu.u.conference_invite_request.termination_method = (TerminationMethod)m_eTerminationMethod;

	if (! g_GCCCoder->Encode((LPVOID) &connect_pdu,
								CONNECT_GCC_PDU,
								PACKED_ENCODING_RULES,
								&encoded_pdu,
								&encoded_pdu_length))
	{
		ERROR_OUT(("CConf::ConfInviteRequest: can't encode"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	mcs_error = g_pMCSIntf->ConnectProviderRequest (
						&m_nConfID,     // calling domain selector
						&m_nConfID,     // called domain selector
						calling_address,
						called_address,
						fSecure,
						FALSE,	// Downward connection
						encoded_pdu,
						encoded_pdu_length,
						connection_handle,
						m_pDomainParameters,
						this);

	g_GCCCoder->FreeEncoded(encoded_pdu);

	if (MCS_NO_ERROR != mcs_error)
	{
		ERROR_OUT(("CConf::ConfInviteRequest: ConnectProviderRequest failed: rc=%d", mcs_error));

		/*
		**	DataBeam's current implementation of MCS returns
		**	MCS_INVALID_PARAMETER when something other than
		**	the transport prefix is wrong with the specified
		**	transport address.
		*/
		rc = (mcs_error == MCS_INVALID_PARAMETER) ?
				GCC_INVALID_TRANSPORT_ADDRESS :
				g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
		goto MyExit;
	}

	/*
	**	Add the user's tag number to the list of
	**	outstanding user ids along with its associated
	**	connection.
	*/
	m_ConnHdlTagNumberList2.Append(connect_pdu.u.conference_invite_request.tag, *connection_handle);

	//	Add connection handle to the list of connections
    ASSERT(0 != *connection_handle);
	m_ConnHandleList.Append(*connection_handle);

	/*
	**	Add the connection handle and the Node Id tag to
	**	the list of outstanding	invite request.
	*/
	DBG_SAVE_FILE_LINE
	invite_request_info = new INVITE_REQ_INFO;
	if (NULL == invite_request_info)
	{
		ERROR_OUT(("CConf::ConfInviteRequest: can't create invite request info"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	invite_request_info->connection_handle = *connection_handle;
	invite_request_info->invite_tag = m_nUserIDTagNumber;
	invite_request_info->user_data_list = NULL;

	m_InviteRequestList.Append(invite_request_info);

	//	Free the privilege list packed into structures for encoding
	if (connect_pdu.u.conference_invite_request.bit_mask & CIRQ_CONDUCTOR_PRIVS_PRESENT)
	{
		m_pConductorPrivilegeList->FreePrivilegeListPDU(
			connect_pdu.u.conference_invite_request.cirq_conductor_privs);
	}

	if (connect_pdu.u.conference_invite_request.bit_mask & CIRQ_CONDUCTED_PRIVS_PRESENT)
	{
		m_pConductModePrivilegeList->FreePrivilegeListPDU(
			connect_pdu.u.conference_invite_request.cirq_conducted_privs);
	}

	if (connect_pdu.u.conference_invite_request.bit_mask & CIRQ_NON_CONDUCTED_PRIVS_PRESENT)
	{
		m_pNonConductModePrivilegeList->FreePrivilegeListPDU(
			connect_pdu.u.conference_invite_request.cirq_non_conducted_privs);
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CConf::ConfInviteRequest, rc);
	return rc;
}

/*
 * CConf::ConfLockRequest()
 *
 * Public Function Description:
 *		This routine is called from Control Sap when a
 *		ConfLockRequest primitive needs to be processed.
 */
#ifdef JASPER
GCCError CConf::
ConfLockRequest ( void )
{
	GCCError				rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConfLockRequest);

	if (m_fConfIsEstablished)
	{
		if (m_fConfLocked == CONFERENCE_IS_NOT_LOCKED)
		{
			if (IsConfTopProvider())
			{
				ProcessConferenceLockRequest((UserID)m_pMcsUserObject->GetMyNodeID());
			}
			else
			{
				rc = m_pMcsUserObject->SendConferenceLockRequest();
			}
		}
		else 		// the conference is already locked
		{
#ifdef JASPER
			g_pControlSap->ConfLockConfirm(GCC_RESULT_CONFERENCE_ALREADY_LOCKED, m_nConfID);
#endif // JASPER
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConfLockRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfLockRequest, rc);
	return rc;
}
#endif // JASPER


/*
 * CConf::ConfLockResponse()
 *
 * Public Function Description:
 *		This routine is called from Control Sap when a
 *		ConfLockResponse primitive needs to be processed.
 */
GCCError CConf::
ConfLockResponse
(
	UserID		    	requesting_node,
	GCCResult		    result
)
{
	GCCError rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConfLockResponse);

	if (m_fConfIsEstablished)
	{
		if (requesting_node == m_pMcsUserObject->GetTopNodeID())
		{
#ifdef JASPER
			g_pControlSap->ConfLockConfirm(result, m_nConfID);
#endif // JASPER
		}
		else
		{
			rc = m_pMcsUserObject->SendConferenceLockResponse(requesting_node, result);
		}
		
		if (rc == GCC_NO_ERROR && result == GCC_RESULT_SUCCESSFUL)
		{
			m_fConfLocked = CONFERENCE_IS_LOCKED;
			rc = m_pMcsUserObject->SendConferenceLockIndication(
											TRUE,  //indicates uniform send
											0);
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConfLockResponse: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

    DebugExitINT(CConf::ConfLockResponse, rc);
	return rc;
}


/*
 * CConf::ConfUnlockRequest()
 *
 * Public Function Description:
 *		This routine is called from Control Sap when a
 *		ConferenceUnlockRequest primitive needs to be processed.
 */
#ifdef JASPER
GCCError CConf::
ConfUnlockRequest ( void )
{
	GCCError				rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConfUnlockRequest);

	if (m_fConfIsEstablished)
	{
		if (m_fConfLocked == CONFERENCE_IS_LOCKED)
		{
			if (IsConfTopProvider())
			{
				ProcessConferenceUnlockRequest((UserID)m_pMcsUserObject->GetMyNodeID());
			}
			else
			{
				rc = m_pMcsUserObject->SendConferenceUnlockRequest();
			}
		}
		else 		// the conference is already unlocked
		{
#ifdef JASPER
			g_pControlSap->ConfUnlockConfirm(GCC_RESULT_CONFERENCE_ALREADY_UNLOCKED, m_nConfID);
#endif // JASPER
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConfUnlockRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfUnlockRequest, rc);
	return rc;
}
#endif // JASPER


/*
 * CConf::ConfUnlockResponse()
 *
 * Public Function Description:
 *		This routine is called from Control Sap when a
 *		ConfUnlockResponse primitive needs to be processed.
 */
#ifdef JASPER
GCCError CConf::
ConfUnlockResponse
(
	UserID					requesting_node,
	GCCResult				result
)
{
	GCCError rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConfUnlockResponse);

	if (m_fConfIsEstablished)
	{
		if (requesting_node == m_pMcsUserObject->GetTopNodeID())
		{
#ifdef JASPER
			g_pControlSap->ConfUnlockConfirm(result, m_nConfID);
#endif // JASPER
		}
		else
		{
			rc = m_pMcsUserObject->SendConferenceUnlockResponse(requesting_node, result);
		}
		
		if (rc == GCC_NO_ERROR && result == GCC_RESULT_SUCCESSFUL)
		{
			m_fConfLocked = CONFERENCE_IS_NOT_LOCKED;
			rc = m_pMcsUserObject->SendConferenceUnlockIndication(
												TRUE,  //indicates uniform send
												0);
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConfUnlockResponse: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfUnlockResponse, rc);
	return rc;
}
#endif // JASPER

/*
 *	CConf::ConfEjectUserRequest ()
 *
 *	Private Function Description
 *		This function initiates an eject user for the specified node id.
 */
GCCError CConf::
ConfEjectUserRequest
(
    UserID					ejected_node_id,
    GCCReason				reason
)
{
    GCCError	rc = GCC_NO_ERROR;

    DebugEntry(CConf::ConfEjectUserRequest);

    if (m_fConfIsEstablished)
    {
        if (IsConfTopProvider())
        {
            if (IsThisNodeParticipant(ejected_node_id))
            {
                ConnectionHandle    nConnHdl;
                BOOL		fChildNode = FALSE;

                //	First check to see if it is a child node that is being ejected.
                m_ConnHandleList.Reset();
                while (0 != (nConnHdl = m_ConnHandleList.Iterate()))
                {
                    if (m_pMcsUserObject->GetUserIDFromConnection(nConnHdl) == ejected_node_id)
                    {
                    	fChildNode = TRUE;
                    	break;
                    }
                }

                if (fChildNode ||
                    DoesRequesterHavePrivilege(m_pMcsUserObject->GetMyNodeID(), EJECT_USER_PRIVILEGE))
                {
                    //	Add this ejected node to the list of Ejected Nodes
                    m_EjectedNodeConfirmList.Append(ejected_node_id);

                    /*
                    **	The user attachment object decides where the ejct should
                    **	be sent (either to the Top Provider or conference wide as
                    **	an indication.
                    */
                    m_pMcsUserObject->EjectNodeFromConference(ejected_node_id, reason);
                }
                else
                {
#ifdef JASPER
                    /*
                    **	The top provider does not have the privilege to eject
                    **	a node from the conference.  Send the appropriate
                    **	confirm.
                    */
                    g_pControlSap->ConfEjectUserConfirm(
                                            m_nConfID,
                                            ejected_node_id,
                                            GCC_RESULT_INVALID_REQUESTER);
#endif // JASPER
                    rc = fChildNode ? GCC_INSUFFICIENT_PRIVILEGE : GCC_INVALID_MCS_USER_ID;
                    WARNING_OUT(("CConf::ConfEjectUserRequest: failed, rc=%d", rc));
                }
            }
            else
            {
            	rc = GCC_INVALID_MCS_USER_ID;
            	WARNING_OUT(("CConf::ConfEjectUserRequest: failed, rc=%d", rc));
            }
        }
        else
        {
            //	Add this ejected node to the list of Ejected Nodes
            m_EjectedNodeConfirmList.Append(ejected_node_id);

            /*
            **	The user attachment object decides where the ejct should
            **	be sent (either to the Top Provider or conference wide as
            **	an indication.
            */
            m_pMcsUserObject->EjectNodeFromConference(ejected_node_id, reason);
        }
    }
    else
    {
    	ERROR_OUT(("CConf::ConfEjectUserRequest: conf not established"));
    	rc = GCC_CONFERENCE_NOT_ESTABLISHED;
    }

    DebugExitINT(CConf::ConfEjectUserRequest, rc);
    return rc;
}

/*
 *	CConf::ConfAnnouncePresenceRequest ()
 *
 *	Private Function Description
 *		This function forces a roster update indication and a confirm to be
 *		sent.
 */
GCCError CConf::
ConfAnnouncePresenceRequest ( PGCCNodeRecord node_record )
{
	GCCError	rc;

	DebugEntry(CConf::ConfAnnouncePresenceRequest);

	// If the conference is not established send back a negative confirm
	if (! m_fConfIsEstablished)
	{
		WARNING_OUT(("CConf::ConfAnnouncePresenceRequest: conf not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
		goto MyExit;
	}

    /*
    **	This takes care of setting up the nodes record in the
    **	appropriate conference roster.
    */
    rc = m_pConfRosterMgr->AddNodeRecord(node_record);
    if (GCC_NO_ERROR != rc)
    {
    	TRACE_OUT(("CConf::ConfAnnouncePresenceRequest: updating previous record"));
    	rc = m_pConfRosterMgr->UpdateNodeRecord(node_record);
    	if (GCC_NO_ERROR != rc)
    	{
    		ERROR_OUT(("CConf::ConfAnnouncePresenceRequest: can't update node record, rc=%d", rc));
    		goto MyExit;
    	}
    }

    //	Only flush the roster data here if there is no startup alarm.
    rc = AsynchFlushRosterData();
    if (GCC_NO_ERROR != rc)
    {
    	ERROR_OUT(("CConf::ConfAnnouncePresenceRequest: can't flush roster data, rc=%d", rc));
    	goto MyExit;
    }

	g_pControlSap->ConfAnnouncePresenceConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CConf::ConfAnnouncePresenceRequest, rc);
	return rc;
}


/*
 *	GCCError	ConfDisconnectRequest ()
 *
 *	Public Function Description
 *		This function initiates a disconnect of this node from the conference.
 *		This involves ejecting all subordinate nodes before actually
 *		disconnecting the parent connection.
 */
GCCError CConf::
ConfDisconnectRequest ( void )
{
	GCCError					rc = GCC_NO_ERROR;
	UserID						child_node_id;
	ConnectionHandle            nConnHdl;

	DebugEntry(CConf::ConfDisconnectRequest);

	/*
	**	Before we start the disconnect process we must remove all the
	**	outstanding invite request from our list and send back associated
	**	confirms.  Here we go ahead disconnect all connection associated with
	**	the invites.
	*/
	DeleteOutstandingInviteRequests();

	/*
	**	We set conference established to FALSE since the conference is
	**	no longer established (this also prevents a terminate indication
	**	from being sent).
	*/
	m_fConfIsEstablished = FALSE;

	/*
	**	Iterate through the list of connection handles and eject each
	**	of the child nodes that is associated with it.
	*/
	m_ConnHandleList.Reset();
	while (0 != (nConnHdl = m_ConnHandleList.Iterate()))
	{
		child_node_id = m_pMcsUserObject->GetUserIDFromConnection(nConnHdl);

		rc = m_pMcsUserObject->EjectNodeFromConference (child_node_id,
														GCC_REASON_HIGHER_NODE_DISCONNECTED);
		if (rc != GCC_NO_ERROR)
		{
			ERROR_OUT(("CConf::ConfDisconnectRequest: can't eject node from conference"));
			break;
		}
	}

	//	If there is an error we go ahead and do a hard disconnect
	if (m_ConnHandleList.IsEmpty() || rc != GCC_NO_ERROR)
	{
		/*
		**	First inform the control SAP that this node has successfuly
		**	disconnected.
		*/
		rc = g_pControlSap->ConfDisconnectConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);

		//	Tell the owner object to terminate this conference
		InitiateTermination(GCC_REASON_NORMAL_TERMINATION, 0);
	}
	else
	{
		/*
		**	Wait for all the ejects to complete before the conference is
		**	terminated.
		*/
		m_fConfDisconnectPending = TRUE;
	}

	DebugExitINT(CConf::ConfDisconnectRequest, rc);
	return rc;
}


/*
 *	GCCError	ConfTerminateRequest ()
 *
 *	Public Function Description
 *		This routine initiates a terminate sequence which starts with a request
 *		to the Top Provider if this node is not already the Top Provider.
 */
#ifdef JASPER
GCCError CConf::
ConfTerminateRequest ( GCCReason reason )
{
	GCCError	rc;

	DebugEntry(CConf::ConfTerminateRequest);

	if (m_fConfIsEstablished)
	{
		/*
		**	Before we start the termination process we must remove all the
		**	outstanding invite request from our list and send back associated
		**	confirms.  Here we go ahead disconnect all connections associated
		**	with these invites.
		*/
		DeleteOutstandingInviteRequests();

		if (IsConfTopProvider())
		{
			if (DoesRequesterHavePrivilege(	m_pMcsUserObject->GetMyNodeID(),
											TERMINATE_PRIVILEGE))
			{
		   		TRACE_OUT(("CConf::ConfTerminateRequest: Node has permission to terminate"));
				/*
				**	Since the terminate was successful, we go ahead and
				**	set the m_fConfIsEstablished instance variable to
				**	FALSE.  This prevents any other messages from flowing
				**	to the SAPs other than terminate messages.
				*/
				m_fConfIsEstablished = FALSE;
				
				//	Send the terminate confirm.
				g_pControlSap->ConfTerminateConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);

				//	This call takes care of both the local and remote terminate
				m_pMcsUserObject->ConferenceTerminateIndication(reason);
			}
			else
			{
				WARNING_OUT(("CConf::ConfTerminateRequest: Node does NOT have permission to terminate"));
				g_pControlSap->ConfTerminateConfirm(m_nConfID, GCC_RESULT_INVALID_REQUESTER);
			}
		}
		else
		{
			m_pMcsUserObject->ConferenceTerminateRequest(reason);
		}
		rc = GCC_NO_ERROR;
	}
	else
	{
		ERROR_OUT(("CConf::ConfTerminateRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfTerminateRequest, rc);
	return rc;
}
#endif // JASPER


/********************* Registry Calls ***********************************/


/*
 *	GCCError RegistryRegisterChannelRequest ()
 *
 *	Public Function Description
 *		This initiates a registry request sequence.  Note that the registry
 *		response is handled by the registry class.
 */
GCCError CConf::
RegistryRegisterChannelRequest
(
    PGCCRegistryKey         registry_key,
    ChannelID               nChnlID,
    CAppSap                 *pAppSap
)
{
	GCCError	rc;
	EntityID	eid;

	DebugEntry(CConf::RegistryRegisterChannelRequest);

	rc = GetEntityIDFromAPEList(pAppSap, &registry_key->session_key, &eid);
	if (rc == GCC_NO_ERROR)
	{
		rc = m_pAppRegistry->RegisterChannel(registry_key, nChnlID, eid);
	}

	DebugExitINT(CConf::RegistryRegisterChannelRequest, rc);
	return rc;
}


/*
 *	GCCError RegistryAssignTokenRequest ()
 *
 *	Public Function Description
 *		This initiates a registry request sequence.  Note that the registry
 *		response is handled by the registry class.
 */
GCCError CConf::
RegistryAssignTokenRequest
(
    PGCCRegistryKey         registry_key,
    CAppSap                 *pAppSap
)
{
	GCCError	rc;
	GCCEntityID	eid;

	DebugEntry(CConf::RegistryAssignTokenRequest);

	rc = GetEntityIDFromAPEList(pAppSap, &registry_key->session_key, &eid);
	if (rc == GCC_NO_ERROR)
	{
		rc = m_pAppRegistry->AssignToken(registry_key, eid);
	}

	DebugExitINT(CConf::RegistryAssignTokenRequest, rc);
	return rc;
}


/*
 *	GCCError	RegistrySetParameterRequest ()
 *
 *	Public Function Description
 *		This initiates a registry request sequence.  Note that the registry
 *		response is handled by the registry class.
 */
GCCError CConf::
RegistrySetParameterRequest
(
	PGCCRegistryKey			registry_key,
	LPOSTR			        parameter_value,
	GCCModificationRights	modification_rights,
	CAppSap                 *pAppSap
)
{
	GCCError	rc;
	GCCEntityID	eid;

	DebugEntry(CConf::RegistrySetParameterRequest);

	rc = GetEntityIDFromAPEList(pAppSap, &registry_key->session_key, &eid);
	if (rc == GCC_NO_ERROR)
	{
		rc = m_pAppRegistry->SetParameter(registry_key,
											parameter_value,
											modification_rights,
											eid);
	}

	DebugExitINT(CConf::RegistrySetParameterRequest, rc);
	return rc;
}


/*
 *	GCCError RegistryRetrieveEntryRequest ()
 *
 *	Public Function Description
 *		This initiates a registry request sequence.  Note that the registry
 *		response is handled by the registry class.
 */
GCCError CConf::
RegistryRetrieveEntryRequest
(
    PGCCRegistryKey         registry_key,
    CAppSap                 *pAppSap
)
{
	GCCError	rc;
	GCCEntityID	eid;

	DebugEntry(CConf::RegistryRetrieveEntryRequest);

	rc = GetEntityIDFromAPEList(pAppSap, &registry_key->session_key, &eid);
	if (rc == GCC_NO_ERROR)
	{
		rc = m_pAppRegistry->RetrieveEntry(registry_key, eid);
	}

	DebugExitINT(CConf::RegistryRetrieveEntryRequest, rc);
	return rc;
}


/*
 *	GCCError RegistryDeleteEntryRequest ()
 *
 *	Public Function Description
 *		This initiates a registry request sequence.  Note that the registry
 *		response is handled by the registry class.
 */
GCCError CConf::
RegistryDeleteEntryRequest
(
    PGCCRegistryKey         registry_key,
    CAppSap                 *pAppSap
)
{
	GCCError	rc;
	EntityID	eid;

	DebugEntry(CConf::RegistryDeleteEntryRequest);

	rc = GetEntityIDFromAPEList(pAppSap, &registry_key->session_key, &eid);
	if (rc == GCC_NO_ERROR)
	{
		rc = m_pAppRegistry->DeleteEntry(registry_key, eid);
	}

	DebugExitINT(CConf::RegistryDeleteEntryRequest, rc);
	return rc;
}


/*
 *	GCCError RegistryMonitorRequest ()
 *
 *	Public Function Description
 *		This initiates a registry request sequence.  Note that the registry
 *		response is handled by the registry class.
 */
GCCError CConf::
RegistryMonitorRequest
(
    BOOL                fEnableDelivery,
    PGCCRegistryKey     registry_key,
    CAppSap             *pAppSap)
{
	GCCError	rc;
	GCCEntityID	eid;

	DebugEntry(CConf::RegistryMonitorRequest);

	rc = GetEntityIDFromAPEList(pAppSap, &registry_key->session_key, &eid);
	if (rc == GCC_NO_ERROR)
	{
		rc = m_pAppRegistry->MonitorRequest(registry_key, fEnableDelivery, eid);
	}

	DebugExitINT(CConf:RegistryMonitorRequest, rc);
	return rc;
}


/*
 *	GCCError RegistryAllocateHandleRequest ()
 *
 *	Public Function Description
 *		This initiates a registry request sequence.  Note that the registry
 *		response is handled by the registry class.  This registry call is
 *		a bit different from the other registry calls.  Notice that there is
 *		no registry key associated with this call so there is no way to
 *		explicitly determine the entity ID.  Luckily, the entity ID is not
 *		passed back in the allocate confirm so we just pick an entity id
 *		that is associated with this SAP.  It makes no difference which one
 *		we pick because they all accomplish the same thing.
 */
GCCError CConf::
RegistryAllocateHandleRequest
(
    UINT            cHandles,
    CAppSap         *pAppSap
)
{
	GCCError				rc;
	ENROLLED_APE_INFO       *lpEnrAPEInfo;
	GCCEntityID				eid;

	DebugEntry(CConf::RegistryAllocateHandleRequest);

	//	First we must find a single entity id that is associated with this SAP.
	if (NULL != (lpEnrAPEInfo = GetEnrolledAPEbySap(pAppSap, &eid)))
	{
		ASSERT(GCC_INVALID_EID != eid);
		rc = m_pAppRegistry->AllocateHandleRequest(cHandles, eid);
	}
	else
	{
		WARNING_OUT(("CConf::RegistryAllocateHandleRequest: Application not enrolled"));
		rc = GCC_APP_NOT_ENROLLED;
	}

	DebugExitINT(CConf::RegistryAllocateHandleRequest, rc);
	return rc;
}


/********************* Conductorship Calls ***********************************/


/*
 *	GCCError ConductorAssignRequest ()
 *
 *	Public Function Description
 *		This initiates a Conductor assign request sequence.  Here the node is
 *		requesting to become the conductor.
 */
#ifdef JASPER
GCCError CConf::
ConductorAssignRequest ( void )
{
	GCCError	rc = GCC_NO_ERROR;
	GCCResult	eResult = INVALID_GCC_RESULT;

	DebugEntry(CConf::ConductorAssignRequest);

	//	Return an error if the conference is not established.
	if (m_fConfIsEstablished)
	{
		if (m_fConfConductible)
		{
			if (m_nConductorNodeID != m_pMcsUserObject->GetMyNodeID())
			{
				if ((m_nPendingConductorNodeID == 0) &&	! m_fConductorGiveResponsePending)
				{
					m_fConductorAssignRequestPending = TRUE;
					rc = m_pMcsUserObject->ConductorTokenGrab();
				}
				else
				{
					TRACE_OUT(("CConf::ConductorAssignConfirm:Give Pending"));
					eResult = GCC_RESULT_CONDUCTOR_GIVE_IS_PENDING;
				}
			}
			else
			{
				ERROR_OUT(("CConf::ConductorAssignRequest: Already Conductor"));
				/*
				**	Since we are already the conductor send back a successful
				**	result
				*/
				//
				// LONCHANC: Why not GCC_RESULT_ALREADY_CONDUCTOR?
				//
				eResult = GCC_RESULT_SUCCESSFUL;
			}
		}
		else
		{
			ERROR_OUT(("CConf::ConductorAssignRequest: not conductible"));
	 		eResult = GCC_RESULT_NOT_CONDUCTIBLE;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConductorAssignRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

#ifdef JASPER
	if (INVALID_GCC_RESULT != eResult)
	{
		g_pControlSap->ConductorAssignConfirm(eResult, m_nConfID);
	}
#endif // JASPER

	DebugExitINT(CConf::ConductorAssignRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError ConductorReleaseRequest ()
 *
 *	Public Function Description
 *		Here the node is attempting to give up conductorship.
 */
#ifdef JASPER
GCCError CConf::
ConductorReleaseRequest ( void )
{
	GCCError	rc = GCC_NO_ERROR;
	GCCResult	eResult = INVALID_GCC_RESULT;

	DebugEntry(CConf::ConductorReleaseRequest);

	if (m_fConfConductible)
	{
		if (m_nConductorNodeID == m_pMcsUserObject->GetMyNodeID())
		{
			if (m_nPendingConductorNodeID == 0)
			{
				/*
				**	This does not seem right, but this is the way that T.124
				**	defines it should work.
				*/
				m_nConductorNodeID = 0;	//	Set back to non-conducted mode

				m_fConductorGrantedPermission = FALSE;

				rc = m_pMcsUserObject->SendConductorReleaseIndication();
				if (rc == GCC_NO_ERROR)
				{
					rc = m_pMcsUserObject->ConductorTokenRelease();
					
					/*
					**	Inform the control SAP and all the enrolled application
					**	SAPs that the  conductor was released.  We do this here
					**	because we will not process the release indication
					**	when it comes back in.
					*/
					if (rc == GCC_NO_ERROR)
					{
						g_pControlSap->ConductorReleaseIndication(m_nConfID);

						/*
						**	We iterate on a temporary list to avoid any problems
						**	if the application sap leaves during the callback.
						*/
						CAppSap     *pAppSap;
						CAppSapList TempList(m_RegisteredAppSapList);
						TempList.Reset();
						while (NULL != (pAppSap = TempList.Iterate()))
						{
							if (DoesSAPHaveEnrolledAPE(pAppSap))
							{
								pAppSap->ConductorReleaseIndication(m_nConfID);
							}
						}
					}
				}
			}
			else
			{
				TRACE_OUT(("CConf: ConductorReleaseRequest: Give Pending"));
				eResult = GCC_RESULT_CONDUCTOR_GIVE_IS_PENDING;
			}
		}
		else
		{
			ERROR_OUT(("CConf::ConductorReleaseRequest: Not the Conductor"));
			eResult = GCC_RESULT_NOT_THE_CONDUCTOR;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConductorReleaseRequest: not conductible"));
		eResult = GCC_RESULT_NOT_CONDUCTIBLE;
	}

#ifdef JASPER
	if (INVALID_GCC_RESULT != eResult)
	{
		g_pControlSap->ConductorReleaseConfirm(eResult, m_nConfID);
	}
#endif // JASPER

	DebugExitINT(CConf::ConductorReleaseRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError ConductorPleaseRequest ()
 *
 *	Public Function Description
 *		Here the node is asking to be given conductorship.
 */
#ifdef JASPER
GCCError CConf::
ConductorPleaseRequest ( void )
{
	GCCError	rc = GCC_NO_ERROR;
	GCCResult	eResult = INVALID_GCC_RESULT;

	DebugEntry(CConf::ConductorPleaseRequest);

	if (m_fConfConductible)
	{
		//	Return an error if the conference is not established
		if (m_nConductorNodeID != 0)
		{
			if (m_nConductorNodeID != m_pMcsUserObject->GetMyNodeID())
			{
				rc = m_pMcsUserObject->ConductorTokenPlease();
				if (rc == GCC_NO_ERROR)
				{
					//	Send back positive confirm if successful
					eResult = GCC_RESULT_SUCCESSFUL;
				}
			}
			else
			{
				WARNING_OUT(("CConf::ConductorPleaseRequest: already conductor"));
				eResult = GCC_RESULT_ALREADY_CONDUCTOR;
			}
		}
		else
		{
			ERROR_OUT(("CConf::ConductorPleaseRequest: not in conducted mode"));
			eResult = GCC_RESULT_NOT_IN_CONDUCTED_MODE;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConductorPleaseRequest: not conductible"));
		eResult = GCC_RESULT_NOT_CONDUCTIBLE;
	}

#ifdef JASPER
	if (INVALID_GCC_RESULT != eResult)
	{
		g_pControlSap->ConductorPleaseConfirm(eResult, m_nConfID);
	}
#endif // JASPER

	DebugExitINT(CConf::ConductorPleaseRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError ConductorGiveRequest ()
 *
 *	Public Function Description
 *		The function is called when the conductor wants to pass off
 *		conductorship to a different node.
 */
#ifdef JASPER
GCCError CConf::
ConductorGiveRequest ( UserID recipient_node_id )
{
	GCCError	rc = GCC_NO_ERROR;
	GCCResult	eResult = INVALID_GCC_RESULT;

	DebugEntry(CConf::ConductorGiveRequest);

	if (m_fConfConductible)
	{
		//	Am I in conducted mode?
		if (m_nConductorNodeID  != 0)
		{
			//	Am I the conductor?
			if (m_nConductorNodeID == m_pMcsUserObject->GetMyNodeID())
			{
				if (recipient_node_id != m_pMcsUserObject->GetMyNodeID())
				{
					if (m_nPendingConductorNodeID == 0)
					{
						/*
						**	We don't assume that the recipient node is the new
						**	conductor until we get a confirm or an
						**	AssignIndication.  The m_nPendingConductorNodeID is
						**	used to buffer the recipient until the give confirm
						**	is received.
						*/
						m_nPendingConductorNodeID = recipient_node_id;
						rc = m_pMcsUserObject->ConductorTokenGive(recipient_node_id);
					}
					else
					{
						TRACE_OUT(("CConf::ConductorGiveRequest: conductor give is pending"));
						eResult = GCC_RESULT_CONDUCTOR_GIVE_IS_PENDING;
					}
				}
				else
				{
					WARNING_OUT(("CConf::ConductorGiveRequest: already conductor"));
					eResult = GCC_RESULT_ALREADY_CONDUCTOR;
				}
			}
			else
			{
				ERROR_OUT(("CConf::ConductorGiveRequest: not the conductor"));
				eResult = GCC_RESULT_NOT_THE_CONDUCTOR;
			}
		}
		else
		{
			ERROR_OUT(("CConf::ConductorGiveRequest: not in conduct mode"));
			eResult = GCC_RESULT_NOT_IN_CONDUCTED_MODE;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConductorGiveRequest: not conductible"));
		eResult = GCC_RESULT_NOT_CONDUCTIBLE;
	}

#ifdef JASPER
	if (INVALID_GCC_RESULT != eResult)
	{
		g_pControlSap->ConductorGiveConfirm(eResult, m_nConfID, recipient_node_id);
	}
#endif // JASPER

	DebugExitINT(CConf::ConductorGiveRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError ConductorGiveResponse ()
 *
 *	Public Function Description
 *		This function gets called in response to a Conductor Give Indication.
 *		If result is success then this node is the new conductor.
 */
GCCError CConf::
ConductorGiveResponse ( GCCResult eResult )
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConductorGiveResponse);

	if (! m_fConductorGiveResponsePending)
	{
		ERROR_OUT(("CConf::ConductorGiveResponse: no give response pending"));
		rc = GCC_NO_GIVE_RESPONSE_PENDING;
		goto MyExit;
	}

	m_fConductorGiveResponsePending = FALSE;

	if (eResult == GCC_RESULT_SUCCESSFUL)
	{
		//	Set the conductor id to my user id if the response is success.
		m_nConductorNodeID = m_pMcsUserObject->GetMyNodeID();

		//	The new conductor always has permission.
		m_fConductorGrantedPermission = TRUE;

		/*
		**	We must perform the give response before sending the dummy to
		**	the top provider so that MCS knows that the conductor token
		**	belongs to this node.
		*/
		rc = m_pMcsUserObject->ConductorTokenGiveResponse(RESULT_SUCCESSFUL);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConductorGiveResponse: ConductorTokenGiveResponse failed, rc=%d", rc));
			goto MyExit;
		}

		/*
		**	If this node is not the Top Provider, we must try to Give the
		**	Conductor token to the Top Provider.  The Top Provider is used
		**	to issue the Assign Indication whenever the conductor changes
		**	hands.
		*/
		if (m_pMcsUserObject->GetMyNodeID() != m_pMcsUserObject->GetTopNodeID())
		{
			rc = m_pMcsUserObject->ConductorTokenGive(m_pMcsUserObject->GetTopNodeID());
		}
		else
		{
			/*
			**	Here we go ahead and send the assign indication because we
			**	are already at the Top Provider.
			*/
			rc = m_pMcsUserObject->SendConductorAssignIndication(m_nConductorNodeID);
		}
	}
	else
	{
		//	Inform that giver that we are not interested
		rc = m_pMcsUserObject->ConductorTokenGiveResponse(RESULT_USER_REJECTED);
	}

MyExit:

	DebugExitINT(CConf::ConductorGiveResponse, rc);
	return rc;
}
				

/*
 *	GCCError ConductorPermitAskRequest ()
 *
 *	Public Function Description
 *		This call is made when a node wants to request permission from the
 *		conductor.
 */
#ifdef JASPER
GCCError CConf::
ConductorPermitAskRequest ( BOOL grant_permission )
{
	GCCError	rc = GCC_NO_ERROR;
	GCCResult	eResult = INVALID_GCC_RESULT;

	DebugEntry(CConf::ConductorPermitAskRequest);

	if (m_fConfConductible)
	{
		//	Am I in conducted mode?
		if (m_nConductorNodeID != 0)
		{
			if (m_nConductorNodeID != m_pMcsUserObject->GetMyNodeID())
			{
				rc = m_pMcsUserObject->SendConductorPermitAsk(grant_permission);
				if (rc == GCC_NO_ERROR)
				{
					eResult = GCC_RESULT_SUCCESSFUL;
				}
			}
			else
			{
				WARNING_OUT(("CConf::ConductorPermitAskRequest: already conductor"));
		 		eResult = GCC_RESULT_ALREADY_CONDUCTOR;
			}
		}
		else
		{
			ERROR_OUT(("CConf::ConductorPermitAskRequest: not in conducted mode"));
			eResult = GCC_RESULT_NOT_IN_CONDUCTED_MODE;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConductorPermitAskRequest: not conductible"));
		eResult = GCC_RESULT_NOT_CONDUCTIBLE;
	}

#ifdef JASPER
	if (INVALID_GCC_RESULT != eResult)
	{
		g_pControlSap->ConductorPermitAskConfirm(eResult, grant_permission, m_nConfID);
	}
#endif // JASPER

	DebugExitINT(CConf::ConductorPermitAskRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError ConductorPermitGrantRequest ()
 *
 *	Public Function Description
 *		This function is called when a conductor wishes to grant permission
 *		to a specific node or to a list of nodes.
 */
#ifdef JASPER
GCCError CConf::
ConductorPermitGrantRequest
(
	UINT					number_granted,
	PUserID					granted_node_list,
	UINT					number_waiting,
	PUserID					waiting_node_list
)
{
	GCCError	rc = GCC_NO_ERROR;
	GCCResult	eResult = INVALID_GCC_RESULT;

	DebugEntry(CConf::ConductorPermitGrantRequest);

	if (m_fConfConductible)
	{
		//	Am I in conducted mode?
		if (m_nConductorNodeID != 0)
		{
			//	Am I the conductor?
			if (m_nConductorNodeID == m_pMcsUserObject->GetMyNodeID())
			{
				TRACE_OUT(("CConf: ConductorPermitGrantRequest: SEND: number_granted = %d", number_granted));

				rc = m_pMcsUserObject->SendConductorPermitGrant(
															number_granted,
															granted_node_list,
															number_waiting,
															waiting_node_list);
				if (rc == GCC_NO_ERROR)
				{
					eResult = GCC_RESULT_SUCCESSFUL;
				}
			}
			else
			{
				ERROR_OUT(("CConf::ConductorPermitGrantRequest: not the conductor"));
				eResult = GCC_RESULT_NOT_THE_CONDUCTOR;
			}
		}
		else
		{
			ERROR_OUT(("CConf::ConductorPermitGrantRequest: not in conducted mode"));
	 		eResult = GCC_RESULT_NOT_IN_CONDUCTED_MODE;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConductorPermitGrantRequest: not conductible"));
		eResult = GCC_RESULT_NOT_CONDUCTIBLE;
	}

#ifdef JASPER
	if (INVALID_GCC_RESULT != eResult)
	{
		g_pControlSap->ConductorPermitGrantConfirm(eResult, m_nConfID);
	}
#endif // JASPER

	DebugExitINT(CConf::ConductorPermitGrantRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError ConductorInquireRequest ()
 *
 *	Public Function Description
 *		This function is called when a node request conductorship information.
 */
GCCError CConf::
ConductorInquireRequest ( CBaseSap *pSap )
{
	GCCError	rc = GCC_NO_ERROR;
	GCCResult	eResult = INVALID_GCC_RESULT;

	DebugEntry(CConf::ConductorInquireRequest);

	if (m_fConfConductible)
	{
		if (m_nConductorNodeID != 0)
		{
			rc = m_pMcsUserObject->ConductorTokenTest();

			/*
			**	We must "push" the command target to the to the list of
			**	outstanding conductor test request.  When the test confirm
			**	comes back the command target will be "poped" of the list.
			**	Note that all test request must be processed in the order that
			**	they are requested.
			*/
			m_ConductorTestList.Append(pSap);
		}
		else
		{
			//	If not in conducted mode send back NO conductor information
			ERROR_OUT(("CConf::ConductorInquireRequest: not in conducted mode"));
			eResult = GCC_RESULT_NOT_IN_CONDUCTED_MODE;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConductorInquireRequest: not conductible"));
		eResult = GCC_RESULT_NOT_CONDUCTIBLE;
	}

	if (INVALID_GCC_RESULT != eResult)
	{
		pSap->ConductorInquireConfirm(NULL,
									eResult,
									m_fConductorGrantedPermission,
									FALSE,
									m_nConfID);
	}

	DebugExitINT(CConf:ConductorInquireRequest, rc);
	return rc;
}

/********************** Miscelaneous Finctions **********************/


/*
 *	GCCError 	ConferenceTimeRemainingRequest ()
 *
 *	Public Function Description
  *		This function initiates a TimeRemainingRequest sequence.
 */
GCCError CConf::
ConferenceTimeRemainingRequest
(
	UINT			time_remaining,
	UserID			node_id
)
{
	GCCError	rc;

	DebugEntry(CConf::ConferenceTimeRemainingRequest);

	if (m_fConfIsEstablished)
	{
		rc = m_pMcsUserObject->TimeRemainingRequest(time_remaining, node_id);	
#ifdef JASPER
		if (rc == GCC_NO_ERROR)
		{
			g_pControlSap->ConfTimeRemainingConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);
		}
#endif // JASPER
	}
	else
	{
		ERROR_OUT(("CConf::ConferenceTimeRemainingRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConferenceTimeRemainingRequest, rc);

	return rc;
}


/*
 *	GCCError 	ConfTimeInquireRequest ()
 *
 *	Public Function Description
 *		This function initiates a ConfTimeInquireRequest sequence.
 */
#ifdef JASPER
GCCError CConf::
ConfTimeInquireRequest ( BOOL time_is_conference_wide )
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConfTimeInquireRequest);

	if (m_fConfIsEstablished)
	{
		if ((m_eNodeType == CONVENER_NODE) ||
			(m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE)||
			(m_eNodeType == JOINED_CONVENER_NODE))
		{
			g_pControlSap->ConfTimeInquireIndication(
					m_nConfID,
					time_is_conference_wide,
					m_pMcsUserObject->GetMyNodeID());
		}
		else
		{
			rc = m_pMcsUserObject->TimeInquireRequest(time_is_conference_wide);
		}	

#ifdef JASPER
		if (rc == GCC_NO_ERROR)
		{
			g_pControlSap->ConfTimeInquireConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);
		}
#endif // JASPER
	}
	else
	{
		ERROR_OUT(("CConf::ConfTimeInquireRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfTimeInquireRequest, rc);

	return rc;
}
#endif // JASPER


/*
 *	GCCError 	ConfExtendRequest ()
 *
 *	Public Function Description
 *		This function initiates a ConfExtendRequest sequence.
 */
#ifdef JASPER
GCCError CConf::
ConfExtendRequest
(
	UINT			extension_time,
	BOOL		 	time_is_conference_wide
)
{
	GCCError		rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConfExtendRequest);

	if (m_fConfIsEstablished)
	{
		if ((m_eNodeType == CONVENER_NODE) ||
			(m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE)||
			(m_eNodeType == JOINED_CONVENER_NODE))
		{
#ifdef JASPER
			g_pControlSap->ConfExtendIndication(
									m_nConfID,
									extension_time,
									time_is_conference_wide,
									m_pMcsUserObject->GetMyNodeID());
#endif // JASPER
		}
		else
		{
			rc = m_pMcsUserObject->ConferenceExtendIndication(
													extension_time,
													time_is_conference_wide);
		}

#ifdef JASPER
		if (rc == GCC_NO_ERROR)
		{
			g_pControlSap->ConfExtendConfirm(
										m_nConfID,
										extension_time,
										GCC_RESULT_SUCCESSFUL);
		}
#endif // JASPER
	}
	else
	{
		ERROR_OUT(("CConf::ConfExtendRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfExtendRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError 	ConfAssistanceRequest ()
 *
 *	Public Function Description
 *		This function initiates a ConfAssistanceRequest sequence.
 */
#ifdef JASPER
GCCError CConf::
ConfAssistanceRequest
(
	UINT			number_of_user_data_members,
	PGCCUserData    *user_data_list
)
{
	GCCError	rc;

	DebugEntry(CConf::ConfAssistanceRequest);

	if (m_fConfIsEstablished)
	{
		rc = m_pMcsUserObject->ConferenceAssistanceIndication(
												number_of_user_data_members,
												user_data_list);
#ifdef JASPER
		if (rc == GCC_NO_ERROR)
		{
			g_pControlSap->ConfAssistanceConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);
		}
#endif // JASPER
	}
	else
	{
		ERROR_OUT(("CConf::ConfAssistanceRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfAssistanceRequest, rc);
	return rc;
}
#endif // JASPER

/*
 *	GCCError 	AppInvokeRequest()
 *
 *	Public Function Description
 *		This function initiates an ApplicationInvokeRequest sequence.
 */
GCCError CConf::
AppInvokeRequest
(
    CInvokeSpecifierListContainer   *invoke_list,
    GCCSimpleNodeList               *pNodeList,
    CBaseSap                        *pSap,
    GCCRequestTag                   nReqTag
)
{
	GCCError	rc;

	DebugEntry(CConf::AppInvokeRequest);

	if (m_fConfIsEstablished)
	{
		rc = m_pMcsUserObject->AppInvokeIndication(invoke_list, pNodeList);
		if (rc == GCC_NO_ERROR)
		{
			pSap->AppInvokeConfirm(m_nConfID, invoke_list, GCC_RESULT_SUCCESSFUL, nReqTag);
		}
	}
	else
	{
		ERROR_OUT(("CConf::AppInvokeRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::AppInvokeRequest, rc);
	return rc;
}


/*
 *	GCCError 	TextMessageRequest ()
 *
 *	Public Function Description
 *		This function initiates an TextMessageRequest sequence.
 */
#ifdef JASPER
GCCError CConf::
TextMessageRequest
(
    LPWSTR          pwszTextMsg,
    UserID          destination_node
)
{
	GCCError	rc;

	DebugEntry(CConf::TextMessageRequest);

	if (m_fConfIsEstablished)
	{
	 	if (destination_node != m_pMcsUserObject->GetMyNodeID())
		{
			rc = m_pMcsUserObject->TextMessageIndication(pwszTextMsg, destination_node);
#ifdef JASPER
			if (rc == GCC_NO_ERROR)
			{
				g_pControlSap->TextMessageConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);
			}
#endif // JASPER
		}
		else
		{
			WARNING_OUT(("CConf::TextMessageRequest: invalid user ID"));
			rc = GCC_INVALID_MCS_USER_ID;
		}
	}
	else
	{
		ERROR_OUT(("CConf::TextMessageRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::TextMessageRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError 	ConfTransferRequest ()
 *
 *	Public Function Description
 *		This function initiates an ConfTransferRequest sequence.
 */
#ifdef JASPER
GCCError CConf::
ConfTransferRequest
(
	PGCCConferenceName	    destination_conference_name,
	GCCNumericString	    destination_conference_modifier,
	CNetAddrListContainer   *destination_address_list,
	UINT				    number_of_destination_nodes,
	PUserID				    destination_node_list,
	CPassword               *password
)
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CConf::ConfTransferRequest);

	if (m_fConfIsEstablished)
	{
		if (IsConfTopProvider())
		{
			if (DoesRequesterHavePrivilege(	m_pMcsUserObject->GetMyNodeID(),
											TRANSFER_PRIVILEGE))
			{
				rc = m_pMcsUserObject->ConferenceTransferIndication(
												destination_conference_name,
												destination_conference_modifier,
												destination_address_list,
												number_of_destination_nodes,
						 						destination_node_list,
												password);
#ifdef JASPER
				if (rc == GCC_NO_ERROR)
				{
					g_pControlSap->ConfTransferConfirm(
												m_nConfID,
												destination_conference_name,
												destination_conference_modifier,
												number_of_destination_nodes,
						 						destination_node_list,
												GCC_RESULT_SUCCESSFUL);
				}
#endif // JASPER
			}
			else
			{
				WARNING_OUT(("CConf::ConfTransferRequest: insufficient privilege to transfer conference"));
			}
		}
		else
		{
			rc = m_pMcsUserObject->ConferenceTransferRequest(
												destination_conference_name,
												destination_conference_modifier,
												destination_address_list,
												number_of_destination_nodes,
						 						destination_node_list,
												password);
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConfTransferRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfTransferRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError	ConfAddRequest ()
 *
 *	Public Function Description
 *		This function initiates an ConfAddRequest sequence.
 */
#ifdef JASPER
GCCError CConf::
ConfAddRequest
(
	CNetAddrListContainer   *network_address_container,
	UserID				    adding_node,
	CUserDataListContainer  *user_data_container
)
{
	GCCError	rc = GCC_NO_ERROR;
	TagNumber	conference_add_tag;
	UserID		target_node;

	DebugEntry(CConf::ConfAddRequest);

	if (! m_fConfIsEstablished)
	{
		ERROR_OUT(("CConf::ConfAddRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
		goto MyExit;
	}

	/*
	**	A node cannot tell itself to add because of the way the
	**	Add Response call works.  Since an Add Response is sent non-
	**	uniformly directly to the node that made the request the response
	**	would never reach the requesting node.  Therefore, this is flaged
	**	as an error condition here.
	*/
	if (adding_node == m_pMcsUserObject->GetMyNodeID())
	{
		ERROR_OUT(("CConf::ConfAddRequest: can't tell myself to add"));
		rc = GCC_BAD_ADDING_NODE;
		goto MyExit;
	}

	/*
	**	Note that the way the standard reads, it looks like you
	**	do not have to check the privileges for the top provider
	**	on an Add.  We do though check to see if the Top Provider is
	**	making the request to a node other than the top provider. If
	**	not this is considered an error here.
	*/
	if (IsConfTopProvider())
	{
		/*
		**	If the adding node is zero at the top provider, this is
		**	the same as specifying ones self to be the adding node.
		*/
		if (adding_node == 0)
		{
			ERROR_OUT(("CConf::ConfAddRequest: can't tell myself to add"));
			rc = GCC_BAD_ADDING_NODE;
			goto MyExit;
		}
		else
		{
			target_node = adding_node;
		}
	}
	else
	{
		target_node = m_pMcsUserObject->GetTopNodeID();
	}

	//	First determine the conference add tag
	while (1)
	{
		conference_add_tag = ++m_nConfAddRequestTagNumber;
		if (NULL == m_AddRequestList.Find(conference_add_tag))
			break;
	}

	//	Send out the PDU
	rc = m_pMcsUserObject->ConferenceAddRequest(
										conference_add_tag,
										m_pMcsUserObject->GetMyNodeID(),
										adding_node,
										target_node,
										network_address_container,
										user_data_container);
	if (GCC_NO_ERROR != rc)
	{
		ERROR_OUT(("CConf::ConfAddRequest: ConferenceAddRequest failed, rc=%d", rc));
		goto MyExit;
	}

	/*
	**	We must lock the network address to keep it from
	**	being deleted upon returning.
	*/
	if (network_address_container != NULL)
	{
		network_address_container->LockNetworkAddressList();
	}

	//	Add this entry to the add request list.					
	m_AddRequestList.Append(conference_add_tag, network_address_container);

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CConf::ConfAddRequest, rc);
	return rc;
}
#endif // JASPER


/*
 *	GCCError	ConfAddResponse ()
 *
 *	Public Function Description
 *		This call is made in response to an Add indication.  It is initiated
 *		by the Node Controller.
 */
GCCError CConf::
ConfAddResponse
(
	GCCResponseTag		    add_response_tag,
	UserID				    requesting_node,
	CUserDataListContainer  *user_data_container,
	GCCResult			    result
)
{
	GCCError	rc;
	TagNumber	lTagNum;

	DebugEntry(CConf::ConfAddResponse);

	if (m_fConfIsEstablished)
	{
		if (0 != (lTagNum = m_AddResponseList.Find(add_response_tag)))
		{
			//	Send out the response PDU
			rc = m_pMcsUserObject->ConferenceAddResponse(lTagNum, requesting_node,
														user_data_container, result);
			if (rc == GCC_NO_ERROR)
			{
				m_AddResponseList.Remove(add_response_tag);
			}
			else
			{
				ERROR_OUT(("CConf::ConfAddResponse: ConferenceAddResponse failed, rc=%d", rc));
			}
		}
		else
		{
			ERROR_OUT(("CConf::ConfAddResponse: invalid add response tag"));
			rc = GCC_INVALID_ADD_RESPONSE_TAG;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConfAddResponse: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::ConfAddResponse, rc);
	return rc;
}


/*
**	These calls are received from the User Attachment object via the
**	Owner-Callback routine.  Note that all calls received from the
**	user attachment object are preceeded by the word Process.
*/


/*
 *	CConf::ProcessRosterUpdateIndication ()	
 *
 *	Private Function Description
 *		This routine is responsible for processing all the incomming roster
 *		update PDUs which are received from subordinate nodes.  These
 *		roster updates typically only include additions, changes or deletions
 *		of a few records within each PDU.
 *
 *	Formal Parameters:
 *		roster_update	-	This is the PDU structure that contains the data
 *							associated with the roster update.
 *		sender_id		-	User ID of node that sent the roster update.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessRosterUpdatePDU
(
    PGCCPDU         roster_update,
    UserID          sender_id
)
{
	GCCError	err = GCC_NO_ERROR;

	DebugEntry(CConf::ProcessRosterUpdatePDU);

	if (m_pConfRosterMgr != NULL)
	{
		err = m_pConfRosterMgr->RosterUpdateIndication(roster_update, sender_id);
		if (err != GCC_NO_ERROR)
		{
			goto MyExit;
		}

		//	Process the whole PDU before performing the flush.
		err = ProcessAppRosterIndicationPDU(roster_update, sender_id);
		if (err != GCC_NO_ERROR)
		{
			goto MyExit;
		}
		
 		UpdateNodeVersionList(roster_update, sender_id);

        if (HasNM2xNode())
        {
            T120_QueryApplet(APPLET_ID_CHAT,  APPLET_QUERY_NM2xNODE);
        }

#ifdef CHECK_VERSION
		if (GetNodeVersion(sender_id) >= NM_T120_VERSION_3)  // after NM 3.0
		{
			if (!m_fFTEnrolled)
			{
				m_fFTEnrolled = DoesRosterPDUContainApplet(roster_update,
									&FT_APP_PROTO_KEY, FALSE);
				if (m_fFTEnrolled)
				{
					::T120_LoadApplet(APPLET_ID_FT, FALSE, m_nConfID, FALSE, NULL);
				}
			}
		}
#else
		if (!m_fFTEnrolled)
		{
			m_fFTEnrolled = DoesRosterPDUContainApplet(roster_update,
								&FT_APP_PROTO_KEY, FALSE);
			if (m_fFTEnrolled)
			{
				::T120_LoadApplet(APPLET_ID_FT, FALSE, m_nConfID, FALSE, NULL);
			}
		}
#endif // CHECK_VERSION

		if (!m_fWBEnrolled)
		{
			m_fWBEnrolled = DoesRosterPDUContainApplet(roster_update,
								&WB_APP_PROTO_KEY, FALSE);
			if (m_fWBEnrolled)
			{
				::T120_LoadApplet(APPLET_ID_WB, FALSE, m_nConfID, FALSE, NULL);
			}
		}
		if (!m_fChatEnrolled)
		{
			m_fChatEnrolled = DoesRosterPDUContainApplet(roster_update,
								&CHAT_APP_PROTO_KEY, FALSE);
			if (m_fChatEnrolled)
			{
				::T120_LoadApplet(APPLET_ID_CHAT, FALSE, m_nConfID, FALSE, NULL);
			}
		}

		/*
		**	If this is the top provider and we are adding new nodes
		**	then we must update the new node with various roster
		**	information.  That is what is going on here.  If no new
		**	nodes have been added we go ahead and perform the
		**	Flush here.
		*/
		if (IsConfTopProvider() &&
			roster_update->u.indication.u.roster_update_indication.node_information.nodes_are_added)
		{
			err = UpdateNewConferenceNode ();
		}
		else
		{
		    //
		    // We just got an roster update from the wire.
		    //
			err = FlushRosterData();
		}
	}

MyExit:

	if (err != GCC_NO_ERROR)
	{
		ERROR_OUT(("CConf::ProcessRosterUpdatePDU: error processing roster refresh indication"));
		InitiateTermination(GCC_REASON_ERROR_TERMINATION, 0);
	}

	DebugExitVOID(CConf::ProcessRosterUpdatePDU);
}

/*
 *	GCCError ProcessAppRosterIndicationPDU ()	
 *
 *	Private Function Description
 *		This function operates specifically on the application roster
 *		portion of a roster PDU.
 *
 *	Formal Parameters:
 *		roster_update	-	This is the PDU structure that contains the data
 *							associated with the roster update.
 *		sender_id		-	User ID of node that sent the roster update.
 *
 *	Return Value
 *		GCC_NO_ERROR				-	No error.
 *		GCC_ALLOCATION_FAILURE		-	A resource error occured.
 *		GCC_BAD_SESSION_KEY			-	A bad session key exists in the update.		
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConf::
ProcessAppRosterIndicationPDU
(
    PGCCPDU         roster_update,
    UserID          sender_id
)
{
	GCCError							rc = GCC_NO_ERROR;
	PSetOfApplicationInformation		set_of_application_info;
	CAppRosterMgr						*app_roster_manager;
	CAppRosterMgr						*new_app_roster_manager;
	PSessionKey							session_key;

	DebugEntry(CConf::ProcessAppRosterIndicationPDU);

	set_of_application_info = roster_update->u.indication.u.
						roster_update_indication.application_information;

	/*
	**	First we iterate through the complete set of application information
	**	to determine if there is information here for an application roster
	**	manager that does not yet exists.  If we find one that does not
	**	exists we must go ahead and create it.
	*/
	while (set_of_application_info != NULL)
	{
		CAppRosterMgr		*pMgr;

		//	First set up the session key PDU pointer
		session_key = &set_of_application_info->value.session_key;

		/*
		**	We first iterate through the complete list of application
		**	roster manager objects looking for one with an application key that
		**	matches the key in the PDU.  If it is not found we create it.
		*/
		app_roster_manager = NULL;
		new_app_roster_manager = NULL;

//
// LONCHANC: We should be able to move this as separate common subroutine.
//
		m_AppRosterMgrList.Reset();
		while (NULL != (pMgr = m_AppRosterMgrList.Iterate()))
		{
			if (pMgr->IsThisYourSessionKeyPDU(session_key))
			{
				//	This application roster manager exist so return it.
				app_roster_manager = pMgr;
				break;
			}
		}

		/*
		**	If a roster manager associated with this app key does not exist
		**	we must create it here.
		*/	
		if (app_roster_manager == NULL)
		{
			DBG_SAVE_FILE_LINE
			app_roster_manager = new CAppRosterMgr(
											NULL,
											session_key,
											m_nConfID,
											m_pMcsUserObject,
											this,
											&rc);
			if (NULL == app_roster_manager || GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ProcessAppRosterIndicationPDU: can't create app roster mgr, rc=%d", rc));
                if (NULL != app_roster_manager)
                {
				    app_roster_manager->Release();
                }
                else
                {
                    rc = GCC_ALLOCATION_FAILURE;
                }
				goto MyExit;
			}

			new_app_roster_manager = app_roster_manager;
		}
		
		/*
		**	We no process this set of application information.  We pass it
		**	to the app roster manager found or created above.
		*/
		rc = app_roster_manager->ProcessRosterUpdateIndicationPDU(	
														set_of_application_info,
														sender_id);
		if (GCC_NO_ERROR != rc)
		{
		    //
			// LONCHANC: We should delete the newly created roster mgr.
			//
            if (NULL != new_app_roster_manager)
            {
                new_app_roster_manager->Release();
            }
			goto MyExit;
		}

		/*
		**	Save the new application roster manager if one was created
		**	when processing this roster update.
		*/											
		if (new_app_roster_manager != NULL)
		{
			m_AppRosterMgrList.Append(new_app_roster_manager);
		}

		//	Load the next application information structure.
		set_of_application_info = set_of_application_info->next;
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CConf::ProcessAppRosterIndicationPDU, rc);
	return rc;
}


/*
 *	CConf::ProcessDetachUserIndication ()
 *
 *	Private Function Description
 *		This routine sends the detach user indication to the node controler
 *		and updates the roster.
 *
 *	Formal Parameters:
 *		detached_user	-	User ID of user that detached from the conference.
 *		reason			-	Reason that the user detached.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessDetachUserIndication
(
    UserID          detached_user,
    GCCReason       reason
)
{
	GCCError		err = GCC_NO_ERROR;
	UINT			cRecords;

	DebugEntry(CConf::ProcessDetachUserIndication);

	if (m_fConfIsEstablished)
	{
		CAppRosterMgr	*lpAppRosterMgr;
		/*
		**	Send a disconnect indication to the node controller if this
		**	detached user corresponds to a GCC user id.
		*/
		if (m_pConfRosterMgr->Contains(detached_user))
		{
			g_pControlSap->ConfDisconnectIndication(
												m_nConfID,
												reason,
												detached_user);
		}

		//	Here we update the CConf Roster and the Application Roster.
		err = m_pConfRosterMgr->RemoveUserReference(detached_user);
		if (err == GCC_NO_ERROR)
		{
			if (IsConfTopProvider())
			{
				cRecords = m_pConfRosterMgr->GetNumberOfNodeRecords();
				/*
				**	If only one record remains in the conference roster
				**	it must be the local nodes record.  Therefore, if
				**	the conference is set up to be automatically
				**	terminated the owner object is notified to delete
				**	the conference.
				*/
				if ((m_eTerminationMethod == GCC_AUTOMATIC_TERMINATION_METHOD)
					&& (cRecords == 1))
				{
					TRACE_OUT(("CConf::ProcessDetachUserIndication: AUTOMATIC_TERMINATION"));
	 				InitiateTermination(GCC_REASON_NORMAL_TERMINATION, 0);
				}
				
				//	If this is the convener set its node id back to 0
				if (m_nConvenerNodeID == detached_user)
				{
					m_nConvenerNodeID = 0;
				}
			}
		}
		else
		if (err == GCC_INVALID_PARAMETER)
		{
			err = GCC_NO_ERROR;
		}
		
		/*
		**	Cleanup the Application Rosters of any records owned by this node.
		*/	
		m_AppRosterMgrList.Reset();
		while (NULL != (lpAppRosterMgr = m_AppRosterMgrList.Iterate()))
		{
			err = lpAppRosterMgr->RemoveUserReference(detached_user);
			if (GCC_NO_ERROR != err)
			{
				WARNING_OUT(("CConf::ProcessDetachUserIndication: can't remove user reference from app roster mgr, err=%d", err));
				break;
			}
		}
			
		//	Remove ownership rights this user had on any registry entries.
		m_pAppRegistry->RemoveNodeOwnership(detached_user);

		//	Cleanup Conductorship if detached user was the conductor
		if (detached_user == m_nConductorNodeID)
		{
			ProcessConductorReleaseIndication(0);
		}

		/*
		**	Here we give the roster managers a chance to flush any PDUs
		**	or data that might have gotten queued when removing the user
		**	reference. An error here is considered FATAL in that the conference
		**	information base at this node is now corrupted therefore we
		**	terminate the conference.
		*/
		if (err == GCC_NO_ERROR)
		{
		    //
		    // We just got detach user indication from the wire.
		    //
			err = FlushRosterData();
		}

		if (err != GCC_NO_ERROR)
		{
			ERROR_OUT(("CConf::ProcessDetachUserIndication: Error occured when flushing the rosters, err=%d", err));
	 		InitiateTermination((err == GCC_ALLOCATION_FAILURE) ?
									GCC_REASON_ERROR_LOW_RESOURCES :
		 							GCC_REASON_ERROR_TERMINATION,
								0);
		}
	 }

	DebugExitVOID(CConf::ProcessDetachUserIndication);
}


/*
 *	CConf::ProcessTerminateRequest ()
 *
 *	Private Function Description
 *		This routine processes a terminate request received from the MCSUser
 *		object.
 *
 *	Formal Parameters:
 *		requester_id	-	User ID of node that is requesting the terminate.
 *		reason			-	Reason for termination.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessTerminateRequest
(
    UserID          requester_id,
    GCCReason       reason
)
{
	DebugEntry(CConf::ProcessTerminateRequest);

	if (DoesRequesterHavePrivilege(requester_id, TERMINATE_PRIVILEGE))
	{
		TRACE_OUT(("CConf::ProcessTerminateRequest: Node has permission to terminate"));

		/*
		**	Since the terminate was successful, we go ahead and set the
		**	m_fConfIsEstablished instance variable to FALSE.  This prevents
		**	any other messages from flowing to the SAPs other than terminate
		**	messages.
		*/
		m_fConfIsEstablished = FALSE;

		//	Send a positive response to the requesting node
		m_pMcsUserObject->ConferenceTerminateResponse(requester_id, GCC_RESULT_SUCCESSFUL);
	
		/*
		**	This request will kick off a terminate at this node as well as
		**	all the nodes below this node in the connection hierarchy.
		*/
		m_pMcsUserObject->ConferenceTerminateIndication(reason);
	}
	else
	{
   		WARNING_OUT(("CConf::ProcessTerminateRequest: Node does NOT have permission to terminate"));
		//	Send a negative response to the requesting node
		m_pMcsUserObject->ConferenceTerminateResponse(requester_id, GCC_RESULT_INVALID_REQUESTER);
	}

	DebugExitVOID(CConf::ProcessTerminateRequest);
}


/*
 *	CConf::ProcessTerminateIndication ()
 *
 *	Private Function Description
 *		This routine takes care of both a normal termination through
 *		a terminate pdu and termination that occurs due to a parent
 *		node disconnecting.
 *
 *	Formal Parameters:
 *		reason			-	Reason for termination.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessTerminateIndication ( GCCReason gcc_reason )
{
	UserID	user_id;

	DebugEntry(CConf::ProcessTerminateIndication);

	/*
	**	Setting this to true here will insure that a terminate indication
	**	will be delivered to the control SAP.
	*/
	m_fConfTerminatePending = TRUE;
	
	if (gcc_reason == GCC_REASON_PARENT_DISCONNECTED)
	{
		TRACE_OUT(("CConf::ProcessTerminateIndication: Terminate due to parent disconnecting"));
		user_id = m_pMcsUserObject->GetMyNodeID();
	}
	else
	if (m_ConnHandleList.IsEmpty())
	{
		TRACE_OUT(("CConf: ProcessTerminateIndication: Terminate due to request (no child connections)"));
		/*
		**	Since there is a flaw in the terminate indication PDU were the
		**	node id that requested the termination is not sent we always
		**	assume here that the request came from the top provider (which
		**	is only partially true).
		*/
		user_id = m_pMcsUserObject->GetTopNodeID();
	}
	else
	{
		TRACE_OUT(("CConf::ProcessTerminateIndication: Wait till children disconnect before terminating"));

		/*
		**	Wait until disconnect provider indications are received on all the
		**	child connections before terminating the conference.
		*/
			
		m_eConfTerminateReason = gcc_reason;
	
		DBG_SAVE_FILE_LINE
		m_pConfTerminateAlarm = new Alarm (TERMINATE_TIMER_DURATION);
		if (NULL != m_pConfTerminateAlarm)
		{
			// let's wait, bail out without initiating termination.
			goto MyExit;
		}
		
		//	Go ahead and terminate if there is a resource error
		ERROR_OUT(("CConf: ProcessTerminateIndication: can't create terminate alarm"));
		user_id = m_pMcsUserObject->GetTopNodeID();
	}

	InitiateTermination(gcc_reason, user_id);

MyExit:

	DebugExitVOID(CConf::ProcessTerminateIndication);
}


/*
 *	CConf::ProcessUserIDIndication ()
 *
 *	Private Function Description
 *		This routine is responsible for matching incomming user IDs with
 *		tag numbers returned by the subordinate node.
 *
 *	Formal Parameters:
 *		tag_number		-	Tag used to match incomming user ID indication.
 *		user_id			-	User ID of node sending the indication.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
// checkpoint
void CConf::
ProcessUserIDIndication
(
    TagNumber           tag_number,
    UserID              user_id
)
{
	INVITE_REQ_INFO     *invite_request_info;
    ConnectionHandle    nConnHdl;

	DebugEntry(CConf::ProcessUserIDIndication);

	if (0 != (nConnHdl = m_ConnHdlTagNumberList2.Remove(tag_number)))
	{
		INVITE_REQ_INFO *lpInvReqInfo;

    	if (m_pMcsUserObject != NULL)
		{
			TRACE_OUT(("CConf: ProcessUserIDIndication: ID is set"));
			
			m_pMcsUserObject->SetChildUserIDAndConnection(user_id, nConnHdl);
		}
        else
		{
        	TRACE_OUT(("CConf::UserIDIndication: Error User Att. is NULL"));
		}
			
		/*
		**	Here we send an indication informing the node controller that
		**	a subordinate node has completed initialization.
		*/
		g_pControlSap->SubInitializationCompleteIndication (user_id, nConnHdl);

		/*
		**	Now we determine if the responding node is the convener and if it
		**	is we will set up the m_nConvenerNodeID.  This node id is used to
		**	determine privileges on certain GCC operations.
		*/
	 	if (m_nConvenerUserIDTagNumber == tag_number)
		{
			TRACE_OUT(("CConf::UserIDIndication: Convener Node ID is being set"));
			m_nConvenerUserIDTagNumber = 0;
			m_nConvenerNodeID = user_id;
		}
		
		/*
		**	If this is a User ID from an invited node we must pass the invite
		**	confirm to the Node Controller.
		*/
		m_InviteRequestList.Reset();
		invite_request_info = NULL;
		while (NULL != (lpInvReqInfo = m_InviteRequestList.Iterate()))
		{
			if (tag_number == lpInvReqInfo->invite_tag)
			{
				invite_request_info = lpInvReqInfo;
				break;
			}
		}

		if (invite_request_info != NULL)
		{
			g_pControlSap->ConfInviteConfirm(
								m_nConfID,
								invite_request_info->user_data_list,
								GCC_RESULT_SUCCESSFUL,
								invite_request_info->connection_handle);

			//	Free up user data if it exists
			if (invite_request_info->user_data_list != NULL)
			{
				invite_request_info->user_data_list->Release();
			}

		    //	Cleanup the invite request list
		    m_InviteRequestList.Remove(invite_request_info);

		    //	Free up the invite request info structure
		    delete invite_request_info;

		}
	}
	else
	{
		TRACE_OUT(("CConf::ProcessUserIDIndication: Bad User ID Tag Number received"));
	}

	DebugExitVOID(CConf::ProcessUserIDIndication);
}


/*
 *	CConf::ProcessUserCreateConfirm ()
 *
 *	Private Function Description
 *		This routine handles the processes that occur after a user
 *		create confirm is received. This process will differ depending
 *		on what the node type is.
 *
 *	Formal Parameters:
 *		result_value	-	Result of the user attachment being created.
 *		node_id			-	This nodes node id.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessUserCreateConfirm
(
    UserResultType	    result_value,
    UserID              node_id
)
{
	GCCError					err = GCC_NO_ERROR;
	PUChar						encoded_pdu;
	UINT						encoded_pdu_length;
	ConnectGCCPDU				connect_pdu;
	MCSError					mcs_error;
	GCCConferenceName			conference_name;
	GCCNumericString			conference_modifier;
	GCCNumericString			remote_modifier = NULL;
	BOOL						is_top_provider;

	DebugEntry(CConf::ProcessUserCreateConfirm);

	if (result_value == USER_RESULT_SUCCESSFUL)
	{
		switch (m_eNodeType)
		{
			case TOP_PROVIDER_NODE:
				/*
				**	Encode the tag number into the ConferenceCreateResponse
				**	PDU.  If we have gotten this far the result is success.
				*/
				
				connect_pdu.choice = CONFERENCE_CREATE_RESPONSE_CHOSEN;
				connect_pdu.u.conference_create_response.bit_mask = 0;
				
				connect_pdu.u.conference_create_response.node_id = node_id;
				
				/*
				**	Here we save this particular User ID tag and mark it as the
				**	conveners so that when the convener's user ID is returned
				**	the m_nConvenerNodeID instance variable can be properly
				**	initialized.
				*/
				m_nConvenerUserIDTagNumber = GetNewUserIDTag ();
				connect_pdu.u.conference_create_response.tag = m_nConvenerUserIDTagNumber;
			
				if (m_pUserDataList != NULL)
				{
					connect_pdu.u.conference_create_response.bit_mask |= CCRS_USER_DATA_PRESENT;

					err = m_pUserDataList->GetUserDataPDU(
												&connect_pdu.u.conference_create_response.ccrs_user_data);
					if (err != GCC_NO_ERROR)
					{
						//	Terminate conference due to resource error
 						InitiateTermination (	GCC_REASON_ERROR_LOW_RESOURCES,
 									   			0);
						break;
					}
				}
				
				connect_pdu.u.conference_create_response.result =
                		::TranslateGCCResultToCreateResult(GCC_RESULT_SUCCESSFUL);

				if (g_GCCCoder->Encode((LPVOID) &connect_pdu,
											CONNECT_GCC_PDU,
											PACKED_ENCODING_RULES,
											&encoded_pdu,
											&encoded_pdu_length))
				{
					mcs_error = g_pMCSIntf->ConnectProviderResponse (
	                						m_hConvenerConnection,
											&m_nConfID,
											m_pDomainParameters,
											RESULT_SUCCESSFUL,
											encoded_pdu,
											encoded_pdu_length);

					g_GCCCoder->FreeEncoded(encoded_pdu);

					if (mcs_error == MCS_NO_ERROR)
					{
						m_fConfIsEstablished = TRUE;
					
						/*
						**	Add the user's tag number to the list of
						**	outstanding user ids along with its associated
						**	connection.
						*/
                        ASSERT(0 != m_hConvenerConnection);
						m_ConnHdlTagNumberList2.Append(connect_pdu.u.conference_create_response.tag,
													m_hConvenerConnection);
					}
					else if (mcs_error == MCS_DOMAIN_PARAMETERS_UNACCEPTABLE)
					{
						/*
						**	Inform the node controller that the reason
						**	the conference was terminated was that the
						**	domain parameter passed in the Create Response
						**	were unacceptable.
						*/
	 					InitiateTermination(GCC_REASON_DOMAIN_PARAMETERS_UNACCEPTABLE, 0);
					}
					else
					{
	 					InitiateTermination(GCC_REASON_MCS_RESOURCE_FAILURE, 0);
					}
				}
                else
                {
					/*
					**	A Fatal Resource error has occured. At this point
					**	the conference is invalid and should be terminated.
					*/
					ERROR_OUT(("CConf::ProcessUserCreateConfirm: can't encode. Terminate Conference"));
	 				InitiateTermination(GCC_REASON_ERROR_LOW_RESOURCES, 0);
                }
				break;
				
			case CONVENER_NODE:

				if(g_pControlSap)
				{
					/*
					**	Send the GCC User ID is here. This will require a call to
					**	the User Object. The tag number that was returned in
					**	the ConfCreateResponse call is used here.
					*/
					if (m_pMcsUserObject != NULL)
					{
						m_pMcsUserObject->SendUserIDRequest(m_nParentIDTagNumber);
					}
					
					//	Fill in the conference name data pointers.
		        	GetConferenceNameAndModifier(&conference_name, &conference_modifier);

					g_pControlSap->ConfCreateConfirm(&conference_name,
													conference_modifier,
													m_nConfID,
												    m_pDomainParameters,
													m_pUserDataList,
													GCC_RESULT_SUCCESSFUL,
												    m_hParentConnection);

					//	Free up the User Data List
					if (m_pUserDataList != NULL)
					{
						m_pUserDataList->Release();
						m_pUserDataList = NULL;
					}

					m_fConfIsEstablished = TRUE;
				}
				break;

			case TOP_PROVIDER_AND_CONVENER_NODE:
				if(g_pControlSap)
				{
					/*
					**	First set up the convener node id. In this case it is
					**	identical to the node ID of the Top Provider which is this
					**	node.
					*/
					m_nConvenerNodeID = m_pMcsUserObject->GetMyNodeID();
					
					//	Fill in the conference name data pointers.
	            	GetConferenceNameAndModifier(	&conference_name,
	                                          		&conference_modifier);

					g_pControlSap->ConfCreateConfirm(
	        										&conference_name,
													conference_modifier,
													m_nConfID,
	                                      			m_pDomainParameters,
	                                      			NULL,
													GCC_RESULT_SUCCESSFUL,
													0);	//Parent Connection
					m_fConfIsEstablished = TRUE;
				}
				break;

			case JOINED_NODE:
			case JOINED_CONVENER_NODE:
				if(g_pControlSap)
				{
					/*
					**	Send the GCC User ID is here. This will require a call to
					**	the User Object. The tag number that was returned in
					**	the ConfCreateResponse call is used here.
					*/
					if (m_pMcsUserObject != NULL)
					{
						m_pMcsUserObject->SendUserIDRequest(m_nParentIDTagNumber);
					}
					
					//	Fill in the conference name data pointers.
	            	GetConferenceNameAndModifier(	&conference_name,
	                                          		&conference_modifier);
													
					if (m_pszRemoteModifier != NULL)
					{
						remote_modifier = (GCCNumericString) m_pszRemoteModifier;
					}

					g_pControlSap->ConfJoinConfirm(
											&conference_name,
											remote_modifier,
											conference_modifier,
											m_nConfID,
											NULL,
											m_pDomainParameters,
											m_fClearPassword,
											m_fConfLocked,
											m_fConfListed,
											m_fConfConductible,
											m_eTerminationMethod,
											m_pConductorPrivilegeList,
											m_pConductModePrivilegeList,
											m_pNonConductModePrivilegeList,
											m_pwszConfDescription,
											m_pUserDataList,
											GCC_RESULT_SUCCESSFUL,
	                                                                                m_hParentConnection,
	                                                                                NULL,
	                                                                                0);
							
					m_fConfIsEstablished = TRUE;
				}
				break;

			case INVITED_NODE:
				/*
				**	Send the GCC User ID here. This will require a call to
				**	the User Object.
				*/
				if (m_pMcsUserObject != NULL)
					m_pMcsUserObject->SendUserIDRequest(m_nParentIDTagNumber);
				
				m_fConfIsEstablished = TRUE;
				break;
				
			default:
				TRACE_OUT(("CConf:UserCreateConfirm: Error: Bad User Type"));
				break;
		}
	
	
		if (m_fConfIsEstablished)
		{
			/*
			**	We now instantiate the conference roster manager to be used
			**	with this conference.
			*/
			if ((m_eNodeType == TOP_PROVIDER_NODE) ||
				(m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE))
			{
				is_top_provider = TRUE;
			}
			else
				is_top_provider = FALSE;

			DBG_SAVE_FILE_LINE
			m_pConfRosterMgr = new CConfRosterMgr(
												m_pMcsUserObject,
												this,
												is_top_provider,
												&err);
			if (m_pConfRosterMgr == NULL)
				err = GCC_ALLOCATION_FAILURE;

			/*
			**	We create the application registry object here because we now
			**	know the node type.
			*/
			if (err == GCC_NO_ERROR)
			{
				if ((m_eNodeType == TOP_PROVIDER_NODE) ||
					(m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE))
				{
					DBG_SAVE_FILE_LINE
					m_pAppRegistry = new CRegistry(
											m_pMcsUserObject,
											TRUE,
											m_nConfID,
											&m_AppRosterMgrList,
											&err);
	            }
				else
				{
					DBG_SAVE_FILE_LINE
					m_pAppRegistry = new CRegistry(
											m_pMcsUserObject,
											FALSE,
											m_nConfID,
											&m_AppRosterMgrList,
											&err);
				}
			}

			if ((m_pAppRegistry != NULL) &&
				(err == GCC_NO_ERROR))
			{
				/*
				**	Inform the node controller that it is time to do an announce
				**	presence for this conference.
				*/
				g_pControlSap->ConfPermissionToAnnounce(m_nConfID, node_id);

				/*
				**	Make the owner callback to inform that the owner object that
				**	the conference object was successfully created. This also
				**	kicks off the permission to enroll process.
				*/
				g_pGCCController->ProcessConfEstablished(m_nConfID);

				/*
				**	For all nodes except the top provider node we allocate a
				**	startup alarm that is used to hold back all roster flushes
				**	for a certain length of time giving all the local APEs
				**	time to enroll. An allocation failure here is not FATAL
				**	since everything will work with or without this alarm.
				**	Without the Alarm there may be a bit more network traffic
				**	during the startup process.  Note that there is no need
				**	for a startup alarm if there are no application SAPs.
				*/
				if ((m_eNodeType != TOP_PROVIDER_NODE) &&
					(m_eNodeType != TOP_PROVIDER_AND_CONVENER_NODE))
				{
					TRACE_OUT(("CConf:ProcessUserCreateConfirm: Creating Startup Alarm"));
					// m_pConfStartupAlarm = new Alarm(STARTUP_TIMER_DURATION);
				}
			}
			else
			{
				TRACE_OUT(("CConf: UserCreateConfirm: Error initializing"));
	 			InitiateTermination(GCC_REASON_ERROR_LOW_RESOURCES, 0);
			}
		}
	}
	else
	{
		TRACE_OUT(("CConf: UserCreateConfirm: Create of User Att. Failed"));

		/*
		**	Try to properly cleanup here.  Since the user creation failed
		**	the conference is no longer valid and needs to be cleaned up.
		*/
		switch (m_eNodeType)
		{
			case TOP_PROVIDER_NODE:
				g_pMCSIntf->ConnectProviderResponse (
	              							m_hConvenerConnection,
											&m_nConfID,
											m_pDomainParameters,
											RESULT_UNSPECIFIED_FAILURE,
											NULL, 0);
				break;

			case CONVENER_NODE:
			case TOP_PROVIDER_AND_CONVENER_NODE:
				if(g_pControlSap)
				{
		            GetConferenceNameAndModifier(	&conference_name,
		                                          	&conference_modifier);

					g_pControlSap->ConfCreateConfirm(
												&conference_name,
												conference_modifier,
												m_nConfID,
												m_pDomainParameters,
	                                 			NULL,
												GCC_RESULT_RESOURCES_UNAVAILABLE,
											    m_hParentConnection);
				}
				break;

			case JOINED_NODE:
			case JOINED_CONVENER_NODE:
				if(g_pControlSap)
				{
		            GetConferenceNameAndModifier(	&conference_name,
		                                          	&conference_modifier);

					if (m_pszRemoteModifier != NULL)
					{
						remote_modifier = (GCCNumericString) m_pszRemoteModifier;
					}

					g_pControlSap->ConfJoinConfirm(
												&conference_name,
												remote_modifier,
												conference_modifier,
												m_nConfID,
												NULL,
												m_pDomainParameters,
												m_fClearPassword,
												m_fConfLocked,
												m_fConfListed,
												m_fConfConductible,
												m_eTerminationMethod,
												m_pConductorPrivilegeList,
												m_pConductModePrivilegeList,
												m_pNonConductModePrivilegeList,
												m_pwszConfDescription,
												m_pUserDataList,
												GCC_RESULT_RESOURCES_UNAVAILABLE,
	                                                                                        m_hParentConnection,
	                                                                                        NULL,
	                                                                                        0);
				}
				break;

			case INVITED_NODE:
			default:
				break;
		}

		/*
		**	A Fatal Resource error has occured. At this point
		**	the conference is invalid and should be terminated.
		*/
	 	InitiateTermination(GCC_REASON_MCS_RESOURCE_FAILURE, 0);
	}

	DebugExitVOID(CConf::ProcessUserCreateConfirm);
}


//	Calls received from the MCS interface


/*
 *	CConf::ProcessConnectProviderConfirm ()
 *
 *	Private Function Description
 *		This routine processes connect provider confirms received
 *		directly from MCS.
 *
 *	Formal Parameters:
 *		connect_provider_confirm	-	This structure contains the MCS related
 *										data such as sender id and connection
 *										Handle as well as the PDU data.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConnectProviderConfirm ( PConnectProviderConfirm connect_provider_confirm )
{
	PPacket							packet;
	PConnectGCCPDU					connect_pdu;
	PacketError						packet_error;
	GCCResult						result = GCC_RESULT_SUCCESSFUL;
	GCCConferenceName				conference_name;
	GCCNumericString				conference_modifier;
	GCCNumericString				remote_modifier = NULL;
	INVITE_REQ_INFO                 *invite_request_info;

	DebugEntry(CConf::ProcessConnectProviderConfirm);

	if (connect_provider_confirm->user_data_length != 0)
	{
		/*
		**	If the result is success create the packet to be decoded from
		**	the PDU passed back in the MCS user data field. If creation
		**	failes this again is a FATAL error and the conference must be
		**	terminated.
		*/
		DBG_SAVE_FILE_LINE
		packet = new Packet((PPacketCoder) g_GCCCoder,
							PACKED_ENCODING_RULES,
							connect_provider_confirm->user_data,
							connect_provider_confirm->user_data_length,
							CONNECT_GCC_PDU,
							TRUE,
							&packet_error);
		if ((packet != NULL) && (packet_error == PACKET_NO_ERROR))
		{
			connect_pdu = (PConnectGCCPDU)packet->GetDecodedData();			
			/*
			**	If all the above succeeds then decode the packet based on
			**	which node type this is.
			*/
			switch (connect_pdu->choice)
			{
				case CONFERENCE_CREATE_RESPONSE_CHOSEN:
						ProcessConferenceCreateResponsePDU (
									&connect_pdu->u.conference_create_response,
									connect_provider_confirm);
						break;

				case CONNECT_JOIN_RESPONSE_CHOSEN:
						ProcessConferenceJoinResponsePDU (
									&connect_pdu->u.connect_join_response,
									connect_provider_confirm);
						break;

				case CONFERENCE_INVITE_RESPONSE_CHOSEN:
						ProcessConferenceInviteResponsePDU (
									&connect_pdu->u.conference_invite_response,
									connect_provider_confirm );
						break;
						
				default:
						ERROR_OUT(("CConf:ProcessConnectProviderConfirm: "
							"Error: Received Invalid Connect Provider Confirm"));
						break;
			}

			//	Free the decoded packet
			packet->Unlock ();
		}
		else
		{
			ERROR_OUT(("CConf: ProcessConnectProviderConfirm:"
				"Incompatible protocol occured"));
			result = GCC_RESULT_INCOMPATIBLE_PROTOCOL;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ProcessConnectProviderConfirm: result=%d", (UINT) connect_provider_confirm->result));

		/*
		**	This section of the code assumes that there is no connect PDU in
		**	the returned packet.  First determine what the result is.  We
		**	assume that if the MCS connection was rejected due to
		**	parameters being unacceptable and no GCC pdu was returned that there
		**	was a protocol incompatibility.
		*/
		if (connect_provider_confirm->result == RESULT_PARAMETERS_UNACCEPTABLE)
			result = GCC_RESULT_INCOMPATIBLE_PROTOCOL;
		else
		{
			result = ::TranslateMCSResultToGCCResult(connect_provider_confirm->result);
		}
	}

	//	Handle any errors that might have occured.	
	if (result != GCC_RESULT_SUCCESSFUL)
	{	
		INVITE_REQ_INFO *lpInvReqInfo;

		//	First check to see if there are any outstanding invite request
		m_InviteRequestList.Reset();
		invite_request_info = NULL;
		while (NULL != (lpInvReqInfo = m_InviteRequestList.Iterate()))
		{
			if (connect_provider_confirm->connection_handle == lpInvReqInfo->connection_handle)
			{
				TRACE_OUT(("CConf: ProcessConnectProviderConfirm: Found Invite Request Match"));
				invite_request_info = lpInvReqInfo;
				break;
			}
				
		}

		if (invite_request_info != NULL)
		{
			//	This must be the confirm of an invite
			ProcessConferenceInviteResponsePDU (NULL, connect_provider_confirm);
		}
		else
		{
			switch (m_eNodeType)
			{
				case CONVENER_NODE:		
				case TOP_PROVIDER_AND_CONVENER_NODE:
	               	GetConferenceNameAndModifier (	&conference_name,
	                                                &conference_modifier);

					g_pControlSap->ConfCreateConfirm(
            								&conference_name,
            								conference_modifier,
            								m_nConfID,
            								m_pDomainParameters,
                               				NULL,
            								result,
            								connect_provider_confirm->connection_handle);

	 				InitiateTermination (  	GCC_REASON_ERROR_TERMINATION,
	 										0);
					break;

				case JOINED_NODE:
				case JOINED_CONVENER_NODE:
					TRACE_OUT(("CConf::ProcessConnectProviderConfirm:"
								"Joined Node connect provider failed"));
	               	GetConferenceNameAndModifier (	&conference_name,
	                                                &conference_modifier);
				
					if (m_pszRemoteModifier != NULL)
					{
						remote_modifier = (GCCNumericString) m_pszRemoteModifier;
					}
				
					TRACE_OUT(("CConf::ProcessConnectProviderConfirm: Before conference Join Confirm"));
					g_pControlSap->ConfJoinConfirm(
        								&conference_name,
        								remote_modifier,
        								conference_modifier,
        								m_nConfID,
        								NULL,
        								m_pDomainParameters,
        								m_fClearPassword,
        								m_fConfLocked,
        								m_fConfListed,
        								m_fConfConductible,
        								m_eTerminationMethod,
        								m_pConductorPrivilegeList,
        								m_pConductModePrivilegeList,
        								m_pNonConductModePrivilegeList,
        								NULL,
        								NULL,
        								result,
        								connect_provider_confirm->connection_handle,
        								NULL,
        								0);

					TRACE_OUT(("CConf::ProcessConnectProviderConfirm: After conference Join Confirm"));

					InitiateTermination(GCC_REASON_ERROR_TERMINATION, 0);
					break;
		 				
				default:
					TRACE_OUT(("CConf: ProcessConnectProviderConfirm:"
								"Assertion Failure: Bad confirm received"));
					break;
			}
		}
	}

	DebugExitVOID(CConf::ProcessConnectProviderConfirm);
}



/*
 *	void ProcessConferenceCreateResponsePDU ()
 *
 *	Private Function Description
 *		This routine processes a Conference Create Response PDU that is
 *		delivered as part of a Connect Provider Confirm.
 *
 *	Formal Parameters:
 *		create_response				-	This is the Conference Create response
 *										PDU.
 *		connect_provider_confirm	-	This structure contains the MCS related
 *										data such as sender id and connection
 *										Handle as well as the PDU data.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceCreateResponsePDU
(
	PConferenceCreateResponse	create_response,
	PConnectProviderConfirm		connect_provider_confirm
)
{
	GCCError						err = GCC_NO_ERROR;
	GCCResult						result;
	UserID							top_gcc_node_id;
	UserID							parent_user_id;
	GCCConferenceName				conference_name;
	GCCNumericString				conference_modifier;

	DebugEntry(CConf::ProcessConnectProviderConfirm);

	//	Translate the result back to GCC Result
	result = ::TranslateCreateResultToGCCResult(create_response->result);

	if ((result == GCC_RESULT_SUCCESSFUL) &&
		(connect_provider_confirm->result == RESULT_SUCCESSFUL))
	{
		/*
		**	Save the domain parameters.  The domain parameters returned in
		**	the connect provider confirm should always be up to date.
		*/
		if (m_pDomainParameters == NULL)
		{
			DBG_SAVE_FILE_LINE
			m_pDomainParameters = new DomainParameters;
		}

		if (m_pDomainParameters != NULL)
			*m_pDomainParameters = connect_provider_confirm->domain_parameters;
		else
			err = GCC_ALLOCATION_FAILURE;
	
		//	Get any user data that might exists	
		if ((create_response->bit_mask & CCRS_USER_DATA_PRESENT) &&
			(err == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			m_pUserDataList = new CUserDataListContainer(create_response->ccrs_user_data, &err);
			if (m_pUserDataList == NULL)
				err = GCC_ALLOCATION_FAILURE;
		}

		if (err == GCC_NO_ERROR)
		{		
			m_nParentIDTagNumber = create_response->tag;

			top_gcc_node_id = create_response->node_id;
			parent_user_id = top_gcc_node_id;
	
			//	Create the user attachment object.
			DBG_SAVE_FILE_LINE
			m_pMcsUserObject = new MCSUser(this, top_gcc_node_id, parent_user_id, &err);
			if (m_pMcsUserObject == NULL || GCC_NO_ERROR != err)
            {
                if (NULL != m_pMcsUserObject)
                {
                    m_pMcsUserObject->Release();
		            m_pMcsUserObject = NULL;
                }
                else
                {
		            err = GCC_ALLOCATION_FAILURE;
                }
            }
		}
	}
	else
	{
		TRACE_OUT(("CConf: ProcessConnectProviderConfirm: conference create result was Failure"));

		//	Go ahead and translate the mcs error to a gcc error if one occured.
		if ((result == GCC_RESULT_SUCCESSFUL) &&
			(connect_provider_confirm->result != RESULT_SUCCESSFUL))
		{
			result = ::TranslateMCSResultToGCCResult(connect_provider_confirm->result);
		}
  	
		//	Get the conference name to pass back in the create confirm
  		GetConferenceNameAndModifier (	&conference_name,
                                		&conference_modifier);

		g_pControlSap->ConfCreateConfirm(
								&conference_name,
								conference_modifier,
								m_nConfID,
								m_pDomainParameters,
                   				NULL,
								result,
								connect_provider_confirm->connection_handle);

		//	Terminate the conference
		InitiateTermination (  	GCC_REASON_NORMAL_TERMINATION,
								0);
	}
	
	
	if (err != GCC_NO_ERROR)
	{				
	 	InitiateTermination (	GCC_REASON_ERROR_LOW_RESOURCES,
								0);
	}

	DebugExitVOID(CConf::ProcessConnectProviderConfirm);
}



/*
 *	void	ProcessConferenceJoinResponsePDU ()
 *
 *	Private Function Description
 *		This routine processes a Conference Join Response PDU that is
 *		delivered as part of a Connect Provider Confirm.
 *
 *	Formal Parameters:
 *		join_response				-	This is the Conference Join response
 *										PDU.
 *		connect_provider_confirm	-	This structure contains the MCS related
 *										data such as sender id and connection
 *										Handle as well as the PDU data.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceJoinResponsePDU
(
	PConferenceJoinResponse		join_response,
	PConnectProviderConfirm		connect_provider_confirm
)
{
	GCCError						err = GCC_NO_ERROR;
	GCCResult						result;
	UserID							top_gcc_node_id;
	UserID							parent_user_id;
	CPassword                       *password_challenge = NULL;
	CUserDataListContainer		    *user_data_list = NULL;
	GCCConferenceName				conference_name;
	GCCNumericString				local_modifier;
	GCCNumericString				remote_modifier = NULL;

	DebugEntry(CConf::ProcessConferenceJoinResponsePDU);

	//	Translate the result back to GCC Result
	result = ::TranslateJoinResultToGCCResult (join_response->result);
	
	if ((result == GCC_RESULT_SUCCESSFUL) &&
		(connect_provider_confirm->result == RESULT_SUCCESSFUL))
	{
		/*
		**	Save the domain parameters.  The domain parameters returned in
		**	the connect provider confirm should always be up to date.
		*/
		if (m_pDomainParameters == NULL)
		{
			DBG_SAVE_FILE_LINE
			m_pDomainParameters = new DomainParameters;
		}

		if (m_pDomainParameters != NULL)
			*m_pDomainParameters = connect_provider_confirm->domain_parameters;
		else
			err = GCC_ALLOCATION_FAILURE;
		
		//	Get the conference name alias if one exists	
		if ((join_response->bit_mask & CONFERENCE_NAME_ALIAS_PRESENT) &&
			(err == GCC_NO_ERROR))
		{
			if (join_response->conference_name_alias.choice ==
												NAME_SELECTOR_NUMERIC_CHOSEN)
			{
                delete m_pszConfNumericName;
				if (NULL == (m_pszConfNumericName = ::My_strdupA(
								join_response->conference_name_alias.u.name_selector_numeric)))
				{
					err = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
                delete m_pwszConfTextName;
				if (NULL == (m_pwszConfTextName = ::My_strdupW2(
								join_response->conference_name_alias.u.name_selector_text.length,
								join_response->conference_name_alias.u.name_selector_text.value)))
				{
					err = GCC_ALLOCATION_FAILURE;
				}
			}
		}
		
		//	Get the conductor privilege list if one exists	
		if ((join_response->bit_mask & CJRS_CONDUCTOR_PRIVS_PRESENT) &&
			(err == GCC_NO_ERROR))
		{
		    delete m_pConductorPrivilegeList;
			DBG_SAVE_FILE_LINE
			m_pConductorPrivilegeList = new PrivilegeListData(join_response->cjrs_conductor_privs);
			if (m_pConductorPrivilegeList == NULL)
				err = GCC_ALLOCATION_FAILURE;
		}
		
		//	Get the conducted mode privilege list if one exists	
		if ((join_response->bit_mask & CJRS_CONDUCTED_PRIVS_PRESENT) &&
			(err == GCC_NO_ERROR))
		{
		    delete m_pConductModePrivilegeList;
			DBG_SAVE_FILE_LINE
			m_pConductModePrivilegeList = new PrivilegeListData(join_response->cjrs_conducted_privs);
			if (m_pConductModePrivilegeList == NULL)
				err = GCC_ALLOCATION_FAILURE;
		}
		
		//	Get the non-conducted mode privilege list if one exists	
		if ((join_response->bit_mask & CJRS_NON_CONDUCTED_PRIVS_PRESENT) &&
			(err == GCC_NO_ERROR))
		{
		    delete m_pNonConductModePrivilegeList;
			DBG_SAVE_FILE_LINE
			m_pNonConductModePrivilegeList = new PrivilegeListData(join_response->cjrs_non_conducted_privs);
			if (m_pNonConductModePrivilegeList == NULL)
				err = GCC_ALLOCATION_FAILURE;
		}

		//	Get the conference description if it exists
		if ((join_response->bit_mask & CJRS_DESCRIPTION_PRESENT) &&
			(err == GCC_NO_ERROR))
		{
		    delete m_pwszConfDescription;
			if (NULL == (m_pwszConfDescription = ::My_strdupW2(
									join_response->cjrs_description.length,
									join_response->cjrs_description.value)))
			{
				err = GCC_ALLOCATION_FAILURE;
			}
		}

		//	Get the user data if it exists
		if ((join_response->bit_mask & CJRS_USER_DATA_PRESENT)	&&
			(err == GCC_NO_ERROR))
		{
            if (NULL != m_pUserDataList)
            {
                m_pUserDataList->Release();
            }
			DBG_SAVE_FILE_LINE
			m_pUserDataList = new CUserDataListContainer(join_response->cjrs_user_data, &err);
            // in case of err but valid m_pUserDataList, the destructor will clean it up.
			if (m_pUserDataList == NULL)
            {
				err = GCC_ALLOCATION_FAILURE;
            }
		}
			
		if (err == GCC_NO_ERROR)
		{
			parent_user_id = (join_response->bit_mask & CJRS_NODE_ID_PRESENT) ?
                                (UserID) join_response->cjrs_node_id :
		                        (UserID) join_response->top_node_id;
				
			m_nParentIDTagNumber = join_response->tag;
			top_gcc_node_id = (UserID)join_response->top_node_id;
			m_fClearPassword = join_response->clear_password_required;
			m_fConfLocked = join_response->conference_is_locked;
			m_fConfListed = join_response->conference_is_listed;
			m_eTerminationMethod = (GCCTerminationMethod)join_response->termination_method;
			m_fConfConductible = join_response->conference_is_conductible;

			//	Create the user attachment object.
			ASSERT(NULL == m_pMcsUserObject);
			DBG_SAVE_FILE_LINE
			m_pMcsUserObject = new MCSUser(this, top_gcc_node_id, parent_user_id, &err);
            // in case of err but valid m_pMcsUserObject, the destructor will clean it up.
			if (m_pMcsUserObject == NULL)
            {
                err = GCC_ALLOCATION_FAILURE;
            }
		}
	}
	else
	{
		if ((join_response->bit_mask & CJRS_PASSWORD_PRESENT) &&
			(err == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			password_challenge = new CPassword(&join_response->cjrs_password, &err);
			if (password_challenge == NULL)
            {
				err = GCC_ALLOCATION_FAILURE;
            }
		}
	
		//	Get the user data if it exists
		if ((join_response->bit_mask & CJRS_USER_DATA_PRESENT)	&&
			(err == GCC_NO_ERROR))
		{
			DBG_SAVE_FILE_LINE
			user_data_list = new CUserDataListContainer(join_response->cjrs_user_data, &err);
			if (user_data_list == NULL)
            {
				err = GCC_ALLOCATION_FAILURE;
            }
		}
		
		if (err == GCC_NO_ERROR)
		{
			/*
			**	Go ahead and translate the mcs error to a gcc error if
			**	one occured.
			*/
			if ((result == GCC_RESULT_SUCCESSFUL) &&
				(connect_provider_confirm->result != RESULT_SUCCESSFUL))
			{
				result = ::TranslateMCSResultToGCCResult(connect_provider_confirm->result);
			}
			
			//	Fill in the conference name data pointers.
        	GetConferenceNameAndModifier(&conference_name, &local_modifier);

			if (m_pszRemoteModifier != NULL)
			{
				remote_modifier = (GCCNumericString) m_pszRemoteModifier;
			}

			//
			// LONCHANC: To get rid of the conference object
			// in GCC Controller's active conference list.
			// The conference object will then be moved to
			// the deletion list.
			//
			InitiateTermination ( GCC_REASON_NORMAL_TERMINATION, 0);

			g_pControlSap->ConfJoinConfirm(
									&conference_name,
									remote_modifier,
									local_modifier,
									m_nConfID,
									password_challenge,
									m_pDomainParameters,
									m_fClearPassword,
									m_fConfLocked,
									m_fConfListed,
									m_fConfConductible,
									m_eTerminationMethod,
									m_pConductorPrivilegeList,
									m_pConductModePrivilegeList,
									m_pNonConductModePrivilegeList,
									NULL,
									user_data_list,
									result,
									connect_provider_confirm->connection_handle,
									connect_provider_confirm->pb_cred,
									connect_provider_confirm->cb_cred);
		}

		if (password_challenge != NULL)
		{
			password_challenge->Release();
		}

		if (user_data_list != NULL)
		{
			user_data_list->Release();
		}
	}

	if (err != GCC_NO_ERROR)
	{
		InitiateTermination (GCC_REASON_ERROR_LOW_RESOURCES, 0);
	}

	DebugExitVOID(CConf::ProcessConferenceJoinResponsePDU);
}


/*
 *	void	ProcessConferenceInviteResponsePDU ()
 *
 *	Private Function Description
 *		This routine processes a Conference Invite Response PDU that is
 *		delivered as part of a Connect Provider Confirm.
 *
 *	Formal Parameters:
 *		invite_response				-	This is the Conference Invite response
 *										PDU.
 *		connect_provider_confirm	-	This structure contains the MCS related
 *										data such as sender id and connection
 *										Handle as well as the PDU data.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceInviteResponsePDU
(
	PConferenceInviteResponse	invite_response,
	PConnectProviderConfirm		connect_provider_confirm
)
{
	GCCError					err;
	GCCResult					result;
	CUserDataListContainer	    *user_data_list = NULL;
	INVITE_REQ_INFO             *invite_request_info = NULL;
	INVITE_REQ_INFO             *lpInvReqInfo;

	DebugEntry(CConf::ProcessConferenceInviteResponsePDU);

	//	First obtain the info request info structure.
	m_InviteRequestList.Reset();
	while (NULL != (lpInvReqInfo = m_InviteRequestList.Iterate()))
	{
		if (connect_provider_confirm->connection_handle == lpInvReqInfo->connection_handle)
		{
			invite_request_info = lpInvReqInfo;
			break;
		}
	}

	if (invite_request_info == NULL)
		return;

	if (invite_response != NULL)
	{
		//	Get the user data list if one exists
		if (invite_response->bit_mask & CIRS_USER_DATA_PRESENT)
		{
			DBG_SAVE_FILE_LINE
			user_data_list = new CUserDataListContainer(invite_response->cirs_user_data, &err);
		}

		//	Translate the result to GCCResult
		result = ::TranslateInviteResultToGCCResult(invite_response->result);
	}
	else
	{
		result = (connect_provider_confirm->result == RESULT_USER_REJECTED) ?
                    GCC_RESULT_INCOMPATIBLE_PROTOCOL :
			        ::TranslateMCSResultToGCCResult(connect_provider_confirm->result);
	}
		
	if ((result == GCC_RESULT_SUCCESSFUL) &&
		(connect_provider_confirm->result == RESULT_SUCCESSFUL))
	{
		TRACE_OUT(("CConf::ProcessConferenceInviteResponsePDU:"
						"Received Connect Provider confirm on Invite"));
						
		/*
		**	Save the domain parameters.  The domain parameters returned in
		**	the connect provider confirm should always be up to date.
		*/
		if (m_pDomainParameters == NULL)
		{
			DBG_SAVE_FILE_LINE
			m_pDomainParameters = new DomainParameters;
		}

		if (m_pDomainParameters != NULL)
			*m_pDomainParameters = connect_provider_confirm->domain_parameters;
		else
			err = GCC_ALLOCATION_FAILURE;

		//	Save the user data list for the invite confirm
		invite_request_info->user_data_list = user_data_list;

		//	Wait for user ID from invited node before sending invite confirm.
	}
	else
	{
		/*
		**	Go ahead and translate the mcs error to a gcc error if
		**	one occured.
		*/
		if ((result == GCC_RESULT_SUCCESSFUL) &&
			(connect_provider_confirm->result != RESULT_SUCCESSFUL))
		{
			result = ::TranslateMCSResultToGCCResult(connect_provider_confirm->result);
		}

		//	Cleanup the connection handle list
        ASSERT(0 != connect_provider_confirm->connection_handle);
		m_ConnHandleList.Remove(connect_provider_confirm->connection_handle);

        // In case of error, the node controller will delete this conference.
        // AddRef here to protect itself from going away.
        AddRef();

		g_pControlSap->ConfInviteConfirm(
								m_nConfID,
								user_data_list,
								result,
								connect_provider_confirm->connection_handle);

		//	Free up the user data
		if (user_data_list != NULL)
		{
			user_data_list->Release();
		}

        // The reason that we check this is because in some cases, in the call to
        // g_pControlSap->ConfInviteConfirm, someone was calling DeleteOutstandingInviteRequests
        // which was killing the list via a call to m_InviteRequestList.Clear...
        // This happens when the calee refuses to accept the call
        if(m_InviteRequestList.Remove(invite_request_info))
        {
			//	Free up the invite request info structure
			delete invite_request_info;
        }

        // To match AddRef above.
        Release();
	}

	DebugExitVOID(CConf::ProcessConferenceInviteResponsePDU);
}


/*
 *	CConf::ProcessEjectUserIndication ()
 *
 *	Private Function Description
 *		This routine processes an Eject User Indication.
 *
 *	Formal Parameters:
 *		reason				-	Reason that this node is being ejected.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessEjectUserIndication ( GCCReason reason )
{
    DebugEntry(CConf::ProcessEjectUserIndication);

    if (m_fConfIsEstablished)
    {
        /*
        **	First inform the control SAP that this node has been ejected from this
        **	particular conference.
        */
        g_pControlSap->ConfEjectUserIndication(
                                    m_nConfID,
                                    reason,
                                    m_pMcsUserObject->GetMyNodeID());

        /*
        **	Next we set conference established to FALSE since the conference is
        **	no longer established (this also prevents a terminate indication from
        **	being sent).
        */
        m_fConfIsEstablished = FALSE;

        InitiateTermination(reason, m_pMcsUserObject->GetMyNodeID());
    }

    DebugExitVOID(CConf::ProcessEjectUserIndication);
}


/*
 *	CConf::ProcessEjectUserRequest ()
 *
 *	Private Function Description
 *		This routine processes an eject user request PDU.  This routine should
 *		only be called from the Top Provider.
 *
 *	Formal Parameters:
 *		eject_node_request	-	This is the PDU data associated with the
 *								eject user request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessEjectUserRequest ( PUserEjectNodeRequestInfo eject_node_request )
{
	GCCResult	result;

	DebugEntry(CConf::ProcessEjectUserRequest);

	//	Check to make sure that the requesting node has the proper privileges
	if (DoesRequesterHavePrivilege(	eject_node_request->requester_id,
									EJECT_USER_PRIVILEGE))
	{
		/*
		**	The user attachment object decides where the eject should
		**	be sent (either to the Top Provider or conference wide as
		**	an indication.
		*/
		m_pMcsUserObject->EjectNodeFromConference (
											eject_node_request->node_to_eject,
											eject_node_request->reason);
											
		result = GCC_RESULT_SUCCESSFUL;
	}
	else
		result = GCC_RESULT_INVALID_REQUESTER;
	
	m_pMcsUserObject->SendEjectNodeResponse (eject_node_request->requester_id,
											eject_node_request->node_to_eject,
											result);

	DebugExitVOID(CConf::ProcessEjectUserRequest);
}


/*
 *	CConf::ProcessEjectUserResponse ()
 *
 *	Private Function Description
 *		This routine processes an eject user response PDU.  This routine is
 *		called in response to an eject user request.
 *
 *	Formal Parameters:
 *		eject_node_response	-	This is the PDU data associated with the
 *								eject user response.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessEjectUserResponse ( PUserEjectNodeResponseInfo eject_node_response )
{
	DebugEntry(CConf::ProcessEjectUserResponse);

	if (m_EjectedNodeConfirmList.Remove(eject_node_response->node_to_eject))
	{
#ifdef JASPER
		g_pControlSap->ConfEjectUserConfirm(
									m_nConfID,
									eject_node_response->node_to_eject,
									eject_node_response->result);
#endif // JASPER
	}
	else
	{
		ERROR_OUT(("CConf::ProcessEjectUserResponse: Assertion: Bad ejected node response received"));
	}

	DebugExitVOID(CConf::ProcessEjectUserResponse);
}


/*
 *	CConf::ProcessConferenceLockRequest()
 *
 *	Private Function Description
 *		This routine processes a conference lock request PDU.
 *
 *	Formal Parameters:
 *		requester_id	-	Node ID of node making the lock request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceLockRequest ( UserID	requester_id )
{
	DebugEntry(CConf::ProcessConferenceLockRequest);

	if (DoesRequesterHavePrivilege (requester_id,
									LOCK_UNLOCK_PRIVILEGE))
	{
		g_pControlSap->ConfLockIndication(m_nConfID, requester_id);
	}
	else
	{
		if (requester_id == m_pMcsUserObject->GetTopNodeID())
		{
#ifdef JASPER
			g_pControlSap->ConfLockConfirm(GCC_RESULT_INVALID_REQUESTER, m_nConfID);
#endif // JASPER
		}
		else
		{
			m_pMcsUserObject->SendConferenceLockResponse(
									requester_id,
									GCC_RESULT_INVALID_REQUESTER);
		}
	}

	DebugExitVOID(CConf::ProcessConferenceLockRequest);
}

/*
 * CConf::ProcessConferenceUnlockRequest()
 *
 * Private Function Description
 *		This routine processes a conference unlock request PDU.
 *
 *	Formal Parameters:
 *		requester_id	-	Node ID of node making the unlock request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceUnlockRequest ( UserID requester_id )
{
	DebugEntry(CConf::ProcessConferenceUnlockRequest);

	if (DoesRequesterHavePrivilege (requester_id,
									LOCK_UNLOCK_PRIVILEGE))
	{
#ifdef JASPER
		g_pControlSap->ConfUnlockIndication(m_nConfID, requester_id);
#endif // JASPER
	}
	else
	{
		if (requester_id == m_pMcsUserObject->GetTopNodeID())
		{
#ifdef JASPER
			g_pControlSap->ConfUnlockConfirm(GCC_RESULT_INVALID_REQUESTER, m_nConfID);
#endif // JASPER
		}
		else
		{
			m_pMcsUserObject->SendConferenceUnlockResponse(
									requester_id,
									GCC_RESULT_INVALID_REQUESTER);
		}
	}

	DebugExitVOID(CConf::ProcessConferenceUnlockRequest);
}


/*
 *	CConf::ProcessConferenceLockIndication()
 *
 *	Private Function Description
 *		This routine processes a conference lock indication PDU.
 *
 *	Formal Parameters:
 *		source_id	-	Node ID which sent out the lock indication.  Should
 *						only be sent by the top provider.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceLockIndication ( UserID source_id )
{
	DebugEntry(CConf::ProcessConferenceLockIndication);

	if (source_id == m_pMcsUserObject->GetTopNodeID())
	{
		 m_fConfLocked = CONFERENCE_IS_LOCKED;
#ifdef JASPER
		 g_pControlSap->ConfLockReport(m_nConfID, m_fConfLocked);
#endif // JASPER
	}

	DebugExitVOID(CConf::ProcessConferenceLockIndication);
}


/*
 *	CConf::ProcessConferenceUnlockIndication()
 *
 *	Private Function Description
 *		This routine processes a conference unlock indication PDU.
 *
 *	Formal Parameters:
 *		source_id	-	Node ID which sent out the unlock indication.  Should
 *						only be sent by the top provider.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceUnlockIndication ( UserID source_id )
{
	DebugEntry(CConf::ProcessConferenceUnlockIndication);

	if (source_id == m_pMcsUserObject->GetTopNodeID())
	{
		 m_fConfLocked = CONFERENCE_IS_NOT_LOCKED;
#ifdef JASPER
		 g_pControlSap->ConfLockReport(m_nConfID, m_fConfLocked);
#endif // JASPER
	}

	DebugExitVOID(CConf::ProcessConferenceUnlockIndication);
}



/*
 *	void 	ProcessConferenceTransferRequest ()
 *
 *	Public Function Description
 *		This routine processes a conference transfer request PDU.
 *
 *	Formal Parameters:
 *		requesting_node_id				-	Node ID that made the transfer
 *											request.
 *		destination_conference_name		-	The name of the conference to
 *											transfer to.
 *		destination_conference_modifier	-	The name of the conference modifier
 *											to transfer to.
 *		destination_address_list		-	Network address list of the
 *											conference to transfer to.
 *		number_of_destination_nodes		-	The number of nodes in the list of
 *											nodes that should perform the
 *											transfer.
 *		destination_node_list			-	The list of nodes that should
 *											perform the transfer.
 *		password						-	The password needed to join the
 *											new conference.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceTransferRequest
(
	UserID				    requesting_node_id,
	PGCCConferenceName	    destination_conference_name,
	GCCNumericString	    destination_conference_modifier,
	CNetAddrListContainer   *destination_address_list,
	UINT				    number_of_destination_nodes,
	PUserID				    destination_node_list,
	CPassword               *password
)
{
	GCCResult	result;
	
	DebugEntry(CConf::ProcessConferenceTransferRequest);

	if (DoesRequesterHavePrivilege(	requesting_node_id,
									TRANSFER_PRIVILEGE))
	{
		result = GCC_RESULT_SUCCESSFUL;
	}
	else
		result = GCC_RESULT_INVALID_REQUESTER;
	
	m_pMcsUserObject->ConferenceTransferResponse (
										requesting_node_id,
										destination_conference_name,
										destination_conference_modifier,
										number_of_destination_nodes,
			 							destination_node_list,
			 							result);
		
	if (result == GCC_RESULT_SUCCESSFUL)
	{
		m_pMcsUserObject->ConferenceTransferIndication (
											destination_conference_name,
											destination_conference_modifier,
											destination_address_list,
											number_of_destination_nodes,
				 							destination_node_list,
											password);
	}

	DebugExitVOID(CConf::ProcessConferenceTransferRequest);
}


/*
 *	CConf::ProcessConferenceAddRequest ()
 *
 *	Private Function Description
 *		This routine processes a conference add request PDU.
 *
 *	Formal Parameters:
 *		requesting_node_id				-	Node ID that made the transfer
 *											request.
 *		destination_conference_name		-	The name of the conference to
 *											transfer to.
 *		destination_conference_modifier	-	The name of the conference modifier
 *											to transfer to.
 *		destination_address_list		-	Network address list of the
 *											conference to transfer to.
 *		number_of_destination_nodes		-	The number of nodes in the list of
 *											nodes that should perform the
 *											transfer.
 *		destination_node_list			-	The list of nodes that should
 *											perform the transfer.
 *		password						-	The password needed to join the
 *											new conference.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConferenceAddRequest
(
	CNetAddrListContainer   *network_address_list,
	CUserDataListContainer  *user_data_list,
	UserID					adding_node,
	TagNumber				add_request_tag,
	UserID					requesting_node
)
{
	BOOL			generate_add_indication = FALSE;
	GCCResponseTag	add_response_tag;

	DebugEntry(CConf::ProcessConferenceAddRequest);

	if (m_pMcsUserObject->GetMyNodeID() == m_pMcsUserObject->GetTopNodeID())
	{
		if (DoesRequesterHavePrivilege(requesting_node, ADD_PRIVILEGE))
		{
			if ((m_pMcsUserObject->GetMyNodeID() == adding_node) ||
				(adding_node == 0))
			{
				generate_add_indication = TRUE;
			}
			else
			{
				/*
				**	Here we send the add request on to the MCU that is
				**	supposed to do the adding.
				*/
				m_pMcsUserObject->ConferenceAddRequest(
												add_request_tag,
												requesting_node,
												adding_node,
												adding_node,
												network_address_list,
												user_data_list);
			}
		}
		else
		{
			//	Send back negative response stating inproper privileges
			m_pMcsUserObject->ConferenceAddResponse(
												add_request_tag,
                                    requesting_node,
												NULL,
												GCC_RESULT_INVALID_REQUESTER);
		}
			
	}
	else if (m_pMcsUserObject->GetMyNodeID() == adding_node)
	{
		/*
		**	This is the node that is supposed to get the add indication
		**	so send it on.
		*/
		generate_add_indication = TRUE;
	}
	
	if (generate_add_indication)
	{
		//	First set up the Add Response Tag
		while (1)
		{
			add_response_tag = m_nConfAddResponseTag++;
			
			if (0 == m_AddResponseList.Find(add_response_tag))
				break;
		}
		
		m_AddResponseList.Append(add_response_tag, add_request_tag);
		
		g_pControlSap->ConfAddIndication(m_nConfID,
										add_response_tag,
										network_address_list,
										user_data_list,
										requesting_node);
	}

	DebugExitVOID(CConf::ProcessConferenceAddRequest);
}


/***************Conductorship Callbacks from User object*******************/


/*
 *	void ProcessConductorGrabConfirm ()
 *
 *	Private Function Description
 *		The routine processes a conductor grab confirm received from the
 *		MCSUser object.
 *
 *	Formal Parameters:
 *		result			-	This is the result from the grab request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConductorGrabConfirm ( GCCResult result )
{
	DebugEntry(CConf::ProcessConductorGrabConfirm);

	TRACE_OUT(("CConf::ProcessConductorGrabConfirm: result = %d", result));

	if ((m_eNodeType == TOP_PROVIDER_NODE) ||
		(m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE))
	{
#ifdef JASPER
		//	Inform the control SAP of the result
		g_pControlSap->ConductorAssignConfirm (	result,
												m_nConfID);
#endif // JASPER

		/*
		**	If we were successful, we must send a Conductor Assign Indication
		**	PDU to every node in the conference to inform them that the
		**	conductor has changed.
		*/
		if (result == GCC_RESULT_SUCCESSFUL)
		{
			/*
			**	We use NULL for the conductor ID because the conductor can be
			**	determined from the sender of the Assign Indication PDU.
			*/
			m_pMcsUserObject->SendConductorAssignIndication(
											m_pMcsUserObject->GetTopNodeID());
			m_nConductorNodeID = m_pMcsUserObject->GetMyNodeID();
			m_fConductorGrantedPermission = TRUE;
		}

		//	Reset the Assign Request Pending flag back to FALSE.
		m_fConductorAssignRequestPending = FALSE;
	}
	else
	{
		if (result == GCC_RESULT_SUCCESSFUL)
		{
			/*
			**	If this node is not the Top Provider, we must try to Give the
			**	Conductor token to the Top Provider. The Top Provider is used to
			**	monitor the use of the conductor token.  I the give to the Top
			**	Provider is unsuccessful then this node is the new conductor.
			*/
			m_pMcsUserObject->ConductorTokenGive(m_pMcsUserObject->GetTopNodeID());
		}
		else
		{
#ifdef JASPER
			//	Inform the control SAP of the result
			g_pControlSap->ConductorAssignConfirm(result, m_nConfID);
#endif // JASPER
		}
	}

	DebugExitVOID(CConf::ProcessConductorGrabConfirm);
}


/*
 *	void ProcessConductorAssignIndication ()
 *
 *	Private Function Description
 *		This routine processes a conductor assign indication received from
 *		the MCSUser object.
 *
 *	Formal Parameters:
 *		new_conductor_id	-	This is the node id of the new conductor.
 *		sender_id			-	Node ID of node that sent the indication.
 *								Should be the Top Provider.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConductorAssignIndication
(
    UserID          new_conductor_id,
    UserID          sender_id
)
{
	DebugEntry(CConf::ProcessConductorAssignIndication);

	if (sender_id == m_pMcsUserObject->GetTopNodeID())
	{
		TRACE_OUT(("CConf: ConductAssignInd: Received from top provider"));

		//	Ignore this indication if the conference is not conductible
		if (m_fConfConductible)
		{
			//	Save UserID of the new conductor if not the Top Provider
			if (sender_id != m_pMcsUserObject->GetMyNodeID())
			{
				m_nConductorNodeID = new_conductor_id;
			}

			/*
			**	Inform the control SAP and all the enrolled application SAPs
			**	that there is a new conductor.
			*/
			TRACE_OUT(("CConf: ConductAssignInd: Send to Control SAP"));
			g_pControlSap->ConductorAssignIndication(m_nConductorNodeID, m_nConfID);

			/*
			**	We iterate on a temporary list to avoid any problems
			**	if the application sap leaves during the callback.
			*/
			CAppSap     *pAppSap;
			CAppSapList TempList(m_RegisteredAppSapList);
			TempList.Reset();
			while (NULL != (pAppSap = TempList.Iterate()))
			{
				if (DoesSAPHaveEnrolledAPE(pAppSap))
				{
					pAppSap->ConductorAssignIndication(m_nConductorNodeID, m_nConfID);
				}
			}
		}
		else
		{
			ERROR_OUT(("CConf:ProcessConductorAssignInd: Conductor Assign sent in non-conductible conference"));
		}
	}
	else
	{
		ERROR_OUT(("CConf:ProcessConductorAssignInd: Conductor Assign sent from NON-Top Provider"));
	}

	DebugExitVOID(CConf::ProcessConductorAssignIndication);
}


/*
 *	void ProcessConductorReleaseIndication ()
 *
 *	Private Function Description
 *		This routine processes a conductor release indication received from
 *		the MCSUser object.
 *
 *	Formal Parameters:
 *		sender_id			-	Node ID of node that sent the indication.
 *								Should be the Top Provider or the conductor.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConductorReleaseIndication ( UserID sender_id )
{
	DebugEntry(CConf::ProcessConductorReleaseIndication);

	if ((sender_id == m_pMcsUserObject->GetTopNodeID()) ||
		(sender_id == m_nConductorNodeID) ||
		(sender_id == 0))
	{
		//	Ignore this indication if the conference is not conductible
		if (m_fConfConductible)
		{
			m_fConductorGrantedPermission = FALSE;

			//	Reset to Non-Conducted mode
			m_nConductorNodeID = 0;

			/*
			**	Inform the control SAP and all the enrolled application SAPs
			**	that the  conductor was released.
			*/
			g_pControlSap->ConductorReleaseIndication( m_nConfID );

			/*
			**	We iterate on a temporary list to avoid any problems
			**	if the application sap leaves during the callback.
			*/
			CAppSap     *pAppSap;
			CAppSapList TempList(m_RegisteredAppSapList);
			TempList.Reset();
			while (NULL != (pAppSap = TempList.Iterate()))
			{
				if (DoesSAPHaveEnrolledAPE(pAppSap))
				{
					pAppSap->ConductorReleaseIndication(m_nConfID);
				}
			}
		}
	}

	DebugExitVOID(CConf::ProcessConductorReleaseIndication);
}


/*
 *	void ProcessConductorGiveIndication ()
 *
 *	Private Function Description
 *		This routine processes a conductor give indication received from
 *		the MCSUser object.
 *
 *	Formal Parameters:
 *		giving_node_id		-	Node ID of node that is givving up
 *								conductorship.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConductorGiveIndication ( UserID giving_node_id )
{
	DebugEntry(CConf::ProcessConductorGiveIndication);

	//	Ignore this indication if the conference is not conductible
	if (m_fConfConductible)
	{
		/*
		**	If this node is the Top Provider and node giving conductor ship is
		**	not the current Conductor, this node must check to make sure that
		**	it is valid for this node to become the Top Conductor.   Otherwise,
		**	we can assume this is a real give.
		*/
		if ((giving_node_id == m_nConductorNodeID) ||
			(m_pMcsUserObject->GetMyNodeID() != m_pMcsUserObject->GetTopNodeID()))
		{
			//	This flag is set when there is an outstanding give.
 			m_fConductorGiveResponsePending = TRUE;
		
			/*
			**	Inform the control SAP.
			*/
			g_pControlSap->ConductorGiveIndication(m_nConfID);
		}
		else
		{
			TRACE_OUT(("CConf: ProcessConductorGiveInd: Send REAL Assign Ind"));
			m_nConductorNodeID = giving_node_id;
			m_pMcsUserObject->SendConductorAssignIndication(m_nConductorNodeID);
			m_pMcsUserObject->ConductorTokenGiveResponse(RESULT_USER_REJECTED);
		}
	}

	DebugExitVOID(CConf::ProcessConductorGiveIndication);
}
			

/*
 *	void ProcessConductorGiveConfirm ()
 *
 *	Private Function Description
 *		This routine processes a conductor give confirm received from
 *		the MCSUser object.
 *
 *	Formal Parameters:
 *		result		-	This is the result of the give request.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConductorGiveConfirm ( GCCResult result )
{
	DebugEntry(CConf::ProcessConductorGiveConfirm);

	TRACE_OUT(("CConf::ProcessConductorGiveConfirm: result = %d", result));

	//	Ignore this indication if the conference is not conductible
	if (m_fConfConductible)
	{
		/*
		**	First we must determine if this Give Confirm is from
		**	a Give Request to the Top Provider that was associated with an
		**	Assign Request.  This type of Give Confirm is from the Top Provider.
		**	If not, we check to make sure that this is a Give Confirm associated
		**	with a give request issued by the Node Controller.  Otherwise, we
		**	dont process it.
		*/
		if (m_fConductorAssignRequestPending)
		{
#ifdef JASPER
			/*
			**	The proper result is for the Top Provider to reject the give
			**	to the Donor User ID that is the new Conductor.  This is
			**	straight out of the T.124 document.
			*/
			if (result != GCC_RESULT_SUCCESSFUL)	
				result = GCC_RESULT_SUCCESSFUL;
			else
				result = GCC_RESULT_UNSPECIFIED_FAILURE;

			//	Inform the control SAP of the result
			g_pControlSap->ConductorAssignConfirm(result, m_nConfID);
#endif // JASPER

			m_fConductorAssignRequestPending = FALSE;
		}
		else if (m_nPendingConductorNodeID != 0)
		{
			if (result == GCC_RESULT_SUCCESSFUL)
				m_fConductorGrantedPermission = FALSE;

#ifdef JASPER
			g_pControlSap->ConductorGiveConfirm(result, m_nConfID, m_nPendingConductorNodeID);
#endif // JASPER

			//	Set the pending conductor node ID back to zero.
			m_nPendingConductorNodeID = 0;
		}
	}

	DebugExitVOID(CConf::ProcessConductorGiveConfirm);
}


/*
 *	void	ProcessConductorPermitGrantInd ()
 *
 *	Private Function Description
 *		This routine processes a conductor permission grant indication received
 *		from the MCSUser object.
 *
 *	Formal Parameters:
 *		permission_grant_indication	-	This is the PDU data structure
 *										associated with the conductor
 *										permission grant indication.
 *		sender_id					-	This is the node ID of the node
 *										that sent the indication.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConductorPermitGrantInd
(
	PUserPermissionGrantIndicationInfo	permission_grant_indication,
	UserID								sender_id
)
{
	UINT	i;

	DebugEntry(CConf::ProcessConductorPermitGrantInd);

	if (m_fConfConductible)
	{
		if (sender_id == m_nConductorNodeID)
		{
			//	First check to see if we have been given permission
			m_fConductorGrantedPermission = FALSE;
			for (i = 0; i < permission_grant_indication->number_granted; i++)
			{
				if (permission_grant_indication->granted_node_list[i] ==
									m_pMcsUserObject->GetMyNodeID())
				{
					TRACE_OUT(("CConf::ProcessConductorPermitGrantInd: Permission was Granted"));
					m_fConductorGrantedPermission = TRUE;
					break;
				}
			}

			/*
			**	This indication goes to the control SAP and all the application
			**	SAPs.
			*/
			g_pControlSap->ConductorPermitGrantIndication (
								m_nConfID,
								permission_grant_indication->number_granted,
								permission_grant_indication->granted_node_list,
								permission_grant_indication->number_waiting,
								permission_grant_indication->waiting_node_list,
								m_fConductorGrantedPermission);

			/*
			**	We iterate on a temporary list to avoid any problems
			**	if the application sap leaves during the callback.
			*/
			CAppSap     *pAppSap;
			CAppSapList TempList(m_RegisteredAppSapList);
			TempList.Reset();
			while (NULL != (pAppSap = TempList.Iterate()))
			{
				if (DoesSAPHaveEnrolledAPE(pAppSap))
				{
					pAppSap->ConductorPermitGrantIndication(
								m_nConfID,
								permission_grant_indication->number_granted,
								permission_grant_indication->granted_node_list,
								permission_grant_indication->number_waiting,
								permission_grant_indication->waiting_node_list,
								m_fConductorGrantedPermission);
				}
			}
		}
		
	}

	DebugExitVOID(CConf::ProcessConductorPermitGrantInd);
}


/*
 *	void ProcessConductorTestConfirm ()
 *
 *	Private Function Description
 *		This routine processes a conductor test confirm received
 *		from the MCSUser object.
 *
 *	Formal Parameters:
 *		result		-	This is the result of the conductor test request
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
ProcessConductorTestConfirm ( GCCResult result )
{
	BOOL				conducted_mode;
	CBaseSap            *pSap;

	DebugEntry(CConf::ProcessConductorTestConfirm);

	if (! m_ConductorTestList.IsEmpty())
	{
		if (result == GCC_RESULT_SUCCESSFUL)
			conducted_mode = TRUE;
		else
			conducted_mode = FALSE;

		/*
		**	Pop the next command target of the list of command targets.
		**	Note that all token test request are processed in the order
		**	that they were issued so we are gauranteed to send the confirms
		**	to the correct target.
		*/

		pSap = m_ConductorTestList.Get();

		pSap->ConductorInquireConfirm(m_nConductorNodeID,
									result,
									m_fConductorGrantedPermission,
									conducted_mode,
									m_nConfID);
	}

	DebugExitVOID(CConf::ProcessConductorTestConfirm);
}


/*************************************************************************/


/*
 *	CConf::InitiateTermination ()
 *
 *	Private Function Description
 *		This routine informs the owner object that the conference has
 *		self terminated.  It also directs a disconnect provider request at
 *		the parent connection.
 *
 *	Formal Parameters:
 *		reason				-	This is the reason for the termination.
 *		requesting_node_id	-	This is the node ID of the node that is
 *								making the request,
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
InitiateTermination
(
    GCCReason           reason,
    UserID              requesting_node_id
)
{
    DebugEntry(CConf::InitiateTermination);

    if (! m_fTerminationInitiated)
    {
        m_fTerminationInitiated = TRUE;

        if (m_fConfIsEstablished ||
            (reason == GCC_REASON_DOMAIN_PARAMETERS_UNACCEPTABLE) ||
            m_fConfTerminatePending)
        {
            g_pControlSap->ConfTerminateIndication(m_nConfID, requesting_node_id, reason);
            m_fConfIsEstablished = FALSE;
        }

        //	Disconnect from the MCS parent connection if it exists
        if (m_hParentConnection != NULL)
        {
            g_pMCSIntf->DisconnectProviderRequest(m_hParentConnection);
            m_hParentConnection = NULL;
        }

        g_pGCCController->ProcessConfTerminated(m_nConfID, reason);

        /*
        **	Here we cleanup the registered application list. If any Application
        **	SAPs are still registered we will first send them PermitToEnroll
        **	indications revoking the permission to enroll and then we will
        **	unregister them (the unregister call takes care of this).  First set up
        **	a temporary list of the registered applications to iterate on since
        **	members of this list will be removed during this process.
        */
        if (! m_RegisteredAppSapList.IsEmpty())
        {
            CAppSapList TempList(m_RegisteredAppSapList);
            CAppSap     *pAppSap;
            TempList.Reset();
            while (NULL != (pAppSap = TempList.Iterate()))
            {
                UnRegisterAppSap(pAppSap);
            }
        }
    }

    DebugExitVOID(CConf::InitiateTermination);
}


/*
 *	CConf::GetConferenceNameAndModifier ()
 *
 *	Private Function Description
 *		This routine returns pointers to the conference name and modifier.
 *
 *	Formal Parameters:
 *		conference_name		-	Pointer to structure that holds the conference
 *								name.
 *		requesting_node_id	-	This is a pointer to a pointer that holds the
 *								conference modifier.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
GetConferenceNameAndModifier
(
	PGCCConferenceName	pConfName,
	PGCCNumericString	ppszConfModifier
)
{
	pConfName->numeric_string = m_pszConfNumericName;
	pConfName->text_string = m_pwszConfTextName;
	*ppszConfModifier = (GCCNumericString) m_pszConfModifier;
}




/*
 *	CAppRosterMgr * CConf::GetAppRosterManager ()
 *
 *	Private Function Description
 *		This call returns a pointer to the application manager that
 *		matches the passed in key. It returns NULL is the application
 *		does not exists.
 *
 *	Formal Parameters:
 *		session_key			-	This is the session key associated with the
 *								application roster manager that is being
 *								requested.
 *
 *	Return Value
 *		A pointer to the appropriate application roster manager.
 *		NULL if on does not exists.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
CAppRosterMgr * CConf::
GetAppRosterManager ( PGCCSessionKey session_key )
{
	CAppRosterMgr				*app_roster_manager = NULL;

	if (session_key != NULL)
	{
		CAppRosterMgr				*lpAppRosterMgr;

		m_AppRosterMgrList.Reset();
		while (NULL != (lpAppRosterMgr = m_AppRosterMgrList.Iterate()))
		{
			if (lpAppRosterMgr->IsThisYourSessionKey(session_key))
			{
				app_roster_manager = lpAppRosterMgr;
				break;
			}
		}
	}

	return (app_roster_manager);
}


/*
 *	CConf::GetNewUserIDTag ()
 *
 *	Private Function Description
 *		This routine generates a User ID Tag number that is used in a
 *		User ID indication sent betweek two connected nodes.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		This is the User ID tag number generated by this routine.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		Zero is not a valid.  We initialize the convener user ID tag to
 *		zero which is an invalid tag.
 */
TagNumber CConf::
GetNewUserIDTag ( void )
{
	/*
	**	Determine the tag number to associate with the GCC User ID
	**	that will be returned after the pending request or confirm.
	*/
	while (1)
	{
		if (++m_nUserIDTagNumber != 0)
		{
			if (m_ConnHdlTagNumberList2.Find(m_nUserIDTagNumber) == 0)
				break;
		}
	}

	return (m_nUserIDTagNumber);
}


/*
 *	CConf::DoesRequesterHavePrivilege ()
 *
 *	Private Function Description
 *		This routine determines if the specified user has the specified
 *		privilege.
 *
 *	Formal Parameters:
 *		requester_id	-	This is the node ID that is being checked for
 *							the specified privilege.
 *		privilege		-	Privilege being checked for.
 *
 *	Return Value
 *		TRUE		-	If requester has privilege.
 *		FALSE		-	If requester does NOT have privilege.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
BOOL CConf::
DoesRequesterHavePrivilege
(
	UserID					    requester_id,
	ConferencePrivilegeType	    privilege
)
{
	BOOL				rc = FALSE;

	if (requester_id == m_nConvenerNodeID)
		rc = TRUE;
	else
	{
		/*
		**	First check to see if the node is the conductor and a conductor
		**	privilege list exists.	Next check to see if the conference is in
		**	conducted mode and a conducted mode privilege list exists.
		**	Else, if not in conducted mode and a Non-Conducted mode privilege
		**	list exists use it.
		*/
		if (m_nConductorNodeID == requester_id)
		{
			if (m_pConductorPrivilegeList != NULL)
			{
				rc = m_pConductorPrivilegeList->
											IsPrivilegeAvailable(privilege);
			}
		}

		if (rc == FALSE)
		{
			if (m_nConductorNodeID != 0)
			{
				if (m_pConductModePrivilegeList != NULL)
				{
					rc = m_pConductModePrivilegeList->IsPrivilegeAvailable(privilege);
				}
			}
			else
			{
				if (m_pNonConductModePrivilegeList != NULL)
				{
					rc = m_pNonConductModePrivilegeList->IsPrivilegeAvailable(privilege);
				}
			}
		}
	}

	return rc;
}


/*
 *	CConf::SendFullRosterRefresh ()
 *
 *	Private Function Description
 *		When a new node is added to the conference it is the Top Provider's
 *		responsiblity to send out a complete refresh of all the rosters
 *		including both the conference roster and all the application rosters.
 *		That is the responsiblity of the routine.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConf::
SendFullRosterRefresh ( void )
{
	GCCError							rc;
	GCCPDU								gcc_pdu;
	PSetOfApplicationInformation	*	application_information;
	PSetOfApplicationInformation		next_set_of_information;

	DebugEntry(CConf::SendFullRosterRefresh);

	/*
	**	Start building the roster update indication. Not that this update
	**	will include the conference roster as well as all the application
	**	rosters.
	*/
	gcc_pdu.choice = INDICATION_CHOSEN;

	gcc_pdu.u.indication.choice = ROSTER_UPDATE_INDICATION_CHOSEN;

	gcc_pdu.u.indication.u.roster_update_indication.application_information =
																		NULL;

	gcc_pdu.u.indication.u.roster_update_indication.refresh_is_full = TRUE;

	//	Call on the base class to fill in the PDU structure
	rc = m_pConfRosterMgr->GetFullRosterRefreshPDU (
			&gcc_pdu.u.indication.u.roster_update_indication.node_information);

	/*
	**	If the conference roster get was successful we will iterate through
	**	all the application roster managers making the same request for a
	**	full refresh.  Note that the application_information pointer is updated
	**	after every request to an app roster manager.  This is because new
	**	sets of application information are being allocated everytime this call
	**	is made.
	*/
	if (rc == GCC_NO_ERROR)
	{
		CAppRosterMgr				*lpAppRosterMgr;

		application_information = &gcc_pdu.u.indication.u.
							roster_update_indication.application_information;
							
		m_AppRosterMgrList.Reset();
		while (NULL != (lpAppRosterMgr = m_AppRosterMgrList.Iterate()))
		{
			next_set_of_information = lpAppRosterMgr->GetFullRosterRefreshPDU (
																application_information,
																&rc);
			if (rc == GCC_NO_ERROR)
			{
				if (next_set_of_information != NULL)
					application_information = &next_set_of_information->next;

//
// LONCHANC: If next_set_of_information is NULL,
// then application_information is unchanged.
// This means we effectively ignore this iteration.
// This is good because we do not lose anything.
//
			}
			else
				break;
		}
	}

	/*
	**	If no errors have occured up to this point we will go ahead and send
	**	out the PDU.
	*/
	if (rc == GCC_NO_ERROR)
		m_pMcsUserObject->RosterUpdateIndication (&gcc_pdu, FALSE);

	DebugExitINT(CConf::SendFullRosterRefresh, rc);
	return rc;
}


/*
 *	CConf::UpdateNewConferenceNode ()
 *
 *	Private Function Description
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConf::
UpdateNewConferenceNode ( void )
{
	GCCError	rc = GCC_NO_ERROR;

	DebugEntry(CConf::UpdateNewConferenceNode);

	//	Here we send a full roster refresh for the node that added			
	rc = SendFullRosterRefresh ();

	if (rc == GCC_NO_ERROR)
	{
		/*
		**	We must inform the new node of the current conductorship
		**	status.  Note that we only do this if the conference is
		**	conductible and we are the Top Provider.
		*/
		if (m_fConfLocked == CONFERENCE_IS_LOCKED)
		{
			m_pMcsUserObject->SendConferenceLockIndication(
					TRUE,    // Indicates uniform send
					0);
		}
		else
		{
			m_pMcsUserObject->SendConferenceUnlockIndication(
					TRUE,    // Indicates uniform send
					0);
		}

		if (m_fConfConductible)
		{
			if (m_nConductorNodeID != 0)
			{
				m_pMcsUserObject->SendConductorAssignIndication(m_nConductorNodeID);
			}
			else
				m_pMcsUserObject->SendConductorReleaseIndication();
		}
	}
	else
	{
		ERROR_OUT(("CConf: UpdateNewConferenceNode: Error sending full refresh"));
		InitiateTermination(GCC_REASON_ERROR_LOW_RESOURCES,	0);
	}

	DebugExitINT(CConf::UpdateNewConferenceNode, rc);
	return rc;
}


/*
**	Before we start the disconnect/termination process we must remove all the
**	outstanding invite request from our list and send back associated
**	confirms. Here we go ahead disconnect all connection associated with
**	the invites.
*/
void CConf::
DeleteOutstandingInviteRequests ( void )
{
    INVITE_REQ_INFO *pInvReqInfo;
    while (NULL != (pInvReqInfo = m_InviteRequestList.Get()))
    {
        DeleteInviteRequest(pInvReqInfo);
    }
}


void CConf::
CancelInviteRequest ( ConnectionHandle hInviteReqConn )
{
    INVITE_REQ_INFO *pInvReqInfo;
    m_InviteRequestList.Reset();
    while (NULL != (pInvReqInfo = m_InviteRequestList.Iterate()))
    {
        if (hInviteReqConn == pInvReqInfo->connection_handle)
        {
            m_InviteRequestList.Remove(pInvReqInfo);
            DeleteInviteRequest(pInvReqInfo);
            return;
        }
    }
}

void CConf::
DeleteInviteRequest ( INVITE_REQ_INFO *pInvReqInfo )
{
    //	Cleanup the connection handle list
    ASSERT(NULL != pInvReqInfo);
    ASSERT(0 != pInvReqInfo->connection_handle);
    m_ConnHandleList.Remove(pInvReqInfo->connection_handle);

    g_pMCSIntf->DisconnectProviderRequest(pInvReqInfo->connection_handle);

    //	Send the invite confirm	
    g_pControlSap->ConfInviteConfirm(m_nConfID,
                                     NULL,
                                     GCC_RESULT_INVALID_CONFERENCE,
                                     pInvReqInfo->connection_handle);

    //	Free up the invite request info structure
    if (NULL != pInvReqInfo->user_data_list)
    {
        pInvReqInfo->user_data_list->Release();
    }
    delete pInvReqInfo;
}


void CConf::
ProcessConfJoinResponse
(
    PUserJoinResponseInfo   join_response_info
)
{
    BOOL_PTR                bptr;

    if (NULL != (bptr = m_JoinRespNamePresentConnHdlList2.Remove(join_response_info->connection_handle)))
    {
        ConfJoinIndResponse (
                (ConnectionHandle)join_response_info->connection_handle,
                join_response_info->password_challenge,
                join_response_info->user_data_list,
                (bptr != FALSE_PTR),
                FALSE,
                join_response_info->result);
    }
}


void CConf::
ProcessAppInvokeIndication
(
    CInvokeSpecifierListContainer   *pInvokeList,
    UserID                          uidInvoker
)
{
    /*
    **	Here we pass the invoke along to all the enrolled application
    **	SAPs as well as the control SAP.
    */
    g_pControlSap->AppInvokeIndication(m_nConfID, pInvokeList, uidInvoker);

    /*
    **	We iterate on a temporary list to avoid any problems
    **	if the application sap leaves during the callback.
    */
    CAppSap     *pAppSap;
    CAppSapList TempList(m_RegisteredAppSapList);
    TempList.Reset();
    while (NULL != (pAppSap = TempList.Iterate()))
    {
        if (DoesSAPHaveEnrolledAPE(pAppSap))
        {
            pAppSap->AppInvokeIndication(m_nConfID, pInvokeList, uidInvoker);
        }
    }
}

#ifdef JASPER
void CConf::
ProcessConductorPermitAskIndication
(
    PPermitAskIndicationInfo    indication_info
)
{
    //	Ignore this indication if the conference is not conductible
    if (m_fConfConductible &&
        (m_nConductorNodeID == m_pMcsUserObject->GetMyNodeID()))
    {
        g_pControlSap->ConductorPermitAskIndication(
                                m_nConfID,
                                indication_info->permission_is_granted,
                                indication_info->sender_id);
    }
}
#endif // JASPER


void CConf::
ProcessConfAddResponse
(
    PAddResponseInfo    add_response_info
)
{
    CNetAddrListContainer *network_address_list;

    if (NULL != (network_address_list = m_AddRequestList.Remove(add_response_info->add_request_tag)))
    {
        g_pControlSap->ConfAddConfirm(
                            m_nConfID,
                            network_address_list,
                            add_response_info->user_data_list,
                            add_response_info->result);

        //	Unlock and remove the net address list
        network_address_list->UnLockNetworkAddressList();
    }
}


void CConf::
ConfRosterReportIndication ( CConfRosterMsg * pMsg )
{
    //	First send the update to the Control Sap.
    g_pControlSap->ConfRosterReportIndication(m_nConfID, pMsg);

    //	Next send the update to all the Enrolled Application Saps

#if 0 // LONCHANC: app sap does not support conf roster report indication
    /*
    **	We iterate on a temporary list to avoid any problems
    **	if the application sap leaves during the callback.
    */
    CAppSap     *pAppSap;
    CAppSapList TempList(m_RegisteredAppSapList);
    TempList.Reset();
    while (NULL != (pAppSap = TempList.Iterate()))
    {
        if (DoesSAPHaveEnrolledAPE(pAppSap))
        {
            pAppSap->ConfRosterReportIndication(m_nConfID, pMsg);
        }
    }
#endif // 0
}



int  KeyCompare(const struct Key *key1, const struct Key *key2)
{
	if (key1->choice != key2->choice)
		return 1;

	switch (key1->choice) {
	case object_chosen:
		return ASN1objectidentifier_cmp((struct ASN1objectidentifier_s **) &key1->u.object,
										(struct ASN1objectidentifier_s **) &key2->u.object);
		
	case h221_non_standard_chosen:
		if (key1->u.h221_non_standard.length != key2->u.h221_non_standard.length)
			return 1;
		return memcmp(&key1->u.h221_non_standard.value,
			    	  &key2->u.h221_non_standard.value,
			   		  key1->u.h221_non_standard.length);
		
	}
	return 1;
}


BOOL CConf::
DoesRosterPDUContainApplet(PGCCPDU  roster_update,
			const struct Key *app_proto_key, BOOL  refreshonly)
{
	BOOL								rc = FALSE;
	PSetOfApplicationInformation		set_of_application_info;
	ASN1choice_t						choice;	
	PSessionKey							session_key;

	DebugEntry(CConf::DoesRosterPDUContainApplet);

	set_of_application_info = roster_update->u.indication.u.
						roster_update_indication.application_information;


	while (set_of_application_info != NULL)
	{
		choice = set_of_application_info->value.application_record_list.choice;
		session_key = &set_of_application_info->value.session_key;

		if (refreshonly && (choice != application_record_refresh_chosen))
			continue;
		if (!refreshonly && (choice == application_no_change_chosen))
			continue;

		if (0 == KeyCompare(&session_key->application_protocol_key,
							app_proto_key))
		{
			rc = TRUE;
			break;
		}
		set_of_application_info = set_of_application_info->next;
	}

	DebugExitINT(CConf::DoesRosterPDUContainApplet, rc);
	return rc;
}


UINT HexaStringToUINT(LPCTSTR pcszString)
{
    ASSERT(pcszString);
    UINT uRet = 0;
    LPTSTR pszStr = (LPTSTR) pcszString;
    while (_T('\0') != pszStr[0])
    {
        if ((pszStr[0] >= _T('0')) && (pszStr[0] <= _T('9')))
		{
			uRet = (16 * uRet) + (BYTE) (pszStr[0] - _T('0'));
		}
		else if ((pszStr[0] >= _T('a')) && (pszStr[0] <= _T('f')))
		{
			uRet = (16 * uRet) + (BYTE) (pszStr[0] - _T('a') + 10);
		}
		else if  ((pszStr[0] >= _T('A')) && (pszStr[0] <= _T('F')))
		{
			uRet = (16 * uRet) + (BYTE) (pszStr[0] - _T('A') + 10);
		}
		else
			ASSERT(0);

        pszStr++; // NOTE: DBCS characters are not allowed!
    }
    return uRet;
}


void CConf::AddNodeVersion(UserID  NodeId,  NodeRecord *pNodeRecord)
{
	PSetOfUserData		set_of_user_data;
	ASN1octetstring_t	user_data;
	ASN1octet_t			*currpos;
	TCHAR				szVersion[256];

	if (pNodeRecord->bit_mask&RECORD_USER_DATA_PRESENT)
	{
		set_of_user_data = pNodeRecord->record_user_data;
		while (set_of_user_data)
		{
			if (set_of_user_data->user_data_element.bit_mask & USER_DATA_FIELD_PRESENT)
			{
				user_data = set_of_user_data->user_data_element.user_data_field;
				// Looking for the octet string L"VER:"
				currpos = user_data.value;
				while (currpos + sizeof(L"VER:") < user_data.value + user_data.length)
				{	
					if (!memcmp(currpos, L"VER:", 8))
					{
						break;
					}
					currpos++;
				}
				if (currpos + sizeof(L"VER:") < user_data.value + user_data.length)
				{   // found
					WideCharToMultiByte(CP_ACP, 0, (const unsigned short*)(currpos+8),
							4  /* only need version num, "0404" */,
							szVersion, 256, 0, 0);
					szVersion[4] = '\0';
					DWORD dwVer = HexaStringToUINT(szVersion);
					m_NodeVersionList2.Append(NodeId, dwVer);
					WARNING_OUT(("Insert version %x0x for node %d.\n", dwVer, NodeId));
				}
			}
			set_of_user_data = set_of_user_data->next;
		}
	}
}

GCCError CConf::UpdateNodeVersionList(PGCCPDU  roster_update,
									  GCCNodeID sender_id)
{
	GCCError rc = GCC_NO_ERROR;
	NodeRecordList							node_record_list;
	ASN1choice_t							choice;	
	PSetOfNodeRecordRefreshes				set_of_node_refresh;
	PSetOfNodeRecordUpdates					set_of_node_update;
	UserID									node_id;
	NodeRecord								*pNodeRecord;

	node_record_list = roster_update->u.indication.u.roster_update_indication.
				node_information.node_record_list;

	switch(node_record_list.choice)
	{
	case node_no_change_chosen:
		break;

	case node_record_refresh_chosen:
		set_of_node_refresh = node_record_list.u.node_record_refresh;
		while (set_of_node_refresh)
		{
			node_id = set_of_node_refresh->value.node_id;
			pNodeRecord = &set_of_node_refresh->value.node_record;
			AddNodeVersion(node_id, pNodeRecord);
			set_of_node_refresh = set_of_node_refresh->next;
		}
		break;

	case node_record_update_chosen:
		set_of_node_update = node_record_list.u.node_record_update;
		while (set_of_node_update)
		{
			node_id = set_of_node_update->value.node_id;
			switch(set_of_node_update->value.node_update.choice)
			{
			case node_remove_record_chosen:
				m_NodeVersionList2.Remove(node_id);
				break;

			case node_add_record_chosen:
				pNodeRecord = &set_of_node_update->value.node_update.u.node_add_record;
				AddNodeVersion(node_id, pNodeRecord);
				break;
			}
			
			set_of_node_update = set_of_node_update->next;
		}
		break;
	}
	return rc;
}


BOOL CConf::HasNM2xNode(void)
{
    DWORD_PTR dwVer;
    m_NodeVersionList2.Reset();
    while (NULL != (dwVer = m_NodeVersionList2.Iterate()))
    {
        if (dwVer < 0x0404)
            return TRUE;
    }
    return FALSE;
}

DWORD_PTR WINAPI T120_GetNodeVersion(GCCConfID ConfId, GCCNodeID NodeId)
{
    CConf *pConf = g_pGCCController->GetConfObject(ConfId);
    DWORD_PTR version;
    if (pConf)
    {
        version = pConf->GetNodeVersion(NodeId);
        return version;
    }
    return 0;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\conf.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	conf.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the imlementation file for the CConf Class. The
 *		conference class is the heart of GCC.  It maintains all the
 *		information basses for a single conference including conference and
 *		application rosters as well as registry information.  It also
 *		routes, encodes and decodes various PDU's and primitives supported
 *		by GCC.
 *
 *		FOR A MORE DETAILED EXPLANATION OF THIS CLASS SEE THE INTERFACE FILE.
 *
 *	Portable:
 *		Yes
 *
 *	Private Instance Variables
 *		m_JoinRespNamePresentConnHdlList2
 *			This list keeps up with outstanding	joins at an intermediate node.
 *		Enrolled_App_List
 *			This list keeps up with all the	enrolled applications.
 *		m_ConnHandleList
 *			This list keeps up with all the child node connection handles.	
 *		m_ConnHdlTagNumberList2
 *			This list keeps up with all the outstanding user ID Tag numbers.
 *		m_EjectedNodeConfirmList
 *			This list keeps up with all the nodes that have been ejected but
 *			have yet to disconnect.  Used to disconnect any misbehaving apps.
 *		m_pMcsUserObject
 *			Holds a pointer to the MCSUser object owned by this conference.
 *		m_pszConfNumericName
 *			Holds the numeric conference name.
 *		m_pwszConfTextName
 *			Holds a pointer to a unicode string	object that contains the text
 *			conference name.  NULL if empty.
 *		m_pszConfModifier
 *			Holds a pointer to the conference modifier. NULL if empty.
 *		m_pszRemoteModifier
 *			Holds a pointer to the remote modifier. Only used in Join Confirms.
 *		m_nConfID
 *			Holds the conference ID associated with this conference object.
 *		m_fConfLocked
 *			Flag that indicates if the conference is locked.
 *		m_fConfListed
 *			Flag that indicates if the conference is listed.
 *		m_fConfConductible
 *			Flag that indicates if the conference is conductible.
 *		m_fClearPassword
 *			Flag that indicates if password in the clear is used.
 *		m_nConvenerNodeID
 *			Holds the MCS user ID of the convener. Zero if convener has left.
 *		m_eTerminationMethod
 *			Holds the enumeration that defines the termination method.
 *		m_pDomainParameters
 *			Holds the domain parameters that are returned in a number
 *			of confirms.
 *		m_nUserIDTagNumber
 *			The tag number that must be included when sending this nodes user ID
 *			back to a connected node.
 *		m_nConvenerUserIDTagNumber
 *			Used to uniquely mark the convener when it is rejoining a
 *			conference.
 *		m_nParentIDTagNumber
 *			Used to uniquely mark the parent user ID for an invited node.
 *		m_eNodeType
 *			Holds the enumerated Node Type for this particular node.
 *      m_hParentConnection
 *			Holds the parent logical connection	handle.
 *		m_hConvenerConnection
 *			Holds the convener connection handle.
 *		m_fConfIsEstablished
 *			Flag which is set to TRUE when the confernce is completely
 *			established and ready for enrolls and announces.
 *		m_fConfDisconnectPending
 *			Flag which is set to TRUE when a disconnect has been issued but
 *			the conference is waiting for subordinate nodes to disconnect.
 *		m_fConfTerminatePending
 *			Flag which is set to TRUE when a terminate has been issued but
 *			the conference is waiting for subordinate nodes to disconnect.
 *		m_eConfTerminateReason
 *			Maintains the terminate reason for delivery in the indication.
 *		m_pConfTerminateAlarm
 *			Alarm that is used to force automatic termination when
 *			subordinate nodes will not disconnect.
 *		m_pConfStartupAlarm
 *			Alarm used to hold back the flush of the first roster update
 *			indication until all the APEs that wish to enroll have had time
 *			to enroll.
 *		m_pConductorPrivilegeList
 *			Holds a pointer to the conductor privilege list object.
 *		m_pConductModePrivilegeList
 *			Holds a pointer to the conducted mode privilege list object.
 *		m_pNonConductModePrivilegeList
 *			Holds a pointer to the non-conducted mode privilege list object.
 *		m_pwszConfDescription
 *			Holds a pointer to a unicode string which holds the conference
 *			description.
 *		m_pNetworkAddressList
 *			Holds a pointer to an object that contains all the local network
 *			addresses.
 *		m_pUserDataList
 *			Holds a pointer to a user data object needed to deliver an
 *			asynchronus confirm message.
 *		m_nConfAddRequestTagNumber
 *			This instance variable is used to generate the add request tag that
 *			is returned in an add response.
 *		m_nConfAddResponseTag
 *			This instance variable is used to generate a response tag that is
 *			passed in an add indication and returned in an add response.
 *		m_AddRequestList
 *			List that keeps up with all the outstanding add request tags.	
 *		m_AddResponseList
 *			List that keeps up with all the outstanding add response tags.
 *		m_pConfRosterMgr
 *			Pointer to the Conference Roster manager.
 *		m_AppRosterMgrList
 *			List which holds pointers to all ofthe Application Roster managers.
 *		m_pAppRegistry
 *			Pointer to the Application Registry object used by this conference.
 *		m_InviteRequestList
 *			List which keeps up with the info associated with all of the
 *			outstanding invite request.  Used for cleanup when the invited
 *			node never responds.
 *		m_nConductorNodeID
 *			The MCS user ID associated with the conducting node. Zero if the
 *			conference is not in conducted mode.
 *		m_nPendingConductorNodeID
 *			Used to keep up with the new conductor node ID when conductorship
 *			is being passed from one node to another.
 *		m_fConductorGrantedPermission
 *			Flag which when TRUE specifies that this node has conductor granted
 *			permission.
 *		m_ConductorTestList
 *			List that is used to keep up with all the command targets that have
 *			issued conductor inquire request.
 *		m_fConductorGiveResponsePending
 *			Flag that states if this node is waiting on a conductor give
 *			response.
 *		m_fConductorAssignRequestPending
 *			Flag that states if this node is waiting to here back from an
 *			assign request.
 *		APE_Enitity_ID
 *			This is a counter used to generate application enityt ids.
 *
 *	Caveats:
 *		Note that the conference object is now split into two seperate files
 *		to prevent text segment problems.  This file contains the constructors
 *		and all the entry points for the Owner Object.
 *
 *	Author:
 *		blp
 */

#include "conf.h"
#include "gcontrol.h"
#include "translat.h"
#include "ogcccode.h"

#ifdef _DEBUG
#define	STARTUP_TIMER_DURATION			10000	//	Ten second startup time
#else
#define	STARTUP_TIMER_DURATION			2000	//	Two second startup time
#endif


extern MCSDLLInterface     *g_pMCSIntf;

/*
 *	This is a global variable that has a pointer to the one GCC coder that
 *	is instantiated by the GCC Controller.  Most objects know in advance
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CGCCCoder	*g_GCCCoder;

/*
 *	CConf::CConf ()
 *
 *	Public Function Description
 *  When pConfSpecParams != NULL
 *		This is the conference constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *		It also creates the MCS domain based on the conference id.
 *		Fatal errors are returned from this constructor in the
 *		return value. Note that this constructor is used when the
 *		Conference specification parameters such as termination	
 *		method or known in advance of conference creation.  This is
 *		the case for a CONVENOR node and a TOP PROVIDER.  It is not
 *		used for joining nodes.
 *
 *	When pConfSpecParams == NULL
 *		This is the conference constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 *		It also creates the MCS domain based on the conference id.
 *		Fatal errors are returned from this constructor in the
 *		return value. Note that this constructor is used by nodes that
 *		do not know the Conference specification parameters such as
 *		termination method in advance of conference creation.  This is
 *		the case for joining nodes.
 */
CConf::
CConf
(
	PGCCConferenceName			pConfName,
	GCCNumericString			pszConfModifier,
	GCCConfID   				nConfID,
	CONF_SPEC_PARAMS			*pConfSpecParams,
	UINT						cNetworkAddresses,
	PGCCNetworkAddress 			*pLocalNetworkAddress,
	PGCCError					pRetCode
)
:
    CRefCount(MAKE_STAMP_ID('C','o','n','f')),
	m_RegisteredAppSapList(DESIRED_MAX_APP_SAP_ITEMS),
	m_EnrolledApeEidList2(DESIRED_MAX_APP_SAP_ITEMS),
	m_ConnHdlTagNumberList2(DESIRED_MAX_CONN_HANDLES),
	m_JoinRespNamePresentConnHdlList2(CLIST_DEFAULT_MAX_ITEMS),
    m_InviteRequestList(CLIST_DEFAULT_MAX_ITEMS),
	m_ConnHandleList(DESIRED_MAX_CONN_HANDLES),
	m_EjectedNodeConfirmList(CLIST_DEFAULT_MAX_ITEMS),
	m_AddRequestList(CLIST_DEFAULT_MAX_ITEMS),
	m_AddResponseList(CLIST_DEFAULT_MAX_ITEMS),
    m_NodeVersionList2(CLIST_DEFAULT_MAX_ITEMS),
	m_cEnrollRequests(0),
	m_fFirstAppRosterSent(FALSE),
	m_nConfID(nConfID),
	m_pMcsUserObject(NULL),
	m_pDomainParameters(NULL),
	m_pUserDataList(NULL),
	m_pszRemoteModifier(NULL),
	m_pConfRosterMgr(NULL),
	m_pAppRegistry(NULL),
	m_nConductorNodeID(0),
	m_nPendingConductorNodeID(0),
	m_fConductorGrantedPermission(FALSE),
	m_fConductorGiveResponsePending(FALSE),
	m_fConductorAssignRequestPending(FALSE),
	m_hParentConnection(0),
	m_hConvenerConnection(0),
	m_pConfTerminateAlarm(NULL),
	m_nUserIDTagNumber(0),
	m_nConfAddRequestTagNumber(0),
	m_nConfAddResponseTag(0),
	m_nConvenerNodeID(0),
	m_nConvenerUserIDTagNumber(0),
	m_nAPEEntityID(0),
	m_pwszConfTextName(NULL),
	m_pszConfModifier(NULL),
	m_pConductorPrivilegeList(NULL),
	m_pConductModePrivilegeList(NULL),
	m_pNonConductModePrivilegeList(NULL),
	m_pwszConfDescription(NULL),
	m_pNetworkAddressList(NULL),
	/*	This variable transitions to TRUE when the conference has completely
	**	stabilized. Once it is set to TRUE applications may enroll with the
	**	conference. */
	m_fConfIsEstablished(FALSE),
	/*	This variable is transitioned to TRUE if the node that is
	**	disconnected is connected to child nodes. */
	m_fConfDisconnectPending(FALSE),
	/*	This variable is transitioned to TRUE if a valid Terminate request
	**	is processed. */
	m_fConfTerminatePending(FALSE),
	/* This variable is set to TRUE if InitiateTermination is called once */
	m_fTerminationInitiated(FALSE),
	m_fSecure(FALSE),
	m_fWBEnrolled(FALSE),
	m_fFTEnrolled(FALSE),
	m_fChatEnrolled(FALSE)
{
	GCCError			rc = GCC_ALLOCATION_FAILURE;

	DebugEntry(CConf::CConf);

	//	Conference Specification
	if (NULL != pConfSpecParams)
	{
		m_fClearPassword = pConfSpecParams->fClearPassword;
		m_fConfLocked = pConfSpecParams->fConfLocked;
		m_fConfListed = pConfSpecParams->fConfListed;
		m_fConfConductible = pConfSpecParams->fConfConductable;
		m_eTerminationMethod = pConfSpecParams->eTerminationMethod;
	}

	// m_pConfStartupAlarm = NULL;
	DBG_SAVE_FILE_LINE
	m_pConfStartupAlarm = new Alarm(STARTUP_TIMER_DURATION);
	if (NULL == m_pConfStartupAlarm)
	{
		ERROR_OUT(("CConf::CConf: Error allocating startup alarm"));
		goto MyExit;
	}

	//	Save the numeric conference name.
	if (NULL != pConfName->numeric_string)
	{
		if (NULL == (m_pszConfNumericName = ::My_strdupA(pConfName->numeric_string)))
		{
			ERROR_OUT(("CConf::CConf: Error allocating conf numeric name"));
			goto MyExit;
		}
		TRACE_OUT(("CConf::CConf: m_strConfNumericName = %s", m_pszConfNumericName));
	}
	else
	{
		m_pszConfNumericName = NULL;
		if (NULL != pConfSpecParams)
		{
		    //
			// LONCHANC: It is an error for top-provider.
			//
			ERROR_OUT(("CConf::CConf: Error: Numeric Name not present"));
			rc = GCC_INVALID_CONFERENCE_NAME;
			goto MyExit;
		}
		//
		// LONCHANC: It is not an error for joining node.
		//
	}

	//	Save the text conference name if one exists
	if (NULL != pConfName->text_string)
	{
		if (NULL == (m_pwszConfTextName = ::My_strdupW(pConfName->text_string)))
		{
			ERROR_OUT(("CConf::CConf: Error allocating unicode string"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}
	}

	//	Save the conference modifier if one exists
	if (NULL != pszConfModifier)
	{
		if (NULL == (m_pszConfModifier = ::My_strdupA(pszConfModifier)))
		{
			ERROR_OUT(("CConf::CConf: Error allocating conf modifier"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}
		else
		{
			TRACE_OUT(("CConf::CConf: Conference_Modifier = %s", m_pszConfModifier));
		}
	}

	//	Set up the privilege list as needed
	if (NULL != pConfSpecParams)
	{
		if (NULL != pConfSpecParams->pConductPrivilege)
		{
			DBG_SAVE_FILE_LINE
			m_pConductorPrivilegeList = new PrivilegeListData(pConfSpecParams->pConductPrivilege);
			if (NULL == m_pConductorPrivilegeList)
			{
				ERROR_OUT(("CConf::CConf: Error allocating conductor privilege list"));
				ASSERT(GCC_ALLOCATION_FAILURE == rc);
				goto MyExit;
			}
		}
			
		if (NULL != pConfSpecParams->pConductModePrivilege)
		{
			DBG_SAVE_FILE_LINE
			m_pConductModePrivilegeList = new PrivilegeListData(pConfSpecParams->pConductModePrivilege);
			if (NULL == m_pConductModePrivilegeList)
			{
				ERROR_OUT(("CConf::CConf: Error allocating conduct mode privilege list"));
				ASSERT(GCC_ALLOCATION_FAILURE == rc);
				goto MyExit;
			}
		}

		if (NULL != pConfSpecParams->pNonConductPrivilege)
		{
			DBG_SAVE_FILE_LINE
			m_pNonConductModePrivilegeList = new PrivilegeListData(pConfSpecParams->pNonConductPrivilege);
			if (NULL == m_pNonConductModePrivilegeList)
			{
				ERROR_OUT(("CConf::CConf: Error allocating non-conduct mode privilege list"));
				ASSERT(GCC_ALLOCATION_FAILURE == rc);
				goto MyExit;
			}
		}

		if (NULL != pConfSpecParams->pwszConfDescriptor)
		{
			if (NULL == (m_pwszConfDescription =
								::My_strdupW(pConfSpecParams->pwszConfDescriptor)))
			{
				ERROR_OUT(("CConf::CConf: Error allocating conf descriptor"));
				ASSERT(GCC_ALLOCATION_FAILURE == rc);
				goto MyExit;
			}
		}
	}

	//	Save the network address(es)
	if (0 != cNetworkAddresses)
	{
		DBG_SAVE_FILE_LINE
		m_pNetworkAddressList = new CNetAddrListContainer(cNetworkAddresses, pLocalNetworkAddress, &rc);
		if (NULL == m_pNetworkAddressList || GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::CConf: Error allocating network address list"));
			rc = GCC_ALLOCATION_FAILURE; // rc could be a different value
			goto MyExit;
		}
	}

	ASSERT(GCC_ALLOCATION_FAILURE == rc);

	/*
	**	Create the Domain based on the conference name that was
	**	passed in.
	*/
	if (MCS_NO_ERROR != g_pMCSIntf->CreateDomain(&m_nConfID))
	{
		ERROR_OUT(("CConf::CConf: Error creating domain"));
		rc = GCC_FAILURE_CREATING_DOMAIN;
		goto MyExit;
	}

	rc = GCC_NO_ERROR;

MyExit:

	*pRetCode = rc;

	DebugExitINT(CConf::CConf, rc);
}


/*
 *	CConf::~CConf ()
 *
 *	Public Function Description
 *		This is the conference destructor. It is responsible for
 *		deleting the User Attachment and freeing up any outstanding
 *		resources used by the conference class. It also calls
 *		MCS Disconnect Provider to disconnect fron all its connections
 *		including both parent and child connections. In addition, it
 *		unregisters its command target from the controller and application
 *		SAPs and deletes the MCS domain it is associated with.
 *
 *	Caveats
 *		none
 */
CConf::
~CConf ( void )
{
	ConnectionHandle            nConnHdl;
	//CAppRosterMgr				*lpAppRosterMgr;
	ENROLLED_APE_INFO			*lpEnrAPEInfo;
	//CAppSap	    				*pAppSap;

	DebugEntry(CConf::~CConf);

	//	Delete the terminate alarm if it exists	
	delete m_pConfTerminateAlarm;

	//	Delete the startup alarm if it exists
	delete m_pConfStartupAlarm;

	//	Delete Conference Roster Managers
	if (NULL != m_pConfRosterMgr)
    {
        m_pConfRosterMgr->Release();
    }

	//	Delete Application Roster Managers
	m_AppRosterMgrList.DeleteList();

	//	Delete the application registry
	if (NULL != m_pAppRegistry)
	{
	    m_pAppRegistry->Release();
	}

	//	Delete the text conference name if it exist
	delete m_pszConfNumericName;
	delete m_pwszConfTextName;

	//	Delete the conference modifier if it exist
	delete m_pszConfModifier;

	//	Delete the remote modifier if it exist
	delete m_pszRemoteModifier;

	/*
	**	The privilege list are not directly deleted here instead Free is called
	**	to prevent the list from being deleted in the case where it has been
	**	locked outside the conference object.
	*/

 	//	Delete all the privilege list (Free is needed incase the list
	delete m_pConductorPrivilegeList;
	delete m_pConductModePrivilegeList;
	delete m_pNonConductModePrivilegeList;

	//	Delete the conference descriptor
	delete m_pwszConfDescription;

	//	Delete the network address list
	if (NULL != m_pNetworkAddressList)
	{
	    m_pNetworkAddressList->Release();
	}

	if (NULL != m_pUserDataList)
	{
	    m_pUserDataList->Release();
	}

	//	Delete the Domain Parameters if they exist
	delete m_pDomainParameters;

	//	Delete the User Attachment object if they exist
	if (NULL != m_pMcsUserObject)
    {
        m_pMcsUserObject->Release();
    }

	//	Disconnect from the MCS parent connection
	if (m_hParentConnection != NULL)
	{
		g_pMCSIntf->DisconnectProviderRequest(m_hParentConnection);
	}

	//	Disconnect from all MCS child connections
	m_ConnHandleList.Reset();
	while (0 != (nConnHdl = m_ConnHandleList.Iterate()))
	{
		g_pMCSIntf->DisconnectProviderRequest(nConnHdl);
	}

	//	Delete the MCS domain
	g_pMCSIntf->DeleteDomain(&m_nConfID);

	//	Cleanup up the m_EnrolledApeEidList2
	m_EnrolledApeEidList2.Reset();
	while (NULL != (lpEnrAPEInfo = m_EnrolledApeEidList2.Iterate()))
	{
		if (NULL != lpEnrAPEInfo->session_key)
		{
		    lpEnrAPEInfo->session_key->Release();
		}
		delete lpEnrAPEInfo;
	}

	DebugExitVOID(CConf::~CConf);
}


/*
**	Non-CommandTarget Calls. Initiated from the Owner Object. Note that
**	all calls received from the owner object are preceeded by GCC.
*/


/*
 *	CConf::ConfCreateRequest()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a
 *		ConferenceCreateRequest primitive needs to be processed.
 *		If the calling address equals the called address then an
 *		empty conference is created at this node (this node will
 *		then be both the convenor and the top provider).
 *
 *	Caveats
 *		All errors should be handled directly by the calling application.
 *		This includes deletion of the conference object.
 */
GCCError CConf::
ConfCreateRequest
(
	TransportAddress		calling_address,
	TransportAddress		called_address,
	BOOL					fSecure,
	CPassword               *convener_password,
	CPassword               *password,
	LPWSTR					pwszCallerID,
	PDomainParameters		domain_parameters,
	CUserDataListContainer  *user_data_list,
	PConnectionHandle		connection_handle
)
{
	GCCError				rc = GCC_ALLOCATION_FAILURE;
	ConnectGCCPDU			connect_pdu;
	LPBYTE					encoded_pdu;
	UINT					encoded_pdu_length;
	MCSError				mcs_error;

	DebugEntry(CConf::ConfCreateRequest);

	/*
	**	First make a copy of the new domain parameters if they exists. These
	**	will be copied over when the connect provider confirm comes in.
	*/
	if (NULL != domain_parameters)
	{
		DBG_SAVE_FILE_LINE
		m_pDomainParameters = new DomainParameters;
		if (NULL == m_pDomainParameters)
		{
			ERROR_OUT(("CConf::ConfCreateRequest: can't create DomainParameters"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}

		// structure-wide shallow copy
		*m_pDomainParameters = *domain_parameters;
	}

	/*
	**	If the called address equals NULL this node will be both the Top
	**	Provider and the Convener. In this case there is no need to send out the
	**	ConfCreateRq PDU. Instead we go ahead and create the User Object. If the
	**	conference is created with someone else, wait until the response is
	**	returned before creating the User Object.
	*/
	if (NULL != called_address)
	{
		//	Set up the node type
		m_eNodeType = CONVENER_NODE;

		/*
		**	Create the ConferenceCreateRequest PDU here.
		*/
		connect_pdu.choice = CONFERENCE_CREATE_REQUEST_CHOSEN;
		connect_pdu.u.conference_create_request.bit_mask = 0;

		//	Encode the conference name
		connect_pdu.u.conference_create_request.conference_name.bit_mask = 0;
		
		//	Encode the numeric portion of the name
		::lstrcpyA(connect_pdu.u.conference_create_request.conference_name.numeric,
				m_pszConfNumericName);

		//	Encode the text portion of the conference name if it exists
		if (NULL != m_pwszConfTextName)
		{
			connect_pdu.u.conference_create_request.conference_name.bit_mask |=
					CONFERENCE_NAME_TEXT_PRESENT;
			connect_pdu.u.conference_create_request.conference_name.conference_name_text.value =
					m_pwszConfTextName;
	 		connect_pdu.u.conference_create_request.conference_name.conference_name_text.length =
					::lstrlenW(m_pwszConfTextName);
		}

		//	Encode the convener password if one exists.
		if (NULL != convener_password)
		{
			rc = convener_password->GetPasswordPDU(
						&connect_pdu.u.conference_create_request.ccrq_convener_password);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfCreateRequest: can't get convenor password, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.conference_create_request.bit_mask |=	CCRQ_CONVENER_PASSWORD_PRESENT;
		}

		//	Encode the convener password if one exists.
		if (NULL != password)
		{
			rc = password->GetPasswordPDU(	
							&connect_pdu.u.conference_create_request.ccrq_password);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfCreateRequest: can't get password, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.conference_create_request.bit_mask |=	CCRQ_PASSWORD_PRESENT;
		}

		//	Encode the privilege list
		if (NULL != m_pConductorPrivilegeList)
		{
			rc = m_pConductorPrivilegeList->GetPrivilegeListPDU(	
							&connect_pdu.u.conference_create_request.ccrq_conductor_privs);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfCreateRequest: can't get conductor's privileges, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.conference_create_request.bit_mask |=	CCRQ_CONDUCTOR_PRIVS_PRESENT;
		}
		
		if (NULL != m_pConductModePrivilegeList)
		{
			rc = m_pConductModePrivilegeList->GetPrivilegeListPDU(	
							&connect_pdu.u.conference_create_request.ccrq_conducted_privs);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfCreateRequest: can't get conduct mode privileges, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.conference_create_request.bit_mask |=	CCRQ_CONDUCTED_PRIVS_PRESENT;
		}
		
		if (NULL != m_pNonConductModePrivilegeList)
		{
			rc = m_pNonConductModePrivilegeList->GetPrivilegeListPDU(	
							&connect_pdu.u.conference_create_request.ccrq_non_conducted_privs);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfCreateRequest: can't get non-conduct mode privileges, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.conference_create_request.bit_mask |=	
											CCRQ_NON_CONDUCTED_PRIVS_PRESENT;
		}
		
		//	Encode the conference descriptor
		if (NULL != m_pwszConfDescription)
		{
			connect_pdu.u.conference_create_request.bit_mask |=	CCRQ_DESCRIPTION_PRESENT;

			connect_pdu.u.conference_create_request.ccrq_description.length =
						::lstrlenW(m_pwszConfDescription);

			connect_pdu.u.conference_create_request.ccrq_description.value =
						m_pwszConfDescription;
		}

		//	Encode the caller identifier if on exists.
		if (NULL != pwszCallerID)
		{
			connect_pdu.u.conference_create_request.bit_mask |= CCRQ_CALLER_ID_PRESENT;
			connect_pdu.u.conference_create_request.ccrq_caller_id.length = ::lstrlenW(pwszCallerID);
			connect_pdu.u.conference_create_request.ccrq_caller_id.value = pwszCallerID;
		}
		
		//	Encode the user data if any exists
		if (NULL != user_data_list)
		{
			rc = user_data_list->GetUserDataPDU(
					&connect_pdu.u.conference_create_request.ccrq_user_data);
			if (GCC_NO_ERROR != NULL)
			{
				ERROR_OUT(("CConf::ConfCreateRequest: can't get user data, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.conference_create_request.bit_mask |= CCRQ_USER_DATA_PRESENT;
		}

		connect_pdu.u.conference_create_request.conference_is_locked = (ASN1bool_t)m_fConfLocked;
		connect_pdu.u.conference_create_request.conference_is_listed = (ASN1bool_t)m_fConfListed;
		connect_pdu.u.conference_create_request.conference_is_conductible = (ASN1bool_t)m_fConfConductible;
		connect_pdu.u.conference_create_request.termination_method = (TerminationMethod)m_eTerminationMethod;

		if (! g_GCCCoder->Encode((LPVOID) &connect_pdu,
									CONNECT_GCC_PDU,
									PACKED_ENCODING_RULES,
									&encoded_pdu,
									&encoded_pdu_length))
		{
			ERROR_OUT(("CConf::ConfCreateRequest: can't encode"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

		mcs_error = g_pMCSIntf->ConnectProviderRequest (
							&m_nConfID,     // calling domain selector
							&m_nConfID,     // called domain selector
							calling_address,
							called_address,
							fSecure,
							TRUE,			// Upward connection
							encoded_pdu,
							encoded_pdu_length,
							&m_hParentConnection,
							m_pDomainParameters,
							this);

		g_GCCCoder->FreeEncoded(encoded_pdu);
		*connection_handle = m_hParentConnection;

		if (MCS_NO_ERROR != mcs_error)
		{
			ERROR_OUT(("CConf::ConfCreateRequest: ConnectProviderRequest call failed, rc=%d", mcs_error));

			/*
			**	DataBeam's current implementation of MCS returns
			**	MCS_INVALID_PARAMETER when something other than
			**	the transport prefix is wrong with the specified
			**	transport address.
			*/
			rc = (mcs_error == MCS_INVALID_PARAMETER) ?
					GCC_INVALID_TRANSPORT_ADDRESS :
					g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
			goto MyExit;
		}
		
		//	Free the privilege list packed into structures for encoding
		if (connect_pdu.u.conference_create_request.bit_mask & CCRQ_CONDUCTOR_PRIVS_PRESENT)
		{
			m_pConductorPrivilegeList->FreePrivilegeListPDU(
				connect_pdu.u.conference_create_request.ccrq_conductor_privs);
		}

		if (connect_pdu.u.conference_create_request.bit_mask & CCRQ_CONDUCTED_PRIVS_PRESENT)
		{
			m_pConductModePrivilegeList->FreePrivilegeListPDU(
				connect_pdu.u.conference_create_request.ccrq_conducted_privs);
		}

		if (connect_pdu.u.conference_create_request.bit_mask & CCRQ_NON_CONDUCTED_PRIVS_PRESENT)
		{
			m_pNonConductModePrivilegeList->FreePrivilegeListPDU(
				connect_pdu.u.conference_create_request.ccrq_non_conducted_privs);
		}
	}
	else
	{
		*connection_handle = NULL;
		m_eNodeType = TOP_PROVIDER_AND_CONVENER_NODE;
		DBG_SAVE_FILE_LINE
		m_pMcsUserObject = new MCSUser(this, 0, 0, &rc);
		if (NULL == m_pMcsUserObject || GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf: ConfCreateRequest: can't create mcs user object, rc=%d", rc));
            if (NULL != m_pMcsUserObject)
            {
                m_pMcsUserObject->Release();
			    m_pMcsUserObject = NULL;
            }
            else
            {
 			    rc = GCC_ALLOCATION_FAILURE; // rc may be a different value
            }
			goto MyExit;
		}
	}

	m_fSecure = fSecure;

	rc = GCC_NO_ERROR;

MyExit:

	if (GCC_NO_ERROR != rc)
	{
		if (NULL != domain_parameters)
		{
			delete m_pDomainParameters;
			m_pDomainParameters = NULL;
		}
	}

	DebugExitINT(CConf::ConferenceCreateRequest, rc);
	return rc;
}


/*
 *	CConf::ConfCreateResponse ()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a
 *		ConferenceCreateResponse primitive needs to be processed.
 *		Note that this should only be called when the result of
 *		the response is success. Only the top provider receives the
 *		conference create response.
 *
 *	Caveats
 *		All errors should be handled directly by the calling application.
 *		This includes deletion of the conference object and notification
 *		to the node controller that the conference was abnormally
 *		terminated.
 */
GCCError CConf::
ConfCreateResponse
(
	ConnectionHandle        connection_handle,
	PDomainParameters       domain_parameters,
	CUserDataListContainer  *user_data_list
)
{
	GCCError rc = GCC_ALLOCATION_FAILURE;

	DebugEntry(CConf::ConfCreateResponse);

	//	Conference Create Responses can only be received at the top provider
	m_eNodeType = TOP_PROVIDER_NODE;

	/*
	**	First make a copy of the new domain parameters if they exists.  We do
	**	this here so that they can be passed in when we perform the Connect
	**	Provider Response.
	*/
	if (domain_parameters != NULL)
	{
		DBG_SAVE_FILE_LINE
		m_pDomainParameters = new DomainParameters;
		if (NULL == m_pDomainParameters)
		{
			ERROR_OUT(("CConf::ConfCreateResponse: can't create domain parameters"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}

		// structure-wide shallow copy
		*m_pDomainParameters = *domain_parameters;
	}

	//	Store the child connection in the list of connection handles
    ASSERT(0 != connection_handle);
	m_ConnHandleList.Append(connection_handle);

	/*	
	**	The convener connection handle is stored seperately so that
	**	the Connect Provider response can be sent on the right
	**	connection.  This may be overkill but I was a little concerned
	**	about pulling this out of the list even though this should be
	**	the only entry in the list when it's time to send the response.
	*/
	m_hConvenerConnection = connection_handle;
	
	if (user_data_list != NULL)
	{
		/*
		**	Since we must wait until the user attachment is fully
		**	established	before we send the response we must save the user
		**	data list in a temporary container.
		*/
		m_pUserDataList = user_data_list;
		
		//	Lock the user data in memory
		m_pUserDataList->LockUserDataList();
	}

	/*
	**	Now create the user attachment object and wait for the confirm
	**	which occurs after all the proper channels are joined. The
	**	user object will determine the top provider ID. When the user
	**	create confirm is received the response PDU will be sent out
	**	in the Connect Provider Response.
	*/
	DBG_SAVE_FILE_LINE
	m_pMcsUserObject = new MCSUser(this, 0, 0, &rc);
	if (NULL == m_pMcsUserObject || GCC_NO_ERROR != rc)
	{
		ERROR_OUT(("CConf::ConfCreateResponse: can't create mcs user object, rc=%d", rc));
        if (NULL != m_pMcsUserObject)
        {
            m_pMcsUserObject->Release();
		    m_pMcsUserObject = NULL;
        }
        else
        {
		    rc = GCC_ALLOCATION_FAILURE; // rc may be a different value
        }
		goto MyExit;
	}

	rc = GCC_NO_ERROR;

MyExit:

	if (GCC_NO_ERROR != rc)
	{
		if (NULL != domain_parameters)
		{
			delete m_pDomainParameters;
			m_pDomainParameters = NULL;
		}
	}

	DebugExitINT(CConf::ConferenceCreateResponse, rc);
	return rc;
}


/*
 *	CConf::ConfJoinRequest()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a
 *		ConferenceJoinRequest primitive received from the node controller needs
 *		to be processed.  This routine sends a JoinRequest PDU to its parent
 *		node through an MCS Connect Provider Request.
 *
 *	Caveats
 *		All errors should be handled directly by the calling application.
 *		This includes deletion of the conference object.
 */
GCCError CConf::
ConfJoinRequest
(
	GCCNumericString				called_node_modifier,
	CPassword                       *convener_password,
	CPassword                       *password_challenge,
	LPWSTR							pwszCallerID,
	TransportAddress				calling_address,
	TransportAddress				called_address,
	BOOL							fSecure,
	PDomainParameters 				domain_parameters,
	CUserDataListContainer		    *user_data_list,
	PConnectionHandle				connection_handle
)
{
	GCCError				rc = GCC_ALLOCATION_FAILURE;
	LPBYTE					encoded_pdu;
	UINT					encoded_pdu_length;
	MCSError				mcs_error;
	ConnectGCCPDU			connect_pdu;

	DebugEntry(CConf::ConfJoinRequest);

	ASSERT(FALSE == m_fSecure);
	m_fSecure = fSecure;

	/*
	**	First make a copy of the new domain parameters if they exists. These
	**	will be copied over when the connect provider confirm comes in.
	*/
	if (domain_parameters != NULL)
	{
		DBG_SAVE_FILE_LINE
		m_pDomainParameters = new DomainParameters;
		if (NULL == m_pDomainParameters)
		{
			ERROR_OUT(("CConf::ConfJoinRequest: can't create domain parameters"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}

		*m_pDomainParameters = *domain_parameters;
	}

	m_eNodeType = (NULL == convener_password) ?
					//	Node type must be joined when receiving this request
					JOINED_NODE :
					//	Node type must be joined convener when receiving this request
 					JOINED_CONVENER_NODE;
	
	//	Create the ConferenceJoinRequest PDU here.
	connect_pdu.choice = CONNECT_JOIN_REQUEST_CHOSEN;

	connect_pdu.u.connect_join_request.bit_mask = CONFERENCE_NAME_PRESENT;

	if (NULL != m_pszConfNumericName && '\0' != *m_pszConfNumericName)
	{
		//	Send the numeric portion of the conference name
		connect_pdu.u.connect_join_request.conference_name.choice = NAME_SELECTOR_NUMERIC_CHOSEN;

		::lstrcpyA(connect_pdu.u.connect_join_request.conference_name.u.name_selector_numeric,
				m_pszConfNumericName);
	}
	else
	{
		//	Send the text portion of the conference name
		connect_pdu.u.connect_join_request.conference_name.choice = NAME_SELECTOR_TEXT_CHOSEN;

		connect_pdu.u.connect_join_request.conference_name.u.name_selector_text.length =
						::lstrlenW(m_pwszConfTextName);
		connect_pdu.u.connect_join_request.conference_name.u.name_selector_text.value =
						m_pwszConfTextName;
	}
	
	//	Fill in the remote node modifier if one exists
	if (NULL != called_node_modifier)
	{
		//	Save the remote modifier so that it can be returned in the confirm
		if (NULL == (m_pszRemoteModifier = ::My_strdupA(called_node_modifier)))
		{
			ERROR_OUT(("CConf::ConfJoinRequest: can't create remote modifier"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}

		connect_pdu.u.connect_join_request.bit_mask |= CJRQ_CONFERENCE_MODIFIER_PRESENT;
		::lstrcpyA(connect_pdu.u.connect_join_request.cjrq_conference_modifier,
				   (LPCSTR) called_node_modifier);
	}
	
	//	Fill in the convener password selector.
	if (NULL != convener_password)
	{
		rc = convener_password->GetPasswordSelectorPDU(
						&connect_pdu.u.connect_join_request.cjrq_convener_password);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfJoinRequest: can't get password selector, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.connect_join_request.bit_mask |= CJRQ_CONVENER_PASSWORD_PRESENT;
	}

	//	Fill in the password challenge
	if (NULL != password_challenge)
	{
		rc = password_challenge->GetPasswordChallengeResponsePDU(
							&connect_pdu.u.connect_join_request.cjrq_password);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfJoinRequest: can't get password challenge response, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.connect_join_request.bit_mask |=CJRQ_PASSWORD_PRESENT;
	}


	//	Fill in the caller identifier if one exists
	if (NULL != pwszCallerID)
	{
		connect_pdu.u.connect_join_request.bit_mask |= CJRQ_CALLER_ID_PRESENT;
		connect_pdu.u.connect_join_request.cjrq_caller_id.value = pwszCallerID;
		connect_pdu.u.connect_join_request.cjrq_caller_id.length = ::lstrlenW(pwszCallerID);
	}

	//	Fill in the user data if it exists
	if (NULL != user_data_list)
	{
		rc = user_data_list->GetUserDataPDU(
						&connect_pdu.u.connect_join_request.cjrq_user_data);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfJoinRequest: can't get user data, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.connect_join_request.bit_mask |= CJRQ_USER_DATA_PRESENT;
	}

	if (! g_GCCCoder->Encode((LPVOID) &connect_pdu,
								CONNECT_GCC_PDU,
								PACKED_ENCODING_RULES,
								&encoded_pdu,
								&encoded_pdu_length))
	{
		ERROR_OUT(("CConf::ConfJoinRequest: can't encode"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	/*
	**	Note that the TransportStrings are casted twice here.  It
	**	must be done this way to satisfy the compiler.  Sorry about
	**	not adhearing to coding standards.
	*/
	mcs_error = g_pMCSIntf->ConnectProviderRequest(
						&m_nConfID,     // calling domain selector
						&m_nConfID,     // called domain selector
						calling_address,
						called_address,
						m_fSecure,
						TRUE,	// Upward connection
						encoded_pdu,
						encoded_pdu_length,
						&m_hParentConnection,
						m_pDomainParameters,
						this);

	g_GCCCoder->FreeEncoded(encoded_pdu);

	*connection_handle = m_hParentConnection;

	if (MCS_NO_ERROR != mcs_error)
	{
		ERROR_OUT(("CConf::ConfJoinRequest: can't connect provider request, rc=%d", mcs_error));
	
		/*
		**	DataBeam's current implementation of MCS returns
		**	MCS_INVALID_PARAMETER when something other than
		**	the transport prefix is wrong with the specified
		**	transport address.
		*/
		rc = (mcs_error == MCS_INVALID_PARAMETER) ?
				GCC_INVALID_TRANSPORT_ADDRESS :
				g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
		goto MyExit;
	}

	rc = GCC_NO_ERROR;

MyExit:

	if (GCC_NO_ERROR != rc)
	{
		if (NULL != domain_parameters)
		{
			delete m_pDomainParameters;
			m_pDomainParameters = NULL;
		}

		if (NULL != called_node_modifier)
		{
			delete m_pszRemoteModifier;
			m_pszRemoteModifier = NULL;
		}
	}

	DebugExitINT(CConf:ConferenceJoinRequest, rc);
	return rc;
}

/*
 *	CConf::ForwardConfJoinRequest ()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a conference join
 *		request is received for a conference that is at a node that is not the
 *		Top Provider.  This routine forwards the request on up to the Top
 *		Provider.
 *
 *	Caveats
 *		This routine should never be called if this node is the Top Provider.
 */
GCCError CConf::
ForwardConfJoinRequest
(
	CPassword               *convener_password,
	CPassword               *password_challange,
	LPWSTR					pwszCallerID,
	CUserDataListContainer  *user_data_list,
	BOOL					numeric_name_present,
	ConnectionHandle		connection_handle
)
{
	GCCError rc;

	DebugEntry(CConf::ForwardConfJoinRequest);

	/*
	**	If the node is the top provider we will go ahead and send the
	**	join indication to the node controller, otherwise we will pass
	**	the request on up to the top provider.
	*/
	if (IsConfTopProvider())
	{
		WARNING_OUT(("CConf::GCCConferenceJoinIndication: not top provider"));
		rc = GCC_INVALID_CONFERENCE;
		goto MyExit;
	}

	/*
	**	The connection handle is used as the tag which is sent in the request
	**	and returned in the response.  Note that it is the user objects
	**	responsiblity to resolve any type conflicts with the tag.
	*/
	if (NULL == m_pMcsUserObject)
	{
		ERROR_OUT(("CConf::GCCConferenceJoinIndication: invalid mcs user object"));
		rc = GCC_INVALID_CONFERENCE;
		goto MyExit;
	}

	/*
	**	This list holds information about the conference name alias that
	**	must be returned in the join response.  When the reponse comes
	**	back from the top provider, the information can be obtained from
	**	this list.
	*/
    m_JoinRespNamePresentConnHdlList2.Append(connection_handle, numeric_name_present ? TRUE_PTR : FALSE_PTR);

	//	The user object is responsible for encoding this PDU
	rc = m_pMcsUserObject->ConferenceJoinRequest(convener_password,
													password_challange,
													pwszCallerID,
													user_data_list,
													connection_handle);
MyExit:

	DebugExitINT(CConf::ForwardConfJoinRequest, rc);
	return rc;
}

/*
 *	CConf::ConfJoinIndResponse()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a
 *		ConferenceJoinResponse primitive is received from the node controller.
 *		It is also called when a ConferenceJoinResponse is received from the
 *		Top Provider.
 *
 *	Caveats
 *		If the GCC_DOMAIN_PARAMETERS_UNACCEPTABLE error is returned from this
 *		routine, MCS will automatically reject the connection sending a
 *		result to the other side stating the the Domain Parameters were
 *		unacceptable.
 */
GCCError CConf::
ConfJoinIndResponse
(
	ConnectionHandle	    connection_handle,
	CPassword               *password_challenge,
	CUserDataListContainer  *user_data_list,
	BOOL				    numeric_name_present,
	BOOL				    convener_is_joining,
	GCCResult			    result
)
{
	GCCError				rc = GCC_NO_ERROR;
	MCSError				mcs_error;
	LPBYTE					encoded_pdu;
	UINT					encoded_pdu_length;
	ConnectGCCPDU			connect_pdu;
	Result					mcs_result;

	DebugEntry(CConf::ConfJoinIndResponse);

	//	Set up the MCS result for the connect provider response.
	mcs_result = (result == GCC_RESULT_SUCCESSFUL) ?
					RESULT_SUCCESSFUL :
					RESULT_USER_REJECTED;

	//	Encode the PDU
	connect_pdu.choice = CONNECT_JOIN_RESPONSE_CHOSEN;	
	connect_pdu.u.connect_join_response.bit_mask = CJRS_NODE_ID_PRESENT;

	if (result == GCC_RESULT_SUCCESSFUL)
	{
		//	Check to see if it is necessary to send the conference name alias
		if (numeric_name_present && (m_pwszConfTextName != NULL))
		{
			connect_pdu.u.connect_join_response.bit_mask |= CONFERENCE_NAME_ALIAS_PRESENT;

			connect_pdu.u.connect_join_response.conference_name_alias.choice =
							NAME_SELECTOR_TEXT_CHOSEN;

			connect_pdu.u.connect_join_response.conference_name_alias.u.name_selector_text.value =	
							m_pwszConfTextName;

			connect_pdu.u.connect_join_response.conference_name_alias.u.name_selector_text.length =	
							::lstrlenW(m_pwszConfTextName);
		}
		else
		if (! numeric_name_present)
		{
			connect_pdu.u.connect_join_response.bit_mask |=
							CONFERENCE_NAME_ALIAS_PRESENT;

			connect_pdu.u.connect_join_response.conference_name_alias.choice =
							NAME_SELECTOR_NUMERIC_CHOSEN;

			lstrcpy (connect_pdu.u.connect_join_response.conference_name_alias.u.name_selector_numeric,
					m_pszConfNumericName);
		}

		//	Get the conductor privilege list
		if (NULL != m_pConductorPrivilegeList)
		{
			rc = m_pConductorPrivilegeList->GetPrivilegeListPDU(
							&connect_pdu.u.connect_join_response.cjrs_conductor_privs);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfJoinIndResponse: can't get privilege, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.connect_join_response.bit_mask |= CJRS_CONDUCTOR_PRIVS_PRESENT;
		}
		
		//	Get the conducted mode privilege list
		if (NULL != m_pConductModePrivilegeList)
		{
			rc = m_pConductModePrivilegeList->GetPrivilegeListPDU(
							&connect_pdu.u.connect_join_response.cjrs_conducted_privs);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfJoinIndResponse: can't get conduct mode privilege, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.connect_join_response.bit_mask |= CJRS_CONDUCTED_PRIVS_PRESENT;
		}
		
		//	Get the non conducted mode privilege list
		if (NULL != m_pNonConductModePrivilegeList)
		{
			rc = m_pNonConductModePrivilegeList->GetPrivilegeListPDU(
							&connect_pdu.u.connect_join_response.cjrs_non_conducted_privs);
		
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::ConfJoinIndResponse: can't get non-conduct mode privilege, rc=%d", rc));
				goto MyExit;
			}

			connect_pdu.u.connect_join_response.bit_mask |= CJRS_NON_CONDUCTED_PRIVS_PRESENT;
		}
		
		//	Get the conference description
		if (NULL != m_pwszConfDescription)
		{
			connect_pdu.u.connect_join_response.cjrs_description.length =
									::lstrlenW(m_pwszConfDescription);
			connect_pdu.u.connect_join_response.cjrs_description.value =
									m_pwszConfDescription;
			connect_pdu.u.connect_join_response.bit_mask |= CJRS_DESCRIPTION_PRESENT;
		}
	}
	
	//	Get the password challenge
	if (NULL != password_challenge)
	{
		rc = password_challenge->GetPasswordChallengeResponsePDU (
							&connect_pdu.u.connect_join_response.cjrs_password);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfJoinIndResponse: can't get password challenge response, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.connect_join_response.bit_mask |= CJRS_PASSWORD_PRESENT;
	}

	//	Get the user data list
	if (NULL != user_data_list)
	{
		rc = user_data_list->GetUserDataPDU(&connect_pdu.u.connect_join_response.cjrs_user_data);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfJoinIndResponse: can't get user data, rc=%d", rc));
			goto MyExit;
		}

		connect_pdu.u.connect_join_response.bit_mask |= CJRS_USER_DATA_PRESENT;
	}

	connect_pdu.u.connect_join_response.tag = GetNewUserIDTag ();

	/*
	**	if this is the convener rejoining the conference, we save
	**	the user id tag so that we can record the convener id when it
	**	is returned in the user id indication.
	*/	
	if (convener_is_joining &&
		((m_eNodeType == TOP_PROVIDER_NODE) ||
		 (m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE)))
	{
		m_nConvenerUserIDTagNumber = connect_pdu.u.connect_join_response.tag;
	}

	connect_pdu.u.connect_join_response.cjrs_node_id = m_pMcsUserObject->GetMyNodeID();
	connect_pdu.u.connect_join_response.top_node_id = m_pMcsUserObject->GetTopNodeID();
	connect_pdu.u.connect_join_response.clear_password_required = (ASN1bool_t)m_fClearPassword;
	connect_pdu.u.connect_join_response.conference_is_locked = (ASN1bool_t)m_fConfLocked;
	connect_pdu.u.connect_join_response.conference_is_listed = (ASN1bool_t)m_fConfListed;
	connect_pdu.u.connect_join_response.conference_is_conductible = (ASN1bool_t)m_fConfConductible;
	connect_pdu.u.connect_join_response.termination_method = (TerminationMethod)m_eTerminationMethod;
	connect_pdu.u.connect_join_response.result = ::TranslateGCCResultToJoinResult(result);

	if (! g_GCCCoder->Encode((LPVOID) &connect_pdu,
								CONNECT_GCC_PDU,
								PACKED_ENCODING_RULES,
								&encoded_pdu,
								&encoded_pdu_length))
	{
		ERROR_OUT(("CConf::ConfJoinIndResponse: can't encode"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	mcs_error = g_pMCSIntf->ConnectProviderResponse(
									connection_handle,
									&m_nConfID,
									m_pDomainParameters,
									mcs_result,
									encoded_pdu,
									encoded_pdu_length);

	g_GCCCoder->FreeEncoded(encoded_pdu);

	if ((mcs_error == MCS_NO_ERROR) &&
		(result == GCC_RESULT_SUCCESSFUL))
	{
		/*
		**	Add the connection handle to our list of
		**	connection handles.
		*/
        ASSERT(0 != connection_handle);
		m_ConnHandleList.Append(connection_handle);

		/*
		**	Add the user's tag number to the list of outstanding
		**	user ids along with its associated connection.
		*/
		m_ConnHdlTagNumberList2.Append(connect_pdu.u.connect_join_response.tag, connection_handle);
	}
	else
	{
		WARNING_OUT(("CConf::ConfJoinIndResponse: ConnectProviderResponse failed, mcs_error=%d, result=%d", mcs_error, result));
		rc = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
		goto MyExit;
	}

	//	Free up any memory allocated by the conatiners to build the PDU structs
	if (connect_pdu.u.connect_join_response.bit_mask & CJRS_CONDUCTOR_PRIVS_PRESENT)
	{
		m_pConductorPrivilegeList->FreePrivilegeListPDU(
				connect_pdu.u.connect_join_response.cjrs_conductor_privs);
	}

	if (connect_pdu.u.connect_join_response.bit_mask & CJRS_CONDUCTED_PRIVS_PRESENT)
	{
		m_pConductModePrivilegeList->FreePrivilegeListPDU(
				connect_pdu.u.connect_join_response.cjrs_conducted_privs);
	}

	if (connect_pdu.u.connect_join_response.bit_mask & CJRS_NON_CONDUCTED_PRIVS_PRESENT)
	{
		m_pNonConductModePrivilegeList->FreePrivilegeListPDU(
				connect_pdu.u.connect_join_response.cjrs_non_conducted_privs);
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

    if (GCC_NO_ERROR != rc)
    {
        g_pGCCController->FailConfJoinIndResponse(m_nConfID, connection_handle);
    }

    g_pGCCController->RemoveConfJoinInfo(connection_handle);

	DebugExitINT(CConf::ConfJoinIndResponse, rc);
	return rc;
}

/*
 *	CConf::ConfInviteResponse()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a
 *		ConferenceInviteResponse primitive needs to be processed.
 */
GCCError CConf::
ConfInviteResponse
(
	UserID				    parent_user_id,
	UserID				    top_user_id,
	TagNumber			    tag_number,
	ConnectionHandle        connection_handle,
	BOOL					fSecure,
	PDomainParameters       domain_parameters,
	CUserDataListContainer  *user_data_list
)
{
	GCCError					rc = GCC_ALLOCATION_FAILURE;
	LPBYTE						encoded_pdu;
	UINT						encoded_pdu_length;
	MCSError					mcs_error;
	ConnectGCCPDU				connect_pdu;

	DebugEntry(CConf::ConfInviteResponse);

	ASSERT(FALSE == m_fSecure);
	m_fSecure = fSecure;

	//	First make a copy of the new domain parameters if they exists
	if (domain_parameters != NULL)
	{
		DBG_SAVE_FILE_LINE
		m_pDomainParameters = new DomainParameters;
		if (NULL == m_pDomainParameters)
		{
			ERROR_OUT(("CConf::ConfInviteResponse: can't create domain parameters"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}

		// structure-wide shallow copy
		*m_pDomainParameters = *domain_parameters;
	}

 	m_eNodeType = INVITED_NODE;

	m_nParentIDTagNumber = tag_number;
	m_hParentConnection = connection_handle;

	/*
	**	First we must send the invite response back to the requester.
	**	If we've gotten this far it will always be a positive response.
	*/

	//	Create the ConferenceInviteRequest PDU here.
	connect_pdu.choice = CONFERENCE_INVITE_RESPONSE_CHOSEN;
	connect_pdu.u.conference_invite_response.bit_mask = 0;

	if (user_data_list != NULL)
	{
		rc = user_data_list->GetUserDataPDU(
						&connect_pdu.u.conference_invite_response.cirs_user_data);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::ConfInviteResponse: can't get user data, rc=%d", rc));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
			goto MyExit;
		}

		connect_pdu.u.conference_invite_response.bit_mask |= CIRS_USER_DATA_PRESENT;
	}

	connect_pdu.u.conference_invite_response.result =
			::TranslateGCCResultToInviteResult(GCC_RESULT_SUCCESSFUL);
	if (! g_GCCCoder->Encode((LPVOID) &connect_pdu,
								CONNECT_GCC_PDU,
								PACKED_ENCODING_RULES,
								&encoded_pdu,
								&encoded_pdu_length))
	{
		ERROR_OUT(("CConf::ConfInviteResponse: can't encode"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	/*
	**	Note that the TransportStrings are casted twice here.  It
	**	must be done this way to satisfy the compiler.  Sorry about
	**	not adhearing to coding standards.
	*/
	mcs_error = g_pMCSIntf->ConnectProviderResponse (
										connection_handle,
										&m_nConfID,
										m_pDomainParameters,
										RESULT_SUCCESSFUL,
										encoded_pdu,
										encoded_pdu_length);

	g_GCCCoder->FreeEncoded(encoded_pdu);

	if (MCS_NO_ERROR != mcs_error)
	{
		WARNING_OUT(("CConf::ConfInviteResponse: ConnectProviderRequest failed: rc=%d", mcs_error));
		rc = g_pMCSIntf->TranslateMCSIFErrorToGCCError(mcs_error);
		goto MyExit;
	}

	/*
	**	Now create the user attachment object and wait for the
	**	confirm which occurs after all the proper channels are
	**	joined. The user object will determine the top provider ID.
	**	When the user create confirm is received the response PDU
	**	will be sent out in the Connect Provider Response.
	*/
	DBG_SAVE_FILE_LINE
	m_pMcsUserObject = new MCSUser(this, top_user_id, parent_user_id, &rc);
	if (NULL == m_pMcsUserObject || GCC_NO_ERROR != rc)
	{
		ERROR_OUT(("CConf::ConfInviteResponse: Creation of User Attachment failed, rc=%d", rc));
        if (NULL != m_pMcsUserObject)
        {
            m_pMcsUserObject->Release();
		    m_pMcsUserObject = NULL;
        }
        else
        {
		    rc = GCC_ALLOCATION_FAILURE;
        }
		goto MyExit;
	}

	rc = GCC_NO_ERROR;

MyExit:

	if (GCC_NO_ERROR != rc)
	{
		if (NULL != domain_parameters)
		{
			delete m_pDomainParameters;
			m_pDomainParameters = NULL;
		}
	}	

	DebugExitINT(CConf::ConfInviteResponse, rc);
    return rc;
}


/*
 *	CConf::RegisterAppSap()
 *
 *	Public Function Description
 *		This routine is called from the owner object whenever an application
 *		SAP becomes a candidate for Enrollment.  This will happen whenever
 *		Applications SAPs exists at the same time a conference becomes
 *		established.  It will also be called whenever a conference exists
 *		and a new application SAP is created.
 */
GCCError CConf::
RegisterAppSap ( CAppSap *pAppSap )
{
	GCCError				rc;
	GCCConferenceName		conference_name;
	GCCNumericString		conference_modifier;

	DebugEntry(CConf::RegisterAppSap);

	if (m_fConfIsEstablished)
	{
    	/*
    	**	We first check to see if the application is already registered.
    	**	If so, we do not add it to the list of registered applications
    	**	again.
    	*/
    	if (NULL == m_RegisteredAppSapList.Find(pAppSap))
    	{
    		//	Add the application sap pointer to the registered sap list.
    		pAppSap->AddRef();
    		m_RegisteredAppSapList.Append(pAppSap);

    		/*
    		**	Get the conference name and modifier to send back in the
    		**	permission to enroll indication.
    		*/
    		GetConferenceNameAndModifier(&conference_name, &conference_modifier);

    		//	Inform the application that it can now enroll.	
    		pAppSap->PermissionToEnrollIndication(m_nConfID, TRUE);
    	}

    	rc = GCC_NO_ERROR;
	}
	else
	{
		ERROR_OUT(("CConf::RegisterAppSap: CConf not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf::RegisterAppSap, rc);
	return rc;
}


/*
 *	CConf::UnRegisterAppSap ()
 *
 *	Public Function Description
 *		This routine is called from the owner object whenever an application
 *		SAP becomes unavailable due to whatever reason.  This routine is
 *		responsible for unenrolling any APEs from any rosters that it might have
 *		used this SAP to enroll with.
 */
GCCError CConf::
UnRegisterAppSap ( CAppSap *pAppSap )
{
	GCCError				rc = GCC_NO_ERROR;
	GCCConferenceName		conference_name;
	GCCNumericString		conference_modifier;

	DebugEntry(CConf::UnRegisterAppSap);

	/*
	**	We first check to see if the application is already registered.
	**	If so, we do not add it to the list of registered applications
	**	again.
	*/
	if (! m_RegisteredAppSapList.Find(pAppSap))
	{
		TRACE_OUT(("CConf::UnRegisterAppSap: app not registered"));
		rc = GCC_APPLICATION_NOT_REGISTERED;
		goto MyExit;
	}

	/*
	**	Get the conference name and modifier to send back in the
	**	permission to enroll indication.
	*/
	GetConferenceNameAndModifier(&conference_name, &conference_modifier);

	//	Inform the application that it can no longer enroll.	
	pAppSap->PermissionToEnrollIndication(m_nConfID, FALSE);

	/*
	**	We unenroll the appropriate APE.  Note that we will only send roster updates
	**	if the conference is established.	
	*/
	RemoveSAPFromAPEList(pAppSap);

#if 0   // LONCHANC: UnRegisterAppSap should not affect the roster.
        // Only UnenrollApp will affect the app roster.
	if (m_fConfIsEstablished)
	{
		/*
		**	Here we flush any PDU data or messages that might have gotten
		**	queued up when this SAP we was being unenrolled.
		**	An error here is considered FATAL in that the conference
		**	information base at this node is now corrupted therefore we
		**	terminate the conference.
		*/
		rc = AsynchFlushRosterData();
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::UnRegisterAppSap: can't flush roster data, rc=%d", rc));
            //
            // Do not need to initiate termination because we are
            // either already in termination procedure or
            // the application is going away.
            //
            #if 0
			InitiateTermination((rc == GCC_ALLOCATION_FAILURE) ?
									GCC_REASON_ERROR_LOW_RESOURCES :
									GCC_REASON_ERROR_TERMINATION,
								0);
			#endif // 0
			goto MyExit;
		}
	}
#endif // 0

	//	Remove the application sap from list of registered SAPs
	if (m_RegisteredAppSapList.Remove(pAppSap))
	{
		//
		// Only when this app sap is still in the list, we then can
		// release it. It is possible that this app sap has been
		// unregistered by the app due to permission-to-enroll-ind
		// we just sent earlier.
		//
		pAppSap->Release();
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	DebugExitINT(CConf::UnRegisterAppSap, rc);
	return rc;
}

/*
 *	CConf::AppEnrollRequest()
 *
 *	Public Function Description
 *		This routine is called from the owner object when an
 *		Application is requesting to enroll with this conference.
 *
 *	Caveats
 *		Enroll confirms are performed by the application roster manager so
 *		anyplace where the application roster manager isn't informed of the
 *		enroll we must perform the enroll confirm here in this routine.
 */
GCCError CConf::
AppEnrollRequest
(
    CAppSap             *pAppSap,
    GCCEnrollRequest    *pReq,
    GCCRequestTag       nReqTag
)
{
	GCCError							rc = GCC_NO_ERROR;
	CAppRosterMgr						*pAppRosterMgr;
	CAppRosterMgr						*pNewAppRosterMgr = NULL; // a must
	EntityID							eid, new_eid = GCC_INVALID_EID; // a must
	GCCNodeID                           nid;
	GCCAppEnrollConfirm                 aec;

	DebugEntry(CConf::AppEnrollRequest);

	TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CConf::AppEnrollRequest: "
					"enrolled?=%u\r\n", (UINT) pReq->fEnroll));

	// If the conference is not established return an error.
	if (! m_fConfIsEstablished)
	{
		WARNING_OUT(("CConf::AppEnrollRequest: CConf not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
		goto MyExit;
	}

    if (! m_RegisteredAppSapList.Find(pAppSap))
	{
		WARNING_OUT(("CConf::AppEnrollRequest: app not registered"));
		rc = GCC_APPLICATION_NOT_REGISTERED;
		goto MyExit;
	}

	if (pReq->fEnroll)
	{
		m_cEnrollRequests++;
	}
	else
	{
		m_cEnrollRequests--;
	}

	TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CConf::AppEnrollRequest: cEnroll=%d\r\n", m_cEnrollRequests));

	if (m_cEnrollRequests < 0)
	{
	    //
		// LONCHANC: It seems to me that the upper layer does unenroll without
		// enroll first. it happens when someone calls me.
		// We should change this later and have a way to know whether the app
		// already enrolled or not.
		//
		m_cEnrollRequests = 0;
	}

    // get the node id
    nid = m_pMcsUserObject->GetMyNodeID();

	/*
	**	Is the application enrolling or unenrolling?	Here we set up the
	**	application roster and APE information if enrolling.
	*/
	if (pReq->fEnroll)	//	Appplication is enrolling
	{
		TRACE_OUT(("CConf::AppEnrollRequest: Application is Enrolling"));

		/*
		**	First determine if this APE has already enrolled with this
		**	conference. If it hasn't we must generate a new EntityID for
		**	this APE.
		*/
		rc = GetEntityIDFromAPEList(pAppSap, pReq->pSessionKey, &eid);
		if (rc == GCC_APP_NOT_ENROLLED)
		{
			rc = GenerateEntityIDForAPEList(pAppSap, pReq->pSessionKey, &new_eid);
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::AppEnrollRequest: can't generate entity id, rc=%d", rc));
				goto MyExit;
			}

			eid = new_eid;
			m_pAppRegistry->EnrollAPE(eid, pAppSap);
		}

		/*
		**	This takes care of setting up the application roster manager
		**	if none exists or it will call the appropriate manager with
		**	the enroll.
		*/
		pAppRosterMgr = GetAppRosterManager(pReq->pSessionKey);
		if (pAppRosterMgr == NULL)
		{
			DBG_SAVE_FILE_LINE
			pNewAppRosterMgr = new CAppRosterMgr(
										pReq->pSessionKey,
										NULL,
										m_nConfID,
										m_pMcsUserObject,
										this,
										&rc);
			if (NULL == pNewAppRosterMgr || GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConf::AppEnrollRequest: can't create app roster mgr, rc=%d", rc));
				rc = GCC_ALLOCATION_FAILURE;
				goto MyExit;
			}

			pAppRosterMgr = pNewAppRosterMgr;
		}

		/*
		**	Doing the enroll here ensures that an empty roster
		**	manager will not get put in to the roster manager
		**	list if the Enroll Fails.
		*/
        rc = pAppRosterMgr->EnrollRequest(pReq, eid, nid, pAppSap);
		if (GCC_NO_ERROR != rc)
		{
			ERROR_OUT(("CConf::AppEnrollRequest: EnrollRequest failed, rc=%d", rc));
			goto MyExit;
		}

		/*
		**	If this is a new roster manager we will append it to
		**	the list of roster managers here if no errors occcured.
		*/							
		if (pNewAppRosterMgr != NULL)
		{
			m_AppRosterMgrList.Append(pNewAppRosterMgr);
		}

		/*
		**	Here we inform the newly enrolled application of the
		**	conductor status if the conference is conductible.
		*/
		if (m_fConfConductible)
		{
			if (m_nConductorNodeID != 0)
			{
				pAppSap->ConductorAssignIndication(m_nConductorNodeID, m_nConfID);
			}
			else
			{
				pAppSap->ConductorReleaseIndication(m_nConfID);
			}
		}
	}
	else	//	Appplication is unenrolling
	{
		TRACE_OUT(("CConf::AppEnrollRequest: Application is UnEnrolling"));

		if (pReq->pSessionKey != NULL)
		{
			rc = GetEntityIDFromAPEList(pAppSap, pReq->pSessionKey, &eid);
			if (rc != GCC_NO_ERROR)
			{
				WARNING_OUT(("CConf::AppEnrollRequest: app not enrolled"));
				goto MyExit;
			}

			pAppRosterMgr = GetAppRosterManager(pReq->pSessionKey);
			if (NULL == pAppRosterMgr)
			{
				WARNING_OUT(("CConf::AppEnrollRequest: app not enrolled"));
				rc = GCC_APP_NOT_ENROLLED;
				goto MyExit;
			}

			/*
			**	UnEnroll this APE from the specified session.
			**	Note that the application roster manager will send
			**	the enroll confirm.
			*/
			pAppRosterMgr->UnEnrollRequest(pReq->pSessionKey, eid);

			//	UnEnroll this APE from the registry
			m_pAppRegistry->UnEnrollAPE(eid);

			/*
			**	Since this APE is no longer enrolled remove it from
			**	the list of APEs.
			*/
			DeleteEnrolledAPE(eid);
		}
		else
		{
			TRACE_OUT(("CConf::AppEnrollRequest: null session key"));
			/*
			**	Since a null session key was passed in we will go ahead
			**	and unenroll all the APEs associated with this sap.
			*/
			RemoveSAPFromAPEList(pAppSap);
		}
	}

	/*
	**	Here we take care of sending the enroll confirm to the application
	**	SAP that enrolled.  We also flush any roster PDUs and messages that
	**	might have been queued up during the enrollment process above. Note
	**	that we only send a successful enroll confirm if no errors occured.
	*/	

	ASSERT(GCC_NO_ERROR == rc);

	/*
	**	First we sent the enroll confirm.  It is important to send this
	**	before the flush so that the node ID and entity ID will be
	**	received by a top provider node before the roster is delivered
	**	with the applications record in it.  This makes it easier on the
	**	developer when trying to determine if the enrolled record is in
	**	the roster when the roster report is received.
	*/
	aec.nConfID = m_nConfID;
	aec.sidMyself = pReq->pSessionKey->session_id;
	aec.eidMyself = eid;
	aec.nidMyself = nid;
	aec.nResult = GCC_RESULT_SUCCESSFUL;
	aec.nReqTag = nReqTag;
	pAppSap->AppEnrollConfirm(&aec);

	/*
	**	Now we flush all the application roster managers of any PDU data
	**	that might have been queued up during enrollment.  This also
	**	gives the roster managers a chance to deliver roster update if
	**	necessary.  Note that we build and deliver the high level
	**	portion of the PDU here. Since only application roster stuff will be
	**	sent in this pdu we must set the pointer to the conference
	**	information to NULL so that the encoder wont try to encode it.
	**	An error here is considered FATAL in that the conference information
	**	base at this node is now corrupted therefore we terminate the
	**	conference.  Note that we only do the flush here if the start up
	**	alarm has expired.
	*/
	rc = AsynchFlushRosterData();
	if (rc != GCC_NO_ERROR)
	{
		ERROR_OUT(("CConf::AppEnrollRequest: can't flush roster data, rc=%d", rc));

		InitiateTermination((rc == GCC_ALLOCATION_FAILURE) ?
								GCC_REASON_ERROR_LOW_RESOURCES :
								GCC_REASON_ERROR_TERMINATION,
							0);
		goto MyExit;
	}

	ASSERT(GCC_NO_ERROR == rc);

MyExit:

	if (GCC_NO_ERROR != rc && pReq->fEnroll)
	{
        if (NULL != pNewAppRosterMgr)
        {
            pNewAppRosterMgr->Release();
        }

		if (new_eid != GCC_INVALID_EID)
		{
			//	UnEnroll this APE from the registry
			m_pAppRegistry->UnEnrollAPE(new_eid);
			DeleteEnrolledAPE(new_eid);
		}
	}

	DebugExitINT(CConf::AppEnrollRequest, rc);
	return rc;
}


/*
 *	CConf::DisconnectProviderIndication ()
 *
 *	Public Function Description
 *		This routine is called from the owner object when a
 *		Disconnect Provider is received from the MCS interface.
 *		Since the owner object has no way of knowing which connections
 *		are associated with which conferences it may be possible to
 *		receive a disconnect provider for a connection that is not in
 *		the conferences list.
 */
GCCError CConf::
DisconnectProviderIndication ( ConnectionHandle connection_handle )
{
	GCCError	rc = GCC_NO_ERROR;
	GCCNodeID	nidDisconnected;

	DebugEntry(CConf::DisconnectProviderIndication);

	TRACE_OUT(("CConf::DisconnectProviderIndication: connection_handle = %d", connection_handle));

    // reject any pending join ind response
    ConnectionHandle hConn;
    while (NULL != m_JoinRespNamePresentConnHdlList2.Get(&hConn))
    {
        if (NULL != g_pGCCController)
        {
            g_pGCCController->FailConfJoinIndResponse(0, hConn);
        }
    }

	//	First check for the parent connection going down.
	if (m_hParentConnection == connection_handle)
	{
		TRACE_OUT(("CConf::DisconnectProviderIndication: Connection == PARENT"));

		/*
		**	If the Parent Connection is broken the conference must be
		**	terminated since this node no longer has access to the top
		**	gcc provider.
		*/
		m_hParentConnection = NULL;
	 	InitiateTermination ( GCC_REASON_PARENT_DISCONNECTED, 0);
	}
	else
	{
		/*
		**	Now check to see if this connection is associated with an ejected
		**	node.
		*/
		nidDisconnected = m_pMcsUserObject->GetUserIDFromConnection(connection_handle);
												
		if (m_EjectedNodeConfirmList.Remove(nidDisconnected))
		{
#ifdef JASPER
			g_pControlSap->ConfEjectUserConfirm(m_nConfID,
												nidDisconnected,
												GCC_RESULT_SUCCESSFUL);
#endif // JASPER
		}

		//	If this is the convener set its node id back to 0
		if (m_nConvenerNodeID == nidDisconnected)
			m_nConvenerNodeID = 0;

		//	Inform the User Attachment object that another user disconnected
		m_pMcsUserObject->UserDisconnectIndication (nidDisconnected);

        ASSERT(0 != connection_handle);
		if (m_ConnHandleList.Remove(connection_handle))
		{
			TRACE_OUT(("CConf::DisconnectProviderIndication: Connection = CHILD"));

			/*
			**	If there is a disconnect pending we must send the disconnect
			**	confirm here and terminate the conference.  Note that in this
			**	case, the m_fConfIsEstablished variable was set to FALSE
			**	when the Disconnect Request was issued (therefore a terminate
			**	indication will not be sent).
			*/
			if (m_ConnHandleList.IsEmpty() && m_fConfDisconnectPending)
			{
	        	TRACE_OUT(("CConf::DisconnectProviderIndication: conf disconnect confirm"));
				/*
				**	First inform the control SAP that this node has successfuly
				**	disconnected.
				*/
				g_pControlSap->ConfDisconnectConfirm(m_nConfID, GCC_RESULT_SUCCESSFUL);

				//	Tell the owner object to terminate this conference
				InitiateTermination(GCC_REASON_NORMAL_TERMINATION, m_pMcsUserObject->GetMyNodeID());
			}
			else
			if (m_ConnHandleList.IsEmpty() && m_fConfTerminatePending)
			{
	        	TRACE_OUT(("CConf::DisconnectProviderIndication: Terminate Request is Completed"));

				InitiateTermination(m_eConfTerminateReason, m_pMcsUserObject->GetMyNodeID());
			}
			else
			if (m_ConnHandleList.IsEmpty() &&
				((m_eNodeType == TOP_PROVIDER_NODE) ||
				 (m_eNodeType == TOP_PROVIDER_AND_CONVENER_NODE)) &&
				(m_eTerminationMethod == GCC_AUTOMATIC_TERMINATION_METHOD))
			{
				/*
				**	If nothing is left in our connection list and we are the Top
				**	Provider and automatic termination is enabled then terminate
				**	the conference.
				*/
	        	TRACE_OUT(("CConf::DisconnectProviderIndication: AUTOMATIC_TERMINATION"));

				InitiateTermination( GCC_REASON_NORMAL_TERMINATION, 0);
			}
		}
		else
		{
			rc = GCC_INVALID_PARAMETER;
		}
	}

	DebugExitINT(CConf::DisconnectProviderIndication, rc);
	return rc;
}


/*
 *	void ConfRosterInquireRequest()
 *
 *	Public Function Description
 *		This function is used to obtain a conference roster.  The conference
 *		roster is delivered to the requesting command target in a Conference
 *		Roster inquire confirm.
 */
GCCError CConf::
ConfRosterInquireRequest
(
    CBaseSap            *pSap,
    GCCAppSapMsgEx      **ppMsgEx
)
{
	GCCError				rc = GCC_NO_ERROR;
	CConfRoster				*conference_roster;
	LPWSTR					pwszConfDescription = NULL;
	GCCConferenceName		conference_name;
	GCCNumericString		conference_modifier;

	DebugEntry(CConf::ConfRosterInquireRequest);

	if (m_fConfIsEstablished)
	{
		/*
		**	We use the actual conference roster here to build the roster
		**	inquire confirm message.  Note that the SAP should NOT free this
		**	roster.
		*/
		conference_roster = m_pConfRosterMgr->GetConferenceRosterPointer();
		if (conference_roster != NULL)
		{
        	GetConferenceNameAndModifier(&conference_name, &conference_modifier);
			if (m_pwszConfDescription != NULL)
			{
				pwszConfDescription= m_pwszConfDescription;
			}

			pSap->ConfRosterInquireConfirm(m_nConfID,
											&conference_name,
											conference_modifier,
											pwszConfDescription,
											conference_roster,
											GCC_RESULT_SUCCESSFUL,
                                            ppMsgEx);
		}
		else
		{
			ERROR_OUT(("CConf::ConfRosterInquireRequest: conf roster does not exist"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
	{
		ERROR_OUT(("CConf::ConfRosterInquireRequest: conference not established"));
		rc = GCC_CONFERENCE_NOT_ESTABLISHED;
	}

	DebugExitINT(CConf:ConfRosterInquireRequest, rc);
	return rc;
}


/*
 *	CConf::AppRosterInquireRequest()
 *
 *	Public Function Description
 *		This function is used to obtain a list of application rosters.  This
 *		list is delivered to the requesting SAP through an	Application Roster
 *		inquire confirm message.
 */
GCCError CConf::
AppRosterInquireRequest
(
    PGCCSessionKey      session_key,
    CAppRosterMsg       **ppAppRosterMsgOut
)
{
	GCCError				rc;
	BOOL					roster_manager_found = FALSE;
	CAppRosterMsg			*roster_message = NULL;
	CAppRosterMgr			*lpAppRosterMgr;

	DebugEntry(CConf::AppRosterInquireRequest);

	if (m_AppRosterMgrList.IsEmpty())
	{
		WARNING_OUT(("CConf::AppRosterInquireRequest: app roster mgr is empty"));
		rc = GCC_NO_SUCH_APPLICATION;
		goto MyExit;
	}

	//	First allocate the application roster message
	DBG_SAVE_FILE_LINE
	roster_message = new CAppRosterMsg();
	if (NULL == roster_message)
	{
		ERROR_OUT(("CConf::AppRosterInquireRequest: can't create app roster msg"));
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	rc = GCC_NO_ERROR;

	m_AppRosterMgrList.Reset();
	if (session_key != NULL)
	{										
		while (NULL != (lpAppRosterMgr = m_AppRosterMgrList.Iterate()))
		{
			roster_manager_found = lpAppRosterMgr->IsThisYourSessionKey (session_key);
			if (roster_manager_found)
			{
				rc = lpAppRosterMgr->ApplicationRosterInquire(session_key, roster_message);
				break;
			}
		}
	}
	else
	{
		while (NULL != (lpAppRosterMgr = m_AppRosterMgrList.Iterate()))
		{
			rc = lpAppRosterMgr->ApplicationRosterInquire (NULL, roster_message);
			if (rc != GCC_NO_ERROR)
			    break;
		}
	}

MyExit:

    if (GCC_NO_ERROR == rc)
    {
        *ppAppRosterMsgOut = roster_message;
        // do not call roster_message->Release() because the sap will call it as needed
    }
    else
    {
        if (NULL != roster_message)
        {
            roster_message->Release();
        }
    }

	DebugExitINT(CConf::AppRosterInquireRequest, rc);
	return rc;
}


/*
 *	CConf::FlushOutgoingPDU()
 *
 *	Public Function Description
 *		This is the heartbeat for the conference object. The conference
 *		is responsible for giving the User Attachment object its
 *		heartbeat.
 *	Return value:
 *		TRUE, if there remain un-processed msgs in the CConf message queue
 *		FALSE, if all the msgs in the conference msg queue were processed.
 */
BOOL CConf::
FlushOutgoingPDU ( void )
{
	//GCCError	error_value;
	BOOL		fFlushMoreData = FALSE;

	if (m_fConfTerminatePending && m_pConfTerminateAlarm != NULL)
	{
		if (m_pConfTerminateAlarm->IsExpired())
		{
			delete m_pConfTerminateAlarm;
			m_pConfTerminateAlarm = NULL;
			InitiateTermination(m_eConfTerminateReason, m_pMcsUserObject->GetTopNodeID());
		}
		else
		{
			fFlushMoreData = TRUE;
		}
	}

	if (m_pMcsUserObject != NULL)
	{
	    m_pMcsUserObject->CheckEjectedNodeAlarms();
		fFlushMoreData |= m_pMcsUserObject->FlushOutgoingPDU();
	}

	return fFlushMoreData;
}


/*
 *	BOOL		IsConfEstablished ()
 *
 *	Public Function Description
 *		The conference is established when it is ready to be enrolled
 *		with. No application permission to enrolls should be sent until
 *		this routine returns TRUE.
 */


/*
 *	BOOL		IsConfTopProvider ()
 *
 *	Public Function Description
 *		Function informs whether this node is the Top Provider of the
 *		conference.
 */


/*
 *	GCCNodeID   GetTopProvider ()
 *
 *	Public Function Description
 *		Function returns the GCCNodeID of the Top Provider of the conference.
 */



/*
 *	BOOL		DoesConvenerExists ()
 *
 *	Public Function Description
 *		This function informs whether or not the convener is still joined to
 *		this conference.
 */


/*
 *	LPSTR	GetNumericConfName()
 *
 *	Public Function Description
 *		Returns a pointer to the numeric portion of the conference name.  Used
 *		for comparisons.
 */


/*
 *	LPWSTR	GetTextConfName()
 *
 *	Public Function Description
 *		Returns a pointer to the text portion of the conference name.  Used for
 *		comparisons.
 */


/*
 *	LPSTR	GetConfModifier()
 *
 *	Public Function Description
 *		Returns a pointer to the conference name modifier.
 */


/*
 *	LPWSTR	GetConfDescription()
 *
 *	Public Function Description
 *		Returns a pointer to the conference description.
 */


/*
 *	CNetAddrListContainer *GetNetworkAddressList()
 *
 *	Public Function Description
 *		Returns a pointer to the network address list.
 */


/*
 *	GCCConfID GetConfID()
 *
 *	Public Function Description
 *		Returns the conference ID.
 */


/*
 *	BOOL			IsConfListed()
 *
 *	Public Function Description
 *		Returns the listed flag.
 */


/*
 *	BOOL			IsConfPasswordInTheClear()
 *
 *	Public Function Description
 *		Returns the password protected flag.
 */


/*
 *	BOOL			IsConfLocked()
 *
 *	Public Function Description
 *		Returns the locked flag.
 */


/*
**	These routines operate on the m_EnrolledApeEidList2.
*/

/*
 *	CConf::GetEntityIDFromAPEList ()
 *
 *	Private Function Description
 *		This routine determines what the entity id is for the specified APE
 *		(note that an APE is defined by its SAP handle and the session key
 *		of the session it is enrolled in).  If there is no entity ID associated
 *		with this APE an error is returned.
 *
 *	Formal Parameters:
 *		hSap		-	(i)	SAP handle associated with the entity ID being
 *							searched for.
 *		session_key	-	(i)	Session key associated with the entity ID being
 *							searched for.
 *		entity_id	-	(o)	The found entity ID is returned here (or zero if
 *							none is found).
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured allocating session
 *									key data.
 *		GCC_APP_NOT_ENROLLED	-	Entity ID was not found.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConf::
GetEntityIDFromAPEList
(
    CAppSap             *pAppSap,
    PGCCSessionKey      session_key,
    GCCEntityID         *pEid
)
{
	GCCError			rc = GCC_ALLOCATION_FAILURE;
	CSessKeyContainer   *pSessKey;

	*pEid = GCC_INVALID_EID;

	DBG_SAVE_FILE_LINE
	pSessKey = new CSessKeyContainer(session_key, &rc);
	if (pSessKey != NULL && rc == GCC_NO_ERROR)
	{
        GCCEntityID             eid;
		ENROLLED_APE_INFO		*lpEnrAPEInfo;

		m_EnrolledApeEidList2.Reset();
		while (NULL != (lpEnrAPEInfo = m_EnrolledApeEidList2.Iterate(&eid)))
		{
			if (pAppSap == lpEnrAPEInfo->pAppSap &&
				*pSessKey == *lpEnrAPEInfo->session_key)
			{
				*pEid = eid;
				break;
			}
		}

		if (*pEid == GCC_INVALID_EID)
		{
			TRACE_OUT(("CConf::GetEntityIDFromAPEList: App NOT Enrolled"));
			rc = GCC_APP_NOT_ENROLLED;
		}
	}

	//	Free up the temporary session key.
	if (NULL != pSessKey)
	{
	    pSessKey->Release();
	}

	return rc;
}


/*
 *	CConf::GenerateEntityIDForAPEList ()
 *
 *	Private Function Description
 *		This function is responsible for generating a unqiue entity ID for
 *		the specified APE.
 *
 *	Formal Parameters:
 *		hSap		-	(i)	SAP handle associated with the entity ID being
 *							generated.
 *		session_key	-	(i)	Session key associated with the entity ID being
 *							generated.
 *		entity_id	-	(o)	The generated entity ID is returned here.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConf::
GenerateEntityIDForAPEList
(
    CAppSap             *pAppSap,
    PGCCSessionKey      session_key,
    GCCEntityID         *pEid
)
{
	GCCError			rc = GCC_ALLOCATION_FAILURE;
	CSessKeyContainer   *pSessKey = NULL; // a must
	EntityID			eidOriginal;
	ENROLLED_APE_INFO	*enrolled_ape_info = NULL; // a must

	/*
	**	First find an entity id that has not been used.  If all of the IDs
	**	are in use we return an allocation failure.
	*/
	*pEid = GCC_INVALID_EID;
	eidOriginal = m_nAPEEntityID;
	while (TRUE)
	{
		if (++m_nAPEEntityID != GCC_INVALID_EID)
		{
			if (NULL == m_EnrolledApeEidList2.Find(m_nAPEEntityID))
			{
				// the new entity ID does not exist. job is done.
				*pEid = m_nAPEEntityID;
				break;
			}

			if (m_nAPEEntityID == eidOriginal)
			{
				ERROR_OUT(("CConf::GenerateEntityIDForAPEList: use up all entity IDs"));
				ASSERT(GCC_ALLOCATION_FAILURE == rc);
				goto MyExit;
			}
		}
	}

	ASSERT(GCC_INVALID_EID != *pEid);

	/*
	**	Now if no errors occured we will create the enrolled APE info structure
	**	that will be stored in the enrolled APE list.
	*/
	//
	// LONCHANC: We should avoid this memory allocation. ENROLLED_APE_INFO has only 2 dwords!
	//
	DBG_SAVE_FILE_LINE
	enrolled_ape_info = new ENROLLED_APE_INFO;
	if (NULL == enrolled_ape_info)
	{
		ERROR_OUT(("CConf::GenerateEntityIDForAPEList: can't create ENROLLED_APE_INFO"));
		ASSERT(GCC_ALLOCATION_FAILURE == rc);
		goto MyExit;
	}

	enrolled_ape_info->pAppSap = pAppSap;

	DBG_SAVE_FILE_LINE
	pSessKey = new CSessKeyContainer(session_key, &rc);
	if (pSessKey != NULL && rc == GCC_NO_ERROR)
	{
	    enrolled_ape_info->session_key = pSessKey;
		m_EnrolledApeEidList2.Append(*pEid, enrolled_ape_info);
	}

MyExit:

	if (GCC_NO_ERROR != rc)
	{
		delete enrolled_ape_info;
		if (NULL != pSessKey)
		{
		    pSessKey->Release();
		}
	}

	return rc;
}


/*
 *	CConf::RemoveSAPFromAPEList ()
 *
 *	Private Function Description
 *		This routine takes care of removing all the references to a single
 *		sap from the m_EnrolledApeEidList2.  It is also responsible for unenrolling
 *		all of these APEs from the appropriate Application SAPs.
 *
 *	Formal Parameters:
 *		hSap	-	(i)	SAP handle to remove and unenroll.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConf::
RemoveSAPFromAPEList ( CAppSap *pAppSap )
{
	GCCEntityID					eid;
	ENROLLED_APE_INFO			*lpEnrAPEInfo;		

	/*
	**	We make a temporary copy of the list here so that we can remove
	**	members from it while we are iterating on it.
	*/
	while (NULL != (lpEnrAPEInfo = GetEnrolledAPEbySap(pAppSap, &eid)))
	{
		CAppRosterMgr	*lpAppRosterMgr;
		/*
		**	Here we remove the entities associated with this application
		**	from any application rosters it is enrolled in.
		*/
		m_AppRosterMgrList.Reset();
		while (NULL != (lpAppRosterMgr = m_AppRosterMgrList.Iterate()))
		{
			TRACE_OUT(("CConf::RemoveSAPFromAPEList: remove entity = %d", (int) eid));
			lpAppRosterMgr->RemoveEntityReference(eid);
		}

		/*	
		**	We must remove any references to this SAP from the
		**	registry so that any outstanding request by this SAP
		**	will not be processed.
		*/
		m_pAppRegistry->UnEnrollAPE(eid);

		/*
		**	Since this APE is no longer enrolled remove it from
		**	the list of APEs.
		*/
		DeleteEnrolledAPE(eid);
	}
}

/*
 *	CConf::DoesSAPHaveEnrolledAPE ()
 *
 *	Private Function Description
 *		This routine is responsible for determining if there is a single
 *		(or multiple) APEs enrolled through the specified SAP handle.
 *
 *	Formal Parameters:
 *		sap_handle	-	(i) SAP handle of SAP being checked.
 *
 *	Return Value
 *		TRUE	-	If SAP does have an enrolled APE.
 *		FALSE	-	If SAP does not have an enrolled APE.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */


ENROLLED_APE_INFO *CConf::
GetEnrolledAPEbySap
(
    CAppSap         *pAppSap,
    GCCEntityID     *pEid
)
{
	ENROLLED_APE_INFO	*pEnrAPEInfo;
	GCCEntityID         eid;

	m_EnrolledApeEidList2.Reset();
	while (NULL != (pEnrAPEInfo = m_EnrolledApeEidList2.Iterate(&eid)))
	{
		if (pAppSap == pEnrAPEInfo->pAppSap)
		{
			if (NULL != pEid)
			{
				*pEid = eid;
			}
			return pEnrAPEInfo;
		}
	}
	return NULL;
}


void CConf::
DeleteEnrolledAPE ( EntityID nEntityID )
{
	ENROLLED_APE_INFO *lpEnrAPEInfo;

	if (NULL != (lpEnrAPEInfo = m_EnrolledApeEidList2.Remove(nEntityID)))
	{
		if (NULL != lpEnrAPEInfo->session_key)
		{
		    lpEnrAPEInfo->session_key->Release();
		}
		delete lpEnrAPEInfo;
	}
}


/*
 *	GCCError		FlushRosterData()
 *
 *	Private Function Description
 *		This routine flushes all the application roster managers of any PDU data
 *		that might be queued up.  This also gives the roster managers a chance
 *		to deliver roster update if	necessary.  Note that we build and deliver
 *		the high level portion of the PDU here. Since only application roster
 *		stuff will be sent in this pdu we must set the pointer to the conference
 *		information to NULL so that the encoder wont try to encode it.
 */
GCCError CConf::
AsynchFlushRosterData ( void )
{
    if (NULL != g_pControlSap)
    {
        AddRef();
        ::PostMessage(g_pControlSap->GetHwnd(), CONF_FLUSH_ROSTER_DATA, 0, (LPARAM) this);
    }

    return GCC_NO_ERROR;
}

void CConf::
WndMsgHandler ( UINT uMsg )
{
    if (CONF_FLUSH_ROSTER_DATA == uMsg)
    {
        FlushRosterData();

        //
        // We AddRef while posting the message.
        //
        Release();
    }
    else
    {
        ERROR_OUT(("WndMsgHandler: invalid msg=%u", uMsg));
    }
}

GCCError CConf::
FlushRosterData ( void )
{
    GCCError    rc = GCC_NO_ERROR;

    DebugEntry(CConf::FlushRosterData);

    if (m_fConfIsEstablished)
    {
    	GCCPDU								gcc_pdu;
    	CAppRosterMgrList					RosterMgrDeleteList;
    	CAppRosterMgr						*lpAppRosterMgr;

    	gcc_pdu.choice = INDICATION_CHOSEN;
    	gcc_pdu.u.indication.choice = ROSTER_UPDATE_INDICATION_CHOSEN;
    	gcc_pdu.u.indication.u.roster_update_indication.refresh_is_full = FALSE;
    	gcc_pdu.u.indication.u.roster_update_indication.application_information= NULL;

    	//	First get any CConf Roster PDU data that exists.
    	rc = m_pConfRosterMgr->FlushRosterUpdateIndication(
    		&gcc_pdu.u.indication.u.roster_update_indication.node_information);
    	if (GCC_NO_ERROR != rc)
    	{
    		ERROR_OUT(("CConf::FlushRosterData: can't flush conf roster update, rc=%d", rc));
    		goto MyExit;
    	}

    	if (IsReadyToSendAppRosterUpdate())
    	{
    		PSetOfApplicationInformation		*ppSetOfAppInfo;
    		PSetOfApplicationInformation		pNextSetOfInfo;

    		//	Set up the pointer to the first application information.
    		ppSetOfAppInfo = &gcc_pdu.u.indication.u.roster_update_indication.application_information;

    		/*
    		**	Here we iterate through all the application roster managers
    		**	giving each a chance to append their roster updates to the
    		**	roster update PDU and to deliver any necessary roster update
    		**	messages.
    		*/	
    		m_AppRosterMgrList.Reset();
    		while (NULL != (lpAppRosterMgr = m_AppRosterMgrList.Iterate()))
    		{
    			pNextSetOfInfo = lpAppRosterMgr->FlushRosterUpdateIndication(ppSetOfAppInfo, &rc);
    			if (GCC_NO_ERROR != rc)
    			{
    				ERROR_OUT(("CConf::FlushRosterData: can't flush app roster update, rc=%d", rc));
    				goto MyExit;
    			}

    			if (NULL != pNextSetOfInfo)
    			{
    				ppSetOfAppInfo = &pNextSetOfInfo->next;
    			}

    			/*
    			**	Here we add the application roster manager to the list of
    			**	managers to delete.  They we be deleted and removed from the
    			**	roster manager list below after the	PDU is delivered.	
    			*/
    			if (lpAppRosterMgr->IsEmpty())
    			{
    				m_AppRosterMgrList.Remove(lpAppRosterMgr);
    				RosterMgrDeleteList.Append(lpAppRosterMgr);
    			}
    		}
    	} // if ready-to-send-app-roster-update
    	else
    	{
    		TRACE_OUT(("CConf::FlushRosterData: not ready to send app roster update"));
    		TRACE_OUT(("cApps=%u, m_cEnrollRequests=%u", m_RegisteredAppSapList.GetCount(), m_cEnrollRequests));
    	}

    	/*
    	**	Here, if there are no errors and there is actual application
    	**	information, we go ahead and send out the roster update.
    	*/
    	if (NULL != gcc_pdu.u.indication.u.roster_update_indication.
    										application_information
    		||
    		NODE_NO_CHANGE_CHOSEN != gcc_pdu.u.indication.u.roster_update_indication.
    										node_information.node_record_list.choice)
    	{
    		TRACE_OUT(("CConf::FlushRosterData: sending roster update indication to mcs"));
    		m_pMcsUserObject->RosterUpdateIndication(
    						&gcc_pdu,
    						IsConfTopProvider() ? FALSE : TRUE);
    	}

    	/*
    	**	Here we cleanup any empty roster managers.  Note that we must do this
    	**	after delivering the PDU to avoid deleting a roster manager before
    	**	using data associated with it (data obtained in the flush).
    	*/
    	RosterMgrDeleteList.DeleteList();
    } // if m_fConfIsEstablished

    ASSERT(GCC_NO_ERROR == rc);

MyExit:

    DebugExitINT(CConf::FlushRosterData, rc);
    return rc;
}



#define MIN_REGISTERED_APPS			2

BOOL CConf::
IsReadyToSendAppRosterUpdate ( void )
{
	if (m_fFirstAppRosterSent)
	{
		TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CConf::IsReadyToSendAppRosterUpdate: "
						"YES <first one sent>\r\n"));
		return TRUE;
	}

	BOOL fRet = TRUE;

	if (NULL != m_pConfStartupAlarm &&
		m_pConfStartupAlarm->IsExpired())
	{
		TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CConf::IsReadyToSendAppRosterUpdate: "
						"YES <alarm expired>\r\n"));
		// fRet = TRUE;
	}
	else
	{
		UINT cApps = m_RegisteredAppSapList.GetCount();
		if (cApps >= MIN_REGISTERED_APPS &&
			(int) cApps <= m_cEnrollRequests)
		{
			TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CConf::IsReadyToSendAppRosterUpdate: "
							"YES <cApp=%u, cEnroll=%d>\r\n", cApps, m_cEnrollRequests));
			// fRet = TRUE;
		}
		else
		{
			TRACE_OUT_EX(ZONE_T120_APP_ROSTER, ("CConf::IsReadyToSendAppRosterUpdate: "
							"NO <cApp=%u, cEnroll=%d>\r\n", cApps, m_cEnrollRequests));
			fRet = FALSE;
		}
	}

	if (fRet)
	{
		m_fFirstAppRosterSent = TRUE;
		delete m_pConfStartupAlarm;
		m_pConfStartupAlarm = NULL;
	}

	return fRet;
}


// look for this node ID in the roster's record set.
BOOL CConf::
IsThisNodeParticipant ( GCCNodeID nid )
{
    return ((NULL != m_pConfRosterMgr) ?
                        m_pConfRosterMgr->IsThisNodeParticipant(nid) :
                        FALSE);
}



void CConfList::
DeleteList ( void )
{
    CConf *pConf;
    while (NULL != (pConf = Get()))
    {
        pConf->Release();
    }
}


void CConfList2::
DeleteList ( void )
{
    CConf *pConf;
    while (NULL != (pConf = Get()))
    {
        pConf->Release();
    }
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\cnppdu.c ===
/* Copyright (C) Microsoft Corporation, 1999. All rights reserved. */
/* ASN.1 definitions for Connection Negotiation Protocol (GNP) */

#include <windows.h>
#include "cnppdu.h"

ASN1module_t CNPPDU_Module = NULL;

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ip6Address(ASN1encoding_t enc, CNP_TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipxAddress(ASN1encoding_t enc, CNP_TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipAddress(ASN1encoding_t enc, CNP_TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val);
static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val);
static int ASN1CALL ASN1Enc_CNP_NonStandardParameter(ASN1encoding_t enc, CNP_NonStandardParameter *val);
#define ASN1Enc_PublicTypeOfNumber(x,y)      0
#define ASN1Enc_PublicPartyNumber(x,y)      0
#define ASN1Enc_PrivateTypeOfNumber(x,y)      0
#define ASN1Enc_PrivatePartyNumber(x,y)      0
#define ASN1Enc_PartyNumber(x,y)      0
#define ASN1Enc_ReliableTransportProtocolType(x,y)      0
#define ASN1Enc_ReliableTransportProtocol(x,y)      0
#define ASN1Enc_UnreliableTransportProtocolType(x,y)      0
#define ASN1Enc_UnreliableSecurityProtocol(x,y)      0
static int ASN1CALL ASN1Enc_X274WithSAIDInfo(ASN1encoding_t enc, X274WithSAIDInfo *val);
static int ASN1CALL ASN1Enc_ConnectRequestPDU(ASN1encoding_t enc, ConnectRequestPDU *val);
static int ASN1CALL ASN1Enc_DisconnectReason(ASN1encoding_t enc, DisconnectReason *val);
#define ASN1Enc_RejectCause(x,y)      0
#define ASN1Enc_ErrorPDU(x,y)      0
#define ASN1Enc_CNP_NonStandardPDU(x,y)      0
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipAddress_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ipAddress_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, CNP_TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipxAddress_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ipxAddress_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ip6Address_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ip6Address_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_CNP_NonStandardPDU_nonStandardParameters(ASN1encoding_t enc, PCNP_NonStandardPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ErrorPDU_nonStandardParameters(ASN1encoding_t enc, PErrorPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_DisconnectRequestPDU_nonStandardParameters(ASN1encoding_t enc, PDisconnectRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ConnectConfirmPDU_nonStandardParameters(ASN1encoding_t enc, PConnectConfirmPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ConnectRequestPDU_nonStandardParameters(ASN1encoding_t enc, PConnectRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableSecurityProtocols(ASN1encoding_t enc, PConnectRequestPDU_unreliableSecurityProtocols *val);
static int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableTransportProtocols(ASN1encoding_t enc, PConnectRequestPDU_reliableTransportProtocols *val);
static int ASN1CALL ASN1Enc_UnreliableTransportProtocol_nonStandardParameters(ASN1encoding_t enc, PUnreliableTransportProtocol_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_ReliableTransportProtocol_nonStandardParameters(ASN1encoding_t enc, PReliableTransportProtocol_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_PrivatePartyNumber_nonStandardParameters(ASN1encoding_t enc, PPrivatePartyNumber_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_PublicPartyNumber_nonStandardParameters(ASN1encoding_t enc, PPublicPartyNumber_nonStandardParameters *val);
static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute(ASN1encoding_t enc, CNP_TransportAddress_ipSourceRoute *val);
#define ASN1Enc_CNP_TransportAddress(x,y)      0
#define ASN1Enc_AliasAddress(x,y)      0
static int ASN1CALL ASN1Enc_ReliableSecurityProtocol(ASN1encoding_t enc, ReliableSecurityProtocol *val);
#define ASN1Enc_UnreliableTransportProtocol(x,y)      0
static int ASN1CALL ASN1Enc_ConnectConfirmPDU(ASN1encoding_t enc, ConnectConfirmPDU *val);
static int ASN1CALL ASN1Enc_DisconnectRequestPDU(ASN1encoding_t enc, DisconnectRequestPDU *val);
static int ASN1CALL ASN1Enc_CNPPDU(ASN1encoding_t enc, CNPPDU *val);
static int ASN1CALL ASN1Enc_DisconnectRequestPDU_destinationAddress(ASN1encoding_t enc, PDisconnectRequestPDU_destinationAddress *val);
static int ASN1CALL ASN1Enc_ConnectRequestPDU_destinationAddress(ASN1encoding_t enc, PConnectRequestPDU_destinationAddress *val);
static int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableTransportProtocols(ASN1encoding_t enc, PConnectRequestPDU_unreliableTransportProtocols *val);
static int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableSecurityProtocols(ASN1encoding_t enc, PConnectRequestPDU_reliableSecurityProtocols *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_route *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ip6Address(ASN1decoding_t dec, CNP_TransportAddress_ip6Address *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipxAddress(ASN1decoding_t dec, CNP_TransportAddress_ipxAddress *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipAddress(ASN1decoding_t dec, CNP_TransportAddress_ipAddress *val);
static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val);
static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val);
static int ASN1CALL ASN1Dec_CNP_NonStandardParameter(ASN1decoding_t dec, CNP_NonStandardParameter *val);
#define ASN1Dec_PublicTypeOfNumber(x,y)      0
#define ASN1Dec_PublicPartyNumber(x,y)      0
#define ASN1Dec_PrivateTypeOfNumber(x,y)      0
#define ASN1Dec_PrivatePartyNumber(x,y)      0
#define ASN1Dec_PartyNumber(x,y)      0
#define ASN1Dec_ReliableTransportProtocolType(x,y)      0
#define ASN1Dec_ReliableTransportProtocol(x,y)      0
#define ASN1Dec_UnreliableTransportProtocolType(x,y)      0
#define ASN1Dec_UnreliableSecurityProtocol(x,y)      0
static int ASN1CALL ASN1Dec_X274WithSAIDInfo(ASN1decoding_t dec, X274WithSAIDInfo *val);
static int ASN1CALL ASN1Dec_ConnectRequestPDU(ASN1decoding_t dec, ConnectRequestPDU *val);
static int ASN1CALL ASN1Dec_DisconnectReason(ASN1decoding_t dec, DisconnectReason *val);
#define ASN1Dec_RejectCause(x,y)      0
#define ASN1Dec_ErrorPDU(x,y)      0
#define ASN1Dec_CNP_NonStandardPDU(x,y)      0
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipAddress_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ipAddress_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, CNP_TransportAddress_ipSourceRoute_routing *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipxAddress_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ipxAddress_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ip6Address_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ip6Address_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_CNP_NonStandardPDU_nonStandardParameters(ASN1decoding_t dec, PCNP_NonStandardPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ErrorPDU_nonStandardParameters(ASN1decoding_t dec, PErrorPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_DisconnectRequestPDU_nonStandardParameters(ASN1decoding_t dec, PDisconnectRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ConnectConfirmPDU_nonStandardParameters(ASN1decoding_t dec, PConnectConfirmPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ConnectRequestPDU_nonStandardParameters(ASN1decoding_t dec, PConnectRequestPDU_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableSecurityProtocols(ASN1decoding_t dec, PConnectRequestPDU_unreliableSecurityProtocols *val);
static int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableTransportProtocols(ASN1decoding_t dec, PConnectRequestPDU_reliableTransportProtocols *val);
static int ASN1CALL ASN1Dec_UnreliableTransportProtocol_nonStandardParameters(ASN1decoding_t dec, PUnreliableTransportProtocol_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_ReliableTransportProtocol_nonStandardParameters(ASN1decoding_t dec, PReliableTransportProtocol_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_PrivatePartyNumber_nonStandardParameters(ASN1decoding_t dec, PPrivatePartyNumber_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_PublicPartyNumber_nonStandardParameters(ASN1decoding_t dec, PPublicPartyNumber_nonStandardParameters *val);
static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute(ASN1decoding_t dec, CNP_TransportAddress_ipSourceRoute *val);
#define ASN1Dec_CNP_TransportAddress(x,y)      0
#define ASN1Dec_AliasAddress(x,y)      0
static int ASN1CALL ASN1Dec_ReliableSecurityProtocol(ASN1decoding_t dec, ReliableSecurityProtocol *val);
#define ASN1Dec_UnreliableTransportProtocol(x,y)      0
static int ASN1CALL ASN1Dec_ConnectConfirmPDU(ASN1decoding_t dec, ConnectConfirmPDU *val);
static int ASN1CALL ASN1Dec_DisconnectRequestPDU(ASN1decoding_t dec, DisconnectRequestPDU *val);
static int ASN1CALL ASN1Dec_CNPPDU(ASN1decoding_t dec, CNPPDU *val);
static int ASN1CALL ASN1Dec_DisconnectRequestPDU_destinationAddress(ASN1decoding_t dec, PDisconnectRequestPDU_destinationAddress *val);
static int ASN1CALL ASN1Dec_ConnectRequestPDU_destinationAddress(ASN1decoding_t dec, PConnectRequestPDU_destinationAddress *val);
static int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableTransportProtocols(ASN1decoding_t dec, PConnectRequestPDU_unreliableTransportProtocols *val);
static int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableSecurityProtocols(ASN1decoding_t dec, PConnectRequestPDU_reliableSecurityProtocols *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_route(PCNP_TransportAddress_ipSourceRoute_route *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ip6Address(CNP_TransportAddress_ip6Address *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipxAddress(CNP_TransportAddress_ipxAddress *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipAddress(CNP_TransportAddress_ipAddress *val);
static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val);
static void ASN1CALL ASN1Free_CNP_NonStandardParameter(CNP_NonStandardParameter *val);
#define ASN1Free_PublicTypeOfNumber(x)     
#define ASN1Free_PublicPartyNumber(x)     
#define ASN1Free_PrivateTypeOfNumber(x)     
#define ASN1Free_PrivatePartyNumber(x)     
#define ASN1Free_PartyNumber(x)     
#define ASN1Free_ReliableTransportProtocolType(x)     
#define ASN1Free_ReliableTransportProtocol(x)     
#define ASN1Free_UnreliableTransportProtocolType(x)     
#define ASN1Free_UnreliableSecurityProtocol(x)     
static void ASN1CALL ASN1Free_X274WithSAIDInfo(X274WithSAIDInfo *val);
static void ASN1CALL ASN1Free_ConnectRequestPDU(ConnectRequestPDU *val);
static void ASN1CALL ASN1Free_DisconnectReason(DisconnectReason *val);
#define ASN1Free_RejectCause(x)     
#define ASN1Free_ErrorPDU(x)     
#define ASN1Free_CNP_NonStandardPDU(x)     
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipAddress_nonStandardParameters(PCNP_TransportAddress_ipAddress_nonStandardParameters *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(PCNP_TransportAddress_ipSourceRoute_nonStandardParameters *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_routing(CNP_TransportAddress_ipSourceRoute_routing *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipxAddress_nonStandardParameters(PCNP_TransportAddress_ipxAddress_nonStandardParameters *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ip6Address_nonStandardParameters(PCNP_TransportAddress_ip6Address_nonStandardParameters *val);
static void ASN1CALL ASN1Free_CNP_NonStandardPDU_nonStandardParameters(PCNP_NonStandardPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ErrorPDU_nonStandardParameters(PErrorPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_DisconnectRequestPDU_nonStandardParameters(PDisconnectRequestPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ConnectConfirmPDU_nonStandardParameters(PConnectConfirmPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ConnectRequestPDU_nonStandardParameters(PConnectRequestPDU_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableSecurityProtocols(PConnectRequestPDU_unreliableSecurityProtocols *val);
static void ASN1CALL ASN1Free_ConnectRequestPDU_reliableTransportProtocols(PConnectRequestPDU_reliableTransportProtocols *val);
static void ASN1CALL ASN1Free_UnreliableTransportProtocol_nonStandardParameters(PUnreliableTransportProtocol_nonStandardParameters *val);
static void ASN1CALL ASN1Free_ReliableTransportProtocol_nonStandardParameters(PReliableTransportProtocol_nonStandardParameters *val);
static void ASN1CALL ASN1Free_PrivatePartyNumber_nonStandardParameters(PPrivatePartyNumber_nonStandardParameters *val);
static void ASN1CALL ASN1Free_PublicPartyNumber_nonStandardParameters(PPublicPartyNumber_nonStandardParameters *val);
static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute(CNP_TransportAddress_ipSourceRoute *val);
#define ASN1Free_CNP_TransportAddress(x)     
#define ASN1Free_AliasAddress(x)     
static void ASN1CALL ASN1Free_ReliableSecurityProtocol(ReliableSecurityProtocol *val);
#define ASN1Free_UnreliableTransportProtocol(x)     
static void ASN1CALL ASN1Free_ConnectConfirmPDU(ConnectConfirmPDU *val);
static void ASN1CALL ASN1Free_DisconnectRequestPDU(DisconnectRequestPDU *val);
static void ASN1CALL ASN1Free_CNPPDU(CNPPDU *val);
static void ASN1CALL ASN1Free_DisconnectRequestPDU_destinationAddress(PDisconnectRequestPDU_destinationAddress *val);
static void ASN1CALL ASN1Free_ConnectRequestPDU_destinationAddress(PConnectRequestPDU_destinationAddress *val);
static void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableTransportProtocols(PConnectRequestPDU_unreliableTransportProtocols *val);
static void ASN1CALL ASN1Free_ConnectRequestPDU_reliableSecurityProtocols(PConnectRequestPDU_reliableSecurityProtocols *val);

typedef ASN1PerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[1] = {
    (ASN1EncFun_t) ASN1Enc_CNPPDU,
};
typedef ASN1PerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[1] = {
    (ASN1DecFun_t) ASN1Dec_CNPPDU,
};
static const ASN1FreeFun_t freefntab[1] = {
    (ASN1FreeFun_t) ASN1Free_CNPPDU,
};
static const ULONG sizetab[1] = {
    SIZE_CNPPDU_Module_PDU_0,
};

/* forward declarations of values: */
extern ASN1uint32_t t123AnnexBProtocolId_elems[6];
/* definitions of value components: */
static const struct ASN1objectidentifier_s t123AnnexBProtocolId_list[6] = {
    { (ASN1objectidentifier_t) &(t123AnnexBProtocolId_list[1]), 0 },
    { (ASN1objectidentifier_t) &(t123AnnexBProtocolId_list[2]), 0 },
    { (ASN1objectidentifier_t) &(t123AnnexBProtocolId_list[3]), 20 },
    { (ASN1objectidentifier_t) &(t123AnnexBProtocolId_list[4]), 123 },
    { (ASN1objectidentifier_t) &(t123AnnexBProtocolId_list[5]), 2 },
    { NULL, 1 }
};
/* definitions of values: */
ASN1objectidentifier_t t123AnnexBProtocolId = (ASN1objectidentifier_t) t123AnnexBProtocolId_list;

void ASN1CALL CNPPDU_Module_Startup(void)
{
    CNPPDU_Module = ASN1_CreateModule(0x10000, ASN1_PER_RULE_ALIGNED, ASN1FLAGS_NONE, 1, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x706e63);
}

void ASN1CALL CNPPDU_Module_Cleanup(void)
{
    ASN1_CloseModule(CNPPDU_Module);
    CNPPDU_Module = NULL;
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_route(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_route *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CNP_TransportAddress_ipSourceRoute_route_ElmFn);
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_route_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_route(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_route *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CNP_TransportAddress_ipSourceRoute_route_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_route_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_route val)
{
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &val->value, 4))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_route(PCNP_TransportAddress_ipSourceRoute_route *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CNP_TransportAddress_ipSourceRoute_route_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_route_ElmFn(PCNP_TransportAddress_ipSourceRoute_route val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ip6Address(ASN1encoding_t enc, CNP_TransportAddress_ip6Address *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 16))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CNP_TransportAddress_ip6Address_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ip6Address(ASN1decoding_t dec, CNP_TransportAddress_ip6Address *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 16))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CNP_TransportAddress_ip6Address_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ip6Address(CNP_TransportAddress_ip6Address *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CNP_TransportAddress_ip6Address_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipxAddress(ASN1encoding_t enc, CNP_TransportAddress_ipxAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->port, 2))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CNP_TransportAddress_ipxAddress_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipxAddress(ASN1decoding_t dec, CNP_TransportAddress_ipxAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->node, 6))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->netnum, 4))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->port, 2))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CNP_TransportAddress_ipxAddress_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipxAddress(CNP_TransportAddress_ipxAddress *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CNP_TransportAddress_ipxAddress_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipAddress(ASN1encoding_t enc, CNP_TransportAddress_ipAddress *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CNP_TransportAddress_ipAddress_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipAddress(ASN1decoding_t dec, CNP_TransportAddress_ipAddress *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CNP_TransportAddress_ipAddress_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipAddress(CNP_TransportAddress_ipAddress *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CNP_TransportAddress_ipAddress_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_H221NonStandard(ASN1encoding_t enc, H221NonStandard *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35CountryCode))
	return 0;
    ASN1PEREncAlignment(enc);
    if (!ASN1PEREncBitVal(enc, 8, (val)->t35Extension))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->manufacturerCode))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_H221NonStandard(ASN1decoding_t dec, H221NonStandard *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35CountryCode))
	return 0;
    ASN1PERDecAlignment(dec);
    if (!ASN1PERDecU16Val(dec, 8, &(val)->t35Extension))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->manufacturerCode))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Enc_NonStandardIdentifier(ASN1encoding_t enc, NonStandardIdentifier *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PEREncObjectIdentifier(enc, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_H221NonStandard(enc, &(val)->u.h221NonStandard))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_NonStandardIdentifier(ASN1decoding_t dec, NonStandardIdentifier *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 1))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1PERDecObjectIdentifier(dec, &(val)->u.object))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_H221NonStandard(dec, &(val)->u.h221NonStandard))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_NonStandardIdentifier(NonStandardIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1objectidentifier_free(&(val)->u.object);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CNP_NonStandardParameter(ASN1encoding_t enc, CNP_NonStandardParameter *val)
{
    if (!ASN1Enc_NonStandardIdentifier(enc, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->data))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_NonStandardParameter(ASN1decoding_t dec, CNP_NonStandardParameter *val)
{
    if (!ASN1Dec_NonStandardIdentifier(dec, &(val)->nonStandardIdentifier))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->data))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CNP_NonStandardParameter(CNP_NonStandardParameter *val)
{
    if (val) {
	ASN1Free_NonStandardIdentifier(&(val)->nonStandardIdentifier);
	ASN1octetstring_free(&(val)->data);
    }
}

static int ASN1CALL ASN1Enc_X274WithSAIDInfo(ASN1encoding_t enc, X274WithSAIDInfo *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->localSAID))
	return 0;
    if (!ASN1PEREncOctetString_NoSize(enc, &(val)->peerSAID))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_X274WithSAIDInfo(ASN1decoding_t dec, X274WithSAIDInfo *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->localSAID))
	return 0;
    if (!ASN1PERDecOctetString_NoSize(dec, &(val)->peerSAID))
	return 0;
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_X274WithSAIDInfo(X274WithSAIDInfo *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->localSAID);
	ASN1octetstring_free(&(val)->peerSAID);
    }
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU(ASN1encoding_t enc, ConnectRequestPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 7, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1PEREncBoolean(enc, (val)->reconnectRequested))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PEREncBitVal(enc, 4, (val)->priority))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ConnectRequestPDU_reliableTransportProtocols(enc, &(val)->reliableTransportProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_ConnectRequestPDU_reliableSecurityProtocols(enc, &(val)->reliableSecurityProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_ConnectRequestPDU_unreliableTransportProtocols(enc, &(val)->unreliableTransportProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_ConnectRequestPDU_unreliableSecurityProtocols(enc, &(val)->unreliableSecurityProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_ConnectRequestPDU_destinationAddress(enc, &(val)->destinationAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Enc_ConnectRequestPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU(ASN1decoding_t dec, ConnectRequestPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 7, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if (!ASN1PERDecBoolean(dec, &(val)->reconnectRequested))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1PERDecU16Val(dec, 4, &(val)->priority))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ConnectRequestPDU_reliableTransportProtocols(dec, &(val)->reliableTransportProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_ConnectRequestPDU_reliableSecurityProtocols(dec, &(val)->reliableSecurityProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_ConnectRequestPDU_unreliableTransportProtocols(dec, &(val)->unreliableTransportProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_ConnectRequestPDU_unreliableSecurityProtocols(dec, &(val)->unreliableSecurityProtocols))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_ConnectRequestPDU_destinationAddress(dec, &(val)->destinationAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x2) {
	if (!ASN1Dec_ConnectRequestPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConnectRequestPDU(ConnectRequestPDU *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ConnectRequestPDU_reliableTransportProtocols(&(val)->reliableTransportProtocols);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_ConnectRequestPDU_reliableSecurityProtocols(&(val)->reliableSecurityProtocols);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_ConnectRequestPDU_unreliableTransportProtocols(&(val)->unreliableTransportProtocols);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_ConnectRequestPDU_unreliableSecurityProtocols(&(val)->unreliableSecurityProtocols);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_ConnectRequestPDU_destinationAddress(&(val)->destinationAddress);
	}
	if ((val)->o[0] & 0x2) {
	    ASN1Free_ConnectRequestPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_DisconnectReason(ASN1encoding_t enc, DisconnectReason *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Enc_CNP_NonStandardParameter(enc, &(val)->u.nonStandardDisconnectReason))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisconnectReason(ASN1decoding_t dec, DisconnectReason *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Dec_CNP_NonStandardParameter(dec, &(val)->u.nonStandardDisconnectReason))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisconnectReason(DisconnectReason *val)
{
    if (val) {
	switch ((val)->choice) {
	case 10:
	    ASN1Free_CNP_NonStandardParameter(&(val)->u.nonStandardDisconnectReason);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipAddress_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ipAddress_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipAddress_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipAddress_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ipAddress_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipAddress_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipAddress_nonStandardParameters(PCNP_TransportAddress_ipAddress_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipAddress_nonStandardParameters_ElmFn(PCNP_TransportAddress_ipAddress_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipSourceRoute_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(PCNP_TransportAddress_ipSourceRoute_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_nonStandardParameters_ElmFn(PCNP_TransportAddress_ipSourceRoute_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute_routing(ASN1encoding_t enc, CNP_TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Enc_CNP_NonStandardParameter(enc, &(val)->u.nonStandardRouting))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute_routing(ASN1decoding_t dec, CNP_TransportAddress_ipSourceRoute_routing *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 2))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	if (!ASN1Dec_CNP_NonStandardParameter(dec, &(val)->u.nonStandardRouting))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute_routing(CNP_TransportAddress_ipSourceRoute_routing *val)
{
    if (val) {
	switch ((val)->choice) {
	case 3:
	    ASN1Free_CNP_NonStandardParameter(&(val)->u.nonStandardRouting);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipxAddress_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ipxAddress_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ipxAddress_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipxAddress_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ipxAddress_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ipxAddress_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipxAddress_nonStandardParameters(PCNP_TransportAddress_ipxAddress_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipxAddress_nonStandardParameters_ElmFn(PCNP_TransportAddress_ipxAddress_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ip6Address_nonStandardParameters(ASN1encoding_t enc, PCNP_TransportAddress_ip6Address_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_TransportAddress_ip6Address_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ip6Address_nonStandardParameters(ASN1decoding_t dec, PCNP_TransportAddress_ip6Address_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_TransportAddress_ip6Address_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ip6Address_nonStandardParameters(PCNP_TransportAddress_ip6Address_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ip6Address_nonStandardParameters_ElmFn(PCNP_TransportAddress_ip6Address_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CNP_NonStandardPDU_nonStandardParameters(ASN1encoding_t enc, PCNP_NonStandardPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_CNP_NonStandardPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_CNP_NonStandardPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PCNP_NonStandardPDU_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_NonStandardPDU_nonStandardParameters(ASN1decoding_t dec, PCNP_NonStandardPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_CNP_NonStandardPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_CNP_NonStandardPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PCNP_NonStandardPDU_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CNP_NonStandardPDU_nonStandardParameters(PCNP_NonStandardPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_CNP_NonStandardPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_CNP_NonStandardPDU_nonStandardParameters_ElmFn(PCNP_NonStandardPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ErrorPDU_nonStandardParameters(ASN1encoding_t enc, PErrorPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ErrorPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ErrorPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PErrorPDU_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ErrorPDU_nonStandardParameters(ASN1decoding_t dec, PErrorPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ErrorPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ErrorPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PErrorPDU_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ErrorPDU_nonStandardParameters(PErrorPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ErrorPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ErrorPDU_nonStandardParameters_ElmFn(PErrorPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_DisconnectRequestPDU_nonStandardParameters(ASN1encoding_t enc, PDisconnectRequestPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisconnectRequestPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_DisconnectRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PDisconnectRequestPDU_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisconnectRequestPDU_nonStandardParameters(ASN1decoding_t dec, PDisconnectRequestPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisconnectRequestPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisconnectRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PDisconnectRequestPDU_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisconnectRequestPDU_nonStandardParameters(PDisconnectRequestPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisconnectRequestPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisconnectRequestPDU_nonStandardParameters_ElmFn(PDisconnectRequestPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConnectConfirmPDU_nonStandardParameters(ASN1encoding_t enc, PConnectConfirmPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConnectConfirmPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ConnectConfirmPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConnectConfirmPDU_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectConfirmPDU_nonStandardParameters(ASN1decoding_t dec, PConnectConfirmPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConnectConfirmPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConnectConfirmPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConnectConfirmPDU_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectConfirmPDU_nonStandardParameters(PConnectConfirmPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConnectConfirmPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConnectConfirmPDU_nonStandardParameters_ElmFn(PConnectConfirmPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_nonStandardParameters(ASN1encoding_t enc, PConnectRequestPDU_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConnectRequestPDU_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_nonStandardParameters_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_nonStandardParameters(ASN1decoding_t dec, PConnectRequestPDU_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConnectRequestPDU_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_nonStandardParameters_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_nonStandardParameters(PConnectRequestPDU_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConnectRequestPDU_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_nonStandardParameters_ElmFn(PConnectRequestPDU_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableSecurityProtocols(ASN1encoding_t enc, PConnectRequestPDU_unreliableSecurityProtocols *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn);
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_unreliableSecurityProtocols val)
{
    if (!ASN1Enc_UnreliableSecurityProtocol(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableSecurityProtocols(ASN1decoding_t dec, PConnectRequestPDU_unreliableSecurityProtocols *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_unreliableSecurityProtocols val)
{
    if (!ASN1Dec_UnreliableSecurityProtocol(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableSecurityProtocols(PConnectRequestPDU_unreliableSecurityProtocols *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableSecurityProtocols_ElmFn(PConnectRequestPDU_unreliableSecurityProtocols val)
{
    if (val) {
	ASN1Free_UnreliableSecurityProtocol(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableTransportProtocols(ASN1encoding_t enc, PConnectRequestPDU_reliableTransportProtocols *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConnectRequestPDU_reliableTransportProtocols_ElmFn);
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableTransportProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_reliableTransportProtocols val)
{
    if (!ASN1Enc_ReliableTransportProtocol(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableTransportProtocols(ASN1decoding_t dec, PConnectRequestPDU_reliableTransportProtocols *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConnectRequestPDU_reliableTransportProtocols_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableTransportProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_reliableTransportProtocols val)
{
    if (!ASN1Dec_ReliableTransportProtocol(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_reliableTransportProtocols(PConnectRequestPDU_reliableTransportProtocols *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConnectRequestPDU_reliableTransportProtocols_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_reliableTransportProtocols_ElmFn(PConnectRequestPDU_reliableTransportProtocols val)
{
    if (val) {
	ASN1Free_ReliableTransportProtocol(&val->value);
    }
}

static int ASN1CALL ASN1Enc_UnreliableTransportProtocol_nonStandardParameters(ASN1encoding_t enc, PUnreliableTransportProtocol_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_UnreliableTransportProtocol_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_UnreliableTransportProtocol_nonStandardParameters_ElmFn(ASN1encoding_t enc, PUnreliableTransportProtocol_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_UnreliableTransportProtocol_nonStandardParameters(ASN1decoding_t dec, PUnreliableTransportProtocol_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_UnreliableTransportProtocol_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_UnreliableTransportProtocol_nonStandardParameters_ElmFn(ASN1decoding_t dec, PUnreliableTransportProtocol_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_UnreliableTransportProtocol_nonStandardParameters(PUnreliableTransportProtocol_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_UnreliableTransportProtocol_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_UnreliableTransportProtocol_nonStandardParameters_ElmFn(PUnreliableTransportProtocol_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ReliableTransportProtocol_nonStandardParameters(ASN1encoding_t enc, PReliableTransportProtocol_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ReliableTransportProtocol_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_ReliableTransportProtocol_nonStandardParameters_ElmFn(ASN1encoding_t enc, PReliableTransportProtocol_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ReliableTransportProtocol_nonStandardParameters(ASN1decoding_t dec, PReliableTransportProtocol_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ReliableTransportProtocol_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ReliableTransportProtocol_nonStandardParameters_ElmFn(ASN1decoding_t dec, PReliableTransportProtocol_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ReliableTransportProtocol_nonStandardParameters(PReliableTransportProtocol_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ReliableTransportProtocol_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ReliableTransportProtocol_nonStandardParameters_ElmFn(PReliableTransportProtocol_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PrivatePartyNumber_nonStandardParameters(ASN1encoding_t enc, PPrivatePartyNumber_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PrivatePartyNumber_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_PrivatePartyNumber_nonStandardParameters_ElmFn(ASN1encoding_t enc, PPrivatePartyNumber_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivatePartyNumber_nonStandardParameters(ASN1decoding_t dec, PPrivatePartyNumber_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PrivatePartyNumber_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PrivatePartyNumber_nonStandardParameters_ElmFn(ASN1decoding_t dec, PPrivatePartyNumber_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivatePartyNumber_nonStandardParameters(PPrivatePartyNumber_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PrivatePartyNumber_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PrivatePartyNumber_nonStandardParameters_ElmFn(PPrivatePartyNumber_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_PublicPartyNumber_nonStandardParameters(ASN1encoding_t enc, PPublicPartyNumber_nonStandardParameters *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_PublicPartyNumber_nonStandardParameters_ElmFn);
}

static int ASN1CALL ASN1Enc_PublicPartyNumber_nonStandardParameters_ElmFn(ASN1encoding_t enc, PPublicPartyNumber_nonStandardParameters val)
{
    if (!ASN1Enc_CNP_NonStandardParameter(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PublicPartyNumber_nonStandardParameters(ASN1decoding_t dec, PPublicPartyNumber_nonStandardParameters *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_PublicPartyNumber_nonStandardParameters_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_PublicPartyNumber_nonStandardParameters_ElmFn(ASN1decoding_t dec, PPublicPartyNumber_nonStandardParameters val)
{
    if (!ASN1Dec_CNP_NonStandardParameter(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PublicPartyNumber_nonStandardParameters(PPublicPartyNumber_nonStandardParameters *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_PublicPartyNumber_nonStandardParameters_ElmFn);
    }
}

static void ASN1CALL ASN1Free_PublicPartyNumber_nonStandardParameters_ElmFn(PPublicPartyNumber_nonStandardParameters val)
{
    if (val) {
	ASN1Free_CNP_NonStandardParameter(&val->value);
    }
}

static int ASN1CALL ASN1Enc_CNP_TransportAddress_ipSourceRoute(ASN1encoding_t enc, CNP_TransportAddress_ipSourceRoute *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 1, (val)->o))
	return 0;
    if (!ASN1PEREncOctetString_FixedSize(enc, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PEREncUnsignedShort(enc, (val)->port))
	return 0;
    if (!ASN1Enc_CNP_TransportAddress_ipSourceRoute_route(enc, &(val)->route))
	return 0;
    if (!ASN1Enc_CNP_TransportAddress_ipSourceRoute_routing(enc, &(val)->routing))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CNP_TransportAddress_ipSourceRoute(ASN1decoding_t dec, CNP_TransportAddress_ipSourceRoute *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 1, (val)->o))
	return 0;
    if (!ASN1PERDecOctetString_FixedSize(dec, (ASN1octetstring2_t *) &(val)->ip, 4))
	return 0;
    if (!ASN1PERDecUnsignedShort(dec, &(val)->port))
	return 0;
    if (!ASN1Dec_CNP_TransportAddress_ipSourceRoute_route(dec, &(val)->route))
	return 0;
    if (!ASN1Dec_CNP_TransportAddress_ipSourceRoute_routing(dec, &(val)->routing))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CNP_TransportAddress_ipSourceRoute(CNP_TransportAddress_ipSourceRoute *val)
{
    if (val) {
	ASN1Free_CNP_TransportAddress_ipSourceRoute_route(&(val)->route);
	ASN1Free_CNP_TransportAddress_ipSourceRoute_routing(&(val)->routing);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CNP_TransportAddress_ipSourceRoute_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_ReliableSecurityProtocol(ASN1encoding_t enc, ReliableSecurityProtocol *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Enc_X274WithSAIDInfo(enc, &(val)->u.x274WithSAID))
	    return 0;
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Enc_CNP_NonStandardParameter(enc, &(val)->u.nonStandardSecurityProtocol))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ReliableSecurityProtocol(ASN1decoding_t dec, ReliableSecurityProtocol *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 4))
	return 0;
    switch ((val)->choice) {
    case 1:
	break;
    case 2:
	break;
    case 3:
	break;
    case 4:
	break;
    case 5:
	break;
    case 6:
	break;
    case 7:
	if (!ASN1Dec_X274WithSAIDInfo(dec, &(val)->u.x274WithSAID))
	    return 0;
	break;
    case 8:
	break;
    case 9:
	break;
    case 10:
	if (!ASN1Dec_CNP_NonStandardParameter(dec, &(val)->u.nonStandardSecurityProtocol))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ReliableSecurityProtocol(ReliableSecurityProtocol *val)
{
    if (val) {
	switch ((val)->choice) {
	case 7:
	    ASN1Free_X274WithSAIDInfo(&(val)->u.x274WithSAID);
	    break;
	case 10:
	    ASN1Free_CNP_NonStandardParameter(&(val)->u.nonStandardSecurityProtocol);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_ConnectConfirmPDU(ASN1encoding_t enc, ConnectConfirmPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 5, (val)->o))
	return 0;
    if (!ASN1PEREncObjectIdentifier(enc, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ReliableTransportProtocol(enc, &(val)->reliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ReliableSecurityProtocol(enc, &(val)->reliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_UnreliableTransportProtocol(enc, &(val)->unreliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_UnreliableSecurityProtocol(enc, &(val)->unreliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_ConnectConfirmPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectConfirmPDU(ASN1decoding_t dec, ConnectConfirmPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 5, (val)->o))
	return 0;
    if (!ASN1PERDecObjectIdentifier(dec, &(val)->protocolIdentifier))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ReliableTransportProtocol(dec, &(val)->reliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ReliableSecurityProtocol(dec, &(val)->reliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_UnreliableTransportProtocol(dec, &(val)->unreliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_UnreliableSecurityProtocol(dec, &(val)->unreliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_ConnectConfirmPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_ConnectConfirmPDU(ConnectConfirmPDU *val)
{
    if (val) {
	ASN1objectidentifier_free(&(val)->protocolIdentifier);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ReliableTransportProtocol(&(val)->reliableTransportProtocol);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ReliableSecurityProtocol(&(val)->reliableSecurityProtocol);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_UnreliableTransportProtocol(&(val)->unreliableTransportProtocol);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_UnreliableSecurityProtocol(&(val)->unreliableSecurityProtocol);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_ConnectConfirmPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_DisconnectRequestPDU(ASN1encoding_t enc, DisconnectRequestPDU *val)
{
    if (!ASN1PEREncExtensionBitClear(enc))
	return 0;
    if (!ASN1PEREncBits(enc, 6, (val)->o))
	return 0;
    if (!ASN1Enc_DisconnectReason(enc, &(val)->disconnectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_ReliableTransportProtocol(enc, &(val)->reliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_ReliableSecurityProtocol(enc, &(val)->reliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Enc_UnreliableTransportProtocol(enc, &(val)->unreliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Enc_UnreliableSecurityProtocol(enc, &(val)->unreliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Enc_DisconnectRequestPDU_destinationAddress(enc, &(val)->destinationAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Enc_DisconnectRequestPDU_nonStandardParameters(enc, &(val)->nonStandardParameters))
	    return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_DisconnectRequestPDU(ASN1decoding_t dec, DisconnectRequestPDU *val)
{
    ASN1uint32_t y;
    if (!ASN1PERDecExtensionBit(dec, &y))
	return 0;
    if (!ASN1PERDecExtension(dec, 6, (val)->o))
	return 0;
    if (!ASN1Dec_DisconnectReason(dec, &(val)->disconnectReason))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Dec_ReliableTransportProtocol(dec, &(val)->reliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Dec_ReliableSecurityProtocol(dec, &(val)->reliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x20) {
	if (!ASN1Dec_UnreliableTransportProtocol(dec, &(val)->unreliableTransportProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x10) {
	if (!ASN1Dec_UnreliableSecurityProtocol(dec, &(val)->unreliableSecurityProtocol))
	    return 0;
    }
    if ((val)->o[0] & 0x8) {
	if (!ASN1Dec_DisconnectRequestPDU_destinationAddress(dec, &(val)->destinationAddress))
	    return 0;
    }
    if ((val)->o[0] & 0x4) {
	if (!ASN1Dec_DisconnectRequestPDU_nonStandardParameters(dec, &(val)->nonStandardParameters))
	    return 0;
    }
    if (y) {
	if (!ASN1PERDecSkipNormallySmallExtensionFragmented(dec))
	    return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_DisconnectRequestPDU(DisconnectRequestPDU *val)
{
    if (val) {
	ASN1Free_DisconnectReason(&(val)->disconnectReason);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_ReliableTransportProtocol(&(val)->reliableTransportProtocol);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_ReliableSecurityProtocol(&(val)->reliableSecurityProtocol);
	}
	if ((val)->o[0] & 0x20) {
	    ASN1Free_UnreliableTransportProtocol(&(val)->unreliableTransportProtocol);
	}
	if ((val)->o[0] & 0x10) {
	    ASN1Free_UnreliableSecurityProtocol(&(val)->unreliableSecurityProtocol);
	}
	if ((val)->o[0] & 0x8) {
	    ASN1Free_DisconnectRequestPDU_destinationAddress(&(val)->destinationAddress);
	}
	if ((val)->o[0] & 0x4) {
	    ASN1Free_DisconnectRequestPDU_nonStandardParameters(&(val)->nonStandardParameters);
	}
    }
}

static int ASN1CALL ASN1Enc_CNPPDU(ASN1encoding_t enc, CNPPDU *val)
{
    if (!ASN1PEREncSimpleChoiceEx(enc, (val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_ConnectRequestPDU(enc, &(val)->u.connectRequest))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_ConnectConfirmPDU(enc, &(val)->u.connectConfirm))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_DisconnectRequestPDU(enc, &(val)->u.disconnectRequest))
	    return 0;
	break;
    case 4:
	if (!ASN1Enc_ErrorPDU(enc, &(val)->u.error))
	    return 0;
	break;
    case 5:
	if (!ASN1Enc_CNP_NonStandardPDU(enc, &(val)->u.nonStandardCNPPDU))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1EncSetError(enc, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CNPPDU(ASN1decoding_t dec, CNPPDU *val)
{
    if (!ASN1PERDecSimpleChoiceEx(dec, &(val)->choice, 3))
	return 0;
    switch ((val)->choice) {
    case 1:
	if (!ASN1Dec_ConnectRequestPDU(dec, &(val)->u.connectRequest))
	    return 0;
	break;
    case 2:
	if (!ASN1Dec_ConnectConfirmPDU(dec, &(val)->u.connectConfirm))
	    return 0;
	break;
    case 3:
	if (!ASN1Dec_DisconnectRequestPDU(dec, &(val)->u.disconnectRequest))
	    return 0;
	break;
    case 4:
	if (!ASN1Dec_ErrorPDU(dec, &(val)->u.error))
	    return 0;
	break;
    case 5:
	if (!ASN1Dec_CNP_NonStandardPDU(dec, &(val)->u.nonStandardCNPPDU))
	    return 0;
	break;
    case 0:
	/* extension case */
	if (!ASN1PERDecSkipFragmented(dec, 8))
	    return 0;
	break;
    default:
	/* impossible */
	ASN1DecSetError(dec, ASN1_ERR_CHOICE);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CNPPDU(CNPPDU *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_ConnectRequestPDU(&(val)->u.connectRequest);
	    break;
	case 2:
	    ASN1Free_ConnectConfirmPDU(&(val)->u.connectConfirm);
	    break;
	case 3:
	    ASN1Free_DisconnectRequestPDU(&(val)->u.disconnectRequest);
	    break;
	case 4:
	    ASN1Free_ErrorPDU(&(val)->u.error);
	    break;
	case 5:
	    ASN1Free_CNP_NonStandardPDU(&(val)->u.nonStandardCNPPDU);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_DisconnectRequestPDU_destinationAddress(ASN1encoding_t enc, PDisconnectRequestPDU_destinationAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_DisconnectRequestPDU_destinationAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_DisconnectRequestPDU_destinationAddress_ElmFn(ASN1encoding_t enc, PDisconnectRequestPDU_destinationAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DisconnectRequestPDU_destinationAddress(ASN1decoding_t dec, PDisconnectRequestPDU_destinationAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_DisconnectRequestPDU_destinationAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_DisconnectRequestPDU_destinationAddress_ElmFn(ASN1decoding_t dec, PDisconnectRequestPDU_destinationAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DisconnectRequestPDU_destinationAddress(PDisconnectRequestPDU_destinationAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_DisconnectRequestPDU_destinationAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_DisconnectRequestPDU_destinationAddress_ElmFn(PDisconnectRequestPDU_destinationAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_destinationAddress(ASN1encoding_t enc, PConnectRequestPDU_destinationAddress *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConnectRequestPDU_destinationAddress_ElmFn);
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_destinationAddress_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_destinationAddress val)
{
    if (!ASN1Enc_AliasAddress(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_destinationAddress(ASN1decoding_t dec, PConnectRequestPDU_destinationAddress *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConnectRequestPDU_destinationAddress_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_destinationAddress_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_destinationAddress val)
{
    if (!ASN1Dec_AliasAddress(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_destinationAddress(PConnectRequestPDU_destinationAddress *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConnectRequestPDU_destinationAddress_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_destinationAddress_ElmFn(PConnectRequestPDU_destinationAddress val)
{
    if (val) {
	ASN1Free_AliasAddress(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableTransportProtocols(ASN1encoding_t enc, PConnectRequestPDU_unreliableTransportProtocols *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConnectRequestPDU_unreliableTransportProtocols_ElmFn);
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_unreliableTransportProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_unreliableTransportProtocols val)
{
    if (!ASN1Enc_UnreliableTransportProtocol(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableTransportProtocols(ASN1decoding_t dec, PConnectRequestPDU_unreliableTransportProtocols *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConnectRequestPDU_unreliableTransportProtocols_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_unreliableTransportProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_unreliableTransportProtocols val)
{
    if (!ASN1Dec_UnreliableTransportProtocol(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableTransportProtocols(PConnectRequestPDU_unreliableTransportProtocols *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConnectRequestPDU_unreliableTransportProtocols_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_unreliableTransportProtocols_ElmFn(PConnectRequestPDU_unreliableTransportProtocols val)
{
    if (val) {
	ASN1Free_UnreliableTransportProtocol(&val->value);
    }
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableSecurityProtocols(ASN1encoding_t enc, PConnectRequestPDU_reliableSecurityProtocols *val)
{
    return ASN1PEREncSeqOf_NoSize(enc, (ASN1iterator_t **) val, (ASN1iterator_encfn) ASN1Enc_ConnectRequestPDU_reliableSecurityProtocols_ElmFn);
}

static int ASN1CALL ASN1Enc_ConnectRequestPDU_reliableSecurityProtocols_ElmFn(ASN1encoding_t enc, PConnectRequestPDU_reliableSecurityProtocols val)
{
    if (!ASN1Enc_ReliableSecurityProtocol(enc, &val->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableSecurityProtocols(ASN1decoding_t dec, PConnectRequestPDU_reliableSecurityProtocols *val)
{
    return ASN1PERDecSeqOf_NoSize(dec, (ASN1iterator_t **) val, (ASN1iterator_decfn) ASN1Dec_ConnectRequestPDU_reliableSecurityProtocols_ElmFn, sizeof(**val));
}

static int ASN1CALL ASN1Dec_ConnectRequestPDU_reliableSecurityProtocols_ElmFn(ASN1decoding_t dec, PConnectRequestPDU_reliableSecurityProtocols val)
{
    if (!ASN1Dec_ReliableSecurityProtocol(dec, &val->value))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_reliableSecurityProtocols(PConnectRequestPDU_reliableSecurityProtocols *val)
{
    if (val) {
	ASN1PERFreeSeqOf((ASN1iterator_t **) val, (ASN1iterator_freefn) ASN1Free_ConnectRequestPDU_reliableSecurityProtocols_ElmFn);
    }
}

static void ASN1CALL ASN1Free_ConnectRequestPDU_reliableSecurityProtocols_ElmFn(PConnectRequestPDU_reliableSecurityProtocols val)
{
    if (val) {
	ASN1Free_ReliableSecurityProtocol(&val->value);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\control.cpp ===
#include "precomp.h"
#include "cnpcoder.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	control.cpp
 *
 *	Copyright (c) 1993 - 1996 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the MCS controller.  Its primary
 *		purpose is to create and destroy objects as needed at run-time.  The
 *		interface file contains a detailed description of what this class
 *		does.
 *
 *		There can be only one instance of this object within an MCS provider.
 *		Once initialization is complete, this object performs all activity
 *		as part of an owner callback from one of its "children".
 *
 *		The owner callback member function determines which callback is
 *		occurring, unpacks the parameters, and calls a private member function
 *		that is associated with that callback.  So when reading through the
 *		code, it is possible to view those private member functions as though
 *		they were direct calls from the child objects.  It is worth noting
 *		that all of the owner callback private member functions follow the
 *		same naming convention.  The function name is the name of the
 *		originating object followed by the name of the operation.  For
 *		example,  if an application interface object sends a create domain
 *		request to the controller through the owner callback, the name of
 *		the associated member function is ApplicationCreateDomain.  When a
 *		connection object wishes to delete itself, this is called
 *		ConnectionDeleteConnection.
 *
 *		The Windows version of the constructor can optionally allocate a
 *		Windows timer to provider MCS with a heartbeat.  The timer procedure
 *		uses a static variable to "jump into" the context of the controller
 *		object.  For this reason, there can only be one instance of this class.
 *
 *		This class is also responsible for sending four different messages
 *		to the node controller: connect provider indication; connect provider
 *		confirm; disconnect provider indication; and transport status
 *		indication.  A control queue is maintained to buffer these indications
 *		and confirms until the next time slice.
 *
 *	Private Instance Variables:
 *		Connection_Handle_Counter
 *			A rolling counter used by the controller to generate connection
 *			handles.  It is 16-bit, and will not repeat a handle until all 64K
 *			have been used (0 is NOT a valid handle).
 *		ASN_Coder
 *			When using the DataBeam's implementation of ASN.1, this is the
 *			ASN coder.  When the MCS coder is created, this object is passed
 *			to it, but this instance variable allows us to later delete this
 *			object.
 *		m_DomainList2
 *			A list of existing Domains, indexed by DomainSelector.  These are
 *			created when the controller receives a CreateDomain.
 *		m_ConnectionList2
 *			A list of existing Connections, indexed by ConnectionHandle.  These
 *			are created in one of two ways.  First, in response to a locally
 *			generated ConnectProviderRequest (with a valid local domain and
 *			transport address).  Second, in response to a locally generated
 *			ConnectProviderResponse (which is responding to an incoming
 *			connection).
 *		m_ConnPollList
 *			This is a list of active connection objects which is used for
 *			polling in the heartbeat call.  The order of the entries is modified
 *			every heartbeat in order to provide fair access to resources.
 *		m_ConnPendingList2
 *			This is a list of incoming connections for which a connect provider
 *			response has not yet been received.  This list holds pertinent
 *			information about the pending connection that will not be passed
 *			back in the ConnectProviderResponse..
 *		m_ConnectionDeletionList2
 *			A list of connection objects awaiting deletion,
 *		Connection_Deletion_Pending
 *			A flag that indicates whether or not there is anything in the
 *			connection deletion list.
 *	Private Member Functions:
 *		LoadTransportStacks
 *			This function is called by the constructor to load all available
 *			transport stacks for use by MCS.  It reads the INI file to
 *			determine which DLLs are to be used, and then instantiate a
 *			transport interface object for each.  This code is NOT portable.
 *		ApplicationCreateDomain
 *			This is an owner callback function that results from a call to
 *			CreateDomain.  This callback comes from the application interface
 *			object that represents the originator of the request.  The named
 *			domain will be created (if it doesn't already exist).
 *		ApplicationDeleteDomain
 *			This is an owner callback function that results from a call to
 *			DeleteDomain.  This callback comes from the application interface
 *			object that represents the originator of the request.  The named
 *			domain will be deleted (if it exists).
 *		ApplicationConnectProviderRequest
 *			This is an owner callback function that occurs when the node
 *			controller calls ConnectProviderRequest.  After parameters are
 *			validated, a new connection object will be created.
 *		ApplicationConnectProviderResponse
 *			This is an owner callback function that occurs when the node
 *			controller calls ConnectProviderResponse.  The controller responds
 *			by sending a message to the proper domain object, letting it know
 *			whether an inbound connection was accepted or rejected.
 *		ApplicationDisconnectProviderRequest
 *			This is an owner callback function that occurs when the node
 *			controller calls DisconnectProviderRequest.  If the connection
 *			handle is valid, the associated connection object will be deleted.
 *		ApplicationAttachUserRequest
 *			This is an owner callback function that occurs when any application
 *			sends an AttachUserRequest via one of the active application
 *			interface objects.  The controller will create a new user object
 *			after parameter validation.
 *		ConnectionDeleteConnection
 *			This is an owner callback function that occurs when a connection
 *			object determines the need to delete itself.  This can occur for
 *			two reasons.  First, in response to a disconnect provider ultimatum
 *			from either the local or the remote domain.  Second, in response
 *			to a loss of connection from the transport layer.
 *		ConnectionConnectProviderConfirm
 *			This is an owner callback function that occurs when a connection
 *			object receives a connect response PDU from a remote provider for an
 *			outstanding connect initial.  The controller responds by sending a
 *			connect provider confirm to the node controller.
 *		TransportDataIndication
 *			This is an owner callback function that occurs when data is
 *			received on a transport connection for which no other object has
 *			registered.
 *		TransportStatusIndication
 *			This is an owner callback function that occurs when a status
 *			indication message comes from the transport layer.  This information
 *			is forwarded to the node controller in the form of a transport
 *			status indication message.
 *		ProcessConnectInitial
 *			Processes incoming connect initial PDUs.  Sends connect provider
 *			indication to the node controller.
 *		ProcessConnectAdditional
 *			Processes incoming connect additional PDUs.  Binds them to the
 *			appropriate connection, if possible.
 *		ConnectResponse
 *			Issues a failed connect response when something goes wrong.
 *		ConnectResult
 *			Issues a failed connect result when something goes wrong.
 *		AllocateConnectionHandle
 *			This private member function is used by the controller to allocate
 *			new connection handles when creating a new connection object.
 *		FlushMessageQueue
 *			This member function flushes the control message queue by sending
 *			all contained messages to the node controller.
 *
 *	Caveats:
 *		There can only one instance of this object at a time.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

/*
 *	External Interfaces
 */

#include <nmqos.h>
#include <t120qos.h>
#include "csap.h"

/*
 *	Macros
 */
enum
{
    TRANSPORT_TRANSMIT_EVENT,
    CONNECTION_DELETION_PENDING_EVENT,
    GCC_FLUSH_OUTGOING_PDU_EVENT,

    NUMBER_OF_EVENTS
};

/*
 *	Macros
 *
 *	These macros define the maximum length of various strings within the
 *	controller.  They are used when reading data from the INI file, which is
 *	very Windows specific.  These values are somewhat arbitrary and may be
 *	changed in future releases, if necessary.
 */
#define	MAXIMUM_CONFIGURATION_ITEM_LENGTH		20
#define	MAXIMUM_TRANSPORT_IDENTIFIER_LENGTH		40

/* The MSMCSTCP window class name. This name must be unique system-wide. */
#define MSMCSTCP_WINDOW_CLASS_NAME	"NM TCP Window"

/* 	Timer duration. We can get a timer event every X milliseconds.  During
 *	this time, we can do any maintenance that is necessary. */
#define	MSMCSTCP_TIMER_DURATION		30000

/*
 * This is the number of extra memory blocks that the local memory
 * manager can allocate.
 * This number should be set to 3 * prime number and close to the
 * maximum number of extra memory blocks that can be allocated.
 */
#define DEFAULT_MAX_EXTERNAL_MEMORY				237

/*
 *	This is a prototype for the controller thread entry point.
 */
ULong	APIENTRY	ControllerThread (PVoid);

// The DLL's HINSTANCE.
extern HINSTANCE		g_hDllInst;

// The TCP socket window handle
HWND					TCP_Window_Handle;

// The global MCS Critical Section
CRITICAL_SECTION 		g_MCS_Critical_Section;

/*
 *	This is a global variable that has a pointer to the one MCS coder that
 *	is instantiated by the MCS Controller.  Most objects know in advance 
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CMCSCoder		*g_MCSCoder;

extern CCNPCoder        *g_CNPCoder;

// The global TransportInterface pointer (for transport access)
extern PTransportInterface g_Transport;

BOOL GetSecurityInfo(ConnectionHandle connection_handle, PBYTE pInfo, PDWORD pcbInfo);
/*
 *	g_pMCSController
 *		This is a pointer to the one-and-only controller created within the
 *		MCS system.  This object is created during MCSInitialize by the process
 *		that is taking on the responsibilities of the node controller.
 */
PController				g_pMCSController = NULL;

// The MCS main thread handle
HANDLE 					g_hMCSThread = NULL;

/*
 *	These macros define the number of buckets to be used in various hash
 *	dictionaries that are maintained by the controller.  Having more buckets
 *	allows the dictionaries to handle more entries efficiently, but costs
 *	more resources.
 */
#define CONNECTION_LIST_NUMBER_OF_BUCKETS       16

/*
 *	Controller ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the Controller.  It creates the application
 *		interface and transport interface objects that will be used by MCS.
 *		It also creates the memory manager object that will used throughout
 *		the system by anyone requiring memory management services.  And its
 *		last duty is to allocate a Windows timer for use in getting a time
 *		slice within which MCS does its work.
 */
Controller::Controller
(
    PMCSError       mcs_error
) 
:
    CRefCount(MAKE_STAMP_ID('M','C','t','r')),
    m_DomainList2(),
    m_ConnectionList2(CONNECTION_LIST_NUMBER_OF_BUCKETS),
    m_ConnPendingList2(),
    m_ConnectionDeletionList2(CONNECTION_LIST_NUMBER_OF_BUCKETS)
{
	ULong								thread_id;
	TransportInterfaceError				transport_interface_error;

	/*
	 *	Initialize the return value to indicate that no error has yet occured.
	 */
	*mcs_error = MCS_NO_ERROR;

	// Perform memory pool allocation for DataPacket objects.
	DataPacket::AllocateMemoryPool (ALLOCATE_DATA_PACKET_OBJECTS);

	/*
	 *	Give all pointers and handles initial values so that the destructor
	 *	will not try to free unallocated resources when the constructor fails
	 *	part-way.
	 */
	TCP_Window_Handle = NULL;
	Transport_Transmit_Event = NULL;
	Connection_Deletion_Pending_Event = NULL;
	m_fControllerThreadActive = FALSE;
#ifndef NO_TCP_TIMER
	Timer_ID = 0;
#endif	/* NO_TCP_TIMER */

	/*
	 *	Initialize the handle counters to 0.  These rolling instance variables
	 *	are used to generate uniwue handles as each user and connection object
	 *	is created.
	 */
	Connection_Handle_Counter = 0;
	Connection_Deletion_Pending = FALSE;

	// Initialize MCS's critical section.
	InitializeCriticalSection (&g_MCS_Critical_Section);

	/*
	 *	Create an ASN.1 coder which will encode all ASN.1 PDUs.  Check
	 *	to make sure the coder was successfully created.
	 */
	DBG_SAVE_FILE_LINE
	g_MCSCoder = new CMCSCoder ();

	/*
	 *	Make sure the creation of the packet coder was successful before
	 *	proceeding.
	 */
	if (g_MCSCoder == NULL)
	{
		/*
		 *	If the packet coder could not be createdm then report the error.
		 *	This IS a fatal error, so the faulty controller should be
		 *	destroyed and never used.
		 */
		WARNING_OUT (("Controller::Controller: failure creating packet coder"));
		*mcs_error = MCS_ALLOCATION_FAILURE;
	}

	/*
	 *	Do not continue with the initialization if an error has occured.
	 */
	if (*mcs_error == MCS_NO_ERROR)
	{
		// We have to initialize the User class
		if (FALSE == User::InitializeClass()) {
			/*
			 *	The initialization of the User class failed, so we
			 *	must fail the creation of this controller.
			 */
			WARNING_OUT (("Controller::Controller: "
					"failed to initialize User class."));
			*mcs_error = MCS_ALLOCATION_FAILURE;
		}
	}

	/*
	 *	Do not continue with the initialization if an error has occured.
	 */
	if (*mcs_error == MCS_NO_ERROR)
	{
		/*
		 *	We must allocate an event object that will used to notify the
		 *	controller when data is ready to be transmitted to a transport
		 *	stack.
		 */
		Transport_Transmit_Event = CreateEvent (NULL, FALSE, FALSE, NULL);

		if (Transport_Transmit_Event == NULL)
		{
			/*
			 *	Were unable to allocate an event object for this task, so we
			 *	must fail the creation of this controller.
			 */
			WARNING_OUT (("Controller::Controller: "
					"failure allocating transport transmit event object"));
			*mcs_error = MCS_ALLOCATION_FAILURE;
		}
	}

	/*
	 *	Do not continue with the initialization if an error has occured.
	 */
	if (*mcs_error == MCS_NO_ERROR)
	{
		/*
		 *	We must allocate an event object that will used for 
		 *	synchronization between the event loop thread and the thread 
		 *	that creates/destroys the Controller object.
		 */
		Synchronization_Event = CreateEvent (NULL, FALSE, FALSE, NULL);

		if (Synchronization_Event == NULL)
		{
			/*
			 *	Were unable to allocate an event object for this task, so we
			 *	must fail the creation of this controller.
			 */
			WARNING_OUT (("Controller::Controller: "
					"failure allocating synchronization event object"));
			*mcs_error = MCS_ALLOCATION_FAILURE;
		}
	}

	/*
	 *	Do not continue with the initialization if an error has occured.
	 */
	if (*mcs_error == MCS_NO_ERROR)
	{
		/*
		 *	We must allocate an event object that will used to notify the
		 *	controller when data is ready to be transmitted to a transport
		 *	stack.
		 */
		Connection_Deletion_Pending_Event = CreateEvent (NULL, FALSE, FALSE, NULL);

		if (Connection_Deletion_Pending_Event == NULL)
		{
			/*
			 *	Were unable to allocate an event object for this task, so we
			 *	must fail the creation of this controller.
			 */
			WARNING_OUT (("Controller::Controller: "
					"failure allocating connection deletion pending event object"));
			*mcs_error = MCS_ALLOCATION_FAILURE;
		}
	}

	/*
	 *	Do not continue with the initialization if an error has occured.
	 */
	if (*mcs_error == MCS_NO_ERROR)
	{
		/*
		 *	Initialize the flag that indicates that the controller is not yet
		 *	shutting down.
		 */
		Controller_Closing = FALSE;

		/*
		 *	Since everything else was successful, we must create a thread
		 *	winthin which the controller will do most of its work.
		 */
		g_hMCSThread = CreateThread (NULL, 0, ControllerThread,
				(PVoid) this, 0, &thread_id);

		if (g_hMCSThread == NULL)
		{
			/*
			 *	We were unable to create the thread that the controller needs
			 *	to do its job in an event-driven fashion.  We must therefore
			 *	fail the creation of this controller.
			 */
			WARNING_OUT (("Controller::Controller: failure creating thread"));
			*mcs_error = MCS_ALLOCATION_FAILURE;
		}
	}

	if (*mcs_error == MCS_NO_ERROR) {
		// We need to wait until the event loop thread creates the TCP msg window.
		WaitForSingleObject (Synchronization_Event, INFINITE);
		if (TCP_Window_Handle == NULL) {
			WARNING_OUT (("Controller::Controller: The event-loop thread failed to create the TCP msg window."));
			*mcs_error = MCS_NO_TRANSPORT_STACKS;

			/*
			 *	We assume that the event loop thread has exited.
			 */
			ClosePh (&g_hMCSThread);
		}
		else {
			/*
			 *	We set the flag used by the destructor
			 *	to check whether we should wait for the thread to finish.
			 */
			m_fControllerThreadActive = TRUE;
		}
	}

        if (*mcs_error == MCS_NO_ERROR)
	{
            g_CNPCoder = new CCNPCoder();
            if (g_CNPCoder != NULL) 
            {
                g_CNPCoder->Init();
            }
            else
            {
                WARNING_OUT(("Controller::Controller: "
                             "failuer allocating CNP Coder"));
                *mcs_error = MCS_ALLOCATION_FAILURE;
            }			
	}
        
	/*
	 *	Now, load the transport interface.
	 */
	if (*mcs_error == MCS_NO_ERROR)
	{
		DBG_SAVE_FILE_LINE
		g_Transport = new TransportInterface (Transport_Transmit_Event, 
													&transport_interface_error);

		/*
		 *	Make sure the creation of the object was successful before
		 *	proceeding.
		 */
		if (g_Transport != NULL)
		{
			/*
			 *	Check the return value from the constructor.
			 */
			if (transport_interface_error == TRANSPORT_INTERFACE_NO_ERROR)
			{
				/*
				 *	If everything was successful, put the new transport
				 *	interface object into the dictionary.
				 */
				WARNING_OUT (("Controller::Controller: "
						"TCP transport interface has been created successfully."));
			}
			else
			{
				/*
				 *	If the return value indicates that something went
				 *	wrong during the creation of the transport interface
				 *	object, then must destroy it immediately to insure
				 *	that it does not get used.
				 */
				WARNING_OUT (("Controller::Controller: "
						"deleting faulty TCP transport interface"));
				delete g_Transport;
				g_Transport = NULL;
				*mcs_error = MCS_NO_TRANSPORT_STACKS;
			}
		}
		else
		{
			/*
			 *	We were unable to create the transport interface object.
			 *	The MCS_NO_TRANSPORT_STACKS error is now a fatal error.
			 */
			WARNING_OUT (("Controller::Controller: "
					"failure allocating TCP transport interface"));
			*mcs_error = MCS_NO_TRANSPORT_STACKS;
		}
	}
}

/*
 *	~Controller ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the Controller.  It destroys all objects
 *		owned by the controller.  Note that it attempts to do this in a
 *		systematic way to facilitate cleanup shut down.  If first deletes
 *		connection objects, giving them the opportunity to send disconnects
 *		to both the local and remote domains.  Then it deletes the transport
 *		interfaces.  Next it deletes the user objects, giving them the
 *		opportunity to cleanly sever their attachments to both the user
 *		applications and the local domains.  Then it deletes the application
 *		interfaces (which should no longer be needed).  Lastly it deletes
 *		the domains, which should be empty as a result of all user attachments
 *		and MCS connections being destroyed.
 */
Controller::~Controller ()
{
	PConnection				lpConnection;
	PConnectionPending		lpConnectionPending;
	//PTransportInterface		lpTransportInterface;
	//PUser					lpUser;
	PDomain					lpDomain;

	/*
	 *	We need to wait for the mutex before destroying the controller.  Note
	 *	that we do not check the return value from the wait because we have to
	 *	destroy this object no matter what.
	 */
	EnterCriticalSection (&g_MCS_Critical_Section);
	
	/*
	 *	This code clears out the Connection List.  Here it necessary to delete
	 *	not only the connection objects, but also the connection information
	 *	structure which is maintained by the controller.
	 */
	m_ConnectionList2.Reset();
	while (NULL != (lpConnection = m_ConnectionList2.Iterate()))
	{
		delete lpConnection;
	}

	Connection_Deletion_Pending = FALSE;

	/*
	 *	Clear out the connection pending list.  This includes freeing up memory
	 *	that was allocated to hold the connection pending structure.
	 */
	while (NULL != (lpConnectionPending = m_ConnPendingList2.Get()))
	{
		delete lpConnectionPending;
	}

	/*
	 *	This code clears out the Domain List.  All domain objects are deleted.
	 */
	while (NULL != (lpDomain = m_DomainList2.Get()))
    {
		delete lpDomain;
	}

	if (m_fControllerThreadActive)
	{
		/*
		 *	Set the flag that indicates to the event loop thread that it is time to
		 *	die.  Then, we wait for the thread to terminate itself.
		 */
		Controller_Closing = TRUE;

		// Give the eventloop a chance to exit
		SetEvent(Connection_Deletion_Pending_Event);
	}

	// We can now leave MCS's critical section
	LeaveCriticalSection (&g_MCS_Critical_Section);

	/*
	 *	If a thread termination event was successfully created for this controller, we must
	 *	wait on it.
	 */
	if (m_fControllerThreadActive)
	{
		/*
		 *	If the DLL instance variable is NULL, the process is 
		 *	detaching from the DLL.  This is the abnormal termination
		 *	case (after a GPF, for example). In this case, the event
		 *	loop thread has already exited, and we should not wait for it.
		 */
		if (g_hDllInst != NULL)
			WaitForSingleObject (Synchronization_Event, INFINITE);
			
		CloseHandle (Synchronization_Event);
		//
		//  Relinquish the remainder of our time slice, to allow controller thread to exit.
		//
		Sleep(0);
	}

	// Now, we can delete MCS's critical section
	DeleteCriticalSection (&g_MCS_Critical_Section);

	// Delete the transport interface and the application interfaces
	delete g_Transport;
		
	/*
	 *	If an event object was successfully allocated for application interface
	 *	events, then destroy it.
	 */
	if (Transport_Transmit_Event != NULL)
		CloseHandle (Transport_Transmit_Event);

	/*
	 *	If an event object was successfully allocated for connection deletion pending
	 *	events, then destroy it.
	 */
	if (Connection_Deletion_Pending_Event != NULL)
		CloseHandle (Connection_Deletion_Pending_Event);
	
	/*
	 *	If there is a packet coder, then delete it here.
	 */
	delete g_MCSCoder;

	delete g_CNPCoder;
	// Cleanup the User class
	User::CleanupClass();
	
	// Free up the preallocated DataPacket objects.
	DataPacket::FreeMemoryPool ();

	g_pMCSController = NULL;
}

 /*
 *	ULong APIENTRY	ControllerThread ()
 *
 *	Public
 *
 *	Functional Description:
 */
ULong APIENTRY	ControllerThread (
						PVoid		controller_ptr)
{
		//BOOL    		bTcpOK;
		PController		pController = (PController) controller_ptr;
	/*
	 *	This is the "C" entry point for the controller thread.  All it does is
	 *	use the address passed in to invoke the proper public member function of
	 *	the object that owns the thread.  All real work is done in the C++
	 *	member function.
	 */

	/* Set the New Thread's Priority. It's OK if the call fails.  */
	SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

	pController->CreateTCPWindow ();
	SetEvent (pController->Synchronization_Event);

	if (TCP_Window_Handle != NULL) {
		// Initialize QoS
		CoInitialize(NULL);
		InitializeQoS();
		pController->EventLoop ();

		/*
		 *	Destroy the TCP window.  Since we are here, it has been created
		 *	successfully.
		 */
		pController->DestroyTCPWindow ();

		// Notify the Controller destructor that the thread exited
		SetEvent (pController->Synchronization_Event);

		// Cleanup QoS
		DeInitializeQoS();
		CoUninitialize();
	}
		
	return (0);
}


/*
 *	Void CreateTCPWindow ()
 *
 *	Private
 *
 *	Functional Description:
 *		This method registers the class of the TCP window and creates it.
 *
 *	Returns:
 *		TRUE, if successful. FALSE, otherwise
 */

Void Controller::CreateTCPWindow ()
{
	/*
	 *	Create the window and the resources needed by the transport
	 */
	WNDCLASS window_class = {
				0,					/* style */
				WindowProcedure,	/* lpfnWndProc */
				0,					/* cbClsExtra */
				0,					/* cbWndExtra */
				0,					/* hInstance */
				NULL,				/* hIcon */
				NULL,				/* hCursor */
				NULL,				/* hbrBackground */
				NULL,				/* lpszMenuName */
				MSMCSTCP_WINDOW_CLASS_NAME	/* lpszClassName */
			};

		/* Get the HINSTANCE for this Thread */
	window_class.hInstance = g_hDllInst;

	/* Register the hidden window's class */
	if(RegisterClass((const WNDCLASS *) (&window_class)) != 0) {
		TCP_Window_Handle = CreateWindow(
					MSMCSTCP_WINDOW_CLASS_NAME,	/* address of registered class name */
    				MSMCSTCP_WINDOW_CLASS_NAME,	/* address of window name */
    				WS_POPUP,					/* window style */
		    		CW_USEDEFAULT,				/* horizontal position of window */
    				CW_USEDEFAULT,				/* vertical position of window */
		    		CW_USEDEFAULT,				/* window width */
    				CW_USEDEFAULT,				/* window height */
		    		HWND(NULL),	       			/* handle of parent or owner window */
    				HMENU(NULL),				/* handle of menu */
		    		g_hDllInst,					/* handle of application instance */
    				LPVOID(NULL)); 				/* address of window-creation data */

		if(TCP_Window_Handle != NULL) {
#ifndef NO_TCP_TIMER
			/* Create a timer */
		    Timer_ID = SetTimer (TCP_Window_Handle, 0, 
               					(unsigned int) MSMCSTCP_TIMER_DURATION,
               					(TIMERPROC) NULL);
#endif	/* NO_TCP_TIMER */
		}
		else {
			WARNING_OUT (( "Controller::CreateTCPWindow: Error Creating %s", MSMCSTCP_WINDOW_CLASS_NAME));
		}
	}
	else {
		WARNING_OUT (( "Controller::CreateTCPWindow: Error Registering %s",MSMCSTCP_WINDOW_CLASS_NAME));
	}
}



/*
 *	Void DestroyTCPWindow ()
 *
 *	Private
 *
 *	Functional Description:
 *		This method destroys the TCP window and its class.
 *
 */

Void Controller::DestroyTCPWindow ()
{
	/*
	 *	This code clears out the TCP Transport interface.
	 */
	if (TCP_Window_Handle != NULL) {
		TRACE_OUT(("Controller::DestroyTCPWindow: Destroying TCP window..."));
#ifndef NO_TCP_TIMER
	    if (Timer_ID != 0)
    		KillTimer (TCP_Window_Handle, Timer_ID);
#endif	/* NO_TCP_TIMER */
		if(DestroyWindow (TCP_Window_Handle) == FALSE)
		{
			WARNING_OUT (("Controller::DestroyTCPWindow: Error Destroying %s", MSMCSTCP_WINDOW_CLASS_NAME));
		}
			
		/* Unregister the Window Class */
		if(UnregisterClass(MSMCSTCP_WINDOW_CLASS_NAME, g_hDllInst) == FALSE)
		{
			WARNING_OUT (("Controller::DestroyTCPWindow: Error Unregistering %s",	MSMCSTCP_WINDOW_CLASS_NAME));
		}
	}
}

/*
 *	Void	EventLoop ()
 *
 *	Public
 *
 *	Functional Description:
 */
Void	Controller::EventLoop ()
{
	HANDLE		event_list[NUMBER_OF_EVENTS];
	ULong		object_signaled;
	BOOL    	bFlushMoreData;
	MSG			msg;
	BOOL        fGCCWork;

    //
    // Externals from GCC.
    //
    extern HANDLE g_hevGCCOutgoingPDU;
    BOOL GCCRetryFlushOutgoingPDU ( void );

	/*
	 *	Set the initial timeout interval to infinite
	 */
	Controller_Wait_Timeout = INFINITE;
	Controller_Event_Mask = 0;

	/*
	 *	Set up the event list (this is used in the Wait call below).
	 */
	event_list[TRANSPORT_TRANSMIT_EVENT] = Transport_Transmit_Event;
	event_list[CONNECTION_DELETION_PENDING_EVENT] = Connection_Deletion_Pending_Event;
	event_list[GCC_FLUSH_OUTGOING_PDU_EVENT] = g_hevGCCOutgoingPDU;
	
	/*
	 *	Continue looping until this controller closes down.
	 */
	while (TRUE)
	{
		// Process the TCP window messages.
		while (PeekMessage (&msg, TCP_Window_Handle, 0, 0, PM_REMOVE)) {
			ASSERT (TCP_Window_Handle == msg.hwnd);
			EnterCriticalSection (&g_MCS_Critical_Section);
			DispatchMessage (&msg);
			LeaveCriticalSection (&g_MCS_Critical_Section);
		}

		/*
		 *	Go wait for something to happen (or for the timeout to expire,
		 *	which will cause us to poll for unfinished activity).
		 */
		object_signaled = MsgWaitForMultipleObjects (NUMBER_OF_EVENTS, event_list,
									FALSE, Controller_Wait_Timeout, QS_ALLINPUT);

        //
        // Default is that no GCC work needs to be done.
        //
        fGCCWork = FALSE;

		/*
		 *	Wait for the critical section to be available, before performing
		 *	any work on the event.
		 */
		EnterCriticalSection (&g_MCS_Critical_Section);
		
		if(Controller_Closing) {
			LeaveCriticalSection (&g_MCS_Critical_Section);
			break;
		}

		/*
		 *	Respond to the event dependent on which event occured.
		 */
		switch (object_signaled) {
		case WAIT_TIMEOUT:
		    fGCCWork = (Controller_Event_Mask & GCC_FLUSH_OUTGOING_PDU_MASK);
			/* 
			 *	We need to retry an operation.
			 */
			PollMCSDevices ();
			break;

		case WAIT_OBJECT_0 + CONNECTION_DELETION_PENDING_EVENT:
			/*
			 *	If a Connection object has asked to be deleted, then do it.
			 */
			while (Connection_Deletion_Pending)
			{
				CConnectionList2	Deletion_Pending_Copy(m_ConnectionDeletionList2);
				ConnectionHandle    connection_handle;
				PConnection			connection;

				Connection_Deletion_Pending = FALSE;
				while (NULL != (connection = Deletion_Pending_Copy.Get(&connection_handle)))
				{
					/*
					 *	Get the handle and pointer to the connection object to
					 *	be deleted.  Then remove it from both the connection
					 *	list, and the connection polling list.  Finally, delete
					 *	the connection object.
					 */
					m_ConnectionList2.Remove(connection_handle);
					m_ConnPollList.Remove(connection);
					delete connection;		// This could set the Connection_Deletion_Pending flag to TRUE
					m_ConnectionDeletionList2.Remove(connection_handle);
				}
				if (Connection_Deletion_Pending == FALSE)
				{
					m_ConnectionDeletionList2.Clear();
				}
			}
			break;

		case WAIT_OBJECT_0 + TRANSPORT_TRANSMIT_EVENT:
			/*
			 *	Iterate through the poll list, asking each connection to
			 *	flush any queued messages.
			 */
			PConnection lpConnection;

			bFlushMoreData = FALSE;
			Domain_Traffic_Allowed = TRUE;
			m_ConnPollList.Reset();
			while (NULL != (lpConnection = m_ConnPollList.Iterate()))
			{
				 if (lpConnection->FlushMessageQueue ()) {
				 	bFlushMoreData = TRUE;

				 	/*
				 	 *	We have flushed the connection, but it has more to send to 
				 	 *	the other end. Normally, we will get an FD_WRITE that allows
				 	 *	us to resume sending the queued data and will set this event
				 	 *	again to allow more sending. However, there is a special case
				 	 *	when the domain traffic is disallowed while a connection is
				 	 *	coming up.  For this case, the timeout has to be small, and
				 	 *	we need to set the Domain_Traffic_Allowed variable to 
				 	 *	distinguish between the two cases.
				 	 */
				 	Domain_Traffic_Allowed &= lpConnection->IsDomainTrafficAllowed();
				 }
			}
			UpdateWaitInfo (bFlushMoreData, TRANSPORT_TRANSMIT_INDEX);
			break;

		case WAIT_OBJECT_0 + GCC_FLUSH_OUTGOING_PDU_EVENT:
		    fGCCWork = TRUE;
		    break;
		}

		// Leave the MCS critical section
		LeaveCriticalSection (&g_MCS_Critical_Section);

        //
        // GCC work is done here WITHOUT MCS critical section.
        // The order of critical section in T120 is always GCC in front of MCS.
        // If we enter MCS here and enter GCC later in GCCRetryFlushOutgoingPDU(),
        // then we introduce a potential deadlock.
        //
        if (fGCCWork)
        {
            ASSERT(WAIT_TIMEOUT == object_signaled ||
                   (WAIT_OBJECT_0 + GCC_FLUSH_OUTGOING_PDU_EVENT) == object_signaled);

            bFlushMoreData = GCCRetryFlushOutgoingPDU();

            UpdateWaitInfo (bFlushMoreData, GCC_FLUSH_OUTGOING_PDU_INDEX);
        }
	}
}


/*
 *	Controller::UpdateWaitInfo ()
 *
 *	Private Function Description
 *		This routine updates the instance variables Controller_Wait_Timeout
 *		and Controller_Event_Mask after the processing of an event
 *		in the EventLoop.
 *
 *	Formal Parameters:
 *		bMoreData	-	(i)	Flag that informs us whether the msg flush										that holds a GCC conference query 
 *							triggered by the event was complete or left msgs
 *							unprocessed
 *		EventMask	-	(i)	Tells us which event was processed
 *
 *	Return Value
 *		None
 *
 *  Side Effects
 *		Controller_Event_Mask and Controller_Wait_Timeout are updated
 *
 *	Caveats
 *		None
 */

Void Controller::UpdateWaitInfo (
					BOOL    		bMoreData,
					unsigned int	index)
{
	if (bMoreData) {
		Controller_Event_Mask |= (0x1 << index);
	}
	else {
		if (0 != Controller_Event_Mask)
			Controller_Event_Mask &= ~(0x1 << index);
	}
	
	if (0 == Controller_Event_Mask)
		Controller_Wait_Timeout = INFINITE;
	else if (Controller_Event_Mask & TRANSPORT_MASK) {
		if ((Controller_Event_Mask & TRANSPORT_TRANSMIT_MASK) &&
			 (Domain_Traffic_Allowed == FALSE))
			Controller_Wait_Timeout = CONTROLLER_THREAD_TIMEOUT;
		else if (Controller_Event_Mask & TRANSPORT_RECEIVE_MASK)
			Controller_Wait_Timeout = TRANSPORT_RECEIVE_TIMEOUT;
		else
			Controller_Wait_Timeout = TRANSPORT_TRANSMIT_TIMEOUT;
	}
	else
		Controller_Wait_Timeout = CONTROLLER_THREAD_TIMEOUT;
}

/*
 *	ULong	OwnerCallback ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the owner callback entry function for the controller.  It is
 *		through this function that all of the controller's "children" make
 *		requests of the controller.  Rather than put a lot of otherwise
 *		unrelated code in one place, this function merely unpacks the
 *		parameters and sends them to a different private member function
 *		for each owner callback.
 *
 *		Sometimes the parameters are packed directly into the two long
 *		parameters, and sometimes one of the parameters is a pointer to a
 *		structure that contains more data.  This function takes care of that
 *		distinction, and passes the appropriate data along to each separate
 *		member function.
 */
void Controller::HandleTransportDataIndication
(
    PTransportData      pTransport_data
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    TransportDataIndication(pTransport_data->transport_connection,
                            pTransport_data->user_data,
                            pTransport_data->user_data_length);

    // We need to free up the transport buffer with the original data.
    FreeMemory(pTransport_data->memory);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);
}

void Controller::HandleTransportWaitUpdateIndication
(
    BOOL    fMoreData
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    /*
     *	We are setting ourselves to wake up again after some time
     *	because there has been a read message that could not allocate any
     *	buffers.
     */
    UpdateWaitInfo(fMoreData, TRANSPORT_RECEIVE_INDEX);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);
}

#ifdef NM_RESET_DEVICE
MCSError Controller::HandleAppletResetDevice
(
    PResetDeviceInfo    pDevInfo
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    MCSError rc = ApplicationResetDevice(pDevInfo->device_identifier);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);

    return rc;
}
#endif // NM_RESET_DEVICE

MCSError Controller::HandleAppletCreateDomain
(
    GCCConfID   *domain_selector
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    MCSError rc = ApplicationCreateDomain(domain_selector);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);

    return rc;
}

MCSError Controller::HandleAppletDeleteDomain
(
    GCCConfID   *domain_selector
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    MCSError rc = ApplicationDeleteDomain(domain_selector);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);

    return rc;
}

MCSError Controller::HandleAppletConnectProviderRequest
(
    PConnectRequestInfo pReqInfo
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    MCSError rc = ApplicationConnectProviderRequest(pReqInfo);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);

    return rc;
}

MCSError Controller::HandleAppletConnectProviderResponse
(
    PConnectResponseInfo pRespInfo
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    MCSError rc = ApplicationConnectProviderResponse(
                        pRespInfo->connection_handle,
                        pRespInfo->domain_selector,
                        pRespInfo->domain_parameters,
                        pRespInfo->result,
                        pRespInfo->user_data,
                        pRespInfo->user_data_length);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);

    return rc;
}

MCSError Controller::HandleAppletDisconnectProviderRequest
(
    ConnectionHandle    hConn
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    MCSError rc = ApplicationDisconnectProviderRequest(hConn);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);

    return rc;
}

MCSError Controller::HandleAppletAttachUserRequest
(
    PAttachRequestInfo  pReqInfo
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    MCSError rc = ApplicationAttachUserRequest(pReqInfo->domain_selector,
                                               pReqInfo->ppuser);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);

    return rc;
}

void Controller::HandleConnDeleteConnection
(
    ConnectionHandle    hConn
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    ConnectionDeleteConnection(hConn);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);
}

void Controller::HandleConnConnectProviderConfirm
(
    PConnectConfirmInfo pConfirmInfo,
    ConnectionHandle    hConn
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    ConnectionConnectProviderConfirm(hConn,
                                     pConfirmInfo->domain_parameters,
                                     pConfirmInfo->result,
                                     pConfirmInfo->memory);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);
}

void Controller::HandleTransportDisconnectIndication
(
    TransportConnection     TrnsprtConn,
    ULONG                  *pnNotify
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    TransportDisconnectIndication(TrnsprtConn);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);
}

#ifdef TSTATUS_INDICATION
void Controller::HandleTransportStatusIndication
(
    PTransportStatus    pStatus
)
{
    // Wait for the critical section before attempting any processing
    EnterCriticalSection(&g_MCS_Critical_Section);

    TransportStatusIndication(pStatus);

    // Release the critical section
    LeaveCriticalSection(&g_MCS_Critical_Section);
}
#endif


#ifdef NM_RESET_DEVICE
/*
 *	ULong	ApplicationResetDevice ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to send a reset command to a specified transport
 *		stack.  MCS performs no processing on this command except to pass it
 *		through.
 *
 *	Formal Parameters:
 *		device_identifier
 *			This is an ASCII string that is passed through to the transport
 *			stack to effect the reset.  It will typically contain information
 *			identifying which device within the stack is to be reset.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything worked fine.
 *		MCS_INVALID_PARAMETER
 *			The specified transport stack does not exist.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
ULong	Controller::ApplicationResetDevice (
				PChar				device_identifier)
{
	TransportError			transport_error;
	MCSError				return_value;

	ASSERT (g_Transport != NULL);
	
	/*
	 *	Forward the reset device command to the transport interface
	 *	object.
	 */
	TRACE_OUT(("Controller::ApplicationResetDevice: "
				"sending ResetDevice to transport interface"));
	transport_error = g_Transport->ResetDevice (device_identifier);

	/*
	 *	Set the return value appropriate for the value returned from the
	 *	transport call.
	 */
	switch (transport_error)
	{
		case TRANSPORT_ILLEGAL_COMMAND:
			return_value = MCS_INVALID_PARAMETER;
			break;

		case TRANSPORT_MEMORY_FAILURE:
			return_value = MCS_ALLOCATION_FAILURE;
			break;

		default:
			return_value = MCS_NO_ERROR;
	}

	//
	// Remove this connection from the connection list
	//
	PConnection			connection;
	ConnectionHandle	connection_handle;

	while (NULL != (connection = m_ConnectionList2.Iterate(&connection_handle)))
	{
		if (0 == ::My_strcmpA(connection->GetCalledAddress(), device_identifier))
		{
			PNodeControllerMessage		node_controller_message;

			DBG_SAVE_FILE_LINE
			node_controller_message = new NodeControllerMessage;

			if (node_controller_message != NULL) {
				/*
				 *	Fill out the node controller message structure to indicate the
				 *	disconnect.
				 */
				node_controller_message->message_type =
							MCS_DISCONNECT_PROVIDER_INDICATION;
				node_controller_message->u.disconnect_provider_indication.
							connection_handle = (ConnectionHandle) connection_handle;
				node_controller_message->u.disconnect_provider_indication.
							reason = REASON_DOMAIN_DISCONNECTED;
				node_controller_message->memory = NULL;

				/*
				 *	Put the message into the control queue to be sent to the node
				 *	controller during the next heartbeat.
				 */
				AddToMessageQueue (node_controller_message);
			}
			else 
				ERROR_OUT (("Controller::ApplicationResetDevice: "
							"failed to allocate node controller msg"));
		}
	}

	return ((ULong) return_value);
}
#endif //NM_RESET_DEVICE


/*
 *	Controller::PollMCSDevices ()
 *
 *	Public Function Description
 *		This is the MCS controller's heartbeat. It will call the heartbeat
 *		equivalent functions for the Application SAPs, the connections and
 *		the users.
 */
Void	Controller::PollMCSDevices()
{
	BOOL    		bFlushMoreData;

	if (Controller_Event_Mask & TRANSPORT_TRANSMIT_MASK) {
		/*
		 *	Iterate through the poll list, asking each connection to
		 *	flush any queued messages.
		 */
		PConnection lpConnection;

		bFlushMoreData = FALSE;
		Domain_Traffic_Allowed = TRUE;
		m_ConnPollList.Reset();
		while (NULL != (lpConnection = m_ConnPollList.Iterate()))
		{
			 if (lpConnection->FlushMessageQueue ()) {
			 	bFlushMoreData = TRUE;

			 	/*
			 	 *	We have flushed the connection, but it has more to send to 
			 	 *	the other end. Normally, we will get an FD_WRITE that allows
			 	 *	us to resume sending the queued data and will set this event
			 	 *	again to allow more sending. However, there is a special case
			 	 *	when the domain traffic is disallowed while a connection is
			 	 *	coming up.  For this case, the timeout has to be small, and
			 	 *	we need to set the Domain_Traffic_Allowed variable to 
			 	 *	distinguish between the two cases.
			 	 */
			 	Domain_Traffic_Allowed &= lpConnection->IsDomainTrafficAllowed();
			 }
		}
		UpdateWaitInfo (bFlushMoreData, TRANSPORT_TRANSMIT_INDEX);			
	}

	if (Controller_Event_Mask & TRANSPORT_RECEIVE_MASK) {
		ASSERT (g_Transport);
		g_Transport->ReceiveBufferAvailable();
	}

}

/*
 *	MCSError	ApplicationCreateDomain ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request comes through one of the application interface objects.
 *		the only parameter is a domain selector.  If a domain with that
 *		selector does not currently exist, it will be created.
 *
 *		A domain must be created before user attachments or MCS connections can
 *		be created.
 *
 *	Formal Parameters:
 *		domain_selector (i)
 *			This is the domain selector for the new domain.
 *		domain_selector_length (i)
 *			This is the length of the above domain selector.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			The domain was successfully created.
 *		MCS_ALLOCATION_FAILURE
 *			A memory allocation failure prevented the successful creation of
 *			the new domain.
 *		MCS_DOMAIN_ALREADY_EXISTS
 *			The named domain already exists.
 *
 *	Side Effects:
 *		A logical domain now exists that can accomodate both user attachments
 *		and MCS connections.
 *
 *	Caveats:
 *		None.
 */
MCSError Controller::ApplicationCreateDomain
(
    GCCConfID      *domain_selector
)
{
	PDomain		domain;
	MCSError	return_value;

	/*
	 *	Check to see if the requested domain already exists.  If so, then
	 *	do not attempt to create a new one.  Just return the appropriate
	 *	return value.
	 */
	if (m_DomainList2.Find(*domain_selector) == FALSE)
	{
		/*
		 *	The next action is to instantiate a new domain object.  This
		 *	is initially an empty domain that will be associated with the
		 *	user provided domain selector.
		 */
		DBG_SAVE_FILE_LINE
		domain = new Domain ();
		if (domain != NULL)
		{
			/*
			 *	If everything was allocated successfully, then simply put
			 *	the new domain into the domain list dictionary.  and set the
			 *	return value to indicate success.
			 */
			TRACE_OUT (("Controller::ApplicationCreateDomain: "
					"domain creation successful"));
			if(!m_DomainList2.Append(*domain_selector, domain))
			{
				delete domain;
				return_value = MCS_ALLOCATION_FAILURE;
			}
			else
			{
				return_value = MCS_NO_ERROR;
			}
		}
		else
		{
			/*
			 *	Set the return value to indication a memory allocation failure.
			 */
			WARNING_OUT (("Controller::ApplicationCreateDomain: "
					"domain creation failed"));
			return_value = MCS_ALLOCATION_FAILURE;
		}
	}
	else
	{
		/*
		 *	The domain was not created since it already exists.
		 */
		WARNING_OUT (("Controller::ApplicationCreateDomain: "
				"domain already exists"));
		return_value = MCS_DOMAIN_ALREADY_EXISTS;
	}

	return (return_value);
}

/*
 *	MCSError	ApplicationDeleteDomain ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request comes from one of the application interface objects.  It
 *		instructs the controller to delete an existing domain, with the only
 *		parameter identifying the domain to be deleted.  If the domain exists,
 *		then it will be destroyed.
 *
 *		Note that all user attachments and MCS connections that are attached
 *		to the domain when it is deleted will also be deleted (automatically).
 *
 *	Formal Parameters:
 *		domain_selector (i)
 *			This is the domain selector for the domain to be deleted.
 *		domain_selector_length (i)
 *			This is the length of the above domain selector.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			The domain was successfully deleted.
 *		MCS_NO_SUCH_DOMAIN
 *			There is no domain associated with the passed in domain selector.
 *
 *	Side Effects:
 *		When the domain is deleted, all resources used by it (including user
 *		attachments and MCS connections) will be deleted as well.
 *
 *	Caveats:
 *		None.
 */
MCSError Controller::ApplicationDeleteDomain
(
    GCCConfID       *domain_selector
)
{
	PDomain		domain;
	MCSError	return_value;

	/*
	 *	Check to see if the domain selector refers to a valid domain.
	 */
	if (NULL != (domain = m_DomainList2.Remove(*domain_selector)))
	{
		/*
		 *	If the domain selector is valid, then remove the domain from the
		 *	dictionary and delete it.  Everything else happens automatically
		 *	as a result of destroying the domain object.
		 */
		TRACE_OUT (("Controller::ApplicationDeleteDomain: deleting domain"));
		delete domain;
		return_value = MCS_NO_ERROR;
	}
	else
	{
		/*
		 *	If the domain selector is not in the dictionary, then report the
		 *	error to the caller.
		 */
		ERROR_OUT (("Controller::ApplicationDeleteDomain: invalid domain"));
		return_value = MCS_NO_SUCH_DOMAIN;
	}

	return (return_value);
}

/*
 *	MCSError	ApplicationConnectProviderRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request originates from one of the application interface objects.
 *		This happens as the result of the node controller issuing a
 *		ConnectProviderRequest to whichever application interface object
 *		that it is attached to.  If the parameters are valid, then a new
 *		connection object will be created to represent the outbound connection.
 *		This will result in the connection object calling the proper transport
 *		interface to create the transport connection, etc.
 *
 *	Formal Parameters:
 *		pcriConnectRequestInfo (i)
 *			Contains all the needed info to complete the Connect Provider Request.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			The request was successful.  The connection handle for the newly
 *			created connection has been stored at the address passed into this
 *			request (see parameter list above).  Note that this connection
 *			handle can be used to destroy the new connection immediately, even
 *			if the physical connection has not yet been established.  This
 *			allows the node controller to abort a dial in-progress by calling
 *			DisconnectProviderRequest.
 *		MCS_INVALID_PARAMETER
 *			The format of the called address field is incorrect.
 *		MCS_ALLOCATION_FAILURE
 *			The request was unable to complete successfully due to a memory
 *			allocation failure (either in MCS or the transport layer).
 *		MCS_TRANSPORT_NOT_READY
 *			The transport layer could not process the request because it is not
 *			ready.  This usually means that initialization has not successfully
 *			completed.
 *		MCS_DOMAIN_NOT_HIERARCHICAL
 *			This request is attempting to create an upward connection to a
 *			domain that already has an upward connection (which is not valid).
 *		MCS_NO_SUCH_DOMAIN
 *			The specified local domain does not exist within this provider.
 *
 *	Side Effects:
 *		An outbound connect establishment process is begun.
 *
 *	Caveats:
 *		None.
 */
MCSError Controller::ApplicationConnectProviderRequest (
						PConnectRequestInfo		pcriConnectRequestInfo)
{
	PDomain					domain;
	BOOL					bTransportIdFound;
	PConnection				connection;
	MCSError				return_value; 
	PChar					called_address = pcriConnectRequestInfo->called_address;
	PConnectionHandle		connection_handle = pcriConnectRequestInfo->connection_handle;

	/*
	 *	Make sure the local domain specified corresponds to an existing
	 *	domain.
	 */
	ASSERT(sizeof(GCCConfID) == sizeof(*(pcriConnectRequestInfo->calling_domain)));
	if (NULL != (domain = m_DomainList2.Find(*(pcriConnectRequestInfo->calling_domain))))
	{
		/*
		 *	Check to make sure that the requested connection is valid.
		 *	Specifically, make sure that this is not a request for an upward
		 *	connection to a domain that already has an upward connection.
		 *	This would result in a non-hierarchical domain, which is illegal.
		 */
		if ((pcriConnectRequestInfo->upward_connection == FALSE) || (domain->IsTopProvider ()))
		{
			PChar		pColon;
			/*
			 *	Look for the colon that separates the identifier from the
			 *	address.  
			 */

			for (bTransportIdFound = FALSE, pColon = called_address; *pColon; pColon++)
				if (*pColon == ':') {
					bTransportIdFound = TRUE;
					break;
				}

			/*
			 *	Make sure that there was a colon before continuing.
			 */
			if (bTransportIdFound)
			{
				ASSERT (g_Transport != NULL);
				
				called_address = pColon + 1;
				/*
				 *	Allocate an unused connection handle to be
				 *	associated with the new MCS connection.
				 */
				*connection_handle = AllocateConnectionHandle ();

				/*
				 *	Create a new connection object.  The constructor
				 *	parameters provide everything that the connection
				 *	object will need to create a new outbound MCS
				 *	connection.
				 */
				DBG_SAVE_FILE_LINE
				connection = new Connection (domain,
						*connection_handle, 
						pcriConnectRequestInfo->calling_domain, 
						pcriConnectRequestInfo->called_domain, 
						called_address, 
						pcriConnectRequestInfo->fSecure,
						pcriConnectRequestInfo->upward_connection, 
						pcriConnectRequestInfo->domain_parameters,
						pcriConnectRequestInfo->user_data, 
						pcriConnectRequestInfo->user_data_length, 
						&return_value);
				/*
				 *	Check to see if the allocation of the connection
				 *	worked.
				 */
				if (connection != NULL)
				{
					/*
					 *	Even if the connection object was allocated
					 *	successfully, it is still possible that an error
					 *	occurred while it was trying to initialize.  So
					 *	check the return value from the contructor.
					 */
					if (return_value == MCS_NO_ERROR)
					{
						/*
						 *	Put the connection into the connection list
						 *	dictionary.
						 */
						TRACE_OUT (("Controller::ApplicationConnectProviderRequest: "
									"new connection created"));
						m_ConnectionList2.Insert(*connection_handle, connection);
						m_ConnPollList.Append(connection);
					}
					else
					{
						/*
						 *	If the connection object was successfully
						 *	allocated, but its initialization failed,
						 *	then it is necessary to destroy the faulty
						 *	connection and return the appropriate error
						 *	to the caller.
						 */
						WARNING_OUT (("Controller::ApplicationConnectProviderRequest: "
									"deleting faulty connection"));
						delete connection;
					}
				}
				else
				{
					/*
					 *	The allocation of the connection object has
					 *	failed.  Simply return the appropriate error and
					 *	abort the request.
					 */
					WARNING_OUT (("Controller::ApplicationConnectProviderRequest: "
								"connection allocation failed"));
					return_value = MCS_ALLOCATION_FAILURE;
				}

				// Put back the colon in the "called_address"  
				*pColon = ':';
			}
			else
			{
				/*
				 *	There was not a colon in the called address, so MCS has
				 *	no way of extracting the transport identifier.  The request
				 *	must therefore fail.
				 */
				ERROR_OUT (("Controller::ApplicationConnectProviderRequest: "
						"no colon in called address"));
				return_value = MCS_INVALID_PARAMETER;
			}
		}
		else
		{
			/*
			 *	The domain already has an upward connection (or one pending).
			 *	This request is therefore invalid and must be rejected.
			 */
			ERROR_OUT (("Controller::ApplicationConnectProviderRequest: "
					"domain not hierarchical"));
			return_value = MCS_DOMAIN_NOT_HIERARCHICAL;
		}
	}
	else
	{
		/*
		 *	If the local domain selector does not correspond to a valid
		 *	domain in this provider, then fail the request immediately by
		 *	returning the appropriate error.
		 */
		ERROR_OUT (("Controller::ApplicationConnectProviderRequest: "
				"invalid local domain"));
		return_value = MCS_NO_SUCH_DOMAIN;
	}

	return (return_value);
}

/*
 *	MCSError	ApplicationConnectProviderResponse ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request originates from one of the application interface objects.
 *		This happens as the result of the node controller issuing a
 *		ConnectProviderResponse to whichever application interface object
 *		that it is attached to.  If the connection handle is valid, and the
 *		local domain still exists, then that domain will be told whether or not
 *		the incoming connection was accepted.  This allows it to repsond
 *		appropriately.
 *
 *	Formal Parameters:
 *		connection_handle (i)
 *			This identifies the connection from which a previous connect
 *			provider indication originated.  This request essentially states
 *			whether or not this incoming connection is accepted.
 *		domain_selector (i)
 *			This is the domain selector of the domain that the node controller
 *			wishes to bind the incoming connection to.
 *		domain_selector_length (i)
 *			This is the length of the above domain selector.
 *		domain_parameters (i)
 *			This is a pointer to a structure containing the domain parameters
 *			that the node controller wishes to use for this connection.
 *		result (i)
 *			This is the result to be sent to the remote provider.  Coming
 *			from the node controller this should be either RESULT_SUCCESSFUL
 *			or RESULT_USER_REJECTED.  If it is anything but RESULT_SUCCESSFUL,
 *			the associated connection will be immediately destroyed.
 *		user_data (i)
 *			This is the address of the user data that is to be sent in the
 *			connect response PDU to the remote provider.
 *		user_data_length (i)
 *			This is the length of the user data to be sent in the connect
 *			response PDU to the remote provider.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			The response was sent to the appropriate domain successfully.
 *		MCS_DOMAIN_PARAMETERS_UNACCEPTABLE
 *			This indicates that there is no overlap in the min and max
 *			parameters specified by the remote node, and the min and max
 *			parameters acceptable to the specified domain.  Therefore, no
 *			connection is possible.  This does NOT indicate that there is
 *			anything wrong with the specified target parameters (which are
 *			just suggested values anyway).
 *		MCS_ALLOCATION_FAILURE
 *			The response failed due to a memory allocation failure.
 *		MCS_NO_SUCH_DOMAIN
 *			This indicates that the domain associated with the pending
 *			response has been deleted since the indication was sent.
 *		MCS_NO_SUCH_CONNECTION
 *			This indicates that the connection has been lost since the
 *			indication was issued.
 *		MCS_DOMAIN_NOT_HIERARCHICAL
 *			This request is attempting to create an upward connection to a
 *			domain that already has an upward connection (which is not valid).
 *
 *	Side Effects:
 *		If the response is other than RESULT_SUCCESSFUL, the transport
 *		connection that conveys the connect response PDU will be severed.
 *
 *	Caveats:
 *		None.
 */
MCSError Controller::ApplicationConnectProviderResponse (
				ConnectionHandle		connection_handle,
				GCCConfID              *domain_selector,
				PDomainParameters		domain_parameters,
				Result					result,
				PUChar					user_data,
				ULong					user_data_length)
{
	PConnectionPending		connection_pending;
	TransportConnection		transport_connection;
	BOOL    				upward_connection;
	PDomain					domain;
	PConnection				connection;
	MCSError				return_value;

	/*
	 *	Check to see if the connection handle corresponds to a connection
	 *	that is awaiting a response.
	 */
	if (NULL != (connection_pending = m_ConnPendingList2.Find(connection_handle)))
	{
		/*
		 *	Get the address of the structure containing information about the
		 *	pending connection.  Then load the contained information into
		 *	automatic variables for easier manipulation.
		 */
		transport_connection = connection_pending->transport_connection;
		upward_connection = connection_pending->upward_connection;
		if (domain_parameters == NULL)
			domain_parameters = &connection_pending->domain_parameters;

		/*
		 *	See if the node controller has elected to accept or reject the
		 *	incoming connection.  If it is accepted, then the response must
		 *	be sent through the appropriate domain object.  If it is
		 *	rejected, then the response can be sent directly to the
		 *	connection object (which will then delete itself).
		 */
		if (result == RESULT_SUCCESSFUL)
		{
			/*
			 *	See if the specified domain is valid, before trying to send
			 *	the response to it.
			 */
			if (NULL != (domain = m_DomainList2.Find(*domain_selector)))
			{
				/*
				 *	Check to make sure that the requested connection is valid.
				 *	Specifically, make sure that this is not a request for an
				 *	upward connection to a domain that already has an upward
				 *	connection.  This would result in a non-hierarchical domain,
				 *	which is illegal.
				 */
				if ((upward_connection == FALSE) || (domain->IsTopProvider ()))
				{
					/*
					 *	Create the connection object that will be responsible
					 *	for the inbound connection.  It will automatically issue
					 *	a ConnectResponse during construction.
					 */
					DBG_SAVE_FILE_LINE
					connection = new Connection (domain, 
							connection_handle, transport_connection, 
							upward_connection, domain_parameters,
							&connection_pending->minimum_domain_parameters,
							&connection_pending->maximum_domain_parameters,
							user_data, user_data_length,
							&return_value);

					if (connection != NULL)
					{
						if (return_value == MCS_NO_ERROR)
						{
							/*
							 *	Everything worked fine.  Remove the connection
							 *	handle from the pending list, and put the newly
							 *	created connection object into the active
							 *	connection list.
							 */
							TRACE_OUT(("Controller::ApplicationConnectProviderResponse: "
									"connection created successfully"));
							m_ConnPendingList2.Remove(connection_handle);
							delete connection_pending;
							m_ConnectionList2.Insert(connection_handle, connection);
							m_ConnPollList.Append(connection);
						}
						else
						{
							/*
							 *	The contructor failed, which probably indicates
							 *	an allocation failure.  Report this to the node
							 *	controller, and delete the faulty connection
							 *	object.
							 */
							WARNING_OUT (("Controller::ApplicationConnectProviderResponse: "
									"connection constructor failed"));
							delete connection;
						}
					}
					else
					{
						/*
						 *	The allocation failed.  Report this to the node
						 *	controller.
						 */
						WARNING_OUT (("Controller::ApplicationConnectProviderResponse: "
								"connection constructor failed"));
						return_value = MCS_ALLOCATION_FAILURE;
					}
				}
				else
				{
					/*
					 *	The domain already has an upward connection (or one
					 *	pending).  This request is therefore invalid and must be
					 *	rejected.
					 */
					ERROR_OUT (("Controller::ApplicationConnectProviderResponse:"
							" domain not hierarchical"));
					return_value = MCS_DOMAIN_NOT_HIERARCHICAL;
				}
			}
			else
			{
				/*
				 *	If the indicated domain is not valid, then simply return
				 *	the appropriate error.
				 */
				WARNING_OUT (("Controller::ApplicationConnectProviderResponse: "
						"invalid domain"));
				return_value = MCS_NO_SUCH_DOMAIN;
			}
		}
		else
		{
			/*
			 *	The node controller has elected to reject the incoming
			 *	connection.  It is therefore not necessary to create a
			 *	connection object.  Send the connect response directly to
			 *	the transport interface object, and then disconnect the
			 *	transport connection.
			 */
			TRACE_OUT (("Controller::ApplicationConnectProviderResponse: connection rejected"));

			ASSERT (g_Transport);
			ConnectResponse (transport_connection, result, 
						domain_parameters, 0, user_data, user_data_length);

			g_Transport->DisconnectRequest (transport_connection);

			/*
			 *	Remove the connection handle from the pending list, and
			 *	delete the structure that was holding information about
			 *	the pending connection.
			 */
			m_ConnPendingList2.Remove(connection_handle);
			delete connection_pending;
			return_value = MCS_NO_ERROR;
		}
	}
	else
	{
		/*
		 *	If the connection handle is no longer valid, then fail the request
		 *	with the appropriate error.
		 */
		WARNING_OUT (("Controller::ApplicationConnectProviderResponse: "
				"invalid connection"));
		return_value = MCS_NO_SUCH_CONNECTION;
	}

	return (return_value);
}

/*
 *	MCSError	ApplicationDisconnectProviderRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request originates from one of the application interface objects.
 *		This happens as the result of the node controller issuing a
 *		DisconnectProviderRequest to whichever application interface object
 *		that it is attached to.  If the connection handle is valid, then the
 *		connection object wil be destroyed, which will break the transport
 *		connections associated with it.
 *
 *	Formal Parameters:
 *		connection_handle (i)
 *			This identifies the connection to be destroyed.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			The named connection has been successfully deleted.
 *		MCS_NO_SUCH_CONNECTION
 *			The connection handle is invalid.
 *
 *	Side Effects:
 *		One or more transport connections will be broken.  Furthermore, if
 *		this is an upward connection for a domain, then the domain itself
 *		will be eradicated (all attachments and connections will be severed).
 *
 *	Caveats:
 *		None.
 */
MCSError Controller::ApplicationDisconnectProviderRequest (
				ConnectionHandle		connection_handle)
{
	MCSError				return_value;
	PConnection				connection;
	PConnectionPending		connection_pending;

	/*
	 *	Check to see if the connection handle refers to an existing connection.
	 */
	if (NULL != (connection = m_ConnectionList2.Find(connection_handle)))
	{
		/*
		 *	If the connection handle is valid, then delete the associated
		 *	connection and remove it from the connection dictionary.  It is also
		 *	necessary to delete the connection information structure.
		 */
		TRACE_OUT (("Controller::ApplicationDisconnectProviderRequest: "
				"deleting connection"));
		m_ConnectionList2.Remove(connection_handle);
		m_ConnPollList.Remove(connection);
		delete connection;

		/*
		 *	Check to see if this connection handle is also in the connection
		 *	deletion list.  If so, then remove it from there as well.
		 */
		m_ConnectionDeletionList2.Remove(connection_handle);

		return_value = MCS_NO_ERROR;
	}

	else if (NULL != (connection_pending = m_ConnPendingList2.Remove(connection_handle)))
	{
		/*
		 *	This connection handle refers to a connection that is still
		 *	pending.  Delete it from there.
		 */
		WARNING_OUT (("Controller::ApplicationDisconnectProviderRequest: "
				"deleting pending connection"));
		delete connection_pending;

		return_value = MCS_NO_ERROR;
	}
	else
	{
		/*
		 *	If the connection handle is not in either of the above dictionaries,
		 *	then return the appropriate error.
		 */
		TRACE_OUT (("Controller::ApplicationDisconnectProviderRequest: "
				"invalid connection"));
		return_value = MCS_NO_SUCH_CONNECTION;
	}

	return (return_value);
}

/*
 *	MCSError	ApplicationAttachUserRequest ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is used to attach a user application to an existing
 *		domain.  The user handle that is returned can then be used by the
 *		application to request services from MCS.
 *
 *		After verifying that the specified domain really does exist, the
 *		controller will create a new user object.  The new user object will
 *		attach itself to both the domain and the application interface
 *		specified by the controller.  At that point, information can flow
 *		through the application interface to the user and then on to the
 *		domain without having to pass through the controller.
 *
 *	Formal Parameters:
 *		domain_selector (i)
 *			This identifies the domain to which the user wants to attach.
 *		domain_selector_length (i)
 *			This is the length of the above domain selector.
 *		attachment_flags (i)
 *			This is a set of flags that allow the user application to control
 *			how the attachment is handled.  The only flag currently used by
 *			the controller specifies whether or not the user wants to receive
 *			callbacks during the controller's heartbeat.
 *		ppUser (o)
 *			This is a pointer to a user handle, which will be set to a valid
 *			value by the controller if this function completes successfully.
 *			The user handle is really a pointer to a User object.
 *
 *	Return Value:
 *		MCS_NO_ERROR
 *			Everything completed successfully.  Note that the attachment
 *			cannot actually be used by the user application until it has
 *			received a successful attach user confirm from the domain to
 *			which it has attached.  This return value merely indicates that
 *			process was started successfully.
 *		MCS_ALLOCATION_FAILURE
 *			This attach request was unable to successfully complete due to a
 *			memory allocation failure.
 *		MCS_NO_SUCH_DOMAIN
 *			This attach request was unable to successfully complete because
 *			the specified domain does not exist within this provider.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
MCSError Controller::ApplicationAttachUserRequest
(
    GCCConfID       *domain_selector,
    PUser           *ppUser
)
{
	MCSError	return_value;
	PDomain		domain;

	/*
	 *	First of all make sure that the domain selector refers to a valid
	 *	domain.  If it doesn't, then return the appropriate error.
	 */
	if (NULL != (domain = m_DomainList2.Find(*domain_selector)))
	{
		/*
		 *	Instantiate a new user object, with the domain and the application
		 *	interface pointer as parameters.
		 */
		DBG_SAVE_FILE_LINE
		*ppUser = (PUser) new User (domain, &return_value);

		/*
		 *	Make sure the allocation completed successfully
		 */
		if (*ppUser != NULL) {
			/*
			 *	The creation of the user object was successful.
			 */
			if (return_value != MCS_NO_ERROR) {
				// We have to cleanup the object.
				(*ppUser)->Release();
			}
		}
		else {
			/*
			 *	There was a memory allocation failure, so return the
			 *	appropriate error.
			 */
			WARNING_OUT (("Controller::ApplicationAttachUserRequest: "
					"user creation failed"));
			return_value = MCS_ALLOCATION_FAILURE;
		}
	}
	else
	{
		/*
		 *	The specified domain does not exist, so return the appropriate
		 *	error.
		 */
		WARNING_OUT (("Controller::ApplicationAttachUserRequest: invalid domain"));
		return_value = MCS_NO_SUCH_DOMAIN;
	}

	return (return_value);
}

/*
 *	Void	ConnectionDeleteConnection ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request originates within a connection object when it determines
 *		the need to delete itself.  This is usually caused by one of three
 *		things.  First, the connection was rejected (inbound or outbound).
 *		Second, either the local or remote domain issued a disconnect
 *		provider ultimatum.  Or third, a transport connection was unexpectedly
 *		lost.
 *
 *		The controller responds by deleting the connection, after the
 *		parameters are validated.  It also issues a disconnect provider
 *		indication to the node controller.
 *
 *	Formal Parameters:
 *		connection_handle (i)
 *			This is the handle of the connection object that wishes to be
 *			deleted.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		An MCS connection is terminated, which may result in the destruction
 *		of one or more transport connections.
 *
 *	Caveats:
 *		None.
 */
Void	Controller::ConnectionDeleteConnection (
					ConnectionHandle    connection_handle)
{
	PConnection					connection;

	/*
	 *	Make sure the connection handle is in the dictionary before proceeding.
	 */
	if (NULL != (connection = m_ConnectionList2.Find(connection_handle)))
	{
		/*
		 *	See if the deletion of this connection is already pending.  If so,
		 *	there is no need to queue it up again.
		 */
		if (! m_ConnectionDeletionList2.Find(connection_handle))
		{
			/*
			 *	Put the connection object into the deletion list and set the
			 *	deletion pending flag.
			 */
			TRACE_OUT (("Controller::ConnectionDeleteConnection: "
					"adding connection to deletion list"));
			m_ConnectionDeletionList2.Insert(connection_handle, connection);
			Connection_Deletion_Pending = TRUE;
			SetEvent(Connection_Deletion_Pending_Event);

			/*
			 *	Post the message to the controller window (GCC and MCS
			 *	use the same window to post messages to their controllers).
			 */
			if (! PostMessage (g_pControlSap->GetHwnd(), 
							MCTRLMSG_BASE + MCS_DISCONNECT_PROVIDER_INDICATION,
							NULL, (LPARAM) connection_handle)) {
				ERROR_OUT(("Controller::ConnectionDeleteConnection: "
							"failed to post msg to MCS controller window. Error: %d", GetLastError()));
			}
		}
	}
	else
	{
		/*
		 *	If the connection handle cannot be found in the connection
		 *	dictionary, then simply ignore the request.
		 */
		WARNING_OUT (("Controller::ConnectionDeleteConnection: "
				"unknown connection"));
	}
}

/*
 *	Void	ConnectionConnectProviderConfirm ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request originates within a domain object upon reception of a
 *		connect response PDU.  The controller responds by sending a connect
 *		provider confirm to the node controller.
 *
 *	Formal Parameters:
 *		connection_handle (i)
 *			This is the handle of the connection object from which the connect
 *			provider confirm was received.
 *		domain_parameters (i)
 *			This is a pointer to a structure that contains the domain parameters
 *			that were decided on during capabilities arbitration.
 *		result (i)
 *			This contains the result of the connect request.  Anything but
 *			RESULT_SUCCESSFUL means that the connection was rejected.
 *		memory (i)
 *			If this is not NULL, it contains the user data that was received
 *			in the connect response PDU.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		A connect provider confirm is sent to the node controller.
 *
 *	Caveats:
 *		None.
 */
void	Controller::ConnectionConnectProviderConfirm (
				ConnectionHandle		connection_handle,
				PDomainParameters		domain_parameters,
				Result					result,
				PMemory					memory)
{
	PConnection					connection;
	PUChar						user_data;
	ULong						user_data_length;
	ConnectProviderConfirm		*pconnect_provider_confirm;

	/*
	 *	Make sure the connection handle is in the dictionary before proceeding.
	 */
	if (NULL != (connection = m_ConnectionList2.Find(connection_handle)))
	{
		// Allocate the node controller msg.
		DBG_SAVE_FILE_LINE
		pconnect_provider_confirm = new ConnectProviderConfirm;

		if (pconnect_provider_confirm != NULL) {
			/*
			 *	Check to see if there is user data associated with this confirm.
			 */
			if (memory != NULL)
			{
				/*
				 *	If there is user data, lock it, and get the address and length
				 *	into temporary variables.
				 */
				LockMemory (memory);
				user_data = memory->GetPointer ();
				user_data_length = memory->GetLength ();
			}
			else
			{
				/*
				 *	If there is no user data, then set the address and length fields
				 *	to default values.
				 */
				user_data = NULL;
				user_data_length = 0;
			}

			/*
			 *	Put all information about this confirm into the node controller
			 *	message structure allocated above.
			 */
			pconnect_provider_confirm->connection_handle = (ConnectionHandle) connection_handle;
			pconnect_provider_confirm->domain_parameters = *domain_parameters;
			pconnect_provider_confirm->result = result;
			pconnect_provider_confirm->user_data = user_data;
			pconnect_provider_confirm->user_data_length = user_data_length;
			pconnect_provider_confirm->pb_cred = NULL;
			pconnect_provider_confirm->cb_cred = 0;

			DWORD cb = 0;
			if (GetSecurityInfo(connection_handle, NULL, &cb))
			{
                            if (cb > 0 && NOT_DIRECTLY_CONNECTED != cb)
                            {
                                pconnect_provider_confirm->pb_cred = (PBYTE) CoTaskMemAlloc(cb);
                                if (NULL != pconnect_provider_confirm->pb_cred)
                                {
                                    if (GetSecurityInfo(connection_handle, pconnect_provider_confirm->pb_cred, &cb))
                                    {
                                        pconnect_provider_confirm->cb_cred = cb;
                                    }
                                    else
                                    {
                                        CoTaskMemFree(pconnect_provider_confirm->pb_cred);
                                        pconnect_provider_confirm->pb_cred = NULL;
                                    }
                                }
                                else
                                {
                                    ERROR_OUT(("Controller::ConnectionConnectProviderConfirm: Memory Allocation Error"));
                                }    
                            }
			}
			
			/*
			 *	Post the message to the controller window (GCC and MCS
			 *	use the same window to post messages to their controllers).
			 */
			if (! PostMessage (g_pControlSap->GetHwnd(), 
							MCTRLMSG_BASE + MCS_CONNECT_PROVIDER_CONFIRM,
							(WPARAM) memory, (LPARAM) pconnect_provider_confirm))
            {
                delete pconnect_provider_confirm;
                pconnect_provider_confirm = NULL;
				ERROR_OUT(("Controller::ConnectionDeleteConnection: "
							"failed to post msg to MCS controller window. Error: %d", GetLastError()));
			}

			/*
			 *	If the result of this confirm is not successful, and the connection
			 *	is not already queued for deletion, then we need to queue it for
			 *	deletion.
			 */
			if ((result != RESULT_SUCCESSFUL) &&
				(! m_ConnectionDeletionList2.Find(connection_handle)))
			{
				/*
				 *	Put the connection object into the deletion list and set the
				 *	deletion pending flag.
				 */
				TRACE_OUT (("Controller::ConnectionConnectProviderConfirm: "
							"adding connection to deletion list"));
				m_ConnectionDeletionList2.Insert(connection_handle, connection);
				Connection_Deletion_Pending = TRUE;
				SetEvent(Connection_Deletion_Pending_Event);
			}
		}
		else
			ERROR_OUT(("Controller::ConnectionConnectProviderConfirm: "
						"failed to allocate node controller msg."));
	}
	else
	{
		/*
		 *	If the connection handle cannot be found in the connection
		 *	dictionary, then simply ignore the request.
		 */
		WARNING_OUT (("Controller::ConnectionConnectProviderConfirm: "
				"unknown connection"));
	}
}


/*
 *	Void	TransportDisconnectIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request originates within a transport interface object when it
 *		gets a disconnect indication from the transport layer for a transport
 *		connection that is not assigned to a connection object.  This could
 *		happen in the case where a remote node issues a connect provider request
 *		followed by a disconnect provider request before this node issues a
 *		connect provider response.
 *
 *		The controller responds by simply removing the information from the
 *		connection pending list.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is the transport connection handle that has been assigned to
 *			the newly created transport connection.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	Controller::TransportDisconnectIndication (
					TransportConnection		transport_connection)
{

	PConnectionPending		connection_pending;
	ConnectionHandle        connection_handle;

	/*
	 *	Find the entry in the connection pending list which is associated with
	 *	the given transport connection.  If found, remove the entry.
	 */
	m_ConnPendingList2.Reset();
	while (NULL != (connection_pending = m_ConnPendingList2.Iterate(&connection_handle)))
	{
		if (IS_SAME_TRANSPORT_CONNECTION(connection_pending->transport_connection, transport_connection))
		{
			m_ConnPendingList2.Remove(connection_handle);
			delete connection_pending;
			break;
		}
	}
}

/*
 *	Void	TransportDataIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This function is called when data is received from the transport layer
 *		on a transport connection that no other object has registered
 *		ownership of.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is the transport connection handle that has been assigned to
 *			the newly created transport connection.
 *		user_data
 *			A pointer to the data received.
 *		user_data_length
 *			The length of the data received.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	Controller::TransportDataIndication (
					TransportConnection		transport_connection,
					PUChar					user_data,
					ULong					user_data_length)
{
	PPacket			packet;
	PacketError		packet_error;
	PVoid			pdu_structure;

	ASSERT (g_Transport);
	/*
	 *	Create a packet from the encoded data received from the transport
	 *	interface.  Retrieve the decoded PDU structure from the packet and
	 *	pass it on to the appropriate processing routine.
	 */  
	DBG_SAVE_FILE_LINE
	packet = new Packet (
			(PPacketCoder) g_MCSCoder,
			BASIC_ENCODING_RULES,
			user_data + PROTOCOL_OVERHEAD_X224,
			user_data_length - PROTOCOL_OVERHEAD_X224,
			CONNECT_MCS_PDU,
			TRUE,
			&packet_error);

	if (packet != NULL)
	{
		if (packet_error == PACKET_NO_ERROR)
		{
			/*
			 *	Get a pointer to the decoded data.
			 */
			pdu_structure = packet->GetDecodedData ();
			
			switch (((ConnectMCSPDU *) pdu_structure)->choice)
			{
				case CONNECT_INITIAL_CHOSEN:
					ProcessConnectInitial (	
							transport_connection,
							&((ConnectMCSPDU *) pdu_structure)->u.
							connect_initial);
					break;

				case CONNECT_ADDITIONAL_CHOSEN:
					ProcessConnectAdditional (	
							transport_connection,
							&((ConnectMCSPDU *) pdu_structure)->u.
							connect_additional);
					break;

				default:
					ERROR_OUT (("Controller::TransportDataIndication: "
							"received invalid PDU (%d)",
							((ConnectMCSPDU *) pdu_structure)->choice));
					g_Transport->DisconnectRequest (transport_connection);
					break;
			}
		}
		else
		{
			/*
			 *	A memory allocation failure has prevented us from processing
			 *	this PDU.  Destroy the connection that carried it.
			 */
			WARNING_OUT (("Controller::TransportDataIndication: "
					"packet constructor failed"));
			g_Transport->DisconnectRequest (transport_connection);
		}
		packet->Unlock ();
	}
	else
	{
		/*
		 *	A memory allocation failure has prevented us from processing
		 *	this PDU.  Destroy the connection that carried it.
		 */
		WARNING_OUT (("Controller::TransportDataIndication: "
				"packet allocation failed"));
		g_Transport->DisconnectRequest (transport_connection);
	}
}

#ifdef TSTATUS_INDICATION
/*
 *	Void	TransportStatusIndication ()
 *
 *	Private
 *
 *	Functional Description:
 *		This request originates within a transport interface object when it
 *		receives a status indication from its transport layer.   This function
 *		will forward the status indication to the node controller.
 *
 *	Formal Parameters:
 *		transport_status
 *			This is a pointer to the TransportStatus structure that describes
 *			the reason for the indication.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	Controller::TransportStatusIndication (
				PTransportStatus		transport_status)
{
	ULong						device_identifier_length;
	ULong						remote_address_length;
	ULong						message_length;
	PMemory						memory;
	PUChar						string_address;
	PNodeControllerMessage		node_controller_message;

	/*
	 *	Determine the length of each of the ASCII strings contained in the
	 *	transport status indications.  This will be used to allocate a
	 *	memory block large enough to hold them all.  Note that each length
	 *	includes one extra byte to hold the ASCII NULL terminator.
	 */
	device_identifier_length =
			(ULong) lstrlen (transport_status->device_identifier) + 1;
	remote_address_length =
			(ULong) lstrlen (transport_status->remote_address) + 1;
	message_length =
			(ULong) lstrlen (transport_status->message) + 1;

	/*
	 *	Use the memory manager to allocate a memory block large enough to
	 *	hold all of the strings.
	 */
	DBG_SAVE_FILE_LINE
	memory = AllocateMemory (NULL,
			(device_identifier_length + remote_address_length + message_length));

	if (memory != NULL)
	{
		DBG_SAVE_FILE_LINE
		node_controller_message = new NodeControllerMessage;

		if (node_controller_message != NULL) {
			/*
			 *	Get the address of the memory block that was allocated.
			 */
			string_address = memory->GetPointer ();

			/*
			 *	Indicate what type of message this is.
			 */
			node_controller_message->message_type = MCS_TRANSPORT_STATUS_INDICATION;

			/*
			 *	Copy all of the ASCII strings into the memory block that was
			 *	allocated above.  This block will remain valid until this
			 *	message is sent to the node controller.
			 */
			memcpy (string_address, transport_status->device_identifier,
						device_identifier_length);
			node_controller_message->u.transport_status_indication.
						device_identifier = (PChar) string_address;
			string_address += (Int) device_identifier_length;

			memcpy (string_address, transport_status->remote_address,
						remote_address_length);
			node_controller_message->u.transport_status_indication.
						remote_address = (PChar) string_address;
			string_address += (Int) remote_address_length;

			memcpy (string_address, transport_status->message,
						message_length);
			node_controller_message->u.transport_status_indication.
						message = (PChar) string_address;

			node_controller_message->u.transport_status_indication.
						state = transport_status->state;

			node_controller_message->memory = memory;

			/*
			 *	Put this message into the control queue to be sent to the node
			 *	controller during the next heartbeat.
			 */
			AddToMessageQueue (node_controller_message);
		}
		else
			WARNING_OUT(("Controller::TransportStatusIndication: "
				"WARNING - memory allocation failure"));
	}
	else
	{
		/*
		 *	A memory allocation failure has occurred.  This prevents us from
		 *	being able to deliver this status indication to the node controller.
		 *	This does not compromise the integrity of MCS, but could cause
		 *	problems at a higher level.
		 */
		ERROR_OUT (("Controller::TransportStatusIndication: "
				"WARNING - memory allocation failure"));
	}
}
#endif

/*
 *	Void	ProcessConnectInitial()
 *
 *	Private
 *
 *	Functional Description:
 *		Processes incoming connect initial PDUs.  Sends a connect provider
 *		indication to the node controller if everything checks out.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is assigned transport connection handle for the connection
 *			that carried the PDU.
 *		pdu_structure (i)
 *			This is a pointer to the PDU itself.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void	Controller::ProcessConnectInitial (
				TransportConnection		transport_connection,
				ConnectInitialPDU *		pdu_structure)
{
	PConnectionPending			connection_pending;
	PMemory						memory;
	PUChar						memory_address;
	ConnectProviderIndication	*pconnect_provider_indication;
	ConnectionHandle			connection_handle;
	BOOL    					upward_connection;
	//DomainParameters			domain_parameters;
	
	/*
	 *	Try to allocate a connection pending structure.  This will be used to
	 *	hold information about the incoming connection that will not be passed
	 *	back in the connect provider response.
	 */
	DBG_SAVE_FILE_LINE
	connection_pending = new ConnectionPending;
	DBG_SAVE_FILE_LINE
	pconnect_provider_indication = new ConnectProviderIndication;

	if (connection_pending != NULL && pconnect_provider_indication != NULL)
	{
		/*
		 *	Allocate a memory block to hold the user data field in the
		 *	incoming connection.
		 */
		DBG_SAVE_FILE_LINE
		memory = AllocateMemory (NULL, pdu_structure->user_data.length);

		if (memory != NULL) {
		
			memory_address = memory->GetPointer ();

			/*
			 *	Allocate a connection handle for this inbound connection,
			 *	and put it into the indication structure.  Also fill in the
			 *	physical connection handle, which is obtained by asking the
			 *	transport interface for it.
			 */
			connection_handle = AllocateConnectionHandle ();
			pconnect_provider_indication->connection_handle = connection_handle;
			pconnect_provider_indication->fSecure =
				g_Transport->GetSecurity ( transport_connection );

			/* 
			 *	Copy the user data field into the
			 *	newly allocated memory block.  Also set the pointers in
			 *	the node controller message structure to point into the
			 *	memory block.
			 */
			memcpy (memory_address,
					pdu_structure->user_data.value,
					pdu_structure->user_data.length);
			pconnect_provider_indication->user_data = memory_address;
			pconnect_provider_indication->user_data_length = 
										pdu_structure->user_data.length;

			/*
			 *	Retrieve the direction of the incoming connection.  Put it
			 *	into both the connect provider indication structure and the
			 *	connection pending structure.  Note that in the connection
			 *	pending structure, we need to reverse the direction of the
			 *	flag so that it is from the point-of-view of this provider.
			 */
			upward_connection = pdu_structure->upward_flag;
			pconnect_provider_indication->upward_connection = upward_connection;

			if (upward_connection)
				connection_pending->upward_connection = FALSE;
			else
				connection_pending->upward_connection = TRUE;

			/*
			 *	Retrieve the target domain parameters and put them into both
			 *	the connect provider indication structure, and into the
			 *	connection pending structure (for possible later use).
			 */
			memcpy (&(pconnect_provider_indication->domain_parameters), 
					&(pdu_structure->target_parameters), sizeof (PDUDomainParameters));
			memcpy (&(connection_pending->domain_parameters),
					&(pdu_structure->target_parameters), sizeof (PDUDomainParameters));

			/*
			 *	Retrieve the minimum domain parameters and put them into
			 *	the connection pending structure (for possible later use).
			 */
			memcpy (&(connection_pending->minimum_domain_parameters),
					&(pdu_structure->minimum_parameters), sizeof(PDUDomainParameters));

			/*
			 *	Retrieve the maximum domain parameters and put them into
			 *	the connection pending structure (for possible later use).
			 */
			memcpy (&(connection_pending->maximum_domain_parameters),
					&(pdu_structure->maximum_parameters), sizeof(PDUDomainParameters));

			/*
			 *	Post the message to the controller window (GCC and MCS
			 *	use the same window to post messages to their controllers).
			 */
			if (NULL != g_pControlSap) {
				if (! PostMessage (g_pControlSap->GetHwnd(), 
								MCTRLMSG_BASE + MCS_CONNECT_PROVIDER_INDICATION,
								(WPARAM) memory, (LPARAM) pconnect_provider_indication)) {
					ERROR_OUT(("Controller::ProcessConnectInitial: "
								"failed to post msg to MCS controller window. Error: %d", GetLastError()));
				}
			}

			/*
			 *	We also need to remember which transport interface and
			 *	transport connection are associated with this pending
			 *	MCS connection.  Then put the connection pending structure
			 *	into a list for later use.
			 */
			connection_pending->transport_connection = transport_connection;
			m_ConnPendingList2.Append(connection_handle, connection_pending);

			// No errors have occurred.
			return;
		}
	}

	/*
	 *	A memory allocation failure has occurred.  We have no choice
	 *	but to terminate the connection upon which this PDU arrived.
	 */
	ASSERT (g_Transport);
	WARNING_OUT(("Controller::ProcessConnectInitial: memory allocation failure"));
	delete connection_pending;
	delete pconnect_provider_indication;
	g_Transport->DisconnectRequest (transport_connection);
}

/*
 *	Void	ProcessConnectAdditional ()
 *
 *	Private
 *
 *	Functional Description:
 *		Processes incoming connect additional PDUs.  If the connection handle
 *		contained therein is valid, it will bind the connection to the
 *		proper connection object.
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is assigned transport connection handle for the connection
 *			that carried the PDU.
 *		pdu_structure (i)
 *			This is a pointer to the PDU itself.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
Void	Controller::ProcessConnectAdditional (
				TransportConnection		transport_connection,
				ConnectAdditionalPDU *	pdu_structure)
{
	ConnectionHandle		connection_handle;
	Priority				priority;
	PConnection				connection;

	ASSERT (g_Transport);
	
	connection_handle = (ConnectionHandle) pdu_structure->called_connect_id;
	priority = (Priority) pdu_structure->data_priority;

	if (NULL != (connection = m_ConnectionList2.Find(connection_handle)))
	{
		/*
		 *	The indicated connection does exist, so call upon it to accept
		 *	and register the new transport connection.
		 */
		connection->RegisterTransportConnection (transport_connection, priority);
	}
	else
	{
		/*
		 *	The indicated connection handle is not in the dictionary.  Issue
		 *	a connect result with a failure result, and disconnect the
		 *	transport connection.
		 */
		ConnectResult (transport_connection, RESULT_UNSPECIFIED_FAILURE);

		g_Transport->DisconnectRequest (transport_connection);
	}
}

/*
 *	Void	ConnectResponse ()
 *
 *	Private
 *
 *	Functional Description:
 *		Sends a failed connect response PDU (when something goes wrong).
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is assigned transport connection handle for the connection
 *			that is to carry the PDU.
 *		result (i)
 *			This is the result being sent in the connect response.
 *		domain_parameters (i)
 *			This is a pointer to a structure containing domain parameters.
 *			These parameters will not be used for anything since the connection
 *			is being rejected.
 *		connect_id (i)
 *			This is the connect ID that would be used for any additional
 *			transport connection to be bound to this one.  This is not
 *			required since the connection is being rejected.
 *		user_data (i)
 *			This is a pointer to the user data to be transmitted to the remote
 *			side along with the response.
 *		user_data_lengthn (i)
 *			This is the length of the above user data.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 */
Void	Controller::ConnectResponse (
				TransportConnection		transport_connection,
				Result					result,
				PDomainParameters		domain_parameters,
				ConnectID				connect_id,
				PUChar					user_data,
				ULong					user_data_length)
{
	ConnectMCSPDU		connect_response_pdu;
	PPacket				packet;
	PacketError			packet_error;
	//PVoid				encoded_data;
	//ULong				encoded_data_length;

	ASSERT (g_Transport);
	/*
	 * Fill in the ConnectResponse PDU structure to be encoded.
	 */
	connect_response_pdu.choice = CONNECT_RESPONSE_CHOSEN;
	connect_response_pdu.u.connect_response.result = (PDUResult)result;
	connect_response_pdu.u.connect_response.called_connect_id = connect_id;
	
	memcpy (&(connect_response_pdu.u.connect_response.domain_parameters), 
			domain_parameters, sizeof(PDUDomainParameters));  
		
	connect_response_pdu.u.connect_response.user_data.length = user_data_length;
	connect_response_pdu.u.connect_response.user_data.value = user_data;

	/*
	 * Create a packet which will be used to hold the data to be sent
	 * through the transport interface.	 Check to make sure the packet is
	 * successfully created..
	 */
	DBG_SAVE_FILE_LINE
	packet = new Packet (
			(PPacketCoder) g_MCSCoder,
			BASIC_ENCODING_RULES,
			&connect_response_pdu,
			CONNECT_MCS_PDU,
			TRUE,
			&packet_error);

	if (packet != NULL)
	{
		if (packet_error == PACKET_NO_ERROR)
		{
			/*
			 * Send the packet through the transport interface.
			 */
#ifdef DEBUG
			TransportError err = DataRequest (transport_connection, 
												(PSimplePacket) packet);
			ASSERT (err == TRANSPORT_NO_ERROR);
#else // DEBUG
			DataRequest (transport_connection, (PSimplePacket) packet);
#endif // DEBUG
		}
		else
		{
			/*
			 *	The packet creation has failed due to an internal error so 
			 *	report the error through a print statement.  Note that no
			 *	further action need be taken since this transport connection
			 *	is being terminated anyway.
			 */
			WARNING_OUT (("Controller::ConnectResponse: "
					"internal allocation failure"));
		}
		packet->Unlock ();
	}
	else
	{
		/*
		 *	The packet creation has failed so report the error through a print
		 *	statement.  Note that no further action need be taken since this
		 *	transport connection is being terminated anyway.
		 */
		WARNING_OUT (("Controller::ConnectResponse: "
				"packet allocation failure"));
	}
}

/*
 *	Void	ConnectResult ()
 *
 *	Private
 *
 *	Functional Description:
 *		Sends a failed connect response PDU (when something goes wrong).
 *
 *	Formal Parameters:
 *		transport_connection (i)
 *			This is assigned transport connection handle for the connection
 *			that is to carry the PDU.
 *		result (i)
 *			This is the result being sent in the connect result.
 *
 *	Return Value:
 *		None.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 */
Void	Controller::ConnectResult (
				TransportConnection		transport_connection,
				Result					result)
{
	ConnectMCSPDU		connect_result_pdu;
	PPacket				packet;
	PacketError			packet_error;
	//PVoid				encoded_data;
	//ULong				encoded_data_length;

	ASSERT (g_Transport);
	/*
	 * Fill in the PDU structure to be encoded.
	 */
	connect_result_pdu.choice = CONNECT_RESULT_CHOSEN;
	connect_result_pdu.u.connect_result.result = (PDUResult)result;
	
	/*
	 * Create a packet which will be used to hold the data to be sent
	 * through the transport interface.	 Check to make sure the packet is
	 * successfully created..
	 */
	DBG_SAVE_FILE_LINE
	packet = new Packet (
			(PPacketCoder) g_MCSCoder,
			BASIC_ENCODING_RULES,
			&connect_result_pdu,
			CONNECT_MCS_PDU,
			TRUE,
			&packet_error);

	if (packet != NULL)
	{
		if (packet_error == PACKET_NO_ERROR)
		{
			/*
			 * Send the packet through the transport interface.
			 */
#ifdef DEBUG
			TransportError err = DataRequest (transport_connection, 
											  (PSimplePacket) packet);
			ASSERT (err == TRANSPORT_NO_ERROR);
#else // DEBUG
			DataRequest (transport_connection, (PSimplePacket) packet);
#endif // DEBUG
		}
		else
		{
			/*
			 *	The packet creation has failed due to an internal error so 
			 *	report the error through a print statement.  Note that no
			 *	further action need be taken since this transport connection
			 *	is being terminated anyway.
			 */
			WARNING_OUT (("Controller::ConnectResult: "
					"internal allocation failure"));
		}
		packet->Unlock ();
	}
	else
	{
		/*
		 *	The packet creation has failed so report the error through a print
		 *	statement.  Note that no further action need be taken since this
		 *	transport connection is being terminated anyway.
		 */
		WARNING_OUT (("Controller::ConnectResult: "
				"packet allocation failure"));
	}
}

/*
 *	ConnectionHandle	AllocateConnectionHandle ()
 *
 *	Private
 *
 *	Functional Description:
 *		This routine allocates a unique connection handle to be used for a newly
 *		created connection object.  It is based on a rolling instance variable,
 *		so that no two handles will ever be reused until the number rolls
 *		over at 0xffff.
 *
 *		Note that 0 is not a valid connection handle, and will never be used.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value:
 *		The unique connection handle.
 *
 *	Side Effects:
 *		None.
 *
 *	Caveats:
 *		Note that the assumption is made that there will never be more than
 *		65,534 handles in use at once.  In other words, this loop assumes that
 *		there is at least 1 available handle left.  If there is not, then the
 *		loop will hang forever (this is a pretty safe bet for now).
 */
ConnectionHandle	Controller::AllocateConnectionHandle ()
{
	/*
	 *	This loop simply increments a rolling number, looking for the next
	 *	one that is not already in use.
	 */
	while (1)
	{
		Connection_Handle_Counter++;

		/*
		 *	0 is not a valid handle, so skip it.
		 */
		if (Connection_Handle_Counter == 0)
			continue;

		/*
		 *	If this handle is not in use, break from the loop and use it.
		 */
		if (! m_ConnectionList2.Find(Connection_Handle_Counter))
			break;
	}

	return (Connection_Handle_Counter);
}

BOOL    Controller::GetLocalAddress(ConnectionHandle	connection_handle,
									TransportAddress	local_address,
									PInt				local_address_length)
{
	PConnection				connection = NULL;
	PConnectionPending		connection_pending = NULL;
	TransportError			transport_error;
	BOOL    				return_value = FALSE;
	
	if (NULL == (connection = m_ConnectionList2.Find(connection_handle)))
	{
		connection_pending = m_ConnPendingList2.Find(connection_handle);
	}

	if(connection || connection_pending)
	{	
		// Ask the local address to the transport interface
		if (connection)
		{
			transport_error = ::GetLocalAddress(connection->GetTransportConnection(TOP_PRIORITY),
											  local_address,
											  local_address_length);
		}
		else
		{
			transport_error = ::GetLocalAddress(connection_pending->transport_connection,
												local_address,
												local_address_length);
		}
		
		// Check the error code
		if (TRANSPORT_NO_ERROR == transport_error) {
			return_value = TRUE;
		}
	}
	 
	return(return_value);
}

BOOL Controller::FindSocketNumber(ConnectionHandle connection_handle, SOCKET * socket_number)
{
	PConnection	connection = NULL;
	PConnectionPending connection_pending = NULL;

	if (NULL != (connection = m_ConnectionList2.Find(connection_handle)))
	{
	    TransportConnection XprtConn = connection->GetTransportConnection(TOP_PRIORITY);
        if (IS_SOCKET(XprtConn))
        {
		    * socket_number = XprtConn.nLogicalHandle;
    		return TRUE;
    	}
	}
	else
	if (NULL != (connection_pending = m_ConnPendingList2.Find(connection_handle)))
	{
        if (IS_SOCKET(connection_pending->transport_connection))
        {
		    * socket_number = connection_pending->transport_connection.nLogicalHandle;
		    return TRUE;
		}
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\crost.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_CONF_ROSTER);
/*
 *	crost.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Conference Roster Class.
 *		Instances of this class represent a single Conference Roster's
 *		information base.  It encapsulates all the functionality required to
 *		maintain the information base which includes the ability to add new
 *		roster records, delete records and update records.  It has the ability
 *		to convert its internal information base into a list of conference
 *		records that can be used in a GCC_ROSTER_UPDATE_INDICATION callback.
 *		It is also responsible for converting its internal information base
 *		into Conference Roster Update PDUs.  Basically,  this class is
 *		responsible for all operations that require direct access to the
 *		records contained in a Conference Roster.
 *
 *		The Conference Roster class incorporates Rogue Wave list to hold the
 *		roster record information.  Using iterators throughout the class makes
 *		it easy to quickly convert the information contained in the list into
 *		either a PDU or into a list of record pointers (for roster update
 *		indications back to the node controller).
 *
 *		A Conference Roster object has the ability to serialize its roster data
 *		into a single contiguous memory block when it is required to send a
 *		message to the application interface.  This serialization process is
 *		managed externally by the CConfRosterMsg class through calls
 *		to LockConferenceRoster(), UnLockConferenceRoster() and
 *		GetConfRoster().  When a conference roster is to be serialized, a
 *		call is made to LockConferenceRoster() which causes the CConfRoster
 *		object to increment an internal lock count and returns the number of
 *		bytes required to hold the complete roster update.  The Conference
 *		Roster is then serialized into memory through a call to
 *		GetConfRoster().  The CConfRoster is then unlocked to allow
 *		it to be deleted when the free flag gets set through the
 *		FreeConferenceRoster() function.  In the current implementation of GCC,
 *		FreeConferenceRoster() is not used since the CConfRosterMsg
 *		maintains the data used to deliver the message.
 *
 *	Private Instance Variables:
 *		m_RecordList2
 *			This is the rogue wave list used to hold the pointers to all of the
 *			rogue wave records.
 *		m_nInstanceNumber
 *			This instance variable maintains an up to date instance #
 *			corresponding to the current conference roster.
 *		m_fNodesAdded
 *			Flag indicating if any node records have been added to the
 *			conference roster since the last reset.
 *		m_fNodesRemoved
 *			Flag indicating if any node records have been removed from the
 *			conference roster since the last reset.
 *		m_fRosterChanged
 *			Flag indicating if the roster has changed since the last reset.
 *		m_uidTopProvider
 *			The node id of the top provider in the conference.
 *		m_uidSuperiorNode
 *			This is the node id of this nodes superior node.  For the top
 *			provider this is zero.
 *		m_cbDataMemorySize
 *			This is the number of bytes required to hold the data associated
 *			with a roster update message.  This is calculated on a lock.
 *		m_NodeInformation		
 *			Structure used to hold the roster update indication node information
 *			data in "PDU" form.
 *		m_fTopProvider
 *			Flag indicating if the node where this roster lives is the top
 *			provider.
 *		m_fLocalRoster
 *			Flag indicating if the roster data is associated with a local
 *			roster (maintaining intermediate node data) or global roster (
 *			(maintaining roster data for the whole conference).
 *		m_fMaintainPduBuffer
 *			Flag indicating if it is necessary for this roster object to
 *			maintain internal PDU data.  Won't be necessary for global rosters
 *			at subordinate nodes.
 *		m_fPduFlushed
 *			Flag indicating if the PDU that currently exists has been flushed.
 *		m_pNodeRecordUpdateSet
 *			Pointer to internal PDU data.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		blp/jbo
 */

#include "ms_util.h"
#include "crost.h"

#define		MAXIMUM_NODE_NAME_LENGTH			255
#define		MAXIMUM_PARTICIPANT_NAME_LENGTH		255
#define		MAXIMUM_SITE_INFORMATION_LENGTH		255
#define		ALTERNATIVE_NODE_ID_LENGTH			2

/*
 *	CConfRoster	()
 *
 *	Public Function Description:
 *		This is a constructor for the CConfRoster class.  It initializes
 *		instance variables.
 *
 */
CConfRoster::CConfRoster(UserID uidTopProvider, UserID uidSuperiorNode, UserID uidMyself,
						BOOL is_top_provider, BOOL is_local_roster, BOOL maintain_pdu_buffer)
:
    CRefCount(MAKE_STAMP_ID('C','R','s','t')),
	m_fNodesAdded(FALSE),
	m_fNodesRemoved(FALSE),
	m_fRosterChanged(FALSE),
	m_fTopProvider(is_top_provider),
	m_fLocalRoster(is_local_roster),
	m_fMaintainPduBuffer(maintain_pdu_buffer),
   	m_fPduFlushed(FALSE),
	m_uidTopProvider(uidTopProvider),
 	m_uidSuperiorNode(uidSuperiorNode),
 	m_uidMyNodeID(uidMyself),
	m_nInstanceNumber(0),
	m_cbDataMemorySize(0),
	m_RecordList2(DESIRED_MAX_NODE_RECORDS),
	m_pNodeRecordUpdateSet(NULL)
{
	m_NodeInformation.node_record_list.choice = NODE_NO_CHANGE_CHOSEN;
}

/*
 *	~CConfRoster	()
 *
 *	Public Function Description:
 *		This is the destructor for the CConfRoster.  It performs any
 *		necessary cleanup.
 */
CConfRoster::~CConfRoster(void)
{
	//	Free up any left over PDU data.
	if (m_fMaintainPduBuffer)
		FreeRosterUpdateIndicationPDU ();

	//	Cleanup the Rogue Wave list of node records.
	ClearRecordList();
}


/*
 * Utilities that operate on roster update PDU structures.
 */

/*
 *	void	FlushRosterUpdateIndicationPDU	()
 *
 *	Public Function Description:
 *		This routine is used to retrieve a "RosterUpdateIndication" in the "PDU"
 * 		form which is suitable for passing to the ASN.1 encoder.  The "PDU"
 *		structure is built from a previous request to the conference roster.
 */
void CConfRoster::FlushRosterUpdateIndicationPDU(
								PNodeInformation			node_information)
{
	/*
	**	If this roster has already been flushed we will NOT allow the same
	**	PDU to be flushed again.  Instead we delete the previously flushed
	**	PDU and set the flag back to unflushed.  If another flush comes in
	**	before a PDU is built no change will be passed back in the node
	**	information.
	*/	
	if (m_fPduFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduFlushed = FALSE;
	}

	//	First we copy all of the node record list information.
	*node_information = m_NodeInformation;

	/*
	**	Next we copy the relevent instance variables. Note that we must do
	**	this after we copy the node information so that these variables
	**	will not be copied over with garbage.
	*/
	node_information->roster_instance_number = (ASN1uint16_t)m_nInstanceNumber;
	node_information->nodes_are_added = (ASN1bool_t)m_fNodesAdded;
	node_information->nodes_are_removed = (ASN1bool_t)m_fNodesRemoved;

	/*
	**	Setting this to true will cause the PDU data to be freed up the
	**	next time the roster object is entered insuring that new PDU
	**	data will be created.
	*/
	if (m_NodeInformation.node_record_list.choice != NODE_NO_CHANGE_CHOSEN)
		m_fPduFlushed = TRUE;
}

/*
 *	GCCError	BuildFullRefreshPDU ()
 *
 *	Public Function Description
 *
 */
GCCError CConfRoster::BuildFullRefreshPDU(void)
{
	GCCError	rc;
	
	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduFlushed = FALSE;
	}

	rc = BuildRosterUpdateIndicationPDU (FULL_REFRESH, 0);
	
	return (rc);
}


/*
 *	GCCError	BuildRosterUpdateIndicationPDU	()
 *
 *	Public Function Description:
 *		This routine is used to build a "RosterUpdateIndication" in the "PDU"
 * 		form which is suitable for passing to the ASN.1 encoder.  The "PDU"
 *		structure is built from the data maintained internally.
 */
GCCError CConfRoster::BuildRosterUpdateIndicationPDU(
								CONF_ROSTER_UPDATE_TYPE		update_type,
								UserID						node_id)
{
	GCCError	rc = GCC_NO_ERROR;
	
	if (m_fMaintainPduBuffer)
	{
	   	/*
		**	If "PDU" data has already been allocated then we free it up and
		**	rebuild the PDU structure.  This ensures that the most up-to-date
		**	PDU is returned.
		*/
		if ((update_type == FULL_REFRESH) || m_fTopProvider)
		{
			if (m_NodeInformation.node_record_list.choice ==
													NODE_RECORD_REFRESH_CHOSEN)
			{
				//	Here we free the old set of refreshes.
				FreeSetOfRefreshesPDU();
			}
			else if	(m_NodeInformation.node_record_list.choice ==
													NODE_RECORD_UPDATE_CHOSEN)
			{
				ERROR_OUT(("CConfRoster::BuildRosterUpdateIndicationPDU:"
							"ASSERTION: building refresh when update exists"));
				rc = GCC_INVALID_PARAMETER;
			}
			
			if (rc == GCC_NO_ERROR)
			{
				rc = BuildSetOfRefreshesPDU();
			
				if (rc == GCC_NO_ERROR)
				{
					m_NodeInformation.node_record_list.choice =
													NODE_RECORD_REFRESH_CHOSEN;
				}
			}
		}
		else
		{
			if (m_NodeInformation.node_record_list.choice ==
													NODE_RECORD_REFRESH_CHOSEN)
			{
				ERROR_OUT(("CConfRoster::BuildRosterUpdateIndicationPDU:"
							"ASSERTION: building update when refresh exists"));
				rc = GCC_INVALID_PARAMETER;
			}

			if (rc == GCC_NO_ERROR)
			{
				rc = BuildSetOfUpdatesPDU(node_id, update_type);
				if (rc == GCC_NO_ERROR)
				{
				    //
				    // LONCHANC: Commented out the following check because
				    // we can overrun the update, namely, two updates coming
				    // in side by side. It happens when shutting down a
				    // conference, we got two ConferenceAnnouncePresenceRequest.
				    // It is quite stupid in the node controller to call it
				    // twice unncessarily. The node controller should not call
				    // it at all when we know we are about to ending a conference.
				    //
				    // When two updates come in side by side, m_pNodeRecordUpdateSet
				    // will keep all the update information intact. New information
				    // can then be appended to the list.
				    //

					// if (m_NodeInformation.node_record_list.choice ==
					// 									NODE_NO_CHANGE_CHOSEN)
					{
						m_NodeInformation.node_record_list.u.node_record_update =
													m_pNodeRecordUpdateSet;
						m_NodeInformation.node_record_list.choice =
													NODE_RECORD_UPDATE_CHOSEN;
					}
				}
			}
		}
	}

	return (rc);
}


/*
 *	GCCError	BuildSetOfRefreshesPDU	()
 *
 *	Private Function Description:
 *		This routine is used to retrieve the "SetOfRefreshes" portion of a
 *		"RosterUpdateIndication" in the "PDU" form.  The internally maintained
 *		data is converted into the "PDU" form.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConfRoster::BuildSetOfRefreshesPDU(void)
{
	GCCError						rc = GCC_NO_ERROR;
	PSetOfNodeRecordRefreshes		new_record_refresh;
	PSetOfNodeRecordRefreshes		old_record_refresh;
	PNodeRecord						node_record;
	CONF_RECORD     				*lpRec;
	UserID							uid;

	m_NodeInformation.node_record_list.u.node_record_refresh = NULL;
	old_record_refresh = NULL;	//	This eliminates a compiler warning

	m_RecordList2.Reset();
	while (NULL != (lpRec = m_RecordList2.Iterate(&uid)))
	{
		DBG_SAVE_FILE_LINE
		new_record_refresh = new SetOfNodeRecordRefreshes;
		if (new_record_refresh == NULL)
		{
			ERROR_OUT(("CConfRoster::BuildSetOfRefreshesPDU: can't create set ofnode record refreshes"));
			rc = GCC_ALLOCATION_FAILURE;
			goto MyExit;
		}

        //
        // Ensure everything here is clean.
        // We may fail in the middle of building this node record.
        //
        ::ZeroMemory(new_record_refresh, sizeof(SetOfNodeRecordRefreshes));

        //
        // Hook to the linked list.
        //
		if (m_NodeInformation.node_record_list.u.node_record_refresh == NULL)
		{
			m_NodeInformation.node_record_list.u.node_record_refresh = new_record_refresh;
		}
		else
        {
			old_record_refresh->next = new_record_refresh;
        }

		old_record_refresh = new_record_refresh;

		/*
		 *	Initialize the refresh "next" pointer to NULL and set the
		 *	refresh value node ID equal to the internal node ID.
		 */
		new_record_refresh->next = NULL;
		new_record_refresh->value.node_id = uid;
		
		/*
		 * 	Fill in the "PDU" node record structure from the internal
		 *	record structure.
		 */
		node_record = &(new_record_refresh->value.node_record);
		node_record->bit_mask = 0;

		/*
		 *	Check to see if the superior node ID is present.  If the value
		 * 	is zero, then the record is for the top provider node and the
		 *	superior node ID does not need to be filled in.
		 */
		if (lpRec->superior_node != 0)
		{
			node_record->bit_mask |= SUPERIOR_NODE_PRESENT;
			node_record->superior_node = lpRec->superior_node;
		}

		/*
		 *	Fill in the node type and node properties which are always
		 *	present.
		 */
		node_record->node_type = lpRec->node_type;
		node_record->node_properties = lpRec->node_properties;

		/*
		**	This roster object must not go out of scope while this
		**	update record is still in use!
		*/

		/*
		 *	Fill in the node name if it is present.
		 */
		if (lpRec->pwszNodeName != NULL)
		{
			node_record->bit_mask |= NODE_NAME_PRESENT;
			node_record->node_name.value = lpRec->pwszNodeName;
			node_record->node_name.length = ::lstrlenW(lpRec->pwszNodeName);
		}

		/*
		 *	Fill in the participants list if it is present.
		 */
		if (lpRec->participant_name_list != NULL)
		{
			node_record->bit_mask |= PARTICIPANTS_LIST_PRESENT;

			rc = BuildParticipantsListPDU(uid, &(node_record->participants_list));
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConfRoster::BuildSetOfRefreshesPDU: can't build participant list, rc=%d", rc));
				goto MyExit;
			}
		}

		/*
		 *	Fill in the site information if it is present.
		 */
		if (lpRec->pwszSiteInfo != NULL)
		{
			node_record->bit_mask |= SITE_INFORMATION_PRESENT;
			node_record->site_information.value = lpRec->pwszSiteInfo;
			node_record->site_information.length = ::lstrlenW(lpRec->pwszSiteInfo);
		}

		/*
		 *	Fill in the network address if it is present.
		 */
		if ((lpRec->network_address_list != NULL) && (rc == GCC_NO_ERROR))
		{
			node_record->bit_mask |= RECORD_NET_ADDRESS_PRESENT;

			rc = lpRec->network_address_list->GetNetworkAddressListPDU (
													&(node_record->record_net_address));
			if (GCC_NO_ERROR != rc)
			{
				ERROR_OUT(("CConfRoster::BuildSetOfRefreshesPDU: can't get network address list, rc=%d", rc));
				goto MyExit;
			}
		}

		/*
		 *	Fill in the alternative node ID if it is present.
		 */
		if (lpRec->poszAltNodeID != NULL)
		{
			node_record->bit_mask |= ALTERNATIVE_NODE_ID_PRESENT;

			node_record->alternative_node_id.choice = H243_NODE_ID_CHOSEN;
			node_record->alternative_node_id.u.h243_node_id.length = lpRec->poszAltNodeID->length;

			::CopyMemory(node_record->alternative_node_id.u.h243_node_id.value,
					lpRec->poszAltNodeID->value,
					node_record->alternative_node_id.u.h243_node_id.length);
		}

		/*
		 *	Fill in the user data list if it is present.
		 */
		if ((lpRec->user_data_list != NULL) && (rc == GCC_NO_ERROR))
		{
			node_record->bit_mask |= RECORD_USER_DATA_PRESENT;
			rc = lpRec->user_data_list->GetUserDataPDU (&(node_record->record_user_data));
		}
	}

MyExit:

	if (rc != GCC_NO_ERROR)
	{
		ERROR_OUT(("CConfRoster::BuildSetOfRefreshesPDU: ASSERTION: Error occured: rc=%d", rc));
	}

	return (rc);
}


/*
 *	GCCError	BuildSetOfUpdatesPDU ()
 *
 *	Private Function Description
 *		This routine is used to retrieve the "SetOfUpdates" portion of a
 *		"RosterUpdateIndication" in the "PDU" form.  The internally maintained
 *		data is converted into the "PDU" form.
 *
 *	Formal Parameters:
 *		node_id				-	(i)	Node ID of node record to be included in
 *									the update.
 *		update_type			-	(i)	The type of update PDU to build (Add,
 *									Delete, Replace).
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConfRoster::BuildSetOfUpdatesPDU(
							UserID								node_id,
							CONF_ROSTER_UPDATE_TYPE				update_type)
{
	GCCError			rc = GCC_NO_ERROR;
	PNodeRecord			node_record = NULL;
	CONF_RECORD     	*lpRec;
	PSetOfNodeRecordUpdates		pRecordUpdate, p;
	BOOL                fReplaceExistingOne = FALSE;

	if (NULL != (lpRec = m_RecordList2.Find(node_id)))
	{
	    //
	    // LONCHANC: Check to see if a update record already exists
	    // for this particular node ID. If so, we should replace
	    // the record.
	    //
		for (p = m_pNodeRecordUpdateSet; NULL != p; p = p->next)
		{
		    if (node_id == p->value.node_id)
		    {
		        pRecordUpdate = p;
		        fReplaceExistingOne = TRUE;
                CleanUpdateRecordPDU(pRecordUpdate); // do not free the record itself

                //
                // Remember who is the next to restore because
                // we will zero out the entire structure later.
                //
                p = pRecordUpdate->next;
                break;
		    }
		}

        if (! fReplaceExistingOne)
        {
            DBG_SAVE_FILE_LINE
            pRecordUpdate = new SetOfNodeRecordUpdates;
            if (NULL == pRecordUpdate)
            {
            	ERROR_OUT(("CConfRoster::BuildSetOfUpdatesPDU: can't create set of node record updates, rc=%d", rc));
            	rc = GCC_ALLOCATION_FAILURE;
            	goto MyExit;
            }
        }

        //
        // Ensure everything here is clean.
        // We may fail in the middle of building this node record.
        //
        ::ZeroMemory(pRecordUpdate, sizeof(SetOfNodeRecordUpdates));

        if (! fReplaceExistingOne)
        {
            //
            // Hook to the linked list.
            //
            if (m_pNodeRecordUpdateSet == NULL)
            {
            	m_pNodeRecordUpdateSet = pRecordUpdate;
            }
            else
            {
            	// append to the list
            	for (p = m_pNodeRecordUpdateSet; NULL != p->next; p = p->next)
            		;
            	p->next = pRecordUpdate;
            }
        }
        else
        {
            ASSERT(NULL == pRecordUpdate->next); // just zero out
            // p could not NULL if the one being replaced is
            // the last one in the list.
            pRecordUpdate->next = p; // restore
        }

		/*
		 *	Initialize the update "next" pointer to NULL and set the
		 *	update value node ID equal to the node ID passed in.
		 */
		// pRecordUpdate->next = NULL; // struct already zeroed out
		pRecordUpdate->value.node_id = node_id;

		if (update_type == ADD_RECORD)
		{
			pRecordUpdate->value.node_update.choice = NODE_ADD_RECORD_CHOSEN;
			node_record = &pRecordUpdate->value.node_update.u.node_add_record;
		}
		else if (update_type == REPLACE_RECORD)
		{
			pRecordUpdate->value.node_update.choice = NODE_REPLACE_RECORD_CHOSEN;
			node_record = &pRecordUpdate->value.node_update.u.node_replace_record;
		}
		else
		{
			pRecordUpdate->value.node_update.choice = NODE_REMOVE_RECORD_CHOSEN;
		}

		if (node_record != NULL)
		{
			// node_record->bit_mask = 0; // struct already zeroed out

			/*
			 *	Check to see if the superior node ID is present.  If the
			 * 	value is zero, then the record is for the top provider node
			 *	and the superior node ID does not need to be filled in.
			 */
			if (lpRec->superior_node != 0)
			{
				node_record->bit_mask |= SUPERIOR_NODE_PRESENT;
				node_record->superior_node = lpRec->superior_node;
			}

			/*
			 *	Fill in the node type and node properties which are always
			 *	present.
			 */
			node_record->node_type = lpRec->node_type;
			node_record->node_properties = lpRec->node_properties;

			/*
			**	This roster object must not go out of scope while this
			**	update record is still in use!
			*/

			/*
			 * 	Fill in the node name if it is present.
			 */
			if (lpRec->pwszNodeName != NULL)
			{
				node_record->bit_mask |= NODE_NAME_PRESENT;
				node_record->node_name.value = lpRec->pwszNodeName;
				node_record->node_name.length = ::lstrlenW(lpRec->pwszNodeName);
			}

			/*
			 *	Fill in the participants list if it is present.
			 */
			if (lpRec->participant_name_list != NULL)
			{
				node_record->bit_mask |= PARTICIPANTS_LIST_PRESENT;

				rc = BuildParticipantsListPDU (node_id,
											&(node_record->participants_list));
				if (GCC_NO_ERROR != rc)
				{
					ERROR_OUT(("CConfRoster::BuildSetOfUpdatesPDU: can't build participant list, rc=%d", rc));
					goto MyExit;
				}
			}

			/*
			 *	Fill in the site information if it is present.
			 */
			if (lpRec->pwszSiteInfo != NULL)
			{
				node_record->bit_mask |= SITE_INFORMATION_PRESENT;
				node_record->site_information.value = lpRec->pwszSiteInfo;
				node_record->site_information.length = ::lstrlenW(lpRec->pwszSiteInfo);
			}

			/*
			 *	Fill in the network address if it is present.
			 */
			if ((lpRec->network_address_list != NULL) && (rc == GCC_NO_ERROR))
			{
				node_record->bit_mask |= RECORD_NET_ADDRESS_PRESENT;

				rc = lpRec->network_address_list->GetNetworkAddressListPDU (
														&(node_record->record_net_address));
				if (GCC_NO_ERROR != rc)
				{
					ERROR_OUT(("CConfRoster::BuildSetOfUpdatesPDU: can't get network address list, rc=%d", rc));
					goto MyExit;
				}
			}

			/*
			 *	Fill in the alternative node ID if it is present.
			 */
			if (lpRec->poszAltNodeID != NULL)
			{
				node_record->bit_mask |= ALTERNATIVE_NODE_ID_PRESENT;

				node_record->alternative_node_id.choice = H243_NODE_ID_CHOSEN;
				node_record->alternative_node_id.u.h243_node_id.length = lpRec->poszAltNodeID->length;

				::CopyMemory(node_record->alternative_node_id.u.h243_node_id.value,
						lpRec->poszAltNodeID->value,
						node_record->alternative_node_id.u.h243_node_id.length);
			}

			/*
			 *	Fill in the user data list if it is present.
			 */
			if (lpRec->user_data_list != NULL)
			{
				node_record->bit_mask |= RECORD_USER_DATA_PRESENT;

				rc = lpRec->user_data_list->GetUserDataPDU (&(node_record->record_user_data));
			}
		}
	}
	else
	{
		ERROR_OUT(("CConfRoster::BuildSetOfUpdatesPDU: invalid param"));
		rc = GCC_INVALID_PARAMETER;
	}

MyExit:

	return (rc);
}


/*
 *	GCCError	BuildParticipantsListPDU	()
 *
 *	Public Function Description
 *		This routine is used to retrieve the "ParticipantList" portion of a
 *		"RosterUpdateIndication" in the "PDU" form.  The internally maintained
 *		data is converted into the "PDU" form.
 *
 *	Formal Parameters:
 *		node_id				-	(i)	Node ID of node record to get the
 *									participant list from.
 *		participants_list	-	(o) This is a pointer to the set of participant
 *									list PDU structures	to be filled in by this
 *									routine.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConfRoster::BuildParticipantsListPDU(
									UserID					node_id,
									PParticipantsList   *	participants_list)
{
	GCCError				rc = GCC_NO_ERROR;
	PParticipantsList		new_participants_list;
	PParticipantsList		old_participants_list;
	CONF_RECORD     		*lpRec;
	
	if (NULL != (lpRec = m_RecordList2.Find(node_id)))
	{	
		LPWSTR		PUstring;

		*participants_list = NULL;
		old_participants_list = NULL;

		lpRec->participant_name_list->Reset();
		while (NULL != (PUstring = lpRec->participant_name_list->Iterate()))
		{
			DBG_SAVE_FILE_LINE
			new_participants_list = new ParticipantsList;
			if (new_participants_list == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				FreeParticipantsListPDU (*participants_list);
				break;
			}

			if (*participants_list == NULL)
				*participants_list = new_participants_list;
			else
				old_participants_list->next = new_participants_list;

			/*
			 * Save this pointer so that it's "next" pointer can be filled in
			 * by the line above on the next pass through.
			 */
			old_participants_list = new_participants_list;

			/*
			 * Initialize the current "next" pointer to NULL in case this is
			 * the last time through the loop.
			 */
			new_participants_list->next = NULL;

			/*
			 *	Finally, put the participant list info. in the structure.
			 */
			new_participants_list->value.value = PUstring;
			new_participants_list->value.length = ::lstrlenW(PUstring);
		}
	}
	else
		rc = GCC_INVALID_PARAMETER;

    return (rc);
}


/*
 *	These routines are used to free up a roster update indication PDU.
 */


/*
 *	void		FreeRosterUpdateIndicationPDU ()
 *
 *	Private Function Description
 *		This routine is responsible for freeing up all the data associated
 *		with the PDU.  This routine should be called each time a PDU is
 *		obtained through the GetRosterUpdateIndicationPDU () routine.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConfRoster::FreeRosterUpdateIndicationPDU(void)
{
	if (m_NodeInformation.node_record_list.choice == NODE_RECORD_REFRESH_CHOSEN)
	{
		FreeSetOfRefreshesPDU ();
	}
	else if (m_NodeInformation.node_record_list.choice == NODE_RECORD_UPDATE_CHOSEN)
	{
		FreeSetOfUpdatesPDU ();
	}

	m_NodeInformation.node_record_list.choice = NODE_NO_CHANGE_CHOSEN;
	m_pNodeRecordUpdateSet = NULL;
}


/*
 *	void	FreeSetOfRefreshesPDU	()
 *
 *	Private Function Description:
 *		This routine is used to free up any data allocated to construct the
 *		"PDU" form of the "SetOfRefreshes" portion of the RosterUpdateIndication
 *		"PDU" structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConfRoster::FreeSetOfRefreshesPDU(void)
{
	PSetOfNodeRecordRefreshes		pCurr, pNext;

    for (pCurr = m_NodeInformation.node_record_list.u.node_record_refresh;
            NULL != pCurr;
            pCurr = pNext)
    {
        pNext = pCurr->next;
		if (pCurr->value.node_record.bit_mask & PARTICIPANTS_LIST_PRESENT)
		{
			FreeParticipantsListPDU(pCurr->value.node_record.participants_list);
		}
		delete pCurr;
	}
    m_NodeInformation.node_record_list.u.node_record_refresh = NULL;

    m_RecordList2.CleanList();
}


/*
 *	void	FreeSetOfUpdatesPDU	()
 *
 *	Private Function Description:
 *		This routine is used to free up any data allocated to construct the
 *		"PDU" form of the "SetOfUpdates" portion of the RosterUpdateIndication
 *		"PDU" structure.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConfRoster::
CleanUpdateRecordPDU ( PSetOfNodeRecordUpdates pCurr)
{
	/*
	 *	Check to see if the update is an "Add" or a "Replace".
	 */
	if (pCurr->value.node_update.choice == NODE_ADD_RECORD_CHOSEN)
	{
		/*
		 *	Free the participants list memory if any exists.
		 */
		if (pCurr->value.node_update.u.node_add_record.bit_mask & PARTICIPANTS_LIST_PRESENT)
		{
			FreeParticipantsListPDU(pCurr->value.node_update.u.node_add_record.participants_list);
		}
	}
	else if (pCurr->value.node_update.choice == NODE_REPLACE_RECORD_CHOSEN)
	{
		/*
		 *	Free the participants list memory if any exists.
		 */
		if (pCurr->value.node_update.u.node_replace_record.bit_mask & PARTICIPANTS_LIST_PRESENT)
		{
			FreeParticipantsListPDU(pCurr->value.node_update.u.node_replace_record.participants_list);
		}
	}
}

void CConfRoster::FreeSetOfUpdatesPDU(void)
{
	PSetOfNodeRecordUpdates		pCurr, pNext;
	//PSetOfNodeRecordUpdates		current_record_update;

	for (pCurr = m_NodeInformation.node_record_list.u.node_record_update;
	        NULL != pCurr;
	        pCurr = pNext)
	{
	    pNext = pCurr->next;
	    CleanUpdateRecordPDU(pCurr);
	    delete pCurr;
    }
    m_NodeInformation.node_record_list.u.node_record_update = NULL;

    m_RecordList2.CleanList();
}


void CConfRecordList2::CleanList(void)
{
	CONF_RECORD *lpRec;
	/*
	 * Iterate through the internal list of Record structures telling each
	 * CUserDataListContainer object in the Record to free up it's PDU data.
	 */
	Reset();
	while (NULL != (lpRec = Iterate()))
	{
		if (lpRec->user_data_list != NULL)
		{
			lpRec->user_data_list->FreeUserDataListPDU();
		}

		if (lpRec->network_address_list != NULL)
		{
			lpRec->network_address_list->FreeNetworkAddressListPDU();
		}
	}
}


/*
 *	void	FreeParticipantsListPDU	()
 *
 *	Private Function Description
 *		This routine is used to free up any data allocated to construct the
 *		"PDU" form of the "ParticipantList" portion of the
 *		RosterUpdateIndication	"PDU" structure.
 *
 *	Formal Parameters:
 *		participants_list	-	(i/o)	This is the participant list PDU
 *										to free up.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConfRoster::FreeParticipantsListPDU(
									PParticipantsList		participants_list)
{
	PParticipantsList		pCurr, pNext;

	for (pCurr = participants_list; NULL != pCurr; pCurr = pNext)
	{
		pNext = pCurr->next;
		delete pCurr;
	}
}


/*
 * These routines process roster update indication PDUs.
 */


/*
 *	GCCError	ProcessRosterUpdateIndicationPDU	()
 *
 *	Public Function Description:
 *		This routine is used process a RosterUpdateIndication PDU by saving the
 *		data in the internal format.
 */
GCCError CConfRoster::ProcessRosterUpdateIndicationPDU(
									PNodeInformation		node_information,
									UserID					sender_id)
{
	GCCError		rc = GCC_NO_ERROR;
	CUidList		node_delete_list;

	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduFlushed = FALSE;
	}

	/*
	**	If this is a conference roster update and refresh is chosen we must
	**	clear out the entire list and rebuild it.
	*/
	if (node_information->node_record_list.choice == NODE_RECORD_REFRESH_CHOSEN)
	{
		m_fRosterChanged = TRUE;
		
		/*
		**	If this refresh came from the top provider we must clear out the
		**	entire roster to prepare for the new roster list.  If it was NOT
		**	sent by the Top Provider, we must determine which sub tree is
		**	affected and clear out this particular sub tree.
		*/
		if (sender_id == m_uidTopProvider)
        {
			ClearRecordList();
        }
		else
		{
			rc = GetNodeSubTree(sender_id, &node_delete_list);
			if (rc == GCC_NO_ERROR)
			{
				UserID uid;

				//	Clear out the affected nodes
				node_delete_list.Reset();
				while (GCC_INVALID_UID != (uid = node_delete_list.Iterate()))
                {
					DeleteRecord(uid);
                }
			}
		}

		/*
		**	Increment the instance number if this node is the top provider or
		**	a local roster otherwise get the instance number from the PDU.
		*/
		if (rc == GCC_NO_ERROR)
		{
			if ((m_fTopProvider) || (m_fLocalRoster))
            {
				m_nInstanceNumber++;
            }
			else
            {
				m_nInstanceNumber = node_information->roster_instance_number;
            }

			if (m_fNodesAdded == FALSE)
            {
				m_fNodesAdded = node_information->nodes_are_added;
            }

			if (m_fNodesRemoved == FALSE)
            {
				m_fNodesRemoved = node_information->nodes_are_removed;
            }

			rc = ProcessSetOfRefreshesPDU(node_information->node_record_list.u.node_record_refresh);
		}
	}
	else if (node_information->node_record_list.choice == NODE_RECORD_UPDATE_CHOSEN)
	{
		m_fRosterChanged = TRUE;

		/*
		**	Increment the instance number if this node is the top provider or
		**	a local roster otherwise get the instance number from the PDU.
		*/
		if ((m_fTopProvider) || (m_fLocalRoster))
        {
			m_nInstanceNumber++;
        }
		else
        {
			m_nInstanceNumber = node_information->roster_instance_number;
        }

		if (m_fNodesAdded == FALSE)
        {
			m_fNodesAdded = node_information->nodes_are_added;
        }

		if (m_fNodesRemoved == FALSE)
        {
			m_fNodesRemoved = node_information->nodes_are_removed;
        }

		rc = ProcessSetOfUpdatesPDU(node_information->node_record_list.u.node_record_update);
	}

	return (rc);
}


/*
 *	GCCError	ProcessSetOfRefreshesPDU	()
 *
 *	Private Function Description:
 *		This routine is used process the SetOfRefreshes portion of a
 *		RosterUpdateIndication PDU by saving the data in the internal format.
 *
 *	Formal Parameters:
 *		record_refresh	-	(i)	Refresh PDU data to process.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConfRoster::ProcessSetOfRefreshesPDU(
							PSetOfNodeRecordRefreshes		record_refresh)
{
	GCCError							rc = GCC_NO_ERROR;
	PSetOfNodeRecordRefreshes			current_record_refresh;
	UserID								node_id;
	CONF_RECORD     					*internal_record = NULL;
	
	if (record_refresh != NULL)
	{
		current_record_refresh = record_refresh;
		while ((current_record_refresh != NULL) &&
				(rc == GCC_NO_ERROR))
		{
			node_id = (UserID)current_record_refresh->value.node_id;

			/*
			 *	Create and fill in the new internal conference record.
			 */
			DBG_SAVE_FILE_LINE
			internal_record = new CONF_RECORD;
			if (internal_record == NULL)
			{
				ERROR_OUT(("CConfRoster::ProcessSetOfRefreshesPDU: Error "
						"creating new Record"));
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}

			/*
			 *	Fill in the superior node ID if it is present.
			 */
			if (current_record_refresh->value.node_record.bit_mask &
            											SUPERIOR_NODE_PRESENT)
			{
				internal_record->superior_node = current_record_refresh->
								value.node_record.superior_node;
			}
			else
			{
				ASSERT(0 == internal_record->superior_node);
			}

			/*
			 *	Fill in the node type and node properties which are always
			 *	present.
			 */
			internal_record->node_type = current_record_refresh->
							value.node_record.node_type;

			internal_record->node_properties = current_record_refresh->
							value.node_record.node_properties;

			/*
			 *	Fill in the node name if it is present.
			 */
			if (current_record_refresh->value.node_record.bit_mask & NODE_NAME_PRESENT)
			{
				if (NULL == (internal_record->pwszNodeName = ::My_strdupW2(
								current_record_refresh->value.node_record.node_name.length,
								current_record_refresh->value.node_record.node_name.value)))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->pwszNodeName);
			}

			/*
			 *	Fill in the participants name list if it is present.
			 */
			if ((rc == GCC_NO_ERROR) &&
				(current_record_refresh->value.node_record.bit_mask &
            										PARTICIPANTS_LIST_PRESENT))
			{
				rc = ProcessParticipantsListPDU (
									current_record_refresh->
										value.node_record.participants_list,
										internal_record);
			}
			else
			{
				ASSERT(NULL == internal_record->participant_name_list);
			}
	
			/*
			 *	Fill in the site information if it is present.
			 */
			if ((rc == GCC_NO_ERROR) &&
				(current_record_refresh->value.node_record.bit_mask & SITE_INFORMATION_PRESENT))
			{
				if (NULL == (internal_record->pwszSiteInfo = ::My_strdupW2(
								current_record_refresh->value.node_record.site_information.length,
								current_record_refresh->value.node_record.site_information.value)))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->pwszSiteInfo);
			}

			/*
			 * Fill in the network address if it is present.  The network
			 * address is maintained internally as a CNetAddrListContainer object
			 * which is constructed here from the PDU "SetOfNetworkAddresses"
			 * structure.  If an error occurs in constructing the object, set
			 * the Record's network address list pointer to NULL.
			 */
			if ((rc == GCC_NO_ERROR) &&
					(current_record_refresh->value.node_record.bit_mask &
            										RECORD_NET_ADDRESS_PRESENT))
			{
				DBG_SAVE_FILE_LINE
				internal_record->network_address_list = new CNetAddrListContainer(
						current_record_refresh->value.node_record.record_net_address,
						&rc);
				if ((internal_record->network_address_list == NULL) ||
					(rc != GCC_NO_ERROR))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->network_address_list);
			}

			/*
			 * Fill in the alternative node ID if it is present.
			 */
			if ((rc == GCC_NO_ERROR) &&
					(current_record_refresh->value.node_record.bit_mask &
            									ALTERNATIVE_NODE_ID_PRESENT))
			{
				if (NULL == (internal_record->poszAltNodeID = ::My_strdupO2(
								current_record_refresh->value.node_record.
									alternative_node_id.u.h243_node_id.value,
								current_record_refresh->value.node_record.
									alternative_node_id.u.h243_node_id.length)))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->poszAltNodeID);
			}
	
			/*
			 * Fill in the user data if it is present.  The user data is
			 * maintained internally as a CUserDataListContainer object which is
			 * constructed here from the PDU "SetOfUserData" structure.  If an
			 * error occurs in constructing the object, set the Record's user
			 * data pointer to NULL.
			 */
			if ((rc == GCC_NO_ERROR) &&
				(current_record_refresh->value.node_record.bit_mask &
            										RECORD_USER_DATA_PRESENT))
			{
				DBG_SAVE_FILE_LINE
				internal_record->user_data_list = new CUserDataListContainer(
						current_record_refresh->value.node_record.record_user_data,
						&rc);
				if ((internal_record->user_data_list == NULL) ||
					(rc != GCC_NO_ERROR))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->user_data_list);
			}

			/*
			 * If the Record was successfully filled in, add it to the internal
			 * Rogue Wave list.
			 */
			if (rc == GCC_NO_ERROR)
			{
				m_RecordList2.Append(node_id, internal_record);
				current_record_refresh = current_record_refresh->next;
			}
		}
	}

	/*
	**	Build a full refresh PDU here if no errors occured while processing
	**	the refresh PDU.									
	*/
	if (rc == GCC_NO_ERROR)
	{
		rc = BuildRosterUpdateIndicationPDU(FULL_REFRESH, 0);
	}
	else
	{
		delete internal_record;
	}

	return (rc);
}


/*
 *	GCCError	ProcessSetOfUpdatesPDU	()
 *
 *	Private Function Description:
 *		This routine is used process the SetOfUpdates portion of a
 *		RosterUpdateIndication PDU by saving the data in the internal format.
 *
 *	Formal Parameters:
 *		record_update	-	(i)	Update PDU data to process.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConfRoster::ProcessSetOfUpdatesPDU(
					  		PSetOfNodeRecordUpdates		record_update)
{
	GCCError					rc = GCC_NO_ERROR;
	PSetOfNodeRecordUpdates		current_record_update;
	UserID						node_id;
	PNodeRecord					node_record;
	CONF_RECORD     			*internal_record;
	CONF_ROSTER_UPDATE_TYPE		update_type;

	if (record_update != NULL)
	{
		current_record_update = record_update;

		while ((current_record_update != NULL) &&
				(rc == GCC_NO_ERROR))
		{
			internal_record = NULL;
			node_id = (UserID)current_record_update->value.node_id;

			//	Create and fill in the new conference record.
			if (current_record_update->value.node_update.choice ==
													NODE_ADD_RECORD_CHOSEN)
			{
				//	Add the record.
				if (! m_RecordList2.Find(node_id))
				{
					node_record = &current_record_update->value.node_update.u.node_add_record;
					update_type = ADD_RECORD;
				}
				else
				{
					node_record = NULL;
					ERROR_OUT(("CConfRoster: ProcessSetOfUpdatesPDU: can't add record"));
				}
			}
			else if (current_record_update->value.node_update.choice ==
													NODE_REPLACE_RECORD_CHOSEN)
			{
				//	Replace the record.
				if (m_RecordList2.Find(node_id))
				{
					DeleteRecord (node_id);
					node_record = &current_record_update->
									value.node_update.u.node_replace_record;
					update_type = REPLACE_RECORD;
				}
				else
				{
					node_record = NULL;
					WARNING_OUT(("CConfRoster: ProcessSetOfUpdatesPDU: "
								"ASSERTION: Replace record failed"));
				}
			}
			else
			{
				//	Remove the record.
				if (m_RecordList2.Find(node_id))
				{
					DeleteRecord (node_id);
					update_type = DELETE_RECORD;
				}
				else
                {
					ERROR_OUT(("CConfRoster: ProcessSetOfUpdatesPDU: can't delete record"));
                }

				node_record = NULL;
			}
			
			/*
			**	Process the conference record if one exists.  Create a new
			**	node record to be filled in and added to the internal record
			**	list.
			*/
			if (node_record != NULL)
			{
				DBG_SAVE_FILE_LINE
				internal_record = new CONF_RECORD;
				if (internal_record == NULL)
				{
					ERROR_OUT(("CConfRoster::ProcessSetOfUpdatesPDU: can't create new record"));
					rc = GCC_ALLOCATION_FAILURE;
					break;
				}

				//	Fill in the superior node ID if it is present.
				if (node_record->bit_mask & SUPERIOR_NODE_PRESENT)
				{
					internal_record->superior_node = node_record->superior_node;
				}
				else
				{
					ASSERT(0 == internal_record->superior_node);
				}

				/*
				**	Fill in the node type and node properties which are always
				**	present.
				*/
				internal_record->node_type = node_record->node_type;
				internal_record->node_properties = node_record->node_properties;

				//	Fill in the node name if it is present.
				if (node_record->bit_mask & NODE_NAME_PRESENT)
				{
					if (NULL == (internal_record->pwszNodeName = ::My_strdupW2(
										node_record->node_name.length,
										node_record->node_name.value)))
					{
						rc = GCC_ALLOCATION_FAILURE;
					}
				}
				else
				{
					ASSERT(NULL == internal_record->pwszNodeName);
				}

				//	Fill in the participants list if it is present.
				if ((rc == GCC_NO_ERROR) &&
					(node_record->bit_mask & PARTICIPANTS_LIST_PRESENT))
				{
					rc = ProcessParticipantsListPDU(node_record->participants_list,
												    internal_record);
				}
				else
				{
					ASSERT(NULL == internal_record->participant_name_list);
				}

				//	Fill in the site information if it is present.
				if ((rc == GCC_NO_ERROR) &&
					(node_record->bit_mask & SITE_INFORMATION_PRESENT))
				{
					if (NULL == (internal_record->pwszSiteInfo = ::My_strdupW2(
										node_record->site_information.length,
										node_record->site_information.value)))
					{
						rc = GCC_ALLOCATION_FAILURE;
					}
				}
				else
				{
					ASSERT(NULL == internal_record->pwszSiteInfo);
				}

				/*
				**	Fill in the network address if it is present.  The network
				**	address is maintained internally as a CNetAddrListContainer
				**	object which is constructed here from the PDU
				**	"SetOfNetworkAddresses" structure.  If an error occurs
				**	in constructing the object, set the Record's network address
				**	list pointer to NULL.
				*/
				if ((rc == GCC_NO_ERROR) &&
					(node_record->bit_mask & RECORD_NET_ADDRESS_PRESENT))
				{
					DBG_SAVE_FILE_LINE
					internal_record->network_address_list =
										new CNetAddrListContainer(node_record->record_net_address, &rc);
					if ((internal_record->network_address_list == NULL) ||
						(rc != GCC_NO_ERROR))
					{
						rc = GCC_ALLOCATION_FAILURE;
					}
				}
				else
				{
					ASSERT(NULL == internal_record->network_address_list);
				}

				/*
				 * Fill in the alternative node ID if it is present.
				 */
				if ((rc == GCC_NO_ERROR) &&
					(node_record->bit_mask & ALTERNATIVE_NODE_ID_PRESENT))
				{
					if (NULL == (internal_record->poszAltNodeID = ::My_strdupO2(
							node_record->alternative_node_id.u.h243_node_id.value,
							node_record->alternative_node_id.u.h243_node_id.length)))
					{
						rc = GCC_ALLOCATION_FAILURE;
					}
				}
				else
				{
					ASSERT(NULL == internal_record->poszAltNodeID);
				}

				/*
				 * Fill in the user data if it is present.  The user data is
				 * maintained internally as a CUserDataListContainer object which is
				 * constructed here from the PDU "SetOfUserData" structure.  If
				 * an error occurs in constructing the object, set the Record's
				 * user data pointer to NULL.
				 */
				if ((rc == GCC_NO_ERROR) &&
					(node_record->bit_mask & RECORD_USER_DATA_PRESENT))
				{
					DBG_SAVE_FILE_LINE
					internal_record->user_data_list = new CUserDataListContainer(
											node_record->record_user_data,
											&rc);
					if ((internal_record->user_data_list == NULL) ||
						(rc != GCC_NO_ERROR))
					{
						rc = GCC_ALLOCATION_FAILURE;
					}
				}
				else
				{
					ASSERT(NULL == internal_record->user_data_list);
				}
			}

			/*
			**	Here we add this update to our PDU and jump to the next update
			**	in the PDU currently being processed.
			*/
			if (rc == GCC_NO_ERROR)
			{
				/*
				**	If the Record was successfully filled in, add it to the
				**	internal Rogue Wave list.
				*/
				if (internal_record != NULL)
                {
					m_RecordList2.Append(node_id, internal_record);
                }

                //	Build the PDU from the above update.
				rc = BuildRosterUpdateIndicationPDU(update_type, node_id);
				if (rc == GCC_NO_ERROR)
                {
					current_record_update = current_record_update->next;
                }
			}
			else
			{
				delete internal_record;
			}
		}
	}

	return (rc);
}


/*
 *	GCCError	ProcessParticipantsListPDU	()
 *
 *	Private Function Description:
 *		This routine is used process the ParticipantsList portion of an
 *		incoming RosterUpdateIndication PDU by saving the data in the internal
 *		format.
 *
 *	Formal Parameters:
 *		participants_list	-	(i)	Participant List PDU data to process.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_ALLOCATION_FAILURE	-	A resource error occured.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
GCCError CConfRoster::ProcessParticipantsListPDU (	
							PParticipantsList		participants_list,
							CONF_RECORD     		*node_record)
{
	GCCError				rc = GCC_NO_ERROR;
	PParticipantsList		pCurr;
	LPWSTR					pwszParticipantName;
	
	/*
	 * Clear the current list.
	 */
	DBG_SAVE_FILE_LINE
	node_record->participant_name_list = new CParticipantNameList;

	if (node_record->participant_name_list == NULL)
		return (GCC_ALLOCATION_FAILURE);

	for (pCurr = participants_list; NULL != pCurr; pCurr = pCurr->next)
	{
		if (NULL != (pwszParticipantName = ::My_strdupW2(pCurr->value.length, pCurr->value.value)))
		{
			(node_record->participant_name_list)->Append(pwszParticipantName);
		}
		else
		{
			rc = GCC_ALLOCATION_FAILURE;
			break;
		}
	}

	return (rc);
}


/*
 * Utilities that operate on conference records.
 */

/*
 *	UINT	LockConferenceRoster	()
 *
 *	Public Function Description:
 *		This routine is used "lock" the CConfRoster data in the "API"
 *		form.  The "API" version of the CConfRoster is built from the
 * 		internally maintained data.
 */
UINT CConfRoster::LockConferenceRoster(void)
{
	CONF_RECORD     	*internal_node_record;

	if (Lock() == 1)
	{
		//CONF_RECORD     	*lpRec;
		/*
		 * Set aside memory to hold the conference roster, the pointers to the
		 * GCCNodeRecord structures	and the GCCNodeRecord structures themselves.
		 * The "sizeof" the structure must be rounded to an even four-byte
		 * boundary.
		 */
		m_cbDataMemorySize = ROUNDTOBOUNDARY (sizeof (GCCConferenceRoster));

		m_cbDataMemorySize += m_RecordList2.GetCount() *
						(sizeof(PGCCNodeRecord) + ROUNDTOBOUNDARY (sizeof(GCCNodeRecord)) );

	 	m_RecordList2.Reset();
		while (NULL != (internal_node_record = m_RecordList2.Iterate()))
		{
			/*
			 * Add the size of the node name Unicode String, if it exists.
			 * Space must be allowed for the NULL terminator of the string.
			 */
			if (internal_node_record->pwszNodeName != NULL)
			{
				m_cbDataMemorySize += ROUNDTOBOUNDARY(
						(::lstrlenW(internal_node_record->pwszNodeName) + 1) * sizeof(WCHAR));
			}

			/*
			 * Add the amount of memory needed to hold the pointers to the
			 * list of participants, if it exists.  Also add the total amount
			 * of memory needed to hold the participant list data.
			 */
			if (internal_node_record->participant_name_list != NULL)
			{
				LPWSTR				lpUstring;

				m_cbDataMemorySize += internal_node_record->participant_name_list->GetCount() * sizeof(LPWSTR);

				/*
				 * Set up an iterator for the participant name list in order to
				 * add the amount of memory necessary to hold each Unicode
				 * String.	Space must be allowed for the strings' NULL
				 * terminators.
				 */
				internal_node_record->participant_name_list->Reset();
				while (NULL != (lpUstring = internal_node_record->participant_name_list->Iterate()))
				{
					m_cbDataMemorySize += ROUNDTOBOUNDARY(
							(::lstrlenW(lpUstring) + 1) * sizeof(WCHAR));
				}
			}

			/*
			 * Add the size of the site information Unicode String, if it
			 * exists.  Space must be allowed for the NULL terminator of
			 * the string.
			 */
			if (internal_node_record->pwszSiteInfo != NULL)
			{
				m_cbDataMemorySize += ROUNDTOBOUNDARY(
						(::lstrlenW(internal_node_record->pwszSiteInfo) + 1) * sizeof(WCHAR));
			}

			/*
			 * If a network address list is present, lock the internal network
			 * address list object in order to find	the amount of memory
			 * required by the list.
			 */
			if (internal_node_record->network_address_list != NULL)
			{
				m_cbDataMemorySize += internal_node_record->
						network_address_list->LockNetworkAddressList ();
			}

			/*
			 * Add the space necessary to hold the alternative node ID octet
			 * string structure as well as the string data, if it exists.
			 */
			if (internal_node_record->poszAltNodeID != NULL)
			{
				m_cbDataMemorySize += ROUNDTOBOUNDARY(sizeof(OSTR));
				m_cbDataMemorySize += ROUNDTOBOUNDARY(internal_node_record->poszAltNodeID->length);
			}

			/*
			 * If a user data list is present, lock the internal user data
			 * list object in order to find	the amount of memory required by
			 * the list.
			 */
			if (internal_node_record->user_data_list != NULL)
			{
				m_cbDataMemorySize += internal_node_record->user_data_list->LockUserDataList ();
			}
		}
	}

    return m_cbDataMemorySize;
} 	

/*
 *	void	UnLockConferenceRoster	()
 *
 *	Public Function Description:
 *		This routine is used to "unlock" the CConfRoster "API" data.  The
 *		lock count is decremented each time the routine is called and the "API"
 *		data will actually be freed when the lock count reaches zero.
 */
void CConfRoster::UnLockConferenceRoster(void)
{
	if (Unlock(FALSE) == 0)
	{
		CONF_RECORD *lpRec;

		/*
		**	Set up an iterator in order to unlock any internal data
		**	containers
		**	which have been locked.
		*/
		m_RecordList2.Reset();
		while (NULL != (lpRec = m_RecordList2.Iterate()))
		{
			/*
			 * Unlock the network address list if it exists.
			 */
			if (lpRec->network_address_list != NULL)
			{
				lpRec->network_address_list->UnLockNetworkAddressList ();
			}

			/*
			 * Unlock the user data list if it exists.
			 */
			if (lpRec->user_data_list != NULL)
			{
				lpRec->user_data_list->UnLockUserDataList ();
			}
		}
	}	

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}


/*
 *	UINT	GetConfRoster	()
 *
 *	Public Function Description:
 *		This routine is called in order to retrieve the CConfRoster data
 *		in "API" form.  The CConfRoster data must first be "locked" before
 *		this routine may be called.
 */
UINT CConfRoster::GetConfRoster(
			PGCCConferenceRoster		 *	conference_roster,
			LPBYTE							memory)
{
	UINT					rc;

	/*
	 * If the user data has been locked, fill in the output parameters and
	 * the data referenced by the pointers.  Otherwise, report that the object
	 * has yet to be locked into the "API" form.
	 */
	if (GetLockCount() > 0)
	{
	    UINT					total_data_length = 0;
	    UINT					data_length = 0;
	    UINT    				node_record_counter = 0;
	    PGCCNodeRecord			node_record;
	    PGCCConferenceRoster	roster;
	    CONF_RECORD     		*internal_record;
	    UserID					node_id;
	    USHORT					i;

        /*
		 * Fill in the output length parameter which indicates how much data
		 * referenced outside the structure will be written.
		 */
		rc = m_cbDataMemorySize;

		/*
		 * Set the conference roster pointer equal to the memory pointer passed
		 * in.  This is where the conference roster structure will be built.
		 * Save the conference roster pointer for convienence.
		 */
		*conference_roster = (PGCCConferenceRoster)memory;
		roster = *conference_roster;

		/*
		 * Fill in all of the elements of the conference roster except for
		 * the node record list.
		 */
		roster->instance_number = (USHORT)m_nInstanceNumber;
		roster->nodes_were_added = m_fNodesAdded;
		roster->nodes_were_removed = m_fNodesRemoved;
		roster->number_of_records = (USHORT) m_RecordList2.GetCount();

		/*
		 * The "total_data_length" will hold the total amount of data written
		 * into memory.  Save the amount of memory needed to hold the
		 * conference roster.  Add the amount of memory necessary to hold the
		 * node record pointers and structures.
		 */
		data_length = ROUNDTOBOUNDARY(sizeof(GCCConferenceRoster));

		total_data_length = data_length + m_RecordList2.GetCount() *
				(ROUNDTOBOUNDARY(sizeof(GCCNodeRecord)) + sizeof(PGCCNodeRecord));

		/*
		 * Move the memory pointer past the conference roster structure.  This
		 * is where the node record pointer list will be written.
		 */
		memory += data_length;

		/*
		 * Set the roster's node record list pointer.
		 */
		roster->node_record_list = (PGCCNodeRecord *)memory;

		/*
		 * Move the memory pointer past the list of node record pointers.
		 */
		memory += (m_RecordList2.GetCount() * sizeof(PGCCNodeRecord));

		/*
		 * Iterate through the internal list of record structures, building
		 * "API" GCCNodeRecord structures in memory.
		 */
		m_RecordList2.Reset();
		while (NULL != (internal_record = m_RecordList2.Iterate(&node_id)))
		{
			/*
			 * Save the pointer to the node record structure in the list
			 * of pointers.  Get the internal node record from the list.
			 */
			node_record = (PGCCNodeRecord)memory;
			roster->node_record_list[node_record_counter++] = node_record;

			/*
			 *	Fill in the node ID and the superior node ID.
			 */
			node_record->node_id = node_id;
			node_record->superior_node_id = internal_record->superior_node;
				
			/*
			 *	Fill in the node type and the node properties.
			 */
			GetNodeTypeAndProperties (
					internal_record->node_type,
					internal_record->node_properties,
					&node_record->node_type,
					&node_record->node_properties);

			/*
			 * Move the memory pointer past the node record structure.  This is
			 * where the node name unicode string will be written, if it exists.
			 */
			memory += ROUNDTOBOUNDARY(sizeof(GCCNodeRecord));

			if (internal_record->pwszNodeName != NULL)
			{
				/*
				 * Set the record's node name pointer and copy the node name
				 * data into memory from the internal unicode string.  Be sure
				 * to copy the strings NULL terminating character.  Move the
				 * memory pointer past the node name string data.
				 */
				node_record->node_name = (LPWSTR) memory;
				UINT cbStrSize = (::lstrlenW(internal_record->pwszNodeName) + 1) * sizeof(WCHAR);
				::CopyMemory(memory, internal_record->pwszNodeName, cbStrSize);
				total_data_length += ROUNDTOBOUNDARY(cbStrSize);
				memory += (Int) ROUNDTOBOUNDARY(cbStrSize);
			}
			else
			{
				/*
				 * The node name string does not exist, so set the node record
				 * pointer to NULL.
				 */
				node_record->node_name = NULL;
			}

			if (internal_record->participant_name_list != NULL)
			{
				LPWSTR				lpUstring;
				/*
				 * Fill in the node record's participant name list.  Use an
				 * iterator	to access each participant name for this node
				 * record, copying each string into the appropriate location
				 * in memory.
				 */
				node_record->participant_name_list = (LPWSTR *)memory;
				node_record->number_of_participants = (USHORT)
								internal_record->participant_name_list->GetCount();

				/*
				 * Move the memory pointer past the list of participant name
				 * pointers.  This is where the first participant name string
				 * will	be written.  There is no need to round this value off
				 * to an even multiple of four bytes since a LPWSTR
				 * is actually a pointer.
				 */
				memory += internal_record->participant_name_list->GetCount() * sizeof(LPWSTR);
				total_data_length += internal_record->participant_name_list->GetCount() * sizeof(LPWSTR);

				/*
				 * Initialize the loop counter to zero and fill in the
				 * participants name list.
				 */
				i = 0;
				internal_record->participant_name_list->Reset();
				while (NULL != (lpUstring = internal_record->participant_name_list->Iterate()))
				{
					node_record->participant_name_list[i++] = (LPWSTR)memory;
					UINT cbStrSize = (::lstrlenW(lpUstring) + 1) * sizeof(WCHAR);
					::CopyMemory(memory, lpUstring, cbStrSize);
					memory += ROUNDTOBOUNDARY(cbStrSize);
					total_data_length += ROUNDTOBOUNDARY(cbStrSize);
				}
			}
			else
			{
				/*
				 * The participant name list does not exist, so set the node
				 * record pointer to NULL and the number of participants to
				 * zero.
				 */
				node_record->participant_name_list = NULL;
				node_record->number_of_participants = 0;
			}

			if (internal_record->pwszSiteInfo != NULL)
			{
				/*
				 * Set the record's site information pointer and copy the site
				 * information data into memory from the internal unicode
				 * string.  Be sure to copy	the strings NULL terminating
				 * character.  Move the memory pointer past the site information
				 * string data.
				 */
				node_record->site_information = (LPWSTR)memory;
				UINT cbStrSize = (::lstrlenW(internal_record->pwszSiteInfo) + 1) * sizeof(WCHAR);
				::CopyMemory(memory, internal_record->pwszSiteInfo, cbStrSize);
				total_data_length += ROUNDTOBOUNDARY(cbStrSize);
				memory += ROUNDTOBOUNDARY(cbStrSize);
			}
			else
			{
				/*
				 * The site information string does not exist, so set the
				 * node record pointer to NULL.
				 */
				node_record->site_information = NULL;
			}

			if (internal_record->network_address_list != NULL)
			{
				/*
				 * Fill in the network address list by using the internal
				 * CNetAddrListContainer object.  The "Get" call will fill in the
				 * node record's network address list pointer and number of
				 * addresses, write the network address data into memory, and
				 * return the amount of data written into memory.
				 */
				data_length = internal_record->network_address_list->GetNetworkAddressListAPI (	
								&node_record->number_of_network_addresses,
								&node_record->network_address_list,
								memory);

				/*
				 * Move the memory pointer past the network address list data.
				 * This is where the user data list data will be written.
				 */
				memory += data_length;
				total_data_length += data_length;
			}
			else
			{
				/*
				 * The network address list does not exist, so set the node
				 * record pointer to NULL and the number of addresses to zero.
				 */
				node_record->network_address_list = NULL;
				node_record->number_of_network_addresses = 0;
			}

			if (internal_record->poszAltNodeID != NULL)
			{
				/*
				 * Set the node record's alternative node ID pointer to the
				 * location in memory where the OSTR will be built.
				 * Note that the node record contains a pointer to a
				 * OSTR structure in memory, not just a pointer to
				 * string data.
				 */
				node_record->alternative_node_id = (LPOSTR) memory;

				/*
				 * Move the memory pointer past the octet string structure.
				 * This is where the actual string data will be written.
				 */
				memory += ROUNDTOBOUNDARY(sizeof(OSTR));
				total_data_length += ROUNDTOBOUNDARY(sizeof(OSTR));

				node_record->alternative_node_id->length =
						internal_record->poszAltNodeID->length;

				/*
				 * Set the pointer for the alternative node ID octet string
				 * equal to the location in memory where it will be copied.
				 */
				node_record->alternative_node_id->value =(LPBYTE)memory;

				/*
				 * Now copy the octet string data from the internal Rogue Wave
				 * string into the object key structure held in memory.
				 */
				::CopyMemory(memory, internal_record->poszAltNodeID->value,
						node_record->alternative_node_id->length);

				/*
				 * Move the memory pointer past the alternative node ID string
				 * data written into memory.
				 */
				memory += ROUNDTOBOUNDARY(node_record->alternative_node_id->length);

				total_data_length += ROUNDTOBOUNDARY(node_record->alternative_node_id->length);
			}
			else
			{
				/*
				 * The alternative node ID string does not exist, so set the
				 * node record pointer to NULL.
				 */
				node_record->alternative_node_id = NULL;
			}

			if (internal_record->user_data_list != NULL)
			{
				/*
				 * Fill in the user data list by using the internal CUserDataListContainer
				 * object.  The "Get" call will fill in the	node record's user
				 * data	list pointer and number of user data members, write the
				 * user	data into memory, and return the amount of data written
				 * into memory.
				 */
				data_length = internal_record->user_data_list->GetUserDataList (	
								&node_record->number_of_user_data_members,
								&node_record->user_data_list,
								memory);

				/*
				 * Move the memory pointer past the user data list data.
				 */
				memory += data_length;
				total_data_length += data_length;
			}
			else
			{
				/*
				 * The user data list does not exist, so set the node record
				 * pointer to NULL and the number of data members to zero.
				 */
				node_record->user_data_list = NULL;
				node_record->number_of_user_data_members = 0;
			}
		}
	}
	else
	{
		ERROR_OUT(("CConfRoster::GetConfRoster: Error Data Not Locked"));
    	*conference_roster = NULL;
        rc = 0;
	}

	return rc;
}


/*
 *	GCCError	AddRecord	()
 *
 *	Public Function Description:
 *		This routine is used to add a new Node Record to this conference
 *		roster object.
 */
GCCError CConfRoster::AddRecord(	PGCCNodeRecord			node_record,
									UserID					node_id)
{
	GCCError				rc = GCC_NO_ERROR;
    USHORT					i;
	LPWSTR					pwszParticipantName;
	CONF_RECORD     		*internal_record;
	
	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduFlushed = FALSE;
	}

	if (! m_RecordList2.Find(node_id))
	{
		DBG_SAVE_FILE_LINE
		internal_record = new CONF_RECORD;
		if (internal_record != NULL)
		{
			/*
			**	Convert the passed in conference record to the form that it
			**	is going to be stored in the internal roster database.
			*/

			/*
			**	Save the node type and properties internally.  These will
			**	always exist.
			*/
			GetPDUNodeTypeAndProperties (
									node_record->node_type,
									node_record->node_properties,
									&internal_record->node_type,
									&internal_record->node_properties);
			
			internal_record->superior_node = m_uidSuperiorNode;

			//	Save the node name internally if it exists.
			if (node_record->node_name != NULL)
			{
				if (::lstrlenW(node_record->node_name) > MAXIMUM_NODE_NAME_LENGTH)
				{
					rc = GCC_INVALID_NODE_NAME;
				}
				else
				if (NULL == (internal_record->pwszNodeName = ::My_strdupW(node_record->node_name)))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->pwszNodeName);
			}

			//	Save the list of participants internally if it exists.
			if ((node_record->number_of_participants != 0) &&
				(rc == GCC_NO_ERROR))
			{
				if (node_record->participant_name_list != NULL)
				{
					DBG_SAVE_FILE_LINE
					internal_record->participant_name_list = new CParticipantNameList;
					if (internal_record->participant_name_list == NULL)
						rc = GCC_ALLOCATION_FAILURE;
				}
				else
				{
					ASSERT(NULL == internal_record->participant_name_list);
					rc = GCC_INVALID_PARAMETER;
				}

				if (rc == GCC_NO_ERROR)
				{
					/*	
					**	Convert each participant name that is LPWSTR
					**	to a UnicodeString when storing it into a record.
					*/
					for (i = 0; i < node_record->number_of_participants; i++)
					{
						if (node_record->participant_name_list[i] != NULL)
						{
							if (::lstrlenW(node_record->participant_name_list[i]) >
											MAXIMUM_PARTICIPANT_NAME_LENGTH)
							{
								rc = GCC_INVALID_PARTICIPANT_NAME;
								//
								// LONCHANC: Why no "break"?
								//
							}
							else
							if (NULL == (pwszParticipantName = ::My_strdupW(
												node_record->participant_name_list[i])))
							{
								rc = GCC_ALLOCATION_FAILURE;
								break;
							}
							else
							{
								//	Add the participant to the list
								internal_record->participant_name_list->Append(pwszParticipantName);
							}
						}
						else
						{
							rc = GCC_INVALID_PARAMETER;
							break;
						}
					}
				}
			}
			else
			{
				ASSERT(NULL == internal_record->participant_name_list);
			}

			//	Save site information internally if it exists.
			if (node_record->site_information != NULL)
			{
				if (::lstrlenW(node_record->site_information) > MAXIMUM_SITE_INFORMATION_LENGTH)
				{
					rc = GCC_INVALID_SITE_INFORMATION;
				}
				else
				if (NULL == (internal_record->pwszSiteInfo =
										::My_strdupW(node_record->site_information)))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}	
			else
			{
				ASSERT(NULL == internal_record->pwszSiteInfo);
			}

			/*
			**	Fill in the network address list if it exists.  The network
			**	address list is maintained internally in a CNetAddrListContainer
			**	object which is constructed here using the GCCNetworkAddress
			**	portion of the "API"	node record passed in.
			*/
			if ((node_record->number_of_network_addresses != 0) &&
				(node_record->network_address_list != NULL) &&
				(rc == GCC_NO_ERROR))
			{
				DBG_SAVE_FILE_LINE
				internal_record->network_address_list = new CNetAddrListContainer(
						node_record->number_of_network_addresses,
						node_record->network_address_list,
						&rc);
				if ((internal_record->network_address_list == NULL) ||
					(rc != GCC_NO_ERROR))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->network_address_list);
			}

			//	Save the alternative node ID internally if it exists.
			if ((node_record->alternative_node_id != NULL) &&
				(rc == GCC_NO_ERROR))
			{
				if (NULL == (internal_record->poszAltNodeID = ::My_strdupO2(
								node_record->alternative_node_id->value,
								node_record->alternative_node_id->length)))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
				else if (internal_record->poszAltNodeID->length != ALTERNATIVE_NODE_ID_LENGTH)
				{
					ERROR_OUT(("not equal to alt node id length"));
					rc = GCC_INVALID_ALTERNATIVE_NODE_ID;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->poszAltNodeID);
			}

			/*
			**	Fill in the user data if it exists.  The user data is
			**	maintained internally in a CUserDataListContainer object which is
			**	constructed here using the GCCUserData portion of the "API"
			**	node record passed in.
			*/
			if ((node_record->number_of_user_data_members != 0) &&
				(node_record->user_data_list != NULL) &&
				(rc == GCC_NO_ERROR))
			{
				DBG_SAVE_FILE_LINE
				internal_record->user_data_list = new CUserDataListContainer(
						node_record->number_of_user_data_members,
						node_record->user_data_list,
						&rc);
				if ((internal_record->user_data_list == NULL) ||
					(rc != GCC_NO_ERROR))
				{
					rc = GCC_ALLOCATION_FAILURE;
				}
			}
			else
			{
				ASSERT(NULL == internal_record->user_data_list);
			}

			/*
			**	If the new Record was successfully filled in, add it to the
			**	internal Rogue Wave list of Records.
			*/
			if (rc == GCC_NO_ERROR)
			{
				//	Increment the instance number.
				m_nInstanceNumber++;
				m_fNodesAdded = TRUE;
				m_fRosterChanged = TRUE;

				//	Add the new record to the list of internal records.
				m_RecordList2.Append(node_id, internal_record);

				//	Add an update to the PDU.
				rc = BuildRosterUpdateIndicationPDU(ADD_RECORD, node_id);
			}
			else
			{
				delete internal_record;
			}
		}
		else
        {
			rc = GCC_ALLOCATION_FAILURE;
        }
	}
	else
    {
		rc = GCC_INVALID_PARAMETER;
    }

	return (rc);
}


/*
 *	GCCError	RemoveUserReference	()
 *
 *	Public Function Description:
 *		This routine is used to remove a node record from the list of node
 *		records.
 */
GCCError CConfRoster::RemoveUserReference(UserID	detached_node_id)
{
	GCCError			rc = GCC_NO_ERROR;
	CONF_RECORD     	*node_record;
	CUidList			node_delete_list;

	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduFlushed = FALSE;
	}

	/*
	**	Here we must determine if the node that is detaching is directly
	**	connected to this node.  If so, we will delete the node and any other
	**	nodes found in the roster list that are subordinate to this.  We
	**	determine all of this by using the superior node id stored in each
	**	conference record.
	*/
	if (NULL != (node_record = m_RecordList2.Find(detached_node_id)))
	{
		//	Is this node directly connected to me?
		if (node_record->superior_node == m_uidMyNodeID)
		{
			/*
			**	Use NULL for the pointer since were not concerned about
			**	the pointer here.
			*/
			rc = GetNodeSubTree(detached_node_id, &node_delete_list);
			if (rc == GCC_NO_ERROR)
			{
                UserID uid;

                node_delete_list.Reset();
				while ((GCC_INVALID_UID != (uid = node_delete_list.Iterate())) &&
				        (rc == GCC_NO_ERROR))
				{
					rc = DeleteRecord(uid);
				}

				if (rc == GCC_NO_ERROR)
				{
					//	Increment the instance number.
					m_nInstanceNumber++;
					m_fNodesRemoved = TRUE;
					m_fRosterChanged = TRUE;

					//	Add an update to the PDU.
					rc = BuildRosterUpdateIndicationPDU (FULL_REFRESH, 0 );
				}
			}
		}
		else
        {
			rc = GCC_INVALID_PARAMETER;
        }
	}
	else
    {
	    rc = GCC_INVALID_PARAMETER;
    }

	return (rc);
}


/*
 *	GCCError	ReplaceRecord	()
 *
 *	Public Function Description:
 *		This routine is used to replace one of the records in the list of
 *		node records.
 */
GCCError CConfRoster::ReplaceRecord(
									PGCCNodeRecord			node_record,
									UserID					node_id)
{
	GCCError				rc = GCC_NO_ERROR;
	USHORT					i;
	LPWSTR					pwszParticipantName;
	CONF_RECORD     		*pCRD = NULL;

	/*
	**	Free up the old PDU data here if it is being maintained and the
	**	PDU has been flushed.  Note that we also set the PDU is flushed boolean
	**	back to FALSE so that the new PDU will be maintained until it is
	**	flushed.
	*/
	if (m_fPduFlushed)
	{
		FreeRosterUpdateIndicationPDU ();
		m_fPduFlushed = FALSE;
	}

    //
    // LONCHANC: Do we really need to check this? Why can't we simply
    // add the new one if the old one does not exist?
    //
	if (NULL == m_RecordList2.Find(node_id))
	{
		rc = GCC_INVALID_PARAMETER;
		goto MyExit;
	}

	DBG_SAVE_FILE_LINE
	if (NULL == (pCRD = new CONF_RECORD))
	{
		rc = GCC_ALLOCATION_FAILURE;
		goto MyExit;
	}

	/*
	**	First we build all the internal data and check for validity
	**	before we replace the old record.  We want to make sure that
	**	everything will build before we do the replace.  This prevents
	**	us from corrupting the current record if there is a problem
	**	with the new record data.
	*/

	//	Save the node name internally if it exists.
	if (node_record->node_name != NULL)
	{
		if (::lstrlenW(node_record->node_name) > MAXIMUM_NODE_NAME_LENGTH)
		{
			rc = GCC_INVALID_NODE_NAME;
		}
		else
		if (NULL == (pCRD->pwszNodeName = ::My_strdupW(node_record->node_name)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	//	Save the list of participants internally if it exists.
	if ((node_record->number_of_participants != 0) &&
		(rc == GCC_NO_ERROR))
	{
		if (node_record->participant_name_list != NULL)
		{
			DBG_SAVE_FILE_LINE
			if (NULL == (pCRD->participant_name_list = new CParticipantNameList))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
			rc = GCC_INVALID_PARAMETER;

		if (rc == GCC_NO_ERROR)
		{
			/*	
			**	Convert each participant name that is LPWSTR
			**	to a UnicodeString when storing it into a record.
			*/
			for (i = 0; i < node_record->number_of_participants; i++)
			{
				if (node_record->participant_name_list[i] != NULL)
				{
					if (::lstrlenW(node_record->participant_name_list[i]) >
									MAXIMUM_PARTICIPANT_NAME_LENGTH)
					{
						rc = GCC_INVALID_PARTICIPANT_NAME;
						//
						// LONCHANC: Why no "break"?
						//
					}
					else
					if (NULL == (pwszParticipantName = ::My_strdupW(
									node_record->participant_name_list[i])))
					{
						rc = GCC_ALLOCATION_FAILURE;
						break;
					}
					else
					{
						//	Add the participant to the list
						pCRD->participant_name_list->Append(pwszParticipantName);
					}
				}
				else
				{
					rc = GCC_INVALID_PARAMETER;
					break;
				}
			}
		}
	}

	//	Save site information internally if it exists.
	if (node_record->site_information != NULL)
	{
		if (::lstrlenW(node_record->site_information) > MAXIMUM_SITE_INFORMATION_LENGTH)
		{
			rc = GCC_INVALID_SITE_INFORMATION;
		}
		else
		if (NULL == (pCRD->pwszSiteInfo = ::My_strdupW(node_record->site_information)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	/*
	**	Fill in the network address list if it exists.  The network
	**	address list is maintained internally in a CNetAddrListContainer
	**	object which is constructed here using the GCCNetworkAddress
	**	portion of the "API"	node record passed in.
	*/
	if ((node_record->number_of_network_addresses != 0) &&
		(node_record->network_address_list != NULL) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		pCRD->network_address_list = new CNetAddrListContainer(
				node_record->number_of_network_addresses,
				node_record->network_address_list,
				&rc);
		if ((pCRD->network_address_list == NULL) ||
			(rc != GCC_NO_ERROR))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	//	Save the alternative node ID internally if it exists.
	if ((node_record->alternative_node_id != NULL) &&
		(rc == GCC_NO_ERROR))
	{
		if (NULL == (pCRD->poszAltNodeID = ::My_strdupO2(
				node_record->alternative_node_id->value,
				node_record->alternative_node_id->length)))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
		else if (pCRD->poszAltNodeID->length !=ALTERNATIVE_NODE_ID_LENGTH)
		{
			ERROR_OUT(("not equal to alt node id length"));
			rc = GCC_INVALID_ALTERNATIVE_NODE_ID;
		}
	}

	/*
	**	Fill in the user data if it exists.  The user data is
	**	maintained internally in a CUserDataListContainer object which is
	**	constructed here using the GCCUserData portion of the "API"
	**	node record passed in.
	*/
	if ((node_record->number_of_user_data_members != 0) &&
		(node_record->user_data_list != NULL) &&
		(rc == GCC_NO_ERROR))
	{
		DBG_SAVE_FILE_LINE
		pCRD->user_data_list = new CUserDataListContainer(
				node_record->number_of_user_data_members,
				node_record->user_data_list,
				&rc);
		if ((pCRD->user_data_list == NULL) || (rc != GCC_NO_ERROR))
		{
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	/*
	**	Now if no errors occured we replace the old record with the new
	**	record information created above.
	*/
	if (rc == GCC_NO_ERROR)
	{
		/*
		**	Save the node type and properties internally.  These will
		**	always exist.
		*/
		GetPDUNodeTypeAndProperties (
								node_record->node_type,
								node_record->node_properties,
								&pCRD->node_type,
								&pCRD->node_properties);

		pCRD->superior_node = m_uidSuperiorNode;

		// replace the old record with the new one
		DeleteRecord(node_id);
		m_RecordList2.Append(node_id, pCRD);

		//	Increment the instance number.
		m_nInstanceNumber++;
		m_fRosterChanged = TRUE;
	}

MyExit:

	if (GCC_NO_ERROR == rc)
	{
		//	Add an update to the PDU.
		rc = BuildRosterUpdateIndicationPDU(REPLACE_RECORD, node_id);
	}
	else
	{
		delete pCRD;
	}

	return (rc);
}


/*
 *	GCCError	DeleteRecord	()
 *
 *	Private Function Description:
 *		This routine is used to delete one of the records from the list of
 *		node records.  It only operates on the conference roster list.  It
 *		does not deal with any of the flags associated with a roster PDU or
 *		message such as: m_fNodesAdded and m_fNodesRemoved.
 *
 *	Formal Parameters:
 *		node_id			-		(i)	Node ID of node record to delete.
 *
 *	Return Value
 *		GCC_NO_ERROR			-	No error occured.
 *		GCC_INVALID_PARAMETER	-	Bad node id passed in.	
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
CONF_RECORD::CONF_RECORD(void)
:
	pwszNodeName(NULL),
	participant_name_list(NULL),
	pwszSiteInfo(NULL),
	network_address_list(NULL),
	poszAltNodeID(NULL),
	user_data_list(NULL),
	superior_node(0)
{
}

CONF_RECORD::~CONF_RECORD(void)
{
	/*
	 * If a node name exists, delete it from the Record.
	 */
	delete pwszNodeName;

	/*
	 * If a participants list exists, clear the list and then delete it
	 * from the Record.
	 */
	if (participant_name_list != NULL)
	{
		participant_name_list->DeleteList();
		delete participant_name_list;
	}

	/*
	 * If site information exists, delete it from the Record.
	 */
	delete pwszSiteInfo;

	/*
	 * If a network address list exists, delete it from the Record.
	 */
	if (NULL != network_address_list)
	{
	    network_address_list->Release();
	}

	/*
	 * If a user data list exists, delete it from the Record.
	 */
	if (NULL != user_data_list)
	{
	    user_data_list->Release();
	}
}

GCCError CConfRoster::DeleteRecord(UserID node_id)
{
	GCCError			rc;
	CONF_RECORD     	*lpRec;

	if (NULL != (lpRec = m_RecordList2.Remove(node_id)))
	{
		delete lpRec;
		rc = GCC_NO_ERROR;
	}
	else
	{
		rc = GCC_INVALID_PARAMETER;
	}

	return (rc);
}


/*
 *	void	ClearRecordList	()
 *
 *	Private Function Description:
 *		This routine is used to clear out the internal list of records which
 *		hold the conference roster information.  This routine is called upon
 *		destruction of this object or when a refresh occurs causing the entire
 *		record list to be rebuilt.
 *
 *	Formal Parameters:
 *		None.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConfRoster::ClearRecordList(void)
{
    CONF_RECORD *pRec;
    while (NULL != (pRec = m_RecordList2.Get()))
    {
        delete pRec;
    }
}



/*
 *	NodeType	GetNodeTypeAndProperties	()
 *
 *	Private Function Description:
 *		This routine is used to translate the node type and node properties
 *		from the "PDU" form into the "API" form.
 *
 *	Formal Parameters:
 *		pdu_node_type		-	(i)	This is the node type defined for the PDU.
 *		pdu_node_properties	-	(i)	This is the node properties defined for
 *									the PDU.
 *		node_type			-	(o)	This is a pointer to the GCCNodeType to
 *									be filled in by this routine.
 *		node_properties		-	(o)	This is a pointer to the GCCNodeProperties
 *									to be filled in by this routine.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConfRoster::GetNodeTypeAndProperties (
							NodeType			pdu_node_type,
							NodeProperties		pdu_node_properties,
							PGCCNodeType		node_type,
							PGCCNodeProperties	node_properties)
{
	/*
	 * First translate the node type.
	 */
	if (pdu_node_type == TERMINAL)
		*node_type = GCC_TERMINAL;
	else if (pdu_node_type == MCU)
		*node_type = GCC_MCU;
	else
		*node_type = GCC_MULTIPORT_TERMINAL;
	
	/*
	 * Next translate the node properties.
	 */
	if ((pdu_node_properties.device_is_peripheral)  &&
		(pdu_node_properties.device_is_manager == FALSE))
	{
		*node_properties = GCC_PERIPHERAL_DEVICE;
	}
	else if ((pdu_node_properties.device_is_peripheral == FALSE)  &&
		(pdu_node_properties.device_is_manager))
	{
		*node_properties = GCC_MANAGEMENT_DEVICE;
	}
	else if ((pdu_node_properties.device_is_peripheral)  &&
		(pdu_node_properties.device_is_manager))
	{
		*node_properties = GCC_PERIPHERAL_AND_MANAGEMENT_DEVICE;
	}
	else
		*node_properties = GCC_NEITHER_PERIPHERAL_NOR_MANAGEMENT;
}


/*
 *	void	GetPDUNodeTypeAndProperties	()
 *
 *	Private Function Description:
 *		This routine is used to translate the node type and node properties
 *		from the "API" form into the "PDU" form.
 *
 *	Formal Parameters:
 *		node_type			-	(i)	This is the GCC (or API) node type.
 *		node_properties		-	(i)	This is the GCC (or API) node properties
 *		pdu_node_type	   	-	(o)	This is a pointer to the PDU node type to
 *									be filled in by this routine.
 *		pdu_node_properties	-	(o)	This is a pointer to the PDU node properties
 *									to be filled in by this routine.
 *
 *	Return Value
 *		None.
 *
 *  Side Effects
 *		None.
 *
 *	Caveats
 *		None.
 */
void CConfRoster::GetPDUNodeTypeAndProperties (
							GCCNodeType			node_type,
							GCCNodeProperties	node_properties,
							PNodeType			pdu_node_type,
							PNodeProperties		pdu_node_properties)
{
	/*
	 * First translate node types.
	 */
	if (node_type == GCC_TERMINAL)
		*pdu_node_type = TERMINAL;
	else if (node_type == GCC_MCU)
		*pdu_node_type = MCU;
	else
		*pdu_node_type = MULTIPORT_TERMINAL;

	/*
	 * Next translate node properties.
	 */
	if (node_properties == GCC_PERIPHERAL_DEVICE)
	{
		pdu_node_properties->device_is_manager = FALSE;
		pdu_node_properties->device_is_peripheral = TRUE;
	}
	else if (node_properties == GCC_MANAGEMENT_DEVICE)
	{
		pdu_node_properties->device_is_manager = TRUE;
		pdu_node_properties->device_is_peripheral = FALSE;
	}
	else if (node_properties == GCC_PERIPHERAL_AND_MANAGEMENT_DEVICE)
	{
		pdu_node_properties->device_is_manager = TRUE;
		pdu_node_properties->device_is_peripheral = TRUE;
	}
	else
	{
		pdu_node_properties->device_is_manager = FALSE;
		pdu_node_properties->device_is_peripheral = FALSE;
	}
}


/*
 *	BOOL		Contains ()
 *
 *	Public Function Description:
 *		This routine is used to determine whether or not a record exists within
 *		the internal list corresponding to the given user ID.
 */


/*
 *	UINT		GetNumberOfApplicationRecords ()
 *
 *	Public Function Description:
 *		This routine is used to get the number of node records currently being
 *		maintained within this object's internal list.
 */


/*
 *	void		ResetConferenceRoster ()
 *
 *	Public Function Description:
 */
void CConfRoster::ResetConferenceRoster(void)
{
	m_fRosterChanged = FALSE;
	m_fNodesAdded = FALSE;
	m_fNodesRemoved = FALSE;
}


/*
 *	BOOL		HasRosterChanged ()
 *
 *	Public Function Description:
 */



/*
 *	GCCError	GetNodeSubTree ()
 *
 *	Public Function Description:
 *		This routine traverses the entire tree level-by-level starting at the
 *		root node and then progressively going down the tree.
 */
GCCError CConfRoster::GetNodeSubTree (
									UserID					uidRootNode,
									CUidList				*node_list)
{
	GCCError			rc = GCC_NO_ERROR;
	CUidList			high_level_list;
	UserID				uidSuperiorNode;
	CONF_RECORD     	*lpRec;
	UserID				uid;

	if (m_RecordList2.Find(uidRootNode))
	{
		/*
		**	First add the root node to the high level list to get every thing
		**	going.
		*/
		high_level_list.Append(uidRootNode);

		while (! high_level_list.IsEmpty())
		{
			uidSuperiorNode = high_level_list.Get();

			//	Append the high level node id to the node list passed in.
			node_list->Append(uidSuperiorNode);

			/*
			**	Iterate through the entire roster looking for the next
			**	level of dependent nodes.
			*/		
			m_RecordList2.Reset();
			while (NULL != (lpRec = m_RecordList2.Iterate(&uid)))
			{
				if (lpRec->superior_node == uidSuperiorNode)
                {
					high_level_list.Append(uid);
                }
			}
		}
	}
	else
    {
		rc = GCC_INVALID_PARAMETER;
    }

	return (rc);
}


void CParticipantNameList::DeleteList(void)
{
    LPWSTR pwszParticipantName;
    while (NULL != (pwszParticipantName = Get()))
    {
        delete pwszParticipantName;
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\conflist.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_GCCNC);
/*
 *	conflist.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the class CConfDescriptorListContainer.
 *		Instances of this class represent the Conference Descriptor list that is
 *		generated by a call to GCCConferenceQueryRequest.  This class hides most
 *		of the complexity associated with building this list.  It also handles
 *		building the set of conference descriptors used in the
 *		ConferenceQueryResponse PDU	and the conference descriptor list passed
 *		to the GCC interface.  This class is designed so that a CControlSAP
 *		object can use it to create	a GCC_CONFERENCE_QUERY_CONFIRM message by
 *		requesting a pointer to a list of Conference Descriptor pointers from
 *		it.  Objects of this type only live long enough to service a particular
 *		query request.  After a message	callback has returned or a PDU has been
 *		sent to MCS, the CConfDescriptorListContainer object is deleted.
 *
 *	Protected Instance Variables:
 *		m_ppGCCConfDescriptorList
 *			The list holding the conference descriptors in the API form.		
 *		m_pSetOfConfDescriptors	
 *			The list holding the conference descriptors in the PDU form.
 *		m_cDescriptors
 *			The number of descriptors in the list.
 *		m_pDescriptorListMemory
 *			The memory object used to hold the memory for the API list of
 *			conference descriptors.
 *		m_ConfDescriptorList
 *			The Rogue Wave list used to hold the descriptor data in the
 *			internal form.	
 *		m_pNetAddrListMemory		
 *			The memory object used to hold the memory for the network address
 *			list part of the API conference descriptor list.
 *		m_pNetAddrMemoryPointer
 *			A pointer used to keep track of where the network addresses for
 *			the API form of the descriptor list are written.	
 *
 *	Private Member Functions:
 *		GetConferenceDescriptor
 *			The routine used to fill in an API conference descriptor
 *			structure from an internal descriptor data structure.
 *
 *	Caveats:
 *		The set of conference descriptors uses pointers owned by the conferences
 *	 	pointed to by the passed in list.  Therefore, it is important not to
 *		use the set of descriptors held by this class after a conference is
 *		deleted.  At this point the set of descriptors is invalid.  Ideally,
 *		the decriptor set built by this class should be used immediately after
 *		construction.
 *
 *	Author:
 *		blp
 */

#include "ms_util.h"
#include "conflist.h"

CONF_DESCRIPTOR::CONF_DESCRIPTOR(void)
:
	pszNumericConfName(NULL),
	pwszTextConfName(NULL),
	pszConfModifier(NULL),
	pwszConfDescription(NULL),
	network_address_list(NULL)
{
}

CONF_DESCRIPTOR::~CONF_DESCRIPTOR(void)
{
	delete pszNumericConfName;
	delete pwszTextConfName;
	delete pszConfModifier;
	delete pwszConfDescription;
	if (NULL != network_address_list)
    {
        network_address_list->Release();
    }
}


/*
 *	CConfDescriptorListContainer ()
 *
 *	Public Function Description
 *		This is a constructor for the CConfDescriptorListContainer class.  It
 *		saves the memory manager which is passed in and initializes instance
 *		variables.
 */
CConfDescriptorListContainer::CConfDescriptorListContainer(void)
:
    CRefCount(MAKE_STAMP_ID('C','D','L','C')),
    m_ppGCCConfDescriptorList(NULL),
    m_pSetOfConfDescriptors(NULL),
    m_pDescriptorListMemory(NULL),
    m_pNetAddrListMemory(NULL),
    m_pNetAddrMemoryPointer(NULL),
    m_cDescriptors(0)
{
}

/*
 *	CConfDescriptorListContainer ()
 *
 *	Public Function Description
 *		This constructor builds a List of conference descriptors that can
 *		be passed on to the GCC interface.  This list is built from a set
 *		of conference descriptors which is part of a query response PDU.
 */
CConfDescriptorListContainer::CConfDescriptorListContainer(
							PSetOfConferenceDescriptors		conference_list,
							PGCCError						gcc_error)
:
    CRefCount(MAKE_STAMP_ID('C','D','L','C')),
    m_ppGCCConfDescriptorList(NULL),
    m_pSetOfConfDescriptors(NULL),
    m_pDescriptorListMemory(NULL),
    m_pNetAddrListMemory(NULL),
    m_pNetAddrMemoryPointer(NULL),
    m_cDescriptors(0)
{
	PSetOfConferenceDescriptors		descriptor_pdu;
	CONF_DESCRIPTOR                  *descriptor_data;
	GCCError						error_value;

	/*
	 * Initialize the return parameter and instance variables.
	 */
	*gcc_error = GCC_NO_ERROR;

	descriptor_pdu = conference_list;
	while (descriptor_pdu != NULL)
	{
		/*
		 * Allocate the structure used to hold internal data.
		 */
		DBG_SAVE_FILE_LINE
		descriptor_data = new CONF_DESCRIPTOR;
		if (descriptor_data == NULL)
		{
			*gcc_error = GCC_ALLOCATION_FAILURE;
			break;
		}

		/*
		 * Fill in the descriptor flags.
		 */
		descriptor_data->conference_is_locked = descriptor_pdu->value.conference_is_locked;
		descriptor_data->password_in_the_clear = descriptor_pdu->value.clear_password_required;

		/*
		 * Copy the numeric portion of the conference name.
		 */
		descriptor_data->pszNumericConfName = ::My_strdupA(descriptor_pdu->value.conference_name.numeric);

		/*
		 * Copy the text portion of the name if it exists.
		 */
		if (descriptor_pdu->value.conference_name.bit_mask &
												CONFERENCE_NAME_TEXT_PRESENT)
		{
			if (NULL == (descriptor_data->pwszTextConfName = ::My_strdupW2(
							descriptor_pdu->value.conference_name.conference_name_text.length,
							descriptor_pdu->value.conference_name.conference_name_text.value)))
			{
				*gcc_error = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == descriptor_data->pwszTextConfName);
		}

		/*
		 * Next copy the conference name modifier if it exists.
		 */
		if (descriptor_pdu->value.bit_mask & CONFERENCE_NAME_MODIFIER_PRESENT)
		{
			if (NULL == (descriptor_data->pszConfModifier = ::My_strdupA(
							descriptor_pdu->value.conference_name_modifier)))
			{
				*gcc_error = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == descriptor_data->pszConfModifier);
		}

		/*
		 * Next copy the conference description if it exists.
		 */
		if (descriptor_pdu->value.bit_mask & CONFERENCE_DESCRIPTION_PRESENT)
		{
			if (NULL == (descriptor_data->pwszConfDescription = ::My_strdupW2(
							descriptor_pdu->value.conference_description.length,
							descriptor_pdu->value.conference_description.value)))
			{
				*gcc_error = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == descriptor_data->pwszConfDescription);
		}

		/*
		 * Next copy the network address list if it exists.
		 */
		if (descriptor_pdu->value.bit_mask & DESCRIPTOR_NET_ADDRESS_PRESENT)
		{
			DBG_SAVE_FILE_LINE
			descriptor_data->network_address_list = new CNetAddrListContainer(
								descriptor_pdu->value.descriptor_net_address,
								&error_value);
								
			if ((descriptor_data->network_address_list == NULL) ||
					(error_value != GCC_NO_ERROR))
			{
				*gcc_error = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == descriptor_data->network_address_list);
		}

		/*
		 * If no error has occurred, set up the next pointer and add the data
		 * structure to the list of conference descriptor data.
		 */
		if (*gcc_error == GCC_NO_ERROR)
		{
			descriptor_pdu = descriptor_pdu->next;
			m_ConfDescriptorList.Append(descriptor_data);
		}
		else
		{
			delete descriptor_data;
			break;
		}
	}
}

/*
 *	~CConfDescriptorListContainer ()
 *
 *	Public Function Description
 *		This is the destructor for the CConfDescriptorListContainer class.  It is
 *		responsible for freeing up any resources allocated during the life of
 *		this object.
 */
CConfDescriptorListContainer::~CConfDescriptorListContainer(void)
{
	UINT						i;
	CONF_DESCRIPTOR             *lpConfDescData;

	if (m_pSetOfConfDescriptors != NULL)
		FreeConferenceDescriptorListPDU ();

	/*
	 * Free all resources allocated by this object by iterating through the
	 * internal list of decriptor data structures.
	 */
	m_ConfDescriptorList.Reset();
	while (NULL != (lpConfDescData = m_ConfDescriptorList.Iterate()))
	{
		delete lpConfDescData;
	}
	
	/*
	 * Free up any other allocated resources.
	 */
	if (m_pDescriptorListMemory != NULL)
	{
		for (i = 0; i < m_cDescriptors; i++)
		{
			delete m_ppGCCConfDescriptorList[i];
		}

		delete m_pDescriptorListMemory;
	}

	delete m_pNetAddrListMemory;
}

/*
 *	AddConferenceDescriptorToList ()
 *
 *	Public Function Description
 *		This routine is used to add a single new conference descriptor to the
 *		list of conference descriptors.
 */
GCCError CConfDescriptorListContainer::AddConferenceDescriptorToList(
									LPSTR				pszNumericConfName,
									LPWSTR				pwszConfTextName,
									LPSTR				pszConfModifier,
									BOOL				locked_conference,
									BOOL				password_in_the_clear,
									LPWSTR				pwszConfDescription,
									CNetAddrListContainer *network_address_list)
{
	GCCError            rc = GCC_NO_ERROR;
	CONF_DESCRIPTOR     *descriptor_data;

	/*
	 * If PDU data has been allocated, free it so that the next "GetPDU" call
	 * will result in a rebuild of the PDU data and will therefore include the
	 * data being added in this routine.
	 */
	if (m_pSetOfConfDescriptors != NULL)
		FreeConferenceDescriptorListPDU ();

	/*
	 * Next allocate the structure used to hold the data internally.
	 */
	DBG_SAVE_FILE_LINE
	descriptor_data = new CONF_DESCRIPTOR;
	if (descriptor_data != NULL)
	{
		/*
		 * Fill in the descriptor flags.
		 */
		descriptor_data->conference_is_locked = locked_conference;
		descriptor_data->password_in_the_clear = password_in_the_clear;

		/*
		 * Copy the numeric portion of the conference name.
		 */
		if (pszNumericConfName != NULL)
		{
			descriptor_data->pszNumericConfName = ::My_strdupA(pszNumericConfName);
		}
		else
		{
			ASSERT(NULL == descriptor_data->pszNumericConfName);
			rc = GCC_ALLOCATION_FAILURE;
		}

		/*
		 * Copy the text portion of the name if it exists
		 */
		if (pwszConfTextName != NULL)
		{
			if (NULL == (descriptor_data->pwszTextConfName =
											::My_strdupW(pwszConfTextName)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == descriptor_data->pwszTextConfName);
		}

		/*
		 * Next copy the conference name modifier if it exists.
		 */
		if (pszConfModifier != NULL)
		{
			if (NULL == (descriptor_data->pszConfModifier = ::My_strdupA(pszConfModifier)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == descriptor_data->pszConfModifier);
		}

		/*
		 * Next copy the conference description if it exists.
		 */
		if (pwszConfDescription != NULL)
		{
			if (NULL == (descriptor_data->pwszConfDescription =
									::My_strdupW(pwszConfDescription)))
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}
		else
		{
			ASSERT(NULL == descriptor_data->pwszConfDescription);
		}

		/*
		 * Next copy the network address list if it exists.
		 */
		if (network_address_list != NULL)
		{
			DBG_SAVE_FILE_LINE
			descriptor_data->network_address_list =
			        new CNetAddrListContainer(network_address_list, &rc);
			if (descriptor_data->network_address_list == NULL)
            {
				rc = GCC_ALLOCATION_FAILURE;
            }
		}
		else
		{
			ASSERT(NULL == descriptor_data->network_address_list);
		}
	}
	else
	{
		rc = GCC_ALLOCATION_FAILURE;
	}

	if (GCC_NO_ERROR == rc)
	{
		/*
		 * Add the structure to the descriptor list.
		 */
		m_ConfDescriptorList.Append(descriptor_data);
	}
	else
	{
		delete descriptor_data;
	}

	return rc;
}

/*
 *	GetConferenceDescriptorListPDU ()
 *
 *	Public Function Description
 *		This routine is used to retrieve the PDU form of the conference
 *		descriptor list which is a list of "SetOfConferenceDescriptors"
 *		structures.
 */
GCCError CConfDescriptorListContainer::GetConferenceDescriptorListPDU(
						PSetOfConferenceDescriptors	*  conference_list)
{
	GCCError						rc = GCC_NO_ERROR;
	PSetOfConferenceDescriptors		last_descriptor = NULL;
	PSetOfConferenceDescriptors		new_descriptor;
	CONF_DESCRIPTOR                 *descriptor_data;

	if (m_pSetOfConfDescriptors == NULL)
	{
		m_ConfDescriptorList.Reset();
		while (NULL != (descriptor_data = m_ConfDescriptorList.Iterate()))
		{
			/*
			 * First allocate the new descriptor.
			 */
			DBG_SAVE_FILE_LINE
			new_descriptor = new SetOfConferenceDescriptors;
			if (new_descriptor == NULL)
			{
				rc = GCC_ALLOCATION_FAILURE;
				break;
			}

			/*
			 * Next we add the new descriptor to the list..
			 */
			if (m_pSetOfConfDescriptors == NULL)
				m_pSetOfConfDescriptors = new_descriptor;
			else
				last_descriptor->next = new_descriptor;

			/*
			 * Set up the previous descriptor pointer.
			 */
			last_descriptor = new_descriptor;

			/*
			 * Now fill in the new descriptor with the passed in parameters.
			 */
			new_descriptor->next = NULL;
			new_descriptor->value.bit_mask = 0;

			new_descriptor->value.conference_is_locked =
										(ASN1bool_t)descriptor_data->conference_is_locked;

			new_descriptor->value.clear_password_required =
										(ASN1bool_t)descriptor_data->password_in_the_clear;

			/*
			 * Get the numeric conference name.
			 */
			new_descriptor->value.conference_name.bit_mask = 0;

			::lstrcpyA(new_descriptor->value.conference_name.numeric,
					descriptor_data->pszNumericConfName);

			/*
			 * Get the text conference name, if it exists.
			 */
			if (descriptor_data->pwszTextConfName != NULL)
			{
				new_descriptor->value.conference_name.bit_mask |= CONFERENCE_NAME_TEXT_PRESENT;
				new_descriptor->value.conference_name.conference_name_text.value =
						descriptor_data->pwszTextConfName;
				new_descriptor->value.conference_name.conference_name_text.length =
						::lstrlenW(descriptor_data->pwszTextConfName);
			}

			/*
			 * Check for a conference name modifier.
			 */
			if (descriptor_data->pszConfModifier != NULL)
			{
				new_descriptor->value.bit_mask |= CONFERENCE_NAME_MODIFIER_PRESENT;
				::lstrcpyA(new_descriptor->value.conference_name_modifier,
						descriptor_data->pszConfModifier);
			}

			/*
			 * Get the conference description if one exists.
			 */
			if (descriptor_data->pwszConfDescription != NULL)
			{
				new_descriptor->value.bit_mask |=CONFERENCE_DESCRIPTION_PRESENT;
				new_descriptor->value.conference_description.value =
							descriptor_data->pwszConfDescription;
				new_descriptor->value.conference_description.length =
							::lstrlenW(descriptor_data->pwszConfDescription);
			}

			/*
			 * Get the Network Address list if it exists.
			 */
			if (descriptor_data->network_address_list != NULL)
			{
				new_descriptor->value.bit_mask |=DESCRIPTOR_NET_ADDRESS_PRESENT;

				descriptor_data->network_address_list->
						GetNetworkAddressListPDU(&new_descriptor->value.
						descriptor_net_address);
			}
		}
	}

	*conference_list = (rc == GCC_NO_ERROR) ?
							m_pSetOfConfDescriptors :
							NULL;

	return rc;
}

/*
 *	FreeConferenceDescriptorListPDU ()
 *
 *	Public Function Description
 *		This routine is used to free up any resources allocated to hold the PDU
 *		form of the conference descriptor list.
 */
void CConfDescriptorListContainer::FreeConferenceDescriptorListPDU(void)
{
	PSetOfConferenceDescriptors		pCurr, pNext;
	CONF_DESCRIPTOR                  *lpConfDescData;

	/*
	 * Loop through the list of descriptors, deleting each element.
	 */
	for (pCurr = m_pSetOfConfDescriptors; NULL != pCurr; pCurr = pNext)
	{
		pNext = pCurr->next;
		delete pCurr;
	}

	/*
	 * Free the PDU data for any network address lists which may exist.
	 */
	m_ConfDescriptorList.Reset();
	while (NULL != (lpConfDescData = m_ConfDescriptorList.Iterate()))
	{
		if (NULL != lpConfDescData->network_address_list)
		{
			lpConfDescData->network_address_list->FreeNetworkAddressListPDU();
		}
	}

	m_pSetOfConfDescriptors = NULL;
}

/*
 *	LockConferenceDescriptorList ()
 *
 *	Public Function Description
 *		This routine is used to "lock" the API form of the conference descriptor
 *		list.  The lock count is incremented and the API form of the list
 *		created in preparation for a "GetConferenceDescriptorList" call used to
 *		retrieve the API form of the list.  The memory necessary to hold the
 *		API list is allocated by this routine.
 */
GCCError CConfDescriptorListContainer::LockConferenceDescriptorList(void)
{
	GCCError			rc = GCC_NO_ERROR;
	UINT				i;
	UINT				network_address_data_length = 0;
	CONF_DESCRIPTOR     *lpConfDescData;

	if (Lock() == 1)
	{
		m_cDescriptors = m_ConfDescriptorList.GetCount();
		if (m_cDescriptors != 0)
		{
			/*
			 * Allocate space to hold pointers to all descriptors in the
			 * conference.
			 */
		    DBG_SAVE_FILE_LINE
			m_pDescriptorListMemory = new BYTE[m_cDescriptors * sizeof(PGCCConferenceDescriptor)];
			if (m_pDescriptorListMemory != NULL)
			{
				m_ppGCCConfDescriptorList = (PGCCConferenceDescriptor *) m_pDescriptorListMemory;

				/*
				 * Set up an iterator for the internal descriptor list.  Iterate
				 * through the list, locking each network address list object
				 * and adding up the amount of memory needed to hold all of the
				 * data for the network address lists.  Allocate the necessary
				 * amount of memory and save a pointer to the memory.
				 */
				m_ConfDescriptorList.Reset();
				while (NULL != (lpConfDescData = m_ConfDescriptorList.Iterate()))
				{
					if (lpConfDescData->network_address_list != NULL)
					{
						network_address_data_length += lpConfDescData->network_address_list->LockNetworkAddressList();
					}
				}

				if (network_address_data_length != 0)
				{
				    DBG_SAVE_FILE_LINE
					m_pNetAddrListMemory = new BYTE[network_address_data_length];
					if (m_pNetAddrListMemory != NULL)
					{
						m_pNetAddrMemoryPointer = m_pNetAddrListMemory;
					}
					else
					{
						rc = GCC_ALLOCATION_FAILURE;
					}
				}

				if (rc == GCC_NO_ERROR)
				{
					m_ConfDescriptorList.Reset();
					for (i = 0; i < m_cDescriptors; i++)
					{
						lpConfDescData = m_ConfDescriptorList.Iterate();
                        ASSERT(NULL != lpConfDescData);
						/*
						 * Allocate the API structure used at the interface.
						 * Call the routine which converts the descriptor data
						 * from its internal form into API form.
						 */
						DBG_SAVE_FILE_LINE
						m_ppGCCConfDescriptorList[i] = new GCCConferenceDescriptor;
						if (m_ppGCCConfDescriptorList[i] != NULL)
						{
							GetConferenceDescriptor(m_ppGCCConfDescriptorList[i], lpConfDescData);
						}
						else
						{
							rc = GCC_ALLOCATION_FAILURE;
						}
					}
				}
			}
			else
			{
				rc = GCC_ALLOCATION_FAILURE;
			}
		}

    	if (rc != GCC_NO_ERROR)
    	{
    	    Unlock();
    	}
	}

	return rc;
}

/*
 *	GetConferenceDescriptorList ()
 *
 *	Public Function Description
 *		This routine is used to retrieve the API form of the conference
 *		descriptor list.
 */
void CConfDescriptorListContainer::GetConferenceDescriptorList(
						PGCCConferenceDescriptor **		conference_list,
						UINT					 *		number_of_descriptors)
{
	/*
	 * Check to see if the object has been locked.  Fill in the API descriptor
	 * list if it has, report an error if it has not.
	 */
	if (GetLockCount() > 0)
	{
		*conference_list = m_ppGCCConfDescriptorList;
		*number_of_descriptors = (USHORT) m_cDescriptors;
	}
	else
	{
		ERROR_OUT(("CConfDescriptorListContainer::GetConferenceDescriptorList: Error, data not locked"));
		*conference_list = NULL;
		*number_of_descriptors = 0;
	}
}


/*
 *	UnLockConferenceDescriptorList ()
 *
 *	Public Function Description
 *		This routine is used to "unlock" the "API" data for this object.  This
 *		results in the lock count for this object being decremented.  When the
 *		lock count transitions from 1 to 0, a check is made to determine
 *		whether the object has been freed through a call to
 *		FreeConferenceDescriptorList.  If so, the object will automatically
 *		delete itself.  If not, any resources allocated to hold the API form
 *		of the decriptor list are freed.
 */
void CConfDescriptorListContainer::UnLockConferenceDescriptorList(void)
{
	UINT i;

	/*
	 * If the lock count is zero, delete the object if it is "freed".  If the
	 * lock count is zero but the obect is not "freed", free any resources
	 * allocated to hold the API data.
	 */
	if (Unlock(FALSE) == 0)
	{
		CONF_DESCRIPTOR *lpConfDescData;

		if (m_pDescriptorListMemory != NULL)
		{
			for (i = 0; i < m_cDescriptors; i++)
			{
				delete m_ppGCCConfDescriptorList[i];
			}

			delete m_pDescriptorListMemory;
			m_pDescriptorListMemory = NULL;
			m_ppGCCConfDescriptorList = NULL;
		}

		/*
		 * Free the memory for the network address lists if it exists.
		 * Iterate through the internal descriptor list, unlocking any
		 * network address list objects which exist.
		 */
		if (m_pNetAddrListMemory != NULL)
		{
			delete m_pNetAddrListMemory;
			m_pNetAddrListMemory = NULL;
			m_pNetAddrMemoryPointer = NULL;
		}

		m_ConfDescriptorList.Reset();
		while (NULL != (lpConfDescData = m_ConfDescriptorList.Iterate()))
		{
			if (lpConfDescData->network_address_list != NULL)
			{
				lpConfDescData->network_address_list->UnLockNetworkAddressList ();
			}
		}
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}

/*
 *	void	GetConferenceDescriptor (
 *					PGCCConferenceDescriptor	gcc_descriptor,
 *					CONF_DESCRIPTOR              *descriptor_data)
 *
 *	Private member function of CConfDescriptorListContainer.
 *
 *	Function Description:
 *		This routine is used to fill in an API conference descriptor structure
 *		from an internal descriptor data structure.
 *
 *	Formal Parameters:
 *		gcc_descriptor		(o)	The API descriptor structure to fill in.
 *		descriptor_data		(i) The internal structure holding the data which is
 *									to be copied into the API structure.
 *
 *	Return Value:
 *		None.
 *
 *  Side Effects:
 *		None.
 *
 *	Caveats:
 *		None.
 */
void CConfDescriptorListContainer::GetConferenceDescriptor(
					PGCCConferenceDescriptor	gcc_descriptor,
					CONF_DESCRIPTOR              *descriptor_data)
{
	UINT network_address_data_length;

	/*
	 * Fill in the descriptor flags.
	 */
	gcc_descriptor->conference_is_locked =
										descriptor_data->conference_is_locked;
	gcc_descriptor->password_in_the_clear_required =
										descriptor_data->password_in_the_clear;

	/*
	 * Get the numeric portion of the conference name.
	 */
	gcc_descriptor->conference_name.numeric_string =
						(GCCNumericString) descriptor_data->pszNumericConfName;

	/*
	 * Get the text portion of the conference name, if it exists.
	 */
	gcc_descriptor->conference_name.text_string = descriptor_data->pwszTextConfName;

	/*
	 * Get the conference modifier.
	 */
	if (descriptor_data->pszConfModifier != NULL)
	{
		gcc_descriptor->conference_name_modifier =
						(GCCNumericString) descriptor_data->pszConfModifier;
	}
	else
		gcc_descriptor->conference_name_modifier = NULL;


	/*
	 * Get the conference description.
	 */
	gcc_descriptor->conference_descriptor = descriptor_data->pwszConfDescription;

	/*
	 * Fill in the network address list	if it exists.  Otherwise, set the
	 * number of address to zero and the structure pointer to NULL.
	 */
	if (descriptor_data->network_address_list != NULL)
	{
		network_address_data_length = descriptor_data->network_address_list->
				GetNetworkAddressListAPI(
						&gcc_descriptor->number_of_network_addresses,
						&gcc_descriptor->network_address_list,
						m_pNetAddrMemoryPointer);

		/*
		 * Move the network address list memory pointer past the data written
		 * into memory by the "Get" call.  The data for the next network address
		 * list will then be written there on subsequent "Get" calls.
		 */
		m_pNetAddrMemoryPointer += network_address_data_length;
	}
	else
	{
		gcc_descriptor->number_of_network_addresses = 0;
		gcc_descriptor->network_address_list = NULL;
	}
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\crostmgr.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_CONF_ROSTER);
/*
 *	crostmgr.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Conference Roster
 *		Manager Class.
 *
 *		SEE THE INTERFACE FILE FOR A MORE DETAILED EXPLANATION OF THIS CLASS
 *
 *	Private Instance Variable:
 *		m_pGlobalConfRoster
 *			A pointer to the global conference roster.
 *		m_pLocalConfRoster
 *			A pointer to the local conference roster.
 *		m_fTopProvider
 *			Flag indicating if this is a Top Provider node.
 *		m_pMcsUserObject
 *			Pointer to the MCS user object associated with this conference.
 *		m_pConf
 *			Pointer to object that will receive all the owner callbacks.
 *
 *	Caveats:
 *		None
 *
 *	Author:
 *		blp
 */

#include "crostmsg.h"
#include "crostmgr.h"
#include "conf.h"


/*
 *	CConfRosterMgr	()
 *
 *	Public Function Description
 *		This is the conference roster constructor. It is responsible for
 *		initializing all the instance variables used by this class.
 */
CConfRosterMgr::CConfRosterMgr(
								PMCSUser				user_object,
								CConf					*pConf,
								BOOL					top_provider,
								PGCCError				rc)
:
    CRefCount(MAKE_STAMP_ID('C','R','M','r')),
	m_fTopProvider(top_provider),
	m_pMcsUserObject(user_object),
	m_pLocalConfRoster(NULL),
	m_pGlobalConfRoster(NULL),
	m_pConf(pConf)
{
	BOOL		maintain_pdu_buffer;
	
	DebugEntry(CConfRosterMgr::CConfRosterMgr);
	
	*rc =	GCC_NO_ERROR;

	//	Here we determine if the roster needs to maintain PDU data
	maintain_pdu_buffer = m_fTopProvider;

	//	Create the global conference roster.
	DBG_SAVE_FILE_LINE
	m_pGlobalConfRoster = new CConfRoster(	m_pMcsUserObject->GetTopNodeID(),
											m_pMcsUserObject->GetParentNodeID(),
											m_pMcsUserObject->GetMyNodeID(),
											m_fTopProvider,
											FALSE,			//	Is not Local
											maintain_pdu_buffer);
	if (m_pGlobalConfRoster != NULL)
	{
		if (m_fTopProvider == FALSE)
		{
			//	Create the local conference roster.
			DBG_SAVE_FILE_LINE
			m_pLocalConfRoster = new CConfRoster(
											m_pMcsUserObject->GetTopNodeID(),
											m_pMcsUserObject->GetParentNodeID(),
											m_pMcsUserObject->GetMyNodeID(),
											m_fTopProvider,
											TRUE,	//	Is Local
											TRUE	// Maintain PDU buffer
											);
											
			if (m_pLocalConfRoster == NULL)
				*rc = GCC_ALLOCATION_FAILURE;
		}
	}
	else
		*rc = GCC_ALLOCATION_FAILURE;

	DebugExitVOID(CConfRosterMgr::CConfRosterMgr);
}


/*
 *	~CConfRosterMgr	()
 *
 *	Public Function Description
 *		This is the conference roster destructor. It is responsible for
 *		freeing up all memory allocated by this class.
 */
CConfRosterMgr::~CConfRosterMgr(void)
{
	if (NULL != m_pGlobalConfRoster)
    {
        m_pGlobalConfRoster->Release();
    }

    if (NULL != m_pLocalConfRoster)
    {
        m_pLocalConfRoster->Release();
    }
}


/*
 *	GCCError	AddNodeRecord	()
 *
 *	Public Function Description
 *		This routine is used to add a new record to the conference roster.
 *		This class makes the decision about which roster the new record goes
 *		into (global or local).
 */
GCCError CConfRosterMgr::AddNodeRecord(PGCCNodeRecord node_record)
{
	GCCError				rc = GCC_NO_ERROR;
	CConfRoster				*conference_roster;
	
	DebugEntry(CConfRosterMgr::AddNodeRecord);

	/*
	**	First determinate the right conference roster. For non Top Providers
	**	the global roster will be updated when the refresh comes back in.
	*/
	conference_roster = m_fTopProvider ? m_pGlobalConfRoster : m_pLocalConfRoster;
    	
	//	Add the top providers conference record to the roster.
	rc = conference_roster->AddRecord(node_record, 
									m_pMcsUserObject->GetMyNodeID());

	DebugExitINT(CConfRosterMgr::AddNodeRecord, rc);

	return rc;
}


/*
 *	GCCError		UpdateNodeRecord	()
 *
 *	Public Function Description
 *		This routine is used to replace a record in the conference roster with
 *		a new record. This class makes the decision about which roster the new 
 *		record affects (global or local).
 */
GCCError CConfRosterMgr::UpdateNodeRecord(PGCCNodeRecord node_record)
{
	GCCError			rc = GCC_NO_ERROR;
	CConfRoster			*conference_roster;
	
	DebugEntry(CConfRosterMgr::UpdateNodeRecord);

	/*
	**	First determinate the right conference roster. For non Top Providers
	**	the global roster will be updated when the refresh comes back in.
	*/
	conference_roster = m_fTopProvider ? m_pGlobalConfRoster : m_pLocalConfRoster;

	rc = conference_roster->ReplaceRecord(node_record, m_pMcsUserObject->GetMyNodeID());
	
	DebugExitINT(CConfRosterMgr::UpdateNodeRecord, rc);

	return rc;
}


/*
 *	GCCError	RemoveUserReference	()
 *
 *	Public Function Description
 *		This routine removes the record associated with the specified node
 *		id.
 */
GCCError CConfRosterMgr::RemoveUserReference(UserID deteched_node_id)
{
	GCCError			rc = GCC_NO_ERROR;
	CConfRoster			*conference_roster;
	
	DebugEntry(CConfRosterMgr::RemoveUserReference);

	/*
	**	First determinate the right conference roster. For non Top Providers
	**	the global roster will be updated when the refresh comes back in.
	*/
	conference_roster = m_fTopProvider ? m_pGlobalConfRoster : m_pLocalConfRoster;

	rc = conference_roster->RemoveUserReference (deteched_node_id);
		
	DebugExitINT(CConfRosterMgr::RemoveUserReference, rc);
   
    return rc;
}


/*
 *	GCCError		RosterUpdateIndication	()
 *
 *	Public Function Description
 *		This routine is responsible for processing the decoded PDU data.
 *		It essentially passes the PDU on along to the appropriate roster.
 */
GCCError CConfRosterMgr::RosterUpdateIndication(
									PGCCPDU				roster_update,
									UserID				sender_id)
{
	GCCError			rc = GCC_NO_ERROR;
	CConfRoster			*conference_roster;

	DebugEntry(CConfRosterMgr::RosterUpdateIndication);

	/*
	**	Determine if this update came from the Top Provider or a node
	**	below this node.  This dictates which conference roster will
	**	process the PDU.
	*/
	conference_roster = (m_fTopProvider || (sender_id == m_pMcsUserObject->GetTopNodeID())) ?
						m_pGlobalConfRoster :
						m_pLocalConfRoster;
	
	rc = conference_roster->ProcessRosterUpdateIndicationPDU (
	    		&roster_update->u.indication.u.roster_update_indication.
	    			node_information,
	    		sender_id);

	DebugExitINT(CConfRosterMgr::RosterUpdateIndication, rc);

	return rc;
}


/*
 *	GCCError	FlushRosterUpdateIndication	()
 *
 *	Public Function Description
 *		This routine is used to access any PDU data that might currently be
 *		queued inside the conference roster.  It also is responsible for 
 *		flushing a roster update message if necessary.
 */
GCCError CConfRosterMgr::FlushRosterUpdateIndication(PNodeInformation node_information)
{
	GCCError					rc = GCC_NO_ERROR;
	CConfRoster					*conference_roster;
	CConfRosterMsg				*roster_message;
	
	DebugEntry(CConfRosterMgr::FlushRosterUpdateIndication);

	//	First determine the conference roster that is affected.
	conference_roster = m_fTopProvider ? m_pGlobalConfRoster : m_pLocalConfRoster;

	//	Now add the node information to the PDU structure.
	conference_roster->FlushRosterUpdateIndicationPDU (node_information);

	/*
	**	Next we must deliver any roster update messages that need to be
	**	delivered.
	*/
	if (m_pGlobalConfRoster->HasRosterChanged ())
	{
		DBG_SAVE_FILE_LINE
		roster_message = new CConfRosterMsg(m_pGlobalConfRoster);
		if (roster_message != NULL)
		{
			m_pConf->ConfRosterReportIndication(roster_message);
			roster_message->Release();
		}
		else
		{
		    ERROR_OUT(("CConfRosterMgr::FlushRosterUpdateIndication: can't create CConfRosterMsg"));
			rc = GCC_ALLOCATION_FAILURE;
		}
	}

	/*
	**	Now perform the necessary cleanup which includes resetting the
	**	conference rosters to their neutral state.
	*/
	m_pGlobalConfRoster->ResetConferenceRoster ();

	if (m_fTopProvider == FALSE)
		m_pLocalConfRoster->ResetConferenceRoster ();

	DebugExitINT(CConfRosterMgr::FlushRosterUpdateIndication, rc);
	return rc;
}


/*
 *	GCCError	GetFullRosterRefreshPDU	()
 *
 *	Public Function Description
 *		This routine is used to access a full conference roster refresh.
 */
GCCError CConfRosterMgr::GetFullRosterRefreshPDU(PNodeInformation node_information)
{
	GCCError	rc;
	
	DebugEntry(CConfRosterMgr::GetFullRosterRefreshPDU);

	if (m_fTopProvider)
	{
		//	Call on the global roster to build a full refresh PDU.
		rc = m_pGlobalConfRoster->BuildFullRefreshPDU ();
		
		if (rc == GCC_NO_ERROR)
		{
			/*
			**	Now flush the full refresh PDU. Note that this will also
			**	deliver any queued roster update messages to the local
			**	SAPs that may be queued.
			*/
			rc = FlushRosterUpdateIndication (node_information);
		}
	}
	else
		rc = GCC_INVALID_PARAMETER;

	DebugExitINT(CConfRosterMgr::GetFullRosterRefreshPDU, rc);

	return rc;
}


/*
 *	BOOL		Contains	()
 *
 *	Public Function Description
 *		This routine is used to determine if the specified record exists in
 *		the conference roster.
 */


/*
 *	CConfRoster	*GetConferenceRosterPointer	()
 *
 *	Public Function Description
 *		This routine is used to access a pointer to the conference roster
 *		managed by this conference roster manager.  The global roster
 *		is always returned by this routine.
 */


/*
 *	USHORT	GetNumberOfConferenceRecords	()
 *
 *	Public Function Description
 *		This routine returns the total number of conference roster records
 *		contained in the global conference roster record list.
 */

BOOL CConfRosterMgr::
IsThisNodeParticipant ( GCCNodeID nid )
{
    return ((NULL != m_pGlobalConfRoster) ? 
                        m_pGlobalConfRoster->Contains(nid) :
                        FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\crostmsg.cpp ===
#include "precomp.h"
#include "fsdiag.h"
DEBUG_FILEZONE(ZONE_T120_CONF_ROSTER);
/* 
 *	crostmsg.cpp
 *
 *	Copyright (c) 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the Conference Roster Message 
 *		Class. This	class maintains a conference roster, and is able
 *		to "serialize" the roster into a block of memory.  It utilizes a 
 *		"Lock - UnLock" facility to ensure that the roster memory remains
 *		valid until all interested parties are through using the object.
 *
 *	Protected Instance Variables:
 *
 *	Private Member Functions:
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		jbo/blp
 */

#include "crostmsg.h"

/*
 *	CConfRosterMsg	()
 *
 *	Public Function Description
 *		This constructor is used to create a Conference Roster Message object.
 *		The pointer to the conference roster will be stored.
 */
CConfRosterMsg::CConfRosterMsg(CConfRoster *conference_roster)
:
    CRefCount(MAKE_STAMP_ID('A','R','M','g')),
	m_pMemoryBlock(NULL),
	m_pConfRoster(conference_roster)
{
}

/*
 *	~CConfRosterMsg	()
 *
 *	Public Function Description:
 *		The destructor for the CConfRosterMsg class will clean up
 *		any memory allocated during the life of the object.
 */
CConfRosterMsg::~CConfRosterMsg(void)
{
    delete m_pMemoryBlock;
}

/*
 *	GCCError	LockConferenceRosterMessage	()
 *
 *	Public Function Description
 *		This routine is used to lock an CConfRosterMsg.  The memory
 *		necessary to hold the list of rosters is allocated and the rosters are
 *		"serialized" into the allocated memory block.
 */
GCCError CConfRosterMsg::LockConferenceRosterMessage(void)
{  
	GCCError						rc = GCC_NO_ERROR;
	UINT							roster_data_length;
	PGCCConferenceRoster			temporary_roster;

	/*
	 * Return an error if this object has been freed or if the internal
	 * conference roster pointer is invalid.
	 */
	if (m_pConfRoster == NULL)
		return (GCC_ALLOCATION_FAILURE);

	/*
	 * If this is the first time this routine is called, determine the size of 
	 * the memory required to hold the conference roster and go ahead
	 * and serialize the data.  Otherwise, just increment the lock count.
	 */
	if (Lock() == 1)
	{
		/*
		 * Determine the size of the memory block needed to hold the roster.
		 */
		roster_data_length = m_pConfRoster->LockConferenceRoster();

		/*
		 * Allocate space to hold the conference roster and all associated data.
		 * FIX: Switch critical flag to TRUE when Sharded memory manager is
		 * set up to support it.
		 */
		DBG_SAVE_FILE_LINE
		if (NULL != (m_pMemoryBlock = new BYTE[roster_data_length]))
		{
			/*
			 * Retrieve all of the data for the conference roster.
			 */
			m_pConfRoster->GetConfRoster(&temporary_roster, m_pMemoryBlock);
		}
		else
        {
            ERROR_OUT(("CConfRosterMsg::LockConferenceRosterMessage: "
                        "can't allocate memory, size=%u", (UINT) roster_data_length));
			rc = GCC_ALLOCATION_FAILURE;
        }
	
		/*
		 * Since we do not need the conference roster anymore it is
		 * OK to unlock it here.
		 */		
		m_pConfRoster->UnLockConferenceRoster ();
	}

    if (GCC_NO_ERROR != rc)
    {
        Unlock();
    }

    return rc;
}

/*
 *	GCCError	GetConferenceRosterMessage()
 *
 *	Public Function Description
 *		This routine is used to obtain a pointer to the Conference Roster
 *		memory block used to deliver messages.  This routine should not be 
 *		called before LockConferenceRosterMessage is called. 
 */
GCCError CConfRosterMsg::GetConferenceRosterMessage(LPBYTE *ppRosterData)
{
	GCCError	rc = GCC_ALLOCATION_FAILURE;
	
	if (GetLockCount() > 0)
	{
		if (m_pMemoryBlock != NULL)
		{
			*ppRosterData = m_pMemoryBlock;
			rc = GCC_NO_ERROR;
		}
		else
		{
			ERROR_OUT(("CConfRosterMsg::GetConferenceRosterMessage: no data"));
			ASSERT(GCC_ALLOCATION_FAILURE == rc);
		}
	}
	else
	{
		ERROR_OUT(("CConfRosterMsg::GetConferenceRosterMessage: data not locked"));
		ASSERT(GCC_ALLOCATION_FAILURE == rc);
	}

	return rc;
}

/*
 *	void	UnLockConferenceRosterMessage	()
 *
 *	Public Function Description
 *		This member function is responsible for unlocking the data locked for 
 *		the "API" conference roster after the lock count goes to zero.
 */
void CConfRosterMsg::UnLockConferenceRosterMessage(void)
{
	if (Unlock(FALSE) == 0)
	{
		/*
		 * Free up the memory block allocated to hold the roster
		 */
		delete m_pMemoryBlock;
		m_pMemoryBlock = NULL;
	}

    // we have to call Release() because we used Unlock(FALSE)
    Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\cuserdta.cpp ===
#include "precomp.h"

// CP: DCL's header redefines this:
#ifdef CLEAR_FLAG
#undef CLEAR_FLAG
#endif // CLEAR_FLAG

#include <cuserdta.hpp>
#include <oprahcom.h>
#include <inodecnt.h>


static const BYTE H221IDGUID[5] =
{
    H221GUIDKEY0,
    H221GUIDKEY1,
    H221GUIDKEY2,
    H221GUIDKEY3,
    H221GUIDKEY4
};



CNCUserDataList::
CNCUserDataList(void)
:
    CList(),
    m_apUserData(NULL)
{
}


CNCUserDataList::
~CNCUserDataList(void)
{
    delete[] m_apUserData;

    GCCUserData *pUserData;
    Reset();
    while (NULL != (pUserData = Iterate()))
    {
        delete pUserData->octet_string->value;
        delete pUserData->octet_string;
        delete pUserData;
    }
}


HRESULT CNCUserDataList::
AddUserData
(
    GUID            *pGUID,
    UINT            nData,
    LPVOID          pData
)
{
    ASSERT(pGUID);
    ASSERT(!nData || pData);

    LPBYTE              pWork;
    UINT                nDataPlusHeader = nData+sizeof(GUID);
    GCCUserData *       pUserData;
    LPOSTR              pOctetString;

    // If there is already an entry in the list
    // for the GUID, then delete it.

    DeleteEntry(pGUID);

    // Make sure the size is reasonable
    if (nDataPlusHeader <= 0xffff)
    {
        // Now go and add the new entry to the list.
        DBG_SAVE_FILE_LINE
        if (NULL != (pUserData = new GCCUserData))
        {
            DBG_SAVE_FILE_LINE
            if (NULL != (pOctetString = new OSTR))
            {
                DBG_SAVE_FILE_LINE
                if (NULL != (pWork = new unsigned char[nDataPlusHeader]))
                {
                    pUserData->octet_string = pOctetString;
                    pUserData->key.key_type = GCC_H221_NONSTANDARD_KEY;
                    pUserData->key.h221_non_standard_id.length = sizeof(H221IDGUID);
                    pUserData->key.h221_non_standard_id.value = (LPBYTE) &H221IDGUID[0];
                    pOctetString->value = pWork;
                    pOctetString->length = nDataPlusHeader;
                    *(GUID *)pWork = *pGUID;
                    pWork += sizeof(GUID);
                    ::CopyMemory(pWork, pData, nData);
                    Append(pUserData);
                    return NO_ERROR;
                }
                delete pOctetString;
            }
            delete pUserData;
        }
    }

    return UI_RC_OUT_OF_MEMORY;
}

void CNCUserDataList::
DeleteEntry ( GUID * pGUID )
{
    GCCUserData     *pUserData;

    Reset();
    while (NULL != (pUserData = Iterate()))
    {
        if (0 == ::memcmp(pUserData->octet_string->value, pGUID, sizeof(GUID)))
        {
            Remove(pUserData);
            delete pUserData->octet_string->value;
            delete pUserData->octet_string;
            delete pUserData;
            return;
        }
    }
}


GCCUserData *  CNCUserDataList::
GetUserGUIDData (GUID * pGUID)
{
	GCCUserData   *pUserData;

	Reset();
	while (NULL != (pUserData = Iterate()))
	{
		if (0 == ::memcmp(pUserData->octet_string->value, pGUID, sizeof(GUID)))
		{
			return pUserData;
		}
	}
	return NULL;
}

HRESULT CNCUserDataList::
GetUserDataList
(
    UINT            *pnRecords,
    GCCUserData     ***papUserData
)
{
    GCCUserData **  pUserDataArrayTemp;
    HRESULT         hr = NO_ERROR;

    delete[] m_apUserData;
    m_apUserData = NULL;

    if (! IsEmpty())
    {
        // Allocate memory.
        DBG_SAVE_FILE_LINE
        if (NULL != (m_apUserData = new GCCUserData * [GetCount()]))
        {
            // Fill in array.
            GCCUserData *pUserData;
            pUserDataArrayTemp = m_apUserData;
            Reset();
            while (NULL != (pUserData = Iterate()))
            {
                *(pUserDataArrayTemp++) = pUserData;
            }
        }
        else
        {
            hr = UI_RC_OUT_OF_MEMORY;
        }
    }

    *pnRecords = GetCount();
    *papUserData = m_apUserData;
    return hr;
}


HRESULT NMINTERNAL
GetUserData
(
    UINT            nRecords,
    GCCUserData **  ppUserData,
    GUID *          pGUID,
    UINT *          pnData, 
    LPVOID *        ppData
)
{
    LPBYTE pData;
    UINT nLength;

    while (nRecords--)
    {

        // Check that the H.221 OID is for GUIDS.

        if (((*ppUserData)->key.key_type == GCC_H221_NONSTANDARD_KEY) &&
            ((*ppUserData)->key.h221_non_standard_id.length == sizeof(H221IDGUID)) &&
            (memcmp((*ppUserData)->key.h221_non_standard_id.value,
                    H221IDGUID,
                    sizeof(H221IDGUID)) == 0) ||
            ((*ppUserData)->key.key_type == GCC_OBJECT_KEY) &&
            ((*ppUserData)->key.object_id.long_string_length == 3) &&
            ((*ppUserData)->key.object_id.long_string[0] == 2) &&
            ((*ppUserData)->key.object_id.long_string[1] == 5) &&
            ((*ppUserData)->key.object_id.long_string[2] == 8))
        {
            nLength = (*ppUserData)->octet_string->length;
            pData = (*ppUserData)->octet_string->value;
            if (nLength >= sizeof(GUID))
            {
                if (CompareGuid((GUID *)pData, pGUID) == 0)
                {
                    nLength -= sizeof(GUID);
                    if (nLength)
                    {
                        pData += sizeof(GUID);
                    }
                    else
                    {
                        pData = NULL;
                    }
                    if (pnData)
                    {
                        *pnData = nLength;
                    }
                    if (ppData)
                    {
                        *ppData = (PVOID)pData;
                    }
                    return NO_ERROR;
                }
            }
        }
        ppUserData++;
    }
    return UI_RC_NO_SUCH_USER_DATA;
}


// Create an H.221 application key with a guid
VOID CreateH221AppKeyFromGuid(LPBYTE lpb, GUID * pguid)
{
	CopyMemory(lpb, H221IDGUID, sizeof(H221IDGUID));
	CopyMemory(lpb + sizeof(H221IDGUID), pguid, sizeof(GUID));
}

// Return TRUE if the guid string was extracted from the key
BOOL GetGuidFromH221AppKey(LPTSTR pszGuid, LPOSTR pOctStr)
{
	ASSERT(NULL != pszGuid);
	ASSERT(NULL != pOctStr);

	if (pOctStr->length < (sizeof(H221IDGUID) + sizeof(GUID)) )
		return FALSE;
	if (memcmp(pOctStr->value, H221IDGUID, sizeof(H221IDGUID)) != 0)
		return FALSE;
	
	GuidToSz((GUID *) (((LPBYTE) pOctStr->value)+ sizeof(H221IDGUID)), pszGuid);
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\cuserdta.hpp ===
/***************************************************************************/
/**                  Microsoft Windows                                    **/
/**            Copyright(c) Microsoft Corp., 1995-1996                    **/
/***************************************************************************/


/****************************************************************************

cuserdta.hpp

June 96		LenS

T120 user data/object ID infrastructure.

****************************************************************************/

#ifndef	USERDATA_INC
#define	USERDATA_INC

#include <nmutil.h>
#include <oblist.h>
#include <confdbg.h>
#include <confguid.h>

// H.221 utility functions
VOID CreateH221AppKeyFromGuid(LPBYTE lpb, GUID * pguid);
BOOL GetGuidFromH221AppKey(LPTSTR pszGuid, LPOSTR pOctStr);

// GetUserData extracts user data from a T120 event message.
// The caller passes in the T120 data structures and the GUID
// associated with the user data, and receives back a pointer to
// the buffer containing the user data. 
// This buffer will be invalidated by the user returning from
// the event. If the user data consisted just
// of the GUID, then *pnData == NULL and *ppData == NULL.

HRESULT NMINTERNAL GetUserData(UINT     nRecords,
                               GCCUserData **     ppUserData,
                               GUID *             pGUID,
                               UINT *   pnData, 
                               PVOID *            ppData);

/*************************************************************************

    NAME:		USER_DATA

    SYNOPSIS:	This class is used internally by the Node Controller to
                contruct a user data list. Each entry is GUID based with
                binary data following that is uninterpreted by the 
                Node Controller and T120.

    INTERFACE:	USER_DATA(object ID)
					Construct the container for the list.

				~USER_DATA_GUID()
					Destructor automatically releases data allocated.

				AddUserData()
					Add some user data to the list, keyed by a unique
                    GUID. If the GUID is already in the list, then its
                    data will be overwritten.

				GetUserData()
					Used in conjunction with GetNumUserData() to put the
                    user data into a T120 request.

                GetNumUserData()
					See GetUserData().

    PARENT:		None

    USES:		None

    CAVEATS:	1) The user data binary information must fit in an unsigned
                short field, less the bytes for the GUID header and byte count.

    NOTES:		None.

    HISTORY:
		06/04/96	lens	Created

**************************************************************************/

class CNCUserDataList : private CList
{
public:

    CNCUserDataList(void);
    ~CNCUserDataList(void);

    HRESULT AddUserData(GUID * pGUID, UINT nData, PVOID pData);
    HRESULT GetUserDataList(UINT * pnRecords, GCCUserData *** pppUserData);
    GCCUserData **GetUserData(void);
	GCCUserData *GetUserGUIDData(GUID * pGUID);
    void DeleteEntry(GUID * pGUID);

private:

    BOOL Append(GCCUserData* pData) { return CList::Append((LPVOID) pData); }
    BOOL Remove(GCCUserData* pData) { return CList::Remove((LPVOID) pData); }
    GCCUserData* Iterate(void) { return (GCCUserData*) CList::Iterate(); }

    GCCUserData **  m_apUserData;
};

#endif /* ndef USERDATA_INC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\datapkt.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 * datapkt.cpp
 *
 *	Copyright (c) 1997 by Microsoft Corporation, Redmond, WA
 *
 * Abstract:
 *		This is the implementation file for the MCS data packet class.  The data packet
 *		class is responsible for encoding and decoding the PDUs, as well as
 *		maintaining the necessary pointers to the encoded and decoded data.
 *		However, they differ from normal packets, in that there is only one copy of the 
 *		user data in the encoded and decoded buffers.  Only the encoded buffer has the user data, 
 *		while the decoded one maintains a pointer to the data.
 *		Instances of this class will be created both by User and Connection
 *		objects as PDUs flow through MCS.
 *
 * Private Instance Variables:
 *		ulDataOffset
 *			Maintains the offset of the starting byte of the user data
 *			from the start of the encoded buffer.
 *
 * Caveats:
 *		None.
 *
 * Author:
 *		Christos Tsollis
 */

#include "omcscode.h"

/*
 *	This is a global variable that has a pointer to the one MCS coder that
 *	is instantiated by the MCS Controller.  Most objects know in advance 
 *	whether they need to use the MCS or the GCC coder, so, they do not need
 *	this pointer in their constructors.
 */
extern CMCSCoder	*g_MCSCoder;

/*
 *	The following array contains a template for the X.224 data header.
 *	The 5 of the 7 bytes that it initializes are actually sent to the
 *	wire.  Bytes 3 and 4 will be set to contain the size of the PDU.
 *	The array is only used when we encode a data PDU.
 */
extern UChar g_X224Header[];

/*
 *	These are globals that correspond to the static variables declared as part
 *	of this class.
 */
PVoid *		DataPacket::Object_Array;
long		DataPacket::Object_Count;

/*
 *	operator new
 *
 *	Public
 *
 *	Functional Description:
 *		This is the "new" operator for the DataPacket class.
 *
 */
 PVoid DataPacket::operator new (size_t)
 {	
 		PVoid pNewObject;

	TRACE_OUT(("DataPacket::DataPacket: %d pre-allocated data packet objects are left.",
				Object_Count));
	if (Object_Count > 0) {
		pNewObject = Object_Array[--Object_Count];
	}
	else {
		// Allocate an object from the heap
		DBG_SAVE_FILE_LINE
 		pNewObject = (PVoid) new BYTE[sizeof(DataPacket)];
	 	if (pNewObject != NULL) 
 			((PDataPacket) pNewObject)->fPreAlloc = FALSE;
 	}
 	return (pNewObject);
 } 

/*
 *	operator delete
 *
 *	Public
 *
 *	Functional Description:
 *		This is the "delete" operator for the Packet class.
 *
 */
 Void DataPacket::operator delete (PVoid object)
 {
 	if (((PDataPacket) object)->fPreAlloc) {
 		Object_Array[Object_Count++] = object;
 	}
 	else
 		delete [] ((BYTE *) object);
 }

/*
 *	The AllocateMemoryPool static function pre-allocates DataPacket 
 *	objects for use by MCS.
 */
Void DataPacket::AllocateMemoryPool (long maximum_objects)
{
		ULong		memory_size;
		PUChar		object_ptr;
		long		object_count;
		PVoid		*pStack;

	/*
	 *	Calculate the amount of memory needed to hold the specified number of
	 *	entries.  This memory block will contains two different types of
	 *	information:
	 *
	 *	1.	A stack of available objects (each entry is a PVoid).  The "new"
	 *		operator pops the top entry off the stack.  The "delete" operator
	 *		pushes one back on.
	 *	2.	The objects themselves, sequentially in memory.
	 *
	 *	That is why this calculation adds the size of a PVoid to the size of
	 *	an instance of the class, and multiplies by the specified number.  This
	 *	allows enough room for both sections.
	 */
	memory_size = ((sizeof (PVoid) + sizeof (DataPacket)) * maximum_objects);

	/*
	 *	Allocate the memory required.
	 */
	DBG_SAVE_FILE_LINE
	Object_Array = (PVoid *) new BYTE[memory_size];

	if (Object_Array != NULL)
	{
		Object_Count = maximum_objects;

		/*
		 *	Set a pointer to the first object, which immediately follows the
		 *	stack of available objects.
		 */
		object_ptr = (PUChar) Object_Array + (sizeof (PVoid) * maximum_objects);

		/*
		 *	This loop initializes the stack of available objects to contain all
		 *	objects, in sequential order.
		 */
		for (pStack = Object_Array, object_count = 0; object_count < maximum_objects; 
			 object_count++)
		{
			*pStack++ = (PVoid) object_ptr;
			((PDataPacket) object_ptr)->fPreAlloc = TRUE;		// this object is pre-allocated
			object_ptr += sizeof (DataPacket);
		}
	}
	else
	{
		/*
		 *	The memory allocation failed.  Set the static variable indicating
		 *	that there are no objects left.  This way, ALL attempted allocations
		 *	will fail.
		 */
		Object_Count = 0;
	}
}

/*
 *	The FreeMemoryPool static function frees the pre-allocates DataPacket 
 *	objects. It also deletes the critical section
 *	that controls access to these objects and the memory-tracking 
 *	mechanisms in T.120
 */
Void DataPacket::FreeMemoryPool ()
{
	if (Object_Array != NULL)
		delete [] ((BYTE *) Object_Array);
};
							
/*
 *	DataPacket ()
 *
 *	Public
 *
 *	Functional Description:
 *		This constructor is used to create an outgoing data packet. 
 *		The packet is created by the user object, when the request
 *		for a send data or uniform send data comes through the user
 *		portal.
 */
 //outgoing data packets.
DataPacket::DataPacket (ASN1choice_t		choice,
						PUChar				data_ptr,
						ULong				data_length,
						UINT				channel_id,
						Priority			priority,
						Segmentation		segmentation,
						UINT				initiator_id,
						SendDataFlags		flags,
						PMemory				memory,
						PPacketError		packet_error)
:
	SimplePacket(TRUE),
	m_fIncoming (FALSE),
	m_Memory (memory),
	m_EncodedDataBroken (FALSE),
	m_nMessageType(0)
{
	*packet_error = PACKET_NO_ERROR;
	
	// Fill in the decoded domain PDU fields.
	m_DecodedPDU.choice = choice;
	m_DecodedPDU.u.send_data_request.initiator = (UserID) initiator_id;
	m_DecodedPDU.u.send_data_request.channel_id = (ChannelID) channel_id;
	m_DecodedPDU.u.send_data_request.data_priority = (PDUPriority) priority;
	m_DecodedPDU.u.send_data_request.segmentation = (PDUSegmentation) segmentation;
	m_DecodedPDU.u.send_data_request.user_data.length = data_length;
	m_DecodedPDU.u.send_data_request.user_data.value = (ASN1octet_t *) data_ptr;

	/*
	 *	Now, encode the data PDU. Note that no error/allocation should
	 *	occur during the Encode operation.
	 */
	if (flags == APP_ALLOCATION) {
		ASSERT (m_Memory == NULL);
		// We will need to memcpy the data
		m_EncodedPDU = NULL;
	}
	else {
		// No need for data memcpy!
		ASSERT (m_Memory != NULL);
		
		/*
		 *	We need to set the m_EncodedPDU ptr.  If this is the 1st packet
		 *	of the data request, the space is already allocated.  Otherwise,
		 *	we need to allocate it.
		 */
		if (segmentation & SEGMENTATION_BEGIN) {
			m_EncodedPDU = data_ptr - MAXIMUM_PROTOCOL_OVERHEAD;
		}
		else {
			DBG_SAVE_FILE_LINE
			m_EncodedPDU = Allocate (MAXIMUM_PROTOCOL_OVERHEAD);
			if (NULL != m_EncodedPDU) {
				m_EncodedDataBroken = TRUE;
			}
			else {
				WARNING_OUT (("DataPacket::DataPacket: Failed to allocate MCS encoded headers."));
				*packet_error = PACKET_MALLOC_FAILURE;
			}
		}
		/*
		 *	We lock the big buffer that contains the data included in this packet.
		 */
		LockMemory (m_Memory);
	}

	if (*packet_error == PACKET_NO_ERROR) {
		if (g_MCSCoder->Encode ((LPVOID) &m_DecodedPDU, DOMAIN_MCS_PDU, 
							PACKED_ENCODING_RULES, &m_EncodedPDU,
							&Encoded_Data_Length)) {
			if (m_Memory == NULL) {
				m_Memory = GetMemoryObjectFromEncData(m_EncodedPDU);
			}
		}
		else {
			WARNING_OUT (("DataPacket::DataPacket: Encode failed. Possibly, allocation error."));
			*packet_error = PACKET_MALLOC_FAILURE;
		}
	}
}

/*
 *	Packet ()
 *
 *	Public
 *
 *	Functional Description:
 *		This version of the constructor is used to create a DataPacket object
 *		for incomming PDUs when the packet is to be created from an encoded
 *		data stream containing the PDU data to be decoded.
 *
 *	Input parameters:
 *		pTransportData: This structure contains the following fields:
 *			user_data: Pointer to space containing the real user data + 7 initial
 *						bytes for X.224 headers.
 *			user_data_length: Length of the user data including the 7-byte X.224
 *						header.
 *			buffer: The beginning of the buffer containing the user_data ptr. These
 *					2 ptrs can be different because of security.  This is the buffer
 *					to be freed after we no longer need the data.
 *			buffer_length: size of "buffer" space.  It's only used for accounting 
 *					purposes.  RECV_PRIORITY space is limited.
 *		fPacketDirectionUp: Direction of the data pkt in MCS domain.
 */
// incoming packets
DataPacket::DataPacket(PTransportData	pTransportData,
						BOOL			fPacketDirectionUp)
:
	SimplePacket(fPacketDirectionUp),
	m_fIncoming (TRUE),
	m_Memory (pTransportData->memory),
	m_EncodedDataBroken (FALSE),
	m_nMessageType(0)
{
	m_EncodedPDU = (LPBYTE) pTransportData->user_data;
	Encoded_Data_Length = (UINT) pTransportData->user_data_length;
	
	// take care of the X.224 header
	memcpy (m_EncodedPDU, g_X224Header, PROTOCOL_OVERHEAD_X224);
	AddRFCSize (m_EncodedPDU, Encoded_Data_Length);

	// Now, we can decode the PDU
	g_MCSCoder->Decode (m_EncodedPDU + PROTOCOL_OVERHEAD_X224, 
						Encoded_Data_Length - PROTOCOL_OVERHEAD_X224, 
						DOMAIN_MCS_PDU, PACKED_ENCODING_RULES, 
						(LPVOID *) &m_DecodedPDU, NULL);

	TRACE_OUT (("DataPacket::DataPacket: incoming data PDU packet was created successfully. Encoded size: %d", 
				Encoded_Data_Length - PROTOCOL_OVERHEAD_X224));
}

/*
 *	~DataPacket ()
 *
 *	Public
 *
 *	Functional Description:
 *		Destructor for the DataPacket class.  The destructor ensures that all 
 *		resources that have been allocated are freed.
 */
DataPacket::~DataPacket(void)
{
	if (m_EncodedPDU != NULL) {
		UnlockMemory (m_Memory);
		if (m_EncodedDataBroken) {
			// Free the MCS and X.224 header buffer.
			Free (m_EncodedPDU);
		}
	}
}

/*
 *	Equivalent ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function returns TRUE if the 2 packets belong to the same
 *		original SendData request (normal or uniform), and FALSE, otherwise.
 */
BOOL DataPacket::Equivalent (PDataPacket packet)
{
	ASSERT (m_DecodedPDU.u.send_data_request.segmentation == SEGMENTATION_END);
	ASSERT ((packet->m_DecodedPDU.u.send_data_request.segmentation & SEGMENTATION_END) == 0);

	return ((m_DecodedPDU.u.send_data_request.initiator == packet->m_DecodedPDU.u.send_data_request.initiator) &&
		(m_DecodedPDU.u.send_data_request.channel_id == packet->m_DecodedPDU.u.send_data_request.channel_id) &&
		(m_DecodedPDU.u.send_data_request.data_priority == packet->m_DecodedPDU.u.send_data_request.data_priority) &&
		(m_DecodedPDU.choice == packet->m_DecodedPDU.choice));
}
								
/*
 *	IsDataPacket ()
 *
 *	Public
 *
 *	Functional Description:
 *		This function returns whether this is a data packet (it is).
 */
BOOL DataPacket::IsDataPacket(void)
{
	return (TRUE);
}

/*
 *	SetDirection ()
 *
 *	Public
 *
 *	Functional Description:
 *		If the DataPacket object is oriented differently than desired
 *		by the caller of this method, then the packet coder is called to
 *		reverse the direction of the PDU.
 */
Void DataPacket::SetDirection (DBBoolean	packet_direction_up)
{	
	/*
	 * If the packet's encoded data is oriented differently from the desired
	 * direction, call the packet coder's ReverseDirection method and
	 * reverse the packet's direction indicator.
	 */
	if (packet_direction_up != Packet_Direction_Up)
	{
		/*
		 * Reverse the direction of the PDU.
		 */
		g_MCSCoder->ReverseDirection (m_EncodedPDU);                            
		/*
		 * The packet coder has reversed the direction of the PDU.  Set
		 * the Packet_Direction_Up flag to indicate the new state.
		 */
		Packet_Direction_Up = packet_direction_up;
	}
}

/*
 *	GetDecodedData ()
 *
 *	Public
 *
 *	Functional Description:
 *		The GetDecodedData method returns a pointer to the decoded data
 *		buffer.  If the packet does not have decoded data the Decode method is
 *		called.
 */
PVoid DataPacket::GetDecodedData ()
{		
	return ((PVoid) &m_DecodedPDU);
}                         

/*
 *	GetPDUType ()
 *
 *	Public
 *
 *	Functional Description:
 *		The GetPDUType method returns the PDU type for the data packet.
 *		For such a packet, the value is always 
 */
int	DataPacket::GetPDUType ()
{		
	return (DOMAIN_MCS_PDU);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\t120\mst120\domain.cpp ===
#include "precomp.h"
DEBUG_FILEZONE(ZONE_T120_MCSNC);
/*
 *	domain.cpp
 *
 *	Copyright (c) 1993 - 1995 by DataBeam Corporation, Lexington, KY
 *
 *	Abstract:
 *		This is the implementation file for the domain class.  The domain
 *		class encapsulates a single instance of a domain information base.
 *		This class include all code necessary to modify and act upon that
 *		information base.  Almost all activity into and out of objects of
 *		this class is in the form of MCS commands.  These commands are
 *		implemented as virtual member functions that are inherited from its
 *		base class CommandTarget.  These commands are essentially the same
 *		as the Protocol Data Units (PDUs) defined in T.125.
 *
 *		This class inherits from CommandTarget, which is where the virtual
 *		member functions for each command is defined.  All commands that are
 *		handled by this class are overridden by it.  Life for a domain object
 *		consists of receiving these commands and responding by transmitting
 *		these commands.  A Domain object has no need for its own "thread" of
 *		execution.
 *
 *		Instances of the domain class maintain an information base that is
 *		used to determine how to respond to these commands.  The commands are
 *		not only routed according to the state of the information base, but also
 *		act to change the information base.  When two MCS providers are
 *		connected, the domain objects within them become logically linked.  This
 *		means that they exchange these commands in such a manner as to guarantee
 *		the MCS services for which the providers are responsible.
 *
 *		When a domain object is first instantiated, its information base is
 *		empty.  That is, it has no user attachments, no MCS connections, no
 *		channels, no tokens, and no queued requests.  As the domain object
 *		processes commands, the information base takes shape, and all subsequent
 *		activity follows that shape.
 *
 *		By necessity, there is a lot of complex code in this module.  This is to
 *		allow for all the timing problems that can occur in a distributed
 *		network, such as MCS provides for.  In order to reduce the complexity
 *		as much as possible, this class does NOT worry about certains things,
 *		as follows:
 *
 *		The Domain class does NOT include code to perform any kind of flow
 *		control.  When a send data command comes in to a domain, it is sent out
 *		to any attachment that is to receive it.  It is assumed that any
 *		buffering and flow control is handled by the attachments.
 *
 *		For the most part the domain class does NOT distinguish between user
 *		attachments and MCS connections.  To the domain, they are merely
 *		referred to as "attachments".  MCS connections can be either upward or
 *		downward attachments.  User attachments can only be downward
 *		attachments.  In the case where a user detaches and the domain needs to
 *		know if the whole attachment is gone or just one user, it can check an
 *		entry in its attachment dictionary to determine the type.  Most of the
 *		time it does not care.  Most confirms and indications are routed to user
 *		attachments in exactly the same way they are routed to MCS connections.
 *
 *		Domain objects do not worry about memory management.  They merely pass
 *		packet objects from place to place.  They NEVER look at the contents
 *		of the packet objects.  It is assumed that the attachments have
 *		allocated memory for the user data that is being passed around.
 *
 *		Where possible, behavior that is specific to channels and tokens has
 *		been relegated to those classes.  It is necessary for the domain to
 *		handle channel and token behavior for IDs that do not exist.
 *
 *	Private Instance Variables:
 *		Merge_State
 *			This is current merge state that the domain is in.  These states
 *			are detailed in "domain.h".
 *		Outstanding_Merge_Requests
 *			This is a counter showing the number of outstanding merge requests.
 *			The domain object uses this to know when an in-process merge is
 *			complete.
 *		Number_Of_Users
 *			This is the number of users in the domain.
 *		Number_Of_Channels
 *			This is the number of channels in the domain.
 *		Number_Of_Tokens
 *			This is the number of tokens in the domain.
 *		Domain_Parameters
 *			This is a structure that contains the currently negotiated domain
 *			parameters.  These parameters are used to validate requests, such
 *			as the adding of a new user.
 *		Domain_Parameters_Locked
 *			This is a boolean flag that indicates whether or not the domain
 *			parameters have been locked into place yet.  This locking will
 *			occur when the domain object accepts its first MCS connection.
 *		m_pConnToTopProvider
 *			This is a pointer to the attachment that represents the link to the
 *			top provider.  Note that this provider may be several hops away
 *			from the top provider, so this really just points in the direction
 *			of the top provider.  If this pointer is NULL, this THIS is the
 *			top provider.
 *		m_AttachmentList
 *			This is a list of the downward attachments that this domain is
 *			aware of.  Remeber that this list can contain any combination of
 *			user attachments and MCS connections.  They are treated equally
 *			for most things.
 *		m_AttachUserQueue
 *			This is a list of outstanding attach user requests.  It is necessary
 *			to remember these requests so that they can answered in the same
 *			order in which they arrived.
 *		m_MergeQueue
 *			During a merge operation, this queue is used to remember how to
 *			route merge confirms back to their originators.  The assumption is
 *			made that an upward provider will always respond to merge requests
 *			in the same order that they were received in (a valid assumption
 *			for our implementation).  Also note that this implementation
 *			currently only merges one resource type at a time, so only one queue
 *			is necessary.  For example, user IDs are merged, then static
 *			channels, and so on.
 *		m_ChannelList2
 *			This is a list of channel objects that correspond to active channels
 *			within this domain.  When a channel object exists, the domain lets
 *			it handle all channel related activity (such as approving who can
 *			join a channel).
 *		m_TokenList2
 *			This is a list of token objects that correspond to active tokens
 *			within this domain.  When a token object exists, the domain lets it
 *			handle all token related activity (such as approving who can inhibit
 *			the token).
 *		m_nDomainHeight
 *			This instance variable contains the height of the domain from the
 *			point-of-view of this provider.  If there are two layers of
 *			providers below this one, then the height will be two.
 *		m_DomainHeightList2
 *			This is a list of domain heights that were registered from all
 *			downward attachments.  This allows the current provider to
 *			automatically update domain height when a downward attachment is
 *			lost.
 *		Random_Channel_Generator
 *			This object is used by this domain to generate random channel IDs.
 *
 *	Private Member Functions:
 *		LockDomainParameters
 *			This member function is used to change the values of the locally
 *			maintained domain parameters structure.  Passing NULL to it causes
 *			it to set a default set of parameters.  The second parameter allows
 *			the caller to specify whether or not these new parameters are
 *			"locked" into the domain (meaning that they cannot change since they
 *			have been locked in by acceptance of the first connection).
 *		AllocateDynamicChannel
 *			This routine randomly selects a channel ID from the dynamic range.
 *		ValidateUserID
 *			This routine checks to see if the specified user is in the sub-tree
 *			of this domain.  It can optionally check to see if the user is at
 *			a specific attachment in the sub-tree.
 *		PurgeDomain
 *			This routine purges the entire domain.  This means terminating all
 *			attachments, and freeing up all resources.  This results in
 *			returning the domain to its initialized state.
 *		DeleteAttachment
 *			This routine deletes a specified attachment and frees up all
 *			resources associated with that attachment.
 *		DeleteUser
 *			This routine deletes a user from the domain.  This takes care of
 *			deleting the attachment too if this were a locally attach user.
 *		DeleteChannel
 *			This routine deletes a specific channel from the information base.
 *		DeleteToken
 *			This routine deletes a specific token from the information base.
 *		ReclaimResources
 *			This routine iterates through both the channel list and the token
 *			list, asking each if is still valid (and removing those that are
 *			not).  This allows for automatic "garbage collection" when users
 *			or attachments are lost.
 *		MergeInformationBase
 *			This routine issues the appropriate merge requests to a pending
 *			top provider during a domain merger operation.  It is also a state
 *			machine in that it remembers what has already been merged, so that
 *			the next time it is called, it can merge the next set of resources.
 *		SetMergeState
 *			This routine sets the merge state of the object, and if necessary,
 *			issues a MergeDomainIndication to all downward attachments.
 *		AddChannel
 *			This routine is used to add a new channel to the current channel
 *			list during a merge operation.
 *		AddToken
 *			This routine is used to add a new token to the current token list
 *			during a merge operation.
 *		CalculateDomainHeight
 *			This routine calculates the height of the current domain, and takes
 *			appropriate action if the height limit has been exceeded.
 *
 *	Caveats:
 *		None.
 *
 *	Author:
 *		James P. Galvin, Jr.
 */

#include "plgxprt.h"

/*
 *	External Interfaces
 */


/*
 *	These macros are used when requesting a random dynamic channel ID.
 */
#define	DYNAMIC_CHANNEL_LOW_EXTENT		1001
#define	DYNAMIC_CHANNEL_HIGH_EXTENT		65535L

/*
 *	These two static structure are used by all instances of the domain class
 *	as the minimum and maximum supported values for the domain parameters.
 */
static	DomainParameters	Static_Minimum_Domain_Parameters =
{
	MINIMUM_MAXIMUM_CHANNELS,
	MINIMUM_MAXIMUM_USERS,
	MINIMUM_MAXIMUM_TOKENS,
	MINIMUM_NUMBER_OF_PRIORITIES,
	MINIMUM_MINIMUM_THROUGHPUT,
	MINIMUM_MAXIMUM_DOMAIN_HEIGHT,
	MINIMUM_MAXIMUM_PDU_SIZE,
	MINIMUM_PROTOCOL_VERSION
};

static	DomainParameters	Static_Maximum_Domain_Parameters =
{
	(UShort) MAXIMUM_MAXIMUM_CHANNELS,
	(UShort) MAXIMUM_MAXIMUM_USERS,
	(UShort) MAXIMUM_MAXIMUM_TOKENS,
	MAXIMUM_NUMBER_OF_PRIORITIES,
	MAXIMUM_MINIMUM_THROUGHPUT,
	MAXIMUM_MAXIMUM_DOMAIN_HEIGHT,
	MAXIMUM_MAXIMUM_PDU_SIZE,
	MAXIMUM_PROTOCOL_VERSION
};

/*
 *	This is now set to 0 to indicate that this provider does not perform
 *	any type of throughput enforcement.
 */
#define	DEFAULT_THROUGHPUT_ENFORCEMENT_INTERVAL			0

/*
 *	These macros define the number of buckets to used for each of the hash
 *	dictionaries maintained by this class.
 */
#define	CHANNEL_LIST_NUMBER_OF_BUCKETS                  16


/*
 *	Domain ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the constructor for the domain class.  It merely initailizes
 *		all instance variables to indicate an "empty" state.  It also sets
 *		the initial state of the domain parameters array.
 */
Domain::Domain()
:
    m_AttachmentList(),
    m_ChannelList2(CHANNEL_LIST_NUMBER_OF_BUCKETS),
    m_TokenList2(),
    m_DomainHeightList2(),
    m_pConnToTopProvider(NULL),
    Merge_State(MERGE_INACTIVE),
    Outstanding_Merge_Requests(0),
    Number_Of_Users(0),
    Number_Of_Channels(0),
    Number_Of_Tokens(0),
    m_nDomainHeight(0)
{
	/*
	 *	Set the domain parameters to their default values.
	 */
	LockDomainParameters (NULL, FALSE);
}

/*
 *	~Domain ()
 *
 *	Public
 *
 *	Functional Description:
 *		This is the destructor for the domain class.  All it does is purge the
 *		entire domain, which means to return it to its initial state (all
 *		attachments are broken).
 */
Domain::~Domain ()
{
	PurgeDomain (REASON_USER_REQUESTED);
}

/*
 *	BOOL    IsTopProvider ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine returns TRUE if this is the top provider, and FALSE
 *		otherwise.
 */

/*
 *	Void	GetDomainParameters ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine returns the currently active minimum and maximum domain
 *		parameter values (which will be different depending on whether or not
 *		the domain parameters have been locked yet).
 */
Void	Domain::GetDomainParameters (
				PDomainParameters	domain_parameters,
				PDomainParameters	min_domain_parameters,
				PDomainParameters	max_domain_parameters)
{
	/*
	 *	Load the currently in-use set of domain parameters.
	 */
	if (domain_parameters != NULL)
		*domain_parameters = Domain_Parameters;

	/*
	 *	See if domain parameters are already locked in for this domain.
	 */
	if (Domain_Parameters_Locked)
	{
		/*
		 *	The domain parameters for this domain have already been locked
		 *	during the creation of a previous connection.  Return those values
		 *	as both the minimum and maximum values (no deviation will be
		 *	permitted).
		 */
		if (min_domain_parameters != NULL)
			*min_domain_parameters = Domain_Parameters;
		if (max_domain_parameters != NULL)
			*max_domain_parameters = Domain_Parameters;
	}
	else
	{
		/*
		 *	Domain parameters have not yet been locked.  Therefore, return the
		 *	minimum and maximum values imposed by this implementation.
		 */
		if (min_domain_parameters != NULL)
			*min_domain_parameters = Static_Minimum_Domain_Parameters;
		if (max_domain_parameters != NULL)
			*max_domain_parameters = Static_Maximum_Domain_Parameters;
	}
}

/*
 *	Void	BindConnAttmnt ()
 *
 *	Public
 *
 *	Functional Description:
 *		This routine allows an attachment to bind to the domain.  It takes all
 *		actions appropriate to the addition of a new attachment (upward or
 *		downward).
 */
Void	Domain::BindConnAttmnt (
				PConnection 		pOrigConn,
				BOOL    			upward_connection,
				PDomainParameters	domain_parameters)
{
	CAttachment        *pAtt;
	PUser               pUser;
	PChannel			channel;
	PToken				token;

	/*
	 *	Check the hierarchical direction of the requested attachment.
	 */
	if (upward_connection)
	{
		/*
		 *	This is to be an upward connection.  We must now check to make
		 *	sure that we don't already have an upward connection.
		 */
		if (NULL == m_pConnToTopProvider)
		{
			/*
			 *	This attachment is the new Top Provider.
			 */
			TRACE_OUT(("Domain::BindConnAttmnt: accepting upward attachment"));
			m_pConnToTopProvider = pOrigConn;

			/*
			 *	Tell all channel objects who the new Top Provider is.
			 */
			m_ChannelList2.Reset();
			while (NULL != (channel = m_ChannelList2.Iterate()))
			{
				channel->SetTopProvider(m_pConnToTopProvider);
			}

			/*
			 *	Tell all token objects who the new Top Provider is.
			 */
			m_TokenList2.Reset();
			while (NULL != (token = m_TokenList2.Iterate()))
			{
				token->SetTopProvider(m_pConnToTopProvider);
			}

			/*
			 *	If the domain parameters have not yet been locked, then lock
			 *	these into place.
			 */
			if (Domain_Parameters_Locked == FALSE)
			{
				TRACE_OUT(("Domain::BindConnAttmnt: locking domain parameters"));
				LockDomainParameters (domain_parameters, TRUE);

				/*
				 *	Send a SetDomainParameters to each downward attachment.
				 *	This will allow those objects to adjust their construction
				 *	of send data PDUs to conform to the arbitrated maximum PDU
				 *	size.
				 */
				m_AttachmentList.Reset();
				while (NULL != (pUser = m_AttachmentList.IterateUser()))
				{
					pUser->SetDomainParameters(&Domain_Parameters);
				}
			}

			/*
			 *	Since we have bound to a provider above us, it is necessary to
			 *	inform that provider of our height in the domain (otherwise
			 *	the new Top Provider would have no way of knowing what the
			 *	total height of the domain is).  This is done by issuing an
			 *	erect domain request upward.
			 */
			m_pConnToTopProvider->ErectDomainRequest(m_nDomainHeight, DEFAULT_THROUGHPUT_ENFORCEMENT_INTERVAL);

			/*
			 *	Now that this provider has become the former top provider of
			 *	a lower domain, it is necessary to issue a plumb domain
			 *	indication to all downward attachments.  The primary reason
			 *	for this is to assure that there are no cycles in the domain.
			 */
			m_AttachmentList.Reset();
			while (NULL != (pAtt = m_AttachmentList.Iterate()))
			{
				pAtt->PlumbDomainIndication(Domain_Parameters.max_height);
			}

			/*
			 *	We now have a new top provider, which means that we must begin
			 *	an information base merger.
			 */
			MergeInformationBase ();
		}
		else
		{
			/*
			 *	We already have an upward connection (or one pending).
			 *	Therefore, this attachment must be rejected.
			 */
			ERROR_OUT(("Domain::BindConnAttmnt: domain not hierarchical"));
			pOrigConn->DisconnectProviderUltimatum(REASON_PROVIDER_INITIATED);
		}
	}
	else
	{
		/*
		 *	This is to be a downward connection.  We must now check to see if
		 *	we already have a record of the specified connection.
		 */
		if (! m_AttachmentList.FindConn(pOrigConn))
		{
			/*
			 *	This does represent a new downward connection.  So put it into
			 *	the attachment list.
			 */
			TRACE_OUT(("Domain::BindConnAttmnt: accepting downward attachment"));
			m_AttachmentList.AppendConn(pOrigConn);

			/*
			 *	If the domain parameters have not yet been locked, then lock
			 *	these into place.
			 */
			if (Domain_Parameters_Locked == FALSE)
			{
				TRACE_OUT(("Domain::BindConnAttmnt: locking domain parameters"));
				LockDomainParameters (domain_parameters, TRUE);

				/*
				 *	Send a SetDomainParameters to each downward attachment.
				 *	This will allow those objects to adjust their construction
				 *	of send data PDUs to conform to the arbitrated maximum PDU
				 *	size.
				 */
				m_AttachmentList.Reset();
				while (NULL != (pUser = m_AttachmentList.IterateUser()))
				{
					pUser->SetDomainParameters(&Domain_Parameters);
				}
			}
		}
		else
		{
			/*
			 *	The attachment is already listed in the attachment list, so
			 *	print an error and ignore the request.
			 */
			ERROR_OUT(("Domain::BindConnAttmnt: attachment already exists"));
		}
	}
}

/*
 *	Void	PlumbDomainIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function originates at a hgher provider and travels downward
 *		in the domain.  Each provider examines the height limit, and disconnects
 *		if it is zero.  If not, then the indication is forwarded downward.
 */
Void	Domain::PlumbDomainIndication (
				PConnection         pOrigConn,
				ULong				height_limit)
{
	/*
	 *	Make sure that this indication is from the top provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Check the height limit to determine whether this provider is too
		 *	far from the top or not.
		 */
		if (height_limit != 0)
		{
            CAttachment     *pAtt;
			/*
			 *	We are okay, so decrement the height limit and forward the
			 *	indication to all downward attachments.
			 */
			TRACE_OUT(("Domain::PlumbDomainIndication: forwarding indication downward"));
			height_limit--;
			m_AttachmentList.Reset();
			while (NULL != (pAtt = m_AttachmentList.Iterate()))
			{
				pAtt->PlumbDomainIndication(height_limit);
			}
		}
		else
		{
			/*
			 *	We are too far from the top (which may indicate the existence
			 *	of a cycle in the domain).  It is therefore necessary to
			 *	purge the entire domain (from this provider down).
			 */
			WARNING_OUT(("Domain::PlumbDomainIndication: purging domain"));
			PurgeDomain (REASON_PROVIDER_INITIATED);
		}
	}
	else
	{
		/*
		 *	This indication was received from an attachment that is unknown to
		 *	this domain.  Ignore it.
		 */
		ERROR_OUT(("Domain::PlumbDomainIndication: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	ErectDomainRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This member function is called whenever a lower provider detects a
 *		change in their domain height.  This will be due to someone below this
 *		provider creating or breaking a connection.
 */
Void	Domain::ErectDomainRequest (
				PConnection         pOrigConn,
				ULONG_PTR       	height_in_domain,
				ULong)
{
	/*
	 *	Make sure that this request comes from an attachment that the local
	 *	provider is aware of.
	 */
	if (m_AttachmentList.FindConn(pOrigConn))
	{
		/*
		 *	Put the domain height into the domain height list, and then call
		 *	the subroutine responsible for determining whether any action is
		 *	required as a result of change in the height.
		 */
		TRACE_OUT(("Domain::ErectDomainRequest: processing request"));
		m_DomainHeightList2.Append(pOrigConn, height_in_domain);
		CalculateDomainHeight ();
	}
	else
	{
		/*
		 *	The attachment is unknown to this provider.  Ignore the request.
		 */
		ERROR_OUT(("Domain::ErectDomainRequest: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	MergeChannelsRequest ()
 *
 *	Public
 *
 *	Functional Description:
 *		This public member function is called by a former top provider during
 *		a domain merge operation.  It travels upward to the top provider of
 *		the combined domain, where the merge can be processed.  Any providers
 *		that it travels through on the way must remember how to route the
 *		confirm back to the originator.
 */
Void	Domain::MergeChannelsRequest (
				PConnection             pOrigConn,
				CChannelAttributesList *merge_channel_list,
				CChannelIDList         *purge_channel_list)
{
	PChannelAttributes		merge_channel;
	Channel_Type			channel_type;
	ChannelID				channel_id;
	PChannel				channel;
	CChannelAttributesList	merge_confirm_list;

	/*
	 *	Make sure that this request is coming from a legitimate downward
	 *	attachment before processing it.
	 */
	if (m_AttachmentList.FindConn(pOrigConn))
	{
		/*
		 *	Is this the top provider.  If so the request can be processed
		 *	locally.  If not, it must be forwarded towards the top provider.
		 */
		if (IsTopProvider())
		{
			/*
			 *	Iterate through the merge channel list, admitting all channels
			 *	that can be admitted.
			 */
			merge_channel_list->Reset();
			while (NULL != (merge_channel = merge_channel_list->Iterate()))
			{
				/*
				 *	Get the address of the next channel attributes structure
				 *	in the list.  Then get the type and the ID of the channel
				 *	being merged.
				 */
				channel_type = merge_channel->channel_type;
				switch (channel_type)
				{
					case STATIC_CHANNEL:
						channel_id = merge_channel->
								u.static_channel_attributes.channel_id;
						break;

					case USER_CHANNEL:
						channel_id = merge_channel->
								u.user_channel_attributes.user_id;
						break;

					case PRIVATE_CHANNEL:
						channel_id = merge_channel->
								u.private_channel_attributes.channel_id;
						break;

					case ASSIGNED_CHANNEL:
						channel_id = merge_channel->
								u.assigned_channel_attributes.channel_id;
						break;
				}

				/*
				 *	Check to see if the channel being merged exists in the
				 *	upper domain information base.
				 */
				if (NULL != (channel = m_ChannelList2.Find(channel_id)))
				{
					if ((channel_type == STATIC_CHANNEL) &&
							(channel->GetChannelType () == STATIC_CHANNEL))
					{
						/*
						 *	It is a static channel.  This means that the merge
						 *	is okay (merging static channels is no problem).
						 */
						TRACE_OUT(("Domain::MergeChannelsRequest: static channel merge successful"));

						/*
						 *	Static channels are automatically joined.
						 *	Note that sending an initiator ID of 0 tells the
						 *	channel object not to issue a ChannelJoinConfirm,
						 *	which is inappropriate during a merge.
						 */
						channel->ChannelJoinRequest(pOrigConn, 0, 0);

						/*
						 *	Put the channel attributes structure into the
						 *	merge confirm list, meaning that the information
						 *	associated with the successful merge will be
						 *	repeated in the subsequent confirm.
						 */
						merge_confirm_list.Append(merge_channel);
					}
					else
					{
						/*
						 *	The channel being merged is an in-use dynamic
						 *	channel.  Therefore, it must be rejected (this is
						 *	NOT permitted).
						 */
						WARNING_OUT(("Domain::MergeChannelsRequest: dynamic channel in use - rejecting merge"));

						/*
						 *	Add the channel ID to the list of those channels
						 *	to be purged frmo the lower domain.
						 */
						purge_channel_list->Append(channel_id);
					}
				}
				else
				{
					/*
					 *	If the channel does not exist in the upper domain at
					 *	all, then add it to the upper domain.
					 */
					AddChannel(pOrigConn, merge_channel, &merge_confirm_list, purge_channel_list);
				}
			}

			/*
			 *	Send the appropriate merge channels confirm to the originating
			 *	user.
			 */
			pOrigConn->MergeChannelsConfirm(&merge_confirm_list, purge_channel_list);
		}
		else
		{
			/*
			 *	If this is not the top provider, then add the requesting
			 *	attachment to the merge queue (which is used to route
			 *	confirms back later), and forward the request upward towards
			 *	the top provier.
			 */
			TRACE_OUT(("Domain::MergeChannelsRequest: forwarding request to Top Provider"));
			m_MergeQueue.Append(pOrigConn);

			m_pConnToTopProvider->MergeChannelsRequest(merge_channel_list, purge_channel_list);
		}
	}
	else
	{
		/*
		 *	This request was received from an attachment that is unknown to
		 *	this domain.
		 */
		ERROR_OUT(("Domain::MergeChannelsRequest: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	MergeChannelsConfirm ()
 *
 *	Public
 *
 *	Functional Description:
 *		This public member function is called in response to a previous channels
 *		merge request.  It is forwarded back down the hierarchy until it reaches
 *		the former top provider that initiated the request.  That former top
 *		provider will use the information contained therein to determine
 *		whether the merge on a particular channel was successful or not.  If
 *		it was not, then the channel is purged from the lower domain, and a
 *		purge channels indication is sent downward to let everyone in the lower
 *		domain know of this.
 */
Void	Domain::MergeChannelsConfirm (
				PConnection             pOrigConn,
				CChannelAttributesList *merge_channel_list,
				CChannelIDList         *purge_channel_list)
{
    PConnection             pConn;
	PChannelAttributes		merge_channel;
	Channel_Type			channel_type;
	ChannelID				channel_id;
	PChannel				channel;
	BOOL    				joined;
	CChannelAttributesList	merge_confirm_list;
	CUidList				purge_user_list;
	CChannelIDList			purge_normal_list;

	/*
	 *	Verify that the confirm came from the top provider.
	 */
	if (pOrigConn == m_pConnToTopProvider)
	{
		/*
		 *	Now check the merge state.  If the state is inactive, then that
		 *	means that this provider is an intermediate provider (i.e. a
		 *	provider that lies between the top provider and the former top
		 *	provider of the lower domain).  If the state is not inactive, then
		 *	this must be the former top provider of the lower domain.
		 */
		if (Merge_State == MERGE_INACTIVE)
		{
			/*
			 *	This is a legitimate merge channels confirm.  We must forward
			 *	the confirm to the downward attachment that originated the
			 *	merge channel request.  We remember who this is by pulling
			 *	out the first entry in the merge queue.  Check to make sure
			 *	that there is an entry in the merge queue.
			 */
			if (NULL != (pConn = m_MergeQueue.Get()))
			{
				/*
				 *	Get the attachment that is to receive the confirm and verify
				 *	that it is still connected (the connection could have been
				 *	lost since the request was forwarded upward).
				 */
				if (m_AttachmentList.FindConn(pConn))
				{
					/*
					 *	Iterate through the merge channel list, adding each of
					 *	the channels it contains into the local information
					 *	base.
					 */
					merge_channel_list->Reset();
					while (NULL != (merge_channel = merge_channel_list->Iterate()))
					{
						/*
						 *	Get the next channel to be merge and then get its
						 *	channel ID.
						 */
						channel_type = merge_channel->channel_type;
						switch (channel_type)
						{
							case STATIC_CHANNEL:
								channel_id = merge_channel->
									u.static_channel_attributes.channel_id;
								joined = TRUE;
								break;

							case USER_CHANNEL:
								channel_id = merge_channel->
									u.user_channel_attributes.user_id;
								joined = merge_channel->
									u.user_channel_attributes.joined;
								break;

							case PRIVATE_CHANNEL:
								channel_id = merge_channel->
									u.private_channel_attributes.channel_id;
								joined = merge_channel->
									u.private_channel_attributes.joined;
								break;

							case ASSIGNED_CHANNEL:
								channel_id = merge_channel->
									u.assigned_channel_attributes.channel_id;
								joined = TRUE;
								break;
						}

						/*
						 *	See if the channel already exists in the local
						 *	information base.
						 */
						if (NULL != (channel = m_ChannelList2.Find(channel_id)))
						{
							/*
							 *	If the attachment is joined to this channel,
							 *	then join it at this level too.  Note that
							 *	sending an initiator ID of 0 tells the channel
							 *	object not to issue a ChannelJoinConfirm, which
							 *	would be inappropriate during a merge.
							 */
							TRACE_OUT(("Domain::MergeChannelsConfirm: attempting to join merged channel"));
							if (joined)
								channel->ChannelJoinRequest(pConn, 0, 0);

							/*
							 *	Add the channel to the merge confirm list so
							 *	that it will automatically be forwarded
							 *	downward.
							 */
							merge_confirm_list.Append(merge_channel);
						}
						else
						{
							/*
							 *	The channel does not exist in the local
							 *	information base, so add it.
							 */
							AddChannel(pConn, merge_channel, &merge_confirm_list, purge_channel_list);
						}
					}

					/*
					 *	Forward the merge channel confirm on to the attachment
					 *	from which the request originated.
					 */
					pConn->MergeChannelsConfirm(&merge_confirm_list, purge_channel_list);
				}
				else
				{
					/*
					 *	The attachment from which the merge request originated
					 *	has been lost.  It may be necessary to send something
					 *	to the Top Provider in order to guarantee the integrity
					 *	of the domain.  In some cases it may be necessary to
					 *	purge the domain.
					 */
					WARNING_OUT(("Domain::MergeChannelsConfirm: forwarding attachment lost"));
				}
			}
			else
			{
				/*
				 *	There is no outstanding merge request that can be used to
				 *	direct the confirm.  This will happen only if a confirm
				 *	is received without a previous merge having been sent.
				 *	The proper response should be to send a RejectUltimatum
				 *	to the offending upward attachment.
				 */
				ERROR_OUT(("Domain::MergeChannelsConfirm: merge queue empty"));
			}
		}
		else
		{
			/*
			 *	This confirm should not be received unless there is at least
			 *	one outstanding merge request.  Check to make sure that this
			 *	is so.
			 */
			if (Outstanding_Merge_Requests != 0)
			{
				/*
				 *	If there are any entries in the purge channel list, then
				 *	it is necessary to issue a purge channels indication to all
				 *	downward attachments.
				 */
				if (purge_channel_list->IsEmpty() == FALSE)
				{
					ChannelID   chid;
					UserID      uid;
					/*
					 *	Iterate through the list of channels to be purged,
					 *	putting each channel into either the "user list" or the
					 *	"normal list".  This separation is necessary for lower
					 *	providers to be able to issue the appropriate
					 *	indications.
					 */
					purge_channel_list->Reset();
					while (NULL != (channel_id = purge_channel_list->Iterate()))
					{
						/*
						 *	Get the channel ID of the next channel to be purged.
						 */
						TRACE_OUT(("Domain::MergeChannelsConfirm: merge rejected on channel ID = %04X", (UINT) channel_id));

						/*
						 *	Make sure the channel still exists locally before
						 *	trying to purge it.
						 */
						if (m_ChannelList2.Find(channel_id))
						{
							/*
							 *	Determine what type of channel is being purged
							 *	and add it to the appropriate list.  These lists
							 *	will be used when issuing the purge channels
							 *	indication below.
							 */
							if (ValidateUserID (channel_id, NULL))
								purge_user_list.Append(channel_id);
							else
								purge_normal_list.Append(channel_id);
						}
						else
						{
							/*
							 *	The channel to be purged could not be found in
							 *	the local domain.
							 */
							ERROR_OUT(("Domain::MergeChannelsConfirm: no such channel"));
						}
					}

					/*
					 *	This loop simply transmits a PurgeChannelsIndication to
					 *	all downward attachments in the lower domain.
					 */
				    CAttachment *pAtt;
					m_AttachmentList.Reset();
					while (NULL != (pAtt = m_AttachmentList.Iterate()))
					{
						pAtt->PurgeChannelsIndication(&purge_user_list, &purge_normal_list);
					}

					/*
					 *	Iterate through the list of channels to be purged,
					 *	deleting each channel.
					 */
					purge_normal_list.Reset();
					while (NULL != (chid = purge_normal_list.Iterate()))
					{
						DeleteChannel(chid);
					}
		
					/*
					 *	Iterate through the list of users to be purged, deleting
					 *	each user.
					 */
					purge_user_list.Reset();
					while (NULL != (uid = purge_user_list.Iterate()))
					{
						DeleteUser(uid);
					}
				}

				/*
				 *	Decrement the number of outstanding requests.  If this
				 *	was the last outstanding request, then go back to the
				 *	merge state machine to see if there is anything left to
				 *	do.
				 */
				if (--Outstanding_Merge_Requests == 0)
					MergeInformationBase ();
			}
			else
			{
				/*
				 *	There are no merge requests pending, so this errant confirm
				 *	must be ignored.
				 */
				ERROR_OUT(("Domain::MergeChannelsConfirm: no outstanding merge requests"));
			}
		}
	}
	else
	{
		/*
		 *	This confirm was received from someone besides the top provider.
		 */
		ERROR_OUT(("Domain::MergeChannelsConfirm: invalid originator=0x%p", pOrigConn));
	}
}

/*
 *	Void	PurgeChannelsIndication ()
 *
 *	Public
 *
 *	Functional Description:
 *		This p