y.
                for (pwszPicsLabelEnd = pwszPicsLabel;
                     *pwszPicsLabelEnd;
                     pwszPicsLabelEnd++)
                    ;
            }
            if (pwszPicsLabel && (pwszPicsLabelEnd > pwszPicsLabel))
            {
                WCHAR* pszLabel = new WCHAR[((int)(pwszPicsLabelEnd - pwszPicsLabel)) + 1];

                if (pszLabel)
                {
                    //
                    // pwszPicsLabel may not be NULL terminated so use memcpy to
                    // move it.  Memory allocated by new is zero filled so
                    // pszLabel doesn't have to have L'\0' appeneded.
                    //
                    memcpy(pszLabel, pwszPicsLabel,
                           ((int)(pwszPicsLabelEnd - pwszPicsLabel)) * sizeof(WCHAR));
                    pdoh->_PicsProcBase._HandleInDocumentLabel(pszLabel);

                    delete pszLabel;
                }
            }
        }
        else
        {
            pdoh->_PicsProcBase._dwPicsLabelSource=PICS_LABEL_FROM_PAGE;
        }
    }
#endif

    return S_OK;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::GetWindow(REFGUID rguidReason, HWND* phwnd)
{
    CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);

    if (!phwnd)
        return E_POINTER;

    if (pdoh->_psb) {
        pdoh->_psb->GetWindow(phwnd);
    } else {
        *phwnd = pdoh->_hwnd;
    }

    return S_OK;
}

HRESULT CDocObjectHost::CDOHBindStatusCallback::OnSecurityProblem(DWORD dwProblem)
{
    // force UI - return S_FALSE for all problems
    return S_FALSE;
}


#define BUG_EXEC_ON_FAILURE     //nash:31526

HRESULT CDocObjectHost::CDOHBindStatusCallback::OnStopBinding(HRESULT hrError,
            LPCWSTR szError)
{
    BSCMSG(TEXT("OnStopBinding"), this, hrError);

    _fBinding = FALSE;

    CDocObjectHost * pdoh = IToClass(CDocObjectHost, _bsc, this);
    LPWSTR   pwzHeaders = NULL;
    BOOL     fShouldDisplayError = TRUE;
    DWORD    dwStatusCode = 0;       // We use 0 to mean no status yet
    DWORD    dwStatusCodeSize = sizeof(dwStatusCode);
    BOOL     bSuppressUI = FALSE;
    BOOL     fAsyncDownload = FALSE;
    BOOL     fAborted = _fAborted;
    BOOL     fCancelAutoSearch = FALSE;
    BOOL     fNavigateErrorFired = FALSE;    // I cannot tell if _HandleHttpErrors are really mutually exclusive from the AutoSearching.
                                             // Therefore I am adding a flag to make sure we don't fire NavigateError twice.

    _fAborted = FALSE;

    _privacyQueue.Reset();
    ResetPrivacyInfo();

    //
    //  this is to protect against urlmons behavior of returning 
    //  an async error and sync error on the same call.
    if (pdoh->_fSyncBindToObject && FAILED(hrError))
    {
        pdoh->_hrOnStopBinding = hrError;
        return S_OK;
    }

    // if aborting to let Document.Write work...pretend everything is cool
    if (_fDocWriteAbort && hrError == E_ABORT) hrError = S_OK;

    // Why not use the cached value?
    // pdoh->_GetOfflineSilent(0, &bSuppressUI);
    bSuppressUI = (_bFrameIsSilent || _IsDesktopItem(pdoh)) ? TRUE : FALSE;

    _bindst = 0;    // go back to the normal state

    if (_pbc && pdoh->_punkPending)
    {
        _pbc->RevokeObjectParam(L"__PrecreatedObject");
    }

    if (!_pbc)
    {
        ASSERT(0);
        return S_OK;
    }

    // NOTES: Guard against last Release by _RevokeObjectParam
    AddRef();

    if (pdoh->_pwb)
    {
        pdoh->_pwb->SetNavigateState(BNS_NORMAL);
    }

    if (pdoh->_psb)
    {   // paranoia
        pdoh->_psb->SetStatusTextSB(NULL);
    }

    BSCMSG("OnStopBinding calling _RevokeObjectParam", this, _pbc);
    _RevokeObjectParam(_pbc);
    _pbc->RevokeObjectParam(WSZGUID_OPID_DocObjClientSite);

    //
    //  If the error code is a mapped error code (by URLMON), get the
    // real error code from IBinding for display purpose.
    //
    HRESULT hrDisplay = hrError;    // assume they are the same

#define ENABLE_WHEN_GETBINDRESULT_STARTS_WORKING
#ifdef ENABLE_WHEN_GETBINDRESULT_STARTS_WORKING

    if (hrError>=INET_E_ERROR_FIRST && hrError<=INET_E_ERROR_LAST)
    {
        //
        //  We come here when _pib==NULL, if URLMON synchronously fails
        // (such as a bad protocol).
        //
        // ASSERT(_pib);
        //
        if (_pib)
        {
            CLSID clsid;
            LPWSTR pwszError = NULL;

            HRESULT hresT=_pib->GetBindResult(&clsid, (DWORD *)&hrDisplay, &pwszError, NULL);
            TraceMsg(TF_SHDBINDING, "DOH::OnStopBinding called GetBindResult %x->%x (%x)", hrError, hrDisplay, hresT);

            if (SUCCEEDED(hresT))
            {
                //
                // URLMON returns a native Win32 error.
                //
                if (hrDisplay && SUCCEEDED(hrDisplay))
                {
                    hrDisplay = HRESULT_FROM_WIN32(hrDisplay);
                }

                //
                // URLMON is not supposed to return 0 as the error code,
                //  which causes a "successfully done" error msgbox. 
                //
                AssertMsg(hrDisplay != S_OK, TEXT("Call JohannP if you see this assert."));

                if (pwszError)
                {
                    OleFree(pwszError);
                }
            }
        }
    }
#endif

    TraceMsg(TF_SHDBINDING, "DOH::BSC::OnStopBinding binding failed %x (hrDisplay=%x)", hrError, hrDisplay);

    //
    // HACK: If the object is associated with IE/Shell itself, but has
    //  no CLSID, we'll force MSHTML.
    //
    // if (_fSelfAssociated && (hrError==MK_E_INVALIDEXTENSION || hrError==REGDB_E_CLASSNOTREG)) {
    //     hrError = _HandleSelfAssociate();
    // }

    if (_pib)
    {

        //  we dont need to do the expiry stuff here anymore.
        //  now mshtml should be doing it through the IPersistHistory

        // get the expire info
        // The HTTP rules for expiration are
        // Expires: 0               expire immediately
        // if Expires: <= Date:     expire immediately
        // if Expires: bad format   expire immediately

        IWinInetHttpInfo * phi;

        if (SUCCEEDED(_pib->QueryInterface(IID_IWinInetHttpInfo, (LPVOID*)&phi)))
        {
            BYTE  abBuffer[256]; // We don't care about this data, just
            DWORD cbBuffer=sizeof(abBuffer); // whether it exists or not

            if (phi->QueryInfo(HTTP_QUERY_LAST_MODIFIED, &abBuffer, &cbBuffer, NULL, 0) == S_OK)
                pdoh->_fhasLastModified = TRUE;

            if (phi->QueryInfo(HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER, &dwStatusCode, &dwStatusCodeSize, NULL, 0) != S_OK)
            {
                dwStatusCode = 0;       // failed to get status code
                dwStatusCodeSize = 0;   // failed to get status code
            }

            // This code will decide if we should display a popup error;
            // essentially, it detects if we can reasonably assume that
            // HTML was returned in the error case; if so, we believe that
            // it is an error page, so we let that display rather than a
            // popup.

            if (dwStatusCode)
            {
                 // We got a status code; let's see if we have a
                 // content-type.

                 // HTTP retcode 204 is a "succeeded, do nothing" retcode
                 // So we should always suppress the popup; further, it is
                 // spec'd to NEVER have content, so we do this before checking
                 // for content-type.
                 // So is 100
                 // 100 is not in wininet.h
                 if (dwStatusCode == HTTP_STATUS_NO_CONTENT)
                     fShouldDisplayError = FALSE;

                 // what is max header size?
                 CHAR  szContentType[1024];
                 DWORD dwContentTypeSize = sizeof(szContentType);

                 // This code handles a bug in URLMON where it tells us 
                 // INET_E_DATA_NOT_AVAILABLE when in fact the
                 // data _was_ available.  We don't want any future 
                 // errors affected by this, so we restrict this
                 // hack to less than 600, and ONLY for the 
                 // INET_E_DATA_NOT_AVAILABLE case.

                 if (hrError == INET_E_DATA_NOT_AVAILABLE && 
                     dwStatusCode < 600 &&
                     phi->QueryInfo(HTTP_QUERY_CONTENT_TYPE, &szContentType, 
                                    &dwContentTypeSize, NULL, 0) == S_OK)
                 {
                     fShouldDisplayError = FALSE;
                 }

                //
                // Handle http errors.
                //

                // Let's wrap the firing in case it is not the first attempt in future

                if (dwStatusCode >= 400 && dwStatusCode <= 599)
                {
                    if (!fNavigateErrorFired)
                    {
                        pdoh->_FireNavigateErrorHelper(NULL, dwStatusCode, &fCancelAutoSearch);
                        fNavigateErrorFired = TRUE;
                    }
                    
                    if (!fCancelAutoSearch)
                    {
                        _HandleHttpErrors(dwStatusCode, _cbContentLength, pdoh);
                    }
                    else if (!pdoh->_fCanceledByBrowser)
                    {
                        pdoh->_CancelPendingNavigation(FALSE, FALSE);
                    }
                }
            }

            phi->Release();
        }

        ATOMICRELEASE(_pib);
    }

    ATOMICRELEASE(_psvPrev);

    //
    //  If the object does not support IOleObject, treat it as if we failed
    // to bind.
    //
    if (_fBoundToNoOleObject)
    {
        ASSERT(SUCCEEDED(hrError));
        hrError = MK_E_INVALIDEXTENSION;
    }

    // need to handle navigation in successful proxy response but w/
    // 404 error.  tonyci 13nov96.  for autosearching & autosuffixing

    if (FAILED(hrError)) 
    {
        BOOL fAddToMRU = FALSE;
        pdoh->_fDrawBackground = TRUE;

        TCHAR szURL[MAX_URL_STRING+1];
        szURL[0] = TEXT('\0');

        //
        //  It seems that in some of the case of hrError the code counts on dwStatusCode being set
        //  dwStatus is set exactly when the real error code was obtained from IBinding for display purpose
        //  For the other case I am going to use hrError
        //

        if (!fNavigateErrorFired)
        {
            if (dwStatusCode)
            {
                pdoh->_FireNavigateErrorHelper(NULL, dwStatusCode, &fCancelAutoSearch);
                fNavigateErrorFired = TRUE;
            }
            else if (hrError>=INET_E_ERROR_FIRST && hrError<=INET_E_ERROR_LAST)
            {
                pdoh->_FireNavigateErrorHelper(NULL, hrError, &fCancelAutoSearch);
                fNavigateErrorFired = TRUE;
            }
        }

        if (pdoh->_pmkCur)
        {
            pdoh->_GetCurrentPage(szURL,ARRAYSIZE(szURL));
        }

        TraceMsg(TF_SHDBINDING, "DOH::OnStopBinding hrError=%x", hrError);
        
        pdoh->_OnSetProgressPos(0, PROGRESS_RESET);

        switch(hrError)
        {
        //
        //  If pmk->BindToObject is failed because of "binding", we should
        // offer an option to download it as a file.
        //

#ifdef BUG_EXEC_ON_FAILURE
        case INET_E_CANNOT_INSTANTIATE_OBJECT:
            TraceMsg(TF_SHDBINDING, "DOH::OnStopBinding IDS_ERR_OLESVR");
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info
            goto Lexec;

        case INET_E_CANNOT_LOAD_DATA:
            TraceMsg(TF_SHDBINDING, "DOH::OnStopBinding IDS_ERR_LOAD");
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info
            goto Lexec;
#else
        case INET_E_CANNOT_INSTANTIATE_OBJECT:
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info

            if (MLShellMessageBox(pdoh->_hwnd,
                            MAKEINTRESOURCE(IDS_ERR_OLESVR),
                            MAKEINTRESOURCE(IDS_TITLE),
                            MB_YESNO|MB_ICONERROR,
                            szURL) == IDYES)
            {
                IUnknown * punk;
                HRESULT hresT = pdoh->QueryInterface(IID_IUnknown, (void**)&punk);

                if(SUCCEEDED(hresT))
                {
                    if (!fAborted)
                    {
                        CDownLoad_OpenUI(pdoh->_pmkCur, _pbc, FALSE, TRUE, NULL, NULL, NULL, NULL, NULL, _pszRedirectedURL, pdoh->_uiCP, punk);
                    }

                    punk->Release();
                }
            }

            break;

        case INET_E_CANNOT_LOAD_DATA:
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info

            // e.g. click on .xls link when doc already open/modified/locked
            // and say 'cancel'
            //
            if (MLShellMessageBox(pdoh->_hwnd,
                            MAKEINTRESOURCE(IDS_ERR_LOAD),
                            MAKEINTRESOURCE(IDS_TITLE),
                            MB_YESNO|MB_ICONERROR,
                            szURL) == IDYES) 
            {
                IUnknown *punk;
                HRESULT hresT = pdoh->QueryInterface(IID_IUnknown, (void**)&punk);
                if(SUCCEEDED(hresT))
                {
                    if (!fAborted)
                    {
                        CDownLoad_OpenUI(pdoh->_pmkCur, _pbc, FALSE, TRUE, NULL, NULL, NULL, NULL, _pszRedirectedURL, pdoh->_uiCP, punk);
                    }

                    punk->Release();
                }
            }

            break;
#endif

        //
        // NOTES: According to JohannP, URLMON will give us
        //  REGDB_E_CLASSNOTREG. I'll leave MK_E_INVALIDEXTENSION
        //  to be compatible with old URLMON (which is harmless).
        //
        case MK_E_INVALIDEXTENSION:
        case REGDB_E_CLASSNOTREG:
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info

#ifdef BUG_EXEC_ON_FAILURE
    Lexec: // nash:31526
            // for various instantiation errors:
            // - for ie3 we suppress messages and force a ShellExec as a
            // 2nd try, pretty much always
            // - for ie4 we should be more selective (nash:31526)
#endif

#ifdef FEATURE_PICS
            // For data types that don't have a CLSID, we never get a chance
            // to block in the CLASSIDAVAILABLE OnProgress notification, so
            // we have to block here.  However, avoid blocking documents such
            // as HTML which we want to download completely so we can get
            // ratings strings out of them.
            //
            if (!pdoh->_fPicsBlockLate && (pdoh->_PicsProcBase._fbPicsWaitFlags || !pdoh->_PicsProcBase._fPicsAccessAllowed))
            {
                pdoh->_PicsProcBase._fbPicsWaitFlags &= ~(PICS_WAIT_FOR_INDOC | PICS_WAIT_FOR_END);   /* make sure we don't expect indoc ratings */
                TraceMsg(DM_PICS, "OnStopBinding calling _PicsBlockingDialog, waitflags now %x", (DWORD)pdoh->_PicsProcBase._fbPicsWaitFlags);

                if (pdoh->_PicsProcBase._PicsBlockingDialog() != IDOK)
                {
                    TraceMsg(DM_PICS, "OnStopBinding, PICS canceled, calling _CancelPendingNavigation");
                    pdoh->_CancelPendingNavigation(FALSE);
                    break;
                }
            }
#endif

            BeginningTransaction (NULL, NULL, 0, &pwzHeaders);

            if (_dwBindVerb==BINDVERB_POST)
            {
                // This is a POST. Do it use the same moniker (modeless)
                //
                // Notes: The ownership of the data in pbinfo will be transfered
                //  to CDownLoad_OpenUIPost. Therefore, we should not call
                //  ReleaseBindInfo(pbinfo) here.
                //
                DWORD grfBINDF;

                // The BINDINFO can not be on the stack since it will be freed by the
                // download thread.
                //
                BINDINFO * pbinfo = (BINDINFO*)LocalAlloc(LPTR, SIZEOF(BINDINFO));

                if (!pbinfo)
                {
                    return E_OUTOFMEMORY;
                }

                pbinfo->cbSize = SIZEOF(BINDINFO);
                GetBindInfo(&grfBINDF, pbinfo);

                // If our POST was really a redirected POST, it will have
                // turned into a GET.  In this case, we need to release
                // ownership of the data and pretend like the whole thing
                // was a GET to start with.

                if (pbinfo->dwBindVerb==BINDVERB_GET)
                {
                    WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];

                    ASSERT(_pszRedirectedURL);

                    SHTCharToUnicode(_pszRedirectedURL, wszUrl, ARRAYSIZE(wszUrl));

                    IUnknown * punk;
                    HRESULT hresT = pdoh->QueryInterface(IID_IUnknown, (void**)&punk);

                    if (SUCCEEDED(hresT))
                    {
                        VARIANT varOut = {0};

                        pdoh->_pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_FIREFILEDOWNLOAD,
                                                   0, NULL, &varOut);

                        if (V_VT(&varOut) != VT_BOOL || V_BOOL(&varOut) == VARIANT_FALSE)
                        { 
                            if (!fAborted)
                            {
                                CDownLoad_OpenUIURL(wszUrl, NULL, pwzHeaders, 
                                                 FALSE /* fSync */, FALSE /* fSaveAs */, pdoh->_fCalledMayOpenSafeDlg,
                                                 NULL, NULL, NULL, _pszRedirectedURL, pdoh->_uiCP, punk);

                                pwzHeaders = NULL;   // ownership is to CDownload now
                            }
                        }

                        punk->Release();
                    }

                    ReleaseBindInfo(pbinfo); // This one is OK since we did not pass the pbinfo
                    LocalFree(pbinfo);       // and we can free it 
                    pbinfo = NULL;
                }
                else
                {

                    ASSERT(pbinfo->dwBindVerb==BINDVERB_POST);

                    // Collect the headers associated with this xact
                    IUnknown * punk;
                    HRESULT hresT = pdoh->QueryInterface(IID_IUnknown, (void**)&punk);

                    if (SUCCEEDED(hresT))
                    {
                        VARIANT varOut = {0};

                        pdoh->_pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_FIREFILEDOWNLOAD,
                                                   0, NULL, &varOut);

                        if (V_VT(&varOut) != VT_BOOL || V_BOOL(&varOut) == VARIANT_FALSE)
                        {
                            if (!fAborted)
                            {
                                CDownLoad_OpenUI(pdoh->_pmkCur, _pbc, FALSE /* fSync */, FALSE /* fSaveAs */, pdoh->_fCalledMayOpenSafeDlg /* fSafe */, pwzHeaders, BINDVERB_POST, grfBINDF, pbinfo, _pszRedirectedURL, pdoh->_uiCP, punk);

                                pwzHeaders = NULL;   // ownership is to CDownload now
                            }
                        }

                        punk->Release();
                    }

                    TraceMsg(TF_SHDBINDING, "DOH::OnStopBinding just called CDownLoad_OpenUIPost");

                    // NOTE: t-gpease 8-18-97
                    // Do not ReleaseBindInfo(pinfo) because it is used by the download thread.
                    // The thread is responsible for releasing it.
                }

            }
            else
            {
                // Otherwise, spawn another thread and get it there.

                // NOTE: If UnBind gets called then pdoh->_pmkCur will be NULL
                // and URLMON is most likely returning a bogus error code.  So
                // we'll check the pointer and prevent from blowing up.

                if (pdoh->_pmkCur)
                {
                    BOOL fSafe = pdoh->_fCalledMayOpenSafeDlg;

                    IBrowserService * pbs;

                    if (PathIsFilePath(szURL) && 
                        SUCCEEDED(pdoh->QueryService(SID_STopFrameBrowser, IID_IBrowserService, (LPVOID *)&pbs)))
                    {
                        DWORD dwFlags;

                        if (SUCCEEDED(pbs->GetFlags(&dwFlags)) && (dwFlags & BSF_NOLOCALFILEWARNING))
                        {
                            fSafe = TRUE;
                        }

                        pbs->Release();
                    }

                    IUnknown *punk;
                    HRESULT hresT = pdoh->QueryInterface(IID_IUnknown, (void**)&punk);

                    if (SUCCEEDED(hresT))
                    {
                        VARIANT varOut = {0};

                        pdoh->_pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_FIREFILEDOWNLOAD,
                                                   0, NULL, &varOut);

                        if (V_VT(&varOut) != VT_BOOL || V_BOOL(&varOut) == VARIANT_FALSE)
                        {
                            if (pdoh->_pmsoctBrowser && pdoh->_fWindowOpen)
                            {
                                pdoh->_pmsoctBrowser->Exec(&CGID_Explorer, SBCMDID_CANCELANDCLOSE, 0, NULL, NULL);
                            }

                            if (!fAborted)
                            {
                                CDownLoad_OpenUI(pdoh->_pmkCur, pdoh->_pbcCur, FALSE, FALSE,
                                                fSafe, pwzHeaders, NULL, pdoh->_bsc._dwBindf, NULL, _pszRedirectedURL,
                                                pdoh->_uiCP, punk, pdoh->_fConfirmed);
                
                                pwzHeaders = NULL;   // ownership is to CDownload now
                            }
                        }
                        punk->Release();
                    }

                    fAsyncDownload = TRUE;
                }
            }

            if (pwzHeaders)
            {
                CoTaskMemFree(pwzHeaders);
            }

            break;

        // URLMON failed to bind because it didn't know what to do with
        // with this URL.  Lets check and see if the Shell should handle
        // it via a helper app (news:, mailto:, telnet:, etc.)
        case INET_E_UNKNOWN_PROTOCOL:
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info

            {
                // If we've been redirected, use that URL
                //
                if (_pszRedirectedURL)
                {
                    StrCpyN(szURL, _pszRedirectedURL, ARRAYSIZE(szURL));
                }

                // Here we check to see if it is a URL we really want to shellexecute
                // so it is handled by helper apps.....else it really is an error
                if (ShouldShellExecURL(szURL))
                {
                    // We can add this to the address bar MRU 
                    fAddToMRU = TRUE;

                    // We need to decode this before passing it on to someone.

                    TCHAR szDecodedURL[INTERNET_MAX_URL_LENGTH];
                    DWORD cchDecodedURL = ARRAYSIZE(szDecodedURL);

                    // REVIEW: NT 319480 IE 54850 - need to append _pszLocation back to pszBadProtoURL...
                    //
                    // I assume the string was escaped when it came from urlmon, so we need
                    // to append it before PrepareURLForExternalApp.
                    //
                    // Note: if the url had been redirected above, _pszLocation has been updated
                    // to the new redirected URL, so we still want to append it.
                    //
                    if (pdoh->_pszLocation)
                    {
                        StrCatBuff(szURL, pdoh->_pszLocation, ARRAYSIZE(szURL));
                    }

                    PrepareURLForExternalApp(szURL, szDecodedURL, &cchDecodedURL);

                    // PathQuoteSpaces(szDecodedURL);

                    SHELLEXECUTEINFO sei = {0};

                    sei.cbSize = sizeof(sei);
                    sei.lpFile = szDecodedURL;
                    sei.nShow  = SW_SHOWNORMAL;

                    if (!ShellExecuteEx(&sei))
                    {
                        if(!bSuppressUI)
                        {
                            IE_ErrorMsgBox(pdoh->_psb, pdoh->_hwnd, hrDisplay, szError,
                                           szDecodedURL, IDS_CANTSHELLEX, MB_OK | MB_ICONSTOP );
                        }
                    }

                    //
                    //  We want to close the browser window if this is the
                    // very first navigation. 
                    //
                    fAsyncDownload = TRUE;
                }
                else if ((!bSuppressUI) && (!fCancelAutoSearch))
                {
                    _NavigateToErrorPage(ERRORPAGE_SYNTAX, pdoh, FALSE);
                }

                break;
            }

        case E_ABORT:
        case HRESULT_FROM_WIN32(ERROR_CANCELLED):
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info

            // If the binding was aborted or canceled and this is 
            // a navigation that was delegated from Trident, then
            // we must fire the FileDownload event so Trident won't
            // switch the markup.
            //
            if (pdoh->_fDelegatedNavigation && pdoh->_pmsoctBrowser)
            {
                VARIANT varOut = {0};

                pdoh->_pmsoctBrowser->Exec(&CGID_ShellDocView, SHDVID_FIREFILEDOWNLOAD, 0, NULL, &varOut);
            }

            break;

#ifdef BUG_EXEC_ON_FAILURE
        case E_NOINTERFACE: // nash:31526
            TraceMsg(TF_SHDBINDING, "DOH::OnStopBinding E_NOINTERFACE");
            goto Lexec;
#endif

        case INET_E_RESOURCE_NOT_FOUND:
        case INET_E_DATA_NOT_AVAILABLE:

            if (!fCancelAutoSearch)
            {
                if (_HandleFailedNavigationSearch(&fShouldDisplayError, dwStatusCode, pdoh, hrDisplay, (LPTSTR) &szURL, szError, _pib) != S_OK)
                {
                    fShouldDisplayError = TRUE;
                }
            }
            else if (!pdoh->_fCanceledByBrowser)
            {
                     pdoh->_CancelPendingNavigation(FALSE, FALSE);
            }

            // intentional fallthrough to default to popup if needed

        case INET_E_DOWNLOAD_FAILURE:
            if(IsGlobalOffline())
            {
                fShouldDisplayError = FALSE;
                break; 
            }

            // otherwise fall through to do default handling

        default:
            {
                if (fShouldDisplayError)
                {
                    _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info
                    if  ((!bSuppressUI) && (!fCancelAutoSearch))
                    {
                        //
                        // If we're in a frame try to navigate in place.  This
                        // won't work if we're in a synchronous call
                        // (_fSetTarget).
                        //
                        BOOL fNavigateInPlace = pdoh->_fHaveParentSite && !pdoh->_fSetTarget;
                        _NavigateToErrorPage(ERRORPAGE_DNS, pdoh, fNavigateInPlace);
                    }
                }
            }
            break;

        }

        // Tell addressbar to not add this to its mru
        if (!fAddToMRU)
        {
            _DontAddToMRU(pdoh);
        }

        //
        // Prepare for the case where the container keep us visible
        // after hitting this code (Explorer does, IE doesn't).
        //
        pdoh->_fDrawBackground = TRUE;

        // In the case of quickly jumping to another link, we end up with
        // a _hwnd being NULL and we were invalidating the desktop. So,
        // I check for NULL here before calling InvalidateRect.
        if (pdoh->_hwnd)
        {
            InvalidateRect(pdoh->_hwnd, NULL, TRUE);
        }

        // Tell the browser to cancel the pending navigation only
        // if it has not been canceled by the browser itself.
        // and if the navigation wasn't delegated from the document.
        //
        if (!pdoh->_fCanceledByBrowser)
        {
            pdoh->_CancelPendingNavigation(fAsyncDownload, FALSE, pdoh->_fDelegatedNavigation);

            if (pdoh->_fDelegatedNavigation)
            {
                IDocNavigate * pDocNavigate;

                HRESULT hr = E_FAIL;
                
                if ( pdoh->_pwb )
                {
                    hr = pdoh->_pwb->QueryInterface(IID_PPV_ARG(IDocNavigate, &pDocNavigate));
                }

                if (S_OK == hr)
                {
                    pDocNavigate->OnReadyStateChange(NULL, READYSTATE_COMPLETE);
                    pDocNavigate->Release();
                }
            }
        }
        else
        {
            TraceMsg(TF_SHDNAVIGATE|TF_SHDPROGRESS, 
                "DOH::::OnStopBinding not calling _CancelPendingNav");
        }
    }
    else
    {
        BOOL bDidNavigate = FALSE;

        //  Might have redirected to mailto: or some other protocol handled by
        //  plugable protocol that does some magic (eg launch mail program) and
        //  reports OnStopBinding w/o going through OnObjectAvailable!
        if (NULL == pdoh->_pole && !pdoh->_fCanceledByBrowser)
        {
            pdoh->_CancelPendingNavigation(FALSE);
        }

        // It is still possible that our Proxy failed to find the server but
        // gave us HTML.  If this is the case, and the user has "find sites"
        // set, we should go ahead and start trying to do our automatic
        // navigation stuff.

        if (dwStatusCode && DO_SEARCH_ON_STATUSCODE(dwStatusCode))
        {
            if (!fCancelAutoSearch)
            {
                if (_HandleFailedNavigationSearch(&fShouldDisplayError, dwStatusCode, pdoh, hrDisplay, NULL, szError, _pib) == S_OK)
                {
                    bDidNavigate = TRUE;
                }
            }
            else if (!pdoh->_fCanceledByBrowser)
            {
                 pdoh->_CancelPendingNavigation(FALSE, FALSE);
            }
            // Note, since the Proxy will have given us HTML in this case,
            // we will never display an error dialog.
        }

        if (!bDidNavigate && !pdoh->_fDocCanNavigate)
        {
            _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info

            //  We can suppress this redundant call to Add to History if DocObject
            //  is MSHTML, since it will report readystate
            if (!_fBoundToMSHTML && pdoh->_pmkCur)
            {
                TCHAR  szUrl[MAX_URL_STRING+1];

                pdoh->_GetCurrentPage(szUrl,ARRAYSIZE(szUrl));

                if (pdoh->_pszLocation)
                {
                    StrCatBuff(szUrl, pdoh->_pszLocation, ARRAYSIZE(szUrl));
                }

                if (!bSuppressUI)
                {
                    BOOL fWriteHistory  = TRUE;
                    BOOL fSelectHistory = TRUE;

                    if (NULL != pdoh->_pocthf)
                    {
                        MSOCMD rgCmd[] = { { SBCMDID_WRITEHIST, 0 }, { SBCMDID_SELECTHISTPIDL, 0 } };

                        pdoh->_pocthf->QueryStatus(&CGID_Explorer, ARRAYSIZE(rgCmd), rgCmd, NULL);

                        fWriteHistory  = BOOLIFY(rgCmd[0].cmdf & MSOCMDF_ENABLED);
                        fSelectHistory = BOOLIFY(rgCmd[1].cmdf & MSOCMDF_ENABLED);
                    }

                    AddUrlToUrlHistoryStg(szUrl,
                                          NULL, 
                                          pdoh->_pwb,
                                          fWriteHistory,
                                          fSelectHistory ? pdoh->_pocthf : NULL,
                                          pdoh->get_punkSFHistory(), NULL);
                }
            }
        } // if !bDidNavigate
    } // if failed(hrerror) ... else

    // Released here because we may need it for OpenUI() w/ POST verb
    ATOMICRELEASE(_pbc);

#ifndef NO_DELEGATION
    if (_pbscChained)
    {
        CHAINMSG("OnStopBinding", hrError);
        _pbscChained->OnStopBinding(hrError, szError);
    }
#endif

    ATOMICRELEASE(_pbscChained);
    ATOMICRELEASE(_pnegotiateChained);
    pdoh->_ResetStatusBar();

    ATOMICRELEASE(pdoh->_pbcCur);

    if (_pszHeaders)
    {
        LocalFree(_pszHeaders);
        _pszHeaders = NULL;
    }
    if (_hszPostData)
    {
        GlobalFree(_hszPostData);
        _hszPostData = NULL;
    }

    // NOTES: Guard against last Release by _RevokeObjectParam
    Release();

    return S_OK;
}

void CDocObjectHost::CDOHBindStatusCallback::AbortBinding(void)
{
    TraceMsg(TF_SHDPROGRESS, "CDOH::CBSC::AbortBinding called _pib=%x", _pib);

    if (_pib)
    {
        TraceMsg(0, "sdv TR AbortBinding Calling _pib->Abort");
        //
        // Notes: OnStopBinding(E_ABORT) will be called from _pib->Abort
        //
        HRESULT hresT = _pib->Abort();
        TraceMsg(TF_SHDBINDING, "sdv TR AbortBinding Called _pib->Abort (%x)", hresT);

        // URLMon may call our OnStopBinding asynchronously.
        ATOMICRELEASE(_pib);

        
        CDocObjectHost* pdoh = IToClass(CDocObjectHost, _bsc, this);
        if(pdoh->_dwProgressPos)
        {
            pdoh->_ResetStatusBar();
            pdoh->_OnSetProgressPos(0, PROGRESS_RESET);
        }
    }
}

//
// NavigatesToErrorPage cancels the pending navigation and and navigates to
// an internal error page.
//

void CDocObjectHost::CDOHBindStatusCallback::_NavigateToErrorPage(DWORD dwError, CDocObjectHost* pdoh, BOOL fInPlace)
{
    ASSERT(IsErrorHandled(dwError));
    ASSERT(pdoh);

    // Security:  Release the pre-created object because we don't want
    // anyone to have access to the OM of the navigated error document
    // if they obtained the reference before the error navigation.
    // Releasing the reference prevents a parent window from getting keys
    // to the My Computer zone.

    pdoh->_ReleaseOleObject(FALSE);
    pdoh->_ReleasePendingObject(FALSE);

    //
    // pdoh->_pmkCur can be NULL if this is a "DNS" error and Unbind has already
    // been called.
    //

    if (pdoh->_pmkCur)
    {
        //
        // Save the url the user attempted to navigate to.  It will be used
        // to refresh the page.
        //

        if (pdoh->_pwszRefreshUrl)
        {
            OleFree(pdoh->_pwszRefreshUrl);
            pdoh->_pwszRefreshUrl = NULL;
        }

        pdoh->_pmkCur->GetDisplayName(pdoh->_pbcCur, NULL,
                                      &pdoh->_pwszRefreshUrl);
    }

    if ((NULL == pdoh->_pwszRefreshUrl) || !IsErrorUrl(pdoh->_pwszRefreshUrl))
    {
        // Build the error page url.
        //
        TCHAR szErrorUrl[MAX_URL_STRING];

        if (fInPlace)
        {
            HRESULT hr;

            hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                   HINST_THISDLL,
                                   ML_CROSSCODEPAGE,
                                   (TCHAR *)c_aErrorUrls[EUIndexFromError(dwError)].pszUrl,
                                   szErrorUrl,
                                   ARRAYSIZE(szErrorUrl),
                                   TEXT("shdocvw.dll"));
            if (SUCCEEDED(hr))
            {
                //
                // Navigate to the error page.
                //

                IMoniker* pIMoniker;

                if (SUCCEEDED(MonikerFromString(szErrorUrl, &pIMoniker)))
                {
                    ASSERT(pIMoniker);
#ifdef DEBUG
                    pdoh->_fFriendlyError = TRUE;
#endif

                    pdoh->SetTarget(pIMoniker, pdoh->_uiCP, NULL, NULL, NULL, 0);

                    pIMoniker->Release();
                }
            }
        }
        else
        {
            const WCHAR* const pszFmt = L"#%s";
            HRESULT hr;

            hr = MLBuildResURLWrap(TEXT("shdoclc.dll"),
                                   HINST_THISDLL,
                                   ML_CROSSCODEPAGE,
                                   (TCHAR *)c_aErrorUrls[EUIndexFromError(dwError)].pszUrl,
                                   szErrorUrl,
                                   ARRAYSIZE(szErrorUrl),
                                   TEXT("shdocvw.dll"));
            if (SUCCEEDED(hr))
            {
                int nLenWritten;

                // append the #<refresh URL>
                nLenWritten = lstrlen(szErrorUrl);
                wnsprintf(szErrorUrl + nLenWritten,
                          ARRAYSIZE(szErrorUrl) - nLenWritten,
                          pszFmt,
                          pdoh->_pwszRefreshUrl ? pdoh->_pwszRefreshUrl : L"");

                //
                // Cancel the server page and display the internal page instead.
                //

                if (!pdoh->_fCanceledByBrowser)
                    pdoh->_CancelPendingNavigation(FALSE);

                // Turn off the flag in the base browser that
                // indicates that the view should be reused.
                // We want a new view in this case.
                //
                if ( pdoh->_pwb )
                {
                    pdoh->_pwb->SetFlags(NULL, BSF_HTMLNAVCANCELED);
                }
                    
                pdoh->_DoAsyncNavigation(szErrorUrl);
                pdoh->_fCanceledByBrowser = TRUE;
            }
        }
    }
    return;
}

//
// Check if the user turned off friendly http errors.  Default is yes.
//

BOOL CDocObjectHost::CDOHBindStatusCallback::_DisplayFriendlyHttpErrors()
{
    BOOL fRet;

    DWORD dwType = REG_SZ;
    TCHAR  szYesOrNo[20];
    DWORD  cbSize = sizeof(szYesOrNo);

    if (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_PATH_MAIN,
                                         REGSTR_VAL_HTTP_ERRORS, &dwType,
                                         (LPVOID)szYesOrNo, &cbSize, FALSE,
                                         NULL, 0))
    {
        fRet = StrCmpI(szYesOrNo, L"no");
    }
    else
    {
        fRet = TRUE;
    }

    return fRet;
}

//
// Error handler
//

void CDocObjectHost::CDOHBindStatusCallback::_HandleHttpErrors(DWORD dwError, DWORD cbContentLength, CDocObjectHost* pdoh)
{
    // Tell addressbar to not add this to its mru
    _DontAddToMRU(pdoh);    
    if (IsErrorHandled(dwError))
    {
        pdoh->_fErrorPage = TRUE;
        //
        //  On a 4XX error display an internal page if the server returned a
        //  page smaller than the threshold value.  If the page is larger than
        //  the threshold, display it.
        //
        // If the content length is zero assume the server didn't send the
        // length.  In this case take the conservative approach and don't 
        // show our page.
        //

        if (cbContentLength != 0 &&
            cbContentLength <= _GetErrorThreshold(dwError))
        {
            if (_DisplayFriendlyHttpErrors())
                _NavigateToErrorPage(dwError, pdoh, TRUE);
        }
    }

    return;
}

//
// Informs the address bar to not put this page in its mru
//
void CDocObjectHost::CDOHBindStatusCallback::_DontAddToMRU(CDocObjectHost* pdoh)
{
    IDockingWindow* pdw = NULL;
    IOleCommandTarget* poct;

    if (pdoh->_psp &&
        SUCCEEDED(pdoh->_psp->QueryService(SID_SExplorerToolbar, IID_IDockingWindow, (LPVOID*)&pdw)))
    {
        if (SUCCEEDED(pdw->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&poct)))
        {
            // Get the URL we were navigating to
            LPWSTR pszUrl;
            if (pdoh->_pmkCur &&
                SUCCEEDED(pdoh->_pmkCur->GetDisplayName(pdoh->_pbcCur, NULL, &pszUrl)))
            {
                LBSTR::CString          strDisplay( pszUrl );

                VARIANT varURL = {0};

                varURL.vt      = VT_BSTR;
                varURL.bstrVal = strDisplay;

                poct->Exec(&CGID_Explorer, SBCMDID_ERRORPAGE, 0, &varURL, NULL);

                OleFree(pszUrl);
            }

            poct->Release();
        }
        pdw->Release();
    }
}

//
// Tells the addressbar that we are autosearching so that it can update
// the pending url in its mru
//
void CDocObjectHost::CDOHBindStatusCallback::_UpdateMRU(CDocObjectHost* pdoh, LPCWSTR pszUrl)
{
    IDockingWindow* pdw = NULL;
    IOleCommandTarget* poct;

    if (pdoh->_psp &&
        SUCCEEDED(pdoh->_psp->QueryService(SID_SExplorerToolbar, IID_IDockingWindow, (LPVOID*)&pdw)))
    {
        if (SUCCEEDED(pdw->QueryInterface(IID_IOleCommandTarget, (LPVOID*)&poct)))
        {
            // Copy url to stack allocated bstr
            LBSTR::CString          strDisplay( pszUrl );

            VARIANT varURL = {0};

            varURL.vt      = VT_BSTR;
            varURL.bstrVal = strDisplay;

            poct->Exec(&CGID_Explorer, SBCMDID_AUTOSEARCHING, 0, &varURL, NULL);

            poct->Release();
        }
        pdw->Release();
    }
}

//
//  S_OK means we successfully did a navigation
//  S_FALSE means that we did everything ok, but did not navigate
//  E_* means some internal api failed.
//

HRESULT CDocObjectHost::CDOHBindStatusCallback::_HandleFailedNavigationSearch(
            LPBOOL           pfShouldDisplayError,
            DWORD            dwStatusCode,
            CDocObjectHost * pdoh,
            HRESULT          hrDisplay, 
            TCHAR          * szURL, 
            LPCWSTR          szError, 
            IBinding       * pib,
            BOOL             fAddMRU, /* = TRUE */
            BOOL             fFromTrident /* = FALSE */)
{
    DWORD                dwSearchForExtensions = NO_SUFFIXES;
    DWORD                dwDo404Search = PROMPTSEARCH;
    BOOL                 bAskUser = TRUE;  // rely on init
    BOOL                 bDoSearch = FALSE;  // rely on init
    HRESULT              hres = S_FALSE;
    BOOL                 bSuppressUI = FALSE;
    BOOL                 bFrameIsOffline = FALSE;
    BOOL                 bPrepareForSearch = FALSE;
    DWORD                dwSuffixIndex = 0;
    BOOL                 bAllowSearch = FALSE;
    BOOL                 bContinueSearch = FALSE;
    BOOL                 bSentToEngine = FALSE;
    BOOL                 bOnProxy = FALSE;  
    TCHAR                szSearchFormatStr[MAX_SEARCH_FORMAT_STRING];
    DWORD                dwSearchStyle = 3; // "display search results and navigate to the most likely site"

    ASSERT(pdoh);

#define SAFETRACE(psz)      (psz ? psz : TEXT(""))

    TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() entered status = %d, url = %s, pib = %X", dwStatusCode, SAFETRACE(szURL) , pib);
    if (FAILED(GetSearchKeys(pdoh->_psp, &dwSearchStyle, &dwSearchForExtensions, &dwDo404Search)))
    {
        return E_FAIL;
    }
    
    TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() dwSearch = %d, do404 = %d", dwSearchForExtensions, dwDo404Search);

    // Get any persistent information from the last request
    VARIANT varURL = {0};
    _GetSearchInfo(pdoh->_psp, &dwSuffixIndex, &bAllowSearch, &bContinueSearch, &bSentToEngine, &varURL);

    // See if window.external.autoscan() was called
    BOOL fAutoScan = (varURL.vt == VT_BSTR);

    TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() index = %d, allow = %d, cont = %d, sent = %d", dwSuffixIndex, bAllowSearch, bContinueSearch, bSentToEngine);

    // Why not use the cached value?
    // pdoh->_GetOfflineSilent(&bFrameIsOffline, &bSuppressUI);
    bFrameIsOffline = _bFrameIsOffline ? TRUE : FALSE;
    bSuppressUI = (_bFrameIsSilent || _IsDesktopItem(pdoh)) ? TRUE : FALSE;

    // if we are at the end of the extension list, turn off extensions
    BOOL fAutoSearching = FALSE;
    if (dwSearchForExtensions)
    {
        if (dwSuffixIndex == 0 && dwSearchStyle != 0)
        {
            StrCpyN(szSearchFormatStr, L"? %s", ARRAYSIZE(szSearchFormatStr));
            fAutoSearching = TRUE;
        }
        else if (GetSearchFormatString(dwSuffixIndex, szSearchFormatStr, sizeof(szSearchFormatStr)) != ERROR_SUCCESS)
        {
            dwSearchForExtensions = DONE_SUFFIXES;
            StrCpyN(szSearchFormatStr, TEXT("%s"), ARRAYSIZE(szSearchFormatStr));
        }
    }
    else
    {
        dwSearchForExtensions = DONE_SUFFIXES;
    }

    // don't try a 404 srch if we are still trying suffixes
    if (dwSearchForExtensions == SCAN_SUFFIXES)
        dwDo404Search = NEVERSEARCH;

    {
        DWORD dwOptions;

        if (SUCCEEDED(_GetRequestFlagFromPIB(pib, &dwOptions)))
        {
            if (dwOptions & INTERNET_REQFLAG_VIA_PROXY)
            {
                bOnProxy = TRUE;
            }
        }
        else
        {
            TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() QI to IWinInetInfo failed");
        }
    }

    TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() search = %d, do404 = %d, onproxy = %d, szSearch = %s", dwSearchForExtensions, dwDo404Search, bOnProxy, SAFETRACE(szSearchFormatStr));

    // Prepare to do an automatic search if the navigation failed
    // and we think a search might be valuable.

    // These cases are:
    //   (1) if the previous navigation was search-generated (bContinue)
    //   (2) the user allows searching (bAllow)
    //   (3) we are searching for extensions or autosearching
    //   (4) this is a status code we allow searching for
    //   (5) if over proxy, continue searching even on 404

    // Note: 404 is special; it is the case that most servers return this if
    // the documnet is not there, but Proxies also return this if the server
    // was not found - a conditon which normally makes us search.  This means
    // that a 404 over proxy actually causes a search to occur, which is not
    // what we want.
    // Is there any way I can tell the difference?

    bPrepareForSearch = ((bContinueSearch || (bAllowSearch)) &&
                 (fAutoScan || SHOULD_DO_SEARCH(dwSearchForExtensions, dwDo404Search)) &&
                 DO_SEARCH_ON_STATUSCODE(dwStatusCode) &&
                 (!bOnProxy || pdoh->_fDocCanNavigate || (dwStatusCode == HTTP_STATUS_NOT_FOUND)));

    if (bPrepareForSearch)
    {
        TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() Preparing for Search...");

        HRESULT hr = S_OK;

        // If we don't have the url we are searching, get it from the addressbar
        if (!fAutoScan)
            hr = _GetSearchString(pdoh->_psp, &varURL);

        if (S_OK!=hr && pdoh->_fDocCanNavigate)
        {
            hr = VariantCopy(&varURL, &pdoh->_varUserEnteredUrl);
        }
        
        // If we have completed the autoscan, see if there is a special error page that
        // we should display.
        VARIANT varScanFailure = {0};
        if (SUCCEEDED(hr) &&
            dwSearchForExtensions == DONE_SUFFIXES &&
            SUCCEEDED(_GetScanFailureUrl(pdoh->_psp, &varScanFailure)))
        {
            bDoSearch = TRUE;
        }

        else if (SUCCEEDED(hr) &&
            (dwSearchForExtensions == SCAN_SUFFIXES ||  dwDo404Search == ALWAYSSEARCH)) 
        {
            bDoSearch = TRUE;
        } 
        else 
        {
            bDoSearch = FALSE; 
        }
        bAskUser = FALSE;

        TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() typedurl = %s, ask = %d, dosearch = %d", varURL.bstrVal, bAskUser, bDoSearch);


// Don't prompt user if there is an extension, since we are going to
// not scan anyway.

        if (bDoSearch)
        {
            PARSEDURL pu;

            pu.cbSize = SIZEOF(PARSEDURL);
            if (ParseURL(varURL.bstrVal, &pu) == URL_E_INVALID_SYNTAX)
            {
                // only if this is not a valid URL, should we try to do this searching

                // but try to avoid the case of typos like http;//something.something.com
                // The malformed URL case
                if (!fAutoSearching &&
                    (//StrChrI(varURL.bstrVal, L'.') || 
                     StrChrI(varURL.bstrVal, L'/') ||
                     StrChrI(varURL.bstrVal, L' '))
                    )
                {
                    bAskUser = FALSE;
                    bDoSearch = FALSE;
                }
            }
            else
            {
                bAskUser = FALSE;
                bDoSearch = FALSE;
            }
        }

        TCHAR szT[MAX_URL_STRING + SEARCHPREFIXLENGTH];
        DWORD cchT = SIZECHARS(szT);

        // Bug 35354 has been resolved "not repro" because the dialog below
        // currently cannot ever be displayed (there is no way for bAskUser to
        // be true in the following conditional). If that changes, then that bug
        // needs to get fixed.

        if (bAskUser)
        {
            PrepareURLForDisplay(varURL.bstrVal, szT, &cchT);

            // If we ask the user, make sure we don't display another
            // error dialog.
            *pfShouldDisplayError = FALSE;

            // S_OK means we handled any popups; if we return an error,
            // the caller may display an error dialog
            hres = S_OK;

            if (!bSuppressUI && IDYES == IE_ErrorMsgBox(NULL, pdoh->_hwnd, hrDisplay, szError, szT, IDS_CANTFINDURL, MB_YESNO|MB_ICONSTOP))
            {
                bDoSearch = TRUE;
            }
            else
            {
                _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);  // reset info
                bDoSearch = FALSE;
            }
        }

        if (bDoSearch)
        {
            if (dwSearchForExtensions && dwSearchForExtensions != DONE_SUFFIXES)
            {
                wnsprintf(szT, ARRAYSIZE(szT), szSearchFormatStr, varURL.bstrVal);
                if (!fAutoSearching)
                {
                    _ValidateURL(szT, UQF_DEFAULT);
                }

                if (fAddMRU)
                    _UpdateMRU(pdoh, szT);
            } 
            else if (VT_BSTR == varScanFailure.vt && NULL != varScanFailure.bstrVal)
            {
                StrCpyN(szT, varScanFailure.bstrVal, ARRAYSIZE(szT));
                _ValidateURL(szT, UQF_DEFAULT);
                _DontAddToMRU(pdoh);
            }
            else if (dwDo404Search)
            {
                // add the search prefix
                StrCpyN(szT, TEXT("? "), ARRAYSIZE(szT));
                StrCatBuff(szT, varURL.bstrVal, ARRAYSIZE(szT));
                _DontAddToMRU(pdoh);
            }
            else
            {
                ASSERT(0);
            }

            if (dwSearchForExtensions && dwSearchForExtensions != DONE_SUFFIXES)
                _SetSearchInfo(pdoh, ++dwSuffixIndex, FALSE, TRUE, FALSE);
            else if (dwDo404Search)
                _SetSearchInfo(pdoh, dwSuffixIndex, FALSE, FALSE, TRUE);
            else
                _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);

            // If we're called from Trident (fFromTrident == TRUE), then we're going to call
            // IHTMLPrivateWindow::SuperNavigate().  In that case, the call to _CancelPendingNavigation
            // below needs to be synchronous.  However, if we're going to call _DoAsyncNavigation,
            // then the call to _CancelPendingNavigation needs to remain asynchronous.
            //
            if (!pdoh->_fCanceledByBrowser)
                pdoh->_CancelPendingNavigation(FALSE, fFromTrident);

            TraceMsg(TF_SHDNAVIGATE, "DOH::BSC::_HFNS() Doing search on %s", szT);

            DWORD cchT = SIZECHARS(szT);

            //
            // if we can find a search context living in a host somewhere,
            // then we need to pass that into ParseUrlFromOutsideSource
            // because it'll use it to customize the behavior of
            // the search hooks if a search ends up happening
            //

            ISearchContext *  pSC = NULL;
            pdoh->QueryService(SID_STopWindow, IID_ISearchContext, (void **)&pSC);

            ParseURLFromOutsideSourceWithContextW(szT, szT, &cchT, NULL, pSC);

            if (pSC != NULL)
            {
                pSC->Release();
            }


            if (fFromTrident)
            {
                BSTR  bstrUrl = SysAllocString(szT);
                IHTMLPrivateWindow * pPrivWindow = NULL;

                ASSERT(pdoh->_fDocCanNavigate);
                ASSERT(pdoh->_pHTMLWindow);

                // The navigation state is already reset by cancelpending navigation 
                // causing either trident to cancel pending navigation or by OnStopBinding
                /*
                if (pdoh->_pwb)
                    pdoh->_pwb->SetNavigateState(BNS_NORMAL);
                */

                hres = pdoh->_pHTMLWindow->QueryInterface(IID_IHTMLPrivateWindow,
                                                          (void**)&pPrivWindow);
                if (SUCCEEDED(hres))
                {
                    hres = pPrivWindow->SuperNavigate(bstrUrl, NULL, NULL, NULL, NULL, NULL, 0);
                    pPrivWindow->Release();
                }

                SysFreeString(bstrUrl);
            }
            else
            {
                pdoh->_DoAsyncNavigation(szT);
            }
            
            pdoh->_fCanceledByBrowser = TRUE;
            *pfShouldDisplayError = FALSE;  // Don't display another dialog

            hres = S_OK;  // we did a navigate
        } 

        VariantClear(&varScanFailure);
    }
    else if (bSentToEngine && !bSuppressUI)
    {
        *pfShouldDisplayError = FALSE;
        _SetSearchInfo(pdoh, 0, FALSE, FALSE, FALSE);
        IE_ErrorMsgBox(NULL, pdoh->_hwnd, hrDisplay, szError, szURL, IDS_CANTFINDSEARCH, MB_OK|MB_ICONSTOP);
        hres = S_OK;
    }

    VariantClear(&varURL);

    return hres;

} // _HandleFailedNavigationSearch()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\favband.cpp ===
//
// favband.cpp
//
// favorites band implementation
//

#include "priv.h"
#include "sccls.h"
#include "nscband.h"
#include "resource.h"
#include "favorite.h"
#include "uemapp.h"   // KMTF: Included for instrumentation

#include <mluisupp.h>

#define SUPERCLASS CNSCBand

#define TF_FAVBAND  0

class CFavBand : public CNSCBand
{
public:

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);

protected:
    virtual void _AddButtons(BOOL fAdd);
    HRESULT _BrowserExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    void _OrganizeFavorites();
    virtual BOOL _ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib);
    virtual HRESULT _NavigateRightPane(IShellBrowser *psb, LPCITEMIDLIST pidl);
    virtual HRESULT _TranslatePidl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib);
    friend HRESULT CFavBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

    BOOL       _fStrsAdded;
    LONG_PTR       _lStrOffset;
};

HRESULT CFavBand::_BrowserExec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    return IUnknown_QueryServiceExec(_punkSite, SID_STopLevelBrowser, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

void CFavBand::_OrganizeFavorites()
{
    DoOrganizeFavDlgW(_hwnd, NULL);
}

// *** IOleCommandTarget methods ***
HRESULT CFavBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup && IsEqualGUID(CLSID_FavBand, *pguidCmdGroup))
    {
        TraceMsg(TF_FAVBAND, "CFavBand::Exec CLSID_FavBand -- nCmdID == %x", nCmdID);

        switch(nCmdID)
        {
        case FCIDM_ADDTOFAVORITES:
        {
            _BrowserExec(&CGID_Explorer, SBCMDID_ADDTOFAVORITES, OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
            // Instrument addition to favorites by pane
            UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_ADDTOFAV, UIBL_PANE);     
            return S_OK;
        }

        case FCIDM_ORGANIZEFAVORITES:
        {
            _OrganizeFavorites();
            return S_OK;
        }
        }
    }

    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

static const TBBUTTON c_tbFavorites[] =
{
    {  0, FCIDM_ADDTOFAVORITES,     TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_SHOWTEXT, {0,0}, 0, 0 },
    {  1, FCIDM_ORGANIZEFAVORITES,  TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_SHOWTEXT, {0,0}, 0, 1 },
};

void CFavBand::_AddButtons(BOOL fAdd)
{
    IExplorerToolbar* piet;

    if (SUCCEEDED(_punkSite->QueryInterface(IID_IExplorerToolbar, (void**)&piet)))
    {
        if (fAdd)
        {
            piet->SetCommandTarget((IUnknown*)SAFECAST(this, IOleCommandTarget*), &CLSID_FavBand, 0);

            if (!_fStrsAdded)
            {
                piet->AddString(&CLSID_FavBand, MLGetHinst(), IDS_FAVS_BAR_LABELS, &_lStrOffset);
                _fStrsAdded = TRUE;
            }

            _EnsureImageListsLoaded();
            piet->SetImageList(&CLSID_FavBand, _himlNormal, _himlHot, NULL);

            TBBUTTON tbFavorites[ARRAYSIZE(c_tbFavorites)];
            memcpy(tbFavorites, c_tbFavorites, SIZEOF(TBBUTTON) * ARRAYSIZE(c_tbFavorites));
            for (int i = 0; i < ARRAYSIZE(c_tbFavorites); i++)
                tbFavorites[i].iString += (long) _lStrOffset;

            piet->AddButtons(&CLSID_FavBand, ARRAYSIZE(tbFavorites), tbFavorites);
        }
        else
            piet->SetCommandTarget(NULL, NULL, 0);

        piet->Release();
    }
}

// *** IDockingWindow methods ***
HRESULT CFavBand::ShowDW(BOOL fShow)
{
    HRESULT hres = SUPERCLASS::ShowDW(fShow);
    _AddButtons(fShow);
    return hres;
}


HRESULT CFavBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    CFavBand * pfb = new CFavBand();
    if (!pfb)
        return E_OUTOFMEMORY;

    if (SUCCEEDED(pfb->_Init((LPCITEMIDLIST)CSIDL_FAVORITES)))
    {
        pfb->_pns = CNscTree_CreateInstance();
        if (pfb->_pns)
        {
            ASSERT(poi);
            pfb->_poi = poi;   
            // if you change this cast, fix up CChannelBand_CreateInstance
            *ppunk = SAFECAST(pfb, IDeskBand *);

            IUnknown_SetSite(pfb->_pns, *ppunk);
            pfb->_SetNscMode(MODE_FAVORITES);
            return S_OK;
        }
    }
    pfb->Release();

    return E_FAIL;
}

HRESULT CFavBand::_TranslatePidl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib)
{
    HRESULT hr = E_INVALIDARG;

    if (pidl && ppidlTarget && pulAttrib)
    {
        hr = IEGetAttributesOf(pidl, pulAttrib);
        if (SUCCEEDED(hr))
        {
            hr = SHILClone(pidl, ppidlTarget);
        }
    }
    
    return hr;
}

BOOL CFavBand::_ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib)
{
    return !(ulAttrib & SFGAO_FOLDER);
}

HRESULT CFavBand::_NavigateRightPane(IShellBrowser *psb, LPCITEMIDLIST pidl)
{
    HRESULT hr = E_INVALIDARG;

    if (psb && pidl)
    {
        TCHAR szPath[MAX_PATH];

        hr = SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL);
        if (SUCCEEDED(hr))
        {
            hr = NavFrameWithFile(szPath, psb);
            if (FAILED(hr))
            {
                IShellFolder *psf;
                LPCITEMIDLIST pidlLast;
                if (SUCCEEDED(SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast)))
                {
                    LPITEMIDLIST pidlTarget;
                    if (SUCCEEDED(SHGetNavigateTarget(psf, pidlLast, &pidlTarget, NULL)))
                    {
                        hr = psb->BrowseObject(pidlTarget, SBSP_SAMEBROWSER);
                        ILFree(pidlTarget);
                    }
                    psf->Release();
                }
            }
                
            if (SUCCEEDED(hr))
            {
                UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_NAVIGATE, UIBL_NAVFAVS);
                UEMFireEvent(&UEMIID_BROWSER, UEME_RUNPIDL, UEMF_XEVENT, (WPARAM)NULL, (LPARAM)pidl);
                SHSendChangeMenuNotify(NULL, SHCNEE_PROMOTEDITEM, 0, pidl);
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\favorite.cpp ===
#include "priv.h"

#include <mstask.h>
#include "favorite.h"
#include "iehelpid.h"
#include "webcheck.h"
#include "chanmgr.h"
#include "chanmgrp.h"
#include "resource.h"
#include <platform.h>
#include <mobsync.h>
#include <mobsyncp.h>

#include <mluisupp.h>


UINT IE_ErrorMsgBox(IShellBrowser* psb,
                    HWND hwndOwner, HRESULT hrError, LPCWSTR szError, LPCTSTR pszURLparam,
                    UINT idResource, UINT wFlags);
void ReplaceTransplacedControls (HWND hDlgMaster, HWND hDlgTemplate);

///////////////////////////////////////////////////////////////////////
// helper function for DoOrganizeFavDlgEx
// the org favs dialog returns a list of null terminated strings containing
//   all the urls to update.
void OrgFavSynchronize(HWND hwnd, VARIANT *pvarUrlsToSynch)
{
#ifndef DISABLE_SUBSCRIPTIONS

    ASSERT(pvarUrlsToSynch);
    
    //if there are no urls to update, it's an empty string so bail
    if ( (pvarUrlsToSynch->vt == VT_BSTR) && (pvarUrlsToSynch->bstrVal) &&
         *(pvarUrlsToSynch->bstrVal) )
    {
        PWSTR pwzUrls = pvarUrlsToSynch->bstrVal;

        ISubscriptionMgr *psm;

        if (SUCCEEDED(JITCoCreateInstance(CLSID_SubscriptionMgr, NULL,
                              CLSCTX_INPROC_SERVER, IID_ISubscriptionMgr,
                              (void**)&psm, hwnd, FIEF_FLAG_FORCE_JITUI)))
        {
            //SysStringLen doesn't look at the string contents, just the cb of the alloc
            while (pwzUrls < (pvarUrlsToSynch->bstrVal + SysStringLen(pvarUrlsToSynch->bstrVal)))
            {
                psm->UpdateSubscription(pwzUrls);
                pwzUrls += lstrlenW(pwzUrls) + 1;
            }

            psm->Release();
        }
    }
#endif /* !DISABLE_SUBSCRIPTIONS */
}


/*
 * DoOrganizeFavDlgEx
 *
 * HWND hwnd             Owner window for the dialog.
 * LPWSTR pszInitDir     Dir to use as root. if null, the user's favorites dir is used.
 *
 * Returns:
 *  BOOL.  TRUE if succeeds. FALSE otherwise.
 *
 */

BOOL WINAPI DoOrganizeFavDlgEx(HWND hwnd, LPWSTR pszInitDir)
{
    // The easy answer would be to add an about:OrganizeFavorites that
    // gets registered in our selfreg.inx file.  Unfortunately, multilanguage
    // support requires us to generate the URL on the fly.

    WCHAR wszUrl[6 + MAX_PATH + 11 + 1]; // "res://MAX_PATH/orgfav.dlg"

    StringCchCopy(wszUrl, ARRAYSIZE(wszUrl), L"res://");
    
    if(SUCCEEDED(GetModuleFileNameWrapW(MLGetHinst(), wszUrl + 6, MAX_PATH)))
    {
        if(SUCCEEDED(StringCchCat(wszUrl, ARRAYSIZE(wszUrl), L"/orgfav.dlg")))
        {
            IMoniker *pmk;
            if (SUCCEEDED(CreateURLMoniker(NULL, wszUrl, &pmk)))
            {
                ASSERT(pmk);
                VARIANT varUrlsToSynch, varInitialDir;
                BSTR    bstrInitDir;

                VariantInit(&varUrlsToSynch);
                VariantInit(&varInitialDir);

                if (pszInitDir)
                {
                    bstrInitDir = SysAllocString(pszInitDir);
                    if (bstrInitDir)
                    {
                        varInitialDir.vt = VT_BSTR;
                        varInitialDir.bstrVal = bstrInitDir;
                    }
                }
                
                ShowHTMLDialog(hwnd, pmk, &varInitialDir, L"Resizable=1", &varUrlsToSynch);
                OrgFavSynchronize(hwnd, &varUrlsToSynch);

                if (pszInitDir && bstrInitDir)
                    SysFreeString(bstrInitDir);
                VariantClear(&varUrlsToSynch);
                pmk->Release();
                return TRUE;
            }
            else
                return FALSE;
        }
    }

    return FALSE;
}



/*
 * DoOrganizeFavDlg
 *
 * This API is exported so that it may be called by explorer and mshtml in
 * addition to being called internally by shdocvw.
 *
 * HWND   hwndOwner       Owner window for the dialog.
 * LPWSTR pszInitDir      Dir to use as root. if null, the user's favorites dir is used.
 *
 * Returns:
 *  BOOL.  TRUE if succeeds. FALSE otherwise.
 *
 */

BOOL WINAPI DoOrganizeFavDlg(HWND hwnd, LPSTR pszInitDir)
{
    BOOL fRet;
    WCHAR szInitDir[MAX_PATH];

    if (pszInitDir)
    {
        SHAnsiToUnicode(pszInitDir, szInitDir, ARRAYSIZE(szInitDir));
        fRet = DoOrganizeFavDlgEx(hwnd, szInitDir);
    }
    else
    {
        fRet = DoOrganizeFavDlgEx(hwnd, NULL);
    }

    return fRet;
}

BOOL WINAPI DoOrganizeFavDlgW(HWND hwnd, LPWSTR pszInitDir)
{
    return DoOrganizeFavDlgEx(hwnd, pszInitDir);
}


#define ADDTOFAVPROP TEXT("SHDOC_ATFPROP")

typedef enum { ATF_FAVORITE,
               ATF_CHANNEL,
               ATF_CHANNEL_MODIFY,
               ATF_CHANNEL_SOFTDIST
} FAVDLGTYPE;

typedef struct _ADDTOFAV
{
    PTSTR pszInitDir;
    UINT cchInitDir;
    PTSTR pszFile;
    UINT cchFile;
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlSelected;
    LPCITEMIDLIST pidlFavorite;
    FAVDLGTYPE iDlgType;
    SUBSCRIPTIONINFO siSubsInProg;
    SUBSCRIPTIONTYPE subsType;
    BOOL bIsSoftdist;
    BOOL bStartSubscribed;
    BOOL bSubscribed;
} ADDTOFAV;

BOOL IsSubscribed(ADDTOFAV *patf);

typedef struct _BFFFavSubStruct
{
    WNDPROC lpfnOldWndProc;
    HWND hwndNew;
    HWND hwndTV;
    HWND hwndSave;
    HWND hTemplateWnd;
    ADDTOFAV * patf;
    RECT rcRestored;
} BFFFAVSUBSTRUCT;

BOOL_PTR CALLBACK NewFavDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
    {
        HWND hwnd;
        ASSERT(lParam);
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
        // cross-lang platform support
        SHSetDefaultDialogFont(hDlg, IDD_NAME);
        hwnd = GetDlgItem(hDlg, IDD_NAME);
        SendMessage(hwnd, EM_LIMITTEXT, MAX_PATH - 1, 0);
        EnableOKButtonFromID(hDlg, IDD_NAME);
        break;
    }    
    case WM_DESTROY:
        SHRemoveDefaultDialogFont(hDlg);
        return FALSE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_NAME:
            {
                if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_UPDATE)
                {
                    LPTSTR lpstrName = (LPTSTR) GetWindowLongPtr(hDlg, DWLP_USER);
                    EnableOKButtonFromID(hDlg, IDD_NAME);
                    GetDlgItemText(hDlg, IDD_NAME, lpstrName, MAX_PATH);
                }
                break;
            }

        case IDOK:
        {
            TCHAR  szTmp[MAX_PATH];
            HRESULT hr = StringCchCopy(szTmp, ARRAYSIZE(szTmp), (LPTSTR)GetWindowLongPtr(hDlg, DWLP_USER));

            if(FAILED(hr) || PathCleanupSpec(NULL,szTmp))
            {
               HWND hwnd;

             MLShellMessageBox(
                             hDlg,
                             MAKEINTRESOURCE(IDS_FAVS_INVALIDFN),
                             MAKEINTRESOURCE(IDS_FAVS_ADDTOFAVORITES),
                             MB_OK | MB_ICONHAND);
             hwnd = GetDlgItem(hDlg, IDD_NAME);
             SetWindowText(hwnd, TEXT('\0'));
             EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
             SetFocus(hwnd);
             break;
            }
        }
        // fall through

        case IDCANCEL:
            EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// BOGUS - these id's stolen from SHBrowseForFolder implementation
#define IDD_FOLDERLIST 0x3741
#define IDD_BROWSETITLE 0x3742
#define IDD_BROWSESTATUS 0x3743

const static DWORD aAddToFavHelpIDs[] = {  // Context Help IDs
    IDC_FAVORITE_DESC,          NO_HELP,
    IDD_BROWSETITLE,            NO_HELP,
    IDD_BROWSESTATUS,           NO_HELP,
    IDC_FAVORITE_ICON,          NO_HELP,
    IDC_NAMESTATIC,             IDH_NAMEEDIT,
    IDC_FOLDERLISTSTATIC,       IDH_BROWSELIST,
    IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER,     IDH_BROWSELIST,
    IDC_FAVORITE_NEWFOLDER,     IDH_CREATEIN,
    IDC_SUBSCRIBE_CUSTOMIZE,    IDH_CHANNEL_SUBSCR_CUST_BUTTON,
    IDC_FAVORITE_CREATEIN,      IDH_NEWFOLDER,
    IDC_FAVORITE_NAME,          IDH_NAMEEDIT,
    IDC_MAKE_OFFLINE,           IDH_MAKE_AVAIL_OFFLINE,
    0, 0
};

const static DWORD aAddToChanHelpIDs[] = {  // Context Help IDs
    IDC_FAVORITE_DESC,          NO_HELP,
    IDD_BROWSETITLE,            NO_HELP,
    IDD_BROWSESTATUS,           NO_HELP,
    IDC_FAVORITE_ICON,          NO_HELP,
    IDC_NAMESTATIC,             IDH_NAMEEDIT,
    IDC_FOLDERLISTSTATIC,       IDH_BROWSELIST,
    IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER,     IDH_BROWSELIST,
    IDC_FAVORITE_NEWFOLDER,     IDH_CREATEIN,
    IDC_SUBSCRIBE_CUSTOMIZE,    IDH_CHANNEL_SUBSCR_CUST_BUTTON,
    IDC_FAVORITE_CREATEIN,      IDH_NEWFOLDER,
    IDC_FAVORITE_NAME,          IDH_NAMEEDIT,
    IDC_MAKE_OFFLINE,           IDH_MAKE_AVAIL_OFFLINE,
    0, 0
};

/*
 * Makes sure the item being added to favorites doesn't already exist.  If it does,
 * puts up a message box to have the user confirm whether they want to overwrite
 * the old favorite or not.  
*/
BOOL ConfirmAddToFavorites(HWND hwndOwner, ADDTOFAV * patf)
{
    BOOL fRet = FALSE;
    BOOL fExists;
    int iPromptString = 0;

    if (patf->subsType == SUBSTYPE_CHANNEL)
    {
        //patf->pszInitDir now contains the path with a .url on the end; the channel
        //will be stored in a directory of that name without .url.  Strip it.
        TCHAR szPath[MAX_PATH];
        if(FAILED(StringCchCopy(szPath,  ARRAYSIZE(szPath), patf->pszInitDir)))
        {
             MLShellMessageBox(
                             hwndOwner,
                             MAKEINTRESOURCE(IDS_FAVS_INVALIDFN),
                             MAKEINTRESOURCE(IDS_FAVS_ADDTOFAVORITES),
                             MB_OK | MB_ICONHAND);

            return FALSE;
        }

        PathRemoveExtension (szPath);
        fExists = PathFileExists(szPath);

        iPromptString = IDS_CHANNELS_FILEEXISTS;

    }
    else
    {
        fExists = PathFileExists(patf->pszInitDir);
        iPromptString = IDS_FAVS_FILEEXISTS;

    }

    fRet = ! fExists ||
        (MLShellMessageBox(
                         hwndOwner,
                         MAKEINTRESOURCE(iPromptString),
                         NULL,    //use owner's title
                         MB_ICONQUESTION | MB_YESNO) == IDYES);
    return fRet;
}

//
// Get the localized date and time
//

typedef HRESULT (*PFVARIANTTIMETOSYSTEMTIME)(DOUBLE, LPSYSTEMTIME);


//
// Subscribe to the current site.
//

HRESULT SubscribeToSite(HWND hwnd, LPCTSTR pszFile, LPCITEMIDLIST pidl, DWORD dwFlags,
                        SUBSCRIPTIONINFO* pSubs, SUBSCRIPTIONTYPE subsType)
{
#ifndef DISABLE_SUBSCRIPTIONS

    TCHAR szURL[MAX_URL_STRING];
    ISubscriptionMgr *pISubscriptionMgr;

    //
    // Get a displayable URL.
    //

    IEGetDisplayName(pidl, szURL, SHGDN_FORPARSING);

    //
    // Get a pointer to the subscription manager.
    //

    HRESULT hr = JITCoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_ISubscriptionMgr,
                          (void**)&pISubscriptionMgr, hwnd, FIEF_FLAG_FORCE_JITUI);

    if (SUCCEEDED(hr)) 
    {
        //
        // Create a default subscription.
        //
        BSTR bstrURL = SysAllocStringT(szURL);
        if (bstrURL) 
        {
            BSTR bstrName = SysAllocStringT(pszFile);
            if (bstrName) 
            {
                hr = pISubscriptionMgr->CreateSubscription(hwnd, 
                    bstrURL, bstrName, dwFlags, subsType,  pSubs);
                SysFreeString(bstrName);
            }
            SysFreeString(bstrURL);
        }

        //
        // Clean up.
        //

        pISubscriptionMgr->Release();
    }

    return hr;
#else  /* !DISABLE_SUBSCRIPTIONS */

    return E_FAIL;

#endif /* !DISABLE_SUBSCRIPTIONS */
}


//
// Create in-memory subscription, but only optionally save it to subscription manager
//

BOOL StartSiteSubscription (HWND hwnd, ADDTOFAV* patf, BOOL bFinalize)
{
#ifndef DISABLE_SUBCRIPTIONS

    //update the changes-only flag (radio buttons here are, effectively, direct access to this flag)
    if (patf->subsType == SUBSTYPE_CHANNEL || patf->subsType == SUBSTYPE_DESKTOPCHANNEL)
    {
        //if set, leave alone; otherwise, put to full download
        if (!(patf->siSubsInProg.fChannelFlags & CHANNEL_AGENT_PRECACHE_SOME))
            patf->siSubsInProg.fChannelFlags |= CHANNEL_AGENT_PRECACHE_ALL;

        patf->siSubsInProg.fUpdateFlags |= SUBSINFO_CHANNELFLAGS | SUBSINFO_SCHEDULE;
    }

    if (S_OK != SubscribeToSite(hwnd, patf->pszFile, patf->pidlFavorite,
                                   bFinalize ? CREATESUBS_NOUI | CREATESUBS_FROMFAVORITES : CREATESUBS_NOSAVE,
                                   &patf->siSubsInProg, patf->subsType))
    {
        return FALSE;
    }

    return TRUE;

#else  /* !DISABLE_SUBSCRIPTIONS */

    return FALSE;

#endif /* !DISABLE_SUBSCRIPTIONS */
}

/*
   Combines the path and the filename of the favorite
   and puts it into patf->pszInitDir, so that it has the fully qualified pathname.
*/
#define SZ_URLEXT    TEXT(".url")
#define CCH_URLEXT   SIZECHARS(SZ_URLEXT)

BOOL QualifyFileName(ADDTOFAV *patf)
{
    TCHAR szTemp[MAX_PATH];
    BOOL fRet = FALSE;
    LPTSTR  pstr;

    // Can we safely add the extension to this?
    if (lstrlen(patf->pszFile) < (int)(patf->cchFile - CCH_URLEXT))
    {
        //Add extension .url if its not already there
        //This is to prevent strings like "com"  in "www.microsoft.com" from being interpreted as extensions

        pstr = PathFindExtension(patf->pszFile);
        if (!pstr || (pstr && StrCmpI(pstr, SZ_URLEXT)))// && StrCmpI(pstr, SZ_CDFEXT)))
        {
            if(FAILED(StringCchCat(patf->pszFile, patf->cchFile, SZ_URLEXT)))
                return FALSE;
        }
            
        // Is there a folder associated with the filename?
        if (patf->pidlSelected && SHGetPathFromIDList(patf->pidlSelected, szTemp)) 
        {
            // Yes
            if (PathCombine(szTemp, szTemp, patf->pszFile))
            {
                if ((UINT)lstrlen(szTemp) < patf->cchInitDir)
                {
                    if(SUCCEEDED(StringCchCopy(patf->pszInitDir,  patf->cchInitDir, szTemp)))
                        fRet = TRUE;
                }
            }
        }
    }

    return fRet;
}


BOOL SubscriptionFailsChannelAuthentication (HWND hDlg, SUBSCRIPTIONINFO* psi)
{
#ifndef DISABLE_SUBSCRIPTIONS  

    if (psi->bNeedPassword && !(psi->bstrPassword && psi->bstrPassword[0]
                             && psi->bstrUserName && psi->bstrUserName[0]))
    {   //password would be required
        if (IsDlgButtonChecked (hDlg, IDC_MAKE_OFFLINE))
        {   //they're trying to subscribe...  WRONG!
            MLShellMessageBox(
                hDlg,
                MAKEINTRESOURCE(IDS_NEED_CHANNEL_PASSWORD),
                NULL,
                MB_ICONINFORMATION | MB_OK);
            return TRUE;
        }
    }

    return FALSE;

#else  /* !DISABLE_SUBSCRIPTIONS */

    return FALSE;

#endif /* !DISABLE_SUBSCRIPTIONS */
}


LRESULT CALLBACK BFFFavSubclass(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BFFFAVSUBSTRUCT * pbffFS = (BFFFAVSUBSTRUCT *)GetProp(hwnd, ADDTOFAVPROP);
    WNDPROC lpfnOldWndProc = pbffFS->lpfnOldWndProc;
    RECT rc;

    switch (uMsg) {
        case WM_COMMAND:
            // Intercept the command for the New Folder button we hacked into
            // the SHBrowseForFolder dialog.
            switch (GET_WM_COMMAND_ID(wParam, lParam)) {
            case IDC_FAVORITE_NAME:
            {
                HWND hwndedit;
                if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) 
                    EnableOKButtonFromID(hwnd, IDC_FAVORITE_NAME);
                hwndedit = GetDlgItem(hwnd, IDC_FAVORITE_NAME);
                SendMessage(hwndedit, EM_LIMITTEXT, MAX_PATH - 1, 0);
                break;
            }    

            case IDC_MAKE_OFFLINE:
                EnableWindow(GetDlgItem(hwnd, IDC_SUBSCRIBE_CUSTOMIZE), 
                             IsDlgButtonChecked(hwnd, IDC_MAKE_OFFLINE));
                break;

            case IDC_SUBSCRIBE_CUSTOMIZE:
                //need to create -- but not store -- subscription
                if (StartSiteSubscription (hwnd, pbffFS->patf, FALSE))
                    SendMessage (hwnd, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hwnd, IDOK), TRUE);
                break;

            case IDC_FAVORITE_NEWFOLDER:
                TCHAR szPath[MAX_PATH];
                TCHAR szName[MAX_PATH];
                HWND hwndTV;
                TV_ITEM tv_item;

                // Bring up the Create New Folder dialog
                if ((DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_NEWFOLDER), hwnd,
                    NewFavDlgProc, (LPARAM)szName) == IDOK) &&
                    (SHGetPathFromIDList(pbffFS->patf->pidlSelected, szPath)) &&
                    ((lstrlen(szPath) + lstrlen(szName) + 1) < MAX_PATH))
                {
                    PathCombine(szPath, szPath, szName);

                    BOOL bSuccess = FALSE;

#ifdef CREATEFOLDERSINCHANNELSDIR
                    if (pbffFS->patf->subsType == SUBSTYPE_CHANNEL)
                    {
                        ASSERT(0);  //should not be possible in this release
                                    //(I removed this button in the .rc dialogs for channels)

                        //Note: to make this work in a future release, reenable this code -- it's
                        //functional.  But the folders created here show up ugly in the channel bar
                        //(just a default folder icon) and if you click on them, you get a shell
                        //Explorer window instead of a theater-mode browser window.  The reason
                        //for this second happening is that the desktop.ini file created in the new
                        //folder has no URL=.  To remedy this: AddCategory() has to be fixed so it
                        //doesn't interpret the pszURL argument as a UNC name (I was using a resouce moniker
                        //pointing into cdfview.dll for the html target), and the OC hosted by the default
                        //html pages has to learn how to be hosted from a html page without a path -- or we
                        //actually have to create an html page in the new directory, which is messy.
                        IChannelMgr* pChanMgr;
                        HRESULT hr;

                        hr = JITCoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER,
                                              IID_IChannelMgr, (void**)&pChanMgr, 
                                              hwnd, FIEF_FLAG_FORCE_JITUI);

                        if (SUCCEEDED(hr))
                        {
                            IChannelMgrPriv* pChanMgrPriv;
                            hr = pChanMgr->QueryInterface (IID_IChannelMgrPriv, (void**)&pChanMgrPriv);
                            if (SUCCEEDED(hr))
                            {
                                char szCFPath[MAX_PATH];
                                WCHAR wszFolder[MAX_PATH];
                                IChannelMgrPriv::CHANNELFOLDERLOCATION cflLocation =
                                    (pbffFS->patf->iDlgType == ATF_CHANNEL_SOFTDIST ?
                                        IChannelMgrPriv::CF_SOFTWAREUPDATE :
                                        IChannelMgrPriv::CF_CHANNEL);
                                hr = pChanMgrPriv->GetChannelFolderPath (szCFPath, ARRAYSIZE(szCFPath), cflLocation);

                                int cchCommon = PathCommonPrefix (szPath, szCFPath, NULL);
                                AnsiToUnicode (szPath + cchCommon, wszFolder, ARRAYSIZE(wszFolder));

                                CHANNELCATEGORYINFO info = {0};
                                info.cbSize = sizeof(info);
                                info.pszTitle = wszFolder;
                                bSuccess = SUCCEEDED (pChanMgr->AddCategory (&info));

                                pChanMgrPriv->Release();
                            }

                            pChanMgr->Release();
                        }
                    }
                    else
#endif
                    {
                        bSuccess = CreateDirectory(szPath, NULL);
                    }

                    if (bSuccess)
                    {
                        // This code assumes the layout of SHBrowseForFolder!

                        // directory successfully created, must notify registered shell components.
                        SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, szPath, NULL);
                        // Get the TreeView control
                        hwndTV = GetDlgItem(hwnd, IDD_FOLDERLIST);
                        if (hwndTV) {
                            HTREEITEM hti = TreeView_GetSelection(hwndTV);
                            // Take the selected item and reset it, then reexpand it so
                            // that it shows the new directory we just created.
                            tv_item.mask = TVIF_CHILDREN;
                            tv_item.hItem = hti;
                            tv_item.cChildren = -1;
                            TreeView_SetItem(hwndTV, &tv_item);
                            TreeView_Expand(hwndTV, hti, TVE_COLLAPSE | TVE_COLLAPSERESET);
                            TreeView_Expand(hwndTV, hti, TVE_EXPAND);

                            // Find the new directory we just created and select it by
                            // walking the tree from the selected item down.
                            if (hti = TreeView_GetChild(hwndTV, hti)) {
                                tv_item.mask = TVIF_TEXT;
                                tv_item.pszText = szPath;
                                tv_item.cchTextMax = MAX_PATH;
                                do {
                                    tv_item.hItem = hti;
                                    TreeView_GetItem(hwndTV, &tv_item);
                                    if (StrCmp(szName, szPath) == 0) {
                                        TreeView_Select(hwndTV, hti, TVGN_CARET);
                                        break;
                                    }
                                } while (hti = TreeView_GetNextSibling(hwndTV, hti));
                            }
                            SetFocus(hwndTV);
                        }
                    } else {
                        
                        LPVOID lpMsgBuf;
                        
                        if(FormatMessage( 
                            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                            NULL,
                            GetLastError(),
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                            (LPTSTR) &lpMsgBuf,
                            0,
                            NULL 
                            ))
                        {
                            MLShellMessageBox(
                                            hwnd,
                                            (LPCTSTR)lpMsgBuf,
                                            MAKEINTRESOURCE(IDS_FAVS_ADDTOFAVORITES),
                                            MB_ICONINFORMATION | MB_OK);
                            
                            // Free the buffer.
                            LocalFree( lpMsgBuf );
                        }
                        lpMsgBuf = NULL;                        
                    }
                }
                break;

            case IDOK:
                // first, make sure they're not trying to subscribe to an authenticated
                // channel without entering a password.
                if (SubscriptionFailsChannelAuthentication (hwnd, &pbffFS->patf->siSubsInProg))
                    return FALSE;

                // Retrieve the text from the Name edit control.
                GetDlgItemText(hwnd, IDC_FAVORITE_NAME, pbffFS->patf->pszFile, pbffFS->patf->cchFile);
                { // Just  a block to declare variables
                    BOOL fTooBig = TRUE;        // assume failure
                    TCHAR  szTmp[MAX_PATH];
                                       
                    if (lstrlen(pbffFS->patf->pszFile) < MAX_PATH)
                    {
                        if(FAILED((StringCchCopy(szTmp, ARRAYSIZE(szTmp), pbffFS->patf->pszFile))))
                            return FALSE;

                        // PathCleanupSpec deals with MAX_PATH buffers, so we should be fine
                        if (PathCleanupSpec(NULL, szTmp))
                        {
                            MLShellMessageBox(
                                            hwnd,
                                            MAKEINTRESOURCE(IDS_FAVS_INVALIDFN),
                                            MAKEINTRESOURCE(IDS_FAVS_ADDTOFAVORITES),
                                            MB_OK | MB_ICONHAND);
                            return FALSE;
                        }
                                       
                        // Make sure the name is unique and if not, that the user has
                        // specified that it is OK to override.
                        if (QualifyFileName(pbffFS->patf))
                        {
                            if (!ConfirmAddToFavorites(hwnd, pbffFS->patf))
                                return FALSE;

                            //  Bogus hack since the ATF stuff is only half done
                            //  Depending on which dlg is shown, look for the appropriate
                            //  check.
                            if (IsDlgButtonChecked (hwnd, IDC_MAKE_OFFLINE))
                            {
                               //they want to subscribe!  save subscription we already have in memory
                                //trouble is, pbffFS->patf->pszFile ends in a bogus .url
                                TCHAR* pszTemp = pbffFS->patf->pszFile;
                                TCHAR szNoExt[MAX_PATH];
                                if(FAILED((StringCchCopy(szNoExt, ARRAYSIZE(szNoExt), pbffFS->patf->pszFile))))
                                    return FALSE;

                                pbffFS->patf->pszFile = szNoExt;
                                PathRemoveExtension (szNoExt);
                                pbffFS->patf->bSubscribed = 
                                    StartSiteSubscription (hwnd, pbffFS->patf, TRUE);
                                pbffFS->patf->pszFile = pszTemp;
                            }
                            else if (pbffFS->patf->bStartSubscribed)
                            {
                                //  If we started subscribed and they unchecked make available
                                //  offline, then delete the subscription.

                                ISubscriptionMgr* pSubsMgr;
                                if (SUCCEEDED (CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                                                                IID_ISubscriptionMgr, (void**)&pSubsMgr)))
                                {
                                    //url is in patf->pidlFavorite
                                    WCHAR wszURL[MAX_URL_STRING];
                                    IEGetDisplayName(pbffFS->patf->pidlFavorite, wszURL, SHGDN_FORPARSING);

                                    pSubsMgr->DeleteSubscription(wszURL, NULL);
                                    pSubsMgr->Release();
                                }
                            }

                            // Enable and set focus to the tree view so that it is sure to
                            // be selected so that SHBrowseForFolder will return a pidl.
                            EnableWindow(pbffFS->hwndTV, TRUE);
                            SetFocus(pbffFS->hwndTV);
                            fTooBig = FALSE;
                        }
                    }


                    if (fTooBig)
                    {
                        MLShellMessageBox(
                                        hwnd,
                                        MAKEINTRESOURCE(IDS_FAVS_FNTOOLONG),
                                        MAKEINTRESOURCE(IDS_FAVS_ADDTOFAVORITES),
                                        MB_OK | MB_ICONHAND);
                        return FALSE;
                    }
                }
                break;

            case IDC_FAVORITE_CREATEIN:
                // The advanced button has been clicked.  Enable/disable the tree view
                // and New button, set focus to the tree view or ok button, disable the advanced
                // button and then resize the dialog.
            {
                BOOL fExpanding = !IsWindowEnabled(GetDlgItem(hwnd, IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER)); //random control that gets enabled when dialog expanded
                TCHAR szBuffer[100];

                EnableWindow(pbffFS->hwndTV, fExpanding);
                //don't show New Folder button for channels in the channels folder,
                // see code for case IDC_FAVORITE_NEWFOLDER for why
                if (fExpanding && pbffFS->patf->subsType == SUBSTYPE_CHANNEL)
                {
                    LPITEMIDLIST pidlFavs = NULL;
                    TCHAR tzFavsPath[MAX_PATH];
                
                    if (SUCCEEDED(SHGetSpecialFolderLocation(hwnd, CSIDL_FAVORITES, &pidlFavs)) 
                    &&  SUCCEEDED(SHGetNameAndFlags(pidlFavs, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, tzFavsPath, SIZECHARS(tzFavsPath), NULL))
                    &&  StrCmpNI(tzFavsPath, pbffFS->patf->pszInitDir, ARRAYSIZE(tzFavsPath))==0)
                    {
                        EnableWindow(pbffFS->hwndNew, TRUE);
                    }
                    if(pidlFavs)
                        ILFree(pidlFavs);
                }
                else
                    EnableWindow(pbffFS->hwndNew, fExpanding);

                GetWindowRect(hwnd, &rc);
                if (fExpanding)
                {
                    int lRet = MLLoadString(IDS_FAVS_ADVANCED_COLLAPSE, szBuffer, ARRAYSIZE(szBuffer));
                    ASSERT(lRet);
                    
                    SetFocus(pbffFS->hwndTV);

                    MoveWindow(hwnd, rc.left, rc.top,
                        pbffFS->rcRestored.right - pbffFS->rcRestored.left,
                        pbffFS->rcRestored.bottom - pbffFS->rcRestored.top, TRUE);
                }
                else
                {
                    int lRet = MLLoadString(IDS_FAVS_ADVANCED_EXPAND, szBuffer, ARRAYSIZE(szBuffer));
                    ASSERT(lRet);
                    
                    SetFocus(GetDlgItem(hwnd, IDC_FAVORITE_NAME));

                    MoveWindow(hwnd, rc.left, rc.top,
                        pbffFS->rcRestored.right - pbffFS->rcRestored.left,
                        pbffFS->rcRestored.bottom - pbffFS->rcRestored.top, TRUE);

                    // hide the bottom part of the dialog
                    int cx, cy;
                    RECT rc;
                    GetWindowRect (GetDlgItem (hwnd, IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER), &rc);
                    cy = rc.top;
                    GetWindowRect (hwnd, &rc);
                    cx = rc.right - rc.left;
                    cy = cy /*top of ctrl*/ - rc.top; /*top of window*/
                    SetWindowPos (hwnd, NULL, 0, 0, cx, cy, SWP_NOMOVE | SWP_NOZORDER);
                }
                SetWindowText(GetDlgItem(hwnd, IDC_FAVORITE_CREATEIN), szBuffer);

                break;
            }
            }
            break;

        case WM_DESTROY:
        {
            DWORD dwValue = IsWindowEnabled(GetDlgItem(hwnd, IDC_FAVORITE_NEWFOLDER)); //random control that gets enabled when dialog expanded

            SHRegSetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), TEXT("AddToFavoritesExpanded"),
                REG_DWORD, &dwValue, 4, SHREGSET_HKCU | SHREGSET_FORCE_HKCU);
            ReplaceTransplacedControls (hwnd, pbffFS->hTemplateWnd);
            DestroyWindow (pbffFS->hTemplateWnd);
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) lpfnOldWndProc);
            RemoveProp(hwnd, ADDTOFAVPROP);
            SHRemoveDefaultDialogFont(hwnd);
            ILFree(pbffFS->patf->pidlSelected);
            LocalFree((HLOCAL)pbffFS);
            pbffFS = NULL;
            break;
        }
        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                HELP_WM_HELP, (DWORD_PTR)(LPTSTR) (pbffFS->patf->iDlgType == ATF_FAVORITE
                                ? aAddToFavHelpIDs : aAddToChanHelpIDs));
            return TRUE;
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND) wParam, c_szHelpFile, HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID) (pbffFS->patf->iDlgType == ATF_FAVORITE
                             ? aAddToFavHelpIDs : aAddToChanHelpIDs));
            return TRUE;
            break;

    }

    return CallWindowProc(lpfnOldWndProc, hwnd, uMsg, wParam, lParam);
}


static const TCHAR szTransplacedProp[] = TEXT("tp");
void ReplaceTransplacedControls (HWND hDlgMaster, HWND hDlgTemplate)
{
    /*
     * This function moves the controls that we moved from our temporary
     * dialog over to SHBrowseForFolder's dialog, back to their original
     * home, before they get destroyed.  This is because otherwise we have
     * problems when destroying the template dialog -- specifically, we get
     * a GP fault in user.exe when destroying the edit control, because it
     * looks to its parent window to figure out where its data segment is.
     *
     * Solution: (for safety) -- put everything back where it came from.
     * Other possibilities: just move the edit control (by ID) back, or
     *       move all edit controls back, or use DS_LOCALEDIT for edit controls
     *       (but this is documented only for use with multiline edits.)
     *       Or modify SHBrowseForFolder to allow other dialog templates...
     *       but that's over in shell32.
     */
    HWND hCtrl = GetWindow (hDlgMaster, GW_CHILD);
    while (hCtrl)
    {
        HWND hNext = GetWindow (hCtrl, GW_HWNDNEXT);

        if (GetProp (hCtrl, szTransplacedProp) != NULL)
        {
            RemoveProp (hCtrl, szTransplacedProp);
            SetParent (hCtrl, hDlgTemplate);
        }

        hCtrl = hNext;
    }
}

#define szOriginalWND TEXT("WorkaroundOrigWndProc")
INT_PTR CALLBACK MergeFavoritesDialogControls(HWND hDlgTemplate, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
    {
        HWND hDlgMaster = (HWND)lParam;
        ASSERT (IsWindow (hDlgMaster));

        TCHAR szT[200];
        RECT rc;

        //resize master like us
        GetWindowText (hDlgTemplate, szT, ARRAYSIZE(szT));
        SetWindowText (hDlgMaster, szT);
        GetClientRect (hDlgTemplate, &rc);
        AdjustWindowRect (&rc, GetWindowLong (hDlgMaster, GWL_STYLE), FALSE);
        SetWindowPos (hDlgMaster, NULL, 0, 0, rc.right - rc.left, rc.bottom - rc.top,
            SWP_NOMOVE | SWP_NOZORDER);
        // a-msadek; If the owned window is mirrored, a dialog with specifed 
        // coordinates, the dialog get moved to the worng direction
        HWND hWndOwner = GetWindow(hDlgMaster, GW_OWNER);

        if(IS_WINDOW_RTL_MIRRORED(hWndOwner))
            {
                RECT rcOwner, rcDlg;            
                GetWindowRect(hWndOwner, &rcOwner);
                GetWindowRect(hDlgMaster, &rcDlg);
                SetWindowPos(hDlgMaster, NULL, rcDlg.left - (rcDlg.right - rcOwner.right), rcDlg.top, 0 ,0,
                SWP_NOSIZE | SWP_NOZORDER);
            }
            

#if 0   //now we do this as part of the "move controls from template to master" process,
        //if we notice that a ctrl with that id already exists.  This way we pick up the
        //tab order too.  If someone decides my hack (SetParent) to change tab order is
        //broken, then that code can be nuked and this reenabled.

        //position already-existing controls in master like us
        int ID_PREEXIST_CTRLS[] = { IDOK_PLACEHOLDER, IDCANCEL_PLACEHOLDER,
            IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER };

        for (int iCtrl = 0; iCtrl < ARRAYSIZE(ID_PREEXIST_CTRLS); iCtrl++)
        {
            GetWindowRect (GetDlgItem (hDlgTemplate, ID_PREEXIST_CTRLS[iCtrl]), &rc);
            MapWindowPoints (NULL, hDlgTemplate, (LPPOINT)&rc, 2);
            MoveWindow (GetDlgItem (hDlgMaster, ID_PREEXIST_CTRLS[iCtrl]),
                rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, TRUE);

            DestroyWindow (GetDlgItem (hDlgTemplate, ID_PREEXIST_CTRLS[iCtrl]));
        }
#endif

        //copy other controls from us to master
        //find last child
        HWND hCtrlTemplate = NULL;
        HWND hNextCtrl = GetWindow (hDlgTemplate, GW_CHILD);
        if (hNextCtrl)      //can't see how this would fail, but...
            hCtrlTemplate = GetWindow (hNextCtrl, GW_HWNDLAST);

        //have last window in hCtrlTemplate
        //now move controls over in reverse order -- they'll end up stacking up in original order from template
        while (hCtrlTemplate)
        {
            hNextCtrl = GetWindow (hCtrlTemplate, GW_HWNDPREV);
            DWORD id = GetWindowLong (hCtrlTemplate, GWL_ID);
            HWND hCtrlExisting;
            if (id != (USHORT)IDC_STATIC && NULL != (hCtrlExisting = GetDlgItem (hDlgMaster, id)))
                //it's one of the controls pre-created by SHBrowseForFolder
            {   //so don't move this one over -- adjust existing control for size, position, tab order
                RECT rc;
                GetWindowRect (hCtrlTemplate, &rc);
                MapWindowPoints (NULL, hDlgTemplate, (LPPOINT)&rc, 2);
                SetWindowPos (hCtrlExisting, NULL, rc.left, rc.top,
                    rc.right - rc.left, rc.bottom - rc.top, SWP_NOACTIVATE | SWP_NOZORDER);
                DestroyWindow (hCtrlTemplate);
                //REVIEW
                //hack -- send control to end of tab order
                SetParent (hCtrlExisting, hDlgTemplate);
                SetParent (hCtrlExisting, hDlgMaster);
            }
            else    //we should move this control from template to master
            {
                SetProp (hCtrlTemplate, szTransplacedProp, (HANDLE)TRUE);  //anything -- it's the existence of the prop that we check for
                SetParent (hCtrlTemplate, hDlgMaster);          //to know to move this control back later
            }
            hCtrlTemplate = hNextCtrl;
        }
        // Let Template know about the child so that it can forward WM_COMMAND notifications to it
        // to work around the fact that edit controls cache their parent pointers and ignore SetParents
        // when it comes to sending parent notifications
        SetProp(hDlgTemplate, szOriginalWND, hDlgMaster);
    }

        break;
    case WM_COMMAND:
        // Workaround for above bug
        SendMessage((HWND)GetProp(hDlgTemplate, szOriginalWND), uMsg, wParam, lParam);
        break;
    }

    return FALSE;
}


int CALLBACK BFFFavCallback(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
{
    switch (uMsg)
    {
        case BFFM_INITIALIZED:
        {
            ADDTOFAV* patf = (ADDTOFAV*)lpData;
            ASSERT (patf);

            HWND hDlgTemp = CreateDialogParam(MLGetHinst(), 
                                MAKEINTRESOURCE(IDD_ADDTOFAVORITES_TEMPLATE),
                                NULL, MergeFavoritesDialogControls, (LPARAM)hwnd);
            //this results in all the controls being copied over
            
            //if successful, make our other modifications
            BFFFAVSUBSTRUCT * pbffFavSubStruct;
            if ((IsWindow(GetDlgItem(hwnd, IDC_SUBSCRIBE_CUSTOMIZE)))   //verify existence of randomly-selected control
                && (pbffFavSubStruct = (BFFFAVSUBSTRUCT *) LocalAlloc(LPTR, sizeof(BFFFAVSUBSTRUCT))))
            {
                //done with template, but don't destroy it:
                //see MSKB Q84190, owner/owned vs parent/child -- the children
                // of template are now children of master, but still OWNED
                // by template, and are destroyed when template is destroyed...
                // but we'll just keep template around
                // invisibly.
                //we'll take care of it when we go away

                //Do we need to do SetDefaultDialogFont stuff for localization still, since it all comes from the .rc?

                //set up window stuff for subclass:
                // Get the TreeView control so we can muck with the style bits and move it down
                HWND hwndT;
                if (hwndT = GetDlgItem(hwnd, IDD_FOLDERLIST))
                {
                    DWORD dwStyle = GetWindowLong(hwndT, GWL_STYLE);
                    dwStyle |= TVS_SHOWSELALWAYS;
                    dwStyle &= ~TVS_LINESATROOT;
                    SetWindowLong(hwndT, GWL_STYLE, dwStyle);
                }

                // don't allow subscriptions if the URL is not "http:" protocol, or if already subscribed
                TCHAR szURL[MAX_URL_STRING];

                if (!patf->pidlFavorite ||
                    FAILED(IEGetDisplayName(patf->pidlFavorite, szURL, SHGDN_FORPARSING)) ||
                    SHRestricted2(REST_NoAddingSubscriptions, szURL, 0) ||
                    !IsSubscribable(szURL) ||
                    !IsFeaturePotentiallyAvailable(CLSID_SubscriptionMgr) ||
                    !IsBrowserFrameOptionsPidlSet(patf->pidlFavorite, BFO_USE_IE_OFFLINE_SUPPORT))
                {
                    CheckDlgButton(hwnd, IDC_MAKE_OFFLINE, 0);
                    EnableWindow(GetDlgItem (hwnd, IDC_MAKE_OFFLINE), FALSE);
                    EnableWindow(GetDlgItem (hwnd, IDC_SUBSCRIBE_CUSTOMIZE), FALSE);
                }
                else if (IsSubscribed(patf))
                {
                    patf->bStartSubscribed = TRUE;
                    CheckDlgButton(hwnd, IDC_MAKE_OFFLINE, 1);
                }
                else if (patf->bIsSoftdist)
                {
                    CheckDlgButton(hwnd, IDC_MAKE_OFFLINE, 1);
                }
                EnableWindow(GetDlgItem(hwnd, IDC_SUBSCRIBE_CUSTOMIZE),
                             IsDlgButtonChecked(hwnd, IDC_MAKE_OFFLINE));

                //set the name
                Edit_LimitText(GetDlgItem(hwnd, IDC_FAVORITE_NAME), MAX_PATH - 1);

                // Use URL if title string is not displayable
                if (SHIsDisplayable(patf->pszFile, g_fRunOnFE, g_bRunOnNT5))
                {  
                    SetDlgItemText(hwnd, IDC_FAVORITE_NAME, patf->pszFile);
                }
                else
                {
                    TCHAR szUrlTemp[MAX_URL_STRING];
                    IEGetDisplayName(patf->pidlFavorite, szUrlTemp, SHGDN_FORPARSING);
                    SetDlgItemText(hwnd, IDC_FAVORITE_NAME, szUrlTemp);
                }

                EnableOKButtonFromID(hwnd, IDC_FAVORITE_NAME);


                // hide the (empty) SHBrowseForFolder prompt control
                ShowWindow(GetDlgItem (hwnd, IDD_BROWSETITLE), SW_HIDE);

                // Fill out the structure and set it as a property so that our subclass
                // proc can get to this data.
                pbffFavSubStruct->lpfnOldWndProc = (WNDPROC) SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)BFFFavSubclass);
                pbffFavSubStruct->hwndNew = GetDlgItem(hwnd, IDC_FAVORITE_NEWFOLDER);
                pbffFavSubStruct->patf = patf;
                pbffFavSubStruct->hwndTV = GetDlgItem(hwnd, IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER);
                pbffFavSubStruct->hwndSave = GetDlgItem(hwnd, IDC_FAVORITE_CREATEIN);
                pbffFavSubStruct->hTemplateWnd = hDlgTemp;  //save for explicit destruction later
                GetWindowRect(hwnd, &(pbffFavSubStruct->rcRestored));

                SetProp(hwnd, ADDTOFAVPROP, (HANDLE)pbffFavSubStruct);

                patf->pidlSelected = ILClone(patf->pidl);

                DWORD dwType, dwValue = 0, dwcData = sizeof(dwValue);
                TCHAR szBuffer[100];
                
                SHRegGetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), TEXT("AddToFavoritesExpanded"),
                        &dwType, &dwValue, &dwcData, 0, NULL, sizeof(dwValue));

                if (dwValue == 0)
                {
                    int lRet = MLLoadString(IDS_FAVS_ADVANCED_EXPAND, szBuffer, ARRAYSIZE(szBuffer));
                    ASSERT(lRet);

                    // Disable the tree view and new button so that we can't tab to them.
                    EnableWindow(GetDlgItem (hwnd, IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER), FALSE);
                    EnableWindow(GetDlgItem (hwnd, IDC_FAVORITE_NEWFOLDER), FALSE);

                    // hide the bottom part of the dialog
                    int cx, cy;
                    RECT rc;
                    GetWindowRect (GetDlgItem (hwnd, IDC_SUBSCRIBE_FOLDERLIST_PLACEHOLDER), &rc);
                    cy = rc.top;
                    GetWindowRect (hwnd, &rc);
                    cx = rc.right - rc.left;
                    cy = cy /*top of ctrl*/ - rc.top; /*top of window*/
                    SetWindowPos (hwnd, NULL, 0, 0, cx, cy, SWP_NOMOVE | SWP_NOZORDER);
                }
                else
                {
                    //don't show New Folder button for channels in the channels folder,
                    // see code for case IDC_FAVORITE_NEWFOLDER for why
                    if (patf->subsType == SUBSTYPE_CHANNEL)
                    {
                        LPITEMIDLIST pidlFavs = NULL;
                        TCHAR tzFavsPath[MAX_PATH];
                    
                        if (SUCCEEDED(SHGetSpecialFolderLocation(hwnd, CSIDL_FAVORITES, &pidlFavs)) 
                        && SUCCEEDED(SHGetNameAndFlags(pidlFavs, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, tzFavsPath, SIZECHARS(tzFavsPath), NULL))
                        && 0 == StrCmpNI(tzFavsPath, patf->pszInitDir, ARRAYSIZE(tzFavsPath)))
                        {
                            EnableWindow(pbffFavSubStruct->hwndNew, TRUE);
                        }
                        else
                            EnableWindow(pbffFavSubStruct->hwndNew, FALSE);

                        if(pidlFavs)
                            ILFree(pidlFavs);
                    }
                    else
                        EnableWindow(pbffFavSubStruct->hwndNew, TRUE);
                    
                    int lRet = MLLoadString(IDS_FAVS_ADVANCED_COLLAPSE, szBuffer, ARRAYSIZE(szBuffer));
                    ASSERT(lRet);
                }
                SetWindowText(GetDlgItem(hwnd, IDC_FAVORITE_CREATEIN), szBuffer);
                
            }
            else
            {
                EndDialog(hwnd, IDCANCEL);
            }
            break;
        }
        case BFFM_SELCHANGED:
        {
            //the first of these comes during BFFM_INITIALIZED, so ignore it
            if (((ADDTOFAV *)lpData)->pidlSelected != NULL)
            {
                ILFree(((ADDTOFAV *)lpData)->pidlSelected);
                ((ADDTOFAV *)lpData)->pidlSelected = ILClone((LPITEMIDLIST)lParam);
            }
            break;
        }
    }

    return 0;
}


// This API is not exported.  See below (DoAddToFavDlg) for the exported version
//
// hwnd        parent window for the dialog.
// pszInitDir  input: initial path
//             output: fully qualified path and filename
// chInitDir   Length of pszInitDir buffer
// pszFile     initial (default) filename for shortcut
// cchFile     Length of pszFile buffer
// pidlBrowse  associated with pszInitDir
//
// Returns:
//  TRUE if a directory and filename were selected by user, and no error
//  occurs.  In this case pszInitDir contains the new destination directory
//  and filename, pszFile contains the new file name.
//
//  FALSE if an error occurs or the user selects CANCEL.

STDAPI_(BOOL) DoAddToFavDlgEx(HWND hwnd, 
                            TCHAR *pszInitDir, UINT cchInitDir,
                            TCHAR *pszFile, UINT cchFile, 
                            LPITEMIDLIST pidlBrowse,
                            LPCITEMIDLIST pidlFavorite,
                            FAVDLGTYPE atfDlgType,
                            SUBSCRIPTIONINFO* pInfo)
{
    ADDTOFAV atf = {pszInitDir, cchInitDir - 1, pszFile, cchFile - 1, pidlBrowse, NULL,
                    pidlFavorite, atfDlgType, {sizeof(SUBSCRIPTIONINFO), 0}, SUBSTYPE_URL };
    TCHAR szTemp[1];    //NOTE: we're not using SHBrowseForFolder's prompt string (see below)
    TCHAR szDisplayName[MAX_PATH];
    BROWSEINFO bi = {
            hwnd,
            pidlBrowse,
            szDisplayName,
            szTemp,
            BIF_RETURNONLYFSDIRS,
            // (BFFCALLBACK)
            BFFFavCallback,
            (LPARAM)&atf,
            0
    };
    LPITEMIDLIST pidl;

    if (pInfo)
        atf.siSubsInProg = *pInfo;

    switch (atfDlgType)
    {
        case ATF_CHANNEL_SOFTDIST:
            atf.bIsSoftdist = TRUE;
            //  fall through
        case ATF_CHANNEL:
            atf.subsType = SUBSTYPE_CHANNEL;
            break;

        //default:
        //  set in initialize to SUBSTYPE_URL
    }

    //this string is now in the template dialog in the .rc
    //REVIEW -- do we want to do it this way (we're hiding SHBrowse...'s control)? then the template dialog looks more like the finished product...
    szTemp[0] = 0;
 
    //init native font control, otherwise dialog may fail to initialize
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_NATIVEFNTCTL_CLASS;
        InitCommonControlsEx(&icc);
    }
    
    pidl = SHBrowseForFolder(&bi);

    if (pidl)
    {
        ILFree(pidl);
    }

    //  If the user created a new subscription, start a download.
    if (atf.bSubscribed && !atf.bStartSubscribed)
    {
        ISubscriptionMgr* pSubsMgr;
        if (SUCCEEDED (CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                                        IID_ISubscriptionMgr, (void**)&pSubsMgr)))
        {
            WCHAR wszURL[MAX_URL_STRING];

            IEGetDisplayName(atf.pidlFavorite, wszURL, SHGDN_FORPARSING);

            pSubsMgr->UpdateSubscription(wszURL);
            pSubsMgr->Release();
        }
    }

    return (pidl != NULL);
}

STDAPI_(BOOL) DoSafeAddToFavDlgEx(HWND hwnd, 
                            TCHAR *pszInitDir, UINT cchInitDir,
                            TCHAR *pszFile, UINT cchFile, 
                            LPITEMIDLIST pidlBrowse,
                            LPCITEMIDLIST pidlFavorite,
                            FAVDLGTYPE atfDlgType,
                            SUBSCRIPTIONINFO* pInfo)
{
    BOOL fRet;

    if (IEIsLinkSafe(hwnd, pidlFavorite, ILS_ADDTOFAV))
    {
        fRet = DoAddToFavDlgEx(hwnd, pszInitDir, cchInitDir, pszFile, cchFile,
                               pidlBrowse, pidlFavorite, atfDlgType, pInfo);
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}


// This API is exported so that it may be called by explorer and mshtml (and MSNVIEWR.EXE)
// in addition to being called internally by shdocvw.
// THEREFORE YOU MUST NOT CHANGE THE SIGNATURE OF THIS API
//

STDAPI_(BOOL) DoAddToFavDlg(HWND hwnd, 
                            CHAR *pszInitDir, UINT cchInitDir,
                            CHAR *pszFile, UINT cchFile, 
                            LPITEMIDLIST pidlBrowse)
{
    BOOL fRet;

    WCHAR szInitDir[MAX_PATH];
    WCHAR szFile[MAX_PATH];

    SHAnsiToUnicode(pszInitDir, szInitDir, ARRAYSIZE(szInitDir));
    SHAnsiToUnicode(pszFile, szFile, ARRAYSIZE(szFile));

    fRet = DoSafeAddToFavDlgEx(hwnd, szInitDir, ARRAYSIZE(szInitDir), szFile, ARRAYSIZE(szFile), pidlBrowse, NULL, ATF_FAVORITE, NULL);

    SHUnicodeToAnsi(szInitDir, pszInitDir, cchInitDir);
    SHUnicodeToAnsi(szFile, pszFile, cchFile);

    return fRet;
}


STDAPI_(BOOL) DoAddToFavDlgW(HWND hwnd, 
                             WCHAR *pszInitDir, UINT cchInitDir,
                             WCHAR *pszFile, UINT cchFile, 
                             LPITEMIDLIST pidlBrowse)
{
    return DoSafeAddToFavDlgEx(hwnd, pszInitDir, cchInitDir, pszFile, cchFile, pidlBrowse, NULL, ATF_FAVORITE, NULL);
}


STDAPI AddToFavoritesEx(HWND hwnd, LPCITEMIDLIST pidlCur, LPCTSTR pszTitle, DWORD dwFlags,
                        SUBSCRIPTIONINFO *pInfo, IOleCommandTarget *pCommandTarget, IHTMLDocument2 *pDoc);
STDAPI AddToChannelsEx (HWND hwnd, LPCITEMIDLIST pidlUrl, LPTSTR pszName, LPCWSTR pwszURL,
                        DWORD dwFlags, SUBSCRIPTIONINFO* pInfo);
STDAPI SubscribeFromFavorites (HWND hwnd, LPCITEMIDLIST pidlUrl, LPTSTR pszName, DWORD dwFlags,
                               SUBSCRIPTIONTYPE subsType, SUBSCRIPTIONINFO *pInfo);


// This API is exported privately, and is called by ISubscriptionMgr::CreateSubscription.
// shuioc uses it too.

STDAPI SHAddSubscribeFavoriteEx (
        HWND hwnd, 
        LPCWSTR pwszURL, 
        LPCWSTR pwszName, 
        DWORD dwFlags,
        SUBSCRIPTIONTYPE subsType, 
        SUBSCRIPTIONINFO* pInfo, 
        IOleCommandTarget *pcmdt,
        IHTMLDocument2 *pDoc)
{
    TCHAR           szName[MAX_PATH];
    LPITEMIDLIST    pidl = NULL;
    HRESULT         hr;
    
    if (pwszURL==NULL || pwszName == NULL)
        return E_INVALIDARG;
    //
    // Need to put pwszName into a buffer because it comes in const
    // but gets modified in SubscribeFromFavorites.
    //
    hr = StringCchCopy(szName, ARRAYSIZE(szName), pwszName);
    if(SUCCEEDED(hr))
    {
        hr = IECreateFromPath(pwszURL, &pidl);
    }

    if (SUCCEEDED(hr))
    {
        ASSERT (pidl);

        if (dwFlags & CREATESUBS_FROMFAVORITES)
        {
            if (subsType != SUBSTYPE_URL && subsType != SUBSTYPE_CHANNEL)
            {
                ASSERT(0);
                hr = E_INVALIDARG;
            }
            else
            {
                hr = SubscribeFromFavorites (hwnd, pidl, szName, dwFlags, subsType, pInfo);
            }
        }
        else
        {
            if (subsType == SUBSTYPE_URL)
            {
                hr = AddToFavoritesEx (hwnd, pidl, szName, dwFlags, pInfo, pcmdt, pDoc);
            }
            else if (subsType == SUBSTYPE_CHANNEL && !SHIsRestricted2W(hwnd, REST_NoChannelUI, NULL, 0))
            {
                hr = AddToChannelsEx (hwnd, pidl, szName, pwszURL, dwFlags, pInfo);
            }
            else
            {
                ASSERT (0);
                hr = E_INVALIDARG;
            }
        }

        ILFree(pidl);
    }
    return hr;    
}

STDAPI SHAddSubscribeFavorite (HWND hwnd, LPCWSTR pwszURL, LPCWSTR pwszName, DWORD dwFlags,
                               SUBSCRIPTIONTYPE subsType, SUBSCRIPTIONINFO* pInfo)
{
    return SHAddSubscribeFavoriteEx ( hwnd, pwszURL, pwszName, dwFlags,
                                subsType, pInfo, NULL, NULL);
}

// this API is also exported via the .def
// Use for backward compatibility only -- note that it is only for URL's (not channels)
// and doesn't know how to subscribe.
STDAPI AddUrlToFavorites(HWND hwnd, LPWSTR pszUrlW, LPWSTR pszTitleW, BOOL fDisplayUI)
{
    return SHAddSubscribeFavorite (hwnd, pszUrlW, pszTitleW,
        fDisplayUI ? CREATESUBS_NOUI : 0, SUBSTYPE_URL, NULL);
}


// this API is in the .h and is used elsewhere in shdocvw, but is not exported
// Backward compatibility only -- only for URL's (not channels) and can subscribe, but can't
// pass in subscriptioninfo starter.
STDAPI AddToFavorites(
    HWND hwnd, 
    LPCITEMIDLIST pidlCur, 
    LPCTSTR pszTitle, 
    BOOL fDisplayUI, 
    IOleCommandTarget *pCommandTarget,
    IHTMLDocument2 *pDoc)
{
    return AddToFavoritesEx (hwnd, pidlCur, pszTitle,
        fDisplayUI ? 0 : CREATESUBS_NOUI, NULL, pCommandTarget, pDoc);
}


//helper function to create one column in a ListView control, add one item to that column,
//size the column to the width of the control, and color the control like a static...
//basically, like SetWindowText for a ListView.  Because we use a lot of ListViews to display
//urls that would otherwise be truncated... the ListView gives us automatic ellipsis and ToolTip.
void SetListViewToString (HWND hLV, LPCTSTR pszString)
{
    ASSERT(hLV);
    
    LV_COLUMN   lvc = {0};
    RECT lvRect;
    GetClientRect (hLV, &lvRect);
    lvc.mask = LVCF_WIDTH;
    lvc.cx = lvRect.right - lvRect.left;
    if (-1 == ListView_InsertColumn(hLV, 0, &lvc))   {
        ASSERT(0);
    }

    SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_INFOTIP, LVS_EX_INFOTIP);

    LV_ITEM lvi = {0};
    lvi.iSubItem = 0;
    lvi.pszText = (LPTSTR)pszString;
    lvi.mask = LVIF_TEXT;
    ListView_InsertItem(hLV, &lvi);
    ListView_EnsureVisible(hLV, 0, TRUE);
    
    ListView_SetBkColor(hLV, GetSysColor(COLOR_BTNFACE));
    ListView_SetTextBkColor(hLV, GetSysColor(COLOR_BTNFACE));
}


INT_PTR CALLBACK SubscribeFavoriteDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    ADDTOFAV * patf = (ADDTOFAV*)GetProp(hDlg, ADDTOFAVPROP);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            TCHAR szURL[MAX_URL_STRING];

            patf = (ADDTOFAV*)lParam;
            SetProp(hDlg, ADDTOFAVPROP, (HANDLE)patf);

            //set up name and url displays
            SetDlgItemText (hDlg, IDC_CHANNEL_NAME, patf->pszFile);
            //url is in patf->pidlFavorite
            IEGetDisplayName(patf->pidlFavorite, szURL, SHGDN_FORPARSING);
            SetListViewToString (GetDlgItem (hDlg, IDC_CHANNEL_URL), szURL);

            //now the tricky part... this is for modifying the subscription associated with
            //an existing ChannelBar shortcut.  We need to find out if they are subscribed --
            //if so, load the existing subscription into memory so it can be modified in the
            //wizard.  If not, leave the information that was passed up because it's got the
            //schedule extracted from the CDF.  In either case, check the radio button that
            //corresponds to their current subscription level.
            ISubscriptionMgr* pSubsMgr;
            BOOL bSubs = FALSE;

            HRESULT hr = JITCoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                                             IID_ISubscriptionMgr, (void**)&pSubsMgr, 
                                             hDlg, FIEF_FLAG_FORCE_JITUI | FIEF_FLAG_PEEK);

            if (SUCCEEDED(hr))
            {
                pSubsMgr->IsSubscribed(szURL, &bSubs);

                patf->bStartSubscribed = bSubs;

                pSubsMgr->Release();
            }
            else if ((E_ACCESSDENIED == hr) || !IsBrowserFrameOptionsPidlSet(patf->pidlFavorite, BFO_USE_IE_OFFLINE_SUPPORT))
            {
                EnableWindow(GetDlgItem(hDlg, IDC_MAKE_OFFLINE), FALSE);
            }

            if (!bSubs && patf->bIsSoftdist)
            {
                bSubs = TRUE;
            }

            CheckDlgButton(hDlg, IDC_MAKE_OFFLINE, bSubs ? 1 : 0);
            EnableWindow(GetDlgItem (hDlg, IDC_SUBSCRIBE_CUSTOMIZE), bSubs);
        }
        break;

    case WM_DESTROY:
        RemoveProp (hDlg, ADDTOFAVPROP);
        break;

    case WM_HELP:
        SHWinHelpOnDemandWrap((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPTSTR) (patf->iDlgType == ATF_FAVORITE
                            ? aAddToFavHelpIDs : aAddToChanHelpIDs));
        return TRUE;
        break;

    case WM_CONTEXTMENU:
        SHWinHelpOnDemandWrap((HWND) wParam, c_szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID) (patf->iDlgType == ATF_FAVORITE
                         ? aAddToFavHelpIDs : aAddToChanHelpIDs));
        return TRUE;
        break;

    case WM_COMMAND:
        ASSERT (patf);
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            break;

        case IDOK:
            // first, make sure they're not trying to subscribe to an authenticated
            // channel without entering a password.
            if (SubscriptionFailsChannelAuthentication (hDlg, &patf->siSubsInProg))
                return FALSE;

            //find out whether they WERE subscribed, so if they click OK and they
            //were already subscribed, we delete that subscription -- and either leave it
            //deleted if "No subs" was the choice, or create the new one.
            ISubscriptionMgr* pSubsMgr;
            if (SUCCEEDED (JITCoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                                            IID_ISubscriptionMgr, (void**)&pSubsMgr, 
                                            hDlg, FIEF_FLAG_FORCE_JITUI)))
            {
                //url is in patf->pidlFavorite
                TCHAR szURL[MAX_URL_STRING];
                IEGetDisplayName(patf->pidlFavorite, szURL, SHGDN_FORPARSING);

                BOOL bAlreadySubs;
                if (SUCCEEDED (pSubsMgr->IsSubscribed (szURL, &bAlreadySubs)) && bAlreadySubs)
                {
                    pSubsMgr->DeleteSubscription(szURL, NULL);
                }

                pSubsMgr->Release();
            }

            if (IsDlgButtonChecked (hDlg, IDC_MAKE_OFFLINE))
            {
               //they want to subscribe!  save subscription we already have in memory
                patf->bSubscribed = StartSiteSubscription (hDlg, patf, TRUE);
            }
            EndDialog(hDlg, IDOK);
            break;

        // common code with ATF dialog

        case IDC_SUBSCRIBE_CUSTOMIZE:
            //need to create -- but not store -- subscription
            //need to (temporarily) trash patf->pidlFavorite so that we can go through the
            //wizard without colliding with an existing subscription.  When we actually create
            //the subscription, we'll use the real name.
            LPCITEMIDLIST pidlSave = patf->pidlFavorite;
            TCHAR szUrlTemp[MAX_URL_STRING+1];
            IEGetDisplayName(patf->pidlFavorite, szUrlTemp, SHGDN_FORPARSING);
            if(SUCCEEDED(StringCchCat(szUrlTemp, ARRAYSIZE(szUrlTemp), TEXT("."))))   //just put something nearly invisible on the end
            {
                if (SUCCEEDED (IECreateFromPath(szUrlTemp, (LPITEMIDLIST*)&patf->pidlFavorite)))
                {
                    if (StartSiteSubscription (hDlg, patf, FALSE))
                        SendMessage (hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDOK), TRUE);
                    ILFree ((LPITEMIDLIST)patf->pidlFavorite);
                }
            }
            patf->pidlFavorite = pidlSave;

            break;
        }
        break;
    }

    return FALSE;
}


static const int CREATESUBS_ACTIVATE = 0x8000;      //hidden flag meaning channel is already on system

STDAPI SubscribeFromFavorites (HWND hwnd, LPCITEMIDLIST pidlUrl, LPTSTR pszName, DWORD dwFlags,
                               SUBSCRIPTIONTYPE subsType, SUBSCRIPTIONINFO *pInfo)
{
    //used to subscribe to a channel that's already in the Favorites
    //or a URL that's already a Favorite

    //flags are same as ISubscriptionMgr::CreateSubscription

    //display our part of the fav's dialog -- no need to go through SHBrowseForFolder
    //or any of that, just our radio buttons in a fixed-size dialog with our own DlgProc

    INT_PTR iDlgResult;
    HRESULT hr = S_OK;
    ADDTOFAV atf = {0};
    atf.pszFile = pszName;
    atf.siSubsInProg.cbSize = sizeof(SUBSCRIPTIONINFO);
    if (pInfo && pInfo->cbSize == sizeof(SUBSCRIPTIONINFO))
        atf.siSubsInProg = *pInfo;

    atf.subsType = subsType;

    //figure out what dialog to use
    atf.iDlgType = (subsType == SUBSTYPE_URL ? ATF_FAVORITE :
        (dwFlags & CREATESUBS_ACTIVATE ? ATF_CHANNEL_MODIFY : ATF_CHANNEL));
    // Do we potentially need ANOTHER dialog type for softdist channels?

    if (dwFlags & CREATESUBS_SOFTWAREUPDATE)
    {
        atf.bIsSoftdist = TRUE;
    }

    atf.pidlFavorite = pidlUrl;

#ifdef OLD_FAVORITES
    int iTemplate;
    switch (atf.iDlgType)
    {
    case ATF_CHANNEL_SOFTDIST: // Inappropriate, but it doesn't currently get used
    case ATF_CHANNEL:
        iTemplate = IDD_SUBSCRIBE_FAV_CHANNEL;
        break;
    case ATF_CHANNEL_MODIFY:
        iTemplate = IDD_ACTIVATE_PLATINUM_CHANNEL;
        break;
    case ATF_FAVORITE:
        iTemplate = IDD_SUBSCRIBE_FAVORITE;
        break;
    }

    iDlgResult = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(iTemplate), hwnd,
            SubscribeFavoriteDlgProc, (LPARAM)&atf);

#endif

    iDlgResult = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_ADDTOFAVORITES_TEMPLATE), hwnd,
            SubscribeFavoriteDlgProc, (LPARAM)&atf);


    switch (iDlgResult)
    {
    case -1:
        hr = E_FAIL;
        break;
    case IDCANCEL:
        hr = S_FALSE;
        break;
    default:
        if (pInfo && (pInfo->cbSize == sizeof(SUBSCRIPTIONINFO))
                  && (dwFlags & CREATESUBS_NOSAVE))
            *pInfo = atf.siSubsInProg;
        hr = S_OK;
        break;
    }

    return hr;
}


STDAPI AddToChannelsEx (HWND hwnd, LPCITEMIDLIST pidlUrl, LPTSTR pszName, LPCWSTR pwszURL,
                        DWORD dwFlags, SUBSCRIPTIONINFO* pInfo)
{
    HRESULT hr = S_OK;
    IChannelMgrPriv* pIChannelMgrPriv;

    hr = JITCoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_IChannelMgrPriv, (void**)&pIChannelMgrPriv, 
                          hwnd, FIEF_FLAG_FORCE_JITUI);

    if (SUCCEEDED(hr))
    {
        if (S_OK == pIChannelMgrPriv->IsChannelInstalled (pwszURL))
        {
            hr = SubscribeFromFavorites (hwnd, pidlUrl, pszName, dwFlags | CREATESUBS_ACTIVATE,
                SUBSTYPE_CHANNEL, pInfo);
        }
        else
        {
            LPITEMIDLIST pidlChannelFolder;
            TCHAR szPath[MAX_PATH];
            TCHAR szCFPath[MAX_PATH];

            ASSERT(pIChannelMgrPriv);

            IChannelMgrPriv::CHANNELFOLDERLOCATION cflLocation =
                ((dwFlags & CREATESUBS_SOFTWAREUPDATE) ?
                    IChannelMgrPriv::CF_SOFTWAREUPDATE :
                    IChannelMgrPriv::CF_CHANNEL);

            hr = pIChannelMgrPriv->GetChannelFolder(&pidlChannelFolder, cflLocation);
            if (SUCCEEDED (hr))
            {
                //
                // Change IChannelMgrPriv to unicode!  This has to get fixed to
                // support a unicode "Channels" name. (edwardp)
                //

                CHAR szBuff[MAX_PATH];

                hr = pIChannelMgrPriv->GetChannelFolderPath (szBuff, ARRAYSIZE(szBuff), cflLocation);

                if (SUCCEEDED(hr))
                    SHAnsiToUnicode(szBuff, szCFPath, ARRAYSIZE(szCFPath));
                

                if (SUCCEEDED (hr))
                {
                    TCHAR szDspName[MAX_URL_STRING];
                    DWORD cchDspName = ARRAYSIZE(szDspName);

                    hr = StringCchCopy(szPath,  ARRAYSIZE(szPath), szCFPath);
            
                    if(SUCCEEDED(hr))
                    {
                        // When we create a short cut for the URL, we have to make sure it's readable for
                        // the end user. PrepareURLForDisplay() will unescape the string if it's escaped.
                        if (!UrlIs(pszName, URLIS_URL) ||
                            !PrepareURLForDisplay(pszName, szDspName, &cchDspName))
                        {
                            // Unescaping wasn't wanted or didn't work.
                            hr = StringCchCopy(szDspName, ARRAYSIZE(szDspName), pszName);
                        }
                    }
                    
                    if(SUCCEEDED(hr))
                    {
                        PathCleanupSpec(szPath, szDspName);

                        FAVDLGTYPE iDlgType = (dwFlags & CREATESUBS_SOFTWAREUPDATE ? ATF_CHANNEL_SOFTDIST : ATF_CHANNEL);

                        if ((dwFlags & CREATESUBS_NOUI) || 
                            DoSafeAddToFavDlgEx(hwnd, szPath, ARRAYSIZE(szPath), 
                                            szDspName, ARRAYSIZE(szDspName), pidlChannelFolder,
                                            pidlUrl, iDlgType, pInfo))
                        {
                            //we create the channelbar entry here, instead of cdfview, because here
                            //we know where in the channels folder the user wants it to go.
                            IChannelMgr* pChannelMgr = NULL;
                            hr = pIChannelMgrPriv->QueryInterface (IID_IChannelMgr, (void**)&pChannelMgr);
                            if (SUCCEEDED (hr))
                            {
                                //prepare strings
                                PathRemoveExtension(szPath);

                                //strip off absolute part of folder path, and convert to Unicode
                                int cchCommon = PathCommonPrefix (szPath, szCFPath, NULL);

                                //pack in the info we have
                                CHANNELSHORTCUTINFO csiChannel = {0};
                                csiChannel.cbSize = sizeof(csiChannel);
                                csiChannel.pszTitle = szPath + cchCommon;
                                csiChannel.pszURL = (LPWSTR)pwszURL;
                                csiChannel.bIsSoftware = (dwFlags & CREATESUBS_SOFTWAREUPDATE) ? TRUE : FALSE;
                                //and tell the channel mgr to add the channel
                                hr = pChannelMgr->AddChannelShortcut (&csiChannel);
                                pChannelMgr->Release();
                            }
                        }
                        else
                        {
                            hr = S_FALSE;       //no failure, but no add
                        }
                    }
                }

                ILFree (pidlChannelFolder);
            }
        }
        pIChannelMgrPriv->Release();
    }

    return hr;
}


STDAPI AddToFavoritesEx(
    HWND hwnd, 
    LPCITEMIDLIST pidlCur, 
    LPCTSTR pszTitle,
    DWORD dwFlags, 
    SUBSCRIPTIONINFO *pInfo, 
    IOleCommandTarget *pCommandTarget,
    IHTMLDocument2 *pDoc)
{
    HRESULT hres = S_FALSE;
    HRESULT hr;
    HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    if (pidlCur)
    {
        TCHAR szName[MAX_URL_STRING];
        TCHAR szPath[MAX_PATH];
        if (pszTitle)
        {
            hr = StringCchCopy(szName,  ARRAYSIZE(szName), pszTitle);
            if(FAILED (hr))
            {
                SetCursor(hCursorOld);
                return hr;
            }
        }
        else
        {
            szName[0] = 0;

            IEGetNameAndFlags(pidlCur, SHGDN_INFOLDER | SHGDN_NORMAL, szName, SIZECHARS(szName), NULL);
        }

        LPITEMIDLIST pidlFavorites;

        if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_FAVORITES, TRUE) &&
            (pidlFavorites = SHCloneSpecialIDList(NULL, CSIDL_FAVORITES, TRUE)))
        {
            TCHAR szDspName[MAX_PATH];
            DWORD cchDspName = ARRAYSIZE(szDspName);
            
            // When we create a short cut for the URL, we have to make sure it's readable for
            // the end user. PrepareURLForDisplay() will unescape the string if it's escaped.
            if (!UrlIs(szName, URLIS_URL) ||
                !PrepareURLForDisplay(szName, szDspName, &cchDspName))
            {
                // Unescaping wasn't wanted or didn't work.
                hr = StringCchCopy(szDspName,  ARRAYSIZE(szDspName), szName);
                if(FAILED(hr))
                {
                    ILFree(pidlFavorites);
                    SetCursor(hCursorOld);
                    return hr;
                }
            }

            PathCleanupSpec(szPath, szDspName);

            // if left with spaces only, use the filename friendly version of the url instead.
            StrTrim(szDspName, L" ");
            if (szDspName[0] == 0)
            {
                if (SUCCEEDED(IEGetNameAndFlags(pidlCur, SHGDN_FORPARSING, szDspName, ARRAYSIZE(szDspName), NULL)))
                    PathCleanupSpec(szPath, szDspName);
            }

            BOOL fDisplayUI = (dwFlags & CREATESUBS_NOUI) ? FALSE : TRUE;
            if (!fDisplayUI || 
                DoSafeAddToFavDlgEx(hwnd, szPath, ARRAYSIZE(szPath), 
                                    szDspName, ARRAYSIZE(szDspName), pidlFavorites,
                                    pidlCur, ATF_FAVORITE, NULL))
            {
                if (fDisplayUI)
                    PathRemoveFileSpec(szPath);
                    
                ISHCUT_PARAMS ShCutParams = {0};
                
                PathRemoveExtension(szDspName);
                
                ShCutParams.pidlTarget = pidlCur;
                ShCutParams.pszTitle = PathFindFileName(szDspName); 
                ShCutParams.pszDir = szPath; 
                ShCutParams.pszOut = NULL;
                ShCutParams.bUpdateProperties = FALSE;
                ShCutParams.bUniqueName = FALSE;
                ShCutParams.bUpdateIcon = TRUE;
                ShCutParams.pCommand = pCommandTarget;
                ShCutParams.pDoc = pDoc;
                hres = CreateShortcutInDirEx(&ShCutParams);
                if (fDisplayUI && FAILED(hres)) 
                {
                    IE_ErrorMsgBox(NULL, hwnd, GetLastError(), NULL, szDspName, IDS_FAV_UNABLETOCREATE, MB_OK| MB_ICONSTOP);
                }
            }
            else
            {
                hres = S_FALSE;
            }
            ILFree(pidlFavorites);
        }
    }

    SetCursor(hCursorOld);
    
    return hres;
}


BOOL IsSubscribed(ADDTOFAV *patf)
{
    BOOL bSubscribed = FALSE;

    TCHAR szURL[MAX_URL_STRING];
    if (SUCCEEDED(IEGetDisplayName(patf->pidlFavorite, szURL, SHGDN_FORPARSING)))
    {
        ISubscriptionMgr *pSubscriptionMgr;
        if (SUCCEEDED(CoCreateInstance(CLSID_SubscriptionMgr,
                                       NULL, CLSCTX_INPROC_SERVER,
                                       IID_ISubscriptionMgr,
                                       (void**)&pSubscriptionMgr)))
        {
            BSTR bstrURL = SysAllocStringT(szURL);
            if (bstrURL)
            {
                if (SUCCEEDED(pSubscriptionMgr->IsSubscribed(bstrURL, &bSubscribed)) &&
                    bSubscribed)
                {
                    patf->siSubsInProg.fUpdateFlags = SUBSINFO_ALLFLAGS;
                    pSubscriptionMgr->GetSubscriptionInfo(bstrURL, &patf->siSubsInProg);
                }
                SysFreeString(bstrURL);
            }
            pSubscriptionMgr->Release();
        }
    }

    return bSubscribed;
}

BOOL IsSubscribed(LPWSTR pwzUrl)
{
#ifndef DISABLE_SUBSCRIPTIONS

    BOOL bSubscribed = FALSE;

    ISubscriptionMgr * pSubscriptionMgr;
    if (FAILED(CoCreateInstance(CLSID_SubscriptionMgr,
                                NULL,
                                CLSCTX_INPROC_SERVER,
                                IID_ISubscriptionMgr,
                                (void**)&pSubscriptionMgr)))
    {
        return FALSE;
    }

    pSubscriptionMgr->IsSubscribed(pwzUrl, &bSubscribed);
    pSubscriptionMgr->Release();

    return bSubscribed;

#else  /* !DISABLE_SUBSCRIPTIONS */

    return FALSE;

#endif /* !DISABLE_SUBSCRIPTIONS */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\fldset.cpp ===
#include "priv.h"

#include "fldset.h"

#define IShellView_CreateViewWindow(_pi, _piPrev, _pfs, _psb, _prc, _phw) \
    (_pi)->CreateViewWindow(_piPrev, _pfs, _psb, _prc, _phw)

#define IShellView2_GetView(_pi, _pv, _flg) \
    (_pi)->GetView(_pv, _flg)
#define IShellView2_CreateViewWindow2(_pi, _cParams) \
    (_pi)->CreateViewWindow2(_cParams)

#define IUnknown_QueryInterface(_pu, _riid, _pi) \
        (_pu)->QueryInterface(_riid, (LPVOID*)_pi)
#define IUnknown_AddRef(_pu)    (_pu)->AddRef()
#define IUnknown_Release(_pu)   (_pu)->Release()

typedef struct CViewSet
{
    HDSA _dsaViews;
} CViewSet;


CViewSet* CViewSet_New()
{
    CViewSet* pThis = (CViewSet*)LocalAlloc(LPTR, SIZEOF(CViewSet));
    if (!pThis)
    {
        return(NULL);
    }

    pThis->_dsaViews = DSA_Create(SIZEOF(SHELLVIEWID), 8);
    if (!pThis->_dsaViews)
    {
        LocalFree(pThis);
        pThis = NULL;
    }

    return(pThis);
}


int CViewSet_Add(CViewSet* that, SHELLVIEWID const* pvid)
{
    return(DSA_AppendItem(that->_dsaViews, (LPVOID)pvid));
}


void CViewSet_Delete(CViewSet* that)
{
    DSA_Destroy(that->_dsaViews);
    that->_dsaViews = NULL;
    LocalFree((HLOCAL)that);
    that = NULL;
}


void CViewSet_GetDefaultView(CViewSet* that, SHELLVIEWID* pvid)
{
    DSA_GetItem(that->_dsaViews, 0, (LPVOID)pvid);
}


void CViewSet_SetDefaultView(CViewSet* that, SHELLVIEWID const* pvid)
{
    DSA_SetItem(that->_dsaViews, 0, (LPVOID)pvid);
}


// PERF: A linear search for the view
BOOL CViewSet_IsViewSupported(CViewSet* that, SHELLVIEWID const* pvid)
{
    int i;

    // Only go down to 1 since item 0 is the default view
    for (i=DSA_GetItemCount(that->_dsaViews)-1; i>=1; --i)
    {
        if (0 == memcmp(pvid, DSA_GetItemPtr(that->_dsaViews, i),
            SIZEOF(SHELLVIEWID)))
        {
            return(TRUE);
        }
    }

    return(FALSE);
}


// PERF: a linear check
BOOL CViewSet_IsSame(CViewSet* that, CViewSet* pThatView)
{
    int iView = DSA_GetItemCount(pThatView->_dsaViews);

    if (DSA_GetItemCount(that->_dsaViews) != iView)
    {
        return(FALSE);
    }

    for (--iView; iView>=1; --iView)
    {
        if (!CViewSet_IsViewSupported(that,
            (SHELLVIEWID const*)DSA_GetItemPtr(pThatView->_dsaViews, iView)))
        {
            return(FALSE);
        }
    }

    return(TRUE);
}


BOOL CShellViews_Init(CShellViews* that)
{
    if (that->_dpaViews)
    {
        return(TRUE);
    }

    {
        HDPA dpaViews = DPA_Create(4);
        if (!dpaViews)
        {
            return(FALSE);
        }

        {
            CViewSet* pCommViews = CViewSet_New();
            if (!pCommViews)
            {
                DPA_Destroy(dpaViews);
                dpaViews = NULL;
                return(FALSE);
            }

            // The first one is the last known view for that set
            CViewSet_Add(pCommViews, &VID_LargeIcons);
            CViewSet_Add(pCommViews, &VID_LargeIcons);
            CViewSet_Add(pCommViews, &VID_SmallIcons);
            CViewSet_Add(pCommViews, &VID_Thumbnails);
            CViewSet_Add(pCommViews, &VID_List      );
            CViewSet_Add(pCommViews, &VID_Details   );
            CViewSet_Add(pCommViews, &VID_Tile      );

            if (0 != DPA_InsertPtr(dpaViews, 0, pCommViews))
            {
                CViewSet_Delete(pCommViews);
                DPA_Destroy(dpaViews);
                dpaViews = NULL;
                return(FALSE);
            }

            that->_dpaViews = dpaViews;
            return(TRUE);
        }
    }
}


void CShellViews_GetDefaultView(CShellViews* that, UINT uViewSet,
    SHELLVIEWID* pvid)
{
    CViewSet* pViewSet = (CViewSet*)DPA_GetPtr(that->_dpaViews, uViewSet);
    if (!pViewSet)
    {
        pViewSet = (CViewSet*)DPA_GetPtr(that->_dpaViews, 0);
        if (!pViewSet)
        {
            *pvid = VID_LargeIcons;
            return;
        }
    }

    CViewSet_GetDefaultView(pViewSet, pvid);
}


void CShellViews_SetDefaultView(CShellViews* that, UINT uViewSet,
    SHELLVIEWID const* pvid)
{
    CViewSet* pViewSet = (CViewSet*)DPA_GetPtr(that->_dpaViews, uViewSet);
    if (!pViewSet)
    {
        return;
    }

    CViewSet_SetDefaultView(pViewSet, pvid);
}


// PERF: a linear search for the view set
int CShellViews_Add(CShellViews* that, CViewSet* pThisView, BOOL *pbNew)
{
    int iViewSet;

    *pbNew = FALSE;

    for (iViewSet=0; ; ++iViewSet)
    {
        CViewSet* pThatView = (CViewSet*)DPA_GetPtr(that->_dpaViews, iViewSet);
        if (!pThatView)
        {
            break;
        }

        if (CViewSet_IsSame(pThatView, pThisView))
        {
            // Found the same set; delete the one passed in and hand back the
            // existing one
            CViewSet_Delete(pThisView);
            return(iViewSet);
        }
    }

    // I guess we didn't find it
    iViewSet = DPA_AppendPtr(that->_dpaViews, (LPVOID)pThisView);
    if (iViewSet < 0)
    {
        CViewSet_Delete(pThisView);
        return(0);
    }

    *pbNew = TRUE;
    return(iViewSet);
}


BOOL CShellViews_IsViewSupported(CShellViews* that, UINT uViewSet,
    SHELLVIEWID  const*pvid)
{
    CViewSet* pViewSet = (CViewSet*)DPA_GetPtr(that->_dpaViews, uViewSet);
    if (!pViewSet)
    {
        return(FALSE);
    }

    return(CViewSet_IsViewSupported(pViewSet, pvid));
}


int DPA_CViewSet_DeleteCallback(LPVOID p, LPVOID d)
{
    if (p)
        CViewSet_Delete((CViewSet*)p);
    return 1;
}

void CShellViews_Delete(CShellViews* that)
{
    if (that && that->_dpaViews)
    {
        DPA_DestroyCallback(that->_dpaViews, DPA_CViewSet_DeleteCallback, 0);
        that->_dpaViews = NULL;
    }
}


BOOL FileCabinet_GetDefaultViewID2(FOLDERSETDATABASE* that, SHELLVIEWID* pvid)
{
    if (CShellViews_Init(&that->_cViews))
    {
        CShellViews_GetDefaultView(&that->_cViews, that->_iViewSet, pvid);
        return(TRUE);
    }

    return(FALSE);
}


HRESULT FileCabinet_CreateViewWindow2(IShellBrowser* psb, FOLDERSETDATABASE* that, IShellView *psvNew,
    IShellView *psvOld, RECT *prcView, HWND *phWnd)
{
    SHELLVIEWID vid, vidOld, vidRestore;
    IShellView2 *psv2New;
    CViewSet *pThisView;
    DWORD dwViewPriority;
    BOOL bCalledSV2 = FALSE;
    HRESULT hres = S_OK;  // init to avoid a bogus C4701 warning

    if (!CShellViews_Init(&that->_cViews))
    {
        // Can't do anything with view sets; just do the old thing
        goto OldStyle;
    }

    // Default to whatever the last "old-style" view is
    CShellViews_GetDefaultView(&that->_cViews, 0, &vidOld);

    if (psvOld)
    {
        IShellView2 *psv2Old;
        if (SUCCEEDED(IUnknown_QueryInterface(psvOld, IID_IShellView2, &psv2Old)))
        {
            // Try to get the current view
            if (NOERROR == IShellView2_GetView(psv2Old, &vidOld, SV2GV_CURRENTVIEW))
            {
                CShellViews_SetDefaultView(&that->_cViews, that->_iViewSet, &vidOld);
            }

            IUnknown_Release(psv2Old);
        }
        else
        {
            // Get the view ID from the folder settings
            ViewIDFromViewMode(that->_fld._fs.ViewMode, &vidOld);
            CShellViews_SetDefaultView(&that->_cViews, 0, &vidOld);
        }
    }

    pThisView = CViewSet_New();
    if (!pThisView)
    {
        goto OldStyle;
    }

    if (SUCCEEDED(IUnknown_QueryInterface(psvNew, IID_IShellView2, &psv2New)))
    {
        SHELLVIEWID vidFolderDefault;
        if (NOERROR == IShellView2_GetView(psv2New, &vidFolderDefault, SV2GV_DEFAULTVIEW))
        {
            // we can now make up a view set for that folder
            if (CViewSet_Add(pThisView, &vidFolderDefault) >= 0)
            {
                int iViewSet;
                UINT uView;
                BOOL bNew;

                // NOTE: This usage of IShellView2::GetView is not documented in MSDN...
                for (uView=0; NOERROR==IShellView2_GetView(psv2New, &vid, uView);
                    ++uView)
                {
                    CViewSet_Add(pThisView, &vid);
                }

                // Add that view set.  we will get an existing view set if it is
                // a duplicate
                iViewSet = CShellViews_Add(&that->_cViews, pThisView, &bNew);
                // This is now owned by CShellViews
                pThisView = NULL;

                
                //
                // Here is where we decide which view we want to use.
                //

                // Start with what came from the FOLDERSETDATABASE, then see if
                // anyone else has a higher VIEW_PRIORITY_XXX that would override this one.
                vidRestore = that->_fld._vidRestore;
                dwViewPriority = that->_fld._dwViewPriority;

                // ToddB, 8-18-99:
                // When we set the _fld._dwViewPriority in WebBrowserOc::Load(IPropertyBag *...) we want that ViewID to stick
                // around.  Only failing the CShellViews_IsViewSupported call below should set a different view.  Even then
                // we want to go back to this view on the next navigate.  To accomplish this we need to keep the priority of
                // that view at what it was originally set to.  This can be done by removing the following line of code:
                //
                //  that->_fld._dwViewPriority = VIEW_PRIORITY_NONE;
                //
                // However, its possible that the line of code above was there for a good reason.  I suspect that line was
                // originally added simply as a precaution or because the meaning of _vidRestore was not clearly defined in
                // relation to navigation inside a WebBrowserOC.  I'm leaving the line here and commented out just in case.
                // If any new bugs arise about changing the view window and getting the wrong view I would look here first.


                // Make sure that what we got is a supported view
                if (!CShellViews_IsViewSupported(&that->_cViews, iViewSet, &vidRestore))
                {
                    // Oops, that view isn't supported by this shell ext.
                    // Set the priority to NONE so that one of the others will override it.
                    dwViewPriority = VIEW_PRIORITY_NONE;
                }

                
                DWORD cbSize;
                DWORD dwValue;
                DWORD dwShellExtPriority;
                cbSize = SIZEOF(dwValue);
                if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER,
                            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                            TEXT("ClassicViewState"), NULL, &dwValue, &cbSize)
                        && dwValue)
                {
                    // We want to inherit from the previous folder if at all possible
                    // Otherwise, we will use the new shell extended view.
                    // To do this, we set the shell ext view priority lower than inherit
                    dwShellExtPriority = VIEW_PRIORITY_SHELLEXT_ASBACKUP;
                }
                else
                {
                    dwShellExtPriority = VIEW_PRIORITY_SHELLEXT;
                }

                // Let the shell ext select the view if it has higher priority than
                // what we already have, and it is supported as well.
                if (dwViewPriority <= dwShellExtPriority &&
                    CShellViews_IsViewSupported(&that->_cViews, iViewSet, &vidFolderDefault))
                {
                    // shell extension is more important
                    vidRestore = vidFolderDefault;
                    dwViewPriority = dwShellExtPriority;
                }
                
                // Maybe we can inherit it from the previous view...
                if (dwViewPriority <= VIEW_PRIORITY_INHERIT &&
                    psvOld &&
                    bNew &&
                    CShellViews_IsViewSupported(&that->_cViews, iViewSet, &vidOld))
                {
                    // We just navigated from another shell view. Use the same view as the last
                    // folder.
                    vidRestore = vidOld;
                    dwViewPriority = VIEW_PRIORITY_INHERIT;
                }

                // We're getting really desperate now...
                if (dwViewPriority <= VIEW_PRIORITY_DESPERATE)
                {
                    // Try the last view for the folders current viewset.
                    CShellViews_GetDefaultView(&that->_cViews, iViewSet, &vidRestore);
                    dwViewPriority = VIEW_PRIORITY_DESPERATE;
                }
                  
                // All finished trying to figure out what view to use
                ASSERT(dwViewPriority > VIEW_PRIORITY_NONE);

                // assure webview no in vid, it is persisted in shellstate now.
                {
                    SV2CVW2_PARAMS cParams =
                    {
                        SIZEOF(SV2CVW2_PARAMS),

                        psvOld,
                        &that->_fld._fs,
                        psb,
                        prcView,
                        &vidRestore,

                        NULL,
                    } ;

                    hres = IShellView2_CreateViewWindow2(psv2New, &cParams);
                    bCalledSV2 = TRUE;
                    *phWnd = cParams.hwndView;
                }

                if (SUCCEEDED(hres))
                {
                    that->_iViewSet = iViewSet;
                }
            }
        }

        IUnknown_Release(psv2New);
    }

    if (pThisView)
    {
        CViewSet_Delete(pThisView);
    }

    if (bCalledSV2)
    {
        return(hres);
    }

OldStyle:
    that->_iViewSet = 0;
    return IShellView_CreateViewWindow(psvNew, psvOld, &that->_fld._fs, (IShellBrowser*)psb, prcView, phWnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\histband.cpp ===
#include "priv.h"
#include "sccls.h"
#include "nscband.h"
#include "nsc.h"
#include "resource.h"
#include "dhuihand.h"
#include <varutil.h>

#include <mluisupp.h>

#define DM_HISTBAND     0x0000000
#define DM_GUIPAINS     0x40000000

#define REGKEY_HISTORY_VIEW TEXT("HistoryViewType")
#define REGKEY_DEFAULT_SIZE 0x10

#define VIEWTYPE_MAX        0x4  // A "guess" at how many viewtypes thare will be
#define VIEWTYPE_REALLOC    0x4  // How many to realloc at a time

// these are temporary
#define MENUID_SEARCH       0x4e4e

// Distance between history search go and stop buttons
#define HISTSRCH_BUTTONDIST 6 

extern HINSTANCE     g_hinst;

#define WM_SEARCH_STATE (WM_USER + 314)

class CHistBand : public CNSCBand,
                  public IShellFolderSearchableCallback
{
    friend HRESULT CHistBand_CreateInstance(IUnknown *punkOuter,
                                            IUnknown **ppunk, LPCOBJECTINFO poi);
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef (void) { return CNSCBand::AddRef();  };
    STDMETHODIMP_(ULONG) Release(void) { return CNSCBand::Release(); };
    
    // *** IOleCommandTarget methods ***
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                  DWORD nCmdID,
                  DWORD nCmdexecopt,
                  VARIANTARG *pvarargIn,
                  VARIANTARG *pvarargOut);

    // *** IOleWindow methods ***
    //  (overriding CNSCBand implementation
    STDMETHODIMP GetWindow(HWND *phwnd);

    // *** IInputObject methods ***
    //  (overriding CNSCBand/CToolBand's implementation)
    STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IDockingWindow methods ***
    STDMETHODIMP ShowDW(BOOL fShow);

    // *** IShellFolderSearchableCallback methods ***
    STDMETHODIMP RunBegin(DWORD dwReserved);
    STDMETHODIMP RunEnd(DWORD dwReserved);
    
protected:
    virtual void    _AddButtons(BOOL fAdd);
    virtual HRESULT _OnRegisterBand(IOleCommandTarget *poctProxy);
    virtual BOOL _ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib);
    virtual HRESULT _NavigateRightPane(IShellBrowser *psb, LPCITEMIDLIST pidl);

    ~CHistBand();

    HRESULT       _InitViewPopup();
    HRESULT       _DoViewPopup(int x, int y);
    HRESULT       _ViewPopupSelect(UINT idCmd);

#ifdef SPLIT_HISTORY_VIEW_BUTTON
    UINT          _NextMenuItem();
#endif

    HRESULT       _ChangePidl(LPITEMIDLIST);
    HRESULT       _SelectPidl(LPCITEMIDLIST pidlSelect, BOOL fCreate,
                              LPCITEMIDLIST pidlViewType = NULL,
                              BOOL fReinsert = FALSE);

    virtual HRESULT _InitializeNsc();
    LPITEMIDLIST  _GetCurrentSelectPidl(IOleCommandTarget *poctProxy = NULL);
    HRESULT       _SetRegistryPersistView(int iMenuID);
    int           _GetRegistryPersistView();
    LPCITEMIDLIST _MenuIDToPIDL(UINT uMenuID);
    int           _PIDLToMenuID(LPITEMIDLIST pidl);
    IShellFolderViewType*  _GetViewTypeInfo();
    HRESULT       _GetHistoryViews();
    HRESULT       _FreeViewInfo();

    void          _ResizeChildWindows(LONG width, LONG height, BOOL fRepaint);
    HRESULT       _DoSearchUIStuff();
    HRESULT       _ExecuteSearch(LPTSTR pszSearchString);
    HRESULT       _ClearSearch();
    IShellFolderSearchable *_EnsureSearch();
    static LRESULT CALLBACK s_EditWndSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK s_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL_PTR    CALLBACK s_HistSearchDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    BOOL  _fStrsAdded;  // Strings from resource have been added as buttons on the toolbar
    LONG_PTR  _lStrOffset;

    HMENU _hViewMenu;          // an instance var so we can cache it
    UINT  _uViewCheckedItem;   // which menuitem in the View menu is checked?

    LPITEMIDLIST *_ppidlViewTypes;
    LPTSTR       *_ppszStrViewNames;
    UINT          _nViews;
    int           _iMaxMenuID;

    HWND          _hwndNSC;
    HWND          _hwndSearchDlg;
    LONG          _lSearchDlgHeight;
    LPITEMIDLIST  _pidlSearch;  // current search
    IShellFolderSearchable *_psfSearch;
    
    LPITEMIDLIST  _pidlHistory; // cache the history pidl from SHGetHistoryPIDL
    IShellFolder *_psfHistory;  // cache the history shell folder
    IShellFolderViewType  *_psfvtCache;  // view type information

    LPITEMIDLIST  _pidlLastSelect;
};

CHistBand::~CHistBand() 
{
    DestroyMenu(_hViewMenu);
    if (_pidlLastSelect)
        ILFree(_pidlLastSelect);
    if (_pidlHistory)
        ILFree(_pidlHistory);
    if (_psfHistory)
        _psfHistory->Release();
    if (_psfvtCache)
        _psfvtCache->Release();
   
    _ClearSearch(); // Frees _pidlSearch 
    if (_psfSearch)
        _psfSearch->Release();
    
    _FreeViewInfo();
}

HRESULT CHistBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CHistBand, IShellFolderSearchableCallback),  // IID_IShellFolderSearchableCallback
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hr))
        hr = CNSCBand::QueryInterface(riid, ppvObj);
    return hr;
}

// *** IOleCommandTarget methods ***
HRESULT CHistBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
                        DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hRes = S_OK;
    if (pguidCmdGroup)
    {
        if (IsEqualGUID(CLSID_HistBand, *pguidCmdGroup))
        {
            switch(nCmdID)
            {
            case FCIDM_HISTBAND_VIEW:
                if (pvarargIn && (pvarargIn->vt == VT_I4))
                {
#ifdef SPLIT_HISTORY_VIEW_BUTTON
                    if (nCmdexecopt == OLECMDEXECOPT_PROMPTUSER)
                        hRes = _DoViewPopup(GET_X_LPARAM(pvarargIn->lVal), GET_Y_LPARAM(pvarargIn->lVal));
                    else
                        hRes = _ViewPopupSelect(_NextMenuItem());
#else
                    ASSERT(nCmdexecopt == OLECMDEXECOPT_PROMPTUSER);
                    hRes = _DoViewPopup(GET_X_LPARAM(pvarargIn->lVal), GET_Y_LPARAM(pvarargIn->lVal));
#endif
                }
                else
                    ASSERT(0);
                break;
                
            case FCIDM_HISTBAND_SEARCH:
                _ViewPopupSelect(MENUID_SEARCH);
                break;
            }
        }
        else if ((IsEqualGUID(CGID_Explorer, *pguidCmdGroup)))
        {
            switch (nCmdID)
            {
            case SBCMDID_SELECTHISTPIDL:
#ifdef ANNOYING_HISTORY_AUTOSELECT
                if (_uViewCheckedItem != MENUID_SEARCH)
                {
                    LPCITEMIDLIST pidlSelect = VariantToIDList(pvarargIn);

                    // Get the current view information
                    LPCITEMIDLIST pidlView = _MenuIDToPIDL(_uViewCheckedItem);
                    DWORD dwViewFlags = SFVTFLAG_NOTIFY_CREATE;
                    IShellFolderViewType* psfvtInfo = _GetViewTypeInfo();

                    if (psfvtInfo)
                    {
                        // query for view type properties -- this will tell us how to
                        //   select the item...
                        hRes = psfvtInfo->GetViewTypeProperties(pidlView,
                                                                &dwViewFlags);
                        psfvtInfo->Release();
                    }
                    if (SUCCEEDED(hRes))
                    {
                        hRes = _SelectPidl(pidlSelect, dwViewFlags & SFVTFLAG_NOTIFY_CREATE,
                                           pidlView,   dwViewFlags & SFVTFLAG_NOTIFY_RESORT);
                    }
                    ILFree(pidlSelect);
                }
                else //eat it, so that nsc doesn't get it
                    hRes = S_OK;
#endif //ANNOYING_HISTORY_AUTOSELECT
                hRes = S_OK;
                break;
                
            case SBCMDID_FILEDELETE:
                hRes = _InvokeCommandOnItem(TEXT("delete"));
                break;
            }
        }
        else
            hRes = CNSCBand::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    else
        hRes =  CNSCBand::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    return hRes;
}

// *** IInputObject methods ***
HRESULT CHistBand::TranslateAcceleratorIO(LPMSG pmsg)
{
#ifdef DEBUG
    if (pmsg->message == WM_KEYDOWN)
        TraceMsg(DM_GUIPAINS, "CHistBand -- TranslateAcceleratorIO called and _hwndSearchDlg is %x", _hwndSearchDlg);
#endif

    HWND hwndFocus = GetFocus();
    
    // Translate accelerator messages for dialog
    if ( (_hwndSearchDlg) && (hwndFocus != _hwndNSC) && (!hwndFocus || !IsChild(_hwndNSC, hwndFocus)) )
    {
        if (pmsg->message == WM_KEYDOWN)
        {
            if (IsVK_TABCycler(pmsg))
            {
                BOOL fBackwards = (GetAsyncKeyState(VK_SHIFT) < 0);
                HWND hwndCur = pmsg->hwnd;
                if (GetParent(pmsg->hwnd) != _hwndSearchDlg)
                    hwndCur = NULL;
                
                HWND hwndNext  = GetNextDlgTabItem(_hwndSearchDlg, hwndCur, fBackwards);
                
                // Get the First dialog item in this searching order
                HWND hwndFirst;
                if (!fBackwards) 
                {
                    hwndFirst = GetNextDlgTabItem(_hwndSearchDlg, NULL, FALSE);
                }
                else
                {
                    // passing NULL for the 2nd parameter returned NULL with ERROR_SUCCESS,
                    //  so this is a workaround
                    hwndFirst = GetNextDlgTabItem(_hwndSearchDlg, GetNextDlgTabItem(_hwndSearchDlg, NULL, FALSE), TRUE);
                }
                
                // If the next dialog tabstop is the first dialog tabstop, then
                //   let someone else get focus
                if ((!hwndCur) || (hwndNext != hwndFirst))
                {
                    SetFocus(hwndNext);
                    return S_OK;
                }
                else if (!fBackwards) 
                {
                    SetFocus(_hwndNSC);
                    return S_OK;
                }
            }
            else if ((pmsg->wParam == VK_RETURN))
                SendMessage(_hwndSearchDlg, WM_COMMAND, MAKELONG(GetDlgCtrlID(pmsg->hwnd), 0), 0L);
        }
        // The History Search Edit Box is activated
        if (pmsg->hwnd == GetDlgItem(_hwndSearchDlg, IDC_EDITHISTSEARCH)) 
        {
            // If the user pressed tab within the dialog
            return EditBox_TranslateAcceleratorST(pmsg);
        }
    }
    return CNSCBand::TranslateAcceleratorIO(pmsg);
}

// sends appropriate resize messages to our children windows
void CHistBand::_ResizeChildWindows(LONG width, LONG height, BOOL fRepaint)
{
    if (_hwndNSC)
    {
        int y1 = _hwndSearchDlg ? _lSearchDlgHeight : 0;
        int y2 = _hwndSearchDlg ? height - _lSearchDlgHeight : height;

        MoveWindow(_hwndNSC, 0, y1, width, y2, fRepaint);
    }

    if (_hwndSearchDlg)
    {
        MoveWindow(_hwndSearchDlg, 0, 0, width, _lSearchDlgHeight, fRepaint);
    }
}

HRESULT CHistBand::_DoSearchUIStuff()
{
    HRESULT hr;

    // host the search dialog inside my window:
    _hwndSearchDlg = CreateDialogParam(MLGetHinst(), MAKEINTRESOURCE(DLG_HISTSEARCH2),
                                       _hwnd, s_HistSearchDlgProc, reinterpret_cast<LPARAM>(this));

    if (_hwndSearchDlg)
    {
        RECT rcSelf;
        GetClientRect(_hwnd, &rcSelf);
    
        RECT rcDlg;
        GetClientRect(_hwndSearchDlg, &rcDlg);

        _lSearchDlgHeight = rcDlg.bottom;

        _ResizeChildWindows(rcSelf.right, rcSelf.bottom, TRUE);
        ShowWindow(_hwndSearchDlg, SW_SHOWDEFAULT);

        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

// WndProc for main window to go in rebar
LRESULT CALLBACK CHistBand::s_WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CHistBand* phb = reinterpret_cast<CHistBand *>(GetWindowLongPtr(hWnd, GWLP_USERDATA));

    switch (msg)
    {
    case WM_SETFOCUS:
        {
            TraceMsg(DM_GUIPAINS, "Histband Parent -- SETFOCUS");
            // The only way this should be called is via a RB_CYCLEFOCUS->...->UIActivateIO->SetFocus
            //  therefore, we can assume that we're being tabbed into or something with equally good.
            // If we tab into the outer dummy window, transfer the focus to
            //  our appropriate child:
            BOOL fBackwards = (GetAsyncKeyState(VK_SHIFT) < 0);
            if (phb->_hwndSearchDlg) {
                // Select either the first or the last item in the dialog depending on
                //  whether we're shifting in or shifting out
                SetFocus(GetNextDlgTabItem(phb->_hwndSearchDlg, (NULL), fBackwards));
            }
            else {
                TraceMsg(DM_GUIPAINS, "NSC is being given focus!");
                SetFocus(phb->_hwndNSC);
            }
        }
        return 0;
    case WM_CREATE:
        SetWindowLongPtr(hWnd, GWLP_USERDATA,
                      (reinterpret_cast<LONG_PTR>((reinterpret_cast<CREATESTRUCT *>(lParam))->lpCreateParams)));
        return 0;
    case WM_SIZE:
        if (phb)
            phb->_ResizeChildWindows(LOWORD(lParam), HIWORD(lParam), TRUE);
        return 0;
    case WM_NCDESTROY:
        //make sure the search object gets freed when the view/window is destroyed, because it holds a ref to us
        phb->_ClearSearch(); // should we null out GWLP_USERDATA?
        break;
        
    case WM_NOTIFY:
        {
            if (phb) 
            {
                // We proxy the notification messages to our own parent who thinks that we
                //  are the namespace control
                LPNMHDR pnmh = (LPNMHDR)lParam;
                
                // Notification message coming from NSC
                if (pnmh->hwndFrom == phb->_hwndNSC)
                    return SendMessage(phb->_hwndParent, msg, wParam, lParam);
            }
        } // INTENTIONAL FALLTHROUGH
    }
    return DefWindowProc(hWnd, msg, wParam, lParam);
}

// *** IOleWindow methods ***
HRESULT CHistBand::GetWindow(HWND *phwnd)
{
    if (!_hwnd)
    {
        // we want to wrap a window around the namespace control so
        //  that we can add siblings later
        
        // Get our parent's dimensions
        RECT rcParent;
        GetClientRect(_hwndParent, &rcParent);

        static LPTSTR pszClassName = TEXT("History Pane");

        WNDCLASSEX wndclass    = { 0 };
        wndclass.cbSize        = sizeof(wndclass);
        wndclass.style         = CS_PARENTDC | CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc   = s_WndProc;
        wndclass.hInstance     = g_hinst;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.lpszClassName = pszClassName;

        RegisterClassEx(&wndclass);
    
        _hwnd = CreateWindow(pszClassName, TEXT("History Window"),
                             WS_CHILD | WS_TABSTOP,
                             0, 0, rcParent.right, rcParent.bottom,
                             _hwndParent, NULL, g_hinst, (LPVOID)this);
    }
    
    if (_hwnd)   // Host NSC
        _pns->CreateTree(_hwnd, _GetTVStyle(), &_hwndNSC);

    return CToolBand::GetWindow(phwnd);
}

// *** IDockingWindow methods ***
HRESULT CHistBand::ShowDW(BOOL fShow)
{
    HRESULT hr = CNSCBand::ShowDW(fShow);
    _AddButtons(fShow);
    return hr;
}

static const TBBUTTON c_tbHistory[] =
{
    { I_IMAGENONE, FCIDM_HISTBAND_VIEW,   TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_WHOLEDROPDOWN | BTNS_SHOWTEXT,  {0,0}, 0, 0 },
    {           2, FCIDM_HISTBAND_SEARCH, TBSTATE_ENABLED, BTNS_AUTOSIZE | BTNS_SHOWTEXT,                       {0,0}, 0, 1 },
};

// Adds buttons from the above table to the Explorer
void CHistBand::_AddButtons(BOOL fAdd)
{
    // don't add button if we have no menu
    if (!_hViewMenu)
        return;

    IExplorerToolbar* piet;
    if (SUCCEEDED(_punkSite->QueryInterface(IID_PPV_ARG(IExplorerToolbar, &piet))))
    {
        if (fAdd)
        {
            piet->SetCommandTarget((IUnknown*)SAFECAST(this, IOleCommandTarget*), &CLSID_HistBand, 0);

            if (!_fStrsAdded)
            {
                piet->AddString(&CLSID_HistBand, MLGetHinst(), IDS_HIST_BAR_LABELS, &_lStrOffset);
                _fStrsAdded = TRUE;
            }

            _EnsureImageListsLoaded();
            piet->SetImageList(&CLSID_HistBand, _himlNormal, _himlHot, NULL);

            TBBUTTON tbHistory[ARRAYSIZE(c_tbHistory)];
            memcpy(tbHistory, c_tbHistory, sizeof(TBBUTTON) * ARRAYSIZE(c_tbHistory));
            for (int i = 0; i < ARRAYSIZE(c_tbHistory); i++)
                tbHistory[i].iString += (long) _lStrOffset;

            piet->AddButtons(&CLSID_HistBand, ARRAYSIZE(tbHistory), tbHistory);
        }
        else
            piet->SetCommandTarget(NULL, NULL, 0);

        piet->Release();
    }
}

// *** IShellFolderSearchableCallback methods ***
// enable and disable cancel buttons 
HRESULT CHistBand::RunBegin(DWORD dwReserved)
{
    HRESULT hr = E_FAIL;
    if (_hwndSearchDlg)
    {
        SendMessage(_hwndSearchDlg, WM_SEARCH_STATE, (WPARAM)TRUE, NULL);
        hr = S_OK;
    }
    return hr;
}

HRESULT CHistBand::RunEnd(DWORD dwReserved)
{
    HRESULT hr = E_FAIL;
    if (_hwndSearchDlg)
    {
        SendMessage(_hwndSearchDlg, WM_SEARCH_STATE, (WPARAM)FALSE, NULL);
        hr = S_OK;
    }
    return hr;
}

// A utility function used in the WM_SIZE handling below...
inline HWND _GetHwndAndRect(HWND hwndDlg, int item, BOOL fClient, RECT &rc) 
{
    HWND hwnd = GetDlgItem(hwndDlg, item);
    if (fClient)
    {
        GetClientRect(hwnd, &rc);
    }
    else 
    {
        GetWindowRect(hwnd, &rc);
        MapWindowPoints(NULL, hwndDlg, ((LPPOINT)&rc), 2);
    }
    return hwnd;
}

LRESULT CALLBACK CHistBand::s_EditWndSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg) 
    {
    case WM_KEYDOWN:
        if ((GetAsyncKeyState(VK_CONTROL) < 0) && (wParam == TEXT('U'))) 
        {
            uMsg   = WM_SETTEXT;
            wParam = 0;
            lParam = ((LPARAM)(LPCTSTR)TEXT(""));
        }
        break;

    case WM_CHAR:
        if (wParam == VK_RETURN) 
        {
            PostMessage(GetParent(hwnd), WM_COMMAND, MAKELONG(IDB_HISTSRCH_GO, 0), 0L);
            return 0L;
        }
        break;
    }
    return CallWindowProc((WNDPROC)(GetWindowLongPtr(hwnd, GWLP_USERDATA)), hwnd, uMsg, wParam, lParam);
}


// Please see note at top of file for explanation...
INT_PTR CALLBACK CHistBand::s_HistSearchDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg) 
    {
    case WM_PAINT:
        {
            // paint a little separator bar on the bottom
            PAINTSTRUCT ps;
            RECT        rcSelf;
            HDC         hdc = BeginPaint(hwndDlg, &ps);
            GetClientRect(hwndDlg, &rcSelf);
            RECT        rcFill = { 0, rcSelf.bottom - 2, rcSelf.right, rcSelf.bottom };
            FillRect(hdc, &rcFill, GetSysColorBrush(COLOR_BTNFACE));
            EndPaint(hwndDlg, &ps);
            break;
        }

    // Supply child controls with correct bkgd color
    case WM_CTLCOLORSTATIC:
        if ((HWND)lParam == GetDlgItem(hwndDlg, IDD_HISTSRCH_ANIMATION)) 
        {
            SetBkColor((HDC)wParam, GetSysColor(COLOR_WINDOW));
            return (INT_PTR) GetSysColorBrush(COLOR_WINDOW);
        }
        else 
        {
            SetBkMode((HDC)wParam, TRANSPARENT);
            return (INT_PTR) GetSysColorBrush(COLOR_WINDOW);
        }
    case WM_CTLCOLORDLG:
        //SetBkColor((HDC)HIWORD(lParam), GetSysColor(COLOR_WINDOW));
        return (INT_PTR) GetSysColorBrush(COLOR_WINDOW);
    case WM_INITDIALOG: 
    {
        HWND    hwndEdit       = GetDlgItem(hwndDlg, IDC_EDITHISTSEARCH);
        WNDPROC pfnOldEditProc = (WNDPROC)(GetWindowLongPtr(hwndEdit, GWLP_WNDPROC));

        // subclass the editbox
        SetWindowLongPtr(hwndEdit, GWLP_USERDATA, (LPARAM)pfnOldEditProc);
        SetWindowLongPtr(hwndEdit, GWLP_WNDPROC,  (LPARAM)s_EditWndSubclassProc);
        
        SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
        Animate_Open(GetDlgItem(hwndDlg, IDD_HISTSRCH_ANIMATION),
                     MAKEINTRESOURCE(IDA_HISTSEARCHAVI));

        // limit the edit control to MAX_PATH-1 characters
        Edit_LimitText(hwndEdit, MAX_PATH-1);

        break;
    }
    case WM_DESTROY:
        Animate_Close(GetDlgItem(hwndDlg, IDD_HISTSRCH_ANIMATION));
        break;
    case WM_SIZE: 
    {
        if (wParam == SIZE_RESTORED) 
        {
            UINT uWidth  = LOWORD(lParam);
            UINT uHeight = HIWORD(lParam);

            RECT rcAnimSize, rcCancel, rcSearch, rcEdit, rcStatic;
            HWND hwndAnim   = _GetHwndAndRect(hwndDlg, IDD_HISTSRCH_ANIMATION, TRUE,  rcAnimSize);
            HWND hwndCancel = _GetHwndAndRect(hwndDlg, IDCANCEL,               FALSE, rcCancel);
            HWND hwndSearch = _GetHwndAndRect(hwndDlg, IDB_HISTSRCH_GO,        FALSE, rcSearch);
            HWND hwndEdit   = _GetHwndAndRect(hwndDlg, IDC_EDITHISTSEARCH,     FALSE, rcEdit);
            
            // calculate the minimum tolerable width
            UINT uMinWidth  = ((rcCancel.right - rcCancel.left) +
                               (rcSearch.right - rcSearch.left) + HISTSRCH_BUTTONDIST +
                               rcEdit.left +
                               rcAnimSize.right + 1);

            if (uWidth < uMinWidth)
                uWidth = uMinWidth;

            HDWP hdwp = BeginDeferWindowPos(5);
            if (hdwp)
            {
                // align the animation box with the upper-right corner
                DeferWindowPos(hdwp, hwndAnim, HWND_TOP, uWidth - rcAnimSize.right, 0,
                               rcAnimSize.right, rcAnimSize.bottom, SWP_NOZORDER);
                
                // stretch the textbox as wide as possible
                UINT uNewTextWidth = uWidth - rcAnimSize.right - 1 - rcEdit.left;
                DeferWindowPos(hdwp, hwndEdit, HWND_TOP, rcEdit.left, rcEdit.top, uNewTextWidth,
                               rcEdit.bottom - rcEdit.top, SWP_NOZORDER);
                
                // static text should not be longer than edit textbox
                HWND hwndStatic = _GetHwndAndRect(hwndDlg, IDC_HISTSRCH_STATIC, FALSE, rcStatic);
                DeferWindowPos(hdwp, hwndStatic, HWND_TOP, rcEdit.left, rcStatic.top, uNewTextWidth,
                               rcStatic.bottom - rcStatic.top, SWP_NOZORDER);
                
                // align the cancel button with the right of the edit box
                UINT uCancelLeft = uWidth - rcAnimSize.right - 1 - (rcCancel.right - rcCancel.left);
                DeferWindowPos(hdwp, hwndCancel, HWND_TOP, uCancelLeft, rcCancel.top,
                               rcCancel.right - rcCancel.left, rcCancel.bottom - rcCancel.top, SWP_NOZORDER);
                
                // align the search button so that it ends six pixels (HISTSRCH_BUTTONDIST)
                //   to the left of the cancel button
                DeferWindowPos(hdwp, hwndSearch, HWND_TOP,
                               uCancelLeft - HISTSRCH_BUTTONDIST - (rcSearch.right - rcSearch.left),
                               rcSearch.top, rcSearch.right - rcSearch.left, rcSearch.bottom - rcSearch.top, SWP_NOZORDER);

                EndDeferWindowPos(hdwp);
            }
        }
        else
            return FALSE;
        break;
    }
    case WM_COMMAND:
        {
            CHistBand *phb = reinterpret_cast<CHistBand *>(GetWindowLongPtr(hwndDlg, DWLP_USER));

            switch (LOWORD(wParam))
            {
            case IDC_EDITHISTSEARCH:
                switch (HIWORD(wParam))
                {
                case EN_SETFOCUS:
                    // This guy allows us to intercept TranslateAccelerator messages
                    //  like backspace.  This is the same as calling UIActivateIO(TRUE), but
                    //  doesn't cause an infinite setfocus loop in Win95
                    IUnknown_OnFocusChangeIS(phb->_punkSite, SAFECAST(phb, IInputObject*), TRUE);
                    SetFocus((HWND)lParam);
                    break;
                case EN_CHANGE:
                    // Enable 'Go Fish' button iff there is text in the edit box
                    EnableWindow(GetDlgItem(hwndDlg, IDB_HISTSRCH_GO),
                                 (bool) SendDlgItemMessage(hwndDlg, IDC_EDITHISTSEARCH, EM_LINELENGTH, 0, 0));
                    break;
                }
                break;
            case IDB_HISTSRCH_GO:
                {
                    TCHAR szSearchString[MAX_PATH];
                    if (GetDlgItemText(hwndDlg, IDC_EDITHISTSEARCH, szSearchString, ARRAYSIZE(szSearchString)))
                    {
                        IServiceProvider *pServiceProvider;
                        
                        HRESULT hr = IUnknown_QueryService(phb->_punkSite, 
                                                           SID_SProxyBrowser, 
                                                           IID_PPV_ARG(IServiceProvider, 
                                                           &pServiceProvider));

                        if (SUCCEEDED(hr))
                        {
                            IWebBrowser2 *pWebBrowser2;
                            hr = pServiceProvider->QueryService(SID_SWebBrowserApp, 
                                                                IID_PPV_ARG(IWebBrowser2, 
                                                                &pWebBrowser2));
                            if (SUCCEEDED(hr))
                            {
                                ::PutFindText(pWebBrowser2, szSearchString);
                                pWebBrowser2->Release();
                            }

                            pServiceProvider->Release();
                        }

                        phb->_ExecuteSearch(szSearchString);
                    }
                }
                break;
            case IDCANCEL:
                {
                    if (phb->_EnsureSearch())
                    {
                        phb->_psfSearch->CancelAsyncSearch(phb->_pidlSearch, NULL);
                    }
                    break;
                }
            default:
                return FALSE;
            }
        }
        return FALSE;

    case WM_SEARCH_STATE:
        {
            BOOL fStart = (BOOL)wParam;
            if (fStart)
            {
                Animate_Play(GetDlgItem(hwndDlg, IDD_HISTSRCH_ANIMATION), 0, -1, -1);
            }
            else 
            {
                HWND hwndAnim = GetDlgItem(hwndDlg, IDD_HISTSRCH_ANIMATION);
                Animate_Stop(hwndAnim);
                Animate_Seek(hwndAnim, 0); // reset the animation

                //HACK for IE5 ship
                //if there's only one item found in history search, the item doesn't display
                //because someone (comctl32?) set redraw to false.
                //so, manually force it to true when the search stops
                CHistBand *phb = reinterpret_cast<CHistBand *>(GetWindowLongPtr(hwndDlg, DWLP_USER));
                if (phb)
                    SendMessage(phb->_hwndNSC, WM_SETREDRAW, TRUE, 0);
            }
            HWND hwndFocus = GetFocus();

            EnableWindow(GetDlgItem(hwndDlg, IDC_EDITHISTSEARCH), !fStart);
            EnableWindow(GetDlgItem(hwndDlg, IDB_HISTSRCH_GO), !fStart);            
            EnableWindow(GetDlgItem(hwndDlg, IDCANCEL), fStart);

            //make sure the focus goes to the right place
            if ((NULL != hwndFocus) && (hwndFocus == GetDlgItem(hwndDlg, IDC_EDITHISTSEARCH) ||
                                       (hwndFocus == GetDlgItem(hwndDlg, IDCANCEL))))
                SetFocus(GetDlgItem(hwndDlg, fStart ? IDCANCEL : IDC_EDITHISTSEARCH));
            break;
        }

    default:
        return FALSE;
    }
    return TRUE;
}

IShellFolderSearchable *CHistBand::_EnsureSearch() 
{
    ASSERT(_psfHistory);
    
    if (!_pidlSearch) 
    {
        _psfHistory->QueryInterface(IID_PPV_ARG(IShellFolderSearchable, &_psfSearch));
    }
    return _psfSearch;
}

HRESULT CHistBand::_ClearSearch() 
{
    HRESULT hr = S_FALSE;

    if (_pidlSearch) 
    {
        if (_EnsureSearch())
        {
            EVAL(SUCCEEDED(_psfSearch->CancelAsyncSearch(_pidlSearch, NULL)));
            hr = _psfSearch->InvalidateSearch(_pidlSearch, NULL);
        }
        ILFree(_pidlSearch);
        _pidlSearch = NULL;
    }
    return hr;
}
    
HRESULT CHistBand::_ExecuteSearch(LPTSTR pszSearchString)
{
    HRESULT hr = E_FAIL;
    
    if (_EnsureSearch())
    {
        _ClearSearch();
        hr = _psfSearch->FindString(pszSearchString,
                                                     NULL,
                                                     reinterpret_cast<IUnknown *>
                                                     (static_cast<IShellFolderSearchableCallback *>
                                                      (this)),
                                                     &_pidlSearch);
        if (SUCCEEDED(hr))
        {
            _ChangePidl(ILCombine(_pidlHistory, _pidlSearch));
        }
    }
    return hr;
}

#ifdef SPLIT_HISTORY_VIEW_BUTTON
UINT CHistBand::_NextMenuItem() 
{
    if (_uViewCheckedItem + 1 > _nViews)
        return 1;
    else
        return _uViewCheckedItem + 1;
}
#endif

HRESULT CHistBand::_ViewPopupSelect(UINT idCmd) 
{
    HRESULT hr = E_FAIL;

    if (idCmd == MENUID_SEARCH)
    {
        if (_uViewCheckedItem != MENUID_SEARCH)
        {
            // display the dialog box
            if (SUCCEEDED(hr = _DoSearchUIStuff()))
            {
                _ChangePidl((LPITEMIDLIST)INVALID_HANDLE_VALUE); // blank out NSC
                _uViewCheckedItem = MENUID_SEARCH;
                CheckMenuRadioItem(_hViewMenu, 1, _iMaxMenuID, _uViewCheckedItem, MF_BYCOMMAND);
            }
        }
        if (_hwndSearchDlg)
            SetFocus(GetDlgItem(_hwndSearchDlg, IDC_EDITHISTSEARCH));
    }
    else
    {
        LPCITEMIDLIST pidlNewSelect = _MenuIDToPIDL(idCmd);
        if (pidlNewSelect) 
        {
            if (ILIsEmpty(pidlNewSelect))
                hr = _ChangePidl(ILClone(_pidlHistory));
            else
                hr = _ChangePidl(ILCombine(_pidlHistory, pidlNewSelect));

            if (SUCCEEDED(hr))
                hr = _SelectPidl(NULL, TRUE, pidlNewSelect);

            // deleted "&& _uViewCheckedItem >= 0" from test below
            // because UINTs are by definition always >= 0
            if (SUCCEEDED(hr))
            {
                // get rid of search dialog -- its no longer needed
                if (_hwndSearchDlg) 
                {
                    EndDialog(_hwndSearchDlg, 0);
                    DestroyWindow(_hwndSearchDlg);
                    _hwndSearchDlg = NULL;
                    // invalidate the previous search and prepare for the next
                    _ClearSearch();
                    RECT rcSelf;
                    GetClientRect(_hwnd, &rcSelf);
                    _ResizeChildWindows(rcSelf.right, rcSelf.bottom, TRUE);
                }
                
                _uViewCheckedItem = idCmd;
                CheckMenuRadioItem(_hViewMenu, 1, _iMaxMenuID,
                                   _uViewCheckedItem, MF_BYCOMMAND);
                // write out the new selection to registry
                EVAL(SUCCEEDED(_SetRegistryPersistView(_uViewCheckedItem)));
                hr = S_OK;
            }
        }
    }
    return hr;
}

HRESULT CHistBand::_DoViewPopup(int x, int y)
{
    if (!_hViewMenu) return E_FAIL;

    HRESULT hr = E_FAIL;

    UINT idCmd = TrackPopupMenu(_hViewMenu, TPM_RETURNCMD, x, y, 0, _hwnd, NULL);
    // Currently, re-selecting the menu item will cause the item to be refreshed
    //  This makes sense to me, but it can be prevented by
    //  testing idCmd != _uViewCheckedItem
    if ((idCmd > 0))
    {
        return _ViewPopupSelect(idCmd);
    }
    else
        hr = S_FALSE;

    return hr;
}

// Change the current select NSC pidl
// WARNING: The pidl passed in will be assimilated by us...
//          We will deallocate it.
HRESULT CHistBand::_ChangePidl(LPITEMIDLIST pidl) 
{
    if (_pidl)
        ILFree(_pidl);

    _pidl = pidl;
    if ((LPITEMIDLIST)INVALID_HANDLE_VALUE == pidl)
        _pidl = NULL;
    _pns->Initialize(pidl, (SHCONTF_FOLDERS | SHCONTF_NONFOLDERS), (NSS_DROPTARGET | NSS_BROWSERSELECT));
    return S_OK;
}

// _SelectPidl - Have NSC change the current selected pidl
//
// passing NULL for pidlSelect will select the current select pidl
HRESULT CHistBand::_SelectPidl(LPCITEMIDLIST pidlSelect,        // <-Standard Hist-type pidl to select
                               BOOL fCreate,                    // <-create NSC item if not there?
                               LPCITEMIDLIST pidlView,/*=NULL*/ // <-special history view type or NULL
                               BOOL fReinsert /*=0*/)           // <-reinsert pidl into NSC and re-sort
{
    HRESULT hRes = S_OK;
    LPITEMIDLIST pidlSelectToFree = NULL;
    if (!pidlSelect)
    {
        pidlSelectToFree = _GetCurrentSelectPidl();

        pidlSelect = pidlSelectToFree;
    }
    
    if (pidlSelect) 
    {
        LPITEMIDLIST pidlNewSelect = NULL;

        // cache the last selected pidl
        if (_pidlLastSelect != pidlSelect) 
        {
            if (_pidlLastSelect)
                ILFree(_pidlLastSelect);
            _pidlLastSelect = ILClone(pidlSelect);
        }

        if (pidlView && !ILIsEmpty(pidlView)) 
        {
            IShellFolderViewType *psfvtInfo = _GetViewTypeInfo();
            if (psfvtInfo) 
            {
                LPITEMIDLIST pidlFromRoot = ILFindChild(_pidlHistory, pidlSelect);
                if (pidlFromRoot && !ILIsEmpty(pidlFromRoot))
                {
                    LPITEMIDLIST pidlNewFromRoot;
                    if (SUCCEEDED(psfvtInfo->TranslateViewPidl(pidlFromRoot, pidlView, &pidlNewFromRoot)))
                    {
                        if (pidlNewFromRoot) 
                        {
                            pidlNewSelect = ILCombine(_pidlHistory, pidlNewFromRoot);
                            if (pidlNewSelect) 
                            {
                                _pns->SetSelectedItem(pidlNewSelect, fCreate, fReinsert, 0);
                                ILFree(pidlNewSelect);
                            }
                            ILFree(pidlNewFromRoot);
                        }
                    }
                }
                psfvtInfo->Release();
            }
        }
        else
            _pns->SetSelectedItem(pidlSelect, fCreate, fReinsert, 0);

        ILFree(pidlSelectToFree);
    }
    return hRes;
}

HRESULT CHistBand::_SetRegistryPersistView(int iMenuID) 
{
    LPCITEMIDLIST pidlReg = _MenuIDToPIDL(iMenuID);
    if (!pidlReg)
        return E_FAIL;

    LONG lRet = (SHRegSetUSValue(REGSTR_PATH_MAIN, REGKEY_HISTORY_VIEW,
                         REG_BINARY, (LPVOID)pidlReg, ILGetSize(pidlReg),
                         SHREGSET_HKCU | SHREGSET_FORCE_HKCU));
    return HRESULT_FROM_WIN32(lRet);
}

// Get the default view from the registry as a menu item
int CHistBand::_GetRegistryPersistView() 
{
    int          iRegMenu = -1;
    DWORD        dwType = REG_BINARY;

    ITEMIDLIST   pidlDefault = { 0 };

    // make a preliminary call to find out the size of the data
    DWORD cbData = 0;
    LONG error   = SHRegGetUSValue(REGSTR_PATH_MAIN, REGKEY_HISTORY_VIEW, &dwType,
                                   NULL, &cbData, FALSE, &pidlDefault,
                                   sizeof(pidlDefault));
    if (cbData)
    {
        LPITEMIDLIST pidlReg = ((LPITEMIDLIST)SHAlloc(cbData));
        if (pidlReg)
        {
            error = SHRegGetUSValue(REGSTR_PATH_MAIN, REGKEY_HISTORY_VIEW, &dwType,
                                    (LPVOID)pidlReg, &cbData, FALSE, &pidlDefault,
                                    sizeof(pidlDefault));

            if (error == ERROR_SUCCESS)
                iRegMenu = _PIDLToMenuID(pidlReg);

            SHFree(pidlReg);
        }
    }

    return iRegMenu;
}

LPCITEMIDLIST CHistBand::_MenuIDToPIDL(UINT uMenuID) 
{
    ASSERT(_ppidlViewTypes);
    if ((uMenuID > 0) && (uMenuID <= _nViews))
        return _ppidlViewTypes[uMenuID - 1];
    return NULL;
}

int CHistBand::_PIDLToMenuID(LPITEMIDLIST pidl) 
{
    ASSERT(_psfHistory && _ppidlViewTypes);

    int iMenuID = -1;

    // handle the empty pidl, which designates the
    //  default view, separately
    if (ILIsEmpty(pidl))
        iMenuID = 1;
    else 
    {
        for (UINT u = 0; u < _nViews; ++u) 
        {
            if (ShortFromResult(_psfHistory->CompareIDs(0, pidl, _ppidlViewTypes[u])) == 0)
                iMenuID = u + 1;
        }
    }
    return iMenuID;
}

// remember to release return value
IShellFolderViewType* CHistBand::_GetViewTypeInfo() 
{
    IShellFolderViewType* psfvRet = NULL;

    if (_psfvtCache)
    {
        _psfvtCache->AddRef();
        psfvRet = _psfvtCache;
    }
    else if (_psfHistory)
    {
        // QI For the views
        // We set the pointer because of a bad QI somewhere...
        if (SUCCEEDED(_psfHistory->QueryInterface(IID_PPV_ARG(IShellFolderViewType, &psfvRet))))
        {
            _psfvtCache = psfvRet;
            psfvRet->AddRef(); // one released in destructor, another by caller
        }
        else
            psfvRet = NULL;
    }
    return psfvRet;
}

HRESULT CHistBand::_FreeViewInfo() 
{
    if (_ppidlViewTypes) 
    {
        // the first pidl in this list is NULL, the default view
        for (UINT u = 0; u < _nViews; ++u)
        {
            ILFree(_ppidlViewTypes[u]);
        }
        LocalFree(_ppidlViewTypes);
        _ppidlViewTypes = NULL;
    }
    
    if (_ppszStrViewNames) 
    {
        for (UINT u = 0; u < _nViews; ++u)
        {
            if (EVAL(_ppszStrViewNames[u]))
                CoTaskMemFree(_ppszStrViewNames[u]);
        }
        LocalFree(_ppszStrViewNames);
        _ppszStrViewNames = NULL;
    }
    return S_OK;
}

// Load the popup menu (if there are views to be had)
HRESULT CHistBand::_InitViewPopup() 
{
    HRESULT hRes = E_FAIL;

    _iMaxMenuID = 0;

    if (SUCCEEDED((hRes = _GetHistoryViews()))) 
    {
        if ((_hViewMenu = CreatePopupMenu()))
        {
            // the IDCMD for the view menu will always be
            //   one more than the index into the view tables
            for (UINT u = 0; u < _nViews; ++u) 
            {
                int iMenuID = _PIDLToMenuID(_ppidlViewTypes[u]);
                if (iMenuID >= 0)
                    AppendMenu(_hViewMenu, MF_STRING, iMenuID, _ppszStrViewNames[u]);
                    
                if (iMenuID > _iMaxMenuID)
                    _iMaxMenuID = iMenuID;
            }

            // retrieve the persisted view information
            //  and check the corresponding menu item
            int iSelectMenuID = _GetRegistryPersistView();
            if (iSelectMenuID < 0 || ((UINT)iSelectMenuID) > _nViews)
                iSelectMenuID = 1; //bogus menuid
            _uViewCheckedItem = iSelectMenuID;
            CheckMenuRadioItem(_hViewMenu, 1, _nViews, _uViewCheckedItem, MF_BYCOMMAND);
        }
    }

#ifdef HISTORY_VIEWSEARCHMENU
    // if this is a searchable shell folder, then add the search menu item
    if (_EnsureSearch())
    {
        hRes = S_OK;

        // only add separator if there is a menu already!
        if (!_hViewMenu)
            _hViewMenu = CreatePopupMenu();
        else
            AppendMenu(_hViewMenu, MF_SEPARATOR, 0, NULL);

        if (_hViewMenu)
        {
            TCHAR szSearchMenuText[MAX_PATH];
            LoadString(MLGetHinst(), IDS_SEARCH_MENUOPT,
                       szSearchMenuText, ARRAYSIZE(szSearchMenuText));
            AppendMenu(_hViewMenu, MF_STRING, MENUID_SEARCH, szSearchMenuText);
            _iMaxMenuID = MENUID_SEARCH;
        }
        else
            hRes = E_FAIL;
    }
#endif
    return hRes;
}

// This guy calls the enumerator
HRESULT CHistBand::_GetHistoryViews() 
{
    ASSERT(_psfHistory);
    HRESULT hRes = E_FAIL;

    UINT cbViews; // how many views are allocated

    ASSERT(VIEWTYPE_MAX > 0);

    EVAL(SUCCEEDED(_FreeViewInfo()));

    IShellFolderViewType *psfViewType = _GetViewTypeInfo();
    if (psfViewType)
    {
        // allocate buffers to store the view information
        _ppidlViewTypes = ((LPITEMIDLIST *)LocalAlloc(LPTR, VIEWTYPE_MAX * sizeof(LPITEMIDLIST)));
        if (_ppidlViewTypes) 
        {
            _ppszStrViewNames = ((LPTSTR *)LocalAlloc(LPTR, VIEWTYPE_MAX * sizeof(LPTSTR)));
            if (_ppszStrViewNames) 
            {
                IEnumIDList *penum = NULL;
                cbViews  = VIEWTYPE_MAX;
                _nViews  = 1;
                // get the default view information
                _ppidlViewTypes[0]   = IEILCreate(sizeof(ITEMIDLIST));
                if (_ppidlViewTypes[0] &&
                    SUCCEEDED((hRes = psfViewType->GetDefaultViewName(0, &(_ppszStrViewNames[0])))))
                {
                    // empty pidl will be the default
                    ASSERT(ILIsEmpty(_ppidlViewTypes[0]));
                    // get the iterator for the other views
                    if (SUCCEEDED((hRes = psfViewType->EnumViews(0, &penum)))) 
                    {
                        ULONG cFetched = 0;
                        // iterate to get other view information
                        while (SUCCEEDED(hRes) &&
                               SUCCEEDED(penum->Next(1, &(_ppidlViewTypes[_nViews]), &cFetched)) &&
                               cFetched)
                        {
                            // get the name of this view
                            if (SUCCEEDED(DisplayNameOfAsOLESTR(_psfHistory, _ppidlViewTypes[_nViews], 0, &(_ppszStrViewNames[_nViews]))))
                            {
                                // prepare for next iteration by reallocating the buffer if necessary
                                if (_nViews > cbViews - 1)
                                {
                                    LPITEMIDLIST *ppidlViewTypes = ((LPITEMIDLIST *)LocalReAlloc(_ppidlViewTypes,
                                                                                       (cbViews + VIEWTYPE_REALLOC) * sizeof(LPITEMIDLIST),
                                                                                       LMEM_MOVEABLE | LMEM_ZEROINIT));
                                    if (ppidlViewTypes)
                                    {
                                        _ppidlViewTypes = ppidlViewTypes;
                                        LPTSTR * ppszStrViewNames = ((LPTSTR *)LocalReAlloc(_ppszStrViewNames,
                                                                                   (cbViews + VIEWTYPE_REALLOC) * sizeof(LPTSTR),
                                                                                   LMEM_MOVEABLE | LMEM_ZEROINIT));
                                        if (ppszStrViewNames)
                                        {
                                            _ppszStrViewNames = ppszStrViewNames;
                                            cbViews += VIEWTYPE_REALLOC;
                                        }
                                        else
                                        {
                                            hRes = E_OUTOFMEMORY;
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        hRes = E_OUTOFMEMORY;
                                        break;
                                    }
                                }
                                ++_nViews;
                            }
                        }
                        penum->Release();
                    }
                }
            }
        }
        psfViewType->Release();
    }
    return hRes;
}

HRESULT CHistBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    CHistBand * phb = new CHistBand();
    if (!phb)
        return E_OUTOFMEMORY;

    ASSERT(phb->_pidlHistory    == NULL &&
           phb->_pidlLastSelect == NULL &&
           phb->_pidl           == NULL &&
           phb->_psfvtCache     == NULL);


    if (SUCCEEDED(SHGetHistoryPIDL(&(phb->_pidlHistory))) &&
        SUCCEEDED(IEBindToObject(phb->_pidlHistory,
                                 &(phb->_psfHistory))))
    {
        HRESULT hResLocal = E_FAIL;

        // if we can get different views, then init with the persisted
        //   view type, otherwise, init with the top-level history type
        if (SUCCEEDED(phb->_InitViewPopup())) 
        {
            LPCITEMIDLIST pidlInit = phb->_MenuIDToPIDL(phb->_uViewCheckedItem);
            if (pidlInit) 
            {
                LPITEMIDLIST pidlFullInit = ILCombine(phb->_pidlHistory, pidlInit);
                if (pidlFullInit) 
                {
                    hResLocal = phb->_Init(pidlFullInit);
                    ILFree(pidlFullInit);
                }
            }
        }
        else
            hResLocal = phb->_Init(phb->_pidlHistory);

        // From old favband code: // if (SUCCEEDED(phb->_Init((LPCITEMIDLIST)CSIDL_FAVORITES)))
        if (SUCCEEDED(hResLocal))
        {
            phb->_pns = CNscTree_CreateInstance();
            if (phb->_pns)
            {
                ASSERT(poi);
                phb->_poi = poi;
                // if you change this cast, fix up CChannelBand_CreateInstance
                *ppunk = SAFECAST(phb, IDeskBand *);

                IUnknown_SetSite(phb->_pns, *ppunk);
                phb->_SetNscMode(MODE_HISTORY);
                return S_OK;
            }
        }
    }

    phb->Release();

    return E_FAIL;
}

// Ask the powers that be which pidl is selected...
LPITEMIDLIST CHistBand::_GetCurrentSelectPidl(IOleCommandTarget *poctProxy/* = NULL*/) 
{
    LPITEMIDLIST pidlRet = NULL;
    VARIANT var;
    BOOL    fReleaseProxy = FALSE;
    VariantInit(&var);
    var.vt = VT_EMPTY;

    if (poctProxy == NULL) 
    {
        IBrowserService *pswProxy;
        if (SUCCEEDED(QueryService(SID_SProxyBrowser, IID_PPV_ARG(IBrowserService, &pswProxy))))
        {
            ASSERT(pswProxy);
            if (FAILED(pswProxy->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &poctProxy))))
            {
                pswProxy->Release();
                return NULL;
            }
            else
                fReleaseProxy = TRUE;

            pswProxy->Release();
        }
    }

    //  Inquire the current select pidl
    if (poctProxy && (SUCCEEDED(poctProxy->Exec(&CGID_Explorer, SBCMDID_GETHISTPIDL, OLECMDEXECOPT_PROMPTUSER, NULL, &var))) &&
        (var.vt != VT_EMPTY))
    {
        pidlRet = VariantToIDList(&var);
        VariantClearLazy(&var);
    }
    if (fReleaseProxy)
        poctProxy->Release();
    return pidlRet;
}

// gets called by CNSCBand::ShowDW every time history band is shown
HRESULT CHistBand::_OnRegisterBand(IOleCommandTarget *poctProxy) 
{
    HRESULT hRes = E_FAIL;
    if (_uViewCheckedItem != MENUID_SEARCH)
    {
        LPITEMIDLIST pidlSelect = _GetCurrentSelectPidl(poctProxy);
        if (pidlSelect)
        {
            _SelectPidl(pidlSelect, TRUE);
            ILFree(pidlSelect);
            hRes = S_OK;
        }
    }
    return hRes;
}

HRESULT CHistBand::_InitializeNsc()
{
    return _pns->Initialize(_pidl, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, NSS_NOHISTSELECT | NSS_DROPTARGET | NSS_BROWSERSELECT);
}

BOOL CHistBand::_ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib)
{
    return !(ulAttrib & SFGAO_FOLDER);
}

HRESULT CHistBand::_NavigateRightPane(IShellBrowser *psb, LPCITEMIDLIST pidl)
{
    HRESULT hr = psb->BrowseObject(pidl, SBSP_SAMEBROWSER | SBSP_NOAUTOSELECT);
    if (SUCCEEDED(hr))
    {
        IOleCommandTarget *poctProxy;
        if (SUCCEEDED(QueryService(SID_SProxyBrowser, IID_PPV_ARG(IOleCommandTarget, &poctProxy))))
        {
            VARIANTARG var;
            
            InitVariantFromIDList(&var, pidl);
            poctProxy->Exec(&CGID_Explorer, SBCMDID_SELECTHISTPIDL, OLECMDEXECOPT_PROMPTUSER, &var, NULL);
            VariantClear(&var);
            poctProxy->Release();
        }
        UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_NAVIGATE, UIBL_NAVHIST);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hnfblock.h ===
#ifndef HNFBLOCK_H_
#define HNFBLOCK_H_
#include <iethread.h>

#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */

DECLARE_HANDLE(HNFBLOCK);

HNFBLOCK ConvertNFItoHNFBLOCK(IETHREADPARAM* pInfo, LPCTSTR pszPath, DWORD dwProcId);
IETHREADPARAM *ConvertHNFBLOCKtoNFI(HNFBLOCK hBlock);

#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */

#endif // HNFBLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hlframe.cpp ===
#include "priv.h"
#include "resource.h"
#include "hlframe.h"
#include "bindcb.h"
#include "winlist.h"
#include "iface.h"
#include "shdocfl.h"
#include <optary.h>
#include <mluisupp.h>

#define DM_SHELLEXECOBJECT    0x80000000


// flags for SHDVID_DOCFAMILYCHARSET communication
#define DFC_URLCHARSET  1

#ifdef FEATURE_PICS
#include "dochost.h"    /* for IID_IsPicsBrowser */
#endif

#ifdef DEBUG
extern DWORD g_dwPerf;
#endif

#define DM_HLINKTRACE DM_TRACE

#define DM_WEBCHECKDRT          0
#define JMPMSG(psz, psz2)    TraceMsg(0, "shlf TR-CDOV::%s %s", psz, psz2)
#define JMPMSG2(psz, x)        TraceMsg(0, "shlf TR-CDOV::%s %x", psz, x)
#define DOFMSG(psz)        TraceMsg(0, "shlf TR-DOF::%s", psz)
#define DOFMSG2(psz, x)        TraceMsg(0, "shlf TR-DOF::%s %x", psz, x)
#define URLMSG(psz)        TraceMsg(0, "shlf TR-DOF::%s", psz)
#define URLMSG2(psz, x)        TraceMsg(0, "shlf TR-DOF::%s %x", psz, x)
#define URLMSG3(psz, x, y)    TraceMsg(0, "shlf TR-DOF::%s %x %x", psz, x, y)
#define BSCMSG(psz, i, j)    TraceMsg(0, "shlf TR-BSC::%s %x %x", psz, i, j)
#define BSCMSG3(psz, i, j, k)    TraceMsg(0, "shlf TR-BSC::%s %x %x %x", psz, i, j, k)
#define BSCMSGS(psz, sz)    TraceMsg(0, "shlf TR-BSC::%s %s", psz, sz)
#define OIPSMSG(psz)        TraceMsg(0, "shlf TR-OIPS::%s", psz)
#define OIPSMSG3(psz, sz, p)    TraceMsg(0, "shlf TR-OIPS::%s %s,%x", psz, sz,p)
#define REFMSG0(psz)        TraceMsg(0, "shlf TR-CDOV::%s", psz)
#define REFMSG(psz, cRef)    TraceMsg(0, "shlf TR-CDOV::%s new _cRef==%d", psz, cRef)
#define REFMSG2(psz, if, cRef)    TraceMsg(0, "shlf TR-CDOV::%s(%s) new _cRef==%d", psz, if, cRef)
#define VIEWMSG(psz)        TraceMsg(0, "shlf TR CDOV::%s", psz)
#define VIEWMSG2(psz,xx)    TraceMsg(0, "shlf TR CDOV::%s %x", psz,xx)
#define CACHEMSG(psz, d)        TraceMsg(0, "shlf TR CDocObjectCtx::%s %d", psz, d)
#define HFRMMSG(psz)        TraceMsg(TF_SHDNAVIGATE, "shlf HFRM::%s", psz)
#define HFRMMSG2(psz, x, y)    TraceMsg(TF_SHDNAVIGATE, "shlf HFRM::%s %x %x", psz, x, y)
#define MNKMSG(psz, psz2)    TraceMsg(0, "shlf MNK::%s (%s)", psz, psz2)
#define SERVMSG(psz, x, y)    TraceMsg(0, "shlf SERV::%s %x %x", psz, x, y)

#define KEY_BINDCONTEXTPARAM            _T("BIND_CONTEXT_PARAM")
#define SZ_DWNBINDINFO_OBJECTPARAM      _T("__DWNBINDINFO")

BOOL g_fHlinkDLLLoaded = FALSE;        // must be per-process

STDAPI HlinkFrameNavigate(DWORD grfHLNF, IBindCtx *pbc,
                           IBindStatusCallback *pibsc,
                           IHlink* pihlNavigate,
                           IHlinkBrowseContext *pihlbc);
STDAPI HlinkFrameNavigateNHL(DWORD grfHLNF, IBindCtx *pbc,
                           IBindStatusCallback *pibsc,
                           LPCWSTR pszTargetFrame,
                           LPCWSTR pszUrl,
                           LPCWSTR pszLocation);

// IHlinkFrame members
HRESULT CIEFrameAuto::SetBrowseContext(IHlinkBrowseContext *pihlbc)
{
    if (pihlbc)
        pihlbc->AddRef();

    if (_phlbc)
    {
        if (_dwRegHLBC) 
        {
            _phlbc->Revoke(_dwRegHLBC);
            _dwRegHLBC = 0;
        }
        _phlbc->Release();
    }

    _phlbc = pihlbc;

    return NOERROR;
}

HRESULT CIEFrameAuto::GetBrowseContext(IHlinkBrowseContext **ppihlbc)
{
    TraceMsg(0, "shlf TR ::GetBrowseContext called");
    
    *ppihlbc = _phlbc;

    if (_phlbc) 
    {
        _phlbc->AddRef();
        return S_OK;
    }
    
    return E_FAIL;
}

void CIEFrameAuto::_SetPendingNavigateContext(IBindCtx *pbc, IBindStatusCallback *pibsc)
{
    if (_pbscPending) 
    {
        _pbscPending->Release();
        _pbscPending = NULL;
    }

    if (_pbcPending) 
    {
        _pbcPending->Release();
        _pbcPending = NULL;
    }

    if (pibsc) 
    {
        _pbscPending = pibsc;
        _pbscPending->AddRef();
    }

    if (pbc) 
    {
        // as long as we are cacheing the pending BindCtx, if it specifies
        // a shortcut URL we need to cache that too. (IE:98431)
        IUnknown *          pUnk = NULL;
        IHtmlLoadOptions *  pHtmlLoadOptions  = NULL;

        _pbcPending = pbc;
        _pbcPending->AddRef();

        pbc->GetObjectParam(_T("__HTMLLOADOPTIONS"), &pUnk);
        if (pUnk)
        {
            pUnk->QueryInterface(IID_IHtmlLoadOptions, (void **) &pHtmlLoadOptions);

            if (pHtmlLoadOptions)
            {
                TCHAR    achCacheFile[MAX_PATH+1];
                ULONG    cchCacheFile = ARRAYSIZE(achCacheFile)-1;

                memset(&achCacheFile, 0, (cchCacheFile+1)*sizeof(TCHAR) );
                
                // now determine if this is a shortcut-initiated load
                pHtmlLoadOptions->QueryOption(HTMLLOADOPTION_INETSHORTCUTPATH,
                                                       &achCacheFile,
                                                       &cchCacheFile);

                if (_pwszShortcutPathPending)
                    LocalFree(_pwszShortcutPathPending);

                _pwszShortcutPathPending = StrDup(achCacheFile);

                pHtmlLoadOptions->Release();
            }

            pUnk->Release();
        }

   }
}

//
//  NavigateContext is a set of parameters passed from one CIEFrameAuto
// to another.
//
void CIEFrameAuto::_ActivatePendingNavigateContext()
{
    if (_pbsc) 
    {
        _pbsc->Release();
        _pbsc = NULL;
    }

    if (_pbc) 
    {
        _pbc->Release();
        _pbc = NULL;
    }

    if (_pwszShortcutPath)
    {
        LocalFree(_pwszShortcutPath);
        _pwszShortcutPath = NULL;
    }

    if (_pbscPending) 
    {
        _pbsc = _pbscPending;
        _pbscPending = NULL;
    }

    if (_pbcPending) 
    {
        _pbc = _pbcPending;
        _pbcPending = NULL;
    }

    if (_pwszShortcutPathPending) 
    {
        _pwszShortcutPath = _pwszShortcutPathPending;
        _pwszShortcutPathPending = NULL;
    }
        
}

//  Called to guarantee a newly created HLinkFrame's window is
//  visible after the navigate.
HRESULT ShowHlinkFrameWindow(IUnknown *pUnkTargetHlinkFrame)
{
    IWebBrowserApp* pdie;
    HRESULT hres = pUnkTargetHlinkFrame->QueryInterface(IID_PPV_ARG(IWebBrowserApp, &pdie));
    if (SUCCEEDED(hres)) 
    {
        pdie->put_Visible(TRUE);
        pdie->Release();
    }
    return hres;
}

HRESULT CIEFrameAuto::_NavigateMagnum(DWORD grfHLNF, IBindCtx *pbc, IBindStatusCallback *pibsc, LPCWSTR pszTargetName, LPCWSTR pszUrl, LPCWSTR pszLocation, IHlink *pihlNavigate, IMoniker *pmkTarget)
{
    HRESULT hres = NOERROR;
    HFRMMSG2("Navigate called", grfHLNF, pihlNavigate);
    BOOL fNavigateForReal = pszUrl || (pihlNavigate && (pihlNavigate != (IHlink*)-1));

    _fSuppressHistory = _psbProxy != _psb;  // no history for search band, etc
    _fSuppressSelect = _psbProxy != _psb;   // no need to record select pidl
    if (grfHLNF != (DWORD)-1)
    {
        if (SHHLNF_WRITENOHISTORY & grfHLNF)
        {
            _fSuppressHistory = TRUE;
        }
        if (SHHLNF_NOAUTOSELECT & grfHLNF)
        {
            _fSuppressSelect = TRUE;
        }
    }

    if (pbc == NULL && pibsc == NULL && pihlNavigate == NULL && pszUrl == NULL) 
    {
        //
        //  This is a private interface so that mshtml can do navigation
        // if it is hosted by the shell.  When IHlinkBrowseContext is implemented
        // in the shell this special code can be removed and the associated
        // code in mshtml that calls Navigate with these special parameters
        // can be removed so that it just goes through the
        // IHlinkBrowseContext->SetCurrentHlink interface.
        //
        //  We also use this private mechanism to release the navigation
        // context with grfHLNF==0.
        // 

        switch (grfHLNF&~(SHHLNF_WRITENOHISTORY|SHHLNF_NOAUTOSELECT)) 
        {
        case HLNF_NAVIGATINGBACK:
            hres = _BrowseObject(PIDL_LOCALHISTORY, SBSP_SAMEBROWSER|SBSP_NAVIGATEBACK);
            break;

        case HLNF_NAVIGATINGFORWARD:
            hres = _BrowseObject(PIDL_LOCALHISTORY, SBSP_SAMEBROWSER|SBSP_NAVIGATEFORWARD);
            break;

        case 0:
            _ActivatePendingNavigateContext();
            break;

        default:
            hres = E_INVALIDARG;
            break;
        }

        return hres;
    }

#ifdef FEATURE_PICS
    /* As part of checking ratings, the PICS code will silently download the
     * root document of a site to look for rating labels in it.  If that's a
     * frameset page, Trident will create OCXs for the subframes and try to
     * navigate them, which will invoke ratings checks for them and cause
     * infinite recursion.  So here we check to see if our top-level browser
     * is really this PICS download, and if it is, we don't do any navigation.
     */
    IUnknown *punkPics;
    if (SUCCEEDED(QueryService(SID_STopLevelBrowser, IID_IsPicsBrowser, (void **)&punkPics)))
    {
        punkPics->Release();
        return S_OK;
    }
#endif

    //
    // If we've got this call while we are busy (EnableModeless is FALSE),
    // we should just bail here (instead of doing somthing and let _JumpTo
    // call fail. 
    //
    // This can happen if someone has a window.location="foobar.htm" in their unload
    // event handler.  
    if (fNavigateForReal && !(grfHLNF & HLNF_OPENINNEWWINDOW)) 
    {
        // If _pbs is NULL, it is bad news; we can't navigate.
        // An allowable reason for this condition is that someone has called CIEFrameAuto::Quit()
        // and we are in the process of shutting down.
        //
        if (_pbs == NULL)
        {
            if (_fQuitInProgress)
            {
                TraceMsg(TF_WARNING, "CIEFrameAuto::_NavigateMagnum quitting due to browser closing.");
                return S_OK;
            }
            TraceMsg(TF_WARNING, "CIEFrameAuto::_NavigateMagnum _pbs is NULL, but we are not shutting down.");
            return E_FAIL;
        }

        // If we have a _pbs but the browser says that it can't navigate now, then return S_FALSE.
        //
        else if (_pbs->CanNavigateNow() != S_OK) 
        {
            TraceMsg(TF_WARNING, "CIEFrameAuto::Navigate CanNavigateNow returns non S_OK, bail out.");
            return S_FALSE;
        }
    }

    //
    // This Navigate method is not re-entrant (because of _SetPendingNavigateContext)
    //
    if (_fBusy) 
    {
        TraceMsg(DM_WARNING, "CIEA::Navigate re-entered. Returning E_FAIL");
        return E_FAIL;
    }
    _fBusy = TRUE;

    //
    // HACK: To let Webcheck DRT go.
    //
    if (fNavigateForReal  && !(grfHLNF & HLNF_OPENINNEWWINDOW)) 
    {
        TraceMsg(DM_WEBCHECKDRT, "CIFA::Navigate calling _CancelPendingNavigation");
        VARIANT var = { 0 };
        var.vt = VT_I4;
        var.lVal = TRUE;    // synchronous

        _CancelPendingNavigation(&var);
    }

    if (pszUrl && SHRestricted2(REST_NOFILEURL, NULL, 0) && PathIsFilePath(pszUrl))
    {
        TCHAR szPath[MAX_URL_STRING];
        SHUnicodeToTChar(pszUrl, szPath, ARRAYSIZE(szPath));
        MLShellMessageBox(NULL, MAKEINTRESOURCE(IDS_SHURL_ERR_PARSE_NOTALLOWED),
                        szPath, MB_OK | MB_ICONERROR, szPath);
    
        _fBusy = FALSE;
        return E_ACCESSDENIED;
    }


    _SetPendingNavigateContext(pbc, pibsc);

#ifdef DEBUG
    g_dwPerf = GetCurrentTime();

#endif

    if (pihlNavigate == (IHlink*)-1) 
    {
        //
        // HACK: -1 means "release the navigation state".
        // CDocObjectHost::_CancelPendingNavigation is the only caller.
        // It Exec's SBCMDID_CANCELNAVIGATION which will asynchronously
        // cancel the pending navigation. Therefore, we no longer need
        // to call _CancelPendingNavigation here. (SatoNa)
        // 
        // _CancelPendingNavigation();
    }
    else if (pihlNavigate || pszUrl) 
    {
        hres = S_OK;

        if (SUCCEEDED(hres))
        {
            if ((grfHLNF & HLNF_EXTERNALNAVIGATE) && (grfHLNF & HLNF_NAVIGATINGBACK))
                GoBack();
            else if ((grfHLNF & HLNF_EXTERNALNAVIGATE) && (grfHLNF & HLNF_NAVIGATINGFORWARD))
                GoForward();
            else 
            {
                hres = _JumpTo(pbc,(LPWSTR) pszLocation, grfHLNF, pibsc, pihlNavigate, pszTargetName, pszUrl);
                if (FAILED(hres)) 
                {
                    TraceMsg(DM_ERROR, "IEAuto::Navigate _JumpTo failed %x", hres);
                }
            }
            if (pihlNavigate)
            {
                //
                //  Hopefully, we'll come up with a clean solution to
                //  solve this problem nicely. I made a proposal to NatBro/SriniK
                //  that CreateHlink will CoCreateInstance IHlink so that OLE
                //  LoadLibrary it and maintains it as an InProc server. (SatoNa)
                //
                // HACK: If we AddRef to IHlink, we need to make it sure that
                //  HLINK.DLL is stay loaded even though the DocObject InProc
                //  server (that implicitly links to HLINK.DLL) is unloaded.
                //
                if (!g_fHlinkDLLLoaded) 
                {
                    LoadLibrary(TEXT("hlink.dll"));
                    g_fHlinkDLLLoaded = TRUE;
                }
            }
        }
        else
        {
            TraceMsg(DM_ERROR, "CIEFA::Nav phl->GetMonRef failed %x", hres);
        }
    }

    _fBusy = FALSE;

    HFRMMSG2("Navigate returning", hres, 0);
    
    if (SUCCEEDED(hres) && (pihlNavigate != (IHlink*)-1)) 
    {
        if (grfHLNF & HLNF_EXTERNALNAVIGATE) 
        {
            HWND hwndFrame;
            _psb->GetWindow(&hwndFrame);
            
            if (_phlbc) 
            {
                // if we have a browse context, then we're navigating from it and
                // we should size our window to match it.
                HLBWINFO hlbwi;
                
                hlbwi.cbSize = SIZEOF(hlbwi);
                if (SUCCEEDED(_phlbc->GetBrowseWindowInfo(&hlbwi)) &&
                    (hlbwi.grfHLBWIF & HLBWIF_HASFRAMEWNDINFO)) 
                {
                    WINDOWPLACEMENT wp;
                    
                    wp.length = sizeof(WINDOWPLACEMENT);
                    GetWindowPlacement(hwndFrame, &wp);
                    wp.rcNormalPosition = hlbwi.rcFramePos;
                    wp.showCmd = (hlbwi.grfHLBWIF & HLBWIF_FRAMEWNDMAXIMIZED) 
                                    ? SW_SHOWMAXIMIZED : SW_SHOWNORMAL;

                    // This is not broken in AOL because this
                    // is an external navigate (word has cocreateinstance()d
                    // Internet.Explorer and navigated it.
                    //
                    SetWindowPlacement(hwndFrame, &wp);
                }

                // Register the hlinkframe interface with the browse context, if it has not already
                // been registered
                if (_dwRegHLBC == 0)
                    _phlbc->Register(0, (IHlinkFrame *) this, pmkTarget, &_dwRegHLBC); 

                // add the link to browse context and
                // REVIEW: need to pass the proper friendly name
                _phlbc->OnNavigateHlink(grfHLNF, pmkTarget, pszLocation, NULL, NULL);
            }

            put_Visible(TRUE);
            
            SetForegroundWindow(hwndFrame);
        }

        //
        // According to SriniK, we need to call IHlinkSite::OnNavigationComplete
        // before returning from IHlinkFrame::Navigate with S_OK. (SatoNa)
        //
        if (pihlNavigate) 
        {
            BOOL fExternal = FALSE;
            if (_phlbc && _pbs) 
            {
                ITravelLog* ptl;
                if (SUCCEEDED(_pbs->GetTravelLog(&ptl))) 
                {
                    if (FAILED(ptl->GetTravelEntry(_pbs, 0, NULL))) 
                    {
                        TraceMsg(DM_HLINKTRACE, "CIEFA::_NavMag this is external nav. Don't call OnNavigationComplete");
                        fExternal = TRUE;
                    }
                    else if (SUCCEEDED(ptl->GetTravelEntry(_pbs, TLOG_BACKEXTERNAL, NULL))) 
                    {
                        TraceMsg(DM_HLINKTRACE, "CIEFA::_NavMag this is external for. Don't call OnNavigationComplete");
                        fExternal = TRUE;
                    }
                    ptl->Release();
                }
            }

            //
            // Don't call OnNavigationComplete if this is an external navigation.
            //
            if (!fExternal) 
            {
                IHlinkSite* pihlSite = NULL;
                DWORD dwSiteData;
                HRESULT hresT = pihlNavigate->GetHlinkSite(&pihlSite, &dwSiteData);
                if (SUCCEEDED(hresT) && pihlSite) 
                {
                    TraceMsg(DM_HLINKTRACE, "CIEFA::_NavMag calling OnNavigationComplete");
                    hresT = pihlSite->OnNavigationComplete(dwSiteData, 0, S_OK, L"");
                    if (FAILED(hresT)) 
                    {
                        TraceMsg(DM_ERROR, "CIEFA::Navigat OnNavComplete failed %x", hresT);
                    }
                    pihlSite->Release();
                }
            }
        }
    }

    return hres;
}

//
//  HACK - what we really want is a good private marshalled interface - zekel 8-AUG-97
//  to the Browser.  but for now we will overload the NavigateHack method, 
//  because it is simple and quick for ship.
//
#define HLNF_REFERRERHACK       0x40000000
HRESULT CIEFrameAuto::_ReferrerHack(LPCWSTR pszUrl)
{
    if (_pbs == NULL)    //Make sure we have a IBrowserService.
        return S_FALSE;

    LPITEMIDLIST pidl;

    if (SUCCEEDED(_pbs->IEParseDisplayName(CP_ACP, pszUrl, &pidl)))
    {
        ASSERT(pidl);
        _pbs->SetReferrer(pidl);
        ILFree(pidl);
    }

    return S_OK;
}

HRESULT CIEFrameAuto::NavigateHack(DWORD grfHLNF, IBindCtx *pbc, IBindStatusCallback *pibsc, LPCWSTR pszTargetName, LPCWSTR pszUrl, LPCWSTR pszLocation)
{
    HRESULT     hres = E_FAIL;
    IBindCtx *  pBindCtx = pbc;
    IUnknown *  pNotify = NULL;
    IUnknown *  pBindCtxParam = NULL;
    BOOL        fAsyncCalled = FALSE;
       
    // Check if we are actually a native frame build... 
    if (pbc)
    {
        hres = pbc->GetObjectParam(KEY_BINDCONTEXTPARAM, &pBindCtxParam);
    }
    
    if (SUCCEEDED(hres) && pBindCtxParam)
    {
        // NavigateHack can be called multiple times, and we only want to create the 
        // new bind context the first time. Since the ITargetNotify pointer is removed
        // after the first use, we can check that to make sure.
        // get and transfer the target notify pointer.
        hres = pbc->GetObjectParam(TARGET_NOTIFY_OBJECT_NAME, &pNotify);
        if (SUCCEEDED(hres) && pNotify)
        {
            // The call is coming from a native frame build of MSHTML. 
            // We can not use their bind context, create a new one and transfer
            // parameters.
            // The old bind context is going to be released by the creator, so do not
            // make a release call on it.
            hres = CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pBindCtx, 0);
            if(FAILED(hres))
                goto Exit;

            fAsyncCalled = TRUE;

            // carry over the ITargetNotify2 pointer.
            hres = pBindCtx->RegisterObjectParam( TARGET_NOTIFY_OBJECT_NAME, pNotify );
            if (FAILED(hres))
                goto Exit;

            pNotify->Release();
            pNotify = NULL;

            // carry over the bind context parameter.
            hres = pBindCtx->RegisterObjectParam( KEY_BINDCONTEXTPARAM, pBindCtxParam );
            if (FAILED(hres))
                goto Exit;

            {
                IUnknown * pDwnBindInfo = NULL;

                if (SUCCEEDED(pbc->GetObjectParam(SZ_DWNBINDINFO_OBJECTPARAM, &pDwnBindInfo)) && pDwnBindInfo)
                {
                    pBindCtx->RegisterObjectParam(SZ_DWNBINDINFO_OBJECTPARAM, pDwnBindInfo);
                    pDwnBindInfo->Release();
                }
            }
        }

        pBindCtxParam->Release();
        pBindCtxParam = NULL;
    }
    
    if (IsFlagSet(grfHLNF, HLNF_REFERRERHACK))
        hres =  _ReferrerHack(pszUrl);
    else
        hres = _NavigateMagnum(grfHLNF, pBindCtx, pibsc, pszTargetName, pszUrl, pszLocation, NULL, NULL);

Exit:
    SAFERELEASE(pNotify); 
    SAFERELEASE(pBindCtxParam);

    // If the call failed anywhere, we can not be sure the new document
    // will free the object parameter that is in the bind context 
    // we have created in this function.
    if (FAILED(hres) && pBindCtx)
    {
        // we don't want to change the return code here.
        pBindCtx->RevokeObjectParam(KEY_BINDCONTEXTPARAM);
        pBindCtx->RevokeObjectParam(TARGET_NOTIFY_OBJECT_NAME);
    }
    
    if (fAsyncCalled)
        pBindCtx->Release();

    return hres;
}

// passing NULL pibsc and pbc will make be like "ReleaseNavigationState"
// passing -1 for pihlNavigate will cancel pending navigation

HRESULT CIEFrameAuto::Navigate(DWORD grfHLNF, IBindCtx *pbc,
     IBindStatusCallback *pibsc, IHlink *pihlNavigate)
{
    IMoniker* pmkTarget = NULL;
    LPOLESTR pwszDisplayName = NULL;
    LPOLESTR pwszLocation = NULL;
    LPOLESTR pwszFrameName = NULL;
    HRESULT hres = S_OK;

    if (pihlNavigate && ((IHlink *)-1) != pihlNavigate)
    {
        pihlNavigate->GetTargetFrameName(&pwszFrameName);

        //
        // Note that we are discarding "relative" portion.
        //
        hres = pihlNavigate->GetMonikerReference(HLINKGETREF_ABSOLUTE, &pmkTarget, &pwszLocation);

        HFRMMSG2("Navigate pihl->GetMonRef returned", hres, pmkTarget);

        if (SUCCEEDED(hres))
        {
            IBindCtx* pbcLocal;
    
            if (pbc) 
            {
                pbcLocal = pbc;
                pbcLocal->AddRef();
            }
            else 
            {
                hres = CreateBindCtx(0, &pbcLocal);
            }

            if (SUCCEEDED(hres))
            {
                hres = pmkTarget->GetDisplayName(pbcLocal, NULL, &pwszDisplayName);
                pbcLocal->Release();
            }
        }
    }

    if (SUCCEEDED(hres))
    {
        hres = _NavigateMagnum(grfHLNF, pbc, pibsc, pwszFrameName, pwszDisplayName, pwszLocation, pihlNavigate, pmkTarget);
    }
    if (pwszFrameName)
    {
        OleFree(pwszFrameName);
    }
    if (pwszDisplayName)
    {
        OleFree(pwszDisplayName);
    }
    if (pwszLocation)
    {
        OleFree(pwszLocation);
    }
    if (pmkTarget)
    {
        pmkTarget->Release();
    }
    return hres;
}

HRESULT CIEFrameAuto::OnNavigate(DWORD grfHLNF,
            /* [unique][in] */ IMoniker *pimkTarget,
            /* [unique][in] */ LPCWSTR pwzLocation,
            /* [unique][in] */ LPCWSTR pwzFriendlyName,
            /* [in] */ DWORD dwreserved)
{
    TraceMsg(0, "shlf TR ::OnNavigate called");
    return S_OK;
}

void CIEFrameAuto::_CancelPendingNavigation(VARIANTARG* pvar)
{
    TraceMsg(0, "shd TR _CancelPendingNavigation called");
    if (_pmsc) 
    {
        TraceMsg(0, "shd TR _CancelPendingNavigation calling _pmsc->Exec");
        _pmsc->Exec(&CGID_Explorer, SBCMDID_CANCELNAVIGATION, 0, pvar, NULL);
    }
}

// *** ITargetNotify ***

void 
CIEFrameAuto::_HandleOpenOptions( IUnknown * pUnkDestination, ITargetNotify * ptgnNotify)
{
    HRESULT             hres = S_OK;
    ITargetNotify2 *    ptgnNotify2 = NULL; 

    if (!pUnkDestination || !ptgnNotify)
        return;

    if (SUCCEEDED(ptgnNotify->QueryInterface( IID_ITargetNotify2, (void **)&ptgnNotify2)))
    {
        BSTR    bstrOptions = NULL;

        ASSERT(ptgnNotify2);

        // Apply the options only if the initator of the navigation 
        // asks for it.

        if (S_OK == ptgnNotify2->GetOptionString(&bstrOptions))
        {
            _omwin._OpenOptions.ReInitialize();

            if (bstrOptions)
            {
                _omwin._ParseOptionString(bstrOptions, ptgnNotify2);

                // We are done with the options string, release it
                SysFreeString(bstrOptions);
            }

            // Apply the options now.
            //
            IWebBrowser2 * pNewIE;

            if (SUCCEEDED(pUnkDestination->QueryInterface(IID_PPV_ARG(IWebBrowser2, &pNewIE))))
            {
                _omwin._ApplyOpenOptions(pNewIE);
                pNewIE->Release();
            }
        }

        ptgnNotify2->Release();
    
    }
}

HRESULT CIEFrameAuto::OnCreate(IUnknown *pUnkDestination, ULONG cbCookie)
{
    HRESULT             hres = S_OK;

    if (cbCookie == (ULONG)_cbCookie && _ptgnNotify)
    {
        _HandleOpenOptions( pUnkDestination, _ptgnNotify);
    
        hres = _ptgnNotify->OnCreate(pUnkDestination, cbCookie);
        SAFERELEASE(_ptgnNotify);
    }
    return hres;
}

HRESULT CIEFrameAuto::OnReuse(IUnknown *pUnkDestination)
{
    return S_OK;
}

#define NOTIFY_WAIT_TIMEOUT (60000)
//  chrisfra 10/10/96: do we need EnableModeless(FALSE)/(TRUE) around 
//  our little loop, or is the busy flag (which is set) sufficient?

HRESULT CIEFrameAuto::_WaitForNotify()
{
    if (_ptgnNotify && IsInternetExplorerApp())
    {
        DWORD dwObject, msWait, msStart = GetTickCount();

        goto DOPEEK;

        while (_ptgnNotify)
        {
            // NB We need to let the run dialog become active so we have to half handle sent
            // messages but we don't want to handle any input events or we'll swallow the
            // type-ahead.
            msWait = GetTickCount();
            if (msWait - msStart > NOTIFY_WAIT_TIMEOUT) 
                break;

            msWait = NOTIFY_WAIT_TIMEOUT - (msWait - msStart);
            dwObject = MsgWaitForMultipleObjects(0, NULL, FALSE, msWait, QS_ALLINPUT);
            // Are we done waiting?
            switch (dwObject) 
            {
            case WAIT_FAILED:
                break;
                
            case WAIT_OBJECT_0:
DOPEEK:
                // got a message, dispatch it and wait again
                MSG msg;
                while (PeekMessage(&msg, NULL,0, 0, PM_REMOVE)) 
                {
                    DispatchMessage(&msg);
                    if (_ptgnNotify == NULL || 
                        ((GetTickCount() - msStart) > NOTIFY_WAIT_TIMEOUT)) 
                        break;
                    
                }
                break;
            }
        }
    }
    return S_OK;
}

HRESULT CIEFrameAuto::_RegisterCallback(TCHAR *szFrameName, ITargetNotify *ptgnNotify)
{
    HRESULT hr = S_OK;

    SAFERELEASE(_ptgnNotify);

    _fRegistered = 0;

    if (ptgnNotify)
    {
        IDispatch *pid;
        hr = QueryInterface(IID_PPV_ARG(IDispatch, &pid));
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
            IShellWindows *psw = WinList_GetShellWindows(TRUE);
            if (psw != NULL)
            {
                long cbCookie;
                hr = psw->Register(pid, NULL, SWC_CALLBACK, &cbCookie);
                if (SUCCEEDED(hr))
                {
                    TCHAR szCookie[25];   // big enough for "_[cbCookie]"
                    int slenCookie;
                    int slenName;
                    int slenMin;

                    _cbCookie = cbCookie;
                    _fRegistered = 1;
                    _ptgnNotify = ptgnNotify;
                    _ptgnNotify->AddRef();

                    //  prepend unique id to target -- tells created WebBrowserOC to
                    //  register the remainder (if any) as frame name and to perform
                    //  callbacks on all registered callbacks
                    wnsprintf(szCookie, ARRAYSIZE(szCookie), TEXT("_[%ld]"), cbCookie);
                    slenCookie = lstrlen(szCookie);
                    slenName = lstrlen(szFrameName);
                    slenMin =  min((int)MAX_URL_STRING-slenCookie,slenName);
                    MoveMemory(&szFrameName[slenCookie], szFrameName, CbFromCch(slenMin));
                    szFrameName[slenCookie+slenMin] = 0;
                    CopyMemory(szFrameName, szCookie, CbFromCch(slenCookie));
                }
                psw->Release();
            }
            pid->Release();
        }
    }

    return hr;
}


HRESULT CIEFrameAuto::_RevokeCallback()
{
    HRESULT hr = S_OK;

    if (_fRegistered)
    {
        IShellWindows *psw = WinList_GetShellWindows(TRUE);
        if (psw != NULL)
        {
            hr = psw->Revoke(_cbCookie);
            psw->Release();
        }
    }
    SAFERELEASE(_ptgnNotify);
    _fRegistered = 0;
    return hr;
}


//
//  HACK - what we really want is a good private marshalled interface - zekel 8-AUG-97
//  to the Browser.  but for now we will overload the NavigateHack method, 
//  because it is simple and quick for ship.
//
void CIEFrameAuto::_SetReferrer(ITargetFramePriv *ptgfp)
{
    LPITEMIDLIST pidl;
    WCHAR szUrl[MAX_URL_STRING];

    ASSERT(ptgfp);

    //Make sure we have a IBrowserService.
    if (_psb && SUCCEEDED(_pbs->GetPidl(&pidl)))
    {
        if (SUCCEEDED(_pbs->IEGetDisplayName(pidl, szUrl, SHGDN_FORPARSING)))
            ptgfp->NavigateHack(HLNF_REFERRERHACK, NULL, NULL, NULL, szUrl, NULL);

        ILFree(pidl);
    }
}

BOOL _ShouldInvokeDefaultBrowserOnNewWindow(IUnknown *punk)
{
    BOOL fResult = FALSE;

    IOleCommandTarget *poct;

    if (SUCCEEDED(IUnknown_QueryService(punk, SID_STopLevelBrowser, IID_PPV_ARG(IOleCommandTarget, &poct))))
    {
        VARIANT var;

        var.vt = VT_EMPTY;

        if (SUCCEEDED(poct->Exec(&CGID_InternetExplorer, 
                                 IECMDID_GET_INVOKE_DEFAULT_BROWSER_ON_NEW_WINDOW,
                                 0,
                                 NULL,
                                 &var)))
        {
            fResult = var.boolVal ? TRUE : FALSE;
        }

        poct->Release();
    }
    
    return fResult;
}

HRESULT CIEFrameAuto::_JumpTo(IBindCtx *pbc, LPWSTR pszLocation, DWORD grfHLNF, IBindStatusCallback *pibsc, IHlink *pihlNavigate, LPCWSTR pszFrameName, LPCWSTR pszUrl)
{
    LPITEMIDLIST pidl = NULL;
    HRESULT hres;
    ITargetNotify *ptgnNotify = NULL;
    IUnknown *punkNotify = NULL;
    IUnknown *punkThis = NULL;
    UINT uiCP = CP_ACP;

    // Get the current document codepage from Trident and use it for url string conversion if necessary.
    if (!(grfHLNF & HLNF_ALLOW_AUTONAVIGATE) && _pmsc)
    {
        VARIANT varOut = { 0 };
        VARIANT varIn = { 0 };

        varIn.vt = VT_I4;
        varIn.lVal = DFC_URLCHARSET; // we want the doc's url charset

        if (SUCCEEDED(_pmsc->Exec(&CGID_ShellDocView, SHDVID_DOCFAMILYCHARSET, 0, &varIn, &varOut)))
            uiCP = (UINT)varOut.lVal;
    }

    //  Note that we are simply passing the pidl to ISB::BrowseObject,
    // assuming that new shell32.dll allows us to bind to DocObject
    // documents.
    //

    DWORD flags = (grfHLNF & HLNF_OPENINNEWWINDOW) ?
        (SBSP_NEWBROWSER | SBSP_ABSOLUTE | SBSP_INITIATEDBYHLINKFRAME) :
        (SBSP_SAMEBROWSER | SBSP_ABSOLUTE | SBSP_INITIATEDBYHLINKFRAME);


    flags |= ((grfHLNF & HLNF_ALLOW_AUTONAVIGATE) ? (SBSP_ALLOW_AUTONAVIGATE) : 0);
    flags |= ((grfHLNF & SHHLNF_WRITENOHISTORY) ? (SBSP_WRITENOHISTORY) : 0);
    flags |= ((grfHLNF & SHHLNF_NOAUTOSELECT) ? (SBSP_NOAUTOSELECT) : 0);

    if (pbc && SUCCEEDED(pbc->GetObjectParam(TARGET_NOTIFY_OBJECT_NAME, &punkNotify)))
    {
        if (FAILED(punkNotify->QueryInterface(IID_PPV_ARG(ITargetNotify, &ptgnNotify))))
            ptgnNotify = NULL;
        
        punkNotify->Release();
        QueryInterface(IID_PPV_ARG(IUnknown, &punkThis));
    }

    if (grfHLNF & HLNF_CREATENOHISTORY)
        flags |= SBSP_REDIRECT;

    if (flags & SBSP_NEWBROWSER)
    {
        TCHAR *pszHeaders = NULL;
        BYTE *pPostData = NULL;
        DWORD cbPostData = 0;
        TCHAR szFrameName[MAX_URL_STRING+1];
        STGMEDIUM stgPostData = { TYMED_NULL, NULL, NULL };

        //Qfe:1478 If restricted to open in new window, return failure.
        if ((grfHLNF & HLNF_OPENINNEWWINDOW) 
            && SHIsRestricted2W(_hwnd, REST_NoOpeninNewWnd, NULL, 0))
        {
            SAFERELEASE(punkThis);
            return E_ACCESSDENIED;
        }

        if ((_ShouldInvokeDefaultBrowserOnNewWindow(_psb) || IsDesktopFrame(_psb)) && !ShouldNavigateInIE(pszUrl))
        {
            //  IE is not the default browser so we'll ShellExecute the Url since someone
            //  has told us that's the behaviour they prefer.
            HINSTANCE hinstRet = ShellExecuteW(NULL, NULL, pszUrl, NULL, NULL, SW_SHOWNORMAL);
            
            hres = ((UINT_PTR)hinstRet) <= 32 ? E_FAIL : S_OK;
        }
        else
        {

            szFrameName[0] = 0;

            //  Here is where if we are doing a new window we must
            //  extract frame, post etc and append to pidl.  These must
            //  be done in the following order (to match extraction code):
            //      URLID_FRAMENAME,URLID_POSTDATA,URLID_HEADERS

            if (pszFrameName)
            {
                SHUnicodeToTChar(pszFrameName, szFrameName, ARRAYSIZE(szFrameName));
            }


            if (pibsc)
            {
                GetHeadersAndPostData(pibsc,&pszHeaders,&stgPostData,&cbPostData, NULL);

                if (stgPostData.tymed == TYMED_HGLOBAL) 
                {
                    pPostData = (LPBYTE) stgPostData.hGlobal;
                }
            }

            hres = _PidlFromUrlEtc(uiCP, pszUrl, pszLocation, &pidl);

            HFRMMSG2("_JumpTo _PidlFromUrlEtc returned", hres, pidl);

            if (SUCCEEDED(hres))
            {
                IUnknown* punkNewWindow = NULL;
                BOOL fCancel = FALSE;

                // The NewWindow2 event may return the window for us.
                FireEvent_NewWindow2(_GetOuter(), &punkNewWindow, &fCancel);
                if (!fCancel)
                {
                    BOOL fProcessed = FALSE;

                    // We might need the old NewWindow event...
                    if (!punkNewWindow)
                    {
                        _RegisterCallback(szFrameName, ptgnNotify);
            
                        // fire an event to indicate a new window needs to be created
                        // to allow a container to handle it itself if it wants
                        // since we may be aggregated, QI our parent

                        // Yet another Compuserve workaround (IE 60688):
                        // If the target frame name is "_blank", Compuserve will pass that name
                        // in to the Navigate call of the new window.  We would then create a new window
                        // (which would fire this event) causing a loop.  Break the recursion by sending
                        // an empty string for the frame name.
                        HWND hwnd = _GetHWND();
                        
                        if (hwnd)
                        {
                            FireEvent_NewWindow(_GetOuter(), hwnd, pidl,pszLocation,0,
                                StrCmpI(szFrameName, TEXT("_blank")) ? szFrameName : TEXT(""),  // Target frame name
                                pPostData,cbPostData,pszHeaders,&fProcessed);
                        }
                    }
        
                    if (!fProcessed)
                    {
                        if (!punkNewWindow)
                        {
    #ifdef INCLUDE_BUSTED_OC_QI
                            IUnknown* pdvb = NULL;
    #endif
                            _RevokeCallback();

    #ifdef INCLUDE_BUSTED_OC_QI
                            // For some unidentifiable reason the old code did NOT
                            // create a new window if we were hosted in the WebBrowserOC.
                            // mikesh/cheechew/jeremys/chrisfra don't know why this happens.
                            // Who knows what app will break if we change this...
                            // (Note: IDefViewBrowser is a CWebBrowseSB only interface)
                            //
                            // NOTE: chrisfra 3/11/97, this code breaks open a
                            // new window for a non-existent target, when in
                            // desktop component or browser band
                            fCancel = !(_psbTop && FAILED(_psbTop->QueryInterface(IID_PPV_ARG(IDefViewBrowser, &pdvb))));
                            if (pdvb)
                                pdvb->Release();
    #endif
                        }
        
                        // what we really want to do is just hand this off to
                        // _psbTop->BrowseObject and let it (CWebBrowserSB or CShellBrowser)
                        // decide whether to use HlinkFrameNavigate or not, but if we
                        // do that, then we lose the grfHLNF and pihlNavigate.
                        // So put that logic here...
                        //
                        if (!fCancel)
                        {
                            hres = CreateTargetFrame(pszFrameName, &punkNewWindow);
                            if (SUCCEEDED(hres))
                            {
                                //  Notify ptgnNotify, then release and remove from bindctx
                                if (ptgnNotify)
                                {
                                    _HandleOpenOptions( punkNewWindow, ptgnNotify);

                                    ptgnNotify->OnCreate(punkNewWindow, GetTickCount());

                                    ptgnNotify->Release();
                                    ptgnNotify = NULL;

                                    pbc->RevokeObjectParam(TARGET_NOTIFY_OBJECT_NAME);
                                }

                                LPHLINKFRAME phf;

                                hres = punkNewWindow->QueryInterface(IID_PPV_ARG(IHlinkFrame, &phf));
                                if (SUCCEEDED(hres))
                                {
                                    ITargetFramePriv * ptgfp;

                                    if (NULL == pihlNavigate)
                                    {
                                        hres = punkNewWindow->QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptgfp));
                                    }

                                    if (SUCCEEDED(hres))
                                    {
                                        if (pihlNavigate)
                                        {
                                            hres = phf->Navigate(grfHLNF & ~HLNF_OPENINNEWWINDOW, 
                                                                 pbc, 
                                                                 pibsc, 
                                                                 pihlNavigate);
                                        }
                                        else
                                        {
                                            // HACK - see this methods comments 
                                            _SetReferrer(ptgfp);

                                            hres = ptgfp->NavigateHack(grfHLNF & ~HLNF_OPENINNEWWINDOW, 
                                                                 pbc, 
                                                                 pibsc,
                                                                 NULL,
                                                                 pszUrl,
                                                                 pszLocation);
                                        }
        
                                        if (FAILED(hres)) 
                                        {
                                            TraceMsg(DM_ERROR, "CIEFA::_JumpTo marshalled IHlinkFrame::Navigate failed %x", hres);
                                        }

                                        ShowHlinkFrameWindow(punkNewWindow);
                                        if (NULL == pihlNavigate)
                                        {
                                            ptgfp->Release();
                                        }

                                        if(SUCCEEDED(hres) && pibsc)
                                        {
                                            _SetPendingNavigateContext(NULL, NULL);
                                        }

                                    }
                                    phf->Release();
                                }
                            }
                        }
                        else 
                        {
                            //
                            //  If NEWBROWSER is specified when there is no top level
                            // browser, we should ask IE/Shell to do browsing.
                            // We don't pass HLNF_OPENINNEWWINDOW in this case.
                            //
                            
                            //  Notify object doing navigation that we are the object implementing IWebBrowserApp
                            if (ptgnNotify) ptgnNotify->OnReuse(punkThis);
        
                            if (pihlNavigate)
                            {
                                hres = HlinkFrameNavigate(grfHLNF & ~HLNF_OPENINNEWWINDOW,
                                                            NULL, NULL, pihlNavigate, NULL);
                            }
                            else
                            {
                                hres = HlinkFrameNavigateNHL(grfHLNF & ~HLNF_OPENINNEWWINDOW,
                                           NULL, NULL, NULL, pszUrl, pszLocation);
                            }
                        }
                    }
                    else
                    {
                        //  Oldstyle AOL or other 3rd Party, wait for registration of 
                        //  WebBrowserOC, which calls us back on _ptgnNotify
                        _WaitForNotify();
                        //  We timed out the window create, notify caller
                        if (_ptgnNotify) 
                            _ptgnNotify->OnCreate(NULL, 0);
                        _RevokeCallback();
                    }
                }

                if (punkNewWindow)
                    punkNewWindow->Release();

            }
            else
            {
                TraceMsg(DM_ERROR, "IEAuto::_JumpTo _PidlFromUrlEtc (1) failed %x", hres);
            }
        }
        if (pszHeaders) 
        {
            LocalFree(pszHeaders);
            pszHeaders = NULL;
        }

        if (stgPostData.tymed != TYMED_NULL)
        {
            ReleaseStgMedium(&stgPostData);
        }

    }
    else
    {
        //  Notify object doing navigation that we are the object implementing IWebBrowserApp
        if (ptgnNotify) ptgnNotify->OnReuse(punkThis);

        hres = _PidlFromUrlEtc(uiCP, pszUrl, pszLocation, &pidl);
        if (SUCCEEDED(hres))
        {
            hres = _psb->BrowseObject(pidl, flags);
        }
        else 
        {
            TraceMsg(DM_ERROR, "IEAuto::_JumpTo _PidlFromUrlEtc (2) failed %x", hres);
        }
    }

    if (pidl)
    {
        HFRMMSG2("_JumpTo _psb->BrowseObject returned", hres, 0);
        ILFree(pidl);
    }
    
    if (ptgnNotify)
    {
        ptgnNotify->Release();
        pbc->RevokeObjectParam(TARGET_NOTIFY_OBJECT_NAME);
    }

    SAFERELEASE(punkThis);

    return hres;
}


HRESULT CIEFrameAuto::QueryService(REFGUID guidService, REFIID riid, void ** ppvObj)
{
    *ppvObj = NULL;

    // WARNING: Note that we are not following the strict semantics of
    //  ISP::QueryService. It is, however, OK because this (the fact that
    //  IHlinkFrame support IServiceProvider) is not public.

    if (IsEqualIID(guidService, SID_SOmWindow)) 
    {
        return _omwin.QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(guidService, IID_IHlinkFrame)) 
    {
        SERVMSG("QueryService called", _pbc, _pbsc);

        if (IsEqualIID(riid, IID_IBindCtx) && _pbc) 
        {
            *ppvObj = _pbc;
            _pbc->AddRef();
        }
        else if (IsEqualIID(riid, IID_IBindStatusCallback) && _pbsc)
        {
            *ppvObj = _pbsc;
            _pbsc->AddRef();
        }         
        else
        {
            return QueryInterface(riid, ppvObj);
        }
    }
    else if (IsEqualIID(guidService, SID_PendingBindStatusCallback)) 
    {
        if (IsEqualIID(riid, IID_IBindStatusCallback) && _pbscPending)
        {
            *ppvObj = _pbscPending;
            _pbscPending->AddRef();
        }
    } 
    else if (_psp) 
    {
        return _psp->QueryService(guidService, riid, ppvObj);
    }

    return *ppvObj ? S_OK : E_FAIL;
}


HRESULT CIEFrameAuto::Exec(
    /* [unique][in] */ const GUID *pguidCmdGroup,
    /* [in] */ DWORD nCmdID,
    /* [in] */ DWORD nCmdexecopt,
    /* [unique][in] */ VARIANTARG *pvarargIn,
    /* [unique][out][in] */ VARIANTARG *pvarargOut)
{
    HRESULT hres = S_OK;

    if (pguidCmdGroup)
    {
        if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
        {
            switch(nCmdID)
            {
            case SBCMDID_CANCELNAVIGATION:
                _CancelPendingNavigation(NULL);
                break;

            case SBCMDID_SELECTHISTPIDL:
            case SBCMDID_HISTSFOLDER:
                if (_poctFrameTop)
                    hres = _poctFrameTop->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                else
                    hres = S_OK;
                break;

            case SBCMDID_IESHORTCUT:
#ifdef BROWSENEWPROCESS_STRICT // "Nav in new process" has become "Launch in new process", so this is no longer needed
                // If this is an IE shortcut and browse in a new process is turned on
                // and we are explorer.exe - we should pass on the request to navigate to
                // this shortcut. The caller is expected to create a new window/process to
                // launch this shortcut
                if (IsBrowseNewProcessAndExplorer())  
                    hres = E_FAIL;
                else
#endif
                    hres = _NavIEShortcut(pvarargIn,pvarargOut);
                
                break;

            case SBCMDID_GETSHORTCUTPATH:
               if (_pwszShortcutPath && pvarargOut)
               {
                    pvarargOut->bstrVal = SysAllocString(_pwszShortcutPath);
                    if (pvarargOut->bstrVal)
                        pvarargOut->vt = VT_BSTR;        //no need to set hres=S_OK since it is inited already
                    else 
                        hres = E_OUTOFMEMORY;
               }
               else 
               {
                    if (pvarargOut)
                        pvarargOut->vt = VT_EMPTY;

                    hres = E_FAIL;
               }
               
               break;    
            default:
                hres = OLECMDERR_E_NOTSUPPORTED; 
            }
        }
        else if (IsEqualGUID(CGID_ShortCut, *pguidCmdGroup))
        {
            if (_poctFrameTop) // we must check!
                hres = _poctFrameTop->Exec(&CGID_ShortCut, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            else
                hres = OLECMDERR_E_NOTSUPPORTED;
        } 
        else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
        {
            switch (nCmdID)
            {
                case SHDVID_DELEGATEWINDOWOM:
                    _omwin.SetDelegationPolicy(V_BOOL(pvarargIn));
                    break;
                default:
                    hres = OLECMDERR_E_NOTSUPPORTED;
            }
        }
        else if (IsEqualGUID(CGID_InternetExplorer, *pguidCmdGroup))
        // CGID_InternetExplorer are public defined in msiehost.h
        {
            switch (nCmdID)
            {
                case IECMDID_CLEAR_AUTOCOMPLETE_FOR_FORMS:
                {
                    if (pvarargIn->vt == VT_I4)
                    {
                        hres = ClearAutoSuggestForForms(V_I4(pvarargIn));
                    }
                    else
                        hres = E_INVALIDARG;
                }
                break;

                case IECMDID_SETID_AUTOCOMPLETE_FOR_FORMS:
                {
                    if ((pvarargIn->vt == VT_UI8) ||
                        (pvarargIn->vt == VT_I8))
                    {
                        hres = SetIdAutoSuggestForForms(((GUID *)(&pvarargIn->ullVal)), _omwin.IntelliForms());
                    }
                    else
                        hres = E_INVALIDARG;
                }
                break;

                default:
                    hres = OLECMDERR_E_NOTSUPPORTED;
            }
        }
        else
        {
            hres = OLECMDERR_E_UNKNOWNGROUP;
        }
    }
    else
    {
        hres = OLECMDERR_E_UNKNOWNGROUP;
    }

    return hres;
}


BOOL CIEFrameAuto::_fNavigationPending()
{
    // unfortunately, the hyperlink frame doesn't REALLY know when there's
    // a navigation pending or not because people might not call OnReleaseNavigation.
    // only the real browser knows.

    if (_pmsc) 
    {
        MSOCMD rgCmd;
        rgCmd.cmdID = SBCMDID_CANCELNAVIGATION;
        rgCmd.cmdf = 0;

        _pmsc->QueryStatus(&CGID_Explorer, 1, &rgCmd, NULL);
        return (rgCmd.cmdf & MSOCMDF_ENABLED);
    }
    return FALSE;
}

HRESULT CIEFrameAuto::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    if (pguidCmdGroup && IsEqualGUID(CGID_Explorer, *pguidCmdGroup)) 
    {
        for (ULONG i = 0; i < cCmds; i++)
        {
            switch (rgCmds[i].cmdID)
            {
            case SBCMDID_CANCELNAVIGATION:
                rgCmds[i].cmdf = _fNavigationPending() ? MSOCMDF_ENABLED : 0;
                break;

            case SBCMDID_WRITEHIST:
                rgCmds[i].cmdf = _fSuppressHistory ? 0:MSOCMDF_ENABLED;
                break;
            
            case SBCMDID_SELECTHISTPIDL:
                rgCmds[i].cmdf = _fSuppressSelect || !_poctFrameTop ? 0:MSOCMDF_ENABLED;
                break;

            default:
                rgCmds[i].cmdf = 0;
                break;
            }
        }
    }
    else
    {
        return OLECMDERR_E_UNKNOWNGROUP;
    }

    if (pcmdtext)
    {
        pcmdtext->cmdtextf = MSOCMDTEXTF_NONE;
        pcmdtext->cwActual = 0;
    }

    return NOERROR;
}

HRESULT CIEFrameAuto::_PidlFromUrlEtc(UINT uiCP, LPCWSTR pszUrl, LPWSTR pszLocation, LPITEMIDLIST* ppidl)
{
    *ppidl = NULL;      // assumes error

    // ALGORITHM:
    //  - First, we call IEParseDisplayName to generate the pidl
    //    to the specified URL or file name.
    //  - if we have fragment (pszLocation) specified,
    //    we call IEILAppendFragment() to add the hidden fragment id
    if (_pbs == NULL)  //Make sure we have a IBrowserService.
        return (S_FALSE);
        
    HRESULT hr = _pbs->IEParseDisplayName(uiCP, pszUrl, ppidl);

    // This is ugly, if it's a file path that failed to parse because
    // it doesn't exist, we want to create a SimpleIDList so we display
    // a res: navigation failed IFrame instead of the err dlg displayed
    // in DisplayParseError() below.
    if (FAILED(hr)) 
    {
        TCHAR szPath[MAX_PATH];
        DWORD cchBuf = ARRAYSIZE(szPath);

        // If it's a FILE URL, convert it to a path.
        if (IsFileUrlW(pszUrl) && SUCCEEDED(PathCreateFromUrl(pszUrl, szPath, &cchBuf, 0)))
        {
            // That worked, we are done because our buffer is now full.
        }
        else        
        {
            // We now need to copy to the buffer and we assume it's a path.
            StrCpyN(szPath, pszUrl, ARRAYSIZE(szPath));
        }

        *ppidl = SHSimpleIDListFromPath(szPath);
        if (*ppidl)
            hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        if (pszLocation && *pszLocation)
        {
            *ppidl = IEILAppendFragment(*ppidl, pszLocation);
            hr = *ppidl ? S_OK : E_OUTOFMEMORY;
        }
    } 
    else 
    {
        //
        // NOTES: This behavior is new in IE4.0. We are adding
        //  this message box based on the request (bug-report)
        //  from Office guys. (SatoNa)
        //
        hr = _pbs->DisplayParseError(hr, pszUrl);
    }
    return hr;
}

HRESULT CIEFrameAuto::_NavIEShortcut(VARIANT *pvarIn, VARIANT *pvarargOut)
{
    //  need to validate verb and clsid
    HRESULT hr = E_ACCESSDENIED;
    READYSTATE ready;
    BOOL fForceNavigate = pvarargOut ? ((VT_BOOL == pvarargOut->vt ) && (pvarargOut->boolVal)) : FALSE;
    
    get_ReadyState(&ready);

    ASSERT(pvarIn);
    ASSERT(pvarIn->vt == VT_BSTR);
    //
    //  we dont want to allow the exec to go through if this window
    //  is busy with something else.  we should probably allow
    //  READYSTATE_COMPLETE and READYSTATE_UNINITIALIZED.
    //  if we use READYSTATE_UNINITIALIZED, we need to init the browser
    //  and make it visible and stuff like that.  something to the 
    //  check that IPersisteHistory->LoadHistory() does in shvocx.cpp.
    //  right now we will only allow COMPLETE.
    //
    TraceMsgW(DM_SHELLEXECOBJECT, "[%X] IEAuto_NavIEShortcut entered '%s' ready = %d", this, pvarIn->bstrVal, ready);

    
    if (((ready == READYSTATE_COMPLETE || ready == READYSTATE_UNINITIALIZED) || (fForceNavigate))
        && S_OK == IUnknown_Exec(_psbTop, &CGID_Explorer, SBCMDID_ISIEMODEBROWSER, 0, NULL, NULL))
        
    {
        IPersistFile *ppf;
        if (SUCCEEDED(CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_ALL, IID_PPV_ARG(IPersistFile, &ppf))))
        {
            if (SUCCEEDED(ppf->Load(pvarIn->bstrVal, STGM_READ)))
            {
                LPWSTR pszUrl = NULL;
                TraceMsg(DM_SHELLEXECOBJECT, "[%X] IEAuto_NavIEShortcut shortcut inited with file", this);

                IUniformResourceLocatorW *purl;
                if (SUCCEEDED(ppf->QueryInterface(IID_PPV_ARG(IUniformResourceLocatorW, &purl))))
                {
                    purl->GetURL(&pszUrl);
                    purl->Release();
                }
                
                if (pszUrl)
                {
                    TraceMsgW(DM_SHELLEXECOBJECT, "[%X] IEAuto_NavIEShortcut found %s", this, pszUrl);
                    
                    LPITEMIDLIST pidl;
                    IEParseDisplayNameW(CP_ACP, pszUrl, &pidl);
                    if (pidl)
                    {
                        ASSERT(NULL == _pwszShortcutPathPending);
                        if (_pwszShortcutPathPending)
                            LocalFree(_pwszShortcutPathPending);

                        _pwszShortcutPathPending = StrDupW(pvarIn->bstrVal);

                        hr = _BrowseObject(pidl, SBSP_SAMEBROWSER);

                        if (SUCCEEDED(hr))
                        {
                            if (ready == READYSTATE_UNINITIALIZED)
                                put_Visible(VARIANT_TRUE);
                            HWND hwnd = _GetHWND();
                            if (hwnd)
                            {
                                if (IsIconic(hwnd))
                                    ShowWindow(hwnd, SW_RESTORE);
                                else
                                    SetForegroundWindow(hwnd);
                            }
                        }
                        ILFree(pidl);
                    }
                    SHFree(pszUrl);
                }
            }
            ppf->Release();
        }
    }
    TraceMsg(DM_SHELLEXECOBJECT, "IEAuto_NavIEShortcut returns 0x%X", hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\history.cpp ===
#include "priv.h"
#include "dochost.h"
#include "resource.h"
#include "urlprop.h"
#include "ishcut.h"
#include "shlguid.h"
#include "mlang.h"

#include <mluisupp.h>

#define DM_HISTORY 0

HRESULT PersistShortcut(IUniformResourceLocator * purl, LPCWSTR pwszFile)
{
    IPersistFile *ppf;
    HRESULT hres = purl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
    if (SUCCEEDED(hres))
    {
        hres = ppf->Save(pwszFile, TRUE);

        if (SUCCEEDED(hres))
            ppf->SaveCompleted(pwszFile);   // return value always S_OK

        ppf->Release();
    }

    return hres;
}


/*************************************************************\
    FUNCTION: GenerateUnknownShortcutName

    PARAMETERS:
        pwzSourceFilename - TCHAR Source Path and Filename that cannot be created.
                      This value will be changed to a valid path\filename
        pwzDestFilename - After pwzSourceFilename is converted to a valid filename,
                      the valid path will be returned here in a UNICODE string.
        dwSize - Size of the pwzDestFilename buffer in chars.

    DESCRIPTION:
      This function will replace the filename at the end of 
    the path in pwzFilename with "Untitled.url".  If that file
    exists, it will try, "Untitled1.url" and so on until it can
    be unique.

    WARNING:
       This function will only allow the incoming value be in ANSI
    because these helper functions (like PathRemoveFileSpecW) won't
    work on Win95 when compiled in UNICODE.  (CharNextW isn't supported
    on Win95)
\*************************************************************/


#define MAX_GEN_TRIES    100
#define GEN_EXTION_LEN   (7 * sizeof(TCHAR))    // size == L"000.url" in chars

BOOL GenerateUnknownShortcutName(
                     IN  LPCTSTR  pszSourceFilename,    
                     IN  LPWSTR  pwzDestFilename, 
                     IN  DWORD   dwSize)
{
    TCHAR       szUntitledStr[MAX_PATH];
    if (MLLoadString(IDS_UNTITLE_SHORTCUT, szUntitledStr, ARRAYSIZE(szUntitledStr)))
    {
        TCHAR szTempFilename[MAX_PATH];
        StrCpyN(szTempFilename, pszSourceFilename, ARRAYSIZE(szTempFilename));
        PathRemoveFileSpec(szTempFilename);   // "Path"
        if (PathAddBackslash(szTempFilename)) // returns NULL in failure case
        {
            // Make sure the string is large enough (including terminator).  (Counting chars, not bytes)
            if (dwSize > (DWORD)(lstrlen(szTempFilename) + lstrlen(szUntitledStr) + GEN_EXTION_LEN))  
            {
                PathCombine(szUntitledStr, szTempFilename, szUntitledStr);    // "Path\untitled"
                StringCchPrintf(szTempFilename, ARRAYSIZE(szTempFilename), TEXT("%s.url"), szUntitledStr);           // "Path\untitled.url"

                // Make a reasonable number of tries (MAX_GEN_TRIES) to find a unique
                // filename.  "path\Untitled.url", "path\Untitled1.url", ...
                LONG lTry = 1;
                while ((PathFileExists(szTempFilename)) && (lTry < MAX_GEN_TRIES))
                    StringCchPrintf(szTempFilename, ARRAYSIZE(szTempFilename), TEXT("%s%ld.url"), szUntitledStr, lTry++);
            
                if (!PathFileExists(szTempFilename))
                {
                    if (SHTCharToUnicode(szTempFilename, pwzDestFilename, dwSize) > 0)
                        return(TRUE);
                }
            }
        }
    }
    return(FALSE);
}

//
// If no directory is specified then it is simply made into a path name without any dir attached
// 
STDAPI_(BOOL) GetShortcutFileName(LPCTSTR pszTarget, LPCTSTR pszTitle, LPCTSTR pszDir, LPTSTR pszOut, int cchOut)
{
    TCHAR szFullName[MAX_PATH];
    BOOL fAddDotUrl = TRUE;
    UINT cchMax;

    static const TCHAR c_szDotURL[] = TEXT(".url");

    TraceMsg(DM_HISTORY, "GetShortcutFileName pszDir          = %s", pszDir);

    cchMax = ARRAYSIZE(szFullName) - lstrlen(c_szDotURL);

    if (pszTitle && pszTitle[0])
        StrCpyN(szFullName, pszTitle, cchMax);
    else if (pszTarget && pszTarget[0])
    {
        StrCpyN(szFullName, PathFindFileName(pszTarget), cchMax);
        UINT cchLen = lstrlen(szFullName);
        if (szFullName[cchLen -1] == TEXT('/')) // Catch the common case of ftp://foo/
            szFullName[cchLen -1] = TEXT('\0');   
        PathRemoveExtension(szFullName);
    }
    else
    {
        fAddDotUrl = FALSE;
        MLLoadString(IDS_NEW_INTSHCUT, szFullName, SIZECHARS(szFullName));
    }

    // We need at least this many characters for the directory + extension + " (nn)" + the null terminator

    // If there are multiple shortcuts with the same beginning, we'll append " (nn)", where
    // nn represents a two-digit maxiumum
    DWORD cc = (DWORD)(lstrlen(pszDir) + (fAddDotUrl ? ARRAYSIZE(c_szDotURL) : 1) + 5);
    // We want to allow for at least a one letter filename
    if ((cc + 1) > ARRAYSIZE(szFullName))
    {
        return FALSE;
    }
    szFullName[ARRAYSIZE(szFullName)-cc] = TEXT('\0');
    
    if (fAddDotUrl)
        StrCatBuff(szFullName, c_szDotURL, ARRAYSIZE(szFullName));

    if (pszDir)
    {
        if (cchOut < MAX_PATH || (PathCleanupSpec(pszDir, szFullName) & PCS_FATAL))
        {
            return FALSE;
        }
        PathCombine(pszOut, pszDir, szFullName);
    }
    else
    {
        StrCpyN(pszOut, szFullName, cchOut);
    }
    
    TraceMsg(DM_HISTORY, "GetShortcutFileName pszOut      = %s", pszOut);
    
    return TRUE;
}

// Unfortunately we do not already have something like this around
// If you find duplicate, please nuke this (dli)
// Warning: This function does not consider all possible URL cases.  
BOOL _GetPrettyURLName(LPCTSTR pcszURL, LPCTSTR pcszDir, LPTSTR pszUrlFile, int cchUrlFile)
{
    BOOL bRet = FALSE;
    PARSEDURL pu = {0};
    pu.cbSize = sizeof(PARSEDURL);
    
    if (SUCCEEDED(ParseURL(pcszURL, &pu)))
    {
        LPCTSTR pszPrettyName = pu.pszSuffix;
        
        // Get rid of the forward '/' 
        while (*pszPrettyName && *pszPrettyName == TEXT('/'))
            pszPrettyName++;
        
        if (!StrCmpN(pszPrettyName, TEXT("www."), 4))
            pszPrettyName += 4;
        
        if (*pszPrettyName)
            bRet = GetShortcutFileName(pcszURL, pszPrettyName, pcszDir, pszUrlFile, cchUrlFile);
    }
    return bRet;
}
/*
 * pcszURL -> "ftp://ftp.microsoft.com"
 * pcszPath -> "c:\windows\desktop\internet\Microsoft FTP.url"
 */
HRESULT 
CreateNewURLShortcut(
                     IN  LPCTSTR pcszURL, 
                     IN  LPCITEMIDLIST pidlURL, 
                     IN  LPCTSTR pcszURLFile,
                     IN  LPCTSTR pcszDir,
                     OUT LPTSTR  pszOut,
                     IN  int     cchOut,
                     IN  BOOL    bUpdateProperties,
                     IN  BOOL    bUpdateIcon,
                     IN  IOleCommandTarget *pCommandTarget)
{
    HRESULT hr;

    WCHAR wszFile[MAX_URL_STRING];

    if (SHTCharToUnicode(pcszURLFile, wszFile, ARRAYSIZE(wszFile)))
    {
        IUniformResourceLocator *purl;

        hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
            IID_PPV_ARG(IUniformResourceLocator, &purl));

        if (SUCCEEDED(hr))
        {
            if (pidlURL)
            {
                // if we're given a pidl, try to set pidl first.
                
                IShellLink *psl;
                hr = purl->QueryInterface(IID_PPV_ARG(IShellLink, &psl));
                if (SUCCEEDED(hr))
                {
                    hr = psl->SetIDList(pidlURL);
                    psl->Release();
                }
            }
            
            if (!pidlURL || FAILED(hr))
                hr = purl->SetURL(pcszURL, 0);

            if (S_OK == hr)
                IUnknown_SetSite(purl, pCommandTarget);
                
            if (SUCCEEDED(hr))
            {
                // Persist the internet shortcut
                hr = PersistShortcut(purl, wszFile);

                // If the previous call fails, try again with a new Filename.
                // This is needed because the other filename could have been invalid,
                // which will happen if the web page's title was stored in DBCS with
                // a non-English code page.
    
                // (dli) First try a file name related to the URL, then the default untitled
                if (FAILED(hr))
                {
                    TCHAR tszFile[MAX_PATH];
                    BOOL bURLname = _GetPrettyURLName(pcszURL, pcszDir, tszFile, ARRAYSIZE(tszFile));
                    if ((bURLname && SHTCharToUnicode(tszFile, wszFile, ARRAYSIZE(wszFile)) > 0) ||
                        (!bURLname && GenerateUnknownShortcutName(pcszURLFile, wszFile, ARRAYSIZE(wszFile))))
                    {
                        hr = PersistShortcut(purl, wszFile);
                    }

                }

                if (SUCCEEDED(hr))
                {
                    VARIANT varIn = {0};

                    if (bUpdateIcon)
                    {
                        HRESULT hrTemp = IUnknown_Exec(purl, &CGID_ShortCut, ISHCUTCMDID_DOWNLOADICON, 0, NULL, NULL);
                        ASSERT(SUCCEEDED(hrTemp));
                    }

                    varIn.vt = VT_UNKNOWN;
                    varIn.punkVal = purl;

                    TCHAR   szFile[MAX_PATH];
                    SHUnicodeToTChar(wszFile, szFile,  ARRAYSIZE(szFile));
                    SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, szFile, NULL);
                    
                    if (pszOut) 
                    {
                        StrCpyN(pszOut, wszFile, cchOut);
                    }
                }
            }
            purl->Release();
        }
    }
    else
        hr = E_FAIL;

    return(hr);
}


BOOL ILCanCreateLNK(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_FALSE;
    DWORD dwAttributes = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_FILESYSANCESTOR;

    // Should call IsBrowserFrameOptionsPidlSet(BIF_PREFER_INTERNET_SHORTCUT) instead.  Some URL delegate
    //         NSEs (FTP for one) may want .lnks instead of .url files.
    //         This would be great for CDocObjFolder to not set this bit so
    //         for .doc files so they will use the .lnk versions.
    if (!pidl || IsURLChild(pidl, TRUE))
        return FALSE;

    hr = IEGetAttributesOf(pidl, &dwAttributes);
    return (SUCCEEDED(hr) && 
         (IsFlagSet(dwAttributes, SFGAO_FOLDER) ||
          IsFlagSet(dwAttributes, SFGAO_FILESYSANCESTOR) )
        );
}


// This API makes a callback via the IN parameter
// pCommand to inform that shortcut creation is over.
// The callback it currently sends back are : 
// 


STDAPI
CreateShortcutInDirEx(ISHCUT_PARAMS *pParams)
{
    LPCITEMIDLIST pidlTarget = pParams->pidlTarget;
    TCHAR szFileName[MAX_PATH];
    TCHAR szTarget[MAX_URL_STRING];
    HRESULT hres;
    BOOL bIsURL = IsURLChild(pidlTarget, TRUE);

    if (!ILCanCreateLNK(pidlTarget) &&
        SUCCEEDED(IEGetDisplayName(pidlTarget, szTarget, SHGDN_FORPARSING)) &&
        _ValidateURL(szTarget, UQF_DEFAULT))
    {
        SHCleanupUrlForDisplay(szTarget);
        
        BOOL bUsePidl;
        
        // Note that _ValidateURL() calls IURLQualify() which adds "file://"
        // prefix to szTarget as appropriate.
        
        if (bIsURL ||
            (GetUrlScheme(szTarget) == URL_SCHEME_FILE))
        {
            bUsePidl = FALSE;
        }
        else
        {
            // use pidl if it's not URL or file: compatible.
            bUsePidl = TRUE;
        }
        
        GetShortcutFileName(szTarget, pParams->pszTitle, pParams->pszDir, szFileName, ARRAYSIZE(szFileName));
        if (pParams->bUniqueName)
            PathYetAnotherMakeUniqueName(szFileName, szFileName, NULL, NULL);
        hres = CreateNewURLShortcut(szTarget, bUsePidl ? pidlTarget : NULL, szFileName, pParams->pszDir, 
                                    pParams->pszOut, pParams->cchOut, pParams->bUpdateProperties,
                                    pParams->bUpdateIcon, pParams->pCommand);   
    } 
    else 
    {
        hres = CreateLinkToPidl(pidlTarget, pParams->pszDir, pParams->pszTitle, pParams->pszOut, pParams->cchOut);
    }

    return hres;
}


// pidlTarget ... the thing the shortcut is going to point to
// pszDir .. the directory that should hold the shortcut

// WARNING:  if you change any parameters for this function, you 
//           need to fix up explorer.exe
STDAPI CreateShortcutInDirA(
                     IN  LPCITEMIDLIST pidlTarget, 
                     IN  LPSTR   pszTitle, 
                     IN  LPCSTR  pszDir, 
                     OUT LPSTR   pszOut,
                     IN  BOOL    bUpdateProperties)
{
    HRESULT hres = E_FAIL;
    TCHAR szTitle[MAX_PATH];
    TCHAR szDir[MAX_PATH];
    TCHAR szOut[MAX_URL_STRING];
    ISHCUT_PARAMS ShCutParams = {0};
    SHAnsiToTChar(pszTitle, szTitle, ARRAYSIZE(szTitle));
    SHAnsiToTChar(pszDir, szDir, ARRAYSIZE(szDir));

    ShCutParams.pidlTarget = pidlTarget;
    ShCutParams.pszTitle = szTitle; 
    ShCutParams.pszDir = szDir; 
    ShCutParams.pszOut = (pszOut ? szOut : NULL);
    ShCutParams.cchOut = (int)((pszOut ? ARRAYSIZE(szOut) : 0));
    ShCutParams.bUpdateProperties = bUpdateProperties;
    ShCutParams.bUniqueName = FALSE;
    ShCutParams.bUpdateIcon = FALSE;
    ShCutParams.pCommand = NULL;
    ShCutParams.pDoc = NULL;
    
    hres = CreateShortcutInDirEx(&ShCutParams);

    if (pszOut && SUCCEEDED(hres))
        SHTCharToAnsi(szOut, pszOut, MAX_URL_STRING);

    return hres;
}


STDAPI CreateShortcutInDirW(
                     IN  LPCITEMIDLIST pidlTarget, 
                     IN  LPWSTR  pwszTitle, 
                     IN  LPCWSTR pwszDir, 
                     OUT LPWSTR  pwszOut,
                     IN  BOOL    bUpdateProperties)
{
    HRESULT hres = E_FAIL;
    TCHAR szTitle[MAX_PATH];
    TCHAR szDir[MAX_PATH];
    TCHAR szOut[MAX_URL_STRING];
    ISHCUT_PARAMS ShCutParams = {0};
    
    SHUnicodeToTChar(pwszTitle, szTitle, ARRAYSIZE(szTitle));
    SHUnicodeToTChar(pwszDir, szDir, ARRAYSIZE(szDir));

    ShCutParams.pidlTarget = pidlTarget;
    ShCutParams.pszTitle = szTitle; 
    ShCutParams.pszDir = szDir; 
    ShCutParams.pszOut = (pwszOut ? szOut : NULL);
    ShCutParams.cchOut = (int)((pwszOut ? ARRAYSIZE(szOut) : 0));
    ShCutParams.bUpdateProperties = bUpdateProperties;
    ShCutParams.bUniqueName = FALSE;
    ShCutParams.bUpdateIcon = FALSE;
    ShCutParams.pCommand = NULL;
    ShCutParams.pDoc = NULL;
    hres = CreateShortcutInDirEx(&ShCutParams);

    if (pwszOut && SUCCEEDED(hres))
        SHTCharToUnicode(szOut, pwszOut, MAX_URL_STRING);

    return hres;
}


//////////////////////////////
//
// Adds the given URL to the history storage
//
//   pwzTitle may be NULL if no title exists
//   
//   Note this function may be called multiple times in a single
//   page-visit.  bUpdateProperties is TRUE only once during 
//   those sequence of calls.
//
HRESULT 
AddUrlToUrlHistoryStg(
    IN LPCWSTR   pwszUrl, 
    IN LPCWSTR   pwszTitle, 
    IN LPUNKNOWN punk,
    IN BOOL fWriteHistory,
    IN IOleCommandTarget *poctNotify,
    IN IUnknown *punkSFHistory,
    OUT UINT* pcodepage)
{
    TraceMsg(DM_HISTORY, "AddUrlToUrlHistoryStg() entered url = %s, title = %s, punk = %X, fwrite = %d, poct = %X, punkHist = %X, cp = %d",
        pwszUrl, pwszTitle, punk,fWriteHistory,poctNotify,punkSFHistory,pcodepage);


    IUrlHistoryPriv *pUrlHistStg;
    HRESULT hr;
    
    if (!pwszUrl)
        return E_POINTER;

    if (punk == NULL)
    {
        
        hr = CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUrlHistoryPriv, &pUrlHistStg));
    }
    else
    {       
        
        // query the pointer for IServiceProvider so we can get the IUrlHistoryStg
        hr = IUnknown_QueryService(punk, SID_SUrlHistory, IID_PPV_ARG(IUrlHistoryPriv, &pUrlHistStg));
    }
    
    if (SUCCEEDED(hr))
    {
        //
        // This demostrate the mechanism to get the codepage for URL.
        //
        hr = pUrlHistStg->AddUrlAndNotifyCP(pwszUrl, 
                                 pwszTitle, 
                                 0, 
                                 fWriteHistory, 
                                 poctNotify,
                                 punkSFHistory,
                                 pcodepage);
        pUrlHistStg->Release();
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\hlframe.h ===
#ifndef _HLFRAME_H_
#define _HLFRAME_H_

#include "iface.h"
#include <mshtml.h>
#include "cnctnpt.h"
#include "dspsprt.h"
#include "expdsprt.h"
#include "caggunk.h"
#include <opsprof.h>
#include <msiehost.h>
#include "iforms.h"
#include <limits.h>

#ifdef _USE_PSTORE_
#include "pstore.h"
#else
#include "wab.h"
#endif  // _USE_PSTORE_

#ifndef HLNF_EXTERNALNAVIGATE
#define HLNF_EXTERNALNAVIGATE 0x10000000
#endif

#ifndef HLNF_ALLOW_AUTONAVIGATE
#define HLNF_ALLOW_AUTONAVIGATE 0x20000000
#endif

// structure for information about event sinks we hold
typedef struct tagSINKINFO {
    LPUNKNOWN pUnknown;
    IConnectionPoint *pCP; // the connection point we're connected to
    DWORD dwConnectionCookie;
} SINKINFO;

// Helper function in mshtml.dll.
typedef HRESULT (STDAPICALLTYPE *PFN_MatchExactGetIDsOfNames)(ITypeInfo *pTI,
                                               REFIID riid,
                                               LPOLESTR *rgzNames,
                                               UINT cNames,
                                               LCID lcid,
                                               DISPID *rgdispid,
                                               BOOL fCaseSensitive);
STDAPI ResetProfileSharing(HWND hwin);

class CIEFrameAutoProp;

class CIEFrameAuto : protected CImpIDispatch
        , public IWebBrowser2
        , public CImpIConnectionPointContainer
        , public CImpIExpDispSupport
        , public IExternalConnection
        , public IShellService
        , public IHlinkFrame
        , public IServiceProvider
        , public IUrlHistoryNotify
        , public ITargetFrame2
        , public ITargetNotify
        , public ITargetFramePriv
        , public CAggregatedUnknown
        , public IEFrameAuto
        , public IWebBrowserPriv
{

public:
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj)
        { return CAggregatedUnknown::QueryInterface(riid, ppvObj); }
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return CAggregatedUnknown::AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return CAggregatedUnknown::Release(); }

    /* forward IDispatch to CImpIDispatch */
    virtual STDMETHODIMP GetTypeInfoCount(UINT FAR* pctinfo)
        { return CImpIDispatch::GetTypeInfoCount(pctinfo); }
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo)
        { return CImpIDispatch::GetTypeInfo(itinfo, lcid, pptinfo); }
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames, LCID lcid, DISPID FAR* rgdispid)
        { return CImpIDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); }
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo, UINT FAR* puArgErr)
        { return CImpIDispatch::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr); }

    /* IWebBrowser methods */
    STDMETHOD(GoBack)(THIS);
    STDMETHOD(GoForward)(THIS);
    STDMETHOD(GoHome)(THIS);
    STDMETHOD(GoSearch)(THIS);
    STDMETHOD(Navigate)(THIS_ BSTR URL, VARIANT FAR* Flags, VARIANT FAR* TargetFrameName, VARIANT FAR* PostData, VARIANT FAR* Headers);
    STDMETHOD(Refresh)(THIS);
    STDMETHOD(Refresh2)(THIS_ VARIANT FAR* Level);
    STDMETHOD(Stop)(THIS);
    STDMETHOD(get_Application)(THIS_ IDispatch * FAR* ppDisp);
    STDMETHOD(get_Parent)(THIS_ IDispatch * FAR* ppDisp);
    STDMETHOD(get_Container)(THIS_ IDispatch * FAR* ppDisp);
    STDMETHOD(get_Document)(THIS_ IDispatch * FAR* ppDisp);
    STDMETHOD(get_TopLevelContainer)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(get_Type)(THIS_ BSTR FAR* pbstrType);
    STDMETHOD(get_Left)(THIS_ long FAR* pl);
    STDMETHOD(put_Left)(THIS_ long Left);
    STDMETHOD(get_Top)(THIS_ long FAR* pl);
    STDMETHOD(put_Top)(THIS_ long Top);
    STDMETHOD(get_Width)(THIS_ long FAR* pl);
    STDMETHOD(put_Width)(THIS_ long Width);
    STDMETHOD(get_Height)(THIS_ long FAR* pl);
    STDMETHOD(put_Height)(THIS_ long Height);
    STDMETHOD(get_LocationName)(THIS_ BSTR FAR* pbstrLocationName);
    STDMETHOD(get_LocationURL)(THIS_ BSTR FAR* pbstrLocationURL);
    STDMETHOD(get_Busy)(THIS_ VARIANT_BOOL FAR* pBool);

    /* IWebBrowserApp methods */
    STDMETHOD(Quit)(THIS);
    STDMETHOD(ClientToWindow)(THIS_ int FAR* pcx, int FAR* pcy);
    STDMETHOD(PutProperty)(THIS_ BSTR szProperty, VARIANT vtValue);
    STDMETHOD(GetProperty)(THIS_ BSTR szProperty, VARIANT FAR* pvtValue);
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pbstrName);
    STDMETHOD(get_HWND)(THIS_ LONG_PTR* pHWND);
    STDMETHOD(get_FullName)(THIS_ BSTR FAR* pbstrFullName);
    STDMETHOD(get_Path)(THIS_ BSTR FAR* pbstrPath);
    STDMETHOD(get_FullScreen)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(put_FullScreen)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_Visible)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(put_Visible)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_StatusBar)(THIS_ VARIANT_BOOL FAR* pBool);
    STDMETHOD(put_StatusBar)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_StatusText)(THIS_ BSTR FAR* pbstr);
    STDMETHOD(put_StatusText)(THIS_ BSTR bstr);
    STDMETHOD(get_ToolBar)(THIS_ int FAR* pBool);
    STDMETHOD(put_ToolBar)(THIS_ int Value);
    STDMETHOD(get_MenuBar)(THIS_ VARIANT_BOOL FAR* pValue);
    STDMETHOD(put_MenuBar)(THIS_ VARIANT_BOOL Value);

    // IWebBrowser2 methods
    STDMETHOD(Navigate2)(THIS_ VARIANT FAR* URL, VARIANT FAR* Flags, VARIANT FAR* TargetFrameName, VARIANT FAR* PostData, VARIANT FAR* Headers);
    STDMETHOD(ShowBrowserBar)(THIS_ VARIANT FAR* pvaClsid, VARIANT FAR* pvaShow, VARIANT FAR* pvaSize);
    STDMETHOD(QueryStatusWB)(THIS_ OLECMDID cmdID, OLECMDF FAR* pcmdf);
    STDMETHOD(ExecWB)(THIS_ OLECMDID cmdID, OLECMDEXECOPT cmdexecopt, VARIANT FAR* pvaIn, VARIANT FAR* pvaOut);
    STDMETHOD(get_ReadyState)(THIS_ READYSTATE FAR* plReadyState);
    STDMETHOD(get_Offline)(THIS_ VARIANT_BOOL FAR* pbOffline);
    STDMETHOD(put_Offline)(THIS_ VARIANT_BOOL bOffline);
    STDMETHOD(get_Silent)(THIS_ VARIANT_BOOL FAR* pbSilent);
    STDMETHOD(put_Silent)(THIS_ VARIANT_BOOL bSilent);
    STDMETHOD(get_RegisterAsBrowser)(THIS_ VARIANT_BOOL FAR* pbRegister);
    STDMETHOD(put_RegisterAsBrowser)(THIS_ VARIANT_BOOL bRegister);
    STDMETHOD(get_RegisterAsDropTarget)(THIS_ VARIANT_BOOL FAR* pbRegister);
    STDMETHOD(put_RegisterAsDropTarget)(THIS_ VARIANT_BOOL bRegister);
    STDMETHOD(get_TheaterMode)(THIS_ VARIANT_BOOL FAR* pbRegister);
    STDMETHOD(put_TheaterMode)(THIS_ VARIANT_BOOL bRegister);
    STDMETHOD(get_AddressBar)(THIS_ VARIANT_BOOL FAR* Value);
    STDMETHOD(put_AddressBar)(THIS_ VARIANT_BOOL Value);
    STDMETHOD(get_Resizable)(THIS_ VARIANT_BOOL FAR* Value);
    STDMETHOD(put_Resizable)(THIS_ VARIANT_BOOL Value);

    // IWebBrowserPriv
    STDMETHOD(NavigateWithBindCtx)(VARIANT FAR * pvarUrl,
                                   VARIANT FAR * pvarFlags,
                                   VARIANT FAR * pvarTargetFrameName,
                                   VARIANT FAR * pvarPostData,
                                   VARIANT FAR * pvarHeaders,
                                   IBindCtx    * pBindCtx,
                                   BSTR          bstrLocation);
    STDMETHOD(OnClose)();

    // *** CImpIConnectionPointContainer ***
    virtual STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS FAR* ppEnum);

    // *** CImpIExpDispSupport override ***
    virtual STDMETHODIMP OnInvoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams,
                        VARIANT FAR* pVarResult,EXCEPINFO FAR* pexcepinfo,UINT FAR* puArgErr);

    // *** IExternalConnection ***
    virtual DWORD __stdcall AddConnection(DWORD extconn, DWORD reserved);
    virtual DWORD __stdcall ReleaseConnection(DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses);

    // *** IShellService ***
    virtual STDMETHODIMP SetOwner(IUnknown* punkOwner);

    // *** IEFrameAuto ***
    virtual STDMETHODIMP SetOwnerHwnd(HWND hwndOwner);
    virtual STDMETHODIMP put_DefaultReadyState(DWORD dwDefaultReadyState, BOOL fUpdateBrowserReadyState);
    virtual STDMETHODIMP OnDocumentComplete(void);
    virtual STDMETHODIMP OnWindowsListMarshalled(void);
    virtual STDMETHODIMP SetDocHostFlags(DWORD dwDocHostFlags);

    DWORD GetDocHostFlags() { return _dwDocHostInfoFlags; };

    // Embed our Connection Point object - implmentation in cnctnpt.cpp
    CConnectionPoint m_cpWebBrowserEvents;
    CConnectionPoint m_cpWebBrowserEvents2;
    CConnectionPoint m_cpPropNotify;

    HRESULT put_Titlebar(BOOL fValue);

    // Embed handler for defunct ITargetFrame interface for backwards compat.
    // HTML frames - implementation in iedisp.cpp
    class CTargetFrame : public ITargetFrame {
        friend CIEFrameAuto;

        public:

        // IUnknown methods
        //
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
        virtual STDMETHODIMP_(ULONG) AddRef(void) ;
        virtual STDMETHODIMP_(ULONG) Release(void);

        // ITargetFrame methods
        //
        virtual STDMETHODIMP SetFrameName(LPCOLESTR pszFrameName);
        virtual STDMETHODIMP GetFrameName(LPOLESTR *ppszFrameName);
        virtual STDMETHODIMP GetParentFrame(LPUNKNOWN *ppunkParentFrame);
        virtual STDMETHODIMP FindFrame(LPCOLESTR pszTargetName, LPUNKNOWN punkContextFrame, DWORD dwFlags, LPUNKNOWN *ppunkTargetFrame);
        virtual STDMETHODIMP SetFrameSrc(LPCOLESTR pszFrameSrc);
        virtual STDMETHODIMP GetFrameSrc(LPOLESTR *ppszFrameSrc);
        virtual STDMETHODIMP GetFramesContainer(LPOLECONTAINER *ppContainer);
        virtual STDMETHODIMP SetFrameOptions(DWORD dwFlags);
        virtual STDMETHODIMP GetFrameOptions(LPDWORD pdwFlags);
        virtual STDMETHODIMP SetFrameMargins(DWORD dwWidth, DWORD dwHeight);
        virtual STDMETHODIMP GetFrameMargins(LPDWORD pdwWidth, LPDWORD pdwHeight);
        virtual STDMETHODIMP RemoteNavigate(ULONG cLength,ULONG *pulData);
        virtual STDMETHODIMP OnChildFrameActivate(LPUNKNOWN pUnkChildFrame) { return S_OK; }
        virtual STDMETHODIMP OnChildFrameDeactivate(LPUNKNOWN pUnkChildFrame) { return S_OK; }
    } _TargetFrame;
    friend class CTargetFrame;

    // IHlinkFrame
    virtual STDMETHODIMP GetBrowseContext(IHlinkBrowseContext **ppihlbc);
    virtual STDMETHODIMP OnNavigate(
        /* [in] */ DWORD grfHLNF,
        /* [unique][in] */ IMoniker *pimkTarget,
        /* [unique][in] */ LPCWSTR pwzLocation,
        /* [unique][in] */ LPCWSTR pwzFriendlyName,
        /* [in] */ DWORD dwreserved) ;

    virtual STDMETHODIMP UpdateHlink(ULONG uHLID, 
        IMoniker *pimkTarget, LPCWSTR pwzLocation, LPCWSTR pwzFriendlyName) 
            { return E_NOTIMPL;};

    virtual STDMETHODIMP SetBrowseContext(
            /* [unique][in] */ IHlinkBrowseContext *pihlbc);

#ifdef OLD_HLIFACE
    virtual STDMETHODIMP PrepareForNavigation(
             DWORD grfHLBF, LPBC pbc,
             IBindStatusCallback *pibsc, IHlink *pihlNavigate);
    virtual STDMETHODIMP Navigate(
             DWORD grfHLNF, IHlink *pihlNavigate);
    virtual STDMETHODIMP OnReleaseNavigationState(
             IHlink *pihlNavigate, DWORD dwReserved);
#else

    virtual STDMETHODIMP Navigate(
        /* [in] */ DWORD grfHLNF,
        /* [in] */ LPBC pbc,
        /* [in] */ IBindStatusCallback *pibsc,
        /* [in] */ IHlink *pihlNavigate);


#endif

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // IOleCommandTarget and IUrlHistoryNotify
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    
    // *** ITargetFrame2 ***
    virtual STDMETHODIMP SetFrameName(LPCOLESTR pszFrameName);
    virtual STDMETHODIMP GetFrameName(LPOLESTR *ppszFrameName);
    virtual STDMETHODIMP GetParentFrame(LPUNKNOWN *ppunkParentFrame);
    virtual STDMETHODIMP SetFrameSrc(LPCOLESTR pszFrameSrc);
    virtual STDMETHODIMP GetFrameSrc(LPOLESTR *ppszFrameSrc);
    virtual STDMETHODIMP GetFramesContainer(LPOLECONTAINER *ppContainer);
    virtual STDMETHODIMP SetFrameOptions(DWORD dwFlags);
    virtual STDMETHODIMP GetFrameOptions(LPDWORD pdwFlags);
    virtual STDMETHODIMP SetFrameMargins(DWORD dwWidth, DWORD dwHeight);
    virtual STDMETHODIMP GetFrameMargins(LPDWORD pdwWidth, LPDWORD pdwHeight);
    virtual STDMETHODIMP FindFrame(LPCWSTR pszTargetName,DWORD dwFlags,LPUNKNOWN *ppunkTargetFrame);
    virtual STDMETHODIMP GetTargetAlias(LPCOLESTR pszTargetName, LPOLESTR *ppszTargetAlias);

    // *** ITargetFramePriv ***
    virtual STDMETHODIMP FindFrameDownwards(LPCWSTR pszTargetName, DWORD dwFlags,LPUNKNOWN *ppunkTargetFrame);
    virtual STDMETHODIMP FindFrameInContext(LPCWSTR pszTargetName, LPUNKNOWN punkContextFrame,DWORD dwFlags,LPUNKNOWN *ppunkTargetFrame);
    virtual STDMETHODIMP OnChildFrameActivate(LPUNKNOWN pUnkChildFrame) { return E_NOTIMPL; }
    virtual STDMETHODIMP OnChildFrameDeactivate(LPUNKNOWN pUnkChildFrame) { return E_NOTIMPL; }
    virtual STDMETHODIMP NavigateHack(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc, LPCWSTR pszTargetName, LPCWSTR pszUrl, LPCWSTR pszLocation);    
    virtual STDMETHODIMP FindBrowserByIndex(DWORD dwID,IUnknown **ppunkBrowser);

    // *** ITargetNotify ***
    virtual STDMETHODIMP OnCreate(LPUNKNOWN pUnkDestination, ULONG cbCookie);
    virtual STDMETHODIMP OnReuse(LPUNKNOWN pUnkDestination);

protected:
    void Exception(WORD wException);
    HWND    _GetHWND(void);
    HRESULT _PidlFromUrlEtc(UINT uiCP, LPCWSTR pszUrl, LPWSTR pszLocation, LPITEMIDLIST* ppidl);
    HRESULT _BrowseObject(LPCITEMIDLIST pidl, UINT wFlags);
    HRESULT _GoStdLocation(DWORD dwWhich);
    HRESULT _NavigateMagnum(DWORD grfHLNF, LPBC pbc, IBindStatusCallback *pibsc, LPCWSTR pszTargetName, LPCWSTR pszUrl, LPCWSTR pszLocation, IHlink *pihlNavigate, IMoniker *pmkTarget);

    //  methods to pass the referring url to a new window
    HRESULT _ReferrerHack(LPCWSTR pszUrl);
    void    _SetReferrer(LPTARGETFRAMEPRIV ptgfp);

    // *** misc helper methods for ITargetFrame implementation
    void _SetPendingNavigateContext(LPBC pbc, IBindStatusCallback *pibsc);
    void _ActivatePendingNavigateContext(void);
    HRESULT _JumpTo(LPBC pbc, LPWSTR pszLocation, DWORD grfHLNF, IBindStatusCallback __RPC_FAR *pibsc,
            /* [in] */ IHlink __RPC_FAR *pihlNavigate, LPCWSTR pszFrameName, LPCWSTR pszUrl);
    void _CancelPendingNavigation(VARIANTARG* pvar);
    BOOL _fNavigationPending();
    HRESULT _DoNamedTarget(LPCOLESTR pszTargetName, LPUNKNOWN punkContextFrame, DWORD dwFlags, LPUNKNOWN *ppunkTargetFrame);
    HRESULT _GetOleObject(IOleObject** ppobj);
    IShellView* _GetShellView(void);
    HRESULT _get_Location(BSTR FAR* pbstr, UINT uFlags);
    void _ClearPropertyList(void);
    HRESULT _WaitForNotify();
    HRESULT _RegisterCallback(TCHAR  *szFrameName, LPTARGETNOTIFY ptgnNotify);
    HRESULT _RevokeCallback();
    virtual HRESULT v_InternalQueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual CConnectionPoint* _FindCConnectionPointNoRef(BOOL fdisp, REFIID iid);
    HRESULT _QueryDelegate(IDispatch **pidDelegate);
    HRESULT _QueryPendingUrl(VARIANT *pvarResult);
    HRESULT _RetryNavigate();
    HRESULT _QueryPendingDelegate(IDispatch **ppDisp, VARIANT *pvarargIn);
    BOOL    _fDesktopComponent();
    HRESULT _GetParentFramePrivate(LPUNKNOWN *ppunkParentFrame);

    HRESULT _FindWindowByName(IOleContainer * pOleContainer,
                              LPCOLESTR       pszTargetName,
                              LPUNKNOWN     * ppunkTargetFrame);

    HRESULT _NavigateHelper(BSTR URL,
                            VARIANT  * Flags,
                            VARIANT  * TargetFrameName,
                            VARIANT  * PostData,
                            VARIANT  * Headers,
                            IBindCtx * pNavBindCtx  = NULL,
                            BSTR       bstrLocation = NULL);

    HRESULT _NavIEShortcut(VARIANT *pvarIn, VARIANT *pvarFlags);
    void     _HandleOpenOptions( IUnknown * pUnkDestination, ITargetNotify * ptgnNotify);
    
    // constructor and destructor are private...
    // use CIEFrameAuto_CreateInstance to get at this object
    CIEFrameAuto(IUnknown* punkAgg=NULL);
    ~CIEFrameAuto();
    friend HRESULT CIEFrameAuto_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk);
    friend HRESULT GetRootDelegate( CIEFrameAuto* pauto, IDispatch ** const ppRootDelegate );
    friend DWORD OpenAndNavigateToURL(CIEFrameAuto *pauto, BSTR *pbstrURL, const WCHAR *pwzTarget, ITargetNotify *pNotify, BOOL bNoHistory, BOOL bSilent);

    // Member variables for automation
    IBrowserService *_pbs;
    ITypeInfo      *_pITI;      //Type information
    HWND            _hwnd;
    UINT            _cLocks;
    CIEFrameAutoProp *_pProps;
    DWORD           _dwDefaultReadyState;
    BOOL            m_bOffline:1; // Indicates if this frame is offline or not
    BOOL            m_bSilent:1; // Indicates if this frame is silent or not
    DWORD           _dwDocHostInfoFlags;    // Flags from GetHostInfo (CDocObjectHost)

    // for IHlinkFrame implementation
    IServiceProvider*           _psp;       // browser
    LPBC                        _pbc;
    IBindStatusCallback *       _pbsc;
    LPBC                        _pbcPending;
    IBindStatusCallback *       _pbscPending;
    IShellBrowser*              _psb;
    IShellBrowser*              _psbTop;
    IShellBrowser*              _psbFrameTop;
    IOleCommandTarget*          _poctFrameTop;
    IShellBrowser*              _psbProxy;
    IOleCommandTarget*          _pmsc;
    IHlinkBrowseContext*        _phlbc;
    LPWSTR                      _pwszShortcutPath;
    LPWSTR                      _pwszShortcutPathPending;
    DWORD                       _dwRegHLBC;
    BOOL                        _fBusy:1;
    BOOL                        _fRegistered:1;
    BOOL                        _fDesktopFrame:1;
    BOOL                        _fSuppressHistory:1;
    BOOL                        _fSuppressSelect:1;
    BOOL                        _fWindowsListMarshalled:1;
    BOOL                        _fRegisterAsBrowser:1;
    BOOL                        _fQuitInProgress:1;
    long                        _cbCookie;
    LPTARGETNOTIFY              _ptgnNotify;
    DWORD                       _dwTickPropertySweep;   

    // for ITargetFrame implementation
    LPOLESTR m_pszFrameName;    // Name of our frame
    LPOLESTR m_pszFrameSrc;     // Original source of our frame (for embedded OC's)
    DWORD m_dwFrameOptions;     // Frame options
    DWORD m_dwFrameMarginWidth; // Frame marginwidth
    DWORD m_dwFrameMarginHeight;// Frame marginheight


    HINSTANCE           _hinstMSHTML;
    PFN_MatchExactGetIDsOfNames _pfnMEGetIDsOfNames;

    class CAutomationStub : public IDispatchEx, public IProvideClassInfo
    {
        friend class CIEFrameAuto;
    public:
        CAutomationStub( DISPID min, DISPID max, BOOL fOwnDefaultDispid );
        HRESULT Init( void *instance, REFIID iid, REFIID clsid, CIEFrameAuto *pauto );
        virtual ~CAutomationStub();

        // Only used internally so we don't need to Addref
        CIEFrameAuto *IEFrameAuto() const { return _pAuto; }
        
        // *** IUnknown members ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void) ;
        STDMETHODIMP_(ULONG) Release(void);
        
        // *** IDispatch members ***
        virtual STDMETHODIMP GetTypeInfoCount(UINT *);
        virtual STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
        virtual STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);
        virtual STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

        // *** IDispatchEx members ***
        STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
        STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller);       
        STDMETHODIMP DeleteMemberByName(BSTR bstr, DWORD grfdex);
        STDMETHODIMP DeleteMemberByDispID(DISPID id);
        STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
        STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName);
        STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid);
        STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk);

        // *** IProvideClassInfo members ***
        STDMETHODIMP GetClassInfo( ITypeInfo** ppTI );

    protected:
        virtual HRESULT _GetIDispatchExDelegate( IDispatchEx ** const ) = 0;
        virtual HRESULT _InternalQueryInterface( REFIID riid, void** const ppvObj ) = 0;

        CIEFrameAuto *_pAuto;

    private:
        HRESULT ResolveTypeInfo2( );

        void *_pInstance;
        ITypeInfo2 *_pInterfaceTypeInfo2;
        ITypeInfo2 *_pCoClassTypeInfo2;
        BOOL _fLoaded;
        IID   _iid;
        CLSID _clsid;
        const DISPID _MinDispid;
        const DISPID _MaxDispid;
        const BOOL _fOwnDefaultDispid;
    };
    friend class CAutomationStub;

public:
    class COmWindow :
        public IHTMLWindow2,
        public CAutomationStub,
        public ITargetNotify,
        public IShellHTMLWindowSupport2,
        public IProvideMultipleClassInfo,
        public IConnectionPointCB,
        public IConnectionPointContainer,
        public IServiceProvider,
#ifndef NO_MARSHALLING
        public IHTMLWindow3
#else
        public IHTMLWindow3,
        public IWindowStatus
#endif
    {
    public:
        friend class CIEFrameAuto;
    
        COmWindow();
        HRESULT Init();
        ~COmWindow() { VariantClear(&_varOpener); UnsinkDelegate(); DestroyIntelliForms( ); }
        HRESULT DeInit( ) { VariantClear(&_varOpener); return S_OK; }

        // *** IUnknown members ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAutomationStub::QueryInterface(riid, ppvObj); }
        STDMETHODIMP_(ULONG) AddRef(void)  { return CAutomationStub::AddRef( ); }
        STDMETHODIMP_(ULONG) Release(void)  { return CAutomationStub::Release( ); }

        // *** IDispatch members ***
        STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return CAutomationStub::GetTypeInfoCount(pi); }
        STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo) { return CAutomationStub::GetTypeInfo(it,lcid,pptypeinfo); }
        STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return CAutomationStub::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgDispId); }
        STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
            { return CAutomationStub::Invoke(dispid,riid,lcid,wFlags,dispparams,pvarResult,pexcepinfo,puArgErr ); }
        
        // *** IDispatchEx members ***
        STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
        STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
            { return CAutomationStub::InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller); }
        STDMETHODIMP DeleteMemberByName(BSTR bstr, DWORD grfdex)
            { return CAutomationStub::DeleteMemberByName(bstr, grfdex); }
        STDMETHODIMP DeleteMemberByDispID(DISPID id)
            { return CAutomationStub::DeleteMemberByDispID(id); }
        STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
            { return CAutomationStub::GetMemberProperties(id, grfdexFetch, pgrfdex); }
        STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName)
            { return CAutomationStub::GetMemberName(id, pbstrName); }
        STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
            { return CAutomationStub::GetNextDispID(grfdex, id, pid); }
        STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk)
            { return CAutomationStub::GetNameSpaceParent(ppunk); }

        // *** IHTMLFramesCollection2 ***
        STDMETHODIMP item( VARIANT *pvarIndex, VARIANT* pvarResult );
        STDMETHODIMP get_length(long* pl);


        // *** IHTMLWindow2 ***
        STDMETHODIMP get_name (BSTR FAR* retval);
        STDMETHODIMP put_name (BSTR theName);
        STDMETHODIMP get_parent(IHTMLWindow2** retval);
        STDMETHODIMP get_top(IHTMLWindow2** retval);
        STDMETHODIMP get_self(IHTMLWindow2** retval);
        STDMETHODIMP get_opener(VARIANT* retval);
        STDMETHODIMP put_opener(VARIANT opener);
        STDMETHODIMP get_window(IHTMLWindow2** retval);
        STDMETHODIMP get_document(IHTMLDocument2** retval);
        STDMETHODIMP get_frames(IHTMLFramesCollection2** retval);
        STDMETHODIMP get_location(IHTMLLocation** retval);
        STDMETHODIMP get_navigator(IOmNavigator** retval);
        STDMETHODIMP get_history(IOmHistory** retval);
        STDMETHODIMP put_defaultStatus(BSTR statusmsg);
        STDMETHODIMP get_defaultStatus(BSTR *retval);
        STDMETHODIMP put_status(BSTR statusmsg);
        STDMETHODIMP get_status(BSTR *retval);
        STDMETHODIMP open( BSTR url, BSTR name, BSTR features, VARIANT_BOOL replace, IHTMLWindow2** ppomWindowResult );
        STDMETHODIMP alert(BSTR message);
        STDMETHODIMP close();
        STDMETHODIMP confirm(BSTR message, VARIANT_BOOL* confirmed);
        STDMETHODIMP prompt(BSTR message, BSTR defstr, VARIANT* textdata);
        STDMETHODIMP setTimeout(BSTR expression, long msec, VARIANT* language, long FAR* timerID);
        STDMETHODIMP clearTimeout(long timerID);
        STDMETHODIMP navigate(BSTR url);
        STDMETHODIMP get_Image(IHTMLImageElementFactory** retval);
        STDMETHODIMP get_event( IHTMLEventObj* * p);
        STDMETHODIMP get__newEnum(IUnknown* * p);
        STDMETHODIMP showModalDialog(BSTR dialog,VARIANT* varArgIn, VARIANT* varOptions,VARIANT* varArgOut);
        STDMETHODIMP showHelp(BSTR helpURL, VARIANT helpArg, BSTR features);
        STDMETHODIMP execScript(BSTR bstrCode, BSTR bstrLanguage, VARIANT * pvarRet);
        STDMETHODIMP get_screen( IHTMLScreen ** p);
        STDMETHODIMP get_Option(IHTMLOptionElementFactory** retval);
        STDMETHODIMP focus();
        STDMETHODIMP get_closed(VARIANT_BOOL*retval);
        STDMETHODIMP blur();
        STDMETHODIMP scroll(long x, long y);
        STDMETHODIMP put_onblur(VARIANT v);
        STDMETHODIMP get_onblur(VARIANT*p);
        STDMETHODIMP put_onfocus(VARIANT v);
        STDMETHODIMP get_onfocus(VARIANT*p);
        STDMETHODIMP put_onload(VARIANT v);
        STDMETHODIMP get_onload(VARIANT*p);
        STDMETHODIMP put_onunload(VARIANT v);
        STDMETHODIMP get_onunload(VARIANT*p);
        STDMETHODIMP put_onhelp(VARIANT v);
        STDMETHODIMP get_onhelp(VARIANT*p);
        STDMETHODIMP put_onerror(VARIANT v);
        STDMETHODIMP get_onerror(VARIANT*p);
        STDMETHODIMP put_onscroll(VARIANT v);
        STDMETHODIMP get_onscroll(VARIANT*p);
        STDMETHODIMP put_onresize(VARIANT v);
        STDMETHODIMP get_onresize(VARIANT*p);
        STDMETHODIMP get_clientInformation( IOmNavigator ** retval );
        STDMETHODIMP setInterval(BSTR expression,long msec,VARIANT* language,long* timerID);
        STDMETHODIMP clearInterval(long timerID);
        STDMETHODIMP put_offscreenBuffering(VARIANT var);
        STDMETHODIMP get_offscreenBuffering(VARIANT *retval);
        STDMETHODIMP put_onbeforeunload(VARIANT v);
        STDMETHODIMP get_onbeforeunload(VARIANT*p);
        STDMETHODIMP toString(BSTR *String);
        STDMETHODIMP scrollBy(long x, long y);
        STDMETHODIMP scrollTo(long x, long y);
        STDMETHODIMP moveTo(long x, long y);
        STDMETHODIMP moveBy(long x, long y);
        STDMETHODIMP resizeTo(long x, long y);
        STDMETHODIMP resizeBy(long x, long y);
        STDMETHODIMP get_external(IDispatch **ppDisp);

        // *** IHTMLWindow3 ***
        STDMETHODIMP get_screenTop(long*p);
        STDMETHODIMP get_screenLeft(long*p);
        STDMETHODIMP attachEvent(BSTR event, IDispatch * pDisp, VARIANT_BOOL *pResult);
        STDMETHODIMP detachEvent(BSTR event, IDispatch * pDisp);
        STDMETHODIMP setTimeout(VARIANT *pExpression, long msec, VARIANT* language, long FAR* timerID);
        STDMETHODIMP setInterval(VARIANT *pExpression, long msec, VARIANT* language, long FAR* timerID);
        STDMETHODIMP print();
        STDMETHODIMP put_onbeforeprint(VARIANT v);
        STDMETHODIMP get_onbeforeprint(VARIANT*p);
        STDMETHODIMP put_onafterprint(VARIANT v);
        STDMETHODIMP get_onafterprint(VARIANT*p);
        STDMETHODIMP get_clipboardData(IHTMLDataTransfer **ppDataTransfer);
        STDMETHOD(showModelessDialog)(BSTR strUrl, 
                                      VARIANT * pvarArgIn, 
                                      VARIANT * pvarOptions, 
                                      IHTMLWindow2 ** ppDialog);

        // *** IConnectionPointContainer ***
        STDMETHODIMP EnumConnectionPoints( LPENUMCONNECTIONPOINTS *ppEnum );
        STDMETHODIMP FindConnectionPoint( REFIID iid, LPCONNECTIONPOINT *ppCP );

        // *** IConnectionPointCB ***
        STDMETHODIMP OnAdvise(REFIID iid, DWORD cSinks, DWORD_PTR dwCookie);
        STDMETHODIMP OnUnadvise(REFIID iid, DWORD cSinks, DWORD_PTR dwCookie)  { return S_OK; }
        
        // *** ITargetNotify members ***
        STDMETHODIMP OnCreate(IUnknown *pUnkDestination, ULONG cbCookie);
        STDMETHODIMP OnReuse(IUnknown *pUnkDestination);

        // *** IShellHTMLWindowSupport ***
        STDMETHODIMP ViewReleaseIntelliForms();
        STDMETHODIMP ViewReleased();
        STDMETHODIMP ViewActivated();
        STDMETHODIMP ReadyStateChangedTo( long, IShellView* );
        STDMETHODIMP CanNavigate();
        STDMETHODIMP ActiveElementChanged(IHTMLElement * pHTMLElement);
        STDMETHODIMP IsGalleryMeta(BOOL bFlag);

        // *** IProvideMultipleClassInfo members ***
        STDMETHODIMP GetClassInfo( ITypeInfo** ppTI ) { return CAutomationStub::GetClassInfo(ppTI); }
        STDMETHODIMP GetGUID( DWORD dwGuidKind, GUID* pGUID );
        STDMETHODIMP GetMultiTypeInfoCount( ULONG *pcti );
        STDMETHODIMP GetInfoOfIndex( ULONG iti, DWORD dwFlags, ITypeInfo **pptiCoClass, DWORD *pdwTIFlags, ULONG *pcdispidReserved,IID *piidPrimary,IID *piidSource );

        // *** IServiceProvider members ***
        STDMETHODIMP QueryService(REFGUID guidService, REFIID iid, LPVOID * ppv);

#ifdef NO_MARSHALLING
        // *** IWindowStatus members ***
        STDMETHOD(IsWindowActivated)();
#endif

        enum Bogus { BOOL_NOTSET = 2 };

        // Options which apply to a newly created window
        class WindowOpenOptions
        {
        public:
            BOOL fToolbar;      // whether to show the  navigation toolbar
            BOOL fLocation;     // "        "           location bar <NYI>
            BOOL fDirectories;  // "        "           quick links <NYI>
            BOOL fStatus;       // "        "           status bar 
            BOOL fMenubar;      // "        "           menu bar <NYI>
            BOOL fScrollbars;   // "        "           scroll bars
            BOOL fResizable;    // whether the new window should be resizable
            BOOL fFullScreen;   // whether the window should be in full-screen (kiosk) mode
            BOOL fChannelMode;  // whether the window should be in Channel mode.
            BOOL fTitlebar;     // whether to show the  title bar of the window
            int iWidth;         // width of the new window
            int  iHeight;       // height of the new window
            int iLeft;          // left x-coordinate of the new window
            int iTop;           // top y-coordinate of the new window
        
            WindowOpenOptions() { ReInitialize(); }
        
            void ReInitialize()
            {
                fMenubar = TRUE; 
                fToolbar = TRUE;
                fStatus = TRUE;
                fScrollbars = TRUE;
                fResizable = TRUE; 
                fDirectories = TRUE;
                fFullScreen = BOOL_NOTSET;    // whether to use full-screen (kiosk) mode
                fChannelMode = BOOL_NOTSET;
                fLocation = BOOL_NOTSET; 
                fTitlebar = TRUE;
                iWidth = -1; 
                iHeight = -1;
                iLeft = -1;
                iTop = -1;
            }
        };

        HRESULT _GetWindowDelegate(IHTMLWindow2 **ppomwDelegate);
        HRESULT _GetWindowDelegate(IHTMLWindow3 **ppomwDelegate);

    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _InternalQueryInterface(REFIID riid, void ** const ppvObj);
        virtual HRESULT _GetIDispatchExDelegate( IDispatchEx ** const delegate );
        
        WindowOpenOptions _OpenOptions;

        // *** Window Open Helper Methods ***
        BSTR _GenerateUniqueWindowName( );
        HRESULT _ApplyOpenOptions( IWebBrowser2 *pie );
        HRESULT _ParseOptionString( BSTR bstrOptionString, ITargetNotify2 * ptgnNotify2 = NULL);

    private:
        static unsigned long s_uniqueIndex;
        BOOL _fCallbackOK;
        IHTMLWindow2 *_pOpenedWindow;
        VARIANT _varOpener;
        BOOL _fIsChild;

        // Connection point stuff.
        class CWindowEventSink : public IDispatch
        {
        public:
            CWindowEventSink() { }
            ~CWindowEventSink() { }

            // *** IUnknown members ***
            STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
            STDMETHODIMP_(ULONG) AddRef(void);
            STDMETHODIMP_(ULONG) Release(void);

            // *** IDispatch members ***
            STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return E_NOTIMPL; }
            STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo)  { return E_NOTIMPL; }
            STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)   { return E_NOTIMPL; }
            STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr );
        };
        friend CWindowEventSink;
        
        // Event Data
        CWindowEventSink _wesDelegate;
        BOOL _fOnloadFired;
        
        CConnectionPoint _cpWindowEvents;
        IConnectionPoint *_pCP;
        DWORD _dwCPCookie;
               
        // Event Methods
        BOOL IsDelegateComplete( );
        HRESULT SinkDelegate( );
        HRESULT UnsinkDelegate( );
        HRESULT FireOnLoad( );
        HRESULT FireOnUnload( );

        // IntelliForms data and methods
        void *_pIntelliForms;
        HRESULT AttachIntelliForms( );
        HRESULT ReleaseIntelliForms( );
        HRESULT DestroyIntelliForms( );

        BOOL   _fIntelliFormsAskUser;
        BOOL   _fDelegateWindowOM;
 
    public:
        HRESULT IntelliFormsAskUser(LPCWSTR pwszValue);
        void   *IntelliForms() { return _pIntelliForms; }
        void    SetDelegationPolicy(BOOL fFlag) { _fDelegateWindowOM = fFlag; }		        
    }; // COmWindow

protected:
    
    friend class COmWindow;
    COmWindow  _omwin;


    class COmLocation : public IHTMLLocation, public CAutomationStub, public IObjectIdentity, public IServiceProvider
    {
    public:
        COmLocation( );
        HRESULT Init( );
        virtual ~COmLocation();

        // *** IUnknown members ***
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAutomationStub::QueryInterface(riid, ppvObj); }
        virtual STDMETHODIMP_(ULONG) AddRef(void)  { return CAutomationStub::AddRef( ); }
        virtual STDMETHODIMP_(ULONG) Release(void)  { return CAutomationStub::Release( ); }

        // *** IDispatch members ***
        virtual STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return CAutomationStub::GetTypeInfoCount(pi); }
        virtual STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo) { return CAutomationStub::GetTypeInfo(it,lcid,pptypeinfo); }
        virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return CAutomationStub::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgDispId); }
        virtual STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
            { return CAutomationStub::Invoke(dispid,riid,lcid,wFlags,dispparams,pvarResult,pexcepinfo,puArgErr ); }
        
        // *** IDispatchEx members ***
        STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
            { return CAutomationStub::GetDispID(bstrName, grfdex, pid); }
        STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
            { return CAutomationStub::InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller); }
        STDMETHODIMP DeleteMemberByName(BSTR bstr, DWORD grfdex)
            { return CAutomationStub::DeleteMemberByName(bstr, grfdex); }
        STDMETHODIMP DeleteMemberByDispID(DISPID id)
            { return CAutomationStub::DeleteMemberByDispID(id); }
        STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
            { return CAutomationStub::GetMemberProperties(id, grfdexFetch, pgrfdex); }
        STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName)
            { return CAutomationStub::GetMemberName(id, pbstrName); }
        STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
            { return CAutomationStub::GetNextDispID(grfdex, id, pid); }
        STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk)
            { return CAutomationStub::GetNameSpaceParent(ppunk); }

        // *** IObjectIdentity members ***
        STDMETHODIMP IsEqualObject(IUnknown * pUnk);

        // *** IServiceProvider members ***
        STDMETHODIMP QueryService(REFGUID guidService, REFIID iid, LPVOID * ppv);

        // properties 
        STDMETHODIMP get_href(BSTR* pbstr);
        STDMETHODIMP put_href(BSTR bstr);
        STDMETHODIMP get_protocol(BSTR* pbstr);
        STDMETHODIMP put_protocol(BSTR bstr);
        STDMETHODIMP get_hostname(BSTR* pbstr);
        STDMETHODIMP put_hostname(BSTR bstr);
        STDMETHODIMP get_host(BSTR* pbstr);
        STDMETHODIMP put_host(BSTR bstr);
        STDMETHODIMP get_pathname(BSTR* pbstr);
        STDMETHODIMP put_pathname(BSTR bstr);
        STDMETHODIMP get_search(BSTR* pbstr);
        STDMETHODIMP put_search(BSTR bstr);
        STDMETHODIMP get_hash(BSTR* pbstr);
        STDMETHODIMP put_hash(BSTR bstr);
        STDMETHODIMP get_port(BSTR* pbstr);
        STDMETHODIMP put_port(BSTR bstr)  ;

        // methods
        STDMETHODIMP reload(VARIANT_BOOL fFlag)  ;
        STDMETHODIMP replace(BSTR bstr)  ;
        STDMETHODIMP assign(BSTR bstr)  ;
        STDMETHODIMP toString(BSTR *pbstr) ;
        
        // Helper function for COmWin
        // Takes a relative URL and returns the absolute URL using this
        // location as the base
        BSTR ComputeAbsoluteUrl( BSTR bstrUrlRelative );

        void RetryNavigate();

    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _InternalQueryInterface(REFIID riid, void ** const ppvObj);
        virtual HRESULT _GetIDispatchExDelegate( IDispatchEx ** const delegate );

        // Helper function for the property access functions
        // Makes sure that the URL has been parsed and returns a copy
        // of the requested field as a BSTR.
        HRESULT GetField(BSTR* bstrField, BSTR* pbstr);
        HRESULT FreeStuff( );
        HRESULT CheckUrl( );
    
        // Helper function for the property setting functions
        // Makes sure that the URL has been parsed
        // Sets the field to its new value 
        // recomposes the URL, IF fRecomposeUrl is true
        // If part of a window, tells the window to go to the new URL
        //
        //
        // @todo JavaScript has some funky behavior on field setting--
        // for example, the protocol field can be set to an entire URL.
        // We need to make sure this functionality is duplicated
        STDMETHODIMP SetField(BSTR* field, BSTR newval, BOOL fRecomposeUrl); 
        
        STDMETHODIMP ComposeUrl();
        STDMETHODIMP DoNavigate();
        STDMETHODIMP ParseUrl();
        
        BSTR m_bstrFullUrl;
        
        BSTR m_bstrProtocol;
        BSTR m_bstrHostName;
        BSTR m_bstrPort;
        BSTR m_bstrPath;
        BSTR m_bstrSearch;
        BSTR m_bstrHash;

        BOOL m_fdontputinhistory:1;        
        BOOL m_fPendingNavigate:1;
        BOOL m_fRetryingNavigate:1;

    }; // COmLocation

    friend class COmLocation;
    COmLocation _omloc;

    class CCommonCollection : public CAutomationStub
    {
    public:
        CCommonCollection();

        // *** IDispatchEx members ***
        STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
        STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller);

        STDMETHODIMP DeleteMemberByName(BSTR bstr, DWORD grfdex)
            { return CAutomationStub::DeleteMemberByName(bstr, grfdex); }
        STDMETHODIMP DeleteMemberByDispID(DISPID id)
            { return CAutomationStub::DeleteMemberByDispID(id); }
        STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
            { return CAutomationStub::GetMemberProperties(id, grfdexFetch, pgrfdex); }
        STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName)
            { return CAutomationStub::GetMemberName(id, pbstrName); }
        STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
            { return CAutomationStub::GetNextDispID(grfdex, id, pid); }
        STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk)
            { return CAutomationStub::GetNameSpaceParent(ppunk); }

        STDMETHODIMP get_length(long* retval);

    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _GetIDispatchExDelegate( IDispatchEx ** const delegate );
    };

    friend class CCommonCollection;

#ifdef UNIX
nested_cls_access:
#endif
    class CMimeTypes : public IHTMLMimeTypesCollection, public CCommonCollection
    {
    public:
        HRESULT Init( );

        // *** IUnknown members ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAutomationStub::QueryInterface(riid, ppvObj); }
        STDMETHODIMP_(ULONG) AddRef(void)  { return CAutomationStub::AddRef( ); }
        STDMETHODIMP_(ULONG) Release(void)  { return CAutomationStub::Release( ); }

        // *** IDispatch members ***
        STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return CAutomationStub::GetTypeInfoCount(pi); }
        STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo) { return CAutomationStub::GetTypeInfo(it,lcid,pptypeinfo); }
        STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return CAutomationStub::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgDispId); }
        STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
            { return CAutomationStub::Invoke(dispid,riid,lcid,wFlags,dispparams,pvarResult,pexcepinfo,puArgErr ); }

        // *** IHTMLMimeTypesCollection members ***
        STDMETHODIMP get_length(long* retval) {return CCommonCollection::get_length(retval);}

    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _InternalQueryInterface( REFIID riid, void ** const ppvObj );
    };
        
    friend class CMimeTypes;
    CMimeTypes  _mimeTypes;


    class CPlugins : public IHTMLPluginsCollection, public CCommonCollection
    {
    public:
        HRESULT Init( );

        // *** IUnknown members ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAutomationStub::QueryInterface(riid, ppvObj); }
        STDMETHODIMP_(ULONG) AddRef(void)  { return CAutomationStub::AddRef( ); }
        STDMETHODIMP_(ULONG) Release(void)  { return CAutomationStub::Release( ); }

        // *** IDispatch members ***
        STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return CAutomationStub::GetTypeInfoCount(pi); }
        STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo) { return CAutomationStub::GetTypeInfo(it,lcid,pptypeinfo); }
        STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return CAutomationStub::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgDispId); }
        STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
            { return CAutomationStub::Invoke(dispid,riid,lcid,wFlags,dispparams,pvarResult,pexcepinfo,puArgErr ); }
        
        // *** IHTMLPluginsCollection members ***
        STDMETHODIMP get_length(long* retval) {return CCommonCollection::get_length(retval);}
        STDMETHODIMP refresh(VARIANT_BOOL fReload){ return S_OK;}

    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _InternalQueryInterface( REFIID riid, void ** const ppvObj );
    };

    friend class CPlugins;
    CPlugins  _plugins;

    /*******************/
    class COpsProfile : 
                public IHTMLOpsProfile,
                public CAutomationStub,
                public IOpsProfileSimple
    {

    public:
        COpsProfile();
        ~COpsProfile();

        HRESULT Init();
    
        // *** IUnknown methods ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAutomationStub::QueryInterface(riid, ppvObj); }
        STDMETHODIMP_(ULONG) AddRef(void)  { return CAutomationStub::AddRef( ); }
        STDMETHODIMP_(ULONG) Release(void)  { return CAutomationStub::Release( ); }

        // *** IDispatch members ***
        STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return CAutomationStub::GetTypeInfoCount(pi); }
        STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo) { return CAutomationStub::GetTypeInfo(it,lcid,pptypeinfo); }
        STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return CAutomationStub::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgDispId); }
        STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
                { return CAutomationStub::Invoke(dispid,riid,lcid,wFlags,dispparams,pvarResult,pexcepinfo,puArgErr ); }

        // Returns the named profile attribute in the second argument
        virtual     STDMETHODIMP    getAttribute(BSTR bstrAttribName, BSTR *bstrAttribValue);

        // Sets the named attirubute to the value given in the second argument
        virtual     STDMETHODIMP    setAttribute(BSTR bstrAttribName, BSTR bstrAttribValue, VARIANT vaPrefs, VARIANT_BOOL *pfSuccess);
                                                 
        // Adds a request to the list
        virtual     STDMETHODIMP    addReadRequest(BSTR bstrName, VARIANT reserved, VARIANT_BOOL *pfSuccess);
        virtual     STDMETHODIMP    addRequest  (BSTR bstrName, VARIANT reserved, VARIANT_BOOL *pfSuccess)
            { return addReadRequest(bstrName, reserved, pfSuccess);   }

        // Clears the request list
        virtual     STDMETHODIMP    clearRequest();

        // Retrieves the items in the request list
        virtual     STDMETHODIMP    doRequest(VARIANT usage, VARIANT fname, VARIANT domain, VARIANT path, VARIANT expire, VARIANT reserved);
        virtual     STDMETHODIMP    doReadRequest(VARIANT usage, VARIANT fname, VARIANT domain, VARIANT path, VARIANT expire, VARIANT reserved)
            { return  doRequest(usage, fname, domain, path, expire, reserved); }

        // Attempts to set the attributes in the change list
        virtual     STDMETHODIMP    commitChanges (VARIANT_BOOL *pfSuccess);
        virtual     STDMETHODIMP    doWriteRequest (VARIANT_BOOL *pfSuccess)
            { return  commitChanges(pfSuccess); }

        // *** IOpsProfileSimple members ***
        STDMETHODIMP    ReadProperties(long lNumProperties, const LPCWSTR szProperties[], LPWSTR szReturnValues[]);
        STDMETHODIMP    WriteProperties(long lNumProperties, const LPCWSTR szProperties[], const LPCWSTR szValues[]);

    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _InternalQueryInterface( REFIID riid, void ** const ppvObj );
        virtual HRESULT _GetIDispatchExDelegate(IDispatchEx ** const delegate);

    private:      
        BOOL                _ValidateElemName(LPCWSTR, INT *pIndex = NULL);

#ifdef _USE_PSTORE_
        HRESULT             _GetPStoreTypes(BSTR bstrField, GUID *pguidType, GUID *pguidSubtype, BSTR *bstrName);
#endif  // _USE_PSTORE_

        HRESULT             _SetFieldValue(const OLECHAR *pszField, BSTR bstrValue);
        HRESULT             _GetFieldValue(const OLECHAR *pszField, BSTR * pbstrValue);
        HRESULT             _CreateStore();
        HRESULT             _ReleaseStore();
        HRESULT             _GetUsageCode(VARIANT vaUsage, LPTSTR bstrUsage, int cLen);
        BOOL                _IsLocalMachine();
        BOOL                _IsUsingSSL();
        static INT          _GetCookieSettings();

        // Common helpers for both dialogs
        static BOOL         _OPSDlg_OnClose(HWND hDlg);

        // Consent dialog functions.
        static INT_PTR      _OPSConsent_DlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
        static BOOL         _OPSConsent_OnInitDlg(HWND hDlg);
        static BOOL         _OPSConsent_ShowRequestedItems(HWND hDlg);
        static BOOL         _OPSConsent_OnCommand(HWND hDlg, UINT id, UINT nCmd);
        static BOOL         _OPSConsent_ViewCertificate(HWND hDlg);
        static BOOL         _OPSConsent_EditProfile(HWND hDlg);

        // Update dialog functions.
        static INT_PTR      _OPSUpdate_DlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
        static BOOL         _OPSUpdate_OnInitDlg(HWND hDlg);
        static BOOL         _OPSUpdate_OnCommand(HWND hDlg, UINT id, UINT nCmd);
         
        static INT          _GetAttrIndexFromName(LPCWSTR);
        static INT          _GetResourceIdFromAttrName(WCHAR *);

        static HRESULT      _StringFromBSTR(BSTR bstrSource, TCHAR *pszDest, DWORD cchDestSize);
        static HRESULT      _StringFromVariant(VARIANT *vaSource, TCHAR *pszDest, DWORD cchDestSize);

#ifdef _USE_PSTORE_
        PST_PROVIDERID      m_provID;
        IPStore            *m_pStore;
#else
        BOOL                m_bWABInit;
        HMODULE             m_hInstWAB;
        LPADRBOOK           m_lpAdrBook;
        LPWABOBJECT         m_lpWABObject;
        HRESULT             m_hrWAB;
        SBinary             m_SBMe;
#endif  // _USE_PSTORE_

        unsigned            m_iStoreRef;
        BSTR                m_bstrLastURL;
        HDPA                m_hdpaRequests;
        HDPA                m_hdpaChanges;
        BOOL                m_fEnabled;
        HKEY                m_hP3Global;
        HKEY                m_hP3Sites;

    public:        
        enum { P3_QUERY, P3_DENY, P3_GRANT, P3_REQSSL };
        enum { P3_REJECT, P3_ACCEPT };
        enum { P3_NONE, P3_GLOBAL, P3_SITELEVEL };

        // Struct for user preferences
        struct P3UserPref {

            short int   m_access;
            short int   m_lastRequest;
        };

        // Struct for holding request information
        struct OPSRequestEntry {
            
            BSTR        m_bstrName;
            BSTR        m_bstrValue;
            BSTR        m_bstrOldVal;
            BOOL        m_fAnswer;
            BOOL        m_fQuery;
            DWORD       m_dwDecision;
            P3UserPref  m_prefs;

            static      int     destWrapper(void *pEntry, void *pUnused);
            static      int     grantRequest(void *pEntry, void *pUnused);

            OPSRequestEntry(); 
            ~OPSRequestEntry();
            void grantRequest();
            void denyRequest();
            void clearValue();
        };
 
        struct AccessSettings {

            TCHAR       m_rgchDomain[INTERNET_MAX_HOST_NAME_LENGTH];
            TCHAR       m_rgchPath[MAX_PATH];
            FILETIME    m_ftExpire;
            BOOL        m_fExactDomain;
            BOOL        m_fExactPath;
            BYTE        m_rgbStdAllow[16];
            BYTE        m_rgbStdDeny[16];
        };

        typedef AccessSettings *LPACS;

        struct OPSDlgInfo {

            HDPA        m_hdpa;
            BSTR        m_bstrFName;
            TCHAR       m_rgchUsage[1024];
            TCHAR       m_rgchURL[MAX_URL_STRING];
            BOOL        m_fRemember;
            BOOL        m_fAllBlank;

            AccessSettings  *m_pacSettings;
            COpsProfile*    m_pOpsProfile;
            
            OPSDlgInfo() : m_bstrFName(NULL), m_pOpsProfile(NULL)   {}
            ~OPSDlgInfo() { SysFreeString(m_bstrFName); }
        };

        typedef struct OPSDlgInfo *LPOPSDLGINFO;
		
        VARIANT m_vUsage; // a-thkesa to solve Windows BUG:589837. store the usage as a member for the next use.


        BOOL        _IsP3Enabled();
        
        HRESULT     _GetUserPreference(BSTR bstrName, P3UserPref *pusrPref);
        HRESULT     _PutUserPreference(BSTR bstrName, P3UserPref usrPref);

        HRESULT     _ApplyPreferences(URL_COMPONENTS *pucComp, HDPA hdpaReqList);
        HRESULT     _ApplyGlobalSettings(HDPA hdpaReqList);
        HRESULT     _ApplySiteSettings(URL_COMPONENTS *pucComp, HDPA hdpaReqList);
        HRESULT     _ApplyDomainSettings(URL_COMPONENTS *pucComp, HKEY hkey, HDPA hdpaReqList);

        BOOL        _PathMatch(TCHAR *pszRoot, TCHAR *pszPath);
        BOOL        _DomainMatch(TCHAR *pszHostName, TCHAR *pszDomain);
        BOOL        _LegalPath(TCHAR *pszActual, TCHAR *pszReqPath);
        BOOL        _LegalDomain(TCHAR *pszActual, TCHAR *pszReqDomain);

        BOOL        _ReadBitVector(LPCBYTE ucBitVector, DWORD dwIndex);
        VOID        _WriteBitVector(LPBYTE ucBitVector, DWORD dwIndex);

        HRESULT     _GetSiteSettings(URL_COMPONENTS *pucComp, VARIANT vaDomain, VARIANT vaPath, VARIANT vaExpire, AccessSettings *pSettings);
        HRESULT     _UpdateSiteSettings(AccessSettings *pSettings, HDPA hdpaReqList);
        BOOL        _ApplySettings(AccessSettings *pac, URL_COMPONENTS *puc, HDPA hdpaReqList, DWORD *pdwLast);
        BOOL        _ReadSettingsFromRegistry(HKEY hkey, AccessSettings *pac);
        BOOL        _WriteSettingsToRegistry(HKEY hkey, AccessSettings *pac);

        BOOL        _DifferentURL();

        static  HRESULT     _FormatSiteSettings(AccessSettings *pSettings, LPTSTR rgchOut, int cLimit);
        static  HRESULT     _ClearAllSettings(HWND hwin = NULL);
        friend  HRESULT STDAPICALLTYPE ResetProfileSharing(HWND hwin);
    };  // COPSProfile

    friend  HRESULT STDAPICALLTYPE ResetProfileSharing(HWND hwin);
    friend class COpsProfile;
    COpsProfile _profile;
    /************/

#ifdef UNIX
protected:
#endif
    class COmNavigator : public IOmNavigator, public CAutomationStub
    {
    public:
        COmNavigator();
        HRESULT Init(CMimeTypes *pMimeTypes, CPlugins *pPlugins, COpsProfile *pProfile);
        virtual ~COmNavigator() { if(_UserAgent) SysFreeString(_UserAgent); }

        // *** IUnknown members ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAutomationStub::QueryInterface(riid, ppvObj); }
        STDMETHODIMP_(ULONG) AddRef(void)  { return CAutomationStub::AddRef( ); }
        STDMETHODIMP_(ULONG) Release(void)  { return CAutomationStub::Release( ); }

        // *** IDispatch members ***
        STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return CAutomationStub::GetTypeInfoCount(pi); }
        STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo) { return CAutomationStub::GetTypeInfo(it,lcid,pptypeinfo); }
        STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return CAutomationStub::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgDispId); }
        STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr );
        
        // *** IDispatchEx members ***
        STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
            { return CAutomationStub::GetDispID(bstrName, grfdex, pid); }
        STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
            { return CAutomationStub::InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller); }
        STDMETHODIMP DeleteMemberByName(BSTR bstr, DWORD grfdex)
            { return CAutomationStub::DeleteMemberByName(bstr, grfdex); }
        STDMETHODIMP DeleteMemberByDispID(DISPID id)
            { return CAutomationStub::DeleteMemberByDispID(id); }
        STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
            { return CAutomationStub::GetMemberProperties(id, grfdexFetch, pgrfdex); }
        STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName)
            { return CAutomationStub::GetMemberName(id, pbstrName); }
        STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
            { return CAutomationStub::GetNextDispID(grfdex, id, pid); }
        STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk)
            { return CAutomationStub::GetNameSpaceParent(ppunk); }

        // *** IOmNavigator members ***
        STDMETHODIMP get_appCodeName(BSTR* retval);
        STDMETHODIMP get_appName(BSTR* retval);
        STDMETHODIMP get_appVersion(BSTR* retval);
        STDMETHODIMP get_userAgent(BSTR* retval);
        STDMETHODIMP get_cookieEnabled(VARIANT_BOOL* retval);
        STDMETHODIMP javaEnabled(VARIANT_BOOL* enabled);
        STDMETHODIMP taintEnabled(VARIANT_BOOL* enabled);
        STDMETHODIMP get_mimeTypes (IHTMLMimeTypesCollection**);
        STDMETHODIMP get_plugins (IHTMLPluginsCollection**);
        STDMETHODIMP get_opsProfile (IHTMLOpsProfile **ppOpsProfile);
        STDMETHODIMP toString(BSTR * pbstr) ;
        STDMETHODIMP get_cpuClass(BSTR * p);
        STDMETHODIMP get_systemLanguage(BSTR * p);
        STDMETHODIMP get_browserLanguage(BSTR * p);
        STDMETHODIMP get_userLanguage(BSTR * p);
        STDMETHODIMP get_platform(BSTR * p);
        STDMETHODIMP get_appMinorVersion(BSTR * p);
        STDMETHODIMP get_connectionSpeed(long * p);
        STDMETHODIMP get_onLine(VARIANT_BOOL * p);
        STDMETHODIMP get_userProfile (IHTMLOpsProfile **ppOpsProfile) { return get_opsProfile(ppOpsProfile); }

    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _InternalQueryInterface( REFIID riid, void ** const ppvObj );
        virtual HRESULT _GetIDispatchExDelegate( IDispatchEx ** const delegate );

    private:
        HRESULT LoadUserAgent( );
    
        BSTR _UserAgent;
        BOOL _fLoaded;

        CMimeTypes *_pMimeTypes;
        CPlugins   *_pPlugins;
        COpsProfile *_pProfile;
    }; // COmNavigator

    friend class COmNavigator;
    COmNavigator _omnav;


    class COmHistory : public IOmHistory, public CAutomationStub
    {
    public:
    
        COmHistory();
        HRESULT Init( );
        virtual ~COmHistory() {}
        
        
        // *** IUnknown members ***
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) { return CAutomationStub::QueryInterface(riid, ppvObj); }
        STDMETHODIMP_(ULONG) AddRef(void)  { return CAutomationStub::AddRef( ); }
        STDMETHODIMP_(ULONG) Release(void)  { return CAutomationStub::Release( ); }
        
        // *** IDispatch members ***
        STDMETHODIMP GetTypeInfoCount(UINT *pi)  { return CAutomationStub::GetTypeInfoCount(pi); }
        STDMETHODIMP GetTypeInfo(UINT it, LCID lcid, ITypeInfo **pptypeinfo) { return CAutomationStub::GetTypeInfo(it,lcid,pptypeinfo); }
        STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId) { return CAutomationStub::GetIDsOfNames(riid,rgszNames,cNames,lcid,rgDispId); }
        STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr )
            { return CAutomationStub::Invoke(dispid,riid,lcid,wFlags,dispparams,pvarResult,pexcepinfo,puArgErr ); }
        
        // *** IDispatchEx members ***
        STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
            { return CAutomationStub::GetDispID(bstrName, grfdex, pid); }
        STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
            { return CAutomationStub::InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller); }
        STDMETHODIMP DeleteMemberByName(BSTR bstr, DWORD grfdex)
            { return CAutomationStub::DeleteMemberByName(bstr, grfdex); }
        STDMETHODIMP DeleteMemberByDispID(DISPID id)
            { return CAutomationStub::DeleteMemberByDispID(id); }
        STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
            { return CAutomationStub::GetMemberProperties(id, grfdexFetch, pgrfdex); }
        STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName)
            { return CAutomationStub::GetMemberName(id, pbstrName); }
        STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
            { return CAutomationStub::GetNextDispID(grfdex, id, pid); }
        STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk)
            { return CAutomationStub::GetNameSpaceParent(ppunk); }

        // *** IOmHistory members ***
        STDMETHODIMP get_length(short* retval);
        STDMETHODIMP back(VARIANT* pvargdistance);
        STDMETHODIMP forward(VARIANT* pvargdistance);
        STDMETHODIMP go(VARIANT* pvargdistance);
    
    protected:
        // *** CAutomationStub members ***
        virtual HRESULT _InternalQueryInterface( REFIID riid, void ** const ppvObj );
        virtual HRESULT _GetIDispatchExDelegate( IDispatchEx ** const delegate );

    }; // COmHistory
    friend class COmHistory;
    COmHistory _omhist;

private:
    static LONG s_cIEFrameAuto;
};


//  Creates a new window, sets frame name (if appropriate)
HRESULT CreateTargetFrame(LPCOLESTR pszTargetName, LPUNKNOWN *ppunkTargetFrame);
HRESULT GetWindowFromUnknown( IUnknown *pUnk, IHTMLWindow2 ** const pWinOut );
HRESULT _TargetTopLevelWindows(LPTARGETFRAMEPRIV ptgfpThis, LPCOLESTR pszTargetName, DWORD dwFlags, LPUNKNOWN *ppunkTargetFrame);

#endif // _HLFRAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\htmlstr.h ===
/*
 * htmlstr.h
 *
 * HTML string constants
 *
 */

#ifndef _HTMLSTR_H
#define _HTMLSTR_H

#if !defined( WIN16 ) || !defined( __WATCOMC__ )

#ifdef DEFINE_STRING_CONSTANTS

#ifndef UNIX

#define MAKEBSTR(name, count, strdata) \
    extern "C" CDECL const WORD DATA_##name [] = {(count * sizeof(OLECHAR)), 0x00, L##strdata}; \
    extern "C" CDECL BSTR name = (BSTR)& DATA_##name[2];

#else

// IEUNIX : Trying to get same memory layout as above.

struct UNIX_BSTR_FORMAT {
        DWORD cbCount;                                         \
        WCHAR data[] ;                                         \
};

#define MAKEBSTR(name, count, strdata)                         \
    const struct UNIX_BSTR_FORMAT STRUCT_##name = {(count * sizeof(OLECHAR)), L##strdata};  \
    extern "C" CDECL BSTR name = (BSTR) &STRUCT_##name.data;

#endif


#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[] = L##y

#else
#define MAKEBSTR(name, count, strdata) extern "C" CDECL LPCWSTR name

#define STR_GLOBAL(x,y)         extern "C" CDECL const TCHAR x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" CDECL const char x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" CDECL const WCHAR x[]
#endif

#else // !WIN16 || !__WATCOMC__

#ifdef DEFINE_STRING_CONSTANTS
#define MAKEBSTR(name, count, strdata) \
    extern "C" const char CDECL DATA_##name [] = {(count * sizeof(OLECHAR)), 0x00, strdata}; \
    extern "C" BSTR  CDECL name = (BSTR)& DATA_##name[2];


#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[] = TEXT(y)
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[] = y
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[] = y

#else
#define MAKEBSTR(name, count, strdata) extern "C" LPCWSTR CDECL name

#define STR_GLOBAL(x,y)         extern "C" const TCHAR CDECL x[]
#define STR_GLOBAL_ANSI(x,y)    extern "C" const char CDECL x[]
#define STR_GLOBAL_WIDE(x,y)    extern "C" const WCHAR CDECL x[]
#endif

#endif // !WIN16 || !__WATCOMC__


MAKEBSTR(c_bstr_AfterBegin, 10, "AfterBegin");
MAKEBSTR(c_bstr_BeforeEnd,   9, "BeforeEnd");
MAKEBSTR(c_bstr_SRC,        3,  "src");
MAKEBSTR(c_bstr_HREF,       4,  "HREF");
MAKEBSTR(c_bstr_IMG,        3,  "IMG");
MAKEBSTR(c_bstr_BGSOUND,    7,  "BGSOUND");
MAKEBSTR(c_bstr_BASE,       4,  "BASE");
MAKEBSTR(c_bstr_Word,       4,  "Word");
MAKEBSTR(c_bstr_Character,  9,  "Character");
MAKEBSTR(c_bstr_StartToEnd, 10, "StartToEnd");
MAKEBSTR(c_bstr_EndToEnd,   8,  "EndToEnd");
MAKEBSTR(c_bstr_StartToStart,   12,  "StartToStart");
MAKEBSTR(c_bstr_EndToStart, 10, "EndToStart");
MAKEBSTR(c_bstr_ANCHOR, 1, "A");
MAKEBSTR(c_bstr_BLOCKQUOTE,10,  "BLOCKQUOTE");
MAKEBSTR(c_bstr_BACKGROUND,10,  "background");
MAKEBSTR(c_bstr_BODY,      4,   "BODY");
MAKEBSTR(c_bstr_TABLE,     5,   "TABLE");
MAKEBSTR(c_bstr_TD,        2,   "TD");
MAKEBSTR(c_bstr_TH,        2,   "TH");
MAKEBSTR(c_bstr_FRAME,     5,   "FRAME");
MAKEBSTR(c_bstr_IFRAME,    6,   "IFRAME");
MAKEBSTR(c_bstr_FRAMESET,  8,   "FRAMESET");
MAKEBSTR(c_bstr_LINK,      4,   "LINK");
MAKEBSTR(c_bstr_REL,       3,   "REL");
MAKEBSTR(c_bstr_STYLESHEET, 10, "stylesheet");
MAKEBSTR(c_bstr_DYNSRC,    6,   "DYNSRC");
MAKEBSTR(c_bstr_INPUT,     5,   "INPUT" );
MAKEBSTR(c_bstr_AREA,     4,   "AREA" );
MAKEBSTR(c_bstr_ON,     2,   "on" );
MAKEBSTR(c_bstr_SCRIPT, 6,  "SCRIPT" );
MAKEBSTR(c_bstr_EMPTY,  0, "");
MAKEBSTR(c_bstr_DesignOff, 3, "off" );
MAKEBSTR(c_bstr_BLANK, 11, "about:blank");
#endif //_HTMLSTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\htregmng.h ===
/*
 * Registry Association Management
 *
 * HTREGMNG.H
 *
 * Copyright (c) 1995 Microsoft Inc.
 *
 */

#ifndef HTREGMNG_H
#define HTREGMNG_H

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Registry Management Structures
 *
 * We need a way to specify a set of registry entries to
 * represent an association.   We can then test and
 * set the registry appropriately to restore associations
 * as needed
 *
 */

typedef enum 
{ 
    RC_ADD, 
    RC_RUNDLL,
    RC_DEL,              // Remove key
    RC_CALLBACK
} REGCMD;


// Flags for RegEntry

#define REF_NORMAL      0x00000000      // Required and forcefully set
#define REF_NOTNEEDED   0x00000001      // Ignored during checks
#define REF_IFEMPTY     0x00000002      // Set only if value/key is empty
#define REF_DONTINTRUDE 0x00000004      // Don't intrude at setup time
#define REF_NUKE        0x00000008      // Remove a key, regardless of the subkeys/values
#define REF_PRUNE       0x00000010      // Walk up this path and remove empty keys
#define REF_EDITFLAGS   0x00000020      // Remove edit flags only if the rest of the tree is empty


// NOTE: these structures are deliberately CHAR, not TCHAR, so we don't
// have to mess with the TEXT macro in all the tables.

typedef struct _RegEntry {
    REGCMD  regcmd;         // Special Handling
    DWORD   dwFlags;        // REF_* 
    HKEY    hkeyRoot;       // Root key
    LPCSTR  pszKey;         // Key Name
    LPCSTR  pszValName;     // Value Name
    DWORD   dwType;         // Value Type
    union 
    {
        LPARAM  lParam;     // lParam
        DWORD   dwSize;     // Value Size (in bytes)
    }DUMMYUNIONNAME;
    VOID const * pvValue;   // Value
} RegEntry;

typedef RegEntry RegList[];

typedef struct _RegSet {
    DWORD       cre;       // Count of entries
    const RegEntry * pre;
} RegSet;


#define IEA_NORMAL          0x00000001 // Only install IE assoc. if IE is currently owner.
#define IEA_FORCEIE         0x00000002 // Force IE to take over associations

HRESULT InstallIEAssociations(DWORD dwFlags);   // IEA_* flags

HRESULT UninstallPlatformRegItems(BOOL bIntegrated);
void    UninstallCurrentPlatformRegItems();
BOOL    IsCheckAssociationsOn();
void    SetCheckAssociations( BOOL );
BOOL    GetIEPath(LPSTR szPath, DWORD cch);
BOOL    IsIEDefaultBrowser(void);
BOOL IsIEDefaultBrowserQuick(void);
HRESULT ResetWebSettings(HWND hwnd, BOOL *pfChangedHomePage);

extern const TCHAR c_szCLSID[];

#ifdef __cplusplus
};
#endif

#endif /* HTREGMNG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\htregmng.cpp ===
/*
 * Registry Management
 *
 * HTREGMNG.C
 *
 * Copyright (c) 1995 Microsoft Corporation
 *
 */

#include "priv.h"
#include "htregmng.h"
#include "resource.h"
#include "regapix.h"
#include <filetype.h>

#include <advpub.h>
#include <mluisupp.h>

//  This file contains the auto-registration code, which smartly performs 
//  the install/uninstall of registry keys and values.  While an inf file
//  is sufficient most of the time, IE needs to be smart about what
//  sort of values to set, based upon certain conditions.  An inf file
//  does not offer this depth of support.  Additionally, IE requires 
//  code to be run when it detects that it is not the default browser,
//  so it can make it the default browser.  Any settings that determine
//  this should be placed here, rather than the inf file.
//
//  This code is table driven.  The idea is simple.  You have a RegSet
//  which is the "Registry Set".  The Registry Set indicates the 
//  root key and contains a list of RegEntries.  Each RegEntry 
//  specifies a command, flags, key and value names, and optional data
//  that provides the essential info to set/change/delete a registry
//  value or key.
//
//  
// NOTE: NOTE: NOTE: NOTE: NOTE: NOTE: NOTE: 
//-------------------------------------------
// Any new Icon check that uses HTReg_UrlIconProc that gets added
// to any of the Assoc arrays and is REQUIRED for Default Browser check to
// succeed has to be added to the c_rlAssoc_FixIcon[] array also.
//


// Make the tables more compact
#define HKCR    HKEY_CLASSES_ROOT
#define HKLM    HKEY_LOCAL_MACHINE
#define HKCU    HKEY_CURRENT_USER


#define IDEFICON_STD    0
#define IDEFICON_NEWS   1
#define IDEFICON_MAIL   2

#ifndef UNIX

#define IEXPLORE_APP    "IExplore"
#define IEXPLORE_EXE    "iexplore.exe"
#define EXPLORER_EXE    "explorer.exe"
#define RUNDLL_CMD_FMT  "rundll32.exe %s"

#else

#define IEXPLORE_APP    "iexplorer"
#define IEXPLORE_EXE    "iexplorer"
#define EXPLORER_EXE    "explorer"
#define RUNDLL_CMD_FMT  "rundll32 %s"

#endif

BOOL    InstallRegSet(const RegSet *prs, BOOL bDontIntrude);

#ifndef UNIX
const CHAR  c_szIexploreKey[]         = "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE";
#else
const CHAR  c_szIexploreKey[]         = "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORER";
#endif

#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Return a string path composed of hkey\pszKey\pszValueName.

Returns: 
Cond:    --
*/
LPTSTR
Dbg_RegStr(
    IN const RegEntry * pre,          
    IN LPTSTR pszBuf)
{
    TCHAR szRoot[5];
    TCHAR szTempKey[MAXIMUM_SUB_KEY_LENGTH];
    TCHAR szTempValue[MAXIMUM_VALUE_NAME_LENGTH];

    ASSERT(pre);
    ASSERT(pszBuf);

    if (HKEY_CLASSES_ROOT == pre->hkeyRoot)
        {
        StrCpyN(szRoot, TEXT("HKCR"), ARRAYSIZE(szRoot));
        }
    else if (HKEY_CURRENT_USER == pre->hkeyRoot)
        {
        StrCpyN(szRoot, TEXT("HKCU"), ARRAYSIZE(szRoot));
        }
    else if (HKEY_LOCAL_MACHINE == pre->hkeyRoot)
        {
        StrCpyN(szRoot, TEXT("HKLM"), ARRAYSIZE(szRoot));
        }
    else
        {
        StrCpyN(szRoot, TEXT("????"), ARRAYSIZE(szRoot));
        ASSERT(0);
        }

    AnsiToTChar(pre->pszKey, szTempKey, ARRAYSIZE(szTempKey));

    szTempValue[0] = TEXT('\0');
    if (pre->pszValName)
        AnsiToTChar(pre->pszValName, szTempValue, ARRAYSIZE(szTempValue));

    ASSERT(lstrlen(pszBuf) < MAX_PATH);
    wnsprintf(pszBuf, MAX_PATH, TEXT("%s\\%hs\\%hs"), szRoot, szTempKey, szTempValue);

    return pszBuf;
}

#else

#define Dbg_RegStr(x, y)    0

#endif // DEBUG



/*----------------------------------------------------------
Purpose: Queries the registry for the location of the path
         of Internet Explorer and returns it in pszBuf.

Returns: TRUE on success
         FALSE if path cannot be determined

Cond:    --
*/

BOOL
GetIEPath2(
    OUT LPSTR pszBuf,
    IN  DWORD cchBuf,
    IN  BOOL  bInsertQuotes)
{
    BOOL bRet = FALSE;
    HKEY hkey;

    *pszBuf = '\0';

    // Get the path of Internet Explorer 
    if (NO_ERROR != RegOpenKeyExA(HKEY_LOCAL_MACHINE, c_szIexploreKey, 0, KEY_READ, &hkey))  
    {
#ifndef UNIX
        TraceMsg(TF_ERROR, "InstallRegSet(): RegOpenKey( %s ) Failed", c_szIexploreKey) ;
#endif
    }
    else
    {
        DWORD cbBrowser;
        DWORD dwType;

        if (bInsertQuotes)
            StrCatBuffA(pszBuf, "\"", cchBuf);

        cbBrowser = CbFromCchA(cchBuf - lstrlenA(" -nohome") - 4);
        if (NO_ERROR != SHQueryValueExA(hkey, "", NULL, &dwType,
                                         (LPBYTE)&pszBuf[bInsertQuotes?1:0], &cbBrowser))
        {
            TraceMsg(TF_ERROR, "InstallRegSet(): RegQueryValueEx() for Iexplore path failed");
        }
        else
        {
            bRet = TRUE;
        }

        if (bInsertQuotes)
            StrCatBuffA(pszBuf, "\"", cchBuf);

        RegCloseKey(hkey);
    }

    return bRet;
}

BOOL
GetIEPath(
    OUT LPSTR pszBuf,
    IN  DWORD cchBuf)
{
    return GetIEPath2(pszBuf, cchBuf, TRUE);
}

// Callback messages

#define RSCB_QUERY          1
#define RSCB_INSTALL        2

typedef BOOL (CALLBACK* RSPECPROC)(UINT nMsg, const RegEntry * pre, LPVOID pvData, DWORD dwData);


// Win9x to NT5 migration generated file.
#define MIGICONS    "migicons.exe"


/*----------------------------------------------------------
Purpose: This callback sets the default icon to point to a
         given index in url.dll.

Returns: varies
Cond:    --
*/
BOOL
CALLBACK
HTReg_UrlIconProc(
    IN UINT       nMsg,
    IN const RegEntry * pre,
    IN LPVOID     pvData,       OPTIONAL
    IN DWORD      dwData)
{
    BOOL bRet = TRUE;
    CHAR sz[MAX_PATH + 20];    // Need a bit extra
    LPCSTR pszPath = (LPCSTR) pvData;
    int cch;
    DWORD dwType;  //local type.
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )
    
    ASSERT(RSCB_QUERY == nMsg && pvData ||
           RSCB_INSTALL == nMsg && !pvData);

    if (!g_fRunningOnNT) {
        ASSERT(REG_EXPAND_SZ == pre->dwType);
        dwType = REG_SZ;
    } else
        dwType = (DWORD)pre->dwType;        
    
    if (dwType == REG_EXPAND_SZ) 
        StrCpyNA (sz, "%SystemRoot%\\system32", ARRAYSIZE(sz));
    else
        GetSystemDirectoryA(sz, ARRAYSIZE(sz));
    cch = lstrlenA(sz);

    // We still have to use url.dll as the source of the internet shortcut
    // icons because the icons need to still be valid on uninstall.
    wnsprintfA(&sz[cch], ARRAYSIZE(sz) - cch, "\\url.dll,%d", (int)pre->DUMMYUNION_MEMBER(lParam));

    switch (nMsg)
    {
    case RSCB_QUERY:
        if (0 != StrCmpNIA(sz, pszPath, dwData / SIZEOF(CHAR)) &&
            0 != StrCmpIA(PathFindFileNameA(sz), PathFindFileNameA(pszPath)))  
        {
            // Failed the Url.Dll test. Check if this is NT5. In that case
            // maybe the icons are in migicons.exe (Win9x to NT5 upgrade).
            if (g_bRunOnNT5 && StrStrIA(pszPath,MIGICONS)!= NULL)
            {    // NT5 and 'migicons.exe' => upgrade. Set global to fix this.
                g_bNT5Upgrade = TRUE;
            }
            else
            {
                TraceMsg(TF_REGCHECK, "IsRegSetInstalled: %s is %hs, expecting %hs", Dbg_RegStr(pre, szDbg), pszPath, sz);
                bRet = FALSE;
            }
        }
        break;

    case RSCB_INSTALL:
        if (NO_ERROR != SHSetValueA(pre->hkeyRoot, pre->pszKey,
                                    pre->pszValName, dwType,
                                    sz, CbFromCchA(lstrlenA(sz) + 1)))
        {
            TraceMsg(TF_ERROR, "InstallRegSet(): SHSetValue(%s) Failed", Dbg_RegStr(pre, szDbg));
            bRet = FALSE;
        }
        else
        {
            DEBUG_CODE( TraceMsg(TF_REGCHECK, "Setting %s", Dbg_RegStr(pre, szDbg)); )
        }
        break;
    }
    return bRet;
}

/*----------------------------------------------------------
Purpose: This callback sets the default icon to point to a
         given index in iexplore.exe
Returns: varies
Cond:    --
*/
BOOL
CALLBACK
HTReg_IEIconProc(
    IN UINT       nMsg,
    IN const RegEntry * pre,
    IN LPVOID     pvData,       OPTIONAL
    IN DWORD      dwData)
{
    BOOL bRet = TRUE;
    CHAR sz[MAX_PATH + 20];    // Need a bit extra
    LPCSTR pszPath = (LPCSTR) pvData;
    int cch;
    DWORD dwType;  //local type.
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )
    
    ASSERT(RSCB_QUERY == nMsg && pvData ||
           RSCB_INSTALL == nMsg && !pvData);

    if (!g_fRunningOnNT) {
        // Sanity check that we don't coerce to REG_SZ wrongfully.
        // If you hit this assert, it means the table entry has the
        // wrong type in it.
        ASSERT(REG_EXPAND_SZ == pre->dwType || REG_SZ == pre->dwType);
        dwType = REG_SZ;
    } else
        dwType = (DWORD)pre->dwType;        
    
    if (!GetIEPath2(sz, SIZECHARS(sz), FALSE))
        return FALSE;
        
    cch = lstrlenA(sz);
    wnsprintfA(&sz[cch], ARRAYSIZE(sz) - cch, ",%d", (int)pre->DUMMYUNION_MEMBER(lParam));

    switch (nMsg)
    {
    case RSCB_QUERY:
        if (0 != StrCmpNIA(sz, pszPath, dwData / SIZEOF(CHAR)) &&
            0 != StrCmpA(PathFindFileNameA(sz), PathFindFileNameA(pszPath)))  
        {
            TraceMsg(TF_REGCHECK, "IsRegSetInstalled: %s is %hs, expecting %hs", Dbg_RegStr(pre, szDbg), pszPath, sz);
            bRet = FALSE;
        }
        break;

    case RSCB_INSTALL:
        if (NO_ERROR != SHSetValueA(pre->hkeyRoot, pre->pszKey,
                                    pre->pszValName, dwType,
                                    sz, CbFromCchA(lstrlenA(sz) + 1)))
        {
            TraceMsg(TF_ERROR, "InstallRegSet(): SHSetValue(%s) Failed", Dbg_RegStr(pre, szDbg));
            bRet = FALSE;
        }
        else
        {
            DEBUG_CODE( TraceMsg(TF_REGCHECK, "Setting %s", Dbg_RegStr(pre, szDbg)); )
        }
        break;
    }
    return bRet;
}


/*----------------------------------------------------------
Purpose: This callback sets the IExplore path.

Returns: varies
Cond:    --
*/
BOOL
CALLBACK
HTReg_IEPathProc(
    IN UINT       nMsg,
    IN const RegEntry * pre,
    IN LPVOID     pvData,       OPTIONAL
    IN DWORD      dwData)
{
    BOOL bRet = TRUE;
    CHAR sz[MAX_PATH + 20];    // Need a bit extra
    CHAR szOther[MAX_PATH + 20];    // Need a bit extra
    LPCSTR pszPath = (LPCSTR) pvData;
    int cch;
    DWORD dwType;
    
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )
    
    ASSERT(RSCB_QUERY == nMsg && pvData ||
           RSCB_INSTALL == nMsg && !pvData);
    
    ASSERT(REG_EXPAND_SZ == pre->dwType || REG_SZ == pre->dwType);
    
    if (!g_fRunningOnNT)
    {
        // Expand string is not supported on Win95
        dwType = REG_SZ;
    }
    else 
    {
        dwType = pre->dwType;        
    }
    
    if (GetIEPath(sz, SIZECHARS(sz))) {
        // sz contains the path as listed in AppPaths\IExplore.
        // NOTE NOTE: GetIEPath() uses the default value which has no
        // terminating ';'. Hence this check is not needed. Anyway, do it and
        // then convert to other form.
        cch = lstrlenA(sz) - 1;

        if (*sz && sz[cch] == ';')
            sz[cch] = '\0';

        // Convert this to LFN or SFN as the case may be.
        GetPathOtherFormA(sz, szOther, ARRAYSIZE(szOther));

        if (pre->DUMMYUNION_MEMBER(lParam))
        {
            StrCatBuffA(sz, (LPSTR)pre->DUMMYUNION_MEMBER(lParam), ARRAYSIZE(sz));
            StrCatBuffA(szOther, (LPSTR)pre->DUMMYUNION_MEMBER(lParam), ARRAYSIZE(szOther));
        }

        switch (nMsg)
        {
        case RSCB_QUERY:
            if ((0 != StrCmpNIA(pszPath, sz, dwData / SIZEOF(CHAR)))
                && (0 != StrCmpNIA(pszPath, szOther, dwData / SIZEOF(CHAR))))  
            {
                TraceMsg(TF_REGCHECK, "IsRegSetInstalled: %s string is \"%hs\", expecting \"%hs\"", Dbg_RegStr(pre, szDbg), pszPath, sz);
                bRet = FALSE;
            }
            break;

        case RSCB_INSTALL:
            if (NO_ERROR != SHSetValueA(pre->hkeyRoot, pre->pszKey,
                                        pre->pszValName, dwType,
                                        sz, CbFromCchA(lstrlenA(sz) + 1)))
            {
                TraceMsg(TF_ERROR, "InstallRegSet(): SHSetValue(%hs) Failed", pre->pszValName);
                bRet = FALSE;
            }
            else
            {
                DEBUG_CODE( TraceMsg(TF_REGCHECK, "Setting %s", Dbg_RegStr(pre, szDbg)); )
            }
            break;
        }
    }
    
    return bRet;
}

/*----------------------------------------------------------
Purpose: This callback checks for the existence of the string
         value "Exchange" at HKLM\Software\Microsoft.  If it
         exists, the value is copied into the default value
         of HKLM\Software\Clients\Mail\Exchange\shell\open\command.

         This is for Athena.  It only happens when setup is run, 
         not when the browser checks to see if it is the default.

Returns: varies
Cond:    --
*/
BOOL
CALLBACK
HTReg_ExchangeProc(
    IN UINT       nMsg,
    IN const RegEntry * pre,
    IN LPVOID     pvData,
    IN DWORD      dwData)
{
    TCHAR sz[MAX_PATH+2];  // +2 because we may need to wrap the path in quotes.
    DWORD cbSize;
    
    switch (nMsg)
    {
    case RSCB_QUERY:
        // We shouldn't be called for this one
        ASSERT(0);      
        break;

    case RSCB_INSTALL:
        // Does the Exchange value exist at "HKLM\Software\Microsoft"?  
        cbSize = sizeof(sz);
        if (NO_ERROR == SHGetValue(HKEY_LOCAL_MACHINE, 
            TEXT("Software\\Microsoft"), TEXT("Exchange"), NULL, sz, &cbSize))
        {
            // Yes; copy it to HKLM\Software\Clients\Mail\Exchange\shell\open\command
            TCHAR szT[MAX_PATH+2];

            // Wrap the path in quotes.  Don't wrap any args though!
            StrCpyN(szT, sz, ARRAYSIZE(szT));
            PathProcessCommand(szT, sz, ARRAYSIZE(szT), PPCF_ADDQUOTES|PPCF_ADDARGUMENTS);

            // Set the size again
            cbSize = CbFromCch(lstrlen(sz)+1);

            SHSetValue(HKEY_LOCAL_MACHINE, 
                TEXT("Software\\Clients\\Mail\\Exchange\\shell\\open\\command"),
                TEXT(""), REG_SZ, sz, cbSize);

            TraceMsg(TF_REGCHECK, "Copying \"%s\" to HKLM\\Software\\Clients\\Mail\\Exchange", sz);

            // Set any other settings in this condition too?
            if (pre->DUMMYUNION_MEMBER(lParam))
                InstallRegSet((const RegSet *)pre->DUMMYUNION_MEMBER(lParam), TRUE);

            // In OSR2 installs, the mailto handler will get out of
            // sync with the actual default mail client.  (Athena installs
            // itself as the default mail client, but exchange remains 
            // the mailto: handler.)  In this case, if exchange is the
            // mailto: handler, change the default mail client to be
            // exchange.

            // Is Exchange the mailto handler?
            cbSize = SIZEOF(sz);
            if (NO_ERROR == SHGetValue(HKEY_CLASSES_ROOT, TEXT("mailto\\shell\\open\\command"),
                                       TEXT(""), NULL, sz, &cbSize) &&
                StrStrI(sz, TEXT("url.dll,MailToProtocolHandler")))
            {
                // Yes; make it be the default mail client too
                SHSetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Clients\\Mail"),
                           TEXT(""), REG_SZ, TEXT("Exchange"), sizeof(TEXT("Exchange")));

                TraceMsg(TF_REGCHECK, "Setting Exchange to be the default mail client.");
            }
        }
        break;
    }
    return TRUE;
}


/*----------------------------------------------------------
Purpose: Uninstall certain keys, as specified by pre->pszKey.

         We do not uninstall a key if the class\shell\open\command
         does not have iexplore.exe.

         If someone else registered themselves to add more
         verbs under class\shell (other than open) or class\shellex,
         then we remove everything but their keys.

Returns: varies
Cond:    --
*/
BOOL
CALLBACK
HTReg_UninstallProc(
    IN UINT       nMsg,
    IN const RegEntry * pre,
    IN LPVOID     pvData,
    IN DWORD      dwData)
{
    TCHAR szKey[MAX_PATH];
    TCHAR sz[MAX_PATH + 20];        // add some padding for arguments
    DWORD cbSize;

    switch (nMsg)
    {
    case RSCB_QUERY:
        // We shouldn't be called for this one
        ASSERT(0);      
        break;

    case RSCB_INSTALL:
        ASSERT(pre->pszKey);

        // Does the shell\open\command value have a microsoft browser?
        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%hs\\shell\\open\\command"), pre->pszKey);

        cbSize = sizeof(sz);
        if (NO_ERROR == SHGetValue(pre->hkeyRoot, szKey, TEXT(""),
                                   NULL, sz, &cbSize) &&
            (StrStrI(sz, TEXT(IEXPLORE_EXE)) || StrStrI(sz, TEXT(EXPLORER_EXE))))
        {
            // Yes; proceed to prune this key of all of our values
            TraceMsg(TF_REGCHECK, "Pruning HKCR\\%hs", pre->pszKey);

            ASSERT(pre->DUMMYUNION_MEMBER(lParam));

            InstallRegSet((const RegSet *)pre->DUMMYUNION_MEMBER(lParam), FALSE);
        } 
        break;
    }
    return TRUE;
}


// NOTE: these are ANSI strings by design.

const DWORD c_dwEditFlags2            = FTA_Show;
const CHAR  c_szTelnetHandler[]       = "url.dll,TelnetProtocolHandler %l";
const CHAR  c_szMailToHandler[]       = "url.dll,MailToProtocolHandler %l";
const CHAR  c_szNewsHandler[]         = "url.dll,NewsProtocolHandler %l";
const CHAR  c_szFileHandler[]         = "url.dll,FileProtocolHandler %l";
const CHAR  c_szOpenURL[]             = "url.dll,OpenURL %l";
const CHAR  c_szOpenURLNash[]         = "shdocvw.dll,OpenURL %l";
const CHAR  c_szURL[]                 = "url.dll";
const CHAR  c_szShdocvw[]             = "shdocvw.dll";
const CHAR  c_szCheckAssnSwitch[]     = "Software\\Microsoft\\Internet Explorer\\Main";
const CHAR  c_szDDE_Default[]         = "\"%1\",,-1,0,,,,";
const CHAR  c_szDDE_FileDefault[]     = "\"file://%1\",,-1,,,,,";


// Note (scotth): a lot of the strings below have substrings that 
//  are repeated over and over and over again.  Should add some 
//  smarter RC_ values that will concatenate the common strings
//  together to save data space.

const CHAR c_szHTTP[]                = "http";
const CHAR c_szHTTPDefIcon[]         = "http\\DefaultIcon";
const CHAR c_szHTTPOpenCmd[]         = "http\\shell\\open\\command";
const CHAR c_szHTTPDdeexec[]         = "http\\shell\\open\\ddeexec";
const CHAR c_szHTTPDdeTopic[]        = "http\\shell\\open\\ddeexec\\Topic";
const CHAR c_szHTTPDdeApp[]          = "http\\shell\\open\\ddeexec\\Application";

const CHAR c_szHTTPS[]               = "https";
const CHAR c_szHTTPSDefIcon[]        = "https\\DefaultIcon";
const CHAR c_szHTTPSOpenCmd[]        = "https\\shell\\open\\command";
const CHAR c_szHTTPSDdeexec[]        = "https\\shell\\open\\ddeexec";
const CHAR c_szHTTPSDdeTopic[]       = "https\\shell\\open\\ddeexec\\Topic";
const CHAR c_szHTTPSDdeApp[]         = "https\\shell\\open\\ddeexec\\Application";

const CHAR c_szFTP[]                 = "ftp";
const CHAR c_szFTPDefIcon[]          = "ftp\\DefaultIcon";
const CHAR c_szFTPOpenCmd[]          = "ftp\\shell\\open\\command";
const CHAR c_szFTPDdeexec[]          = "ftp\\shell\\open\\ddeexec";
const CHAR c_szFTPDdeTopic[]         = "ftp\\shell\\open\\ddeexec\\Topic";
const CHAR c_szFTPDdeApp[]           = "ftp\\shell\\open\\ddeexec\\Application";
const CHAR c_szFTPDdeifExec[]        = "ftp\\shell\\open\\ddeexec\\ifExec";

const CHAR c_szGOPHER[]              = "gopher";
const CHAR c_szGOPHERDefIcon[]       = "gopher\\DefaultIcon";
const CHAR c_szGOPHEROpenCmd[]       = "gopher\\shell\\open\\command";
const CHAR c_szGOPHERDdeexec[]       = "gopher\\shell\\open\\ddeexec";
const CHAR c_szGOPHERDdeTopic[]      = "gopher\\shell\\open\\ddeexec\\Topic";
const CHAR c_szGOPHERDdeApp[]        = "gopher\\shell\\open\\ddeexec\\Application";

const CHAR c_szMailTo[]              = "mailto";
const CHAR c_szMailToDefIcon[]       = "mailto\\DefaultIcon";
const CHAR c_szMailToOpenCmd[]       = "mailto\\shell\\open\\command";

const CHAR c_szTelnet[]              = "telnet";
const CHAR c_szTelnetDefIcon[]       = "telnet\\DefaultIcon";
const CHAR c_szTelnetOpenCmd[]       = "telnet\\shell\\open\\command";

const CHAR c_szRLogin[]              = "rlogin";
const CHAR c_szRLoginDefIcon[]       = "rlogin\\DefaultIcon";
const CHAR c_szRLoginOpenCmd[]       = "rlogin\\shell\\open\\command";

const CHAR c_szTN3270[]              = "tn3270";
const CHAR c_szTN3270DefIcon[]       = "tn3270\\DefaultIcon";
const CHAR c_szTN3270OpenCmd[]       = "tn3270\\shell\\open\\command";

const CHAR c_szNews[]                = "news";
const CHAR c_szNewsDefIcon[]         = "news\\DefaultIcon";
const CHAR c_szNewsOpenCmd[]         = "news\\shell\\open\\command";

const CHAR c_szFile[]                = "file";
const CHAR c_szFileDefIcon[]         = "file\\DefaultIcon";
const CHAR c_szFileOpenCmd[]         = "file\\shell\\open\\command";

const CHAR c_szHTMDefIcon[]          = "htmlfile\\DefaultIcon";
const CHAR c_szHTMShell[]            = "htmlfile\\shell";
const CHAR c_szHTMOpen[]             = "htmlfile\\shell\\open";
const CHAR c_szHTMOpenCmd[]          = "htmlfile\\shell\\open\\command";
const CHAR c_szHTMOpenDdeexec[]      = "htmlfile\\shell\\open\\ddeexec";
const CHAR c_szHTMOpenDdeTopic[]     = "htmlfile\\shell\\open\\ddeexec\\Topic";
const CHAR c_szHTMOpenDdeApp[]       = "htmlfile\\shell\\open\\ddeexec\\Application";

const CHAR c_szMHTMDefIcon[]         = "mhtmlfile\\DefaultIcon";
const CHAR c_szMHTMShell[]           = "mhtmlfile\\shell";
const CHAR c_szMHTMOpen[]            = "mhtmlfile\\shell\\open";
const CHAR c_szMHTMOpenCmd[]         = "mhtmlfile\\shell\\open\\command";
const CHAR c_szMHTMOpenDdeexec[]     = "mhtmlfile\\shell\\open\\ddeexec";
const CHAR c_szMHTMOpenDdeTopic[]    = "mhtmlfile\\shell\\open\\ddeexec\\Topic";
const CHAR c_szMHTMOpenDdeApp[]      = "mhtmlfile\\shell\\open\\ddeexec\\Application";

const CHAR c_szOpenNew[]             = "opennew";
const CHAR c_szHTMOpenNew[]          = "htmlfile\\shell\\opennew";
const CHAR c_szHTMOpenNewCmd[]       = "htmlfile\\shell\\opennew\\command";
const CHAR c_szHTMOpenNewDdeexec[]   = "htmlfile\\shell\\opennew\\ddeexec";
const CHAR c_szHTMOpenNewDdeIfExec[] = "htmlfile\\shell\\opennew\\ddeexec\\IfExec";
const CHAR c_szHTMOpenNewDdeTopic[]  = "htmlfile\\shell\\opennew\\ddeexec\\Topic";
const CHAR c_szHTMOpenNewDdeApp[]    = "htmlfile\\shell\\opennew\\ddeexec\\Application";

const CHAR c_szMHTMOpenNew[]          = "mhtmlfile\\shell\\opennew";
const CHAR c_szMHTMOpenNewCmd[]       = "mhtmlfile\\shell\\opennew\\command";
const CHAR c_szMHTMOpenNewDdeexec[]   = "mhtmlfile\\shell\\opennew\\ddeexec";
const CHAR c_szMHTMOpenNewDdeIfExec[] = "mhtmlfile\\shell\\opennew\\ddeexec\\IfExec";
const CHAR c_szMHTMOpenNewDdeTopic[]  = "mhtmlfile\\shell\\opennew\\ddeexec\\Topic";
const CHAR c_szMHTMOpenNewDdeApp[]    = "mhtmlfile\\shell\\opennew\\ddeexec\\Application";

const CHAR c_szIntShcut[]            = "InternetShortcut";
const CHAR c_szIntShcutDefIcon[]     = "InternetShortcut\\DefaultIcon";
const CHAR c_szIntShcutCLSID[]       = "InternetShortcut\\CLSID";
const CHAR c_szIntShcutOpen[]        = "InternetShortcut\\shell\\open";
const CHAR c_szIntShcutOpenCmd[]     = "InternetShortcut\\shell\\open\\command";
const CHAR c_szIntShcutIconHandler[] = "InternetShortcut\\shellex\\IconHandler";
const CHAR c_szIntShcutPrshtHandler[]= "InternetShortcut\\shellex\\PropertySheetHandlers\\{FBF23B40-E3F0-101B-8488-00AA003E56F8}";
const CHAR c_szIntShcutPropHandler[] = "InternetShortcut\\shellex\\PropertyHandler";
const CHAR c_szIntShcutCMHandler[]   = "InternetShortcut\\shellex\\ContextMenuHandlers\\{FBF23B40-E3F0-101B-8488-00AA003E56F8}";

const CHAR c_szCLSIDCmdFile[]       = "{57651662-CE3E-11D0-8D77-00C04FC99D61}";
const CHAR c_szCLSIDIntshcut[]      = "{FBF23B40-E3F0-101B-8488-00AA003E56F8}";
const CHAR c_szCLSIDURLExecHook[]   = "{AEB6717E-7E19-11d0-97EE-00C04FD91972}";

const CHAR c_szIntshcutInproc[]      = "CLSID\\{FBF23B40-E3F0-101B-8488-00AA003E56F8}\\InProcServer32";
const CHAR c_szIEFrameAuto[]         = "CLSID\\{0002DF01-0000-0000-C000-000000000046}\\LocalServer32";
const CHAR c_szIENameSpaceOpen[]     = "CLSID\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}\\shell\\open\\command";
const CHAR c_szCLSIDURLRoot[]        = "CLSID\\{3DC7A020-0ACD-11CF-A9BB-00AA004AE837}";
const CHAR c_szIntshcutMayChange[]   = "CLSID\\{FBF23B40-E3F0-101B-8488-00AA003E56F8}\\shellex\\MayChangeDefaultMenu";

// 
// General associations shared across browser-only and full-shell
//

const RegEntry c_rlAssoc[] = {
    // HTTP
    { RC_ADD,      REF_NOTNEEDED, HKCR, c_szHTTP, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_HTTPNAME) },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szHTTP, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szHTTP, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_NOTNEEDED
                   |REF_DONTINTRUDE, HKCR, c_szHTTPDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },

    // HTTPS
    { RC_ADD,      REF_NOTNEEDED, HKCR, c_szHTTPS, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_HTTPSNAME) },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szHTTPS, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szHTTPS, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_NOTNEEDED|REF_DONTINTRUDE, HKCR, c_szHTTPSDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },

    // FTP
    { RC_ADD,      REF_NOTNEEDED, HKCR, c_szFTP, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_FTPNAME) },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szFTP, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szFTP, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_NOTNEEDED|REF_DONTINTRUDE, HKCR, c_szFTPDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },

    // Gopher
    { RC_ADD,      REF_NOTNEEDED, HKCR, c_szGOPHER, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_GOPHERNAME) },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szGOPHER, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_NORMAL,    HKCR, c_szGOPHER, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_NOTNEEDED|REF_DONTINTRUDE, HKCR, c_szGOPHERDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },

    // Telnet
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szTelnet, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_TELNETNAME) },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szTelnet, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szTelnet, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_IFEMPTY,   HKCR, c_szTelnetDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },
    { RC_RUNDLL,   REF_IFEMPTY,   HKCR, c_szTelnetOpenCmd, "", REG_SZ, sizeof(c_szTelnetHandler), c_szTelnetHandler },

    // RLogin
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szRLogin, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_RLOGINNAME) },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szRLogin, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szRLogin, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_IFEMPTY,   HKCR, c_szRLoginDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },
    { RC_RUNDLL,   REF_IFEMPTY,   HKCR, c_szRLoginOpenCmd, "", REG_SZ, sizeof(c_szTelnetHandler), c_szTelnetHandler },

    // TN3270
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szTN3270, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_TN3270NAME) },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szTN3270, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szTN3270, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_IFEMPTY,   HKCR, c_szTN3270DefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },
    { RC_RUNDLL,   REF_IFEMPTY,   HKCR, c_szTN3270OpenCmd, "", REG_SZ, sizeof(c_szTelnetHandler), c_szTelnetHandler },

    // Mailto protocol
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szMailTo, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_MAILTONAME) },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szMailTo, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szMailTo, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_IFEMPTY,   HKCR, c_szMailToDefIcon, "", REG_EXPAND_SZ, IDEFICON_MAIL, HTReg_UrlIconProc },
    { RC_RUNDLL,   REF_IFEMPTY,   HKCR, c_szMailToOpenCmd, "", REG_SZ, sizeof(c_szMailToHandler), c_szMailToHandler },

    // News protocol
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szNews, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_NEWSNAME) },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szNews, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_IFEMPTY,   HKCR, c_szNews, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_IFEMPTY,   HKCR, c_szNewsDefIcon, "", REG_EXPAND_SZ, IDEFICON_NEWS, HTReg_UrlIconProc },
    { RC_RUNDLL,   REF_IFEMPTY,   HKCR, c_szNewsOpenCmd, "", REG_SZ, sizeof(c_szNewsHandler), c_szNewsHandler },

    // Internet shortcut
    { RC_ADD,      REF_NORMAL,      HKCR, ".url", "", REG_SZ, sizeof(c_szIntShcut), c_szIntShcut },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntShcut, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_INTSHNAME) },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szIntShcut, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntShcut, "IsShortcut", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntShcut, "NeverShowExt", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntShcutCLSID, "", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },
    { RC_CALLBACK, REF_DONTINTRUDE, HKCR, c_szIntShcutDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntShcutIconHandler, "", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntShcutPrshtHandler, "", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL,      HKCR, "CLSID\\{FBF23B40-E3F0-101B-8488-00AA003E56F8}", "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_INTSHNAME) },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntshcutInproc, "", REG_SZ, sizeof(c_szShdocvw), c_szShdocvw },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntshcutInproc, "ThreadingModel", REG_SZ, sizeof("Apartment"), "Apartment" },
    { RC_ADD,      REF_NORMAL,      HKCR, c_szIntshcutInproc, "LoadWithoutCOM", REG_SZ, 1, ""},

    // HTM file type
    { RC_CALLBACK,      REF_NOTNEEDED,   HKCR, c_szHTMDefIcon, "", REG_SZ, (LPARAM)1, HTReg_IEIconProc },

    // MHTML file type
    { RC_CALLBACK,      REF_NOTNEEDED,   HKCR, c_szMHTMDefIcon, "", REG_SZ, (LPARAM)22, HTReg_IEIconProc },
};


const RegSet c_rsAssoc = {
    ARRAYSIZE(c_rlAssoc),
    c_rlAssoc
};


//
// .htm, .html associations for full-shell and browser-only installs
// 

// This is run when the browser is opened, and considered a requirement
// to make IE be the default browser.
#ifdef UNIX
const RegEntry c_rlAssocHTM[] = {
#else
const RegList c_rlAssocHTM = {
#endif
    // .html
    { RC_ADD,      REF_DONTINTRUDE, HKCR, ".htm", "", REG_SZ, sizeof("htmlfile"), "htmlfile" },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, ".htm", "Content Type", REG_SZ, sizeof("text/html"), "text/html" },

    { RC_ADD,      REF_DONTINTRUDE, HKCR, ".html", "", REG_SZ, sizeof("htmlfile"), "htmlfile" },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, ".html", "Content Type", REG_SZ, sizeof("text/html"), "text/html" },
};

const RegSet c_rsAssocHTM = {
    ARRAYSIZE(c_rlAssocHTM),
    c_rlAssocHTM
};


// This is the minimum set that is queried every time a shell window opens.  
// WARNING: this should be small to reduce the time it takes to open a folder.

// This is needed just to insure webview works.
//
const RegEntry c_rlAssocHTM_WV[] = {
    // .html
    { RC_ADD,      REF_IFEMPTY, HKCR, ".htm", "", REG_SZ, sizeof("htmlfile"), "htmlfile" },
    { RC_ADD,      REF_IFEMPTY, HKCR, ".htm", "Content Type", REG_SZ, sizeof("text/html"), "text/html" },

    { RC_ADD,      REF_IFEMPTY, HKCR, ".html", "", REG_SZ, sizeof("htmlfile"), "htmlfile" },
    { RC_ADD,      REF_IFEMPTY, HKCR, ".html", "Content Type", REG_SZ, sizeof("text/html"), "text/html" },
};


const RegSet c_rsAssocHTM_WV = {
    ARRAYSIZE(c_rlAssocHTM_WV),
    c_rlAssocHTM_WV
};


//
// Browser-only specific association settings
// 

const RegEntry c_rlAssoc_Alone[] = {
    // HTTP
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szHTTPOpenCmd,   "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPDdeexec,   "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPDdeApp,    "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPDdeTopic,  "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // HTTPS
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szHTTPSOpenCmd,   "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPSDdeexec,   "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPSDdeApp,    "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPSDdeTopic,  "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // FTP
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szFTPOpenCmd, "", REG_SZ, (LPARAM)" %1", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeifExec, "", REG_SZ, sizeof("*"), "*" },

    // Gopher
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szGOPHEROpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szGOPHERDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szGOPHERDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szGOPHERDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // File protocol
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFile, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_FILENAME) },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFile, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFile, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szFileDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFileOpenCmd, "", REG_SZ, sizeof(c_szFileHandler), c_szFileHandler },

    // .htm
    //
    //  APPCOMPAT:
    //  HTMOpenCmd needs to be REG_SZ because Office97 reads it out using RegQueryValue.
    //  WebFerret requires the string to be of type REG_SZ.
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szHTMOpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTMOpenDdeexec, "", REG_SZ, sizeof(c_szDDE_FileDefault), c_szDDE_FileDefault },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTMOpenDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTMOpenDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // .mht, .mhtml
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szMHTMOpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szMHTMOpenDdeexec, "", REG_SZ, sizeof(c_szDDE_FileDefault), c_szDDE_FileDefault },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szMHTMOpenDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szMHTMOpenDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // Internet shortcut
    { RC_ADD,      REF_NORMAL, HKCR, c_szIntShcutCMHandler, "", REG_SZ, 1, "" },

    // Other stuff
    { RC_RUNDLL,   REF_NORMAL,       HKCR, c_szIntShcutOpenCmd, "", REG_SZ, sizeof(c_szOpenURLNash), c_szOpenURLNash },
    { RC_CALLBACK, REF_NORMAL,       HKCR, c_szIEFrameAuto, "", REG_SZ, 0, HTReg_IEPathProc },
    { RC_CALLBACK, REF_NORMAL,       HKCR, c_szIENameSpaceOpen, "", REG_SZ, 0, HTReg_IEPathProc },
};

const RegSet c_rsAssoc_Alone = {
    ARRAYSIZE(c_rlAssoc_Alone),
    c_rlAssoc_Alone
};


// The reg entries for the browser only case for http, https, and ftp are duplicated here
const RegEntry c_rlAssoc_Quick[] = {
    // HTTP
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szHTTPOpenCmd,   "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPDdeexec,   "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPDdeApp,    "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPDdeTopic,  "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // HTTPS
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szHTTPSOpenCmd,   "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPSDdeexec,   "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPSDdeApp,    "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szHTTPSDdeTopic,  "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // FTP
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szFTPOpenCmd, "", REG_SZ, (LPARAM)" %1", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeifExec, "", REG_SZ, sizeof("*"), "*" },

};

const RegSet c_rsAssoc_Quick = {
    ARRAYSIZE(c_rlAssoc_Quick),
    c_rlAssoc_Quick
};




//
// Full-shell specific association settings
// 

const RegEntry c_rlAssoc_Full[] = {
    // HTTP
    { RC_CALLBACK, REF_DONTINTRUDE, HKCR, c_szHTTPOpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPDdeexec, "NoActivateHandler", REG_SZ, 1, "" },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // HTTPS
    { RC_CALLBACK, REF_DONTINTRUDE, HKCR, c_szHTTPSOpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPSDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPSDdeexec, "NoActivateHandler", REG_SZ, 1, "" },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPSDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szHTTPSDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // FTP
    { RC_CALLBACK, REF_DONTINTRUDE, HKCR, c_szFTPOpenCmd, "", REG_SZ, (LPARAM)" %1", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szFTPDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szFTPDdeexec, "NoActivateHandler", REG_SZ, 1, "" },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szFTPDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szFTPDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szFTPDdeifExec, "", REG_SZ, sizeof("*"), "*" },

    // Gopher
    { RC_CALLBACK, REF_DONTINTRUDE, HKCR, c_szGOPHEROpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szGOPHERDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szGOPHERDdeexec, "NoActivateHandler", REG_SZ, 1, "" },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szGOPHERDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE, HKCR, c_szGOPHERDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    // .htm
    //
    //  APPCOMPAT:
    //  HTMOpenCmd needs to be REG_SZ because Office97 reads it out using RegQueryValue.
    //  WebFerret requires the string to be of type REG_SZ.
    //  Visual Source Safe reads the Ddeexec string, puts a file in the %1 (NOT %l!),
    //  and performs a dde transaction, so we are pretty much stuck with the "file:%1,,-1,,,,," string now.
    //
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMShell, "", REG_SZ, sizeof(c_szOpenNew), c_szOpenNew },

    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpen, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_OPENSAME)},
    { RC_CALLBACK, REF_NORMAL, HKCR, c_szHTMOpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenDdeexec, "", REG_SZ, sizeof(c_szDDE_FileDefault), c_szDDE_FileDefault },
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenDdeexec, "NoActivateHandler", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMShell, "", REG_SZ, sizeof(c_szOpenNew), c_szOpenNew },
   
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenNew, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_OPEN)},
    { RC_CALLBACK, REF_NORMAL, HKCR, c_szHTMOpenNewCmd, "", REG_SZ, (LPARAM)" %1", HTReg_IEPathProc },
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenNewDdeexec, "", REG_SZ, sizeof(c_szDDE_Default), c_szDDE_Default},
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenNewDdeIfExec, "", REG_SZ, sizeof("*"), "*"},
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenNewDdeexec, "NoActivateHandler", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenNewDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_NORMAL, HKCR, c_szHTMOpenNewDdeTopic, "", REG_SZ, sizeof("WWW_OpenURLNewWindow"), "WWW_OpenURLNewWindow" },

    // .mht, .mhtml
    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMOpen, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_OPENSAME)},
    { RC_CALLBACK, REF_DONTINTRUDE,  HKCR, c_szMHTMOpenCmd, "", REG_SZ, (LPARAM)" -nohome", HTReg_IEPathProc },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szMHTMOpenDdeexec, "", REG_SZ, sizeof(c_szDDE_FileDefault), c_szDDE_FileDefault },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szMHTMOpenDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_DONTINTRUDE,  HKCR, c_szMHTMOpenDdeTopic, "", REG_SZ, sizeof("WWW_OpenURL"), "WWW_OpenURL" },

    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMOpenNew, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_OPEN)},
    { RC_CALLBACK, REF_NORMAL, HKCR, c_szMHTMOpenNewCmd, "", REG_SZ, (LPARAM)" %1", HTReg_IEPathProc },
    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMOpenNewDdeexec, "", REG_SZ, sizeof(c_szDDE_FileDefault), c_szDDE_FileDefault },
    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMOpenNewDdeIfExec, "", REG_SZ, sizeof("*"), "*"},
    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMOpenNewDdeexec, "NoActivateHandler", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMOpenNewDdeApp, "", REG_SZ, sizeof(IEXPLORE_APP), IEXPLORE_APP },
    { RC_ADD,      REF_NORMAL, HKCR, c_szMHTMOpenNewDdeTopic, "", REG_SZ, sizeof("WWW_OpenURLNewWindow"), "WWW_OpenURLNewWindow" },

    // Internet shortcut
    { RC_ADD,      REF_NORMAL, HKCR, c_szCLSIDURLRoot, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_THEINTERNET) },
    { RC_RUNDLL,   REF_NORMAL, HKCR, c_szIntShcutOpenCmd, "", REG_SZ, sizeof(c_szOpenURLNash), c_szOpenURLNash },
    { RC_ADD,      REF_NORMAL, HKCR, c_szIntShcutOpen, "CLSID", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },
    { RC_ADD,      REF_NORMAL, HKCR, c_szIntShcutOpen, "LegacyDisable", REG_SZ, 1, ""},
    { RC_ADD,      REF_NORMAL, HKCR, c_szIntShcutCMHandler, "", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL, HKCR, c_szIntshcutMayChange, "", REG_SZ, 1, "" },
    { RC_ADD,      REF_NORMAL, HKCR, c_szIntShcutPropHandler, "", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },

    //  add ourselves to the applications key
    { RC_CALLBACK, REF_NORMAL, HKCR, "Applications\\iexplore.exe\\shell\\open\\command", "", REG_SZ, (LPARAM)" ""%1""", HTReg_IEPathProc},

    // Other stuff
    { RC_CALLBACK, REF_NORMAL, HKCR, c_szIEFrameAuto, "", REG_SZ, 0, HTReg_IEPathProc },
};


const RegSet c_rsAssoc_Full = {
    ARRAYSIZE(c_rlAssoc_Full),
    c_rlAssoc_Full
};


//
// On upgrading from Win9x to NT5, the icons are shifted to newly created
// file called "migicons.exe". This breaks our Assoc checks. Hence this is
// a list of all HTReg_UrlIconProc checks from the various Assoc arrays that
// MUST BELONG TO US FOR US TO BE DEFAULT BROWSER (REF_NOTNEEDED and
// REF_IFEMPTY ==> not used for check purposes). 
// This list is used to fix the icons.
//
// NOTE: NOTE: NOTE: NOTE: NOTE: NOTE: NOTE: 
// Any new Icon check that uses HTReg_UrlIconProc that gets added
// to any of the Assoc arrays and is REQUIRED for Default Browser check to
// succeed has to be added here also.
//

const RegEntry c_rlAssoc_FixIcon[] = {
    // Icon checks from c_rlAssoc that are essential for us to be Default
    // Browser
    { RC_CALLBACK, REF_DONTINTRUDE, HKCR, c_szIntShcutDefIcon, "", REG_EXPAND_SZ, IDEFICON_STD, HTReg_UrlIconProc }
};

const RegSet c_rsAssoc_FixIcon = {
    ARRAYSIZE(c_rlAssoc_FixIcon),
    c_rlAssoc_FixIcon
};


// 
// General browser-only settings
//

const CHAR c_szCLSIDMIME[]           = "{FBF23B41-E3F0-101B-8488-00AA003E56F8}";
const CHAR c_szIEOnDesktop[]         = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace\\{FBF23B42-E3F0-101B-8488-00AA003E56F8}";
const CHAR c_szShellExecHook[]       = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellExecuteHooks";
const CHAR c_szFileTypesHook[]       = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileTypesPropertySheetHook";

const RegEntry c_rlGeneral_Alone[] = {
    { RC_ADD,   REF_NORMAL, HKLM, c_szIEOnDesktop,   "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_THEINTERNET) },
    { RC_ADD,   REF_NORMAL, HKLM, c_szFileTypesHook, "", REG_SZ, sizeof(c_szCLSIDMIME), c_szCLSIDMIME },

    // URL Exec Hook (CLSID_URLExecHook) (this replaces the old overloaded intshcut CLSID)
    { RC_DEL,   REF_NORMAL, HKLM, c_szShellExecHook, c_szCLSIDIntshcut, REG_SZ, 1, "" },
    { RC_ADD,   REF_NORMAL, HKLM, c_szShellExecHook, c_szCLSIDURLExecHook, REG_SZ, 1, "" },
    { RC_ADD,   REF_NORMAL, HKCR, "CLSID\\{AEB6717E-7E19-11d0-97EE-00C04FD91972}", "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_URLEXECHOOK) },
    { RC_ADD,   REF_NORMAL, HKCR, "CLSID\\{AEB6717E-7E19-11d0-97EE-00C04FD91972}\\InProcServer32", "", REG_SZ, sizeof("url.dll"), "url.dll" },
    { RC_ADD,   REF_NORMAL, HKCR, "CLSID\\{AEB6717E-7E19-11d0-97EE-00C04FD91972}\\InProcServer32", "ThreadingModel", REG_SZ, sizeof("Apartment"), "Apartment" },
};

const RegSet c_rsGeneral_Alone = {
    ARRAYSIZE(c_rlGeneral_Alone),
    c_rlGeneral_Alone
};


//
// General full-shell only settings
//

const RegEntry c_rlGeneral_Full[] = {
    { RC_DEL,   REF_NORMAL, HKLM, c_szIEOnDesktop,        "", REG_SZ, 0, NULL },
    { RC_DEL,   REF_NUKE,   HKLM, c_szFileTypesHook,      "", REG_SZ, sizeof(c_szCLSIDMIME), c_szCLSIDMIME },

    // URL Exec Hook (this replaces the old overloaded intshcut CLSID)
    { RC_DEL,   REF_NORMAL, HKLM, c_szShellExecHook, c_szCLSIDIntshcut, REG_SZ, 1, "" },
    { RC_ADD,   REF_NORMAL, HKLM, c_szShellExecHook, c_szCLSIDURLExecHook, REG_SZ, 1, "" },
    { RC_ADD,   REF_NORMAL, HKCR, "CLSID\\{AEB6717E-7E19-11d0-97EE-00C04FD91972}", "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_URLEXECHOOK) },
    { RC_ADD,   REF_NORMAL, HKCR, "CLSID\\{AEB6717E-7E19-11d0-97EE-00C04FD91972}\\InProcServer32", "", REG_SZ, sizeof("shell32.dll"), "shell32.dll" },
    { RC_ADD,   REF_NORMAL, HKCR, "CLSID\\{AEB6717E-7E19-11d0-97EE-00C04FD91972}\\InProcServer32", "ThreadingModel", REG_SZ, sizeof("Apartment"), "Apartment" },
};

const RegSet c_rsGeneral_Full = {
    ARRAYSIZE(c_rlGeneral_Full),
    c_rlGeneral_Full
};


// XP start menu
// Note: the IE start menu reg entries are created in ie.inx, this table is only needed
// to restore IE as default browser in the start menu (as a result of the user prompts)
const RegEntry c_rlStartMenu_XP[] = {
    // make IE the default internet browser for this machine's Start Menu
    { RC_ADD,      REF_NORMAL, HKLM, "Software\\Clients\\StartMenuInternet", "", REG_SZ, 0, "IEXPLORE.EXE" },
};

const RegSet c_rsStartMenu_XP = {
    ARRAYSIZE(c_rlStartMenu_XP),
    c_rlStartMenu_XP
};

const RegEntry c_rlStartMenu_XP_CU[] = {
    // make IE the default internet browser for this user's Start Menu
    { RC_ADD,      REF_NORMAL, HKCU, "Software\\Clients\\StartMenuInternet", "", REG_SZ, 0, "IEXPLORE.EXE" },
};

const RegSet c_rsStartMenu_XP_CU = {
    ARRAYSIZE(c_rlStartMenu_XP_CU),
    c_rlStartMenu_XP_CU
};

/*
 * S P E C I A L   D Y N A M I C   S E T T I N G S 
 *
 */

#define SZ_EXMAILTO     "Software\\Clients\\Mail\\Exchange\\Protocols\\Mailto"

const RegEntry c_rlExchange[] = {
    { RC_ADD,      REF_NORMAL,    HKLM, "Software\\Clients\\Mail\\Exchange", "", REG_SZ, 0, MAKEINTRESOURCE(IDS_EXCHANGE) },

    { RC_ADD,      REF_IFEMPTY,   HKLM, SZ_EXMAILTO, "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_MAILTONAME) },
    { RC_ADD,      REF_IFEMPTY,   HKLM, SZ_EXMAILTO, "EditFlags", REG_DWORD, sizeof(c_dwEditFlags2), &c_dwEditFlags2 },
    { RC_ADD,      REF_IFEMPTY,   HKLM, SZ_EXMAILTO, "URL Protocol", REG_SZ, 1, "" },
    { RC_CALLBACK, REF_IFEMPTY,   HKLM, SZ_EXMAILTO "\\DefaultIcon", "", REG_EXPAND_SZ, IDEFICON_MAIL, HTReg_UrlIconProc },
    { RC_RUNDLL,   REF_IFEMPTY,   HKLM, SZ_EXMAILTO "\\Shell\\Open\\Command", "", REG_SZ, sizeof(c_szMailToHandler), c_szMailToHandler },
};

const RegSet c_rsExchange = {
    ARRAYSIZE(c_rlExchange),
    c_rlExchange
};

#ifdef UNIX
const RegEntry c_rlAthena[] = {
#else
const RegList c_rlAthena = {
#endif
   { RC_CALLBACK, REF_NORMAL, HKLM, "", "", REG_SZ, (LPARAM)&c_rsExchange, HTReg_ExchangeProc },
};

const RegSet c_rsAthena = {
    ARRAYSIZE(c_rlAthena),
    c_rlAthena
};


/*
 * U N I N S T A L L   S E T T I N G S
 *
 */


// Protocol-specific uninstall (for both full-shell and browser-only)

const RegEntry c_rlUnHTTP[] = {
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTP, "URL Protocol", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPDefIcon, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPDdeApp, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPDdeTopic, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPDdeexec, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_PRUNE,     HKCR, c_szHTTPOpenCmd, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_EDITFLAGS, HKCR, c_szHTTP, "", REG_SZ, 0, NULL },
};

const RegSet c_rsUnHTTP = {
    ARRAYSIZE(c_rlUnHTTP),
    c_rlUnHTTP
};

#ifdef UNIX
const RegEntry c_rlUnHTTPS[] = {
#else
const RegList c_rlUnHTTPS = {
#endif
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPS, "URL Protocol", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPSDefIcon, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPSDdeApp, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPSDdeTopic, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTTPSDdeexec, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_PRUNE,     HKCR, c_szHTTPSOpenCmd, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_EDITFLAGS, HKCR, c_szHTTPS, "", REG_SZ, 0, NULL },
};

const RegSet c_rsUnHTTPS = {
    ARRAYSIZE(c_rlUnHTTPS),
    c_rlUnHTTPS
};

#ifdef UNIX
const RegEntry c_rlUnFTP[] = { 
#else  
const RegList c_rlUnFTP = {
#endif
    { RC_DEL, REF_NORMAL,    HKCR, c_szFTP, "URL Protocol", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szFTPDefIcon, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szFTPDdeApp, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szFTPDdeTopic, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szFTPDdeexec, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_PRUNE,     HKCR, c_szFTPOpenCmd, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_EDITFLAGS, HKCR, c_szFTP, "", REG_SZ, 0, NULL },
};

const RegSet c_rsUnFTP = {
    ARRAYSIZE(c_rlUnFTP),
    c_rlUnFTP
};

#ifdef UNIX
const RegEntry c_rlUnGopher[] = {
#else
const RegList c_rlUnGopher = {
#endif
    { RC_DEL, REF_NORMAL,    HKCR, c_szGOPHER, "URL Protocol", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szGOPHERDefIcon, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szGOPHERDdeApp, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szGOPHERDdeTopic, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szGOPHERDdeexec, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_PRUNE,     HKCR, c_szGOPHEROpenCmd, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_EDITFLAGS, HKCR, c_szGOPHER, "", REG_SZ, 0, NULL },
};

const RegSet c_rsUnGopher = {
    ARRAYSIZE(c_rlUnGopher),
    c_rlUnGopher
};

#ifdef UNIX 
const RegEntry c_rlUnHTM[] = {
#else
const RegList c_rlUnHTM = {
#endif
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTMDefIcon, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTMOpenDdeApp, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTMOpenDdeTopic, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL,    HKCR, c_szHTMOpenDdeexec, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_PRUNE,     HKCR, c_szHTMOpenCmd, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_EDITFLAGS, HKCR, "htmlfile", "", REG_SZ, 0, NULL },

    { RC_DEL, REF_NORMAL,    HKCR, c_szMHTMDefIcon, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_EDITFLAGS, HKCR, "mhtmlfile", "", REG_SZ, 0, NULL },
};

const RegSet c_rsUnHTM = {
    ARRAYSIZE(c_rlUnHTM),
    c_rlUnHTM
};


// Protocol-specific uninstall for full-shell

#ifdef UNIX
const RegEntry c_rlUnHTTP_Full[] = {
#else
const RegList c_rlUnHTTP_Full = {
#endif
    { RC_DEL, REF_NORMAL, HKCR, c_szHTTPDdeexec, "NoActivateHandler", REG_SZ, 0, NULL }
};

const RegSet c_rsUnHTTP_Full = {
    ARRAYSIZE(c_rlUnHTTP_Full),
    c_rlUnHTTP_Full
};

#ifdef UNIX
const RegEntry c_rlUnHTTPS_Full[] = {
#else
const RegList c_rlUnHTTPS_Full = {
#endif
    { RC_DEL, REF_NORMAL, HKCR, c_szHTTPSDdeexec, "NoActivateHandler", REG_SZ, 0, NULL }
};

const RegSet c_rsUnHTTPS_Full = {
    ARRAYSIZE(c_rlUnHTTPS_Full),
    c_rlUnHTTPS_Full
};

#ifdef UNIX
const RegEntry c_rlUnFTP_Full[] = {
#else
const RegList c_rlUnFTP_Full = {
#endif
    { RC_DEL, REF_NORMAL, HKCR, c_szFTPDdeexec, "NoActivateHandler", REG_SZ, 0, NULL },
};

const RegSet c_rsUnFTP_Full = {
    ARRAYSIZE(c_rlUnFTP_Full),
    c_rlUnFTP_Full
};

#ifdef UNIX
const RegEntry c_rlUnGopher_Full[] = {
#else
const RegList c_rlUnGopher_Full = {
#endif
    { RC_DEL, REF_NORMAL, HKCR, c_szGOPHERDdeexec, "NoActivateHandler", REG_SZ, 0, NULL },
};

const RegSet c_rsUnGopher_Full = {
    ARRAYSIZE(c_rlUnGopher_Full),
    c_rlUnGopher_Full
};

#ifdef UNIX
const RegEntry c_rlUnHTM_Full[] = {
#else
const RegList c_rlUnHTM_Full = {
    // remove the default context menu items
#endif
    { RC_DEL, REF_NORMAL, HKCR, c_szHTMShell, NULL, REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szMHTMShell, NULL, REG_SZ, 0, NULL },

    // remove the default values
    { RC_DEL, REF_NORMAL, HKCR, c_szHTMOpenNew, NULL, REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szMHTMOpenNew, NULL, REG_SZ, 0, NULL },

    { RC_DEL, REF_NORMAL, HKCR, c_szHTMOpenNewDdeApp, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szHTMOpenNewDdeTopic, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szHTMOpenNewDdeexec, "NoActivateHandler", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szHTMOpenNewDdeexec, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_PRUNE,  HKCR, c_szHTMOpenNewCmd, "", REG_SZ, 0, NULL },

    { RC_DEL, REF_NORMAL, HKCR, c_szMHTMOpenNewDdeApp, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szMHTMOpenNewDdeTopic, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szMHTMOpenNewDdeexec, "NoActivateHandler", REG_SZ, 0, NULL },
    { RC_DEL, REF_NORMAL, HKCR, c_szMHTMOpenNewDdeexec, "", REG_SZ, 0, NULL },
    { RC_DEL, REF_PRUNE,  HKCR, c_szMHTMOpenNewCmd, "", REG_SZ, 0, NULL },
};

const RegSet c_rsUnHTM_Full = {
    ARRAYSIZE(c_rlUnHTM_Full),
    c_rlUnHTM_Full
};

//
// Browser-only uninstall
//

#ifdef UNIX
const RegEntry c_rlUninstall_Alone[] = {
#else
const RegList c_rlUninstall_Alone = {
#endif
    { RC_DEL,      REF_NORMAL, HKLM, c_szIEOnDesktop,   "", REG_SZ, 0, MAKEINTRESOURCE(IDS_REG_THEINTERNET) },
    { RC_DEL,      REF_PRUNE,  HKCR, c_szIENameSpaceOpen,   "", REG_SZ, 0, NULL },

    // InternetShortcut
    { RC_DEL,    REF_NORMAL, HKCR, c_szIntShcutOpen, "CLSID", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },
    { RC_DEL,    REF_PRUNE,  HKCR, c_szIntShcutCMHandler, "", REG_SZ, 1, "" },
    { RC_DEL,    REF_PRUNE,  HKCR, c_szIntshcutMayChange, "", REG_SZ, 1, "" },
    { RC_DEL,    REF_PRUNE,  HKCR, c_szIntShcutPropHandler, "", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },

    // Change the inprocserver after removing "MayChangeDefaultMenu" above.  
    // Do this so url.dll doesn't repatch the registry.
    { RC_ADD,    REF_NORMAL, HKCR, c_szIntshcutInproc, "", REG_SZ, sizeof(c_szURL), c_szURL },
    { RC_RUNDLL, REF_NORMAL, HKCR, c_szIntShcutOpenCmd, "", REG_SZ, sizeof(c_szOpenURL), c_szOpenURL },

    { RC_CALLBACK, REF_NORMAL, HKCR, "http",     "", PLATFORM_BROWSERONLY, (LPARAM)&c_rsUnHTTP, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "https",    "", PLATFORM_BROWSERONLY, (LPARAM)&c_rsUnHTTPS, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "ftp",      "", PLATFORM_BROWSERONLY, (LPARAM)&c_rsUnFTP, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "gopher",   "", PLATFORM_BROWSERONLY, (LPARAM)&c_rsUnGopher, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "htmlfile", "", PLATFORM_BROWSERONLY, (LPARAM)&c_rsUnHTM, HTReg_UninstallProc },
};

const RegSet c_rsUninstall_Alone = {
    ARRAYSIZE(c_rlUninstall_Alone),
    c_rlUninstall_Alone
};


// 
// Full-shell uninstall
//

#ifdef UNIX
const RegEntry c_rlUninstall_Full[] = {
#else
const RegList c_rlUninstall_Full = {
#endif
    // InternetShortcut
    { RC_DEL,    REF_NORMAL, HKCR, c_szIntShcutOpen, "CLSID", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },
    { RC_DEL,    REF_NORMAL, HKCR, c_szIntShcutOpen, "LegacyDisable", REG_SZ, 1, ""},
    { RC_DEL,    REF_PRUNE,  HKCR, c_szIntShcutCMHandler, "", REG_SZ, 1, "" },
    { RC_DEL,    REF_PRUNE,  HKCR, c_szIntshcutMayChange, "", REG_SZ, 1, "" },
    { RC_DEL,    REF_PRUNE,  HKCR, c_szIntShcutPropHandler, "", REG_SZ, sizeof(c_szCLSIDIntshcut), c_szCLSIDIntshcut },

    // Change the inprocserver after removing "MayChangeDefaultMenu" above.  
    // Do this so url.dll doesn't repatch the registry.
    { RC_ADD,    REF_NORMAL, HKCR, c_szIntshcutInproc, "", REG_SZ, sizeof(c_szURL), c_szURL },
    { RC_RUNDLL, REF_NORMAL, HKCR, c_szIntShcutOpenCmd, "", REG_SZ, sizeof(c_szOpenURL), c_szOpenURL },

    // Protocol associations
    { RC_CALLBACK, REF_NORMAL, HKCR, "http",      "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnHTTP_Full, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "http",      "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnHTTP, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "https",     "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnHTTPS_Full, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "https",     "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnHTTPS, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "ftp",       "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnFTP_Full, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "ftp",       "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnFTP, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "gopher",    "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnGopher_Full, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "gopher",    "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnGopher, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "htmlfile",  "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnHTM_Full, HTReg_UninstallProc },
    { RC_CALLBACK, REF_NORMAL, HKCR, "htmlfile",  "", PLATFORM_INTEGRATED, (LPARAM)&c_rsUnHTM, HTReg_UninstallProc },
};

const RegSet c_rsUninstall_Full = {
    ARRAYSIZE(c_rlUninstall_Full),
    c_rlUninstall_Full
};



/*
 *   D E F A U L T    S E T    O F    R E G   S E T S
 *
 */


// Common association settings for both browser-only and full-shell

// This is the required set of entries to make IE be the default 
// browser.  Only used if the user hasn't turned this off.

const RegSet * const g_rgprsDefault[] = {
    &c_rsAssoc,
    &c_rsAssocHTM,
};

// Browser-only specific associations

const RegSet * const g_rgprsDefault_Alone[] = {
    &c_rsAssoc_Alone,
};

// Browser-only specific associations for a quick check
const RegSet * const g_rgprsDefault_Quick[] = {
    &c_rsAssoc_Quick,
};


// Full-shell specific associations

const RegSet * const g_rgprsDefault_Full[] = {
    &c_rsAssoc_Full,
};

// This is the set of icon entries that need to be fixed in case of a 
// Win9x to NT5 upgrade.

const RegSet * const g_rgprsDefault_FixIcon[] = {
    &c_rsAssoc_FixIcon,
};



//
// Other registry settings
//

const RegSet * const g_rgprsIE30Only[] = 
    {
    &c_rsGeneral_Alone,
    &c_rsAthena,
    };


const RegSet * const g_rgprsNashOnly[] = 
    {
    &c_rsGeneral_Full,
    &c_rsAthena,
    };


const RegSet * const g_rgprsUninstallIE30[] = 
    {
    &c_rsUninstall_Alone,
    };


const RegSet * const g_rgprsUninstallNash[] = 
    {
    &c_rsUninstall_Full,
    };


/*----------------------------------------------------------
Purpose: Determine if a particular RegSet is installed

Returns: 
Cond:    --
*/
BOOL
IsRegSetInstalled( 
    IN const RegSet * prs)
    {
    BOOL        bRet = FALSE;
    UINT        i;
    HKEY        hkey = NULL;
    const RegEntry * pre;
    CHAR        szBuffer[1024];         // Registry Data Holder
    CHAR        szT[MAX_PATH + 20]; // Need a bit extra for pszIExpAppendage
    DWORD       dwType;
    DWORD       dwSize;
    DWORD       dwSizeExpect;
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )

    // Check each registry entry.  Stop when we encounter the first
    // entry which doesn't match (no need to waste time looking at
    // other entries).
    //
    // In the debug build, we enumerate the whole list, so we can
    // see all the differences at once.
    //

#ifdef DEBUG
    #define BAIL_OUT    bRet = TRUE; continue
#else
    #define BAIL_OUT    goto Bail
#endif


    for (i = 0; i < prs->cre; i++)  
        {
        pre = &(prs->pre[i]);

        // Is this regentry not needed, or can it be set by some third 
        // party?
        if (IsFlagSet(pre->dwFlags, REF_NOTNEEDED))
            {
            // Yes; skip to next
            continue;
            }

        // Does the key exist?
        if (NO_ERROR != RegOpenKeyExA(pre->hkeyRoot, pre->pszKey, 0, KEY_READ, &hkey))  
        {
            // No; should it?
            if (RC_DEL == pre->regcmd)
            {
                // No; skip to next
                continue;
            }
            else
            {
                // Yes
                DEBUG_CODE( TraceMsg(TF_REGCHECK, "%s doesn't exist and should", Dbg_RegStr(pre, szDbg)); )
                BAIL_OUT;
            }
        }
        // Yes; should it?
        else if (RC_DEL == pre->regcmd && !*pre->pszValName)
        {
            // No
            DEBUG_CODE( TraceMsg(TF_REGCHECK, "%s exists and shouldn't", Dbg_RegStr(pre, szDbg)); )
            RegCloseKey(hkey);
            BAIL_OUT;
        }

        // Does the value exist?
        dwSize = SIZEOF(szBuffer);
        if (NO_ERROR != RegQueryValueExA(hkey, pre->pszValName, NULL, 
                                         &dwType, (BYTE *)szBuffer, &dwSize))  
        {
            // No; should it?
            if (RC_DEL != pre->regcmd)
            {
                // Yes
                TraceMsg(TF_REGCHECK, "IsRegSetInstalled: RegQueryValueEx( %hs, %hs ) Failed", pre->pszKey, pre->pszValName);
                RegCloseKey(hkey);
                BAIL_OUT;
            }
        }
        // Yes; should it?
        else if (RC_DEL == pre->regcmd)
        {
            // No
            ASSERT(pre->pszValName && *pre->pszValName);

            DEBUG_CODE( TraceMsg(TF_REGCHECK, "%s exists and shouldn't", 
                                 Dbg_RegStr(pre, szDbg)); )
            RegCloseKey(hkey);
            BAIL_OUT;
        }
        RegCloseKey(hkey);

        // Is this a value that cannot be stomped (ie, a 3rd party might have
        // set its value, and that's okay with us)?
        if (IsFlagSet(pre->dwFlags, REF_IFEMPTY))
            {
            // Yes; the existence of the value is good enough for us,
            // skip to next
            continue;
            }

        switch (pre->regcmd)  
            {
        case RC_ADD:
        case RC_RUNDLL:
            if (dwType == REG_SZ)  
            {
                LPCVOID pvValue;

                // Is this a resource string?
                if (0 == HIWORD64(pre->pvValue))
                {
                    // Yes; load it 
                    dwSizeExpect = LoadStringA(g_hinst, PtrToUlong(pre->pvValue), szT, SIZECHARS(szT));

                    // Add null and convert to bytes
                    dwSizeExpect = CbFromCchA(dwSizeExpect + 1);
                    pvValue = szT;
                }
                else
                {
                    // No
                    ASSERT(pre->pvValue);

                    if (RC_RUNDLL == pre->regcmd)
                    {
                        wnsprintfA(szT, ARRAYSIZE(szT), RUNDLL_CMD_FMT, (LPSTR)pre->pvValue);
                        pvValue = szT;

                        // Add null and convert to bytes
                        dwSizeExpect = CbFromCchA(lstrlenA(szT) + 1);
                    }
                    else
                    {
                        pvValue = pre->pvValue;

                        if (0 == pre->DUMMYUNION_MEMBER(dwSize))
                            dwSizeExpect = (DWORD)CbFromCchA(lstrlenA((LPCSTR)pvValue) + 1);
                        else
                            dwSizeExpect = (DWORD)pre->DUMMYUNION_MEMBER(dwSize);
                    }
                }

                if (dwSize != dwSizeExpect)
                {
                    TraceMsg(TF_REGCHECK, "IsRegSetInstalled: %s string size is %d, expecting %d", Dbg_RegStr(pre, szDbg), dwSize, dwSizeExpect);
                    BAIL_OUT;
                }

                // Compare case-insensitive (otherwise we'd just use 
                // memcmp below)
                if (0 != StrCmpNIA((LPSTR)pvValue, szBuffer, dwSize / SIZEOF(CHAR)))  
                    {
                    TraceMsg(TF_REGCHECK, "IsRegSetInstalled: %s string is \"%hs\", expecting \"%hs\"", Dbg_RegStr(pre, szDbg), szBuffer, pvValue);
                    BAIL_OUT;
                    }
                } 
            else 
                {
                // Non-string case
                if (dwSize != pre->DUMMYUNION_MEMBER(dwSize))  
                    {
                    TraceMsg(TF_REGCHECK, "IsRegSetInstalled: %s size is %d, expecting %d", Dbg_RegStr(pre, szDbg), dwSize, pre->DUMMYUNION_MEMBER(dwSize));
                    BAIL_OUT;
                    }

                if (0 != memcmp(pre->pvValue, (BYTE *)szBuffer, dwSize))  
                    {
                    TraceMsg(TF_REGCHECK, "IsRegSetInstalled: %s value is different, expecting %#08x", Dbg_RegStr(pre, szDbg), *(LPDWORD)pre->pvValue);
                    BAIL_OUT;
                    }
                }
            break;

        case RC_CALLBACK:
        {
            RSPECPROC pfn = (RSPECPROC)pre->pvValue;

            ASSERT(IS_VALID_CODE_PTR(pfn, RSPECPROC));

            // If the callback returns false, it means we're not the
            // default browser.
            if ( !pfn(RSCB_QUERY, pre, szBuffer, dwSize) )
                BAIL_OUT;
            break;
        }

        case RC_DEL:
            // Work is done before the switch statement.  Do nothing here.
            break;

        default:
            ASSERT(0);
            TraceMsg(TF_ERROR, "IsRegSetInstalled: Unhandled Special Type");
            break;
            }
        }

#ifdef DEBUG
    // In the debug build, leaving the above loop with bRet == TRUE means
    // something doesn't match, so we need to flip the boolean value.
    bRet ^= TRUE;
#else
    bRet = TRUE;

Bail:
#endif
    return bRet;
    }
                    

/*----------------------------------------------------------
Purpose: Returns TRUE if the key is empty of all subkeys and
         all (non-default) values.

         If dwFlags has REF_EDITFLAGS set, then this function 
         ignores the EditFlags value.

Returns: see above
Cond:    --
*/
BOOL
IsKeyPsuedoEmpty(
    IN HKEY   hkey,
    IN LPCSTR pszSubKey,
    IN DWORD  dwFlags)          // REF_ flags
{
    BOOL bRet = FALSE;
    DWORD dwRet;
    HKEY hkeyNew;

    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, KEY_READ, &hkeyNew);
    if (NO_ERROR == dwRet)
    {
        DWORD ckeys;
        DWORD cvalues;

        // Are the any subkeys?
        if (NO_ERROR == RegQueryInfoKey(hkeyNew, NULL, NULL, NULL, &ckeys,
                                        NULL, NULL, &cvalues, NULL, NULL,
                                        NULL, NULL) &&
            0 == ckeys)
        {
            // No; how about non-default values?
            DWORD dwRetDef = SHGetValueA(hkey, pszSubKey, "", NULL, NULL, NULL);

            bRet = (0 == cvalues || (1 == cvalues && NO_ERROR == dwRetDef));

            // Should we ignore edit flags?
            if (!bRet && IsFlagSet(dwFlags, REF_EDITFLAGS))
            {
                // Yes
                DWORD dwRetEdit = SHGetValueA(hkey, pszSubKey, "EditFlags", NULL, NULL, NULL);

                bRet = ((1 == cvalues && NO_ERROR == dwRetEdit) || 
                        (2 == cvalues && NO_ERROR == dwRetEdit && 
                         NO_ERROR == dwRetDef));
            }
        }
        RegCloseKey(hkeyNew);
    }
    return bRet;
}


/*----------------------------------------------------------
Purpose: Prune the key of our keys and values.  Walk back up
         the tree and delete empty keys below us.

Returns: 
Cond:    --
*/
void
PruneKey(
    IN HKEY    hkeyRoot,
    IN LPCSTR  pszKey)
{
    CHAR szPath[MAX_PATH];

    ASSERT(hkeyRoot);
    ASSERT(pszKey);

    StrCpyNA(szPath, pszKey, ARRAYSIZE(szPath));

    while (PathRemoveFileSpecA(szPath) && *szPath)
    {
        SHDeleteOrphanKeyA(hkeyRoot, szPath);
    }
}


/*----------------------------------------------------------
Purpose: Install a regset (set of registry entries).

         If bDontIntrude is TRUE , then behave such that any
         REF_DONTINTRUDE entry is not forcefully installed (i.e., it
         will only get installed if the key doesn't already
         have a value in it).  

Returns: 
Cond:    --
*/
BOOL
InstallRegSet( 
    IN const RegSet *prs,
    IN BOOL  bDontIntrude)
    {
    BOOL        bRet = TRUE;
    UINT        i;
    HKEY        hkey;
    const RegEntry * pre;
    CHAR        szBuffer[MAX_PATH + 20];    // Need additional space for pszIExpAppendage
    DWORD       dwSize;
    LPCVOID     pvValue;
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )

    /*
     * Install each registry entry
     */
    for (i = 0; i < prs->cre; i++)  
        {
        pre = &(prs->pre[i]);

        // Stomp on this value?
        if (bDontIntrude && IsFlagSet(pre->dwFlags, REF_DONTINTRUDE))
            continue;

        if (IsFlagSet(pre->dwFlags, REF_IFEMPTY))
        {
            // No
            if (NO_ERROR == RegOpenKeyExA(pre->hkeyRoot, pre->pszKey, 0, KEY_READ, &hkey))
            {
                BOOL bSkip;

                // Are we checking the default value?
                if (0 == *pre->pszValName)
                {
                    // Yes; check the size, because default values 
                    // always exist with at least a null terminator.
                    dwSize = 0;
                    RegQueryValueExA(hkey, pre->pszValName, NULL, NULL, NULL, &dwSize);
                    bSkip = (1 < dwSize);
                }
                else
                {
                    // No
                    bSkip = (NO_ERROR == RegQueryValueExA(hkey, pre->pszValName, 
                                            NULL, NULL, NULL, NULL));
                }

                RegCloseKey(hkey);

                // Does it exist?
                if (bSkip)
                {               
                    // Yes; skip it
                    DEBUG_CODE( TraceMsg(TF_REGCHECK, "%s already exists, skipping", 
                                         Dbg_RegStr(pre, szDbg)); )
                    continue;
                }
            }
        }

        switch (pre->regcmd)  
        {
        case RC_ADD:
        case RC_RUNDLL:
            if (NO_ERROR != RegCreateKeyExA(pre->hkeyRoot, pre->pszKey, 0, NULL, 
                                            REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkey, NULL))  
            {
                TraceMsg(TF_ERROR, "InstallRegSet(): RegCreateKey(%hs) Failed", pre->pszKey);
                bRet = FALSE;
            }
            else
            {
                // Is the value a resource string? 
                if (REG_SZ == pre->dwType && 0 == HIWORD64(pre->pvValue))
                {
                    UINT idRes = PtrToUlong(pre->pvValue);
                    // Yes; load it
                    dwSize = LoadStringA(g_hinst, idRes, szBuffer, SIZECHARS(szBuffer));

                    // Add null and convert to bytes
                    dwSize = CbFromCchA(dwSize + 1);     
                    pvValue = szBuffer;
                }
                else
                {
                    // No
                    if (RC_RUNDLL == pre->regcmd)
                    {
                        ASSERT(pre->pvValue);
                        ASSERT(REG_SZ == pre->dwType);

                        wnsprintfA(szBuffer, ARRAYSIZE(szBuffer), RUNDLL_CMD_FMT, (LPSTR)pre->pvValue);
                        pvValue = szBuffer;
                        dwSize = CbFromCchA(lstrlenA(szBuffer) + 1);
                    }
                    else
                    {
                        // Normal case
                        pvValue = pre->pvValue;

                        if (0 == pre->DUMMYUNION_MEMBER(dwSize) && REG_SZ == pre->dwType)
                            dwSize = CbFromCchA(lstrlenA((LPCSTR)pvValue) + 1);
                        else
                            dwSize = pre->DUMMYUNION_MEMBER(dwSize);
                    }
                }

                ASSERT(0 < dwSize);

                if (NO_ERROR != RegSetValueExA(hkey, pre->pszValName, 0, pre->dwType, (BYTE*)pvValue, dwSize))  
                {
                    TraceMsg(TF_ERROR, "InstallRegSet(): RegSetValueEx(%hs) Failed", pre->pszValName );
                    bRet = FALSE;
                }
                else
                {
                    DEBUG_CODE( TraceMsg(TF_REGCHECK, "Setting %s", Dbg_RegStr(pre, szDbg)); )
                }
                RegCloseKey(hkey);
            }
            break;

        case RC_CALLBACK:
        {
            RSPECPROC pfn = (RSPECPROC)pre->pvValue;

            ASSERT(IS_VALID_CODE_PTR(pfn, RSPECPROC));

            pfn(RSCB_INSTALL, pre, NULL, 0);
            break;
        }

        case RC_DEL:
            // Delete the default value, a named value, or the key? 
            if (pre->pszValName == NULL)
            {
                // Default value
                DEBUG_CODE( TraceMsg(TF_REGCHECK, "Deleting default value %s", Dbg_RegStr(pre, szDbg)); )

                SHDeleteValueA(pre->hkeyRoot, pre->pszKey, pre->pszValName);
            }
            else if (*pre->pszValName)
            {
                // Named value
                DEBUG_CODE( TraceMsg(TF_REGCHECK, "Deleting value %s", Dbg_RegStr(pre, szDbg)); )

                SHDeleteValueA(pre->hkeyRoot, pre->pszKey, pre->pszValName);
            }
            else
            {
                // Key
                if (IsFlagSet(pre->dwFlags, REF_NUKE))
                {
                    DEBUG_CODE( TraceMsg(TF_REGCHECK, "Deleting key %s", Dbg_RegStr(pre, szDbg)); )

                    SHDeleteKeyA(pre->hkeyRoot, pre->pszKey);
                }
                // If there are keys or values (other than the
                // default value) that are set, then we don't want
                // to delete either the default value or the
                // key.
                else if (IsKeyPsuedoEmpty(pre->hkeyRoot, pre->pszKey, pre->dwFlags))
                {
                    // Delete the default value so SHDeleteOrphanKey 
                    // will work
                    SHDeleteValueA(pre->hkeyRoot, pre->pszKey, "");

                    // Delete the EditFlags value?  (Without the EditFlags,
                    // the user will not be able to specify associations
                    // for this class in the FileTypes dialog, b/c that
                    // dialog requires this value.  So the rule is, this
                    // function will delete the EditFlags if there is
                    // nothing else in the key.)
                    if (IsFlagSet(pre->dwFlags, REF_EDITFLAGS))
                    {
                        DEBUG_CODE( TraceMsg(TF_REGCHECK, "Deleting %s\\EditFlags", Dbg_RegStr(pre, szDbg)); )
                        
                        SHDeleteValueA(pre->hkeyRoot, pre->pszKey, "EditFlags");
                    }

                    DEBUG_CODE( TraceMsg(TF_REGCHECK, "Deleting empty key %s", Dbg_RegStr(pre, szDbg)); )
                    
                    SHDeleteOrphanKeyA(pre->hkeyRoot, pre->pszKey);

                    // Should we prune?  (This mean we'll walk back up
                    // the tree and try deleting empty keys that lead
                    // to this key.)
                    if (IsFlagSet(pre->dwFlags, REF_PRUNE))
                        PruneKey(pre->hkeyRoot, pre->pszKey);
                }
            }
            break;

        default:
            ASSERT(0);
            TraceMsg(TF_ERROR, "InstallRegSet(): Unhandled Special Case");
            break;
            }
        }

    return bRet;
    }


/****************************************************************************

    FUNCTION: CenterWindow (HWND, HWND)

    PURPOSE:  Center one window over another

    COMMENTS:

    Dialog boxes take on the screen position that they were designed at,
    which is not always appropriate. Centering the dialog over a particular
    window usually results in a better position.

****************************************************************************/
BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
    RECT    rChild, rParent;
    int     wChild, hChild, wParent, hParent;
    int     wScreen, hScreen, xNew, yNew;
    HDC     hdc;

    // Get the Height and Width of the child window
    GetWindowRect (hwndChild, &rChild);
    wChild = rChild.right - rChild.left;
    hChild = rChild.bottom - rChild.top;

    // Get the Height and Width of the parent window
    GetWindowRect (hwndParent, &rParent);
    wParent = rParent.right - rParent.left;
    hParent = rParent.bottom - rParent.top;

    // Get the display limits
    hdc = GetDC (hwndChild);

    if (hdc)
    {
        wScreen = GetDeviceCaps (hdc, HORZRES);
        hScreen = GetDeviceCaps (hdc, VERTRES);
        ReleaseDC (hwndChild, hdc);
    }
    else
    {
        wScreen = 0;
        hScreen = 0;
    }

    // Calculate new X position, then adjust for screen
    xNew = rParent.left + ((wParent - wChild) /2);
    if (xNew < 0) {
        xNew = 0;
    } else if ((xNew+wChild) > wScreen) {
        xNew = wScreen - wChild;
    }

    // Calculate new Y position, then adjust for screen
    yNew = rParent.top  + ((hParent - hChild) /2);
    if (yNew < 0) {
        yNew = 0;
    } else if ((yNew+hChild) > hScreen) {
        yNew = hScreen - hChild;
    }

    // Set it, and return
    return SetWindowPos (hwndChild, NULL,
        xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}


/*----------------------------------------------------------
Purpose: Dialog proc 

*/
BOOL_PTR
CALLBACK
AssociationDialogProc(HWND hdlg, UINT uMsg, WPARAM wparam, LPARAM lparam)
{
    BOOL bMsgHandled = FALSE;

    /* uMsg may be any value. */
    /* wparam may be any value. */
    /* lparam may be any value. */

    switch (uMsg){
    case WM_INITDIALOG:
        CenterWindow( hdlg, GetDesktopWindow());

        if (g_bRunOnNT5)
        {
            // Initialize Checkbox
            // uncheck by default for the first time we show this dialog, 
            // user's action is required. we still persist user's last choice.
            if (FALSE == SHRegGetBoolUSValue(REGSTR_PATH_MAIN, TEXT("ShowedCheckBrowser"), 
                                     FALSE, FALSE)) 
            {
                Button_SetCheck(GetDlgItem(hdlg, IDC_ASSOC_CHECK), FALSE);

                  // mark we have showed this dialog once.
                LPTSTR sz = TEXT("Yes");
                SHRegSetUSValue(REGSTR_PATH_MAIN, TEXT("ShowedCheckBrowser"), REG_SZ, 
                    (LPBYTE)sz, CbFromCch(lstrlen(sz)+1), SHREGSET_HKCU | SHREGSET_FORCE_HKCU);

            }
            else
            {
                Button_SetCheck(GetDlgItem(hdlg, IDC_ASSOC_CHECK), IsCheckAssociationsOn());
            }
        }
        else
            Button_SetCheck(GetDlgItem(hdlg, IDC_ASSOC_CHECK), IsCheckAssociationsOn());

        bMsgHandled  = TRUE;
        break;

    //
    // MSN mucks with the registry in a way that causes IE to ask if it's the
    // default browser.  Then after they launch IE they maximize the active
    // window.  Since the default browsre dialog is active, it gets maximized.
    // Handeling the WM_GETMINMAXINFO prevents this dialog from maximizing.
    //
    case WM_GETMINMAXINFO:
        {
            LPMINMAXINFO lpmmi = (LPMINMAXINFO)lparam;

            if (lpmmi)
            {
                RECT rc;

                if (GetWindowRect(hdlg, &rc))
                {
                    lpmmi->ptMaxSize.x = rc.right - rc.left;
                    lpmmi->ptMaxSize.y = rc.bottom - rc.top;

                    lpmmi->ptMaxPosition.x = rc.left;
                    lpmmi->ptMaxPosition.y = rc.top;

                    bMsgHandled = TRUE;
                }
            }
        }
        break;


    case WM_COMMAND:
        switch (LOWORD(wparam))  {
        case IDYES:
        case IDNO:
            SetCheckAssociations( Button_GetCheck(GetDlgItem(hdlg, IDC_ASSOC_CHECK)) );
            EndDialog( hdlg, LOWORD(wparam));
            break;

        }

    default:
        break;
    }
    return(bMsgHandled);
}


/*----------------------------------------------------------
Purpose: Asks the user whether to make IE be the default browser

*/
BOOL 
AskUserShouldFixReg()
{
    return IDYES == SHFusionDialogBoxParam(MLGetHinst(),
                              MAKEINTRESOURCE(IDD_ASSOC),
                              NULL,
                              AssociationDialogProc,
                              NULL);
}


HRESULT InstallFTPAssociations(void)
{
    IFtpInstaller * pfi;
    HRESULT hr = CoCreateInstance(CLSID_FtpInstaller, NULL, CLSCTX_INPROC_SERVER, IID_IFtpInstaller, (void **) &pfi);

    if (SUCCEEDED(hr))
    {
        hr = pfi->MakeIEDefautlFTPClient();
        pfi->Release();
    }
    else
    {
        // This may fail to create if FTP wasn't installed, which is
        // a valid install case.
        hr = S_OK;
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: Install file and protocol association settings in
         registry.

*/
HRESULT
InstallRegAssoc(
    UINT nInstall,          // One of PLATFORM_*
    BOOL bDontIntrude)     // TRUE: be non-intrusive
{
    int i;

    // Install associations common across both IE and Nashville

    for (i = 0; i < ARRAYSIZE(g_rgprsDefault); i++)
        InstallRegSet(g_rgprsDefault[i], bDontIntrude);

    if (PLATFORM_UNKNOWN == nInstall)
    {
        nInstall = WhichPlatform();
    }

    switch (nInstall)
    {
    case PLATFORM_BROWSERONLY:
        for (i = 0; i < ARRAYSIZE(g_rgprsDefault_Alone); i++)
            InstallRegSet(g_rgprsDefault_Alone[i], bDontIntrude);
        break;

    case PLATFORM_INTEGRATED:
        for (i = 0; i < ARRAYSIZE(g_rgprsDefault_Full); i++)
            InstallRegSet(g_rgprsDefault_Full[i], bDontIntrude);
        break;

    default:
        ASSERT(0);
        break;
    }

    InstallFTPAssociations();

    // Notify shell that the associations have changed.
    SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

    return NOERROR;
}

/*----------------------------------------------------------
Purpose: Settings that can only be set after user confirmation.

*/
void
InstallAfterConfirmation(
    BOOL bDontIntrude)     // TRUE: be non-intrusive
{
    // on XP, add IE to show up in the start menu as the Internet app
    if (IsOS(OS_WHISTLERORGREATER))
    {
        // Try to set ourselves as the system default Start Menu web browser
        if (InstallRegSet(&c_rsStartMenu_XP, bDontIntrude))
        {
            // If that succeeds, then clear the per-user setting and let
            // the user float with the system default.  This is necessary
            // to allow downlevel browsers like Netscape to come in and
            // take over the default browser and steal the user away from us.
            // (We're so nice and accomodating.  I bet they won't extend
            // us the same courtesy!)
            SHDeleteValue(HKEY_CURRENT_USER, TEXT("Software\\Clients\\StartMenuInternet"), NULL);
        }
        else
        {
            // We don't have permission to set the global browser, so set ourselves
            // as the browser for this user.
            InstallRegSet(&c_rsStartMenu_XP_CU, bDontIntrude);
        }

        SHSendMessageBroadcast(WM_SETTINGCHANGE, 0, (LPARAM)TEXT("Software\\Clients\\StartMenuInternet"));
    }
}


/*----------------------------------------------------------
Purpose: Set the CheckAssocation setting in the registry

*/
void
SetCheckAssociations( 
    BOOL fCheck)
{
    HKEY    hk;

    if (RegOpenKeyExA(HKEY_CURRENT_USER, c_szCheckAssnSwitch, 0, KEY_WRITE, &hk) == ERROR_SUCCESS)  {
        LPTSTR szStr;
        DWORD dwSize;

        if (fCheck)
            szStr = TEXT("Yes");
        else
            szStr = TEXT("No");
        dwSize = CbFromCch( lstrlen( szStr ) + 1 );
        RegSetValueEx( hk, TEXT("Check_Associations"), 0, REG_SZ, (LPBYTE) szStr, dwSize );
        RegCloseKey( hk );
    }
}



/*----------------------------------------------------------
Purpose: Determines if the user has turned off the "check for
         default browser" in the registry.

*/
BOOL IsCheckAssociationsOn()
{
    BOOL    rval = TRUE;
    CHAR   szBuf[20];
    DWORD   dwSize = sizeof(szBuf);
    DWORD   dwValType;

    if (NO_ERROR == SHGetValueA(HKEY_CURRENT_USER, c_szCheckAssnSwitch, 
                                 "Check_Associations", &dwValType, 
                                 szBuf, &dwSize))
    {
        if ((dwValType == REG_SZ) && (dwSize < sizeof(szBuf)))  {
            if (StrCmpIA( szBuf, "No") == 0)
                rval = FALSE;
        }
    }

    return( rval );
}

/***********************************************************************

  These routines are used to repair damage done to Internet Explorer's 
  settings by "Netscape Navigator" and "Netscape TuneUp For IE"

 ***********************************************************************/

//
// Prototype for advpack functions
//
HRESULT RunSetupCommand(HWND hWnd, LPCSTR szCmdName, LPCSTR szInfSection, LPCSTR szDir, LPCSTR lpszTitle, HANDLE *phEXE, DWORD dwFlags, LPVOID pvReserved);

//
// This flag tells us whether it's ok to used the
// cached BOOL for IsResetWebSettingsRequired.
//
BOOL g_fAlreadyCheckedForClobber = FALSE;

HRESULT RunSetupCommandW(HWND hWnd, LPCWSTR szCmdName, LPCWSTR szInfSection, LPCWSTR szDir, LPCWSTR lpszTitle, HANDLE *phEXE, DWORD dwFlags, LPVOID pvReserved)
{

    CHAR szCmdNameA[MAX_PATH];
    CHAR szInfSectionA[MAX_PATH];
    CHAR szDirA[MAX_PATH];
    
    SHUnicodeToAnsi(szCmdName,szCmdNameA,ARRAYSIZE(szCmdNameA));
    SHUnicodeToAnsi(szInfSection,szInfSectionA,ARRAYSIZE(szInfSectionA));
    SHUnicodeToAnsi(szDir,szDirA,ARRAYSIZE(szDirA));

    ASSERT(NULL == pvReserved);
    ASSERT(NULL == lpszTitle);

    return RunSetupCommand(hWnd, szCmdNameA, szInfSectionA, szDirA, NULL, phEXE, dwFlags, NULL);
}


//
// Path to the inf file
//
#define IERESTORE_FILENAME  TEXT("iereset.inf")
#define INF_PATH            TEXT("inf")

//
// Names of the sections in our inf file
//
#define INFSECTION_HOMEPAGE  TEXT("RestoreHomePage")
#define INFSECTION_SETTINGS  TEXT("RestoreBrowserSettings")

#define IE_VERIFY_REGKEY     TEXT("Software\\Microsoft\\Internet Explorer\\Main")
#define IE_VERIFY_REGVALUE   TEXT("Default_Page_URL")

#define INFSECTION_VERIFY    TEXT("Strings")
#define IE_VERIFY_INFKEY     TEXT("START_PAGE_URL")

void GetIEResetInfFileName(LPWSTR pszBuffer)
{
    TCHAR szWindowsDir[MAX_PATH];

    if (NULL == pszBuffer)
        return;

    GetWindowsDirectory(szWindowsDir,ARRAYSIZE(szWindowsDir));

    wnsprintfW(
        pszBuffer,
        MAX_PATH,
        TEXT("%s\\%s\\%s"),
        szWindowsDir,INF_PATH,IERESTORE_FILENAME);

    return;
}

/*
 * CheckIESettings
 *
 * This function will try to determine whether or not IE's settings
 * have been clobbered by another browser.
 *
 * Returns S_OK if IE settings are intact.
 * Returns S_FALSE if someone has mucked with the IE settings
 * Returns E_FAIL on error
 * 
 */
HRESULT CheckWebSettings(void)
{

    TCHAR szInfPath[MAX_PATH];
    TCHAR szDataFromInf[MAX_PATH];
    TCHAR szDataFromReg[MAX_PATH];
    LONG retval;

    HKEY hkey;
    DWORD dwType;
    DWORD dwSize = sizeof(szDataFromReg);
    //
    // Get the path to the inf file
    //
    GetIEResetInfFileName(szInfPath);

    //
    // Read the string from the inf file
    //
    retval = SHGetIniString(
        INFSECTION_VERIFY,
        IE_VERIFY_INFKEY,
        szDataFromInf,
        ARRAYSIZE(szDataFromInf),
        szInfPath);

    if (retval <= 0)
        return E_FAIL;

    //
    // Open the corresponding key in the registry
    //
    retval = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        IE_VERIFY_REGKEY,
        NULL,
        KEY_READ,
        &hkey);

    if (retval != ERROR_SUCCESS)
        return E_FAIL;

    //
    // Read the data from the registry
    //
    retval = RegQueryValueEx(
        hkey,
        IE_VERIFY_REGVALUE,
        NULL,
        &dwType,
        (LPBYTE)szDataFromReg,
        &dwSize);

    if (retval != ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
        return E_FAIL;
    }

    ASSERT(dwType == REG_SZ);

    RegCloseKey(hkey);

    //
    // Return S_OK if they match, S_FALSE if they don't
    //
    return StrCmp(szDataFromReg,szDataFromInf) ? S_FALSE : S_OK;

}

extern "C" BOOL IsResetWebSettingsRequired(void)
{
    static BOOL fRequired;

    if (!g_fAlreadyCheckedForClobber)
    {
        fRequired = (S_FALSE == CheckWebSettings());
        g_fAlreadyCheckedForClobber = TRUE;
    }

    return fRequired;

}

HRESULT ResetWebSettingsHelper(BOOL fRestoreHomePage)
{

    HRESULT hr;
    TCHAR szTempPath[MAX_PATH];
    TCHAR szInfPath[MAX_PATH];

    GetTempPath(ARRAYSIZE(szTempPath),szTempPath);
    GetIEResetInfFileName(szInfPath);

    g_fAlreadyCheckedForClobber = FALSE;

    //
    // Run the main part of the inf file
    //
    hr = RunSetupCommandW(
        NULL, 
        szInfPath, 
        INFSECTION_SETTINGS, 
        szTempPath, 
        NULL, 
        NULL, 
        RSC_FLAG_INF|RSC_FLAG_QUIET, 
        NULL);

    //
    // Also, reset their homepage if requested to do so
    //
    if (SUCCEEDED(hr) && fRestoreHomePage)
        hr = RunSetupCommandW(
            NULL, 
            szInfPath, 
            INFSECTION_HOMEPAGE, 
            szTempPath, 
            NULL, 
            NULL, 
            RSC_FLAG_INF|RSC_FLAG_QUIET, 
            NULL);

    return hr;
}

//
// Dialog Procedure for the "reset web settings" dialog
//
// Return values are:
//
//    -1   Something went wrong
//     0   The user changes his/her mind
//     1   We reset everything except the homepage
//     2   We reset everything including the homepage
//

BOOL_PTR CALLBACK ResetWebSettingsDlgProc(HWND hdlg, UINT uMsg, WPARAM wparam, LPARAM lparam)
{

    switch (uMsg)
    {
    case WM_INITDIALOG:

        CenterWindow(hdlg, GetDesktopWindow());
        CheckDlgButton(hdlg,IDC_RESET_WEB_SETTINGS_HOMEPAGE,BST_CHECKED);
        return TRUE;

    case WM_COMMAND:
        
        switch(LOWORD(wparam))
        {
        case IDYES:
            {
                HRESULT hr;
                BOOL fResetHomePage = (BST_CHECKED == IsDlgButtonChecked(hdlg,IDC_RESET_WEB_SETTINGS_HOMEPAGE));

                //
                // Restore the settings to their IE defaults
                //
                hr = ResetWebSettingsHelper(fResetHomePage);

                if (!IsIEDefaultBrowser())
                {
                    InstallRegAssoc(WhichPlatform(), FALSE);
                    InstallAfterConfirmation(FALSE);
                }

                if (FAILED(hr))
                    EndDialog(hdlg, -1);

                else if (fResetHomePage)
                    EndDialog(hdlg, 2);

                else
                    EndDialog(hdlg, 1);

            }
            return TRUE;
            
        case IDCANCEL:
        case IDNO:
            
            EndDialog(hdlg, 0);
            return TRUE;

        default:
            return FALSE;
        }

    default:
        return FALSE;
    }

}

HRESULT ResetWebSettings(HWND hwnd, BOOL *pfChangedHomePage)
{

    HRESULT hr;

    if (pfChangedHomePage)
        *pfChangedHomePage = FALSE;

    switch (DialogBoxParam(
        MLGetHinst(),
        MAKEINTRESOURCE(IDD_RESET_WEB_SETTINGS),
        hwnd,
        ResetWebSettingsDlgProc,
        NULL))
    {
    case -1:
        hr = E_FAIL;
        break;

    case 0:
        hr = S_FALSE;
        break;

    case 1:
        hr = S_OK;
        break;

    case 2:
        if (pfChangedHomePage)
            *pfChangedHomePage = TRUE;
        hr = S_OK;
        break;

    default:
        ASSERT(0);
        hr = E_FAIL;
        break;
    }

    if (FAILED(hr))
    {
        MLShellMessageBox(
            hwnd,
            MAKEINTRESOURCE(IDS_RESET_WEB_SETTINGS_FAILURE),
            MAKEINTRESOURCE(IDS_RESET_WEB_SETTINGS_TITLE),
            MB_OK | MB_ICONEXCLAMATION);
    }
    else if (hr == S_OK)
    {
        MLShellMessageBox(
            hwnd,
            MAKEINTRESOURCE(IDS_RESET_WEB_SETTINGS_SUCCESS),
            MAKEINTRESOURCE(IDS_RESET_WEB_SETTINGS_TITLE),
            MB_OK | MB_ICONINFORMATION);
    }

    return hr;
}

void EnsureWebViewRegSettings()
{
    // We do the following mini-check regardless of the user's settings,
    // and for every window we open
    if (!IsRegSetInstalled(&c_rsAssocHTM_WV))
        InstallRegSet(&c_rsAssocHTM_WV, FALSE);
}

void FixIcons()
{
    int i;

    for (i = 0; i < ARRAYSIZE(g_rgprsDefault_FixIcon); i++)  
    {
        // 2nd param FALSE ==> always intrude.
        InstallRegSet(g_rgprsDefault_FixIcon[i], FALSE);
    }
}


/*----------------------------------------------------------
Purpose: Function that determines if we are the default browser.
         If not the default browser, this function will
         ask the user to if they want to become the default
         browser and make those changes.

*/
void 
DetectAndFixAssociations()
{
    TraceMsg(TF_REGCHECK, "Performing expensive registry query for default browser!");

    // We will become the Default browser if:
    // 1. The User has "Check Associations" On,
    // 2. We don't own the associations, and
    // 3. The user said Yes when we displayed the dialog.
    if (IsCheckAssociationsOn() &&
        !IsIEDefaultBrowser() &&
        AskUserShouldFixReg())
    {
        InstallRegAssoc(WhichPlatform(), FALSE);
        InstallAfterConfirmation(FALSE);
    }
}

/*
A really quick - non - through check to see if IE is likely the
default browser
*/

BOOL IsIEDefaultBrowserQuick(void)
{

    int i;
    BOOL bAssociated = TRUE;

    TraceMsg(TF_REGCHECK, "Performing expensive registry query for default browser!");

    // Check the settings common to all platforms
    for (i = 0; i < ARRAYSIZE(g_rgprsDefault_Quick); i++)  
    {
        if (! IsRegSetInstalled(g_rgprsDefault_Quick[i]))  
            bAssociated = FALSE;
    }
    return bAssociated;

}

/*----------------------------------------------------------
Purpose: Function that determines if we are the default browser.

*/
BOOL
IsIEDefaultBrowser(void)
{
    int i;
    BOOL bAssociated = TRUE;
    UINT nInstall = WhichPlatform();

    TraceMsg(TF_REGCHECK, "Performing expensive registry query for default browser!");

    // Check the settings common to all platforms
    for (i = 0; i < ARRAYSIZE(g_rgprsDefault); i++)  
    {
        if (! IsRegSetInstalled(g_rgprsDefault[i]))  
            bAssociated = FALSE;
    }

    if (bAssociated)
    {
        // Check specific to IE or Nashville
        switch (nInstall)
        {
        case PLATFORM_BROWSERONLY:
            for (i = 0; i < ARRAYSIZE(g_rgprsDefault_Alone); i++)  
            {
                if (! IsRegSetInstalled(g_rgprsDefault_Alone[i]))  
                {
                    bAssociated = FALSE;
                    break;
                }
            }
            break;

        case PLATFORM_INTEGRATED:
            for (i = 0; i < ARRAYSIZE(g_rgprsDefault_Full); i++)  
            {
                if (! IsRegSetInstalled(g_rgprsDefault_Full[i]))  
                {
                    bAssociated = FALSE;
                    break;
                }
            }
            break;

        default:
            ASSERT(0);
            break;
        }
    }
        
    // If IE is the default browser and this was an NT5Upgrade scenario,
    // fix the Icons references.
    if (g_bNT5Upgrade && bAssociated)
    {
        FixIcons();
    }

    return bAssociated;
}


/*----------------------------------------------------------
Purpose: Checks if we're installing over IE.  This function
         looks at the associated shell\open\command handler
         for the http protocol.  

Returns: TRUE if we're installing over IE
*/
BOOL
AreWeInstallingOverIE(void)
{
    BOOL bRet = FALSE;
    CHAR sz[MAX_PATH + 20];    // add some padding for arguments
    DWORD cbData = SIZEOF(sz);

    if (NO_ERROR == SHGetValueA(HKEY_CLASSES_ROOT, c_szHTTPOpenCmd, "",
                               NULL, sz, &cbData) &&
        StrStrIA(sz, IEXPLORE_EXE) || StrStrIA(sz, EXPLORER_EXE))
    {
        TraceMsg(TF_REGCHECK, "Installing over IEXPLORE.EXE");
        bRet = TRUE;
    }
    return bRet;
}    

BOOL ShouldIEBeDefaultBrowser(void)
{
    BOOL bRet = TRUE;          // default to TRUE (eg take over the association)
    CHAR sz[MAX_PATH + 20];    // add some padding for arguments
    DWORD cbData = ARRAYSIZE(sz);
    sz[0] = '\0';

    if (NO_ERROR == SHGetValueA(HKEY_CLASSES_ROOT, ".htm", "", NULL, sz, &cbData))
    {
        if (!sz[0])
        {
            // null key so return TRUE
            return bRet;
        }
        else if (!StrCmpIA(sz, "htmlfile"))
        {
            // Maybe, make sure further
            sz[0] = '\0';
            cbData = ARRAYSIZE(sz);

            if (NO_ERROR == SHGetValueA(HKEY_CLASSES_ROOT, c_szHTMOpenCmd, "",
                                       NULL, sz, &cbData))
            {
                if (!sz[0] ||  // if sz[0] is NULL, we will take it over  (probably broken reg)
                    StrStrIA(sz, IEXPLORE_EXE))
                {
                    // Default browser was IE, so we return TRUE 
                    TraceMsg(TF_REGCHECK, "IEXPLORE.EXE is the default browser");
                }
                else
        {
           TraceMsg(TF_REGCHECK, "%s is the default browser (NOT iexplore.exe)", sz);
           bRet = FALSE;
        }
            }
        }
        else
        {
            // the progid does not point to "htmlfile", so IE cant be the default browser
            TraceMsg(TF_REGCHECK, "%s is the .htm progid (NOT htmlfile)", sz);
            bRet = FALSE;
        }
    }
    // .htm progid key does not exist, so we return TRUE

    return bRet;

}

#define SZ_REGKEY_FTPSHELLOPEN          TEXT("ftp\\shell\\open")
#define SZ_REGKEY_COMMAND               TEXT("command")
#define SZ_REGKEY_DDEEXEC               TEXT("ddeexec\\ifExec")

#define SZ_IEXPLORE_FTP_NEW          TEXT("iexplore.exe\" %1")
#define SZ_IEXPLORE_FTP_OLD          TEXT("iexplore.exe\" -nohome")

HRESULT UpgradeSettings(void)
{
    HRESULT hr = S_OK;
    HKEY hKey;
    
    LONG lRet = RegOpenKeyEx(HKEY_CLASSES_ROOT, SZ_REGKEY_FTPSHELLOPEN, 0, KEY_READ | KEY_SET_VALUE, &hKey);
    hr = HRESULT_FROM_WIN32(lRet);
    if (hKey)
    {
        TCHAR szData[MAX_PATH];
        LONG cbSize = sizeof(szData);
        
        lRet = RegQueryValue(hKey, SZ_REGKEY_COMMAND, szData, &cbSize);
        hr = HRESULT_FROM_WIN32(lRet);
        if (SUCCEEDED(hr))
        {
            DWORD cchStart = (lstrlen(szData) - ARRAYSIZE(SZ_IEXPLORE_FTP_OLD) + 1);

            // Do we own it?
            if (0 == StrCmp(SZ_IEXPLORE_FTP_OLD, &szData[cchStart]))
            {
                // Yes, so we can upgrade it.

                // Buffer Overflow isn't a problem because I know SZ_IEXPLORE_FTP_NEW is smaller
                // than SZ_IEXPLORE_FTP_OLD.
                StrCpyN(&szData[cchStart], SZ_IEXPLORE_FTP_NEW, ARRAYSIZE(szData) - cchStart);

                // Yes, so let's upgrade.
                lRet = RegSetValue(hKey, SZ_REGKEY_COMMAND, REG_SZ, szData, lstrlen(szData));
                hr = HRESULT_FROM_WIN32(lRet);
                if (SUCCEEDED(hr))
                {
                    lRet = RegSetValue(hKey, SZ_REGKEY_DDEEXEC, REG_SZ, TEXT(""), ARRAYSIZE(TEXT("")));
                    hr = HRESULT_FROM_WIN32(lRet);
                }
            }
        }

        RegCloseKey(hKey);
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: Install registry info based upon which shell we're running

*/
HRESULT InstallIEAssociations(DWORD dwFlags)   // IEA_* flags
{
    int i;
    UINT nInstall = WhichPlatform();
    BOOL bDontIntrude = TRUE;
    
    // If IE was the default browser before (or the registry is messed up)
    // or setup is forcing us to register then we want to force IE to be 
    // the default browser
    if (ShouldIEBeDefaultBrowser() || IsFlagSet(dwFlags, IEA_FORCEIE))
        bDontIntrude = FALSE;
    
    // Install file and protocol associations
    
    InstallRegAssoc(nInstall, bDontIntrude);
    
    // Install other registry settings
    
    switch (nInstall)
    {
    case PLATFORM_BROWSERONLY:
        for (i = 0; i < ARRAYSIZE(g_rgprsIE30Only); i++)  
        {
            InstallRegSet(g_rgprsIE30Only[i], bDontIntrude);
        }
        break;
        
    case PLATFORM_INTEGRATED:
        for (i = 0; i < ARRAYSIZE(g_rgprsNashOnly); i++)  
        {
            InstallRegSet(g_rgprsNashOnly[i], bDontIntrude);
        }
        break;
        
    default:
        ASSERT(0);
        break;
    }
    
    InstallFTPAssociations();

    return NOERROR;
}


HRESULT UninstallPlatformRegItems(BOOL bIntegrated)
{
    int i;
    UINT uPlatform = bIntegrated ? PLATFORM_INTEGRATED : PLATFORM_BROWSERONLY;
    
    switch (uPlatform)
    {
    case PLATFORM_BROWSERONLY:
        for (i = 0; i < ARRAYSIZE(g_rgprsUninstallIE30); i++)  
        {
            InstallRegSet(g_rgprsUninstallIE30[i], FALSE);
        }
        break;
        
    case PLATFORM_INTEGRATED:
        for (i = 0; i < ARRAYSIZE(g_rgprsUninstallNash); i++)  
        {
            InstallRegSet(g_rgprsUninstallNash[i], FALSE);
        }
        break;
        
    default:
        // Don't do anything
        break;
    }
    
    return NOERROR;
}

void UninstallCurrentPlatformRegItems()
{
    CHAR sz[MAX_PATH + 20];    // add some padding for arguments
    DWORD cbData = SIZEOF(sz);
    if (NO_ERROR == SHGetValueA(HKEY_CLASSES_ROOT, c_szHTMOpenNewCmd, "",
                               NULL, sz, &cbData))
    {
        // Remove IE4 shell integrated settings
        UninstallPlatformRegItems(TRUE);
    }
    else if (AreWeInstallingOverIE())
    {
        // Remove IE3 / browser only settings
        UninstallPlatformRegItems(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\iedde.h ===
#ifndef _IEDDE_H
#define _IEDDE_H

BOOL IEDDE_Initialize(void);
void IEDDE_Uninitialize(void);
void IEDDE_AutomationStarted(void);
BOOL IEDDE_RunDelayedExecute();
HRESULT IEDDE_BeforeNavigate(LPCWSTR pwszURL, BOOL *pfCanceled);
HRESULT IEDDE_AfterNavigate(LPCWSTR pwszURL, HWND hwnd);
BOOL IEDDE_NewWindow(HWND hwnd);
BOOL IEDDE_WindowDestroyed(HWND hwnd);

#endif  //_IEDDE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\iface.h ===
#ifndef _IFACE_H
#define _IFACE_H

// Interfaces and IIDs defined here are private to shdocvw.dll
//


//
// IDocNavigate
//
// DocHost needs to notify the browser of certain events
//
//131A6950-7F78-11D0-A979-00C04FD705A2
#undef  INTERFACE
#define INTERFACE  IDocNavigate
DECLARE_INTERFACE_(IDocNavigate, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDocNavigate methods ***
    STDMETHOD(OnReadyStateChange)(THIS_ IShellView* psvSource, DWORD dwReadyState) PURE;
    STDMETHOD(get_ReadyState)(THIS_ DWORD * pdwReadyState) PURE;

} ;

//
// IBandNavigate
//
//  band needs to navigate its UI to a specific pidl.
//
#undef  INTERFACE
#define INTERFACE  IBandNavigate
DECLARE_INTERFACE_(IBandNavigate, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IBandNavigate methods ***
    STDMETHOD(Select)(THIS_ LPCITEMIDLIST pidl) PURE;

} ;


//
// IEFrameAuto
//
// CIEFrameAuto private interface to hold randum stuff
//
//131A6953-7F78-11D0-A979-00C04FD705A2
#undef  INTERFACE
#define INTERFACE  IEFrameAuto
DECLARE_INTERFACE_(IEFrameAuto, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IEFrameAuto methods ***
    STDMETHOD(SetOwnerHwnd)(THIS_ HWND hwndOwner) PURE;
    STDMETHOD(put_DefaultReadyState)(THIS_ DWORD dwDefaultReadyState, BOOL fUpdateBrowserReadyState) PURE;
    STDMETHOD(OnDocumentComplete)(THIS) PURE;
    STDMETHOD(OnWindowsListMarshalled)(THIS) PURE;
    STDMETHOD(SetDocHostFlags)(THIS_ DWORD dwDocHostFlags) PURE;
};

//
// IPrivateOleObject
//
// a cut down version of IOleObject used for the WebBrowserOC to communicate with
// objects hosted via CDocObjectView
#undef INTERFACE
#define INTERFACE IPrivateOleObject
DECLARE_INTERFACE_(IPrivateOleObject, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID *ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // IPrivateOleObject
    STDMETHOD( SetExtent )( DWORD dwDrawAspect, SIZEL *psizel) PURE;
    STDMETHOD( GetExtent )( DWORD dwDrawAspect, SIZEL *psizel) PURE;
};


STDAPI AddUrlToUrlHistoryStg(LPCWSTR pwszUrl, LPCWSTR pwszTitle, LPUNKNOWN punk, 
                             BOOL fWriteToHistory, IOleCommandTarget *poctNotify, IUnknown *punkSFHistory,
                             UINT* pcodepage);

#ifdef __cplusplus
//
// IUrlHistoryPriv
//
interface IUrlHistoryPriv : IUrlHistoryStg2
{
    STDMETHOD(QueryUrlA)(LPCSTR pszUrl, DWORD dwFlags, LPSTATURL lpSTATURL) = 0;
    STDMETHOD(CleanupHistory)(void) = 0;
    STDMETHOD_(DWORD,GetDaysToKeep)(void) = 0;
    STDMETHOD(GetProperty)(LPCTSTR pszUrl, PROPID pid, PROPVARIANT* pvarOut) = 0;
    STDMETHOD(GetUserName)(LPTSTR pszUserName, DWORD cchUserName) = 0;
    STDMETHOD(AddUrlAndNotifyCP)(LPCWSTR pwszUrl, LPCWSTR pwszTitle, DWORD dwFlags, BOOL fWriteHistory, IOleCommandTarget *poctNotify, IUnknown *punkSFHistory, UINT* pcodepage) = 0;
};


#define URLFLAG_DONT_DELETE_SUBSCRIBED  0x10000000

extern IUrlHistoryPriv* g_puhUrlHistory;

//
// LATER: Move all ITravelLog/ITravelEntry definitions here
//
// TLOG_BACKEXTERNAL -- succeeds only if the previous entry is external
//
#define TLOG_BACKEXTERNAL   -0x7fffffff

#endif // __cplusplus

#endif // _IFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\iforms.cpp ===
// iforms.cpp : Implementation of CIntelliForms

#include "priv.h"
#include <iehelpid.h>
#include <pstore.h>
#include "hlframe.h"
#include "iformsp.h"
#include "shldisp.h"
#include "opsprof.h"
#include "resource.h"

#include <mluisupp.h>


// {E161255A-37C3-11d2-BCAA-00C04FD929DB}
static const GUID c_PStoreType =
{ 0xe161255a, 0x37c3, 0x11d2, { 0xbc, 0xaa, 0x0, 0xc0, 0x4f, 0xd9, 0x29, 0xdb } };
const TCHAR c_szIntelliForms[] = TEXT("Internet Explorer");

#define TF_IFORMS TF_CUSTOM2

// ALLOW_SHELLUIOC_HOST code will allow us to host intelliforms
//  from the Shell UI OC (shuioc.cpp). This is used for the
//  HTML Find dialog
#define ALLOW_SHELLUIOC_HOST

CIntelliForms *GetIntelliFormsFromDoc(IHTMLDocument2 *pDoc2);

inline void MyToLower(LPWSTR pwszStr)
{
    if (g_fRunningOnNT)
    {
        CharLowerBuffW(pwszStr, lstrlenW(pwszStr));
    }
    else
    {
        // Ideally we would use the code page contained in the string instead of
        //  the system code page.
        CHAR chBuf[MAX_PATH];
        SHUnicodeToAnsi(pwszStr, chBuf, ARRAYSIZE(chBuf));
        CharLowerBuffA(chBuf, lstrlenA(chBuf));
        SHAnsiToUnicode(chBuf, pwszStr, lstrlenW(pwszStr)+1);
    }
}


//=================== Exported functions =====================
// Exported for inetCPL
HRESULT ClearAutoSuggestForForms(DWORD dwClear)
{
    CIntelliForms *pObj = new CIntelliForms();

    if (pObj)
    {
        HRESULT hr;

        hr = pObj->ClearStore(dwClear);

        pObj->Release();

        return hr;
    }

    return E_OUTOFMEMORY;
}

HRESULT SetIdAutoSuggestForForms(const GUID *pguidId, void *pIntelliForms)
{
    CIntelliForms *pThis = (CIntelliForms *)pIntelliForms;

    if (pThis)
    {
        if (GUID_NULL == *pguidId)
        {
            pThis->m_guidUserId = c_PStoreType;
        }
        else
        {
            pThis->m_guidUserId = *pguidId;
        }

        return S_OK;
    }

    return E_FAIL;
}


// called from iedisp.cpp
void AttachIntelliForms(void *pvOmWindow, HWND hwnd, IHTMLDocument2 *pDoc2, void **ppIntelliForms)
{
static DWORD s_dwAdminRestricted = 0xFE;

    CIEFrameAuto::COmWindow *pOmWindow = (CIEFrameAuto::COmWindow *)pvOmWindow;

    ASSERT(ppIntelliForms && *ppIntelliForms==NULL);

    if (s_dwAdminRestricted == 0xFE)
    {
        s_dwAdminRestricted = CIntelliForms::IsAdminRestricted(c_szRegValFormSuggestRestrict) &&
                              CIntelliForms::IsAdminRestricted(c_szRegValSavePasswords);
    }

    if (s_dwAdminRestricted)
    {
        return;
    }

    // If we're not hosted by internet explorer, we don't want to enable Intelliforms
    //  unless dochost explicitly overrides this
    if (!IsInternetExplorerApp() &&
        !(pOmWindow && (DOCHOSTUIFLAG_ENABLE_FORMS_AUTOCOMPLETE & pOmWindow->IEFrameAuto()->GetDocHostFlags())))
    {
        return;
    }

    if (!hwnd && pOmWindow)
    {
        pOmWindow->IEFrameAuto()->get_HWND((LONG_PTR *)&hwnd);
    }

    if (!hwnd || !pDoc2 || !ppIntelliForms || (*ppIntelliForms != NULL))
    {
        return;
    }

#ifndef ALLOW_SHELLUIOC_HOST
    if (!pOmWindow)
    {
        return;
    }
#else
    if (!pOmWindow)
    {
        // Script is asking to attach to this document
        // Deny their request if another CIntelliForms is already attached
        if (NULL != GetIntelliFormsFromDoc(pDoc2))
        {
            return;
        }
    }
#endif

    CIntelliForms *pForms = new CIntelliForms();

    if (pForms)
    {
        if (SUCCEEDED(pForms->Init(pOmWindow, pDoc2, hwnd)))
        {
            *ppIntelliForms = pForms;
        }
        else
        {
            pForms->Release();
        }
    }
}

void ReleaseIntelliForms(void *pIntelliForms)
{
    CIntelliForms *pForms = (CIntelliForms *) pIntelliForms;

    if (pForms)
    {
        pForms->UnInit();
        pForms->Release();
    }
}

HRESULT IntelliFormsActiveElementChanged(void *pIntelliForms, IHTMLElement * pHTMLElement)
{
    CIntelliForms *pForms = (CIntelliForms *) pIntelliForms;

    if (pForms)
        return pForms->ActiveElementChanged(pHTMLElement);
    return E_FAIL;
}

INT_PTR CALLBACK AskUserDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
HRESULT IncrementAskCount();

HRESULT IntelliFormsDoAskUser(HWND hwndBrowser, void *pv)
{
    // Make sure that we haven't asked them yet
    if (S_OK == IncrementAskCount())
    {
        // Modal dialog to ask the user our little question
        SHFusionDialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_AUTOSUGGEST_ASK_USER),
                hwndBrowser, AskUserDlgProc, NULL);
    }

    return S_OK;
}

// Linked list of active CIntelliform objects to translate from
//  IHTMLDocument2->CIntelliforms when script calls window.external.saveforms
// Protected by g_csDll
CIntelliForms *g_pIntelliFormsFirst=NULL;

// Translate this pDoc2 to an existing instance of CIntelliForms
// Will return NULL if no CIntelliForms attached to this doc
// NO REFCOUNT IS ADDED TO THE RETURN
CIntelliForms *GetIntelliFormsFromDoc(IHTMLDocument2 *pDoc2)
{
    if (!pDoc2)
    {
        return NULL;
    }

    ENTERCRITICAL;
    CIntelliForms *pNext = g_pIntelliFormsFirst;
    IUnknown *punkDoc;
    CIntelliForms *pIForms=NULL;

    pDoc2->QueryInterface(IID_IUnknown, (void **)&punkDoc);

    if (punkDoc)
    {
        while (pNext)
        {
            if (pNext->GetDocument() == punkDoc)
            {
                pIForms = pNext;
                break;
            }
            pNext=pNext->GetNext();
        }

        punkDoc->Release();
    }

    LEAVECRITICAL;

    return pIForms;
}

// called from shuioc.cpp
HRESULT IntelliFormsSaveForm(IHTMLDocument2 *pDoc2, VARIANT *pvarForm)
{
    HRESULT hrRet = S_FALSE;
    IHTMLFormElement *pForm=NULL;
    CIntelliForms *pIForms=NULL;

    if (pvarForm->vt == VT_DISPATCH)
    {
        pvarForm->pdispVal->QueryInterface(IID_IHTMLFormElement, (void **)&pForm);
    }

    if (pForm)
    {
        pIForms = GetIntelliFormsFromDoc(pDoc2);

        if (pIForms)
        {
            // Should validate that pIForms was created on this thread
            hrRet = pIForms->ScriptSubmit(pForm);
        }

        pForm->Release();
    }

    return hrRet;
}

const TCHAR c_szYes[] = TEXT("yes");
const TCHAR c_szNo[] = TEXT("no");

INT_PTR AutoSuggestDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);

#ifdef CHECKBOX_HELP
const DWORD c_aIFormsHelpIds[] = {
        IDC_AUTOSUGGEST_NEVER, IDH_INTELLIFORM_PW_PROMPT,
        0, 0
};
#endif

const WCHAR c_wszVCardPrefix[] = L"vCard.";

BOOL CIntelliForms::CAutoSuggest::s_fRegisteredWndClass = FALSE;

// Must be in same order as EVENT enum type
// All events we need to sink anywhere
CEventSinkCallback::EventSinkEntry CEventSinkCallback::EventsToSink[] =
{
    { EVENT_KEYDOWN,    L"onkeydown",   L"keydown"  },
    { EVENT_KEYPRESS,   L"onkeypress",  L"keypress" },
    { EVENT_MOUSEDOWN,  L"onmousedown", L"mousedown"},
    { EVENT_DBLCLICK,   L"ondblclick",  L"dblclick" },
    { EVENT_FOCUS,      L"onfocus",     L"focus"    },
    { EVENT_BLUR,       L"onblur",      L"blur"     },
    { EVENT_SUBMIT,     L"onsubmit",    L"submit"   },
    { EVENT_SCROLL,     L"onscroll",    L"scroll"   },
    { EVENT_COMPOSITION,NULL,           L"composition"},
    { EVENT_NOTIFY,     NULL,           L"notify"   },
};

// Fake edit window class
const WCHAR c_szEditWndClass[] = TEXT("IntelliFormClass");

// Minimum dropdown width
const int MINIMUM_WIDTH=100;

// Submit number to ask user to enable us
const int ASK_USER_ON_SUBMIT_N = 2;

void GetStuffFromEle(IUnknown *punkEle, IHTMLWindow2 **ppWin2, IHTMLDocument2 **ppDoc2)
{
    if (ppWin2)
        *ppWin2=NULL;

    if (ppDoc2)
        *ppDoc2=NULL;

    IHTMLElement *pEle=NULL;
    punkEle->QueryInterface(IID_IHTMLElement, (void **)&pEle);

    if (pEle)
    {
        IDispatch *pDisp=NULL;
        pEle->get_document(&pDisp);
        if (pDisp)
        {
            IHTMLDocument2 *pDoc2 = NULL;
            pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc2);
            if (pDoc2)
            {
                if (ppWin2)
                {
                    pDoc2->get_parentWindow(ppWin2);
                }

                if (ppDoc2)
                {
                    *ppDoc2 = pDoc2;
                }
                else
                {
                    pDoc2->Release();
                }
            }
            pDisp->Release();
        }

        pEle->Release();
    }
}

void Win3FromDoc2(IHTMLDocument2 *pDoc2, IHTMLWindow3 **ppWin3)
{
    *ppWin3=NULL;

    IHTMLWindow2 *pWin2=NULL;

    if (SUCCEEDED(pDoc2->get_parentWindow(&pWin2)) && pWin2)
    {
        pWin2->QueryInterface(IID_IHTMLWindow3, (void **)ppWin3);
        pWin2->Release();
    }
}

// Increment the count of whether we've asked the user to enable us or not. We won't
//  ask them on the first form submit since installing ie5.
HRESULT IncrementAskCount()
{
    DWORD dwData, dwSize, dwType;
    dwSize = sizeof(dwData);

    // c_szRegValAskUser contains the number of form submits
    //  0 means we've already asked user whether to enable us
    //  1 means we've already had one form submit, and should ask the user this time
    //  value not present means we haven't had any form submits

    if ((ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER,
            c_szRegKeyIntelliForms, c_szRegValAskUser, &dwType, &dwData, &dwSize)) &&
        dwType == REG_DWORD)
    {
        if (dwData == 0)
        {
            // Shouldn't get this far
            TraceMsg(TF_IFORMS|TF_WARNING, "IntelliFormsDoAskUser: Already asked user");
            return E_FAIL;      // Already asked user
        }
    }
    else
    {
        dwData = 0;
    }

    if (dwData+1 < ASK_USER_ON_SUBMIT_N)
    {
        dwData ++;
        SHSetValue(HKEY_CURRENT_USER, c_szRegKeyIntelliForms, c_szRegValAskUser,
            REG_DWORD, &dwData, sizeof(dwData));

        TraceMsg(TF_IFORMS, "IntelliFormsDoAskUser incrementing submit count. Not asking user.");

        return E_FAIL;      // Don't ask the user
    }

    return S_OK;            // Let's ask the user
}


/////////////////////////////////////////////////////////////////////////////
// CIntelliForms

CIntelliForms::CIntelliForms()
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CIntelliForms");

    m_cRef = 1;

    m_iRestoredIndex = -1;

    m_fRestricted = IsAdminRestricted(c_szRegValFormSuggestRestrict);
    m_fRestrictedPW = IsAdminRestricted(c_szRegValSavePasswords);
    m_guidUserId = c_PStoreType;
    
    // Add us to global linked list
    ENTERCRITICAL;
    m_pNext = g_pIntelliFormsFirst;
    g_pIntelliFormsFirst = this;
    LEAVECRITICAL;
}

CIntelliForms::~CIntelliForms()
{
    // Remove us from global linked list
    ENTERCRITICAL;

    CIntelliForms *pLast=NULL, *pNext = g_pIntelliFormsFirst;

    while (pNext && pNext != this)
    {
        pLast = pNext;
        pNext=pNext->m_pNext;
    }

    ASSERT(pNext == this);

    if (pNext)
    {
        if (pLast)
        {
            pLast->m_pNext = m_pNext;
        }
        else
        {
            g_pIntelliFormsFirst = m_pNext;
        }
    }
    LEAVECRITICAL;

    TraceMsg(TF_IFORMS, "CIntelliForms::~CIntelliForms");
}

// Called when document is ready to attach to
// We don't support re-initting
HRESULT CIntelliForms::Init(CIEFrameAuto::COmWindow *pOmWindow, IHTMLDocument2 *pDoc2, HWND hwndBrowser)
{
    HRESULT hr;

    ASSERT(pDoc2 && hwndBrowser);

#ifndef ALLOW_SHELLUIOC_HOST
    if (pOmWindow == NULL)
    {
        return E_INVALIDARG;
    }
#endif

    // Connect to get active element changed notifications

    m_pOmWindow = pOmWindow;
    if (pOmWindow)
    {
        pOmWindow->AddRef();
    }

    m_pDoc2 = pDoc2;
    pDoc2->AddRef();
    pDoc2->QueryInterface(IID_IUnknown, (void **)&m_punkDoc2);

    m_hwndBrowser = hwndBrowser;

    m_iRestoredIndex = -1;

    hr = S_OK;

#ifdef ALLOW_SHELLUIOC_HOST
    if (!pOmWindow && (hr == S_OK))
    {
        // Check for the current active element since the page is requesting
        //  us to attach to an existing document
        IHTMLElement *pHTMLElement = NULL;

        m_pDoc2->get_activeElement(&pHTMLElement);
        ActiveElementChanged(pHTMLElement);

        if (pHTMLElement)
            pHTMLElement->Release();
    }
#endif

    GetUrl();       // Init Url member variables so we don't get the url on the
                    //   wrong thread in the FillEnumerator call

    TraceMsg(TF_IFORMS, "CIntelliForms::Init hr=%08x", hr);

    return hr;
}

HRESULT CIntelliForms::UnInit()
{
    if (m_fInModalDialog)
    {
        // Lifetime management. If UnInit is called during modal dialog, we keep ourself
        //  alive. Use Enter/LeaveModalDialog to ensure correct use
        ASSERT(m_fUninitCalled == FALSE);       // Should only be called once...
        m_fUninitCalled = TRUE;
        return S_FALSE;
    }


    // Destroy this now, before we free other member variables, to ensure CAutoSuggest doesn't
    //  try to access us on a second thread.
    if (m_pAutoSuggest)
    {
        m_pAutoSuggest->SetParent(NULL);
        m_pAutoSuggest->DetachFromInput();
        delete m_pAutoSuggest;
        m_pAutoSuggest = NULL;
    }

    if (m_hdpaForms && m_pSink)
    {
        IHTMLElement2 *pEle2;
        EVENTS events[] = { EVENT_SUBMIT };

        for (int i=DPA_GetPtrCount(m_hdpaForms)-1; i>=0; i--)
        {
            ((IHTMLFormElement *)(DPA_FastGetPtr(m_hdpaForms, i)))->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);
            m_pSink->UnSinkEvents(pEle2, ARRAYSIZE(events), events);
            pEle2->Release();
        }
    }

    SysFreeString(m_bstrFullUrl);
    m_bstrFullUrl = NULL;

    SysFreeString(m_bstrUrl);
    m_bstrUrl = NULL;

    if (m_pwszUrlHash)
    {
        LocalFree((void *)m_pwszUrlHash);
        m_pwszUrlHash = NULL;
    }

    // Unhook regular event sink
    if (m_pSink)
    {
#ifndef ALLOW_SHELLUIOC_HOST
        ASSERT(m_pOmWindow);
#endif
        if (m_pOmWindow)
        {
            IHTMLWindow3 *pWin3=NULL;

            Win3FromDoc2(m_pDoc2, &pWin3);

            if (pWin3)
            {
                EVENTS events[] = { EVENT_SCROLL };
                m_pSink->UnSinkEvents(pWin3, ARRAYSIZE(events), events);
                pWin3->Release();
            }
        }

        m_pSink->SetParent(NULL);
        m_pSink->Release();
        m_pSink=NULL;
    }

    // Unhook designer event sink
    if (m_pEditSink)
    {
        m_pEditSink->Attach(NULL);
        m_pEditSink->SetParent(NULL);
        m_pEditSink->Release();
        m_pEditSink=NULL;
    }

    // SAFERELEASE (and ATOMICRELEASE) macro in shdocvw is actually function which requires IUnknown
    ATOMICRELEASET(m_pOmWindow, CIEFrameAuto::COmWindow);
    SAFERELEASE(m_pDoc2);
    SAFERELEASE(m_punkDoc2);

    FreeElementList();
    FreeFormList();

    if (m_pslPasswords)
    {
        delete m_pslPasswords;
        m_pslPasswords = NULL;
    }

    ReleasePStore();

    TraceMsg(TF_IFORMS, "CIntelliForms::UnInit");

    return S_OK;
}

STDMETHODIMP CIntelliForms::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if ((IID_IPropertyNotifySink == riid) ||
        (IID_IUnknown == riid))
    {
        *ppv = (IPropertyNotifySink *)this;
    }

    if (NULL != *ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CIntelliForms::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CIntelliForms::Release(void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}


HRESULT CIntelliForms::ActiveElementChanged(IHTMLElement * pHTMLElement)
{
    ASSERT(m_pDoc2);

    // Detach the AutoSuggest object and destroy it
    if (m_pAutoSuggest)
    {
        m_pAutoSuggest->DetachFromInput();
        delete m_pAutoSuggest;
        m_pAutoSuggest=NULL;
    }

    if (m_pDoc2)
    {
        IHTMLElement *pEle=pHTMLElement;

        if (pEle)
        {
            BOOL fPassword=FALSE;
            IHTMLInputTextElement *pTextEle = NULL;

            if (SUCCEEDED(ShouldAttachToElement(pEle, TRUE, NULL, &pTextEle, NULL, &fPassword)))
            {
                BOOL fEnabledInCPL = IsEnabledInCPL();
                BOOL fEnabledPW = IsEnabledRestorePW();

                // We need to watch user activity if...
                if (fEnabledInCPL ||        // Intelliforms is enabled
                    fEnabledPW ||           // Or Restore Passwords is enabled
                    !AskedUserToEnable())   // Or we may ask them to enable us
                {
                    m_pAutoSuggest = new CAutoSuggest(this, fEnabledInCPL, fEnabledPW);

                    if (m_pAutoSuggest)
                    {
                        if (!m_pSink)
                        {
                            m_pSink = new CEventSink(this);

                            if (m_pSink)
                            {
#ifndef ALLOW_SHELLUIOC_HOST
                                // Don't sink scroll event if hosted by ShellUIOC
                                //  or jscript.dll asserts on unload
                                ASSERT(m_pOmWindow);
#endif
                                if (m_pOmWindow)
                                {
                                    IHTMLWindow3 *pWin3=NULL;

                                    Win3FromDoc2(m_pDoc2, &pWin3);

                                    if (pWin3)
                                    {
                                        EVENTS events[] = { EVENT_SCROLL };
                                        m_pSink->SinkEvents(pWin3, ARRAYSIZE(events), events);
                                        pWin3->Release();
                                    }
                                }
                            }
                        }

                        // Hook up designer sink for IME event
                        if (!m_pEditSink)
                        {
                            m_pEditSink = new CEditEventSink(this);

                            if (m_pEditSink)
                            {
                                m_pEditSink->Attach(pEle);
                            }
                        }

                        if (!m_pSink || FAILED(m_pAutoSuggest->AttachToInput(pTextEle)))
                        {
                            delete m_pAutoSuggest;
                            m_pAutoSuggest = NULL;
                        }
                    }
                }

                pTextEle->Release();
            }
            else
            {
                ASSERT(!pTextEle);

                if (fPassword)
                {
                    m_fHitPWField = TRUE;
                }
            }
            //
            // Don't release pEle
        }
    }

    return S_OK;
}

// Helper functions
BOOL CIntelliForms::AskedUserToEnable()
{
    DWORD dwType, dwSize;
    DWORD dwVal;
    DWORD dwRet;

    dwSize = sizeof(dwVal);

    dwRet = SHGetValue(HKEY_CURRENT_USER, c_szRegKeyIntelliForms, c_szRegValAskUser,
                            &dwType, &dwVal, &dwSize);

    if ((dwRet == ERROR_SUCCESS) && (dwType == REG_DWORD))
    {
        return (dwVal == 0) ? TRUE : FALSE;
    }

    return FALSE;
}

BOOL CIntelliForms::IsEnabledInRegistry(LPCTSTR pszKey, LPCTSTR pszValue, BOOL fDefault)
{
    DWORD dwType, dwSize;
    TCHAR szEnabled[16];
    DWORD dwRet;

    dwSize = sizeof(szEnabled);

    dwRet = SHGetValue(HKEY_CURRENT_USER, pszKey, pszValue, &dwType, szEnabled, &dwSize);

    if (dwRet == ERROR_INSUFFICIENT_BUFFER)
    {
        // Invalid value in registry.
        ASSERT(dwRet == ERROR_SUCCESS);
        return FALSE;
    }

    if (dwRet == ERROR_SUCCESS)
    {
        if ((dwType == REG_SZ) &&
            (!StrCmp(szEnabled, TEXT("yes"))))
        {
            // Enabled
            return TRUE;
        }
        else
        {
            // Disabled
            return FALSE;
        }
    }

    // Value not found
    return fDefault;
}

BOOL CIntelliForms::IsAdminRestricted(LPCTSTR pszRegVal)
{
    DWORD lSize;
    DWORD  lValue;

    lValue = 0; // clear it
    lSize = sizeof(lValue);
    if (ERROR_SUCCESS !=
        SHGetValue(HKEY_CURRENT_USER, c_szRegKeyRestrict, pszRegVal, NULL, (LPBYTE)&lValue, &lSize ))
    {
        return FALSE;
    }

    ASSERT(lSize == sizeof(lValue));

    return (0 != lValue) ? TRUE : FALSE;
}

BOOL CIntelliForms::IsEnabledForPage()
{
    if (!m_fCheckedIfEnabled)
    {
        m_fCheckedIfEnabled = TRUE;

        // We will have our Url in m_bstrFullUrl, only if it is https: protocol
        if (m_bstrFullUrl)
        {
            ASSERT(!StrCmpNIW(m_bstrFullUrl, L"https:", 5));

            m_fEnabledForPage = TRUE;

            // See if this page is in the internet cache. If not, we won't intelliform
            //  for this page either.
            if (!GetUrlCacheEntryInfoW(m_bstrFullUrl, NULL, NULL) && (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
            {
                // Failed - it's not in the cache
                m_fEnabledForPage = FALSE;
            }
        }
        else
        {
            // Url is not https: so always enable Intelliforms
            m_fEnabledForPage = TRUE;
        }
    }

    return m_fEnabledForPage;
}

// static
BOOL CIntelliForms::IsElementEnabled(IHTMLElement *pEle)
{
    BOOL fEnabled=TRUE;
    BSTR bstrAttribute;

    VARIANT varVal;
    varVal.vt = VT_EMPTY;

    // First check "AutoComplete=OFF"
    bstrAttribute=SysAllocString(L"AutoComplete");

    if (bstrAttribute &&
        SUCCEEDED(pEle->getAttribute(bstrAttribute, 0, &varVal)))
    {
        if (varVal.vt == VT_BSTR)
        {
            if (!StrCmpIW(varVal.bstrVal, L"off"))
            {
                // We are disabled.
                fEnabled=FALSE;
            }
        }

        VariantClear(&varVal);
    }

    SysFreeString(bstrAttribute);

    // Then check "READONLY" attribute
    if (fEnabled)
    {
        IHTMLInputElement *pInputEle=NULL;

        pEle->QueryInterface(IID_IHTMLInputElement, (void **)&pInputEle);

        if (pInputEle)
        {
            VARIANT_BOOL vbReadOnly=VARIANT_FALSE;

            pInputEle->get_readOnly(&vbReadOnly);

            if (vbReadOnly)
            {
                // We are read only.
                fEnabled=FALSE;
            }

            pInputEle->Release();
        }
    }

    return fEnabled;
}

// static
HRESULT CIntelliForms::ShouldAttachToElement(IUnknown                *punkEle,
                                             BOOL                     fCheckForm,
                                             IHTMLElement2          **ppEle2,
                                             IHTMLInputTextElement  **ppITE,
                                             IHTMLFormElement       **ppFormEle,
                                             BOOL                    *pfPassword)
{
    IHTMLInputTextElement *pITE = NULL;

    if (ppEle2)
    {
        *ppEle2 = NULL;
    }

    if (ppITE)
    {
        *ppITE = NULL;
    }

    if (ppFormEle)
    {
        *ppFormEle = NULL;
    }

    punkEle->QueryInterface(IID_IHTMLInputTextElement, (void **)&pITE);

    if (NULL == pITE)
    {
        // Not an input text element. Do not attach.
        return E_FAIL;
    }

    HRESULT hr = E_FAIL;

    IHTMLElement2 *pEle2        = NULL;
    IHTMLElement *pEle          = NULL;
    IHTMLFormElement *pFormEle  = NULL;

    punkEle->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);
    punkEle->QueryInterface(IID_IHTMLElement, (void **)&pEle);

    if (pEle2 && pEle)
    {
        // type=text is all that's allowed
        BSTR bstrType=NULL;

        if (SUCCEEDED(pITE->get_type(&bstrType)) && bstrType)
        {
            if (!StrCmpICW(bstrType, L"text"))
            {
                // FormSuggest=off attribute turns us off for this element
                if (IsElementEnabled(pEle))
                {
                    IHTMLElement *pFormHTMLEle=NULL;

                    if (fCheckForm || ppFormEle)
                    {
                        pITE->get_form(&pFormEle);

                        if (pFormEle)
                        {
                            pFormEle->QueryInterface(IID_IHTMLElement, (void **)&pFormHTMLEle);
                        }
                        else
                        {
                            // This may be valid if element is not in form
                            TraceMsg(TF_IFORMS, "Iforms: pITE->get_form() returned NULL");
                        }
                    }

                    // FormSuggest=off for form turns us off for this form
                    if (pFormEle &&
                        (!fCheckForm || (pFormHTMLEle && IsElementEnabled(pFormHTMLEle))))
                    {
                        hr = S_OK;
                        if (ppEle2)
                        {
                            *ppEle2 = pEle2;
                            pEle2->AddRef();
                        }
                        if (ppFormEle)
                        {
                            *ppFormEle = pFormEle;
                            pFormEle->AddRef();
                        }
                        if (ppITE)
                        {
                            *ppITE = pITE;
                            pITE->AddRef();
                        }
                    }

                    SAFERELEASE(pFormHTMLEle);
                    SAFERELEASE(pFormEle);
                }
            }
            else
            {
                if (pfPassword && !StrCmpICW(bstrType, L"password") && IsElementEnabled(pEle))
                {
                    TraceMsg(TF_IFORMS, "IForms: Password field detected.");
                    *pfPassword = TRUE;
                }
            }

            SysFreeString(bstrType);
        }
        else
        {
            TraceMsg(TF_IFORMS, "IntelliForms disabled for single element via attribute");
        }
    }

    SAFERELEASE(pITE);
    SAFERELEASE(pEle2);
    SAFERELEASE(pEle);

    return hr;
}

// Get the URL that we're located at, with query string/anchor stripped.
LPCWSTR CIntelliForms::GetUrl()
{
    if (m_bstrUrl)
    {
        return m_bstrUrl;
    }

    if (m_pOmWindow)
    {
        m_pOmWindow->IEFrameAuto()->get_LocationURL(&m_bstrUrl);
    }
#ifdef ALLOW_SHELLUIOC_HOST
    else
    {
        IHTMLLocation *pHTMLLocation=NULL;

        m_pDoc2->get_location(&pHTMLLocation);

        if (NULL != pHTMLLocation)
        {
            pHTMLLocation->get_href(&m_bstrUrl);
            pHTMLLocation->Release();
        }
    }
#endif

    if (m_bstrUrl)
    {
        PARSEDURLW puW = {0};
        puW.cbSize = sizeof(puW);

        // Save the full url for a security check, if we are https protocol
        if (SUCCEEDED(ParseURLW(m_bstrUrl, &puW)))
        {
            if (puW.nScheme == URL_SCHEME_HTTPS)
            {
                m_bstrFullUrl = SysAllocString(m_bstrUrl);
                if (!m_bstrFullUrl)
                {
                    SysFreeString(m_bstrUrl);
                    m_bstrUrl=NULL;
                }
            }
        }
    }

    if (m_bstrUrl)
    {
        // Strip off any query string or anchor
        LPWSTR lpUrl = m_bstrUrl;
        while (*lpUrl)
        {
            if ((*lpUrl == L'?') || (*lpUrl == L'#'))
            {
                *lpUrl = L'\0';
                break;
            }
            lpUrl ++;
        }

        return m_bstrUrl;
    }

    TraceMsg(TF_WARNING|TF_IFORMS, "CIntelliForms::GetUrl() failing!");
    return L"";     // We can assume non-NULL pointer
}

// hook our "Submit" event sink to this form
HRESULT CIntelliForms::AttachToForm(IHTMLFormElement *pFormEle)
{
    ASSERT(m_pSink);

    if (m_pSink)
    {
        IHTMLElement2 *pEle2 = NULL;

        pFormEle->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);

        if (pEle2)
        {
            // Sink event for the form
            EVENTS events[] = { EVENT_SUBMIT };
            m_pSink->SinkEvents(pEle2, ARRAYSIZE(events), events);
        }

        SAFERELEASE(pEle2);

        return S_OK;
    }

    return E_OUTOFMEMORY;
}

// Returns TRUE if nothing but spaces in string
inline BOOL IsEmptyString(LPCWSTR lpwstr)
{
    while (*lpwstr && (*lpwstr == L' ')) lpwstr++;
    return (*lpwstr == 0);
}

// called for each element in the form we are submitting
HRESULT CIntelliForms::SubmitElement(IHTMLInputTextElement *pITE, FILETIME ftSubmit, BOOL fEnabledInCPL)
{
    if (m_fRestricted) return E_FAIL;

    HRESULT hrRet = S_OK;

    BSTR bstrName;

    CIntelliForms::GetName(pITE, &bstrName);

    if (bstrName && bstrName[0])
    {
        BSTR bstrValue=NULL;

        pITE->get_value(&bstrValue);

        if (bstrValue && bstrValue[0] && !IsEmptyString(bstrValue))
        {
            if (fEnabledInCPL)
            {
                TraceMsg(TF_IFORMS, "IForms: Saving field \"%ws\" as \"%ws\"", bstrName, bstrValue);

                CStringList *psl;

                if (FAILED(ReadFromStore(bstrName, &psl)))
                {
                    CStringList_New(&psl);
                }

                if (psl)
                {
                    HRESULT hr;

                    if (SUCCEEDED(hr = psl->AddString(bstrValue, ftSubmit)))
                    {
                        if ((S_OK == hr) ||
                            (psl->NumStrings() > CStringList::MAX_STRINGS / 4))
                        {
                            // We added a non-duplicate string, or we updated the
                            //  last submit time of an existing string
                            WriteToStore(bstrName, psl);
                        }
                    }

                    delete psl;
                }
            }
            else
            {
                hrRet = S_FALSE;   // Tell caller that we didn't save because we were disabled
            }
        }

        SysFreeString(bstrValue);
    }

    SysFreeString(bstrName);

    return hrRet;
}

HRESULT CIntelliForms::HandleFormSubmit(IHTMLFormElement *pForm)
{
    IUnknown *punkForm=NULL;

    if (!pForm)
    {
        // We currently require a form element even from script
        return E_INVALIDARG;
    }

    if (!m_hdpaElements || !m_hdpaForms)
    {
        return S_OK;
    }

    // Make sure we're enabled
    BOOL fEnabledInCPL = IsEnabledInCPL();
    if (fEnabledInCPL || IsEnabledRestorePW() || !AskedUserToEnable())
    {
        pForm->QueryInterface(IID_IUnknown, (void **)&punkForm);

        if (punkForm)
        {
            IHTMLFormElement *pThisFormEle;
            IUnknown *punkThisForm;
            FILETIME ftSubmit;
            int     iCount=0;
            BOOL    fShouldAskUser=FALSE;
            IHTMLInputTextElement *pFirstEle=NULL;

            GetSystemTimeAsFileTime(&ftSubmit);

            // Go through list of 'changed' elements and save their values
            //  make sure we loop backwards since we nuke elements as we find them
            for (int i=DPA_GetPtrCount(m_hdpaElements)-1; i>=0; i--)
            {
                IHTMLInputTextElement *pITE = ((IHTMLInputTextElement *)(DPA_FastGetPtr(m_hdpaElements, i)));

                if (SUCCEEDED(pITE->get_form(&pThisFormEle)) && pThisFormEle)
                {
                    if (SUCCEEDED(pThisFormEle->QueryInterface(IID_IUnknown, (void **)&punkThisForm)))
                    {
                        if (punkThisForm == punkForm)
                        {
                            // Verify that we're still allowed to save this element
                            if (SUCCEEDED(ShouldAttachToElement(pITE, TRUE, NULL, NULL, NULL, NULL)))
                            {
                                iCount ++;

                                if (!pFirstEle)
                                {
                                    pFirstEle = pITE;
                                    pFirstEle->AddRef();
                                }

                                // Don't save non-password stuff for non-cached pages
                                if (IsEnabledForPage())
                                {
                                    // Won't actually save the value if fEnabledInCPL is FALSE
                                    if (S_FALSE == SubmitElement(pITE, ftSubmit, fEnabledInCPL))
                                    {
                                        // We would have saved this if we were enabled
                                        fShouldAskUser = TRUE;
                                    }
                                }

                                // Remove this element from the DPA to prevent any possibility of
                                //  saving before more user input takes place
                                pITE->Release();
                                DPA_DeletePtr(m_hdpaElements, i);
                            }
                        }
                        else
                        {
                            TraceMsg(TF_IFORMS, "IForms: User input in different form than was submitted...?");
                        }

                        punkThisForm->Release();
                    }

                    pThisFormEle->Release();
                }
                else
                {
                    // It shouldn't be in our DPA if it isn't in a form...
                    TraceMsg(TF_WARNING|TF_IFORMS, "Iforms: pITE->get_form() returned NULL!");
                }
            }

            if (0 == DPA_GetPtrCount(m_hdpaElements))
            {
                DPA_Destroy(m_hdpaElements);
                m_hdpaElements=NULL;
            }

            if (m_fHitPWField || (m_iRestoredIndex != -1))
            {
                // ?? why not check iCount==1 here?
                if (pFirstEle)
                {
                    // May have restored PW and may have changed or entered it
                    SavePassword(pForm, ftSubmit, pFirstEle);

                    // WARNING - after returning from "SavePassword" our object may be invalid
                    //  if we got released/detached during modal dialog
                }
            }
            else if (fShouldAskUser)
            {
                // Possibly ask user if they want to enable intelliforms, only if
                //  this isn't a login
                if (m_pOmWindow)
                {
                    m_pOmWindow->IntelliFormsAskUser(NULL);
                }
                fShouldAskUser = FALSE;
            }

            if (fShouldAskUser)
            {
                // If we should ask the user but we're not going to (login form),
                //  increment our count anyway so that we ask them as soon as we can
                IncrementAskCount();
            }

            punkForm->Release();
            SAFERELEASE(pFirstEle);
        }
    }

    return S_OK;
}

HRESULT CIntelliForms::HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj)
{
    TraceMsg(TF_IFORMS, "CIntelliForms::HandleEvent Event=%ws", EventsToSink[Event].pwszEventName);

    if (Event == EVENT_SUBMIT)
    {
        // Save strings for modified text inputs when appropriate
        IHTMLFormElement *pFormEle = NULL;

        if (pEle)
        {
            pEle->QueryInterface(IID_IHTMLFormElement, (void **)&pFormEle);
            if (pFormEle)
            {
                HandleFormSubmit(pFormEle);
                // Warning - "this" may be detached/destroyed at this point
                pFormEle->Release();
            }
        }
    }
    else
    {
        ASSERT(Event == EVENT_SCROLL);
        if (m_pAutoSuggest)
            m_pAutoSuggest->UpdateDropdownPosition();
    }

    return S_OK;
}

HRESULT CIntelliForms::PreHandleEvent(DISPID inEvtDispId, IHTMLEventObj* pIEventObj)
{
    if ((inEvtDispId == 0) &&
        (m_pAutoSuggest != NULL) &&
        (m_pAutoSuggest->AttachedElement() != NULL))
    {
        BSTR bstrType = NULL;
        CEventSinkCallback::EVENTS Event = EVENT_BOGUS;

        pIEventObj->get_type(&bstrType);

        if (bstrType)
        {
            if (!StrCmp(bstrType, L"composition"))
            {
                Event = EVENT_COMPOSITION;
            }
            else if (!StrCmp(bstrType, L"notify"))
            {
                Event = EVENT_NOTIFY;
            }

            if (Event != EVENT_BOGUS)
            {
                // Trident doesn't set srcElement on eventobj, so just use the one
                // we're attached to
                IHTMLElement *pEle;

                m_pAutoSuggest->AttachedElement()->QueryInterface(IID_IHTMLElement, (void **)&pEle);

                if (pEle)
                {
                    m_pAutoSuggest->HandleEvent(pEle, Event, pIEventObj);
                    pEle->Release();
                }
            }

            SysFreeString(bstrType);
        }
        
    }

    return S_FALSE;     // S_FALSE so that Trident will still process this
}


// Our passwords are stored in username/value pairs
// Search every other string for the username
HRESULT CIntelliForms::FindPasswordEntry(LPCWSTR pwszValue, int *piIndex)
{
    ASSERT(m_pslPasswords);
    ASSERT(!(m_pslPasswords->NumStrings() & 1));   // Should be even number

    int i;

    for (i=0; i<m_pslPasswords->NumStrings(); i += 2)
    {
        if (!StrCmpIW(pwszValue, m_pslPasswords->GetString(i)))
        {
            // Found it
            *piIndex = i+1;
            return S_OK;
        }
    }

    return E_FAIL;
}

// Convert url to string based on shlwapi UrlHash return
LPCWSTR CIntelliForms::GetUrlHash()
{
    BYTE bBuf[15];

    if (m_pwszUrlHash)
    {
        return m_pwszUrlHash;
    }

    LPCWSTR pwszUrl = GetUrl();

    if (!pwszUrl || !*pwszUrl)
    {
        return NULL;
    }

    if (SUCCEEDED(UrlHashW(pwszUrl, bBuf, ARRAYSIZE(bBuf))))
    {
        // Translate this array of bytes into 7-bit chars
        m_pwszUrlHash = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*(ARRAYSIZE(bBuf)+1));

        if (m_pwszUrlHash)
        {
            for (int i=0; i<ARRAYSIZE(bBuf); i++)
            {
                // Translate each char into 32-96 range
                ((LPWSTR)m_pwszUrlHash)[i] = (WCHAR)((bBuf[i] & 0x3F) + 0x20);
            }
            ((LPWSTR)m_pwszUrlHash)[i] = L'\0';
        }

        return m_pwszUrlHash;
    }

    return NULL;
}

// Tells us if passwords are present for this url
BOOL CIntelliForms::ArePasswordsSaved()
{
    if (!m_fRestrictedPW)
    {
        DWORD dwVal, dwSize=sizeof(dwVal);
        LPCWSTR pwsz = GetUrlHash();

        if (pwsz && (ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, c_wszRegKeyIntelliFormsSPW, pwsz, NULL, &dwVal, &dwSize)))
        {
            return TRUE;
        }
    }

    return FALSE;
}

// Will return password list in m_pslPasswords, if passwords are saved
BOOL CIntelliForms::LoadPasswords()
{
    if (!m_fCheckedPW)
    {
        m_fCheckedPW = TRUE;

        // Check if passwords are present without hitting pstore
        if (ArePasswordsSaved())
        {
            // We should have passwords for this url. Hit PStore.
            ReadFromStore(GetUrl(), &m_pslPasswords, TRUE);

            m_iRestoredIndex = -1;
        }
    }
    else if (m_pslPasswords)
    {
        // If we already have passwords, double check the registry in case the user
        //  nuked saved stuff via inetcpl
        if (!ArePasswordsSaved())
        {
            delete m_pslPasswords;
            m_pslPasswords=NULL;
            m_iRestoredIndex = -1;
        }
    }

    return (m_pslPasswords != NULL);
}

void CIntelliForms::SavePasswords()
{
    if (m_pslPasswords && m_bstrUrl)
    {
        WriteToStore(m_bstrUrl, m_pslPasswords);
        SetPasswordsAreSaved(TRUE);
    }
}

// Mark that we have passwords saved for this url
void CIntelliForms::SetPasswordsAreSaved(BOOL fSaved)
{
    LPCWSTR pwsz = GetUrlHash();

    if (pwsz)
    {
        if (fSaved)
        {
            DWORD dwSize = sizeof(DWORD);
            DWORD dw = 0;
            SHSetValueW(HKEY_CURRENT_USER, c_wszRegKeyIntelliFormsSPW, pwsz, REG_DWORD, &dw, sizeof(dw));
        }
        else
        {
            SHDeleteValueW(HKEY_CURRENT_USER, c_wszRegKeyIntelliFormsSPW, pwsz);
        }

    }
}

// enumerates form & gets password fields
class CDetectLoginForm
{
public:
    CDetectLoginForm() { m_pNameEle=m_pPasswordEle=m_pPasswordEle2=NULL; }
    ~CDetectLoginForm() { SAFERELEASE(m_pNameEle); SAFERELEASE(m_pPasswordEle); }

    HRESULT ParseForm(IHTMLFormElement *pFormEle, BOOL fRestoring);

    IHTMLInputTextElement *GetNameEle() { return m_pNameEle; }
    IHTMLInputTextElement *GetPasswordEle() { return m_pPasswordEle; }

protected:
    IHTMLInputTextElement  *m_pNameEle;
    IHTMLInputTextElement  *m_pPasswordEle;

    IHTMLInputTextElement  *m_pPasswordEle2;

    static HRESULT s_PasswordCB(IDispatch *pDispEle, DWORD_PTR dwCBData);
};

// if SUCCEEDED(hr), GetNameEle and GetPasswordEle are guaranteed non-NULL
HRESULT CDetectLoginForm::ParseForm(IHTMLFormElement *pFormEle, BOOL fRestoring)
{
    if (m_pPasswordEle || m_pNameEle || m_pPasswordEle2)
    {
        return E_FAIL;
    }

    CIntelliForms::CEnumCollection<IHTMLFormElement>::EnumCollection(pFormEle, s_PasswordCB, (DWORD_PTR)this);

    // For forms with two password fields (possibly used for login *and* new accounts)
    //  we clear the second field on PW restore and require it to be blank for saving.
    // Ideally, we would detect this as a password change situation as well.
    if (m_pPasswordEle2)
    {
        if (fRestoring)
        {
            BSTR bstrEmpty=SysAllocString(L"");
            if (bstrEmpty)
            {
                m_pPasswordEle2->put_value(bstrEmpty);
                SysFreeString(bstrEmpty);
            }
        }
        else
        {
            BSTR bstrVal=NULL;

            m_pPasswordEle2->get_value(&bstrVal);

            if (bstrVal && bstrVal[0])
            {
                // Failure! Second password field isn't empty.
                SAFERELEASE(m_pNameEle);
                SAFERELEASE(m_pPasswordEle);
            }

            SysFreeString(bstrVal);
        }

        SAFERELEASE(m_pPasswordEle2);   // Always release this
    }

    if (m_pPasswordEle && m_pNameEle)
    {
        return S_OK;
    }

    SAFERELEASE(m_pNameEle);
    SAFERELEASE(m_pPasswordEle);
    ASSERT(!m_pPasswordEle2);

    return E_FAIL;
}

// Password callback for CEnumCollection to find username and password fields
//   in a login form
HRESULT CDetectLoginForm::s_PasswordCB(IDispatch *pDispEle, DWORD_PTR dwCBData)
{
    CDetectLoginForm *pThis = (CDetectLoginForm *)dwCBData;

    HRESULT hr=S_OK;

    IHTMLInputTextElement *pTextEle=NULL;

    pDispEle->QueryInterface(IID_IHTMLInputTextElement, (void **)&pTextEle);

    if (pTextEle)
    {
        BSTR bstrType;

        pTextEle->get_type(&bstrType);

        if (bstrType)
        {
            if (!StrCmpICW(bstrType, L"text"))
            {
                // Assume this is the 'name' field
                if (pThis->m_pNameEle)
                {
                    // Whoops, we've already got a name field. Can't have two...
                    hr = E_ABORT;
                }
                else
                {
                    pThis->m_pNameEle = pTextEle;
                    pTextEle->AddRef();
                }
            }
            else if (!StrCmpICW(bstrType, L"password"))
            {
                // Assume this is the 'password' field
                if (pThis->m_pPasswordEle)
                {
                    // Whoops, we've already got a password field. Can't have two...
                    //  ...oh wait, yes we can...
                    if (pThis->m_pPasswordEle2)
                    {
                        // ...but we definitely can't have three!!!
                        hr = E_ABORT;
                    }
                    else
                    {
                        pThis->m_pPasswordEle2 = pTextEle;
                        pTextEle->AddRef();
                    }
                }
                else
                {
                    pThis->m_pPasswordEle = pTextEle;
                    pTextEle->AddRef();
                }
            }

            SysFreeString(bstrType);
        }

        pTextEle->Release();
    }

    if (hr == E_ABORT)
    {
        SAFERELEASE(pThis->m_pNameEle);
        SAFERELEASE(pThis->m_pPasswordEle);
        SAFERELEASE(pThis->m_pPasswordEle2);
    }

    return hr;
}

// Fill in passwords for this username, if one is available
HRESULT CIntelliForms::AutoFillPassword(IHTMLInputTextElement *pTextEle, LPCWSTR pwszUsername)
{
    BSTR bstrUrl = NULL;

    if (!pTextEle || !pwszUsername)
        return E_INVALIDARG;

    if (!IsEnabledRestorePW() || !LoadPasswords())
    {
        // We have no passwords for this url
        return S_FALSE;
    }

    int iIndex;

    if (SUCCEEDED(FindPasswordEntry(pwszUsername, &iIndex)))
    {
        // Returns index of password in m_pslPasswords
        ASSERT(iIndex>=0 && iIndex<m_pslPasswords->NumStrings() && (iIndex&1));

        FILETIME ft;

        // StringTime==0 indicates user said "no" to saving password
        if (SUCCEEDED(m_pslPasswords->GetStringTime(iIndex, &ft)) && (FILETIME_TO_INT(ft) != 0))
        {
            TraceMsg(TF_IFORMS, "IntelliForms found saved password");

            // We have a password saved for this specific username. Fill it in.
            CDetectLoginForm LoginForm;
            IHTMLFormElement *pFormEle=NULL;
            HRESULT hr = E_FAIL;

            pTextEle->get_form(&pFormEle);
            if (pFormEle)
            {
                // See if this is a valid form: One plain text input, One password input. Find the fields.
                hr = LoginForm.ParseForm(pFormEle, TRUE);

                pFormEle->Release();
            }
            else
            {
                // Shouldn't get this far if we don't have a form for this element
                TraceMsg(TF_WARNING|TF_IFORMS, "Iforms: pITE->get_form() returned NULL!");
            }

            if (SUCCEEDED(hr))
            {
                BSTR bstrPW=NULL;
                m_pslPasswords->GetBSTR(iIndex, &bstrPW);
                if (bstrPW)
                {
                    LoginForm.GetPasswordEle()->put_value(bstrPW);
                    SysFreeString(bstrPW);
                    m_iRestoredIndex = iIndex;

                    // We restored this password. sink the SUBMIT for this form (if we haven't yet)
                    UserInput(pTextEle);
                }
            }
        }
        else
        {
            // User previously said 'no' to remembering passwords
            m_iRestoredIndex = -1;
        }
    }

    return S_OK;
}

HRESULT CIntelliForms::DeletePassword(LPCWSTR pwszUsername)
{
    // If we have a password, ask them if they want to delete it.
    if (LoadPasswords())
    {
        int iIndex;

        if (SUCCEEDED(FindPasswordEntry(pwszUsername, &iIndex)))
        {
            // If they previously said "no", delete without asking - they don't actually
            //  have a password saved
            // Otherwise, ask and delete only if they say "yes"
            FILETIME ft;
            if (FAILED(m_pslPasswords->GetStringTime(iIndex, &ft)) ||
                (0 == FILETIME_TO_INT(ft)) ||
                (IDYES == DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_AUTOSUGGEST_DELETEPASSWORD),
                                m_hwndBrowser, AutoSuggestDlgProc, IDD_AUTOSUGGEST_DELETEPASSWORD)))
            {
                // Delete username then password from string list
                if (SUCCEEDED(m_pslPasswords->DeleteString(iIndex-1)) &&
                    SUCCEEDED(m_pslPasswords->DeleteString(iIndex-1)))
                {
                    TraceMsg(TF_IFORMS, "Deleting password for user \"%ws\"", pwszUsername);
                    ASSERT(!(m_pslPasswords->NumStrings() & 1));

                    if (m_iRestoredIndex == iIndex)
                    {
                        m_iRestoredIndex = -1;
                    }
                    else if (m_iRestoredIndex > iIndex)
                    {
                        m_iRestoredIndex -= 2;
                    }

                    if (m_pslPasswords->NumStrings() == 0)
                    {
                        // No more strings for this url. Nuke it.
                        DeleteFromStore(GetUrl());
                        SetPasswordsAreSaved(FALSE);
                        delete m_pslPasswords;
                        m_pslPasswords = NULL;
                        ASSERT(m_iRestoredIndex == -1);
                    }
                    else
                    {
                        SavePasswords();
                    }
                }
            }
        }
    }

    return S_OK;
}

HRESULT CIntelliForms::SavePassword(IHTMLFormElement *pFormEle, FILETIME ftSubmit, IHTMLInputTextElement *pFirstEle)
{
    if (m_fRestrictedPW ||
        !IsEnabledRestorePW())
    {
        return S_FALSE;
    }

    BOOL fAskUser = TRUE;

    // First let's check for previously saved entries for this username
    if (LoadPasswords())
    {
        int iIndex;

        BSTR bstrUserName=NULL;

        pFirstEle->get_value(&bstrUserName);

        if (bstrUserName)
        {
            if (SUCCEEDED(FindPasswordEntry(bstrUserName, &iIndex)))
            {
                FILETIME ft;
                if (SUCCEEDED(m_pslPasswords->GetStringTime(iIndex, &ft)))
                {
                    if (FILETIME_TO_INT(ft) == 0)
                    {
                        // StringTime==0 means user previously said "no".
                        TraceMsg(TF_IFORMS, "IForms not asking about saving password");
                        fAskUser = FALSE;
                    }
                    else if (m_iRestoredIndex != iIndex)
                    {
                        // User previously said "yes" - but we didn't restore it for some reason
                        // Can happen with "back" button then submit
                        TraceMsg(TF_WARNING|TF_IFORMS, "IForms - user saved password and we didn't restore it");

                        // Write regkey in case that was the problem - we'll work next time
                        SetPasswordsAreSaved(TRUE);
                        m_iRestoredIndex = iIndex;
                    }
                }
            }
            else
            {
                m_iRestoredIndex = -1;
            }

            SysFreeString(bstrUserName);
        }
    }

    // Then lets ask the user if they'd like to save the password for this username
    if (fAskUser)
    {
        CDetectLoginForm LoginForm;

        // See if this is a valid form: One plain text input, One password input. Find the fields.

        if (SUCCEEDED(LoginForm.ParseForm(pFormEle, FALSE)))
        {
            TraceMsg(TF_IFORMS, "IForms Successfully detected 'save password' form");
            BSTR bstrUsername=NULL;
            BSTR bstrPassword=NULL;

            LoginForm.GetNameEle()->get_value(&bstrUsername);
            LoginForm.GetPasswordEle()->get_value(&bstrPassword);

            if (bstrUsername && bstrPassword)
            {
                if (m_iRestoredIndex != -1)
                {
                    // We have a previously saved password. See if our current entry is the same.
                    if (!StrCmpW(bstrPassword, m_pslPasswords->GetString(m_iRestoredIndex)))
                    {
                        // They're the same... nothing to do...
                        TraceMsg(TF_IFORMS, "IForms - user entered PW same as saved PW - nothing to do");
                        // Check to see that the username case is the same, just to be sure
                        if (StrCmpW(bstrUsername, m_pslPasswords->GetString(m_iRestoredIndex-1)))
                        {
                            TraceMsg(TF_IFORMS, "IForms - except change the username's case");
                            if (SUCCEEDED(m_pslPasswords->ReplaceString(m_iRestoredIndex-1, bstrUsername)))
                            {
                                SavePasswords();
                            }
                            else
                            {
                                // Something went horribly wrong!
                                delete m_pslPasswords;
                                m_pslPasswords=NULL;
                            }
                        }
                    }
                    else
                    {
                        // Ask the user if we want to change the saved password
                        INT_PTR iMB;

                        EnterModalDialog();

                        iMB = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_AUTOSUGGEST_CHANGEPASSWORD),
                                    m_hwndBrowser, AutoSuggestDlgProc, IDD_AUTOSUGGEST_CHANGEPASSWORD);

                        if (IDYES == iMB)
                        {
                            // Delete the old one and add the new one. Update filetimes.
                            if (SUCCEEDED(m_pslPasswords->ReplaceString(m_iRestoredIndex, bstrPassword)))
                            {
                                m_pslPasswords->SetStringTime(m_iRestoredIndex, ftSubmit);
                                SavePasswords();
                                TraceMsg(TF_IFORMS, "IForms successfully saved changed password");
                            }
                            else
                            {
                                TraceMsg(TF_IFORMS|TF_WARNING, "IForms couldn't change password!");
                                delete m_pslPasswords;
                                m_pslPasswords = NULL;
                            }
                        }

                        LeaveModalDialog();
                    }
                }
                else
                {
                    // We don't have a previously saved password for this user. See if they want to save it.
                    // If the password is empty, don't bother asking or saving
                    if (IsEnabledAskPW() && bstrPassword[0])
                    {
                        EnterModalDialog();

                        INT_PTR iMB = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_AUTOSUGGEST_SAVEPASSWORD),
                                        m_hwndBrowser, AutoSuggestDlgProc, IDD_AUTOSUGGEST_SAVEPASSWORD);

                        // If we can't load passwords, then create a new list
                        if (!LoadPasswords())
                        {
                            CStringList_New(&m_pslPasswords);
                            if (m_pslPasswords)
                                m_pslPasswords->SetListData(LIST_DATA_PASSWORD);
                        }

                        if (m_pslPasswords)
                        {
                            if ((IDCANCEL == iMB) || ((IDNO == iMB) && (!IsEnabledAskPW())))
                            {
                                // If they hit the close box or said "no" and checked "don't ask",
                                //  don't even save the username; we may ask them again next time
                            }
                            else
                            {
                                if (IDYES != iMB)
                                {
                                    // User said "no" but we save the username (no password) and
                                    //   set filetime to 0 which means they said "no"
                                    bstrPassword[0] = L'\0';
                                    ftSubmit.dwLowDateTime = ftSubmit.dwHighDateTime = 0;
                                }
                                else
                                {
                                    TraceMsg(TF_IFORMS, "IForms saving password for user %ws", bstrUsername);
                                }

                                m_pslPasswords->SetAutoScavenge(FALSE);

                                // Save the username and password, or just the username if they said "no"
                                if (SUCCEEDED(m_pslPasswords->AppendString(bstrUsername, ftSubmit)) &&
                                    SUCCEEDED(m_pslPasswords->AppendString(bstrPassword, ftSubmit)))
                                {
                                    SavePasswords();
                                }
                                else
                                {
                                    TraceMsg(TF_WARNING, "IForms couldn't save username/password");
                                    delete m_pslPasswords;
                                    m_pslPasswords=NULL;
                                }
                            }
                        }

                        LeaveModalDialog();
                    }
                }
            }

            SysFreeString(bstrUsername);
            SysFreeString(bstrPassword);
        } // if (SUCCEEDED(ParseForm()))
    }

    return S_OK;
}

// Returns reference to password string list if present. Return value must be used
//  immediately and not destroyed. Used only by CEnumString.
HRESULT CIntelliForms::GetPasswordStringList(CStringList **ppslPasswords)
{
    if (LoadPasswords())
    {
        *ppslPasswords = m_pslPasswords;
        return S_OK;
    }

    *ppslPasswords = NULL;
    return E_FAIL;
}


HRESULT CIntelliForms::CreatePStore()
{
    if (!m_pPStore)
    {
        if (!m_hinstPStore)
        {
            m_hinstPStore = LoadLibrary(TEXT("PSTOREC.DLL"));
        }

        if (m_hinstPStore)
        {
            HRESULT (* pfn)(IPStore **, PST_PROVIDERID *, void *, DWORD) = NULL;

            *(FARPROC *)&pfn = GetProcAddress(m_hinstPStore, "PStoreCreateInstance");

            if (pfn)
            {
                pfn(&m_pPStore, NULL, NULL, 0);
            }
        }
    }

    return m_pPStore ? S_OK : E_FAIL;
}

void CIntelliForms::ReleasePStore()
{
    SAFERELEASE(m_pPStore);
    if (m_hinstPStore)
    {
        FreeLibrary(m_hinstPStore);
        m_hinstPStore = NULL;
    }

    m_fPStoreTypeInit=FALSE;
}

HRESULT CIntelliForms::CreatePStoreAndType()
{
    HRESULT hr;

    hr = CreatePStore();

    if (SUCCEEDED(hr) && !m_fPStoreTypeInit)
    {
        PST_TYPEINFO    typeInfo;

        typeInfo.cbSize = sizeof(typeInfo);
        typeInfo.szDisplayName = (LPTSTR)c_szIntelliForms;

        hr = m_pPStore->CreateType(PST_KEY_CURRENT_USER, &c_PStoreType, &typeInfo, 0);

        if (hr == PST_E_TYPE_EXISTS)
        {
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            hr = m_pPStore->CreateSubtype(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, &typeInfo, NULL, 0);

            if (hr == PST_E_TYPE_EXISTS)
            {
                hr = S_OK;
            }
        }

        if (SUCCEEDED(hr))
        {
            m_fPStoreTypeInit = TRUE;
        }
    }

    return hr;
}

const WCHAR c_szBlob1Value[] = L"StringIndex";
const WCHAR c_szBlob2Value[] = L"StringData";

HRESULT CIntelliForms::WriteToStore(LPCWSTR pwszName, CStringList *psl)
{
    HRESULT hr = E_FAIL;

    TraceMsg(TF_IFORMS, "+WriteToStore");

    if (SUCCEEDED(CreatePStoreAndType()))
    {
        LPBYTE pBlob1, pBlob2;
        DWORD  cbBlob1, cbBlob2;

        if (SUCCEEDED(psl->WriteToBlobs(&pBlob1, &cbBlob1, &pBlob2, &cbBlob2)))
        {
            PST_PROMPTINFO  promptInfo;

            promptInfo.cbSize = sizeof(promptInfo);
            promptInfo.dwPromptFlags = 0;
            promptInfo.hwndApp = NULL;
            promptInfo.szPrompt = NULL;

            LPWSTR pwszValue;

            int iValLen = lstrlenW(c_szBlob1Value) + lstrlenW(pwszName) + 10;

            pwszValue = (LPWSTR) LocalAlloc(LMEM_FIXED, iValLen * sizeof(WCHAR));

            if (pwszValue)
            {
                // Write Index
                wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob1Value);
                hr = m_pPStore->WriteItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue,
                                        cbBlob1,
                                        pBlob1,
                                        &promptInfo, PST_CF_NONE, 0);

                if (FAILED(hr))
                {
                    TraceMsg(TF_WARNING | TF_IFORMS, "Failure writing Blob1 (Index).  hr=%x", hr);
                }
                else
                {
                    // Wrote Index successfully.  Write data.
                    wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob2Value);
                    hr = m_pPStore->WriteItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue,
                                            cbBlob2,
                                            pBlob2,
                                            &promptInfo, PST_CF_NONE, 0);
                    if (FAILED(hr))
                    {
                        // IE6#16676: This call failed on 64-bit Windows.  Added a warning trace here to facilitate
                        // future debugging.
                        TraceMsg(TF_WARNING | TF_IFORMS, "Failure writing Blob2 (Data).  hr=%x", hr);
                    }
                }

                // If *either* WriteItem failed, we really need to delete both the Index and the Data.
                //
                if (FAILED(hr))
                {
                    // Delete bogus Blobs

                    // Delete Index Blob
                    wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob1Value);
                    if (FAILED(m_pPStore->DeleteItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue, &promptInfo, 0)))
                    {
                        TraceMsg(TF_ERROR | TF_IFORMS, "Failure deleting Blob1 (Index).  hr=%x", hr);
                    }

                    // Delete Data Blob
                    wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob2Value);
                    if (FAILED(m_pPStore->DeleteItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue, &promptInfo, 0)))
                    {
                        TraceMsg(TF_ERROR | TF_IFORMS, "Failure deleting Blob2 (Data).  hr=%x", hr);
                    }
                }

                LocalFree(pwszValue);
                pwszValue = NULL;
            }

            if (pBlob1)
            {
                LocalFree(pBlob1);
                pBlob1 = NULL;
            }

            if (pBlob2)
            {
                LocalFree(pBlob2);
                pBlob2 = NULL;
            }
        }
    }

    TraceMsg(TF_IFORMS, "-WriteToStore");

    return hr;
}

HRESULT CIntelliForms::ReadFromStore(LPCWSTR pwszName, CStringList **ppsl, BOOL fPasswordList/*=FALSE*/)
{
    HRESULT hr = E_FAIL;

    TraceMsg(TF_IFORMS, "+ReadFromStore");

    *ppsl=NULL;

    if (SUCCEEDED(CreatePStore()))
    {
        PST_PROMPTINFO  promptInfo;

        promptInfo.cbSize = sizeof(promptInfo);
        promptInfo.dwPromptFlags = 0;
        promptInfo.hwndApp = NULL;
        promptInfo.szPrompt = NULL;

        LPWSTR pwszValue;

        int iValLen = lstrlenW(c_szBlob1Value) + lstrlenW(pwszName) + 10;

        pwszValue = (LPWSTR) LocalAlloc(LMEM_FIXED, iValLen * sizeof(WCHAR));

        if (pwszValue)
        {
            DWORD dwBlob1Size, dwBlob2Size;
            LPBYTE pBlob1=NULL, pBlob2=NULL;

            wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob1Value);
            hr = m_pPStore->ReadItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue,
                                    &dwBlob1Size,
                                    &pBlob1,
                                    &promptInfo, 0);

            if (SUCCEEDED(hr))
            {
                wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob2Value);
                hr = m_pPStore->ReadItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue,
                                        &dwBlob2Size,
                                        &pBlob2,
                                        &promptInfo, 0);

                if (SUCCEEDED(hr))
                {
                    // bogus... have to reallocate here... bogus... bogus...
                    LPBYTE pBlob1b, pBlob2b;

                    pBlob1b=(LPBYTE)LocalAlloc(LMEM_FIXED, dwBlob1Size);
                    pBlob2b=(LPBYTE)LocalAlloc(LMEM_FIXED, dwBlob2Size);

                    if (pBlob1b && pBlob2b)
                    {
                        memcpy(pBlob1b, pBlob1, dwBlob1Size);
                        memcpy(pBlob2b, pBlob2, dwBlob2Size);

                        CStringList_New(ppsl);
                        if (*ppsl)
                        {
                            hr = (*ppsl)->ReadFromBlobs(&pBlob1b, dwBlob1Size, &pBlob2b, dwBlob2Size);

                            if (SUCCEEDED(hr))
                            {
                                INT64 i;

                                if (FAILED((*ppsl)->GetListData(&i)) ||
                                    ((fPasswordList && !(i & LIST_DATA_PASSWORD)) ||
                                     (!fPasswordList && (i & LIST_DATA_PASSWORD))))
                                {
                                    TraceMsg(TF_WARNING|TF_IFORMS, "IForms: Password/nonpassword lists mixed up");
                                    hr = E_FAIL;    // don't allow malicious site to access PW data
                                }
                            }

                            if (FAILED(hr))
                            {
                                delete *ppsl;
                                *ppsl=NULL;
                            }
                        }
                    }
                    else
                    {
                        if (pBlob1b)
                        {
                            LocalFree(pBlob1b);
                            pBlob1b = NULL;
                        }

                        if (pBlob2b)
                        {
                            LocalFree(pBlob2b);
                            pBlob2b = NULL;
                        }
                    }
                }
                else
                {
                    TraceMsg(TF_IFORMS, "Failed reading Blob2.  hr=%x", hr);
                }
            }
            else
            {
                TraceMsg(TF_IFORMS, "Failed reading Blob1.  hr=%x", hr);
            }

            LocalFree(pwszValue);
            pwszValue = NULL;

            if (pBlob1)
            {
                CoTaskMemFree(pBlob1);
                pBlob1 = NULL;
            }

            if (pBlob2)
            {
                CoTaskMemFree(pBlob2);
                pBlob2 = NULL;
            }
        }
    }

    TraceMsg(TF_IFORMS, "-ReadFromStore");

    return hr;
}

HRESULT CIntelliForms::DeleteFromStore(LPCWSTR pwszName)
{
    HRESULT hr=E_FAIL;

    if (SUCCEEDED(CreatePStore()))
    {
        HRESULT hr1, hr2;
        LPWSTR pwszValue;

        int iValLen = lstrlenW(c_szBlob1Value) + lstrlenW(pwszName) + 10;

        pwszValue = (LPWSTR) LocalAlloc(LMEM_FIXED, iValLen * sizeof(WCHAR));

        if (pwszValue)
        {
            PST_PROMPTINFO  promptInfo;

            promptInfo.cbSize = sizeof(promptInfo);
            promptInfo.dwPromptFlags = 0;
            promptInfo.hwndApp = NULL;
            promptInfo.szPrompt = NULL;

            wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob1Value);
            hr1 = m_pPStore->DeleteItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue, &promptInfo, 0);

            wnsprintfW(pwszValue, iValLen, L"%s:%s", pwszName, c_szBlob2Value);
            hr2 = m_pPStore->DeleteItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszValue, &promptInfo, 0);

            if (SUCCEEDED(hr1) && SUCCEEDED(hr2))
            {
                hr = S_OK;
            }

            LocalFree(pwszValue);
            pwszValue = NULL;
        }
    }

    return hr;
}


const int c_iEnumSize=256;

HRESULT CIntelliForms::ClearStore(DWORD dwClear)
{
    BOOL fReleasePStore = (m_pPStore == NULL);

    ASSERT(dwClear <= 2);

    if (dwClear > 2)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(CreatePStoreAndType()))
    {
        IEnumPStoreItems *pEnumItems;
        ULONG cFetched=0;

        do
        {
            if (SUCCEEDED(m_pPStore->EnumItems(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, 0, &pEnumItems)))
            {
                LPWSTR pwszName[c_iEnumSize];
                PST_PROMPTINFO  promptInfo;

                promptInfo.cbSize = sizeof(promptInfo);
                promptInfo.dwPromptFlags = 0;
                promptInfo.hwndApp = NULL;
                promptInfo.szPrompt = NULL;

                // Enumerator doesn't keep its state - deleting items while we enumerate makes us
                //  miss some. It does support celt>1... but returns failure codes when it succeeds.
                cFetched = 0;

                pEnumItems->Next(c_iEnumSize, pwszName, &cFetched);

                if (cFetched)
                {
                    for (ULONG i=0; i<cFetched; i++)
                    {
                        ASSERT(pwszName[i]);
                        if (pwszName[i])
                        {
                            BOOL fDelete = TRUE;

                            // Hack to work around PStore string-case bug: first take their
                            //  enum value literally, then convert to lowercase and do it
                            //  again; IE5.0 #71001
                            for (int iHack=0; iHack<2; iHack++)
                            {
                                if (iHack == 1)
                                {
                                    // Convert the pwszName[i] to lowercase... only before
                                    //  the colon...
                                    WCHAR *pwch = StrRChrW(pwszName[i], NULL, L':');
                                    if (pwch)
                                    {
                                        *pwch = L'\0';
                                        MyToLower(pwszName[i]);
                                        *pwch = L':';
                                    }
                                    else
                                        break;
                                }

                                if (dwClear != IECMDID_ARG_CLEAR_FORMS_ALL)
                                {
                                    fDelete = FALSE;

                                    // See if this is a password item or not
                                    // This is pretty annoying. Since our string lists are split
                                    //  into two blobs, we need to find out which one this is and
                                    //  load the index for it.
                                    WCHAR *pwch = StrRChrW(pwszName[i], NULL, L':');
                                    if (pwch)
                                    {
                                        LPWSTR pwszIndexName=NULL;
                                        if (!StrCmpCW(pwch+1, c_szBlob2Value))
                                        {
                                            int cch = lstrlenW(pwszName[i]) + 10;
                                            pwszIndexName = (LPWSTR) LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * cch);
                                            if (pwszIndexName)
                                            {
                                                *pwch = L'\0';
                                                wnsprintfW(pwszIndexName, cch, L"%s:%s", pwszName[i], c_szBlob1Value);
                                                *pwch = L':';
                                            }
                                        }

                                        DWORD dwBlob1Size;
                                        LPBYTE pBlob1=NULL;
                                        INT64 iFlags;

                                        if (SUCCEEDED(m_pPStore->ReadItem(
                                                PST_KEY_CURRENT_USER,
                                                &c_PStoreType, &m_guidUserId,
                                                (pwszIndexName) ? pwszIndexName : pwszName[i],
                                                &dwBlob1Size,
                                                &pBlob1,
                                                &promptInfo, 0)) && pBlob1)
                                        {
                                            if (SUCCEEDED(CStringList::GetFlagsFromIndex(pBlob1, &iFlags)))
                                            {
                                                if (((iFlags & LIST_DATA_PASSWORD) && (dwClear == IECMDID_ARG_CLEAR_FORMS_PASSWORDS_ONLY)) ||
                                                    (!(iFlags & LIST_DATA_PASSWORD) && (dwClear == IECMDID_ARG_CLEAR_FORMS_ALL_BUT_PASSWORDS)))
                                                {
                                                    // Delete this item
                                                    fDelete = TRUE;
                                                }
                                            }

                                            CoTaskMemFree(pBlob1);
                                        }
                                        else
                                        {
                                            // The index is already deleted
                                            fDelete = TRUE;
                                        }

                                        if (pwszIndexName)
                                        {
                                            LocalFree(pwszIndexName);
                                            pwszIndexName = NULL;
                                        }
                                    }
                                } // if (dwClear != CLEAR_INTELLIFORMS_ALL)

                                if (fDelete)
                                {
                                    m_pPStore->DeleteItem(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, pwszName[i], &promptInfo, 0);
                                }
                            } // for (iHack)

                            CoTaskMemFree(pwszName[i]);
                        } // if (pwszName[i])
                    }
                }

                pEnumItems->Release();
            }
        }
        while (cFetched == c_iEnumSize);  // In case we didn't cover everything in one pass

        if (dwClear == IECMDID_ARG_CLEAR_FORMS_ALL)
        {
            m_pPStore->DeleteSubtype(PST_KEY_CURRENT_USER, &c_PStoreType, &m_guidUserId, 0);
            m_pPStore->DeleteType(PST_KEY_CURRENT_USER, &c_PStoreType, 0);
        }

        if ((dwClear == IECMDID_ARG_CLEAR_FORMS_ALL) ||
            (dwClear == IECMDID_ARG_CLEAR_FORMS_PASSWORDS_ONLY))
        {
            // Delete the urlhash key storing which urls we have passwords saved for
            SHDeleteKey(HKEY_CURRENT_USER, c_szRegKeyIntelliForms);
        }

        TraceMsg(TF_IFORMS, "IForms: ClearStore cleared at least %d entries", cFetched);
    }

    if (fReleasePStore)
    {
        ReleasePStore();
    }

    return S_OK;
}

// static: Get the name from an input element - uses VCARD_NAME attribute if present.
HRESULT CIntelliForms::GetName(IHTMLInputTextElement *pTextEle, BSTR *pbstrName)
{
    IHTMLElement *pEle=NULL;

    *pbstrName = NULL;

    pTextEle->QueryInterface(IID_IHTMLElement, (void **)&pEle);

    if (pEle)
    {
        BSTR bstrAttr = SysAllocString(L"VCARD_NAME");

        if (bstrAttr)
        {
            VARIANT var;
            var.vt = VT_EMPTY;

            pEle->getAttribute(bstrAttr, 0, &var);

            if (var.vt == VT_BSTR && var.bstrVal)
            {
                *pbstrName = var.bstrVal;
            }
            else
            {
                VariantClear(&var);
            }

            SysFreeString(bstrAttr);
        }

        pEle->Release();
    }

    if (!*pbstrName)
    {
        pTextEle->get_name(pbstrName);
    }

    // Convert the name to lowercase
    if (*pbstrName)
    {
        // Call "MyToLower" instead
        if (g_fRunningOnNT)
        {
            CharLowerBuffW(*pbstrName, lstrlenW(*pbstrName));
        }
        else
        {
            // Ideally we would use the code page contained in the string instead of
            //  the system code page.
            CHAR chBuf[MAX_PATH];
            SHUnicodeToAnsi(*pbstrName, chBuf, ARRAYSIZE(chBuf));
            CharLowerBuffA(chBuf, lstrlenA(chBuf));
            SHAnsiToUnicode(chBuf, *pbstrName, SysStringLen(*pbstrName)+1);
        }
    }

    return (*pbstrName) ? S_OK : E_FAIL;
}

// Called when script calls window.external.AutoCompleteSaveForm
HRESULT CIntelliForms::ScriptSubmit(IHTMLFormElement *pForm)
{
    HRESULT hr = E_FAIL;

    if (pForm)
    {
        hr = HandleFormSubmit(pForm);
    }

    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}


// Called when user changes a text field. Mark it "dirty" and sink submit event for form
HRESULT CIntelliForms::UserInput(IHTMLInputTextElement *pTextEle)
{
    AddToElementList(pTextEle);

    IHTMLFormElement *pForm=NULL;
    pTextEle->get_form(&pForm);

    if (pForm)
    {
        if (S_OK == AddToFormList(pForm))
        {
            AttachToForm(pForm);
        }

        pForm->Release();
    }
    else
    {
        TraceMsg(TF_WARNING|TF_IFORMS, "Iforms: pITE->get_form() returned NULL!");
    }


    return S_OK;
}

HRESULT CIntelliForms::AddToElementList(IHTMLInputTextElement *pITE)
{
    if (m_hdpaElements)
    {
        if (SUCCEEDED(FindInElementList(pITE)))
        {
            return S_FALSE;
        }
    }
    else
    {
        m_hdpaElements = DPA_Create(4);
    }

    if (m_hdpaElements)
    {
        TraceMsg(TF_IFORMS, "CIntelliForms::AddToElementList adding");

        if (DPA_AppendPtr(m_hdpaElements, pITE) >= 0)
        {
            pITE->AddRef();
            return S_OK;
        }
    }

    return E_OUTOFMEMORY;
}

HRESULT CIntelliForms::FindInElementList(IHTMLInputTextElement *pITE)
{
    IUnknown *punk;
    HRESULT hr = E_FAIL;

    pITE->QueryInterface(IID_IUnknown, (void **)&punk);

    if (m_hdpaElements)
    {
        for (int i=DPA_GetPtrCount(m_hdpaElements)-1; i>=0; i--)
        {
            IUnknown *punk2;

            ((IUnknown *)DPA_FastGetPtr(m_hdpaElements, i))->QueryInterface(IID_IUnknown, (void **)&punk2);

            if (punk == punk2)
            {
                punk2->Release();
                break;
            }

            punk2->Release();
        }

        if (i >= 0)
        {
            hr = S_OK;
        }
    }

    punk->Release();

    return hr;
}

void CIntelliForms::FreeElementList()
{
    if (m_hdpaElements)
    {
        for (int i=DPA_GetPtrCount(m_hdpaElements)-1; i>=0; i--)
        {
            ((IUnknown *)(DPA_FastGetPtr(m_hdpaElements, i)))->Release();
        }

        DPA_Destroy(m_hdpaElements);
        m_hdpaElements=NULL;
    }
}

HRESULT CIntelliForms::AddToFormList(IHTMLFormElement *pFormEle)
{
    if (m_hdpaForms)
    {
        if (SUCCEEDED(FindInFormList(pFormEle)))
        {
            return S_FALSE;
        }
    }
    else
    {
        m_hdpaForms = DPA_Create(2);
    }

    if (m_hdpaForms)
    {
        if (DPA_AppendPtr(m_hdpaForms, pFormEle) >= 0)
        {
            TraceMsg(TF_IFORMS, "CIntelliForms::AddToFormList adding");

            pFormEle->AddRef();
            return S_OK;
        }
    }

    return E_OUTOFMEMORY;
}

HRESULT CIntelliForms::FindInFormList(IHTMLFormElement *pFormEle)
{
    IUnknown *punk;
    HRESULT hr = E_FAIL;

    pFormEle->QueryInterface(IID_IUnknown, (void **)&punk);

    if (m_hdpaForms)
    {
        for (int i=DPA_GetPtrCount(m_hdpaForms)-1; i>=0; i--)
        {
            IUnknown *punk2;

            ((IUnknown *)DPA_FastGetPtr(m_hdpaForms, i))->QueryInterface(IID_IUnknown, (void **)&punk2);

            if (punk == punk2)
            {
                punk2->Release();
                break;
            }

            punk2->Release();
        }

        if (i >= 0)
        {
            hr = S_OK;
        }
    }

    punk->Release();

    return hr;
}

void CIntelliForms::FreeFormList()
{
    if (m_hdpaForms)
    {
        for (int i=DPA_GetPtrCount(m_hdpaForms)-1; i>=0; i--)
        {
            ((IUnknown *)(DPA_FastGetPtr(m_hdpaForms, i)))->Release();
        }

        DPA_Destroy(m_hdpaForms);
        m_hdpaForms = NULL;
    }
}

//=========================================================================
//
// Event sinking class
//
//  We simply implement IDispatch and make a call into our parent when
//   we receive a sinked event.
//
//=========================================================================
CIntelliForms::CEventSink::CEventSink(CEventSinkCallback *pParent)
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CEventSink::CEventSink");
    DllAddRef();
    m_cRef = 1;
    m_pParent = pParent;
}

CIntelliForms::CEventSink::~CEventSink()
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CEventSink::~CEventSink");
    ASSERT( m_cRef == 0 );
    DllRelease();
}

STDMETHODIMP CIntelliForms::CEventSink::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if ((IID_IDispatch == riid) ||
        (IID_IUnknown == riid))
    {
        *ppv = (IDispatch *)this;
    }

    if (NULL != *ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CIntelliForms::CEventSink::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CIntelliForms::CEventSink::Release(void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CIntelliForms::CEventSink::SinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents)
{
    VARIANT_BOOL bSuccess = VARIANT_TRUE;

    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pEle2->attachEvent(bstrEvent, (IDispatch *)this, &bSuccess);

            SysFreeString(bstrEvent);
        }
        else
        {
            bSuccess = VARIANT_FALSE;
        }

        if (!bSuccess)
            break;
    }

    return (bSuccess) ? S_OK : E_FAIL;
}

HRESULT CIntelliForms::CEventSink::SinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents)
{
    VARIANT_BOOL bSuccess = VARIANT_TRUE;

    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pWin3->attachEvent(bstrEvent, (IDispatch *)this, &bSuccess);

            SysFreeString(bstrEvent);
        }
        else
        {
            bSuccess = VARIANT_FALSE;
        }

        if (!bSuccess)
            break;
    }

    return (bSuccess) ? S_OK : E_FAIL;
}

HRESULT CIntelliForms::CEventSink::UnSinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents)
{
    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pEle2->detachEvent(bstrEvent, (IDispatch *)this);

            SysFreeString(bstrEvent);
        }
    }

    return S_OK;
}

HRESULT CIntelliForms::CEventSink::UnSinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents)
{
    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pWin3->detachEvent(bstrEvent, (IDispatch *)this);

            SysFreeString(bstrEvent);
        }
    }

    return S_OK;
}

// IDispatch
STDMETHODIMP CIntelliForms::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CIntelliForms::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
            /* [in] */ LCID /*lcid*/,
            /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CIntelliForms::CEventSink::GetIDsOfNames(
                REFIID          riid,
                OLECHAR**       rgszNames,
                UINT            cNames,
                LCID            lcid,
                DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

STDMETHODIMP CIntelliForms::CEventSink::Invoke(
            DISPID dispIdMember,
            REFIID, LCID,
            WORD wFlags,
            DISPPARAMS* pDispParams,
            VARIANT* pVarResult,
            EXCEPINFO*,
            UINT* puArgErr)
{
    if (m_pParent && pDispParams && pDispParams->cArgs>=1)
    {
        if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
        {
            IHTMLEventObj *pObj=NULL;

            if (SUCCEEDED(pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pObj) && pObj))
            {
                EVENTS Event=EVENT_BOGUS;
                BSTR bstrEvent=NULL;

                pObj->get_type(&bstrEvent);

                if (bstrEvent)
                {
                    for (int i=0; i<ARRAYSIZE(CEventSinkCallback::EventsToSink); i++)
                    {
                        if (!StrCmpCW(bstrEvent, CEventSinkCallback::EventsToSink[i].pwszEventName))
                        {
                            Event = (EVENTS) i;
                            break;
                        }
                    }

                    SysFreeString(bstrEvent);
                }

                if (Event != EVENT_BOGUS)
                {
                    IHTMLElement *pEle=NULL;

                    pObj->get_srcElement(&pEle);

                    // EVENT_SCROLL comes from our window so we won't have an
                    //  element for it
                    if (pEle || (Event == EVENT_SCROLL))
                    {
                        // Call the event handler here
                        m_pParent->HandleEvent(pEle, Event, pObj);

                        if (pEle)
                        {
                            pEle->Release();
                        }
                    }
                }

                pObj->Release();
            }
        }
    }

    return S_OK;
}

//=========================================================================
//
// Event sinking class
//
//  We implement IHTMLEditDesigner and make a call into our parent when
//   we receive any event.
//
//=========================================================================
CIntelliForms::CEditEventSink::CEditEventSink(CEditEventSinkCallback *pParent)
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CEditEventSink::CEditEventSink");
    DllAddRef();
    m_cRef = 1;
    m_pParent = pParent;
}

CIntelliForms::CEditEventSink::~CEditEventSink()
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CEditEventSink::~CEditEventSink");
    ASSERT(m_cRef == 0);
    ASSERT(!m_pEditServices);
    DllRelease();
}

STDMETHODIMP CIntelliForms::CEditEventSink::QueryInterface(REFIID riid, void **ppv)
{
    if ((IID_IHTMLEditDesigner == riid) ||
        (IID_IUnknown == riid))
    {
        *ppv = SAFECAST(this, IHTMLEditDesigner *);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG) CIntelliForms::CEditEventSink::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CIntelliForms::CEditEventSink::Release(void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CIntelliForms::CEditEventSink::Attach(IUnknown *punkElement)
{
    HRESULT hr = S_OK;

    // Detach from any existing element
    if (m_pEditServices)
    {
        m_pEditServices->RemoveDesigner(this);
        m_pEditServices->Release();
        m_pEditServices = NULL;
    }

    // Attach to any new element
    if (punkElement)
    {
        hr = E_FAIL;

        IHTMLDocument2 *pDoc2 = NULL;
        GetStuffFromEle(punkElement, NULL, &pDoc2);

        if (pDoc2)
        {
            IServiceProvider *pSP = NULL;

            pDoc2->QueryInterface(IID_IServiceProvider, (void **)&pSP);

            if (pSP)
            {
                pSP->QueryService(SID_SHTMLEditServices, IID_IHTMLEditServices, (void **)&m_pEditServices);
                pSP->Release();
            }

            if (m_pEditServices)
            {
                hr = m_pEditServices->AddDesigner(this);
            }

            pDoc2->Release();
        }
    }

    return hr;
}

HRESULT CIntelliForms::CEditEventSink::PreHandleEvent(DISPID inEvtDispId, IHTMLEventObj *pIEventObj)
{
    if (m_pParent)
    {
        return m_pParent->PreHandleEvent(inEvtDispId, pIEventObj);
    }

    return S_FALSE;
}

HRESULT CIntelliForms::CEditEventSink::PostHandleEvent(DISPID inEvtDispId, IHTMLEventObj *pIEventObj)
{
    return S_FALSE;
}

HRESULT CIntelliForms::CEditEventSink::TranslateAccelerator(DISPID inEvtDispId, IHTMLEventObj *pIEventObj)
{
    return S_FALSE;
}


//=========================================================================
//
// AutoSuggest class
//
// Handles connecting and disconnecting the AutoComplete object, as well
//  as translating between Trident OM and Edit window messages
//=========================================================================

CIntelliForms::CAutoSuggest::CAutoSuggest(CIntelliForms *pParent, BOOL fEnabled, BOOL fEnabledPW)
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::CAutoSuggest");

    m_pParent = pParent;
    m_fEnabled = fEnabled;
    m_fEnabledPW = fEnabledPW;

    ASSERT(m_pEventSink == NULL);
    ASSERT(m_pAutoComplete == NULL);
    ASSERT(m_hwndEdit == NULL);
    ASSERT(m_pTextEle == NULL);

    //
    // bug 81414 : To avoid clashing with app messages used by the edit window, we 
    // use registered messages.
    //
    m_uMsgItemActivate = RegisterWindowMessageA("AC_ItemActivate");
    if (m_uMsgItemActivate == 0)
    {
        m_uMsgItemActivate = WM_APP + 301;
    }

    // Register our window class if necessary
    if (!s_fRegisteredWndClass)
    {
        s_fRegisteredWndClass = TRUE;

        WNDCLASSEXW wndclass =
        {
            sizeof(WNDCLASSEX),
            0,
            CIntelliForms::CAutoSuggest::WndProc,
            0,
            sizeof(DWORD_PTR),
            g_hinst,
            NULL,
            NULL,
            NULL,
            NULL,
            c_szEditWndClass
        };

        if (!RegisterClassEx(&wndclass))
        {
            TraceMsg(TF_IFORMS, "Intelliforms failed to register wnd class!");
        }
    }
}

CIntelliForms::CAutoSuggest::~CAutoSuggest()
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::~CAutoSuggest");
    CleanUp();
}

HRESULT CIntelliForms::CAutoSuggest::CleanUp()
{
    SetParent(NULL);
    DetachFromInput();

    return S_OK;
}

// List of all events we sink for an individual INPUT tag
// post IE5.5 we can use CEditEventSink instead of CEventSink for all of these events.
CEventSinkCallback::EVENTS CIntelliForms::CAutoSuggest::s_EventsToSink[] =
        {
            EVENT_KEYPRESS,
            EVENT_KEYDOWN,
            EVENT_MOUSEDOWN,
            EVENT_DBLCLICK,
            EVENT_FOCUS,
            EVENT_BLUR,
        };

HRESULT CIntelliForms::CAutoSuggest::AttachToInput(IHTMLInputTextElement *pTextEle)
{
    HRESULT hr;

    TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::AttachToInput");

    if (!pTextEle)
        return E_INVALIDARG;

    hr = DetachFromInput();

    if (SUCCEEDED(hr))
    {
        m_pTextEle = pTextEle;
        pTextEle->AddRef();

        if (!m_pEventSink)
        {
            m_pEventSink = new CEventSink(this);

            if (!m_pEventSink)
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (SUCCEEDED(hr))
        {
            // Hook up our event sink
            IHTMLElement2 *pEle2=NULL;

            hr = pTextEle->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);

            if (pEle2)
            {
                hr = m_pEventSink->SinkEvents(pEle2, ARRAYSIZE(s_EventsToSink), s_EventsToSink);

                pEle2->Release();
            }
        }
    }

    if (FAILED(hr))
    {
        TraceMsg(TF_IFORMS, "IForms: AttachToInput failed");
        DetachFromInput();
    }

    return hr;
}

HRESULT CIntelliForms::CAutoSuggest::DetachFromInput()
{
    if (!m_pTextEle)
    {
        return S_FALSE;
    }

    TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::DetachFromInput");

    // Auto Fill Password here, since we get ACTIVEELEMENT change before blur event
    BSTR bstrUsername=NULL;
    m_pTextEle->get_value(&bstrUsername);
    if (bstrUsername)
    {
        CheckAutoFillPassword(bstrUsername);
        SysFreeString(bstrUsername);
    }

    if (m_bstrLastUsername)
    {
        SysFreeString(m_bstrLastUsername);
        m_bstrLastUsername=NULL;
    }

    if (m_hwndEdit)
    {
        // This is for subclass wndproc
        SendMessage(m_hwndEdit, WM_KILLFOCUS, 0, 0);
    }

    if (m_pEnumString)
    {
        m_pEnumString->UnInit();
        m_pEnumString->Release();
        m_pEnumString = NULL;
    }

    if (m_pEventSink)
    {
        IHTMLElement2 *pEle2=NULL;

        m_pTextEle->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);

        if (pEle2)
        {
            m_pEventSink->UnSinkEvents(pEle2, ARRAYSIZE(s_EventsToSink), s_EventsToSink);
            pEle2->Release();
        }

        m_pEventSink->SetParent(NULL);
        m_pEventSink->Release();
        m_pEventSink=NULL;
    }

    SAFERELEASE(m_pAutoComplete);
    SAFERELEASE(m_pAutoCompleteDD);

    if (m_hwndEdit)
    {
        DestroyWindow(m_hwndEdit);
        m_hwndEdit = NULL;
    }

    SAFERELEASE(m_pTextEle);

    m_fInitAutoComplete = FALSE;

    return S_OK;
}

// Creates autocomplete and string enumerator.
HRESULT CIntelliForms::CAutoSuggest::CreateAutoComplete()
{
    if (m_fInitAutoComplete)
    {
        return (m_pAutoCompleteDD != NULL) ? S_OK : E_FAIL;
    }

    HRESULT hr = S_OK;

    ASSERT(!m_hwndEdit && !m_pEnumString && !m_pAutoComplete && !m_pAutoCompleteDD);

    // Create the edit window
#ifndef UNIX
    m_hwndEdit = CreateWindowEx(0, c_szEditWndClass, TEXT("IntelliFormProxy"), WS_POPUP,
#else
    m_hwndEdit = CreateWindowEx(WS_EX_MW_UNMANAGED_WINDOW, c_szEditWndClass, TEXT("IntelliFormProxy"), WS_POPUP,
#endif
        300, 200, 200, 50, m_pParent->m_hwndBrowser, NULL, g_hinst, this);

    if (!m_hwndEdit)
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        // Create our enumerator
        m_pEnumString = new CEnumString();

        if (m_pEnumString)
        {
            m_pEnumString->Init(m_pTextEle, m_pParent);

            // Create the AutoComplete Object
            if (!m_pAutoComplete)
            {
                hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_IAutoComplete2, (void **)&m_pAutoComplete);
                if (m_pAutoComplete)
                {
                    m_pAutoComplete->QueryInterface(IID_IAutoCompleteDropDown, (void **)&m_pAutoCompleteDD);
                    if (!m_pAutoCompleteDD)
                    {
                        SAFERELEASE(m_pAutoComplete);
                    }
                }
            }

            if (m_pAutoComplete)
            {
                hr = m_pAutoComplete->Init(m_hwndEdit, (IUnknown *) m_pEnumString, NULL, NULL);

                DWORD dwOptions = ACO_AUTOSUGGEST | ACO_UPDOWNKEYDROPSLIST;

                // Add the RTLREADING option to the dropdown, if the element is RTL
                BSTR bstrDir = NULL;

                IHTMLElement2 *pEle2=NULL;
                m_pTextEle->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);
                if (pEle2)
                {
                    pEle2->get_dir(&bstrDir);
                    pEle2->Release();
                }

                if (bstrDir)
                {
                    if (!StrCmpIW(bstrDir, L"RTL"))
                    {
                        dwOptions |= ACO_RTLREADING;
                    }

                    SysFreeString(bstrDir);
                }

                m_pAutoComplete->SetOptions(dwOptions);
            }
        }
    }

    m_fInitAutoComplete = TRUE;

    ASSERT_MSG(SUCCEEDED(hr), "IForms: CreateAutoComplete failed");

    return hr;
}

void CIntelliForms::CAutoSuggest::CheckAutoFillPassword(LPCWSTR pwszUsername)
{
    // We don't autofill their password unless we know they've hit a key
    if (m_pParent && m_fEnabledPW && m_fAllowAutoFillPW)
    {
        if (m_bstrLastUsername && !StrCmpCW(pwszUsername, m_bstrLastUsername))
        {
            return;
        }

        SysFreeString(m_bstrLastUsername);
        m_bstrLastUsername = SysAllocString(pwszUsername);

        m_pParent->AutoFillPassword(m_pTextEle, pwszUsername);
    }
}

HRESULT GetScreenCoordinates(IUnknown *punkEle, HWND hwnd, long *plLeft, long *plTop, long *plWidth, long *plHeight)
{
    long lScreenLeft=0, lScreenTop=0;
    HRESULT hr = E_FAIL;

    *plLeft = *plTop = *plWidth = *plHeight = 0;

    IHTMLElement2 *pEle2;
    if (SUCCEEDED(punkEle->QueryInterface(IID_IHTMLElement2, (void **)&pEle2)) && pEle2)
    {
        IHTMLRect *pRect=NULL;

        if (SUCCEEDED(pEle2->getBoundingClientRect(&pRect)) && pRect)
        {
            IHTMLWindow2 *pWin2;

            long lLeft, lRight, lTop, lBottom;

            pRect->get_left(&lLeft);
            pRect->get_right(&lRight);
            pRect->get_top(&lTop);
            pRect->get_bottom(&lBottom);

            lBottom -= 2;           // put dropdown on top of edit box
            if (lBottom < lTop)
            {
                lBottom = lTop;
            }

            if (lTop >= 0 && lLeft >= 0)
            {
                GetStuffFromEle(punkEle, &pWin2, NULL);

                if (pWin2)
                {
                    IHTMLWindow3 *pWin3;
                    
                    if (SUCCEEDED(pWin2->QueryInterface(IID_IHTMLWindow3, (void **)&pWin3)) && pWin3)
                    {
                        IHTMLScreen *pScreen = NULL;
                        RECT rcBrowserWnd;

                        pWin3->get_screenLeft(&lScreenLeft);
                        pWin3->get_screenTop(&lScreenTop);

                        // GetClientRect & the screen_* APIs return document coordinates.
                        // We're position using device coordinates.
                        // Use document (currently 96DPI) and device resolutions & transform
                        pWin2->get_screen(&pScreen);
                        if (pScreen)
                        {
                            IHTMLScreen2 * pScreen2 = NULL;

                            if (SUCCEEDED(pScreen->QueryInterface(IID_IHTMLScreen2, (void **)&pScreen2)))
                            {
                                if (pScreen2)
                                {                        
                                    long xDeviceDPI, yDeviceDPI, xLogicalDPI, yLogicalDPI;

                                    pScreen2->get_deviceXDPI(&xDeviceDPI);
                                    pScreen2->get_deviceYDPI(&yDeviceDPI);
                                    pScreen2->get_logicalXDPI(&xLogicalDPI);
                                    pScreen2->get_logicalYDPI(&yLogicalDPI);

                                    lBottom     = (lBottom * yDeviceDPI) / yLogicalDPI;
                                    lTop        = (lTop * yDeviceDPI) / yLogicalDPI;
                                    lScreenTop  = (lScreenTop * yDeviceDPI) / yLogicalDPI;
                                    lLeft       = (lLeft * xDeviceDPI) / xLogicalDPI;
                                    lRight      = (lRight * xDeviceDPI) / xLogicalDPI;
                                    lScreenLeft = (lScreenLeft * xDeviceDPI) / xLogicalDPI;
                                    pScreen2->Release();
                                }
                            }

                            pScreen->Release();
                        }

                        if (GetWindowRect(hwnd, &rcBrowserWnd))
                        {
                            // Clip the right edge to the window
                            if (lRight+lScreenLeft > rcBrowserWnd.right)
                            {
                                lRight = rcBrowserWnd.right - lScreenLeft;
                            }

                            *plLeft = lScreenLeft + lLeft;
                            *plWidth = lRight-lLeft;
                            *plTop = lScreenTop + lTop;
                            *plHeight = lBottom-lTop;

                            hr = S_OK;

                            if (*plWidth < MINIMUM_WIDTH)
                            {
                                // Primitive minimum width for now
                                *plWidth = MINIMUM_WIDTH;
                            }
                        }

                        pWin3->Release();
                    }

                    pWin2->Release();
                }
            }

            pRect->Release();
        }
        pEle2->Release();
    }

    return hr;
}

HRESULT CIntelliForms::CAutoSuggest::UpdateDropdownPosition()
{
    if (m_pTextEle && m_pParent && m_hwndEdit)
    {
        long lLeft, lTop, lWidth, lHeight;

        if (SUCCEEDED(GetScreenCoordinates(m_pTextEle, m_pParent->m_hwndBrowser, &lLeft, &lTop, &lWidth, &lHeight)))
        {
            MoveWindow(m_hwndEdit, lLeft, lTop, lWidth, lHeight, FALSE);
        }
        else
        {
            // Send "escape" key to autocomplete so that it hides the dropdown.
            // This will happen if dropdown moves outside of parent window, for example.
            SendMessage(m_hwndEdit, IF_CHAR, (WPARAM) VK_ESCAPE, 0);
        }
    }

    return S_OK;
}


HRESULT CIntelliForms::CAutoSuggest::HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj)
{
    TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::HandleEvent Event=%ws", EventsToSink[Event].pwszEventName);

    ASSERT(SHIsSameObject(pEle, m_pTextEle));

    long lKey = 0;
    BOOL fIsComposition = FALSE;

    if (!m_pParent)
    {
        TraceMsg(TF_WARNING|TF_IFORMS, "IForms autosuggest receiving events while invalid");
        return E_FAIL;
    }

    if (Event == EVENT_KEYPRESS || Event == EVENT_KEYDOWN)
    {
        pEventObj->get_keyCode(&lKey);
    }

    if (Event == EVENT_COMPOSITION)
    {
        fIsComposition = TRUE;

        Event = EVENT_KEYPRESS; // Pretend to be a "keypress" for various processing below

    }

    if (Event == EVENT_NOTIFY)
    {
        // Send WM_IME_NOTIFY to AutoComplete so it can hide the dropdown
        //  if necessary
        IHTMLEventObj3 *pObj3 = NULL;

        pEventObj->QueryInterface(IID_PPV_ARG(IHTMLEventObj3, &pObj3));

        if (pObj3)
        {
            LONG_PTR wParam = 0;
            pObj3->get_imeNotifyCommand(&wParam);

            SendMessage(m_hwndEdit, WM_IME_NOTIFY, (WPARAM)wParam, 0);

            pObj3->Release();
        }

        return S_OK;
    }

    if (!m_fEnabled && !m_fEnabledPW)
    {
        // If the dropdown isn't enabled, our only purpose is to tell Intelliforms when
        //  user activity occurs for the first-time enable dialog box.
        if (Event == EVENT_KEYPRESS && lKey != VK_TAB)
        {
            // Add this element to the master list so we save it when we submit
            //  and sink the submit event for this element's form
            MarkDirty();
        }

        return S_OK;
    }

    if (Event == EVENT_KEYDOWN || Event == EVENT_KEYPRESS ||
        Event == EVENT_MOUSEDOWN || Event == EVENT_DBLCLICK)
    {
        m_fAllowAutoFillPW = TRUE;

        // Create our autocomplete object if it hasn't happened yet.
        // If it's "tab" we don't create it; we're leaving the field
        if (lKey != VK_TAB)
        {
            if (FAILED(CreateAutoComplete()))
                return E_FAIL;
        }
        else
        {
            // Add this element to the master list so we save it when we submit
            //  and sink the submit event for this element's form
            MarkDirty();
        }

        ASSERT((m_pEnumString && m_hwndEdit) || (lKey==VK_TAB));
    }

    // If AutoComplete hasn't been initialized there's nothing for us to do
    if (!m_pAutoCompleteDD || !m_hwndEdit)
    {
        return E_FAIL;
    }

    // Update the position of our hidden edit box
    long lLeft, lTop, lWidth, lHeight;

    // call UpdateDropdownPosition instead
    if (SUCCEEDED(GetScreenCoordinates(pEle, m_pParent->m_hwndBrowser, &lLeft, &lTop, &lWidth, &lHeight)))
    {
        MoveWindow(m_hwndEdit, lLeft, lTop, lWidth, lHeight, FALSE);
    }

    switch (Event)
    {
        case EVENT_FOCUS :
            SendMessage(m_hwndEdit, WM_SETFOCUS, 0, 0);
            break;

        case EVENT_BLUR:
        {
            if (m_hwndEdit)
            {
                SendMessage(m_hwndEdit, WM_KILLFOCUS, 0, 0);
            }

            // ensure that script hasn't changed value of edit field?
            BSTR bstrUsername=NULL;
            m_pTextEle->get_value(&bstrUsername);
            if (bstrUsername)
            {
                CheckAutoFillPassword(bstrUsername);
                SysFreeString(bstrUsername);
            }
        }
        break;
        
        case EVENT_MOUSEDOWN:
        case EVENT_DBLCLICK:
        {
            // If the dropdown is invisible, give AutoComplete a downarrow
            long lButton=0;
            pEventObj->get_button(&lButton);
            if ((Event == EVENT_DBLCLICK) ||
                (lButton & 1))                      // Left button down?
            {
                DWORD dwFlags;

                if (SUCCEEDED(m_pAutoCompleteDD->GetDropDownStatus(&dwFlags, NULL)) &&
                    !(dwFlags & ACDD_VISIBLE))
                {
                    TraceMsg(TF_IFORMS, "IForms sending downarrow because of mouse click");
                    PostMessage(m_hwndEdit, IF_KEYDOWN, (WPARAM)VK_DOWN, 0);
                    m_fEscapeHit = FALSE;
                }
            }
        }
        break;
        
        case EVENT_KEYPRESS:
        {
            // Add this element to the master list so we save it when we submit
            //  and sink the submit event for this element's form
            MarkDirty();

            // Ignore ctrl-enter (quickcomplete) (may be unnecessary)
            if (lKey == VK_RETURN)
            {
                VARIANT_BOOL bCtrl;
                if (SUCCEEDED(pEventObj->get_ctrlKey(&bCtrl)) && bCtrl)
                {
                    lKey = 0;
                }
            }

            if (lKey != 0)
            {
                if (lKey == m_lCancelKeyPress)
                {
                    // tell MSHTML to ignore this keystroke (may be tab, enter, escape)
                    TraceMsg(TF_IFORMS, "Intelliforms cancelling default action for EVENT_KEYPRESS=%d", lKey);

                    VARIANT v;
                    v.vt = VT_BOOL;
                    v.boolVal = VARIANT_FALSE;
                    pEventObj->put_returnValue(v);
                    if(!(lKey == VK_DOWN || lKey == VK_UP))
                        pEventObj->put_cancelBubble(VARIANT_TRUE);
                }

                m_lCancelKeyPress = 0;

                // Tell AutoComplete about this keystroke
                if (!m_fEscapeHit)
                {
                    PostMessage(m_hwndEdit, IF_CHAR, (WPARAM)lKey, 0);
                }
            }

            if (fIsComposition)
            {
                // Tell AutoComplete about the new string. This must be a Post so that
                //  Trident handles the event before we send the WM_CHAR to browseui.
                PostMessage(m_hwndEdit, IF_IME_COMPOSITION, 0, 0);
            }
        }
        break;
        
        case EVENT_KEYDOWN:
        {
            long    lKey;
            BOOL    fCancelEvent=FALSE,         // Cancel default MSHTML action?
                    fForwardKeystroke=TRUE;     // Forward keystroke to AutoComplete?

            pEventObj->get_keyCode(&lKey);

            if (m_fEscapeHit)
            {
                // They dismissed the dropdown; don't bring it back unless they ask for it
                if (lKey == VK_DOWN)
                {
                    m_fEscapeHit = FALSE;
                }
                else
                {
                    fForwardKeystroke = FALSE;
                }
            }

            if (lKey != 0)
            {
                if ((lKey == VK_RETURN) || (lKey == VK_TAB))
                {
                    fForwardKeystroke=FALSE;

                    LPWSTR pwszString=NULL;

                    if (SUCCEEDED(m_pAutoCompleteDD->GetDropDownStatus(NULL, &pwszString)) && pwszString)
                    {
                        // User is inside dropdown
                        fForwardKeystroke=TRUE;

                        // Set this value into our edit field
                        SetText(pwszString);

                        // We will fill in their password if they asked for it in m_uMsgItemActivate

                        if (lKey == VK_RETURN)
                        {
                            // Avoid submitting this form
                            fCancelEvent = TRUE;
                        }

                        CoTaskMemFree(pwszString);
                    }
                    else if (lKey == VK_RETURN)
                    {
                        // User's gonna submit. Give 'em their password first.
                        // ensure that script hasn't changed value of edit field?
                        BSTR bstrUsername=NULL;
                        m_pTextEle->get_value(&bstrUsername);
                        if (bstrUsername)
                        {
                            CheckAutoFillPassword(bstrUsername);
                            SysFreeString(bstrUsername);
                        }
                    }
                }
                else if (lKey == VK_DELETE)
                {
                    LPWSTR pwszString=NULL;

                    if (SUCCEEDED(m_pAutoCompleteDD->GetDropDownStatus(NULL, &pwszString)) && pwszString)
                    {
                        // User is inside dropdown
                        fForwardKeystroke=FALSE;

                        // Delete this value from our string lists
                        CStringList *psl=NULL;
                        BSTR bstrName;

                        CIntelliForms::GetName(m_pTextEle, &bstrName);

                        if (bstrName)
                        {
                            int iIndex;

                            if (SUCCEEDED(m_pParent->ReadFromStore(bstrName, &psl)) &&
                                SUCCEEDED(psl->FindString(pwszString, -1, &iIndex, FALSE)))
                            {
                                TraceMsg(TF_IFORMS, "IForms: Deleting string \"%ws\"", pwszString);
                                psl->DeleteString(iIndex);

                                // We deleted string.
                                if (psl->NumStrings() > 0)
                                {
                                    m_pParent->WriteToStore(bstrName, psl);
                                }
                                else
                                {
                                    m_pParent->DeleteFromStore(bstrName);
                                }
                            }
                        }

                        SysFreeString(bstrName);
                        if (psl) delete psl;

                        // avoid deleting a character from the edit window; user was inside dropdown
                        fCancelEvent = TRUE;

                        // Check this url to see if we should maybe delete a password entry
                        m_pParent->DeletePassword(pwszString);

                        // Get AutoComplete to fill in the dropdown again
                        m_pEnumString->ResetEnum();
                        m_pAutoCompleteDD->ResetEnumerator();

                        CoTaskMemFree(pwszString);
                    }
                }

                if (lKey == VK_ESCAPE)
                {
                    DWORD dwFlags;

                    if (SUCCEEDED(m_pAutoCompleteDD->GetDropDownStatus(&dwFlags, NULL)) &&
                        (dwFlags & ACDD_VISIBLE))
                    {
                        fCancelEvent = TRUE;
                        m_fEscapeHit = TRUE;
                    }
                }

                if (lKey == VK_DOWN || lKey == VK_UP)
                {
                    // Cancel the MSHTML events. This will cause MSHTML to return
                    //  S_OK instead of S_FALSE from its TranslateAccelerator, and we
                    //  won't get multiple keystrokes in different panes
                    fCancelEvent = TRUE;
                }

                if (fForwardKeystroke)
                {
                    PostMessage(m_hwndEdit, IF_KEYDOWN, lKey, 0);

                    if (lKey == VK_BACK)
                    {
                        // Never get OnKeyPress for this guy
                        PostMessage(m_hwndEdit, IF_CHAR, lKey, 0);
                    }
                }

                if (fCancelEvent)
                {
                    TraceMsg(TF_IFORMS, "Intelliforms cancelling default action for EVENT_KEYDOWN=%d", lKey);

                    m_lCancelKeyPress = lKey;    // Cancel the EVENT_KEYPRESS when it comes

                    VARIANT v;
                    v.vt = VT_BOOL;
                    v.boolVal = VARIANT_FALSE;
                    pEventObj->put_returnValue(v);
                    if(!(lKey == VK_DOWN || lKey == VK_UP))
                        pEventObj->put_cancelBubble(VARIANT_TRUE);
                }
                else
                {
                    m_lCancelKeyPress = 0;
                }
            }
        }
        break;
    }

    return S_OK;
}

HRESULT CIntelliForms::CAutoSuggest::GetText(int cchTextMax, LPWSTR pszTextOut, LRESULT *lcchCopied)
{
    *pszTextOut = TEXT('\0');
    *lcchCopied = 0;

    if (m_pTextEle)
    {
        BSTR bstr=NULL;
        m_pTextEle->get_value(&bstr);
        if (bstr)
        {
            StrCpyN(pszTextOut, bstr, cchTextMax);
            *lcchCopied = lstrlenW(pszTextOut);     // needed for NT

            SysFreeString(bstr);
        }
    }

    return (*pszTextOut) ? S_OK : E_FAIL;
}

HRESULT CIntelliForms::CAutoSuggest::GetTextLength(int *pcch)
{
    *pcch = 0;

    if (m_pTextEle)
    {
        BSTR bstr=NULL;
        m_pTextEle->get_value(&bstr);
        if (bstr)
        {
            *pcch = SysStringLen(bstr);

            SysFreeString(bstr);
        }
    }

    return S_OK;
}

HRESULT CIntelliForms::CAutoSuggest::SetText(LPCWSTR pszTextIn)
{
    if (m_pTextEle && pszTextIn)
    {
        BSTR bstr=SysAllocString(pszTextIn);

        if (bstr)
        {
            // Even though we know we already have this string in our dropdown, mark
            //  it as dirty so that we sink submit event; can be necessary in saved
            //  password situation.
            MarkDirty();

            // Make sure we don't put a string longer than the max length in this field
            long lMaxLen=-1;
            m_pTextEle->get_maxLength(&lMaxLen);
            if ((lMaxLen >= 0) && (lstrlenW(bstr) > lMaxLen))
            {
                bstr[lMaxLen] = L'\0';
            }

            m_pTextEle->put_value(bstr);
            SysFreeString(bstr);
        }
    }

    TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::SetText \"%ws\"", pszTextIn);

    return S_OK;
}

#define MY_GWL_THISPTR 0

LRESULT CALLBACK CIntelliForms::CAutoSuggest::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CIntelliForms::CAutoSuggest *pThis = (CIntelliForms::CAutoSuggest *)GetWindowLongPtr(hwnd, MY_GWL_THISPTR);

    switch (uMsg)
    {
    case WM_CREATE:
        {
            LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;

            if (!pcs || !(pcs->lpCreateParams))
            {
                return -1;
            }
            SetWindowLongPtr(hwnd, MY_GWL_THISPTR, (LONG_PTR) pcs->lpCreateParams);
            return 0;
        }

    case WM_GETTEXT:
        if (pThis)
        {
            LRESULT lcchCopied=0;

            if (g_fRunningOnNT)
            {
                pThis->GetText((int)wParam, (LPWSTR) lParam, &lcchCopied);
            }
            else
            {
                // We are actually an ANSI window. Convert.
                LPWSTR pwszOutBuf = (LPWSTR) LocalAlloc(LPTR, (wParam+1)*sizeof(WCHAR));

                if (pwszOutBuf)
                {
                    pThis->GetText((int)wParam, pwszOutBuf, &lcchCopied);

                    SHUnicodeToAnsi(pwszOutBuf, (LPSTR) lParam, (int)(wParam+1));

                    LocalFree((HLOCAL)pwszOutBuf);
                    pwszOutBuf = NULL;
                }
            }
            return lcchCopied;
        }

        return 0;

    case WM_GETTEXTLENGTH:
        if (pThis)
        {
            int iLen;
            pThis->GetTextLength(&iLen);
            return iLen;
        }

        return 0;

    case EM_GETSEL:
        // Must return zeroes here or autocomp will use uninitialized
        //  values and crash
        if (wParam) (*(DWORD *)wParam) = 0;
        if (lParam) (*(DWORD *)lParam) = 0;
        break;

    case IF_IME_COMPOSITION:
        // Forward a WM_CHAR. Autocomplete will notice that the rest of the string
        //  has changed if necessary (it does a GetText)
        SendMessage(hwnd, WM_CHAR, 32, 0);
        break;

    case IF_CHAR:
        SendMessage(hwnd, WM_CHAR, wParam, lParam);
        break;

    case IF_KEYDOWN:
        SendMessage(hwnd, WM_KEYDOWN, wParam, lParam);
        break;

    case WM_KEYDOWN:
    case WM_CHAR:
        return 0;       // eat it (see notes at top of file)

    default:

        // Check registered message
        if (pThis && uMsg == pThis->m_uMsgItemActivate)
        {
            TraceMsg(TF_IFORMS, "IForms: Received AM_ITEMACTIVATE(WM_APP+2)");
            pThis->SetText((LPCWSTR)lParam);
            pThis->CheckAutoFillPassword((LPCWSTR)lParam);

            return 0;
        }

        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 1;
}

CIntelliForms::CAutoSuggest::CEnumString::CEnumString()
{
//  TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::CEnumString::CEnumString");
    DllAddRef();

    InitializeCriticalSection(&m_crit);

    m_cRef = 1;
}

CIntelliForms::CAutoSuggest::CEnumString::~CEnumString()
{
//  TraceMsg(TF_IFORMS, "CIntelliForms::CAutoSuggest::CEnumString::~CEnumString");
    if (m_pslMain)
    {
        delete m_pslMain;
    }
    SysFreeString(m_bstrName);
    if (m_pszOpsValue)
    {
        CoTaskMemFree(m_pszOpsValue);
    }

    DeleteCriticalSection(&m_crit);

    DllRelease();
}

HRESULT CIntelliForms::CAutoSuggest::CEnumString::Init(IHTMLInputTextElement *pInputEle, CIntelliForms *pIntelliForms)
{
    if (m_fInit ||              // Can only init once
        !pInputEle || !pIntelliForms)       // Need both pointers
    {
        return E_FAIL;
    }

    m_fInit=TRUE;
    m_pIntelliForms = pIntelliForms;

    // Take care of things that must be done on the main thread. Autocomplete will
    //  call us on a secondary thread to do the enumeration.
    CIntelliForms::GetName(pInputEle, &m_bstrName);

    if (m_bstrName && m_bstrName[0])
    {
        // See if this specifies the "vcard." format
        if (IsEnabledInCPL() &&
            !StrCmpNICW(m_bstrName, c_wszVCardPrefix, ARRAYSIZE(c_wszVCardPrefix)-1))
        {
            // It does. Retrieve string from the profile assistant store.
            IHTMLWindow2     *pWin2 = NULL;
            IServiceProvider *pQS   = NULL;

            // QS up to get the shdocvw IHTMLWindow2 instead of NF trident's
            pInputEle->QueryInterface(IID_IServiceProvider, (void **)&pQS);

            if (pQS)
            {
                pQS->QueryService(IID_IHTMLWindow2, IID_IHTMLWindow2, (void **)&pWin2);
                pQS->Release();
            }

            if (pWin2)
            {
                IOmNavigator *pNav=NULL;
                pWin2->get_navigator(&pNav);
                if (pNav)
                {
                    IHTMLOpsProfile *pProfile=NULL;
                    pNav->get_userProfile(&pProfile);
                    if (pProfile)
                    {
                        IOpsProfileSimple *pSimple=NULL;
                        pProfile->QueryInterface(IID_IOpsProfileSimple, (void **)&pSimple);
                        if (pSimple)
                        {
                            pSimple->ReadProperties(1, &m_bstrName, &m_pszOpsValue);
                            pSimple->Release();
                        }
                        pProfile->Release();
                    }
                    pNav->Release();
                }
                pWin2->Release();
            }
        }
    }

    return S_OK;
}

void CIntelliForms::CAutoSuggest::CEnumString::UnInit()
{
    EnterCriticalSection(&m_crit);

    m_pIntelliForms = NULL;

    LeaveCriticalSection(&m_crit);
}

HRESULT CIntelliForms::CAutoSuggest::CEnumString::ResetEnum()
{
    EnterCriticalSection(&m_crit);

    if (m_pslMain)
    {
        delete m_pslMain;
        m_pslMain = NULL;
    }

    m_fFilledStrings = FALSE;

    LeaveCriticalSection(&m_crit);

    return S_OK;
}

STDMETHODIMP CIntelliForms::CAutoSuggest::CEnumString::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if ((IID_IEnumString == riid) ||
        (IID_IUnknown == riid))
    {
        *ppv = (IEnumString *)this;
    }

    if (NULL != *ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CIntelliForms::CAutoSuggest::CEnumString::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CIntelliForms::CAutoSuggest::CEnumString::Release(void)
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CIntelliForms::CAutoSuggest::CEnumString::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    EnterCriticalSection(&m_crit);

    if (!m_fFilledStrings)
    {
        FillEnumerator();
    }

    if (m_pslMain)
    {
        int iNewPtr = m_iPtr + celt;

        if (iNewPtr > m_pslMain->NumStrings())
        {
            iNewPtr = m_pslMain->NumStrings();
        }

        *pceltFetched = iNewPtr - m_iPtr;

        LPOLESTR lpstr;

        for (; m_iPtr < iNewPtr; m_iPtr ++)
        {
             m_pslMain->GetTaskAllocString(m_iPtr, &lpstr);

             if (!lpstr) break;

             *(rgelt ++) = lpstr;
        }

        if (m_iPtr < iNewPtr)
        {
            *pceltFetched += (m_iPtr - iNewPtr);
        }
    }

    LeaveCriticalSection(&m_crit);

    if (!m_pslMain)
    {
        return E_FAIL;
    }

    return (*pceltFetched) ? S_OK : S_FALSE;
}

STDMETHODIMP CIntelliForms::CAutoSuggest::CEnumString::Reset()
{
    EnterCriticalSection(&m_crit);

    m_iPtr = 0;

    LeaveCriticalSection(&m_crit);

    return S_OK;
}

HRESULT CIntelliForms::CAutoSuggest::CEnumString::FillEnumerator()
{
    // Already in critical section
    ASSERT(!m_pslMain);

    if (m_fFilledStrings)
    {
        return S_FALSE;
    }

    if (!m_bstrName || !m_bstrName[0] || !m_pIntelliForms)
    {
        return E_FAIL;
    }

    m_fFilledStrings = TRUE;

    m_iPtr = 0;

    // Fill the enumerator based on our name
    TraceMsg(TF_IFORMS, "IForms: Intelliforms filling enumerator");

    // Open any previously saved strings
    if (!m_pIntelliForms->IsRestricted() &&
        IsEnabledInCPL() &&
        m_pIntelliForms->IsEnabledForPage())
    {
        m_pIntelliForms->ReadFromStore(m_bstrName, &m_pslMain);

        // Add in profile assistant value, if any
        if (m_pszOpsValue && m_pszOpsValue[0])
        {
            if (!m_pslMain)
            {
                CStringList_New(&m_pslMain);
            }
            else
            {
                // don't risk a scavenge (perf)
                m_pslMain->SetMaxStrings(CStringList::MAX_STRINGS+4);
            }

            if (m_pslMain)
            {
                m_pslMain->AddString(m_pszOpsValue);
            }
        }
    }

    // Next fill with any usernames that have saved passwords
    CStringList *pslPasswords;

    if (!m_pIntelliForms->IsRestrictedPW() &&
        CIntelliForms::IsEnabledRestorePW() &&
        SUCCEEDED(m_pIntelliForms->GetPasswordStringList(&pslPasswords)))
    {
        ASSERT(!(pslPasswords->NumStrings() & 1));

        FILETIME ft;

        if (pslPasswords->NumStrings() > 0)
        {
            if (!m_pslMain)
            {
                CStringList_New(&m_pslMain);
            }
            else
            {
                // avoid expensive scavenging while adding usernames to string list
                m_pslMain->SetMaxStrings(m_pslMain->GetMaxStrings() + pslPasswords->NumStrings()/2);
            }

            if (m_pslMain)
            {
                for (int i=0; i<pslPasswords->NumStrings(); i+=2)
                {
                    if (SUCCEEDED(pslPasswords->GetStringTime(i, &ft)) &&
                        FILETIME_TO_INT(ft) != 0)
                    {
                        // We have a saved password for this username. Add username to enumerator.
                        m_pslMain->AddString(pslPasswords->GetString(i));
                    }
                }
            }
        }

        // do not delete pslPasswords
    }

    return (m_pslMain) ? ((m_pslMain->NumStrings()) ? S_OK : S_FALSE) : E_FAIL;
}

// Static helper. Pretty basic.
HRESULT CStringList_New(CStringList **ppNew, BOOL fAutoDelete/*=TRUE*/)
{
    *ppNew = new CStringList();

    if (*ppNew)
    {
        (*ppNew)->SetAutoScavenge(fAutoDelete);
    }

    return (*ppNew) ? S_OK : E_OUTOFMEMORY;
}

CStringList::CStringList()
{
    TraceMsg(TF_IFORMS, "IForms: CStringList::CStringList");
    m_fAutoScavenge = TRUE;
    m_dwMaxStrings = MAX_STRINGS;
}

CStringList::~CStringList()
{
    TraceMsg(TF_IFORMS, "IForms: CStringList::~CStringList");
    CleanUp();
}

void CStringList::CleanUp()
{
    if (m_psiIndex)
    {
        LocalFree(m_psiIndex);
        m_psiIndex = NULL;
    }
    if (m_pBuffer)
    {
        LocalFree(m_pBuffer);
        m_pBuffer = NULL;
    }
    m_dwIndexSize = 0;
    m_dwBufEnd = m_dwBufSize = 0;
}

HRESULT CStringList::WriteToBlobs(LPBYTE *ppBlob1, DWORD *pcbBlob1, LPBYTE *ppBlob2, DWORD *pcbBlob2)
{
    HRESULT hr = E_FAIL;
    TraceMsg(TF_IFORMS, "+WriteToBlobs");

    if (SUCCEEDED(Validate()))
    {
        DWORD dwIndexSize;

        dwIndexSize = INDEX_SIZE(m_psiIndex->dwNumStrings);
        ASSERT(dwIndexSize <= m_dwIndexSize);

        *ppBlob1 = (LPBYTE) LocalAlloc(LMEM_FIXED, dwIndexSize);
        if (*ppBlob1)
        {
            *ppBlob2 = (LPBYTE) LocalAlloc(LMEM_FIXED, m_dwBufEnd);

            if (*ppBlob2)
            {
                memcpy(*ppBlob1, m_psiIndex, dwIndexSize);
                *pcbBlob1=dwIndexSize;

                memcpy(*ppBlob2, m_pBuffer, m_dwBufEnd);
                *pcbBlob2=m_dwBufEnd;

                hr = S_OK;
            }
        }
    }
    else
    {
        // Validate failed.
        TraceMsg(TF_ERROR | TF_IFORMS, "Validate FAILED in WriteToBlobs");
        *ppBlob1=NULL;
        *ppBlob2=NULL;
    }

    if (FAILED(hr))
    {
        if (*ppBlob1)
        {
            LocalFree(*ppBlob1);
            *ppBlob1=NULL;
        }
        if (*ppBlob2)
        {
            LocalFree(*ppBlob2);
            *ppBlob2=NULL;
        }
        *pcbBlob1=0;
        *pcbBlob2=0;
    }

    TraceMsg(TF_IFORMS, "-WriteToBlobs");

    return hr;
}

// Take the blobs and use as our buffer
HRESULT CStringList::ReadFromBlobs(LPBYTE *ppBlob1, DWORD cbBlob1, LPBYTE *ppBlob2, DWORD cbBlob2)
{
    HRESULT hr = E_FAIL;

    TraceMsg(TF_IFORMS, "+ReadFromBlobs");

    if (m_psiIndex)
    {
        TraceMsg(TF_IFORMS, "IForms: CStringList::ReadFromRegistry called with initialized instance.");
        CleanUp();
    }

    // Allocate our buffers.
    m_psiIndex = (StringIndex *) (*ppBlob1);
    m_pBuffer = (LPBYTE) (*ppBlob2);

    *ppBlob1 = NULL;
    *ppBlob2 = NULL;

    if (!m_psiIndex || !m_pBuffer || !cbBlob1 || !cbBlob2)
    {
        // Nothing to do
        CleanUp();

        return S_FALSE;
    }

    // Validate our string index.
    if ((m_psiIndex->dwSignature == INDEX_SIGNATURE) &&
        (m_psiIndex->cbSize == STRINGINDEX_CBSIZE) &&
        (m_psiIndex->dwNumStrings <= MAX_STRINGS))
    {
        m_dwBufEnd = m_dwBufSize = cbBlob2;
        m_dwIndexSize = cbBlob1;

        if (SUCCEEDED(Validate()))
        {
            // Everything worked. Amazing.
            hr = S_OK;
        }
    }

    if (FAILED(hr))
    {
        // Release buffers if necessary.
        CleanUp();
    }

    TraceMsg(TF_IFORMS, "-ReadFromBlobs");

    return hr;
}

// static
HRESULT CStringList::GetFlagsFromIndex(LPBYTE pBlob1, INT64 *piFlags)
{
    StringIndex *psiIndex = (StringIndex *)pBlob1;

    if ((psiIndex->dwSignature == INDEX_SIGNATURE) &&
        (psiIndex->cbSize == STRINGINDEX_CBSIZE))
    {
        *piFlags = psiIndex->iData;

        return S_OK;
    }

    return E_FAIL;
}

HRESULT CStringList::Validate()
{
    TraceMsg(TF_IFORMS, "+CStringList::Validate");
    if (!m_psiIndex || !m_pBuffer)
    {
        return E_FAIL;
    }

    for (DWORD dw=0; dw < m_psiIndex->dwNumStrings; dw++)
    {
        DWORD dwPtr  = m_psiIndex->StringEntry[dw].dwStringPtr;
        DWORD dwSize = (GetStringLen(dw)+1) * sizeof(WCHAR);

        if (dwPtr + dwSize > m_dwBufSize)
        {
            return E_FAIL;
        }
    }

    TraceMsg(TF_IFORMS, "-CStringList::Validate");
    return S_OK;
}

HRESULT CStringList::Init(DWORD dwBufSize /* =0 */)
{
    DWORD dwMaxStrings=0;
    DWORD dwIndexSize=0;

    if (m_psiIndex)
    {
        TraceMsg(TF_IFORMS, "IForms: CStringList::Init called when already initialized");
        CleanUp();
    }

    if (dwBufSize == 0)
    {
        dwBufSize = INIT_BUF_SIZE;
    }

    dwMaxStrings = dwBufSize >> 5;  // this is relatively arbitrary but doesn't matter much

    if (dwMaxStrings == 0)
        dwMaxStrings = 1;

    dwIndexSize = INDEX_SIZE(dwMaxStrings);

    m_pBuffer = (LPBYTE)LocalAlloc(LMEM_FIXED, dwBufSize);
    m_psiIndex = (StringIndex *)LocalAlloc(LMEM_FIXED, dwIndexSize);

    if ((NULL == m_psiIndex) ||
        (NULL == m_pBuffer))
    {
        TraceMsg(TF_IFORMS, "IForms: CStringList::Init memory allocation failed");

        CleanUp();
        return E_OUTOFMEMORY;
    }

    *((WCHAR *)m_pBuffer) = L'\0';

    m_dwBufSize = dwBufSize;
    m_dwBufEnd = 0;

    m_psiIndex->dwSignature = INDEX_SIGNATURE;
    m_psiIndex->cbSize = STRINGINDEX_CBSIZE;
    m_psiIndex->dwNumStrings = 0;
    m_psiIndex->iData = 0;
    m_dwIndexSize = dwIndexSize;

    TraceMsg(TF_IFORMS, "IForms: CStringList::Init succeeded");

    return S_OK;
}

HRESULT CStringList::GetBSTR(int iIndex, BSTR *pbstrRet)
{
    LPCWSTR lpwstr = GetString(iIndex);

    if (!lpwstr)
    {
        *pbstrRet = NULL;
        return E_INVALIDARG;
    }

    *pbstrRet = SysAllocString(lpwstr);

    return (*pbstrRet) ? S_OK : E_OUTOFMEMORY;
}

HRESULT CStringList::GetTaskAllocString(int iIndex, LPOLESTR *pRet)
{
    LPCWSTR lpwstr = GetString(iIndex);

    if (!lpwstr)
    {
        *pRet = NULL;
        return E_INVALIDARG;
    }

    DWORD dwSize = (GetStringLen(iIndex)+1) * sizeof(WCHAR);

    *pRet = (LPOLESTR)CoTaskMemAlloc(dwSize);

    if (!*pRet)
    {
        return E_OUTOFMEMORY;
    }

    memcpy(*pRet, lpwstr, dwSize);

    return S_OK;
}

HRESULT CStringList::FindString(LPCWSTR lpwstr, int iLen, int *piNum, BOOL fCaseSensitive)
{
    if (!m_psiIndex) return E_FAIL;

    DWORD dw;

    if (!lpwstr)
    {
        return E_INVALIDARG;
    }

    if (iLen <= 0)
    {
        iLen = lstrlenW(lpwstr);
    }

    if (piNum)
    {
        *piNum = -1;
    }

    for (dw=0; dw<m_psiIndex->dwNumStrings; dw++)
    {
        if (m_psiIndex->StringEntry[dw].dwStringLen == (DWORD)iLen)
        {
            if ((fCaseSensitive && (!StrCmpW(GetString(dw), lpwstr))) ||
                (!fCaseSensitive && (!StrCmpIW(GetString(dw), lpwstr))))
            {
                // Match!
                if (piNum)
                {
                    *piNum = (int) dw;
                }

                return S_OK;
            }
        }
    }

    return E_FAIL;      // Couldn't find it
}

// CStringList is not optimized for deleting
HRESULT CStringList::DeleteString(int iIndex)
{
    TraceMsg(TF_IFORMS, "+DeleteString");
    if (!m_psiIndex)
    {
        return E_FAIL;
    }

    if ((iIndex<0) || ((DWORD)iIndex >= m_psiIndex->dwNumStrings))
    {
        return E_INVALIDARG;
    }

    if ((DWORD)iIndex == (m_psiIndex->dwNumStrings-1))
    {
        // Simple case - deleting last string
        m_dwBufEnd -= (sizeof(WCHAR) * (GetStringLen(iIndex) + 1));
        m_psiIndex->dwNumStrings --;
        return S_OK;
    }

    DWORD cbSizeDeleted;
    LPCWSTR pwszString1, pwszString2;

    pwszString1 = GetString(iIndex);
    pwszString2 = GetString(iIndex+1);

    // Size in bytes of string to be deleted including null terminator
    cbSizeDeleted = (DWORD)((DWORD_PTR)pwszString2 - (DWORD_PTR)pwszString1);

    ASSERT(cbSizeDeleted == (sizeof(WCHAR) * (lstrlenW(GetString(iIndex))+1)));

    // Delete entry in index
    memcpy(&(m_psiIndex->StringEntry[iIndex]), &(m_psiIndex->StringEntry[iIndex+1]),
                STRINGENTRY_SIZE*(m_psiIndex->dwNumStrings - iIndex - 1));
    m_psiIndex->dwNumStrings --;

    // Delete string in buffer
    memcpy((LPWSTR)pwszString1, pwszString2, m_dwBufEnd-(int)PtrDiff(pwszString2, m_pBuffer));
    m_dwBufEnd -= cbSizeDeleted;

    // Fix up pointers in index
    for (int i=iIndex; (DWORD)i < m_psiIndex->dwNumStrings; i++)
    {
        m_psiIndex->StringEntry[i].dwStringPtr -= cbSizeDeleted;
    }
    TraceMsg(TF_IFORMS, "-DeleteString");

    return S_OK;
}

HRESULT CStringList::InsertString(int iIndex, LPCWSTR lpwstr)
{
    TraceMsg(TF_IFORMS, "+InsertString");
    if (!m_psiIndex)
    {
        return E_FAIL;
    }

    if ((iIndex<0) || ((DWORD)iIndex > m_psiIndex->dwNumStrings))
    {
        return E_INVALIDARG;
    }

    if ((DWORD)iIndex == m_psiIndex->dwNumStrings)
    {
        // Simple case - inserting to end
        return _AddString(lpwstr, FALSE, NULL);
    }

    DWORD dwLen = (DWORD)lstrlenW(lpwstr);
    DWORD dwSizeInserted = sizeof(WCHAR) * (dwLen + 1);

    if (FAILED(EnsureBuffer(m_dwBufEnd + dwSizeInserted)) ||
        FAILED(EnsureIndex(m_psiIndex->dwNumStrings + 1)))
    {
        return E_OUTOFMEMORY;
    }


    // Insert into buffer
    LPWSTR pwszBufLoc = GetStringPtr(iIndex);

    memcpy((LPBYTE)pwszBufLoc + dwSizeInserted, pwszBufLoc, m_dwBufEnd - (int) PtrDiff(pwszBufLoc, m_pBuffer));
    memcpy(pwszBufLoc, lpwstr, dwSizeInserted);
    m_dwBufEnd += dwSizeInserted;

    // Insert into index
    memcpy(&(m_psiIndex->StringEntry[iIndex+1]), &(m_psiIndex->StringEntry[iIndex]),
                STRINGENTRY_SIZE*(m_psiIndex->dwNumStrings - iIndex));
    struct StringIndex::tagStringEntry *pse=&(m_psiIndex->StringEntry[iIndex]);
    pse->dwStringPtr = (DWORD)PtrDiff(pwszBufLoc, m_pBuffer);
    pse->ftLastSubmitted.dwLowDateTime = pse->ftLastSubmitted.dwHighDateTime = 0;
    pse->dwStringLen = dwLen;
    m_psiIndex->dwNumStrings ++;

    // Fix up pointers after inserted string
    for (int i=iIndex+1; (DWORD)i<m_psiIndex->dwNumStrings; i++)
    {
        m_psiIndex->StringEntry[i].dwStringPtr += dwSizeInserted;
    }
    TraceMsg(TF_IFORMS, "-InsertString");

    return S_OK;
}

HRESULT CStringList::ReplaceString(int iIndex, LPCWSTR lpwstr)
{
    TraceMsg(TF_IFORMS, "+ReplaceString");
    if (!m_psiIndex)
    {
        return E_FAIL;
    }

    if ((iIndex<0) || ((DWORD)iIndex >= m_psiIndex->dwNumStrings))
    {
        return E_INVALIDARG;
    }

    if ((DWORD)lstrlenW(lpwstr) == m_psiIndex->StringEntry[iIndex].dwStringLen)
    {
        // Simple case - strings equal length
        memcpy( GetStringPtr(iIndex),
                lpwstr,
                 (m_psiIndex->StringEntry[iIndex].dwStringLen)*sizeof(WCHAR));

        return S_OK;
    }

    // Delete old string, then insert new one
    DeleteString(iIndex);

    HRESULT hr = InsertString(iIndex, lpwstr);

    TraceMsg(TF_IFORMS, "-ReplaceString");

    return hr;
}

HRESULT CStringList::AddString(LPCWSTR lpwstr, FILETIME ft, int *piNum /*=NULL*/)
{
    int iNum;
    HRESULT hr;

    TraceMsg(TF_IFORMS, "+AddString");

    hr = _AddString(lpwstr, TRUE, &iNum);

    if (piNum)
    {
        *piNum = iNum;
    }

    if (SUCCEEDED(hr))
    {
        UpdateStringTime(iNum, ft);
    }

    TraceMsg(TF_IFORMS, "-AddString");

    return hr;
}


HRESULT CStringList::AddString(LPCWSTR lpwstr, int *piNum /*=NULL*/)
{
    return _AddString(lpwstr, TRUE, piNum);
}

HRESULT CStringList::AppendString(LPCWSTR lpwstr, FILETIME ft, int *piNum /*=NULL*/)
{
    int iNum;
    HRESULT hr;

    hr = _AddString(lpwstr, FALSE, &iNum);

    if (piNum)
    {
        *piNum = iNum;
    }

    if (SUCCEEDED(hr))
    {
        SetStringTime(iNum, ft);
    }

    return hr;
}

HRESULT CStringList::_AddString(LPCWSTR lpwstr, BOOL fCheckDuplicates, int *piNum)
{
    DWORD dwSize, dwLen;
    int iNum = -1;
    WCHAR wchBufTruncated[MAX_URL_STRING];
    LPCWSTR lpwstrTruncated=lpwstr;

    TraceMsg(TF_IFORMS, "+_AddString");

    if (piNum)
    {
        *piNum = -1;
    }

    if (!lpwstr)
    {
        return E_INVALIDARG;
    }

    if (!m_psiIndex)
    {
        if (FAILED(Init()))
        {
            return E_FAIL;
        }
    }

    dwLen = (DWORD) lstrlenW(lpwstr);

    // Explicitly truncate strings to MAX_URL characters. If we don't do this, browseui
    //  autocomplete code truncates it anyway and then we have problems removing
    //  duplicates and deleting these long strings. All IntelliForms code can handle
    //  arbitrary length strings.
    if (dwLen >= ARRAYSIZE(wchBufTruncated))
    {
        StrCpyNW(wchBufTruncated, lpwstr, ARRAYSIZE(wchBufTruncated));
        lpwstrTruncated = wchBufTruncated;
        dwLen = lstrlenW(wchBufTruncated);
    }

    dwSize = (dwLen+1)*sizeof(WCHAR);

    if (fCheckDuplicates && SUCCEEDED(FindString(lpwstrTruncated, (int)dwLen, &iNum, FALSE)))
    {
        if (piNum)
        {
            *piNum = iNum;
        }

        if (!StrCmpW(lpwstrTruncated, GetString(iNum)))
        {
            return S_FALSE;             // String is an exact duplicate
        }

        // String is a duplicate but has different case. Replace.
        ASSERT(m_psiIndex->StringEntry[iNum].dwStringLen == dwLen);
        memcpy(GetStringPtr(iNum), lpwstrTruncated, dwSize);

        return S_OK;                    // String was different in case
    }

    if (m_psiIndex->dwNumStrings >= m_dwMaxStrings)
    {
        if (m_fAutoScavenge)
        {
            // Remove the oldest string from our list.
            DWORD dwIndex;
            int iOldest=-1;
            FILETIME ftOldest = { 0xFFFFFFFF, 0x7FFFFFFF };
            for (dwIndex=0; dwIndex<m_psiIndex->dwNumStrings; dwIndex++)
            {
                if ((FILETIME_TO_INT(m_psiIndex->StringEntry[dwIndex].ftLastSubmitted) != 0) &&
                    (1 == CompareFileTime(&ftOldest, &m_psiIndex->StringEntry[dwIndex].ftLastSubmitted)))
                {
                    ftOldest = m_psiIndex->StringEntry[dwIndex].ftLastSubmitted;
                    iOldest = (int)dwIndex;
                }
            }

            if (iOldest != -1)
            {
                DeleteString(iOldest);
            }
            else
            {
                // User must not be setting string times.
                return E_OUTOFMEMORY;
            }
        }
        else
        {
            // Auto-scavenge is disabled.
            return E_OUTOFMEMORY;
        }
    }

    if (FAILED(EnsureBuffer(m_dwBufEnd + dwSize)) ||
        FAILED(EnsureIndex(m_psiIndex->dwNumStrings + 1)))
    {
        return E_OUTOFMEMORY;
    }

    // Our buffers are large enough. Do it.
    if (piNum)
    {
        *piNum = (int) m_psiIndex->dwNumStrings;
    }

    LPWSTR pwszNewString = (LPWSTR)(m_pBuffer + m_dwBufEnd);

    memcpy(pwszNewString, lpwstrTruncated, dwSize);
    m_dwBufEnd += dwSize;

    struct StringIndex::tagStringEntry *pse=&(m_psiIndex->StringEntry[m_psiIndex->dwNumStrings]);
    pse->dwStringPtr = (DWORD)PtrDiff(pwszNewString, m_pBuffer);
    pse->ftLastSubmitted.dwLowDateTime = pse->ftLastSubmitted.dwHighDateTime = 0;
    pse->dwStringLen = dwLen;

    m_psiIndex->dwNumStrings ++;

    TraceMsg(TF_IFORMS, "-_AddString");

    return S_OK;           // We added a new string
}

HRESULT CStringList::EnsureBuffer(DWORD dwSizeNeeded)
{
    TraceMsg(TF_IFORMS, "+EnsureBuffer");

    if (dwSizeNeeded <= m_dwBufSize)
    {
        return S_OK;        // Already big enough
    }

    if (!m_pBuffer)
    {
        return E_FAIL;
    }

    DWORD dwNewBufSize = m_dwBufSize * 2;

    // Grow buffer.
    if (dwSizeNeeded > dwNewBufSize)
    {
        TraceMsg(TF_IFORMS, "IForms: StringList special growing size (big string)");
        dwNewBufSize = dwSizeNeeded;
    }

    TraceMsg(TF_IFORMS, "IForms: CStringList growing");

    LPBYTE pBuf = (LPBYTE)LocalReAlloc(m_pBuffer, dwNewBufSize, LMEM_MOVEABLE);
    if (!pBuf)
    {
        TraceMsg(TF_IFORMS, "IForms: CStringList: ReAlloc failure");
        // Realloc failure: our old memory is still present
        return E_FAIL;
    }

    m_dwBufSize = dwNewBufSize;

    m_pBuffer = pBuf;

    TraceMsg(TF_IFORMS, "-EnsureBuffer");

    // Successfully realloced to bigger buffer
    return S_OK;
}

// grow psiIndex if needed
HRESULT CStringList::EnsureIndex(DWORD dwNumStringsNeeded)
{
    TraceMsg(TF_IFORMS, "+EnsureIndex");

    if (!m_psiIndex)
    {
        return E_FAIL;
    }

    if (INDEX_SIZE(dwNumStringsNeeded) > m_dwIndexSize)
    {
        DWORD dwNewMaxStrings = (m_psiIndex->dwNumStrings) * 2;
        DWORD dwNewIndexSize = INDEX_SIZE(dwNewMaxStrings);

        TraceMsg(TF_IFORMS, "IForms: CStringList growing max strings");

        StringIndex *psiBuf =
            (StringIndex *)LocalReAlloc(m_psiIndex, dwNewIndexSize, LMEM_MOVEABLE);

        if (!psiBuf)
        {
            // Realloc failure: Old memory still present
            TraceMsg(TF_IFORMS, "IForms: CStringList ReAlloc failure");
            return E_OUTOFMEMORY;
        }

        // Success. Don't need to fix any pointers in index (buffer is unchanged)
        m_psiIndex = psiBuf;
        m_dwIndexSize = dwNewIndexSize;
    }

    TraceMsg(TF_IFORMS, "-EnsureIndex");

    return S_OK;
}

// This dlg proc is used for password save, change, delete dialogs
INT_PTR AutoSuggestDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_INITDIALOG:
        CenterWindow(hDlg, GetParent(hDlg));

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) lParam);

        if (lParam == IDD_AUTOSUGGEST_SAVEPASSWORD)
        {
            // For "Save" password we default to no. For "Change" and "Delete" we default to yes.
            SetFocus(GetDlgItem(hDlg, IDNO));
            return FALSE;
        }
        return TRUE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDCANCEL:          // close box
            case IDYES:             // yes button
            case IDNO:              // no button
                if (IDD_AUTOSUGGEST_SAVEPASSWORD == GetWindowLongPtr(hDlg, DWLP_USER))
                {
                    // Check the "don't ask me again" checkbox for the save password dlg
                    if (IsDlgButtonChecked(hDlg, IDC_AUTOSUGGEST_NEVER))
                    {
                        SHSetValue(HKEY_CURRENT_USER, c_szRegKeySMIEM, c_szRegValAskPasswords,
                                REG_SZ, c_szNo, sizeof(c_szNo));
                    }
                }

                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
        }
        break;

#ifdef CHECKBOX_HELP
    case WM_HELP:
        // Only process WM_HELP for save password dlg
        if (IDD_AUTOSUGGEST_SAVEPASSWORD == GetWindowLong(hDlg, DWL_USER))
        {
            SHWinHelpOnDemandWrap((HWND) ((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                HELP_WM_HELP, (DWORD_PTR)(LPTSTR) c_aIFormsHelpIds);
        }
        break;

    case WM_CONTEXTMENU:      // right mouse click
        // Only process WM_HELP for save password dlg
        if (IDD_AUTOSUGGEST_SAVEPASSWORD == GetWindowLong(hDlg, DWL_USER))
        {
            SHWinHelpOnDemandWrap((HWND) wParam, c_szHelpFile, HELP_CONTEXTMENU,
                (DWORD_PTR)(LPTSTR) c_aIFormsHelpIds);
        }
        break;
#endif
    }

    return FALSE;
}


//================================================================================

INT_PTR CALLBACK AskUserDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        CenterWindow(hDlg, GetParent(hDlg));
        Animate_OpenEx(GetDlgItem(hDlg, IDD_ANIMATE), HINST_THISDLL, MAKEINTRESOURCE(IDA_AUTOSUGGEST));
        return TRUE;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_AUTOSUGGEST_HELP:
                    SHHtmlHelpOnDemandWrap(GetParent(hDlg), TEXT("iexplore.chm > iedefault"),
                        HH_DISPLAY_TOPIC, (DWORD_PTR) TEXT("autocomp.htm"), ML_CROSSCODEPAGE);
                    break;

                case IDYES:
                case IDNO:
                {
                    LPCTSTR pszData;
                    DWORD  cbData;
                    DWORD  dwData=0;

                    if (LOWORD(wParam) == IDYES)
                    {
                        pszData = c_szYes;
                        cbData = sizeof(c_szYes);
                    }
                    else
                    {
                        pszData = c_szNo;
                        cbData = sizeof(c_szNo);
                    }

                    // Write the enabled state into our CPL regkey
                    SHSetValue(HKEY_CURRENT_USER, c_szRegKeySMIEM, c_szRegValUseFormSuggest,
                        REG_SZ, pszData, cbData);

                    // Flag it as "asked user" so we don't ask them again
                    SHSetValue(HKEY_CURRENT_USER, c_szRegKeyIntelliForms, c_szRegValAskUser,
                        REG_DWORD, &dwData, sizeof(dwData));
                }

                // Fall through
                case IDCANCEL:
                {
                    EndDialog(hDlg, LOWORD(wParam));
                }
                break;
            }
        }
        return TRUE;

    case WM_DESTROY:
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\iforms.h ===
// Called from hlframe
// Set user GUID, for identities
HRESULT SetIdAutoSuggestForForms(const GUID *pguidId, void *pIntelliForms);
// Exported for inetCPL
EXTERN_C HRESULT ClearAutoSuggestForForms(DWORD dwClear);   // dwClear in msiehost.h

// called from iedisp.cpp
void AttachIntelliForms(void *pOmWindow, HWND hwnd, IHTMLDocument2 *pDoc2, void **ppIntelliForms);
void ReleaseIntelliForms(void *pIntelliForms);
HRESULT IntelliFormsDoAskUser(HWND hwndBrowser, void *pv);

// called from shuioc.cpp
HRESULT IntelliFormsSaveForm(IHTMLDocument2 *pDoc2, VARIANT *pvarForm);

HRESULT IntelliFormsActiveElementChanged(void *pIntelliForms, IHTMLElement * pHTMLElement);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\iehard.cpp ===
#include "priv.h"
#include "resource.h"
#include <mluisupp.h>

#define REGSTR_VAL_IEHARD_NOWARN     L"IEHardenIENoWarn"
#define REGSTR_VAL_OCHARD_NOWARN     L"IEHardenOCNoWarn"
#define REGSTR_VAL_IEHARD_TIMER      L"IEHardenDlgTimeOut"

#define IEHARD_TIMER_ID              45

BOOL IEHard_DlgSetText(HWND hDlg, BOOL fIE)
{
    BOOL fRet;

    WCHAR szBuff[512];
    fRet = MLLoadString(fIE ? IDS_IEHARDEN_TEXT_IE : IDS_IEHARDEN_TEXT_OC, szBuff, ARRAYSIZE(szBuff));
    if (fRet)
    {
        fRet = (BOOL)SendMessage(GetDlgItem(hDlg, IDC_IEHARDEN_TEXT), WM_SETTEXT, 0, (LPARAM)szBuff);
    }

    return fRet;
}

void IEHard_DlgSetTimer(HWND hDlg)
{
    DWORD dwVal;
    DWORD cbSize = sizeof(dwVal);
    if (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_PATH_INTERNET_SETTINGS, REGSTR_VAL_IEHARD_TIMER, NULL, &dwVal, &cbSize, FALSE, NULL, 0))
    {
        SetTimer(hDlg, IEHARD_TIMER_ID, dwVal * (1000), NULL);
    }
}

BOOL IEHard_InitDialog(HWND hDlg, BOOL fIE)
{
    BOOL fRet;

    fRet = IEHard_DlgSetText(hDlg, fIE);
    if (fRet)
    {
        IEHard_DlgSetTimer(hDlg);
        CenterWindow(hDlg, GetParent(hDlg));
    }

    return fRet;
}

STDAPI ShowUrlInNewBrowserInstance(LPCWSTR pwszUrl)
{
    /* Shell exec RIPs on debug builds since res: isn't registered, use IE directly
    SHELLEXECUTEINFO sei = {0};
    sei.cbSize = sizeof(sei);
    sei.lpFile = L"res://shdoclc/IESechelp.htm";
    ShellExecuteEx(&sei);
    */

    IWebBrowser2* pwb;
    if (SUCCEEDED(CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IWebBrowser2, &pwb))))
    {
        VARIANT vNull = {0};
        VARIANT vTargetURL;

        vTargetURL.vt      = VT_BSTR;
        vTargetURL.bstrVal = SysAllocString(pwszUrl);

        if (vTargetURL.bstrVal)
        {
            pwb->put_Visible(VARIANT_TRUE);
            pwb->Navigate2(&vTargetURL, &vNull, &vNull, &vNull, &vNull);
            SysFreeString(vTargetURL.bstrVal);
        }
        pwb->Release();

        return S_OK;
    }

    return E_FAIL;
}

INT_PTR CALLBACK IEHard_WarnDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fRet = FALSE;

    switch(uMsg)
    {
        case WM_INITDIALOG:
            IEHard_InitDialog(hDlg, lParam ? TRUE : FALSE);
            fRet = TRUE;
            break;

        case WM_TIMER:
            if (IEHARD_TIMER_ID == wParam)
            {
                PostMessage(hDlg, WM_COMMAND, IDCANCEL, 0);
            }
            break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                case IDCANCEL:
                    EndDialog(hDlg, IDOK == LOWORD(wParam) ? IsDlgButtonChecked(hDlg, IDC_IEHARDEN_DONT_SHOW) : FALSE);
                    break;
            }
            break;

        case WM_NOTIFY:
            if (IDC_IEHARDEN_HELP == LOWORD(wParam))
            {
                NMHDR *pnmh = (NMHDR*) lParam;
                if ((NM_CLICK == pnmh->code) || (NM_RETURN == pnmh->code))
                {
                    ShowUrlInNewBrowserInstance(L"res://shdoclc.dll/IESechelp.htm");
                }
            }
            break;
    }

    return fRet;
}

#define REGSTR_VAL_IEHARD_NOWARN     L"IEHardenIENoWarn"
#define REGSTR_VAL_OCHARD_NOWARN     L"IEHardenOCNoWarn"

BOOL UserDisabledIEHardNavWarning(BOOL fIE)
{
    BOOL fRet = FALSE;

    DWORD dwVal;
    DWORD dwSize = sizeof(dwVal);
    if (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_PATH_INTERNET_SETTINGS, fIE ? REGSTR_VAL_IEHARD_NOWARN : REGSTR_VAL_OCHARD_NOWARN, NULL,
                                         &dwVal, &dwSize, FALSE, NULL, 0))
    {
        fRet = (1 == dwVal);
    }

    return fRet;
}

BOOL IEHard_ShowOnNavigateComplete()
{
    BOOL fRet = FALSE;

    DWORD dwVal;
    DWORD cbSize = sizeof(dwVal);
    if (ERROR_SUCCESS == SHRegGetUSValue(REGSTR_PATH_INTERNET_SETTINGS, L"IEHardenWarnOnNav", NULL,
                                         &dwVal, &cbSize, FALSE, NULL, 0))
    {
        fRet = (1 == dwVal);
    }

    return fRet;
}

BOOL IEHard_HostedInIE(IUnknown* punk)
{
    BOOL fRet;

    IWebBrowserApp* pwba;
    if (SUCCEEDED(IUnknown_QueryServiceForWebBrowserApp(punk, IID_IWebBrowserApp, (void**)&pwba)))
    {
        ITargetEmbedding* pte;
        if (SUCCEEDED(pwba->QueryInterface(IID_ITargetEmbedding, (void**)&pte)))
        {
            fRet = FALSE;
            pte->Release();
        }
        else
        {
            fRet = TRUE;
        }
        pwba->Release();
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

void IEHard_NavWarning(HWND hwnd, BOOL fIE)
{
    if (hwnd && fIE && IEHardened() && !UserDisabledIEHardNavWarning(fIE))
    {
        BOOL fDontShow = (BOOL)SHFusionDialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_IEHARDEN1), hwnd, IEHard_WarnDlgProc, fIE);

        if (fDontShow)
        {
            DWORD dwVal = 1;
            SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_INTERNET_SETTINGS, fIE ? REGSTR_VAL_IEHARD_NOWARN : REGSTR_VAL_OCHARD_NOWARN,
                       REG_DWORD, &dwVal, sizeof(dwVal));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\iedde.cpp ===
/* Copyright 1996 Microsoft */

#include "priv.h"

#ifdef DEBUG

#define ENTERPROC EnterProc
#define EXITPROC ExitProc

void EnterProc(DWORD dwTraceLevel, LPTSTR szFmt, ...);
void ExitProc(DWORD dwTraceLevel, LPTSTR szFmt, ...);

extern DWORD g_dwIEDDETrace;

#else

#pragma warning(disable:4002)

#ifndef UNIX

#ifndef CCOVER
#define ENTERPROC()
#define EXITPROC()
#else //CCOVER

// these are needed because of a bug in cl.exe which causes 
// compilation problems with #pragma when a program is preprocessed
// and compiled separately

#define ENTERPROC 1 ? (void) 0 : (void)
#define EXITPROC 1 ? (void) 0 : (void)
#endif // CCOVER

#else
#define ENTERPROC EnterProc
#define EXITPROC ExitProc
inline void EnterProc(DWORD dwTraceLevel, LPTSTR szFmt, ...){}
inline void ExitProc(DWORD dwTraceLevel, LPTSTR szFmt, ...){}
#endif

#endif

//
// Forward reference.
//
class CIEDDEThread;

//
// Stored in _hdsaWinitem
//
typedef struct _tagWinItem
{
    DWORD           dwWindowID;     // Synthetic window ID exposed in IEDDE interfaces
    HWND            hwnd;           // Actual hwnd of browser window
    DWORD           dwThreadID;     // ThreadID for this browser window
    CIEDDEThread    *pidt;          // Thread specific data and methods
} WINITEM;

//
// Stored in _hdsaProtocolHandler
//
typedef struct _tagProtocolReg
{
    LPTSTR  pszProtocol;
    LPTSTR  pszServer;
} PROTOCOLREG;

#define TEN_SECONDS         (10 * 1000)
#define DXA_GROWTH_AMOUNT   (10)

#ifndef UNIX
#define IEXPLORE_STR "IEXPLORE"
#else
#define IEXPLORE_STR "iexplorer"
#endif

static const TCHAR c_szIExplore[] = TEXT(IEXPLORE_STR);
static const TCHAR c_szReturn[] = TEXT("Return");
static const TCHAR c_szWWWOpenURL[] = TEXT("WWW_OpenURL");
static const TCHAR c_szWWWUrlEcho[] = TEXT("WWW_URLEcho");

typedef struct _tagDDETHREADINFO
{
    DWORD       dwDDEInst;
    HSZ         hszService;
    HSZ         hszReturn;
    HDDEDATA    hddNameService;
} DDETHREADINFO;

class CIEDDEThread {
public:
    CIEDDEThread() { };
    ~CIEDDEThread() { };

    void GetDdeThreadInfo(DDETHREADINFO *pdti) { *pdti = _dti; }
    void SetDdeThreadInfo(DDETHREADINFO *pdti) { _dti = *pdti; }
    HDDEDATA OnRequestPoke(HSZ hszTopic, HSZ hszParams);
    HDDEDATA OnExecute(HSZ hszTopic, HDDEDATA hddParams);

    HDDEDATA CallTopic(DWORD dwType, LPCTSTR pszTopic, LPTSTR pszParams);

protected:
    DDETHREADINFO   _dti;

    HDDEDATA DoNavigate(LPTSTR pszLocation, HWND hwnd, BOOL bLaunchNewWindow);
    BOOL MakeQuotedString(LPCTSTR pszInput, LPTSTR pszOutput, int cchOutput);
    HDDEDATA CreateReturnObject(LPVOID p, DWORD cb);
    HDDEDATA CreateReturnStringObject(LPTSTR pszReturnString, DWORD cch);


    BOOL ParseString(LPTSTR *ppsz, LPTSTR *ppszString);
    BOOL ParseQString(LPTSTR *ppsz, LPTSTR *ppszString);
    BOOL ParseNumber(LPTSTR *ppsz, DWORD *pdw);
    BOOL ParseWinitem(LPTSTR *ppsz, WINITEM *pwi);

    HDDEDATA WWW_GetWindowInfo(LPTSTR pszParams);
    HDDEDATA WWW_OpenURL(LPTSTR pszParams);
    HDDEDATA WWW_OpenURLNewWindow(LPTSTR pszParams);
    HDDEDATA WWW_ShowFile(LPTSTR pszParams);
    HDDEDATA WWW_Activate(LPTSTR pszParams);
    HDDEDATA WWW_Exit(LPTSTR pszParams);
    HDDEDATA WWW_RegisterURLEcho(LPTSTR pszParams);
    HDDEDATA WWW_UnregisterURLEcho(LPTSTR pszParams);
    HDDEDATA WWW_RegisterProtocol(LPTSTR pszParams);
    HDDEDATA WWW_UnregisterProtocol(LPTSTR pszParams);
    HDDEDATA WWW_ListWindows(LPTSTR pszParams);
};

class CIEDDE {
public:
    CIEDDE() { };
    ~CIEDDE() { };

    BOOL IsAutomationReady(void) { return _fAutomationReady; }
    BOOL GetWinitemFromWindowID(DWORD dwWindowID, WINITEM *pwi);
    BOOL GetWinitemFromHwnd(HWND hwnd, WINITEM *pwi);
    BOOL AddUrlEcho(LPCTSTR pszUrlEcho);
    BOOL RemoveUrlEcho(LPCTSTR pszUrlEcho);
    BOOL AddProtocolHandler(LPCTSTR pszServer, LPCTSTR pszProtocol);
    BOOL RemoveProtocolHandler(LPCTSTR pszServer, LPCTSTR pszProtocol);
    HDSA GetHdsaWinitem(void) { return _hdsaWinitem; }
    static HDDEDATA DdeCallback(UINT dwType, UINT dwFmt, HCONV hconv, HSZ hsz1, HSZ hsz2, HDDEDATA hdd, DWORD dwData1, DWORD dwData2);
    void EnterCrit(void) { ASSERT(_fCSInitialized); EnterCriticalSection(&_csIEDDE); }
    void LeaveCrit(void) { ASSERT(_fCSInitialized); LeaveCriticalSection(&_csIEDDE); }
    void SetDelayedExecute(LPCTSTR pszTopic, LPCTSTR pszParams);
    void RunDelayedExecute();
    
protected:
    BOOL _fAutomationReady;
    HDSA _hdsaWinitem;
    HDSA _hdsaProtocolHandler;
    HDPA _hdpaUrlEcho;
    BOOL _fCSInitialized;
    CRITICAL_SECTION _csIEDDE;
    DWORD _dwThreadID;
    LPTSTR _pszTopic;
    LPTSTR _pszParams;

    HDDEDATA _SendDDEMessageHsz(DWORD dwDDEInst, HSZ hszApp, HSZ hszTopic, HSZ hszMessage, UINT wType);
    HDDEDATA _SendDDEMessageSz(DWORD dwDDEInst, LPCTSTR pszApp, LPCTSTR pszTopic, LPCTSTR pszMessage, UINT wType);

    static int _DestroyProtocol(LPVOID p1, LPVOID p2);
    static int _DestroyUrlEcho(LPVOID p1, LPVOID p2);
    static int _DestroyWinitem(LPVOID p1, LPVOID p2);

    BOOL _GetWinitemFromThread(DWORD dwThreadID, WINITEM *pwi);
    BOOL _GetDtiFromThread(DWORD dwThreadID, DDETHREADINFO *pdti);

    BOOL _CreateDdeThreadInfo(DDETHREADINFO *pdti);
    void _DestroyDdeThreadInfo(DDETHREADINFO *pdti);
    BOOL _AddWinitem(WINITEM *pwi);
    BOOL _UpdateWinitem(WINITEM *pwi);
    BOOL _DeleteWinitemByHwnd(HWND hwnd, WINITEM *pwi);

    BOOL _Initialize(void);
    void _Uninitialize(void);
    void _AutomationStarted(void);
    HRESULT _BeforeNavigate(LPCTSTR pszURL, BOOL *pfProcessed);
    HRESULT _AfterNavigate(LPCTSTR pszURL, HWND hwnd);
    BOOL _NewWindow(HWND hwnd);
    BOOL _WindowDestroyed(HWND hwnd);

    friend BOOL IEDDE_Initialize(void);
    friend void IEDDE_Uninitialize(void);
    friend void IEDDE_AutomationStarted(void);
    friend HRESULT IEDDE_BeforeNavigate(LPCWSTR pwszURL, BOOL *pfProcessed);
    friend HRESULT IEDDE_AfterNavigate(LPCWSTR pwszURL, HWND hwnd);
    friend BOOL IEDDE_NewWindow(HWND hwnd);
    friend BOOL IEDDE_WindowDestroyed(HWND hwnd);
};
CIEDDE *g_pIEDDE = NULL;

#define ENTER_IEDDE_CRIT g_pIEDDE->EnterCrit()
#define LEAVE_IEDDE_CRIT g_pIEDDE->LeaveCrit()



//
// There is one CIEDDEThread object per browser window.
// Its private data consists of DDE handles, which are
// necessarily valid only in the thread that created them.
//
// Its methods consist of three broad categories:
//      the parser
//      the dispatcher
//      one handler for each DDE topic
//







//
// CreateReturnObject - creates a dde data item.
//
#define CREATE_HDD(x) CreateReturnObject(&x, SIZEOF(x))
HDDEDATA CIEDDEThread::CreateReturnObject(LPVOID p, DWORD cb)
{
    HDDEDATA hddRet;

    ENTERPROC(2, TEXT("CreateReturnObject(p=%08X,cb=%d)"), p, cb);

    hddRet = DdeCreateDataHandle(_dti.dwDDEInst, (BYTE *)p, cb, 0, _dti.hszReturn, CF_TEXT, 0);

    if (hddRet == 0)
    {
        TraceMsg(TF_WARNING, "IEDDE: Could not create return object");
    }

    EXITPROC(2, TEXT("CreateReturnObject=%08X"), hddRet);
    return hddRet;
}

HDDEDATA CIEDDEThread::CreateReturnStringObject(LPTSTR pszReturnString, DWORD cch)
{
    HDDEDATA hddRet = 0;

    ENTERPROC(2, TEXT("CreateReturnStringObject(p=%s,cb=%d)"), pszReturnString, cch);

    //
    // REVIEW I thought specifying CF_UNICODETEXT should have worked, but... 
    // it didn't, so always return ANSI string as out string params
    // - julianj
    //
    LPSTR pszAnsiBuf = (LPSTR)LocalAlloc(LPTR, cch+1);
    if (pszAnsiBuf)
    {
        SHUnicodeToAnsi(pszReturnString, pszAnsiBuf, cch+1);
        hddRet = DdeCreateDataHandle(_dti.dwDDEInst, (BYTE *)pszAnsiBuf, (cch+1), 0, _dti.hszReturn, CF_TEXT, 0);
        LocalFree(pszAnsiBuf);
        pszAnsiBuf = NULL;
    }
    
    if (hddRet == 0)
    {
        TraceMsg(TF_WARNING, "IEDDE: Could not create return object");
    }

    EXITPROC(2, TEXT("CreateReturnObject=%08X"), hddRet);
    return hddRet;
}


//
// OnRequestPoke - handle XTYP_REQUEST and XTYP_POKE
//
HDDEDATA CIEDDEThread::OnRequestPoke(HSZ hszTopic, HSZ hszParams)
{
    HDDEDATA hddRet = 0;
    ENTERPROC(2, TEXT("OnRequestPoke(hszTopic=%08X,hszParams=%08X)"), hszTopic, hszParams);

    TCHAR szTopic[100];
    TCHAR szParams[1000];

    if (DdeQueryString(_dti.dwDDEInst, hszTopic, szTopic, ARRAYSIZE(szTopic), CP_WINNEUTRAL) != 0)
    {
        if (DdeQueryString(_dti.dwDDEInst, hszParams, szParams, ARRAYSIZE(szParams), CP_WINNEUTRAL))
        {
            hddRet = CallTopic(XTYP_REQUEST, szTopic, szParams);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: OnRequestPoke could not query the parameters");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: OnRequestPoke could not query the topic");
    }

    EXITPROC(2, TEXT("OnRequestPoke=%08X"), hddRet);
    return hddRet;
}

//
// OnExecute - handle XTYP_EXECUTE
//
HDDEDATA CIEDDEThread::OnExecute(HSZ hszTopic, HDDEDATA hddParams)
{
    HDDEDATA hddRet = 0;
    ENTERPROC(2, TEXT("OnExecute(hszTopic=%08X,hddParams=%08X)"), hszTopic, hddParams);

    TCHAR szTopic[100];

    if (DdeQueryString(_dti.dwDDEInst, hszTopic, szTopic, ARRAYSIZE(szTopic), CP_WINNEUTRAL) != 0)
    {
        //
        // Why "cbParams + 3"?
        // UNICODE - if we cut the last unicode character in half, we need
        //           one 0 to finish the character, and two more 0 for the
        //           terminating NULL
        // ANSI - if we cut the last DBCS character in half, we need one 0
        //        to finish the character, and one 0 for the terminating NULL
        //
        //
        DWORD cbParams = DdeGetData(hddParams, NULL, 0, 0) + 3;
        LPTSTR pszParams = (LPTSTR) LocalAlloc(LPTR, cbParams);

        if(pszParams)
        {
            DdeGetData(hddParams, (BYTE *)pszParams, cbParams, 0);
            //
            // DdeGetData can't be wrapped in shlwapi since it can return non
            // string data.  Here we only expect strings so the result can be
            // safely converted.
            //
            if (g_fRunningOnNT)
            {
                hddRet = CallTopic(XTYP_EXECUTE, szTopic, pszParams);
            }
            else
            {
                WCHAR szParams[MAX_URL_STRING];
                SHAnsiToUnicode((LPCSTR)pszParams, szParams, ARRAYSIZE(szParams));
                hddRet = CallTopic(XTYP_EXECUTE, szTopic, szParams);
            }
            LocalFree(pszParams);
            pszParams = NULL;
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: OnExecute could not query the topic");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: OnExecute could not query the topic");
    }

    EXITPROC(2, TEXT("OnExecute=%08X"), hddRet);
    return hddRet;
}

//
// CallTopic - Looks up the command in the DDETOPICHANDLER table and calls the
// corresponding function.
//
HDDEDATA CIEDDEThread::CallTopic(DWORD dwType, LPCTSTR pszTopic, LPTSTR pszParams)
{
    HDDEDATA hddRet = DDE_FNOTPROCESSED;
    ENTERPROC(2, TEXT("CallTopic(wType=%d,pszTopic=>%s<,pszParams=>%s<)"), dwType, pszTopic, pszParams);

#define DISPATCH_BEGIN
#define DISPATCH(topic)                                 \
    if (StrCmpI(TEXT("WWW_") TEXT(#topic), pszTopic) == 0)   \
    {                                                   \
        if (fCanRun)                                    \
        {                                               \
            hddRet = WWW_ ## topic(pszParams);          \
        }                                               \
        else                                            \
        {                                               \
            fAbortedRun = TRUE;                         \
        }                                               \
    }                                                   \
    else
#define DISPATCH_END { TraceMsg(TF_WARNING, "IEDDE: CallTopic given unknown topic"); }

    BOOL fAbortedRun = FALSE;
    BOOL fCanRun = ((dwType != XTYP_EXECUTE) || g_pIEDDE->IsAutomationReady());

    DISPATCH_BEGIN
        DISPATCH(GetWindowInfo)
        DISPATCH(OpenURL)
        DISPATCH(ShowFile)
        DISPATCH(Activate)
        DISPATCH(Exit)
        DISPATCH(RegisterURLEcho)
        DISPATCH(UnregisterURLEcho)
        DISPATCH(RegisterProtocol)
        DISPATCH(UnregisterProtocol)
        DISPATCH(ListWindows)
        DISPATCH(OpenURLNewWindow)
    DISPATCH_END

    if (fAbortedRun)
    {
        if (dwType == XTYP_EXECUTE)
        {
            g_pIEDDE->SetDelayedExecute(pszTopic, pszParams);
        }
        hddRet = (HDDEDATA)DDE_FACK;
        TraceMsg(TF_WARNING, "IEDDE: CallTopic received XTYP_EXECUTE before Automation was ready - not processing");
    }

    EXITPROC(2, TEXT("CallTopic=%08X"), hddRet);
    return hddRet;
}

//
// ParseString - parse one string
//
BOOL CIEDDEThread::ParseString(LPTSTR *ppsz, LPTSTR *ppszString)
{
    BOOL fRet = FALSE;

    ENTERPROC(3, TEXT("ParseString(ppsz=%08X,ppszString=%08X)"), ppsz, ppszString);

    LPTSTR pchCurrent, pchNext;
    BOOL fInQuote = FALSE;

    pchCurrent = pchNext = *ppsz;
    while (*pchNext)
    {
        switch (*pchNext)
        {
        case TEXT(' '):
        case TEXT('\t'):
            if (fInQuote)
            {
                //
                // Skip over whitespace when not inside quotes.
                //
                *pchCurrent++ = *pchNext;
            }
            pchNext++;
            break;

        case TEXT('"'):
            //
            // Always copy quote marks.
            //
            fInQuote = !fInQuote;
            *pchCurrent++ = *pchNext++;
            break;

        case TEXT(','):
            if (!fInQuote)
            {
                goto done_parsing;
            }
            *pchCurrent++ = *pchNext++;
            break;

        case TEXT('\\'):
            if (fInQuote &&
                (*(pchNext+1) == TEXT('"')))
            {
                //
                // When in quotes, a \" becomes a ".
                //
                pchNext++;
            }
            *pchCurrent++ = *pchNext++;
            break;

        default:
            *pchCurrent++ = *pchNext++;
            break;
        }
    }
done_parsing:

    //
    // Advance past the comma separator.
    //
    if (*pchNext == TEXT(','))
    {
        pchNext++;
    }

    //
    // NULL terminate the return string.
    //
    *pchCurrent = TEXT('\0');

    //
    // Set the return values.
    //
    *ppszString = *ppsz;
    *ppsz = pchNext;
    fRet = TRUE;

    EXITPROC(3, TEXT("ParseString=%d"), fRet);
    return fRet;
}

//
// ParseQString - parse one quoted string
//
BOOL CIEDDEThread::ParseQString(LPTSTR *ppsz, LPTSTR *ppszString)
{
    BOOL fRet = FALSE;

    ENTERPROC(3, TEXT("ParseQString(ppsz=%08X,ppszString=%08X)"), ppsz, ppszString);

    if (ParseString(ppsz, ppszString))
    {
        LPTSTR pszString = *ppszString;
        int cch = lstrlen(pszString);

        //
        // Strip off optional outer quotes.
        //
        if ((cch >= 2) &&
            (pszString[0] == TEXT('"')) &&
            (pszString[cch-1] == TEXT('"')))
        {
            pszString[0] = pszString[cch-1] = TEXT('\0');
            *ppszString = pszString + 1;
        }

        fRet = TRUE;
    }

    EXITPROC(3, TEXT("ParseQString=%d"), fRet);
    return fRet;
}

//
// ParseNumber - parse one numeric value
//
BOOL CIEDDEThread::ParseNumber(LPTSTR *ppsz, DWORD *pdw)
{
    BOOL fRet = FALSE;
    LPTSTR pszNumber;

    ENTERPROC(3, TEXT("GetNumber(ppsz=%08X,pdw=%08X)"), ppsz, pdw);

    if (ParseString(ppsz, &pszNumber) && pszNumber[0])
    {
        StrToIntEx(pszNumber, STIF_SUPPORT_HEX, (int *)pdw);
        fRet = TRUE;
    }

    EXITPROC(3, TEXT("GetNumber=%d"), fRet);
    return fRet;
}

//
// ParseWinitem - parse one window ID, and return the winitem
//
BOOL CIEDDEThread::ParseWinitem(LPTSTR *ppsz, WINITEM *pwi)
{
    BOOL fRet = FALSE;
    DWORD dwWindowID;

    ENTERPROC(3, TEXT("ParseWinitem(ppsz=%08X,pwi=%08X)"), ppsz, pwi);

    if (ParseNumber(ppsz, &dwWindowID))
    {
        switch (dwWindowID)
        {
        case 0:
        case -1:
            ZeroMemory(pwi, SIZEOF(*pwi));
            pwi->dwWindowID = dwWindowID;
            pwi->hwnd = (HWND)LongToHandle(dwWindowID);
            fRet = TRUE;
            break;

        default:
            fRet = g_pIEDDE->GetWinitemFromWindowID(dwWindowID, pwi);
            break;
        }
    }

    EXITPROC(3, TEXT("ParseWinitem=%d"), fRet);
    return fRet;
}

//
//  WWW_GetWindowInfo - get information about a browser window
//
//  Parameters:
//      dwWindowID - Window ID to examine (-1 = last active window)
//
//  Returns:
//      qcsURL,qcsTitle
//
HDDEDATA CIEDDEThread::WWW_GetWindowInfo(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    WINITEM wi;

    ENTERPROC(1, TEXT("WWW_GetWindowInfo(pszParams=>%s<)"), pszParams);

    if (ParseWinitem(&pszParams, &wi) &&
        (wi.hwnd != 0))
    {
        BSTR bstrURL;

        if (SUCCEEDED(CDDEAuto_get_LocationURL(&bstrURL, wi.hwnd)) && (bstrURL != (BSTR)-1))
        {
            BSTR bstrTitle;

            if (SUCCEEDED(CDDEAuto_get_LocationTitle(&bstrTitle, wi.hwnd)) && (bstrTitle != (BSTR)-1))
            {
                LPTSTR pszURL, pszTitle;


                pszURL = bstrURL;
                pszTitle = bstrTitle;

                if (pszURL && pszTitle)
                {
                    TCHAR szURLQ[MAX_URL_STRING];
                    TCHAR szTitleQ[MAX_URL_STRING];

                    if (MakeQuotedString(pszURL, szURLQ, ARRAYSIZE(szURLQ)) &&
                        MakeQuotedString(pszTitle, szTitleQ, ARRAYSIZE(szTitleQ)))
                    {
                        DWORD cchBuffer = lstrlen(szURLQ) + 1 + lstrlen(szTitleQ) + 1;
                        LPTSTR pszBuffer = (LPTSTR)LocalAlloc(LPTR, cchBuffer * SIZEOF(TCHAR));

                        if (pszBuffer)
                        {
                            wnsprintf(pszBuffer, cchBuffer, TEXT("%s,%s"), szURLQ, szTitleQ);
                            hddRet = CreateReturnStringObject(pszBuffer, lstrlen(pszBuffer));
                            LocalFree(pszBuffer);
                            pszBuffer = NULL;
                        }
                        else
                        {
                            TraceMsg(TF_WARNING, "IEDDE: GetWindowInfo could not alloc buffer");
                        }
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "IEDDE: GetWindowInfo could not quote return strings");
                    }
                }

                SysFreeString(bstrTitle);
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: GetWindowInfo could not get title");
            }

            SysFreeString(bstrURL);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: GetWindowInfo could not get URL");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: GetWindowInfo could not parse parameters");
    }

    EXITPROC(1, TEXT("WWW_GetWindowInfo=%08X"), hddRet);
    return hddRet;
}

//
//  WWW_OpenURLNewWindow - navigate to a URL (but make sure to spawn a new window)
//
//  NOTE: this code was stolen from IEDDEThread::WWW_OpenURL below
//
HDDEDATA CIEDDEThread::WWW_OpenURLNewWindow(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    LPTSTR pszUrl, pszFile;

    ENTERPROC(1, TEXT("WWW_OpenURLNewWindow(pszParams=>%s<)"), pszParams);

    if (*pszParams == TEXT('\0') || *pszParams == TEXT('*'))
    {
        // An empty string is a NOOP.
    }
    else if (ParseQString(&pszParams, &pszUrl) &&
        ParseQString(&pszParams, &pszFile))
    {
        // null hwnd & bLaunchNewWindow = TRUE means "launch a new window",
        // which is exactly what we want to do in the WWW_OpenURLNewWindow case
        hddRet = DoNavigate(pszUrl, NULL, TRUE);
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: WWW_OpenURLNewWindow could not parse parameters");
    }

    EXITPROC(1, TEXT("WWW_OpenURL=%08X"), hddRet);
    return hddRet;
}

//
//  WWW_OpenURL - navigate to a URL
//
//  Parameters:
//      qcsURL - url to navigate to
//      qcsSaveFile - [optional] file to save contents in
//      dwWindowID - Window ID to perform navigation
//      dwFlags - flags for navigation
//      qcsPostFormData - [optional] form data to post to URL
//      qcsPostMIMEType - [optional] mime type for form data
//      csProgressServer - [optional] DDE server to get progress updates
//
//  Returns:
//      dwWindowID - window which is doing the work
//
HDDEDATA CIEDDEThread::WWW_OpenURL(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    LPTSTR pszUrl, pszFile;
    WINITEM wi;

    ENTERPROC(1, TEXT("WWW_OpenURL(pszParams=>%s<)"), pszParams);

    if (*pszParams == TEXT('\0') || *pszParams == TEXT('*'))
    {
        // An empty string is a NOOP.  Needed for NT #291766
    }
    else if (ParseQString(&pszParams, &pszUrl) &&
             ParseQString(&pszParams, &pszFile))
    {
        //
        // APPCOMPAT - a missing hwnd parameter implies -1.
        //
        if (!ParseWinitem(&pszParams, &wi))
        {
            TraceMsg(TF_WARNING, "IEDDE: Some bozo isn't giving the required hwnd parameter to WWW_OpenURL, assuming -1");
            wi.hwnd = (HWND)-1;
        }

#ifdef DEBUG
        DWORD dwFlags;
        if (!ParseNumber(&pszParams, &dwFlags))
        {
            TraceMsg(TF_WARNING, "IEDDE: Some bozo isn't giving the required dwFlags parameter to WWW_OpenURL");
        }
#endif

        hddRet = DoNavigate(pszUrl, wi.hwnd, FALSE);
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: OpenURL could not parse parameters");
    }

    EXITPROC(1, TEXT("WWW_OpenURL=%08X"), hddRet);
    return hddRet;
}

//
//  WWW_ShowFile - navigate to a file
//
//  Parameters:
//      qcsFilename - file to load
//      qcsPostMIMEType - [optional] mime type for form data
//      dwWindowID - Window ID to perform navigation
//      qcsURL - URL of the same document
//
//  Returns:
//      dwWindowID - window which is doing the work
//
HDDEDATA CIEDDEThread::WWW_ShowFile(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    LPTSTR pszFilename, pszMIMEType;
    WINITEM wi;

    ENTERPROC(1, TEXT("WWW_ShowFile(pszParams=>%s<)"), pszParams);

    if (ParseQString(&pszParams, &pszFilename) && pszFilename[0])
    {
        if (!ParseQString(&pszParams, &pszMIMEType) || !pszMIMEType[0])
        {
            TraceMsg(TF_WARNING, "IEDDE: Some bozo isn't giving the required MIMEType parameter to WWW_ShowFile");
        }
        if (!ParseWinitem(&pszParams, &wi))
        {
            TraceMsg(TF_WARNING, "IEDDE: Some bozo isn't giving the required dwWindowID parameter to WWW_ShowFile, assuming -1");
            wi.hwnd = (HWND)-1;
        }

#ifdef DEBUG
        LPTSTR pszURL;

        if (!ParseQString(&pszParams, &pszURL) || !pszURL[0])
        {
            TraceMsg(TF_WARNING, "IEDDE: Some bozo isn't giving the required szURL parameter to WWW_ShowFile");
        }
#endif
        hddRet = DoNavigate(pszFilename, wi.hwnd, FALSE);
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: ShowFile could not parse parameters");
    }

    EXITPROC(1, TEXT("WWW_ShowFile=%08X"), hddRet);
    return hddRet;
}

//
// DoNavigate - navigate to a location
//
HDDEDATA CIEDDEThread::DoNavigate(LPTSTR pszLocation, HWND hwnd, BOOL bLaunchNewWindow)
{
    HDDEDATA hddRet = 0;
    HRESULT hr = S_OK;
    TCHAR szParsedPath[MAX_URL_STRING+1];
    DWORD cchParsedPath = ARRAYSIZE(szParsedPath);

    ENTERPROC(2, TEXT("DoNavigate(pszLocation=>%s<,hwnd=%08X)"), pszLocation, hwnd);

    //
    // Convert URL from outside format to internal format.
    //
    if (ParseURLFromOutsideSource(pszLocation, szParsedPath, &cchParsedPath, NULL))
    {
        pszLocation = szParsedPath;
    }

    //
    // In the case of a file:// URL, convert the location to a path.
    //
    cchParsedPath = ARRAYSIZE(szParsedPath);
    if (IsFileUrlW(pszLocation) && SUCCEEDED(PathCreateFromUrl(pszLocation, szParsedPath, &cchParsedPath, 0)))
    {
        pszLocation = szParsedPath;
    }

    LPWSTR pwszPath;

    pwszPath = pszLocation;

    if (SUCCEEDED(hr))
    {
        hr = CDDEAuto_Navigate(pwszPath, &hwnd, bLaunchNewWindow ? 1 : 0);
    }

    DWORD dwServicingWindow = SUCCEEDED(hr) ? -2 : -3;

    hddRet = CREATE_HDD(dwServicingWindow);

    EXITPROC(2, TEXT("DoNavigate=%08X"), hddRet);
    return hddRet;
}

//
//  WWW_Activate - activate a browser window
//
//  Parameters:
//      dwWindowID - Window ID to activate
//      dwFlags - should always zero
//
//  Returns:
//      dwWindowID - window ID that got activated
//
HDDEDATA CIEDDEThread::WWW_Activate(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    WINITEM wi;

    ENTERPROC(1, TEXT("WWW_Activate(pszParams=>%s<)"), pszParams);

    if (ParseWinitem(&pszParams, &wi) &&
        wi.dwWindowID != 0)
    {
#ifdef DEBUG
        DWORD dwFlags;
        if (ParseNumber(&pszParams, &dwFlags))
        {
            //
            // Netscape spec says this should always be zero.
            //
            ASSERT(dwFlags == 0);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: Some bozo isn't giving the required dwFlags parameter to WWW_Activate");
        }
#endif

        //
        // dwWindowID of -1 means use the active window.
        //
        if (wi.dwWindowID == -1)
        {
            HWND hwnd;

            CDDEAuto_get_HWND((long *)&hwnd);

            if (hwnd)
            {
                if (g_pIEDDE->GetWinitemFromHwnd(hwnd, &wi) == FALSE)
                {
                    wi.dwWindowID = (DWORD)-1;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: Activate could not find an active window");
            }
        }

        //
        // Activate the window.
        //
        if (wi.dwWindowID != -1)
        {
            if ((GetForegroundWindow() == wi.hwnd) || (SetForegroundWindow(wi.hwnd)))
            {
                if (IsIconic(wi.hwnd))
                {
                    ShowWindow(wi.hwnd, SW_RESTORE);
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: Activate could not set foreground window");
            }
            
            hddRet = CREATE_HDD(wi.dwWindowID);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: Activate could not find a browser window to activate");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: Activate could not parse parameters");
    }

    EXITPROC(1, TEXT("WWW_Activate=%08X"), hddRet);
    return hddRet;
}


//
//  WWW_Exit - close all browser windows
//
//  Parameters:
//      none
//
//  Returns:
//      none
//
HDDEDATA CIEDDEThread::WWW_Exit(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;

    ENTERPROC(1, TEXT("WWW_Exit(pszParams=>%s<)"), pszParams);

    CDDEAuto_Exit();

    EXITPROC(1, TEXT("WWW_Exit=%08X"), hddRet);
    return hddRet;
}


//
//  WWW_RegisterURLEcho - register a server for URL change notifications
//
//  Parameters:
//      qcsServer - the DDE server to get notifications
//
//  Returns:
//      fSuccess
//
HDDEDATA CIEDDEThread::WWW_RegisterURLEcho(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    BOOL fSuccess = FALSE;
    LPTSTR pszServer;

    ENTERPROC(1, TEXT("WWW_RegisterURLEcho(pszParams=>%s<)"), pszParams);

    if (ParseQString(&pszParams, &pszServer) && pszServer[0])
    {
        LPTSTR pszServerCopy = StrDup(pszServer);

        if (pszServerCopy)
        {
            if (g_pIEDDE->AddUrlEcho(pszServerCopy))
            {
                fSuccess = TRUE;
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: RegisterURLEcho could not add an URLEcho");
            }

            if (!fSuccess)
            {
                LocalFree(pszServerCopy);
                pszServerCopy = NULL;
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: RegisterURLEcho could not dup a string");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: RegisterURLEcho could not parse parameters");
    }

    hddRet = CREATE_HDD(fSuccess);

    EXITPROC(1, TEXT("WWW_RegisterURLEcho=%08X"), hddRet);
    return hddRet;
}


//
//  WWW_UnregisterURLEcho - unregister a DDE server
//
//  Parameters:
//      qcsServer - the DDE server to stop getting notifications
//
//  Returns:
//      fSuccess
//
HDDEDATA CIEDDEThread::WWW_UnregisterURLEcho(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    BOOL fSuccess = FALSE;
    LPTSTR pszServer;

    ENTERPROC(1, TEXT("WWW_UnregisterURLEcho(pszParams=>%s<)"), pszParams);

    if (ParseQString(&pszParams, &pszServer) && pszServer[0])
    {
        if (g_pIEDDE->RemoveUrlEcho(pszServer))
        {
            fSuccess = TRUE;
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: UnregisterURLEcho could not find the server");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: UnregisterURLEcho could not parse parameters");
    }

    hddRet = CREATE_HDD(fSuccess);

    EXITPROC(1, TEXT("WWW_UnregisterURLEcho=%08X"), hddRet);
    return hddRet;
}

//
//  WWW_RegisterProtocol - register a server for handling a protocol
//
//  Parameters:
//      qcsServer - the DDE server to handle URLs
//      qcsProtocol - the protocol to handle
//
//  Returns:
//      fSuccess - this is the first server to register the protocol
//
HDDEDATA CIEDDEThread::WWW_RegisterProtocol(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    BOOL fSuccess = FALSE;
    LPTSTR pszServer, pszProtocol;

    ENTERPROC(1, TEXT("WWW_RegisterProtocol(pszParams=>%s<)"), pszParams);

    if (ParseQString(&pszParams, &pszServer) && pszServer[0] &&
        ParseQString(&pszParams, &pszProtocol) && pszProtocol[0])
    {
        if (g_pIEDDE->AddProtocolHandler(pszServer, pszProtocol))
        {
            fSuccess = TRUE;
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: RegisterProtocol unable to register");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: RegisterProtocol could not parse parameters");
    }

    hddRet = CREATE_HDD(fSuccess);

    EXITPROC(1, TEXT("WWW_RegisterProtocol=%08X"), hddRet);
    return hddRet;
}

//
//  WWW_UnregisterProtocol - unregister a server handling a protocol
//
//  Parameters:
//      qcsServer - the DDE server which is handling URLs
//      qcsProtocol - the protocol getting handled
//
//  Returns:
//      fSuccess - this server was registered, but now isn't
//
HDDEDATA CIEDDEThread::WWW_UnregisterProtocol(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    BOOL fSuccess = FALSE;
    LPTSTR pszServer, pszProtocol;

    ENTERPROC(1, TEXT("WWW_UnregisterProtocol(pszParams=>%s<)"), pszParams);

    if (ParseQString(&pszParams, &pszServer) && pszServer[0] &&
        ParseQString(&pszParams, &pszProtocol) && pszProtocol[0])
    {
        if (g_pIEDDE->RemoveProtocolHandler(pszServer, pszProtocol))
        {
            fSuccess = TRUE;
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: UnregisterProtocol unable to unregister");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: UnregisterProtocol could not parse parameters");
    }

    hddRet = CREATE_HDD(fSuccess);

    EXITPROC(1, TEXT("WWW_UnregisterProtocol=%08X"), hddRet);
    return hddRet;
}

//
//  WWW_ListWindows - Get a list of DDE supported browser window IDs
//
//  Parameters:
//      none
//
//  Returns:
//      pdwWindowID (terminated with 0)
//
HDDEDATA CIEDDEThread::WWW_ListWindows(LPTSTR pszParams)
{
    HDDEDATA hddRet = 0;
    ENTERPROC(1, TEXT("WWW_ListWindows(pszParams=>%s<)"), pszParams);

    ENTER_IEDDE_CRIT;

    DWORD cbAlloc, *pdwWindowID;
    int cWindows = 0;
    HDSA hdsaWinitem = g_pIEDDE->GetHdsaWinitem();

    if (hdsaWinitem)
    {
        cWindows = DSA_GetItemCount(hdsaWinitem);
    }

    //
    // Note: we are following the Netscape spec (null terminated pdw) here,
    // whereas IE3 followed the Spyglass spec (pdw[0] = count of windows).
    //

    cbAlloc = (cWindows + 1) * SIZEOF(DWORD);

    pdwWindowID = (DWORD *)LocalAlloc(LPTR, cbAlloc);
    if (pdwWindowID)
    {
        DWORD *pdw;

        pdw = pdwWindowID;

        for (int i=0; i<cWindows; i++)
        {
            WINITEM wi;

            int iResult = DSA_GetItem(hdsaWinitem, i, &wi);

            if (iResult != -1)
            {
                *pdw++ = wi.dwWindowID;
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: ListWindows could not get a DSA item");
            }
        }

        hddRet = CreateReturnObject(pdwWindowID, cbAlloc);
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: ListWindows could not allocate a window list");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(1, TEXT("WWW_ListWindows=%08X"), hddRet);
    return hddRet;
}

//
// MakeQuotedString - wrap a string in " marks, escaping internal "s as \"
//
BOOL CIEDDEThread::MakeQuotedString(LPCTSTR pszInput, LPTSTR pszOutput, int cchOutput)
{
    BOOL fRet = FALSE;

    ENTERPROC(2, TEXT("MakeQuotedString(pszInput=>%s<,pszOutput=%08X,cchOutput=%08X)"), pszInput, pszOutput, cchOutput);

    if (cchOutput < 3)
    {
        TraceMsg(TF_WARNING, "IEDDE: MakeQuotedString has no room for minimal quoted string");
    }
    else if ((pszInput == NULL) || (*pszInput == TEXT('\0')))
    {
        StrCpyN(pszOutput, TEXT("\"\""), cchOutput);
        fRet = TRUE;
    }
    else
    {
        //
        // Copy first quote mark.
        //
        *pszOutput++ = TEXT('"');
        cchOutput--;

        //
        // Copy pszInput, escaping quote marks and making
        // sure to leave room for final quote and NULL.
        //
        while ((cchOutput > 2) && (*pszInput))
        {
            if (*pszInput == TEXT('"'))
            {
                *pszOutput++ = TEXT('\\');
                cchOutput--;
            }
            *pszOutput++ = *pszInput++;
            cchOutput--;
        }

        //
        // Copy final quote and NULL if we're done and there is room.
        //
        if ((*pszInput == TEXT('\0')) && (cchOutput >= 2))
        {
            StrCpyN(pszOutput, TEXT("\""), cchOutput);
            fRet = TRUE;
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: MakeQuotedString ran out of room in output buffer");
        }
    }

    EXITPROC(2, TEXT("MakeQuotedString=%d"), fRet);
    return fRet;
}
















#undef CIEDDEThread

//
// There is one global CIEDDE object per process.
// It maintains the global information, such as
// the list of all browsers & what threads they are on,
// and the list of all apps who have registered an URL Echo.
//
// Its methods consist of these categories:
//      the DDE callback function
//      an internal handler for each exposed IEDDE_ function
//      database (hdsa, hdpa) access and manipulation functions
//
// This object creates and destroys CIEDDEThread objects
// (at NewWindow and WindowDestroyed time) and also initializes /
// uninitializes DDE services on a per thread (not per hwnd!) basis.
//



//
// DdeCallback - DDE callback function for IEDDE.
//
#define DDETYPESTR(x) (x == XTYP_REQUEST ? TEXT("Request") : \
                       (x == XTYP_POKE ? TEXT("Poke") : \
                       (x == XTYP_EXECUTE ? TEXT("Execute") : \
                       (x == XTYP_CONNECT ? TEXT("Connect") : TEXT("Unknown")))))
HDDEDATA CIEDDE::DdeCallback(UINT dwType, UINT dwFmt, HCONV hconv, HSZ hsz1, HSZ hsz2, HDDEDATA hdd, DWORD dwData1, DWORD dwData2)
{
    HDDEDATA    hddRet = 0;
    ENTERPROC(2, TEXT("DdeCallback(dwType=%08X(%s),dwFmt=%d,hconv=%d,hsz1=%08X,hsz2=%08X,hdd=%08X,dwData1=%08X,dwData2=%08X)"),
                dwType, DDETYPESTR(dwType), dwFmt, hconv, hsz1, hsz2, hdd, dwData1, dwData2);

    WINITEM wi;

    switch (dwType)
    {
    case XTYP_REQUEST:
    case XTYP_POKE:
        if (g_pIEDDE->_GetWinitemFromThread(GetCurrentThreadId(), &wi))
        {
            hddRet = wi.pidt->OnRequestPoke(hsz1, hsz2);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: DdeCallback unable to get thread info on request / poke");
        }
        break;

    case XTYP_EXECUTE:
        if (g_pIEDDE->_GetWinitemFromThread(GetCurrentThreadId(), &wi))
        {
            hddRet = wi.pidt->OnExecute(hsz1, hdd);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: DdeCallback unable to get thread info on execute");
        }
        break;

    case XTYP_CONNECT:
        if (g_pIEDDE->_GetWinitemFromThread(GetCurrentThreadId(), &wi))
        {
            DDETHREADINFO dti;
            wi.pidt->GetDdeThreadInfo(&dti);
            hddRet = (HDDEDATA)(hsz2 == dti.hszService);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: DdeCallback unable to get thread info on connect");
        }
        break;

    case XTYP_ADVREQ:
    case XTYP_ADVSTOP:
        hddRet = DDE_FNOTPROCESSED;
        break;
    }

    EXITPROC(2, TEXT("DdeCallback=%08X"), hddRet);
    return hddRet;
}

//
// SendDDEMessageHsz - handle based wrapper for doing one DDE client transaction
//
HDDEDATA CIEDDE::_SendDDEMessageHsz(DWORD dwDDEInst, HSZ hszApp, HSZ hszTopic, HSZ hszMessage, UINT wType)
{
    HDDEDATA hddRet = 0;

    ENTERPROC(2, TEXT("_SendDDEMessageHsz(dwDDEInst=%08X,hszApp=%08X,hszTopic=%08X,hszMessage=%08X,wType=%d)"), dwDDEInst, hszApp, hszTopic, hszMessage, wType);

    if (hszApp && hszTopic)
    {
        HCONV hconv;
        
        hconv = DdeConnect(dwDDEInst, hszApp, hszTopic, NULL);
        if (hconv)
        {
            hddRet = DdeClientTransaction(NULL, 0, hconv, hszMessage, CF_TEXT, wType, TEN_SECONDS, NULL);
            DdeDisconnect(hconv);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: _SendDDEMessageHsz could not connect to app");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _SendDDEMessageHsz is missing either App or Topic");
    }

    EXITPROC(2, TEXT("_SendDDEMessageHsz=%08X"), hddRet);
    return hddRet;
}

//
// SendDDEMessageSz - string based wrapper for doing one DDE client transaction
//
HDDEDATA CIEDDE::_SendDDEMessageSz(DWORD dwDDEInst, LPCTSTR pszApp, LPCTSTR pszTopic, LPCTSTR pszMessage, UINT wType)
{
    HDDEDATA hddRet = 0;

    ENTERPROC(2, TEXT("_SendDDEMessageSz(dwDDEInst=%08X,pszApp=>%s<,pszTopic=>%s<,pszMessage=>%s<,wType=%d)"), dwDDEInst, pszApp, pszTopic, pszMessage, wType);

    HSZ hszApp = DdeCreateStringHandle(dwDDEInst, pszApp, CP_WINNEUTRAL);
    if (hszApp)
    {
        HSZ hszTopic = DdeCreateStringHandle(dwDDEInst, pszTopic, CP_WINNEUTRAL);
        if (hszTopic)
        {
            HSZ hszMessage = DdeCreateStringHandle(dwDDEInst, pszMessage, CP_WINNEUTRAL);
            if (hszMessage)
            {
                hddRet = _SendDDEMessageHsz(dwDDEInst, hszApp, hszTopic, hszMessage, wType);
                DdeFreeStringHandle(dwDDEInst, hszMessage);
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _SendDDEMessageSz could not convert message");
            }
            DdeFreeStringHandle(dwDDEInst, hszTopic);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: _SendDDEMessageSz could not convert topic");
        }
        DdeFreeStringHandle(dwDDEInst, hszApp);
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _SendDDEMessageSz could not convert app");
    }

    EXITPROC(2, TEXT("_SendDDEMessageSz=%08X"), hddRet);
    return hddRet;
}

//
// Initialize - called when ready to start IEDDE server
//
BOOL CIEDDE::_Initialize(void)
{
    BOOL fSuccess = TRUE;
    ENTERPROC(2, TEXT("_Initialize()"));

    ASSERT(_fCSInitialized == FALSE);
    InitializeCriticalSection(&_csIEDDE);
    _fCSInitialized = TRUE;

    EXITPROC(2, TEXT("_Initialize=%d"), fSuccess);
    return fSuccess;
}

//
// _DestroyWinitem - DSA callback to partially free the contents of a WINITEM*
//  In practice this should never get called, the hdsaWinItem list should be
//  empty at uninit time.
//
int CIEDDE::_DestroyWinitem(LPVOID p1, LPVOID p2)
{
    WINITEM *pwi = (WINITEM *)p1;
    ASSERT(IS_VALID_READ_PTR(pwi, WINITEM));
    ASSERT(IS_VALID_READ_PTR(pwi->pidt, CIEDDEThread));

    //
    // It would be good to unregister the DDE server at this point,
    // but we'd need to be on its thread to do it.
    //

    delete pwi->pidt;

    return 1;
}

//
// _DestroyProtocol - DSA callback to free the contents of a PROTOCOLREG*
//
int CIEDDE::_DestroyProtocol(LPVOID p1, LPVOID p2)
{
    PROTOCOLREG *pr = (PROTOCOLREG *)p1;
    ASSERT(IS_VALID_READ_PTR(pr, PROTOCOLREG));

    LocalFree(pr->pszProtocol);
    pr->pszProtocol = NULL;
    LocalFree(pr->pszServer);
    pr->pszServer = NULL;

    return 1;
}

//
// _DestroyUrlEcho - DPA callback to free allocated memory
//
int CIEDDE::_DestroyUrlEcho(LPVOID p1, LPVOID p2)
{
    ASSERT(IS_VALID_STRING_PTR((LPTSTR)p1, -1));
    LocalFree(p1);
    p1 = NULL;

    return 1;
}

//
// Uninitialize - called when ready to stop IEDDE server
//
void CIEDDE::_Uninitialize(void)
{
    ENTERPROC(2, TEXT("_Uninitialize()"));

    _fAutomationReady = FALSE;

    if (_hdsaWinitem)
    {
        if (DSA_GetItemCount(_hdsaWinitem))
        {
            //ASSERT(DSA_GetItemCount(_hdsaWinitem)==0);
            TraceMsg(TF_ERROR, "IEDDE: Browser windows still open on uninitialize");
        }

        DSA_DestroyCallback(_hdsaWinitem, _DestroyWinitem, 0);
        _hdsaWinitem = NULL;
    }

    if (_hdsaProtocolHandler)
    {
        DSA_DestroyCallback(_hdsaProtocolHandler, _DestroyProtocol, 0);
        _hdsaProtocolHandler = NULL;
    }

    if (_hdpaUrlEcho)
    {
        DPA_DestroyCallback(_hdpaUrlEcho, _DestroyUrlEcho, 0);
        _hdpaUrlEcho = NULL;
    }

    if (_fCSInitialized)
    {
        DeleteCriticalSection(&_csIEDDE);
    }

    EXITPROC(2, TEXT("_Uninitialize!"));
}

void CIEDDE::SetDelayedExecute(LPCTSTR pszTopic, LPCTSTR pszParams)
{
    _dwThreadID = GetCurrentThreadId();
    Str_SetPtr(&_pszTopic, pszTopic);
    Str_SetPtr(&_pszParams, pszParams);
}

void CIEDDE::RunDelayedExecute()
{
    if (_pszTopic && _pszParams)
    {
        WINITEM wi;
        if (_GetWinitemFromThread(_dwThreadID, &wi) && wi.pidt)
        {
            HDDEDATA h = wi.pidt->CallTopic(XTYP_EXECUTE, _pszTopic, _pszParams);
            DdeFreeDataHandle(h);
        }
    }

    Str_SetPtr(&_pszTopic, NULL);
    Str_SetPtr(&_pszParams, NULL);
}
//
// _AutomationStarted - called when automation support can be called
//
void CIEDDE::_AutomationStarted(void)
{
    ENTERPROC(1, TEXT("_AutomationStarted()"));
    if (!_fAutomationReady && _pszTopic && _pszParams)
    {
        WINITEM wi;
        if (_GetWinitemFromThread(_dwThreadID, &wi) && wi.pidt)
        {
            PostMessage(wi.hwnd, WMC_DELAYEDDDEEXEC, 0, 0);
        }
    }
    _fAutomationReady = TRUE;

    EXITPROC(1, TEXT("_AutomationStarted!"));
}

//
// _BeforeNavigate - called before a navigation occurs.
//
HRESULT CIEDDE::_BeforeNavigate(LPCTSTR pszURL, BOOL *pfProcessed)
{
    ENTERPROC(1, TEXT("_BeforeNavigate(pszURL=>%s<,pfProcessed=%08X)"), pszURL, pfProcessed);

    SHSTR shstrMsg;
    HRESULT hr = S_OK;
    int cProtocols = 0;

    ENTER_IEDDE_CRIT;
    if (_hdsaProtocolHandler)
    {
        cProtocols = DSA_GetItemCount(_hdsaProtocolHandler);
    }
    LEAVE_IEDDE_CRIT;

    if (cProtocols)
    {
        DDETHREADINFO dti;

        if (_GetDtiFromThread(GetCurrentThreadId(), &dti))
        {
            PARSEDURL pu;

            pu.cbSize = SIZEOF(pu);

            if (SUCCEEDED(ParseURL(pszURL, &pu)))
            {
                int i;

                for (i=0; i<cProtocols; i++)
                {
                    PROTOCOLREG pr;

                    ENTER_IEDDE_CRIT;
                    int iResult = DSA_GetItem(_hdsaProtocolHandler, i, &pr);
                    LEAVE_IEDDE_CRIT;

                    if (iResult != -1)
                    {
                        //
                        // Check to see if the protocol to navigate
                        // matches one of our registered protocols.
                        // We do a case insensitive compare.  Note
                        // that:
                        //
                        //   (1) ParseURL does not null terminate the
                        //       pu.pszProtocol (its length is stored
                        //       in pu.cchProtocol).
                        //
                        //   (2) pu.pszProtocol is a LPCTSTR so we
                        //       can't modify the pszProtocol ourselves.
                        //
                        //   (3) There is no win32 lstrncmpi() API.
                        //
                        // Therefore in order to do a case insensitive
                        // compare we must copy the pu.pszProtocol into
                        // a writable buffer at some point.
                        //
                        if (lstrlen(pr.pszProtocol) == (int)pu.cchProtocol)
                        {
                            shstrMsg.SetStr(pu.pszProtocol, pu.cchProtocol);
                            if (StrCmpI(pr.pszProtocol, shstrMsg) == 0)
                            {
                                shstrMsg.SetStr(TEXT("\""));
                                shstrMsg.Append(pszURL);
                                shstrMsg.Append(TEXT("\",,-1,0,,,,"));

                                if (_SendDDEMessageSz(dti.dwDDEInst, pr.pszServer, c_szWWWOpenURL, shstrMsg, XTYP_REQUEST))
                                {
                                    if (pfProcessed)
                                    {
                                        *pfProcessed = TRUE;
                                    }
                                }
                                else
                                {
                                    TraceMsg(TF_WARNING, "IEDDE: _BeforeNavigate could not DDE to protocol handler");
                                }

                                break;
                            }
                        }
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "IEDDE: _BeforeNavigate could not get item from DSA");
                    }
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _BeforeNavigate could not parse URL");
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: _BeforeNavigate unable to get thread info, can't use DDE");
        }
    }

    EXITPROC(1, TEXT("_BeforeNavigate=%08X"), hr);
    return hr;
}

//
// _AfterNavigate - called after a navigation occurs
//
HRESULT CIEDDE::_AfterNavigate(LPCTSTR pszURL, HWND hwnd)
{
    ENTERPROC(1, TEXT("_AfterNavigate(pszURL=>%s<,hwnd=%08X)"), pszURL, hwnd);

    int cURLHooks = 0;
    SHSTR shstrMsg;
    HRESULT hr = S_OK;

    ENTER_IEDDE_CRIT;
    if (_hdpaUrlEcho)
    {
        cURLHooks = DPA_GetPtrCount(_hdpaUrlEcho);
    }
    LEAVE_IEDDE_CRIT;

    if (cURLHooks)
    {
        SHSTR shstrMime;

        // (mattsq 1-97)
        // this is a temporary lie - it should be fixed to use the real mimetype
        // with something like:
        //      GetMimeTypeFromUrl(pszURL, shstrMime);
        // talk to URLMON people
        shstrMime.SetStr(TEXT("text/html"));

        DDETHREADINFO dti={0};
        WINITEM wi;
        DWORD dwWindowID;
        if (GetWinitemFromHwnd(hwnd, &wi))
        {
            dwWindowID = wi.dwWindowID;
            wi.pidt->GetDdeThreadInfo(&dti);
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: _AfterNavigate unable to find browser window ID, using -1");
            dwWindowID = (DWORD)-1;

            WINITEM wiThread;

            if (_GetWinitemFromThread(GetCurrentThreadId(), &wiThread))
            {
                ASSERT(wiThread.pidt);
                wiThread.pidt->GetDdeThreadInfo(&dti);
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _AfterNavigate unable to find DDE thread info");
            }
        }

        if (dti.dwDDEInst)
        {
            HSZ hszTopic = DdeCreateStringHandle(dti.dwDDEInst, c_szWWWUrlEcho, CP_WINNEUTRAL);
            if (hszTopic)
            {
                TCHAR szFinish[16];

                shstrMsg.SetStr(TEXT("\""));                // Quote
                shstrMsg.Append(pszURL);                    // URL
                shstrMsg.Append(TEXT("\",\""));             // Quote Comma Quote
                shstrMsg.Append(shstrMime);                 // Mime
                wnsprintf(szFinish, ARRAYSIZE(szFinish), TEXT("\",%d"), dwWindowID);    //
                shstrMsg.Append(szFinish);                  // Quote Comma dwWindowID NULL

                HSZ hszMsg = DdeCreateStringHandle(dti.dwDDEInst, shstrMsg, CP_WINNEUTRAL);

                if (hszMsg)
                {
                    //
                    // Enumerate in reverse order because calling a hook may destroy it.
                    //
                    for (int i=cURLHooks-1; i>=0; --i)
                    {
                        ENTER_IEDDE_CRIT;
                        LPTSTR pszService = (LPTSTR)DPA_GetPtr(_hdpaUrlEcho, i);
                        LEAVE_IEDDE_CRIT;

                        if (pszService != NULL)
                        {
                            HSZ hszService = DdeCreateStringHandle(dti.dwDDEInst, pszService, CP_WINNEUTRAL);

                            if (hszService)
                            {
                                if (_SendDDEMessageHsz(dti.dwDDEInst, hszService, hszTopic, hszMsg, XTYP_POKE) == 0)
                                {
                                    TraceMsg(TF_WARNING, "IEDDE: _AfterNavigate could not DDE to URLHook handler");
                                }

                                DdeFreeStringHandle(dti.dwDDEInst, hszService);
                            }
                            else
                            {
                                TraceMsg(TF_WARNING, "IEDDE: _AfterNavigate unable to create hszService");
                            }
                        }
                        else
                        {
                            TraceMsg(TF_WARNING, "IEDDE: _AfterNavigate unable to enumerate an URL hook");
                        }
                    }

                    DdeFreeStringHandle(dti.dwDDEInst, hszMsg);
                }
                else
                {
                    TraceMsg(TF_WARNING, "IEDDE: _AfterNavigate unable to create hszMsg");
                }

                DdeFreeStringHandle(dti.dwDDEInst, hszTopic);
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _AfterNavigate unable to create hszTopic");
            }
        }
    }

    EXITPROC(1, TEXT("_AfterNavigate=%08X"), hr);
    return hr;
}

//
// GetWinitemFromHwnd - return the winitem associated with an hwnd
//
BOOL CIEDDE::GetWinitemFromHwnd(HWND hwnd, WINITEM *pwi)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("GetWinitemFromHwnd(hwnd=%08X,pwi=%08X)"), hwnd, pwi);

    ENTER_IEDDE_CRIT;

    if (_hdsaWinitem)
    {
        for (int i=0; i<DSA_GetItemCount(_hdsaWinitem); i++)
        {
            WINITEM wi;

            if (DSA_GetItem(_hdsaWinitem, i, &wi) != -1)
            {
                if (wi.hwnd == hwnd)
                {
                    *pwi = wi;
                    fSuccess = TRUE;
                    break;
                }
            }
        }
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("GetWinitemFromHwnd=%d"), fSuccess); 
    return fSuccess;
}

//
// GetWinitemFromWindowID - return the winitem associated with a window ID
//
BOOL CIEDDE::GetWinitemFromWindowID(DWORD dwWindowID, WINITEM *pwi)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(3, TEXT("GetWinitemFromWindowID(dwWindowID=%08X,pwi=%08X)"), dwWindowID, pwi);

    ENTER_IEDDE_CRIT;

    if (_hdsaWinitem)
    {
        for (int i=0; i<DSA_GetItemCount(_hdsaWinitem); i++)
        {
            WINITEM wi;

            if (DSA_GetItem(_hdsaWinitem, i, &wi) != -1)
            {
                if (wi.dwWindowID == dwWindowID)
                {
                    *pwi = wi;
                    fSuccess = TRUE;
                    break;
                }
            }
        }
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("GetWinitemFromWindowID=%d"), fSuccess); 
    return fSuccess;
}

//
// _GetWinitemFromThread - return the first winitem associated with a thread
//
BOOL CIEDDE::_GetWinitemFromThread(DWORD dwThreadID, WINITEM *pwi)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("_GetWinitemFromThread(dwThreadID=%08X,pwi=%08X)"), dwThreadID, pwi);

    ENTER_IEDDE_CRIT;

    if (_hdsaWinitem)
    {
        for (int i=0; i<DSA_GetItemCount(_hdsaWinitem); i++)
        {
            WINITEM wi;

            if (DSA_GetItem(_hdsaWinitem, i, &wi) != -1)
            {
                if (wi.dwThreadID == dwThreadID)
                {
                    *pwi = wi;
                    fSuccess = TRUE;
                    break;
                }
            }
        }
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("_GetWinitemFromThread=%d"), fSuccess); 
    return fSuccess;
}

//
// _GetDtiFromThread - return the threadinfo associated with a thread
//
BOOL CIEDDE::_GetDtiFromThread(DWORD dwThreadID, DDETHREADINFO *pdti)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("_GetDtiFromThread(dwThreadID=%08X,pdti=%08X)"), dwThreadID, pdti);

    ENTER_IEDDE_CRIT;

    WINITEM wi;
    if (_GetWinitemFromThread(dwThreadID, &wi))
    {
        wi.pidt->GetDdeThreadInfo(pdti);
        fSuccess = TRUE;
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _GetDtiFromThread unable to find winitem");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("_GetDtiFromThread=%d"), fSuccess); 
    return fSuccess;
}

//
// _CreateDdeThreadInfo - Initialize DDE services and names for this thread
//
BOOL CIEDDE::_CreateDdeThreadInfo(DDETHREADINFO *pdti)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("_CreateDdeThreadInfo(pdti=%08X)"), pdti);

    UINT uiDDE;
    DDETHREADINFO dti={0};

    //
    // Initialize DDEML, register our service.
    //

    uiDDE = DdeInitialize(&dti.dwDDEInst, (PFNCALLBACK)DdeCallback,
                           APPCLASS_STANDARD | CBF_FAIL_ADVISES |
                           CBF_SKIP_REGISTRATIONS | CBF_SKIP_UNREGISTRATIONS, 0);

    if (uiDDE == DMLERR_NO_ERROR)
    {
        dti.hszReturn = DdeCreateStringHandle(dti.dwDDEInst, c_szReturn, CP_WINNEUTRAL);
        if (dti.hszReturn)
        {
            dti.hszService = DdeCreateStringHandle(dti.dwDDEInst, c_szIExplore, CP_WINNEUTRAL);
            if (dti.hszService)
            {
                *pdti = dti;
                fSuccess = TRUE;
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _CreateDdeThreadInfo unable to convert service");
            }

            if (!fSuccess)
            {
                DdeFreeStringHandle(dti.dwDDEInst, dti.hszReturn);
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: _CreateDdeThreadInfo unable to convert return");
        }

        if (!fSuccess)
        {
            DdeUninitialize(dti.dwDDEInst);
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _CreateDdeThreadInfo unable to init DDE");
    }

    EXITPROC(2, TEXT("_CreateDdeThreadInfo=%d"), fSuccess);
    return fSuccess;
}

//
// _DestroyDdeThreadInfo - Free up any resources in a dti structure.
//
void CIEDDE::_DestroyDdeThreadInfo(DDETHREADINFO *pdti)
{
    ENTERPROC(2, TEXT("_DestroyDdeThreadInfo(pdti=%08X)"), pdti);

    if (pdti->hddNameService)
    {
        ASSERT(pdti->hszService);
        DdeNameService(pdti->dwDDEInst, pdti->hszService, 0, DNS_UNREGISTER);
        pdti->hddNameService = 0;
    }

    if (pdti->hszService)
    {
        DdeFreeStringHandle(pdti->dwDDEInst, pdti->hszService);
        pdti->hszService = 0;
    }

    if (pdti->hszReturn)
    {
        DdeFreeStringHandle(pdti->dwDDEInst, pdti->hszReturn);
        pdti->hszReturn = 0;
    }

    if (pdti->dwDDEInst)
    {
        DdeUninitialize(pdti->dwDDEInst);
        pdti->dwDDEInst = 0;
    }

    EXITPROC(2, TEXT("_DestroyDdeThreadInfo!"));
    return;
}

//
// _AddWinitem - adds a winitem to _hdsaWinitem
//
BOOL CIEDDE::_AddWinitem(WINITEM *pwi)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("_AddWinitem(pwi=%08X)"), pwi);

    ENTER_IEDDE_CRIT;

    if (!_hdsaWinitem)
    {
        _hdsaWinitem = DSA_Create(SIZEOF(WINITEM), DXA_GROWTH_AMOUNT);
    }

    if (_hdsaWinitem)
    {
        if (DSA_AppendItem(_hdsaWinitem, pwi) != -1)
        {
            fSuccess = TRUE;
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: _AddWinitem could not append an item");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _AddWinitem could not create hdsa");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("_AddWinitem=%d"), fSuccess);
    return fSuccess;
}

//
// _UpdateWinitem - updates a winitem based on the dwWindowID.
//
BOOL CIEDDE::_UpdateWinitem(WINITEM *pwi)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("_UpdateWinitem(pwi=%08X)"), pwi);

    ENTER_IEDDE_CRIT;

    if (_hdsaWinitem)
    {
        int cItems = DSA_GetItemCount(_hdsaWinitem);

        for (int i=0; i<cItems; i++)
        {
            WINITEM wi;

            if (DSA_GetItem(_hdsaWinitem, i, &wi) != -1)
            {
                if (wi.dwWindowID == pwi->dwWindowID)
                {
                    if (DSA_SetItem(_hdsaWinitem, i, pwi))
                    {
                        fSuccess = TRUE;
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "IEDDE: _UpdateWinitem could not update an item");
                    }
                    break;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _UpdateWinitem could not get an item");
            }
        }
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("_UpdateWinitem=%d"), fSuccess);
    return fSuccess;
}

//
// AddUrlEcho - adds an UrlEcho entry to the dpa
//
BOOL CIEDDE::AddUrlEcho(LPCTSTR pszUrlEcho)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("AddUrlEcho(pszUrlEcho=>%s<)"), pszUrlEcho);

    ENTER_IEDDE_CRIT;

    if (!_hdpaUrlEcho)
    {
        _hdpaUrlEcho = DPA_Create(DXA_GROWTH_AMOUNT);
    }

    if (_hdpaUrlEcho)
    {
        if (DPA_AppendPtr(_hdpaUrlEcho, (LPVOID)pszUrlEcho) != -1)
        {
            fSuccess = TRUE;
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: AddUrlEcho unable to append a ptr");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: AddUrlEcho unable to create a dpa");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("AddUrlEcho=%d"), fSuccess);
    return fSuccess;
}

//
// RemoveUrlEcho - remove an UrlEcho entry from the dpa
//
BOOL CIEDDE::RemoveUrlEcho(LPCTSTR pszUrlEcho)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("RemoveUrlEcho(pszUrlEcho=>%s<)"), pszUrlEcho);

    ENTER_IEDDE_CRIT;

    if (_hdpaUrlEcho)
    {
        for (int i=0; i<DPA_GetPtrCount(_hdpaUrlEcho); i++)
        {
            LPTSTR pszList = (LPTSTR)DPA_GetPtr(_hdpaUrlEcho, i);
            if (pszList)
            {
                if (StrCmpI(pszList, pszUrlEcho) == 0)
                {
                    DPA_DeletePtr(_hdpaUrlEcho, i);
                    LocalFree((HANDLE)pszList);
                    pszList = NULL;
                    fSuccess = TRUE;
                    break;
                }
            }
            else
            {
                TraceMsg(TF_ALWAYS, "IEDDE: RemoveUrlEcho unable to get dpa ptr");
            }
        }

        if (!fSuccess)
        {
            TraceMsg(TF_WARNING, "IEDDE: RemoveUrlEcho unable to find server");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: RemoveUrlEcho unable to find dpa");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("RemoveUrlEcho=%d"), fSuccess);
    return fSuccess;
}

//
// AddProtocolHandler - add a PROTOCOLREG entry to the dsa
//
BOOL CIEDDE::AddProtocolHandler(LPCTSTR pszServer, LPCTSTR pszProtocol)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("AddProtocolHandler(pszServer=>%s<,pszProtocol=>%s<)"), pszServer, pszProtocol);

    ENTER_IEDDE_CRIT;

    PROTOCOLREG pr;
    //
    // First, see if anybody else grabbed the protocol first.
    //
    BOOL fFoundHandler = FALSE;
    if (_hdsaProtocolHandler)
    {
        for (int i=0; i<DSA_GetItemCount(_hdsaProtocolHandler); i++)
        {
            if (DSA_GetItem(_hdsaProtocolHandler, i, &pr) != -1)
            {
                if (StrCmpI(pr.pszProtocol, pszProtocol) == 0)
                {
                    TraceMsg(TF_WARNING, "IEDDE: AddProtocolHandler already has a handler");
                    fFoundHandler = TRUE;
                    break;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: AddProtocolHandler unable to get an item");
            }
        }
    }

    if (!fFoundHandler)
    {
        if (!_hdsaProtocolHandler)
        {
            _hdsaProtocolHandler = DSA_Create(SIZEOF(PROTOCOLREG), DXA_GROWTH_AMOUNT);
        }

        if (_hdsaProtocolHandler)
        {
            pr.pszServer = StrDup(pszServer);
            if (pr.pszServer)
            {
                pr.pszProtocol = StrDup(pszProtocol);
                if (pr.pszProtocol)
                {
                    if (DSA_AppendItem(_hdsaProtocolHandler, &pr) != -1)
                    {
                        fSuccess = TRUE;
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "IEDDE: AddProtocolHandler unable to append to dsa");
                    }

                    if (!fSuccess)
                    {
                        LocalFree((HANDLE)pr.pszProtocol);
                        pr.pszProtocol = NULL;
                    }
                }
                else
                {
                    TraceMsg(TF_WARNING, "IEDDE: AddProtocolHandler unable to dup protocol");
                }

                if (!fSuccess)
                {
                    LocalFree((HANDLE)pr.pszServer);
                    pr.pszServer = NULL;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: AddProtocolHandler unable to dup server");
            }

        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: AddProtocolHandler unable to create dsa");
        }
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("AddProtocolHandler=%d"), fSuccess);
    return fSuccess;
}

//
// RemoveProtocolHandler - removes a PROTOCOLREG item from the dsa
//
BOOL CIEDDE::RemoveProtocolHandler(LPCTSTR pszServer, LPCTSTR pszProtocol)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("RemoveProtocolHandler(pszServer=>%s<,pszProtocol=>%s<)"), pszServer, pszProtocol);

    ENTER_IEDDE_CRIT;

    if (_hdsaProtocolHandler)
    {
        for (int i=0; i<DSA_GetItemCount(_hdsaProtocolHandler); i++)
        {
            PROTOCOLREG pr;

            if (DSA_GetItem(_hdsaProtocolHandler, i, &pr) != -1)
            {
                if (StrCmpI(pr.pszProtocol, pszProtocol) == 0)
                {
                    if (StrCmpI(pr.pszServer, pszServer) == 0)
                    {
                        if (DSA_DeleteItem(_hdsaProtocolHandler, i) != -1)
                        {
                            LocalFree((HANDLE)pr.pszServer);
                            pr.pszServer = NULL;
                            LocalFree((HANDLE)pr.pszProtocol);
                            pr.pszProtocol = NULL;
                            fSuccess = TRUE;
                        }
                        else
                        {
                            TraceMsg(TF_WARNING, "IEDDE: RemoveProtocolHandler unable to remove item");
                        }
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "IEDDE: RemoveProtocolHandler says server didn't match");
                    }

                    break;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: RemoveProtocolHandler unable to get item");
            }
        }

        if (!fSuccess)
        {
            TraceMsg(TF_WARNING, "IEDDE: RemoveProtocolHandler unable to complete mission");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: RemoveProtocolHandler can't find the dsa");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("RemoveProtocolHandler=%d"), fSuccess);
    return fSuccess;
}

//
// _DeleteWinitemByHwnd - removes a winitem from _hdsaWinitem
//
BOOL CIEDDE::_DeleteWinitemByHwnd(HWND hwnd, WINITEM *pwi)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(2, TEXT("_DeleteWinitemByHwnd(hwnd=%08X,pwi=%08X)"), hwnd, pwi);

    ENTER_IEDDE_CRIT;

    if (_hdsaWinitem)
    {
        for (int i=0; i<DSA_GetItemCount(_hdsaWinitem); i++)
        {
            WINITEM wi;

            if (DSA_GetItem(_hdsaWinitem, i, &wi) != -1)
            {
                if (wi.hwnd == hwnd)
                {
                    if (DSA_DeleteItem(_hdsaWinitem, i) != -1)
                    {
                        *pwi = wi;
                        fSuccess = TRUE;
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "IEDDE: _DeleteWinitemByHwnd could note delete an item");
                    }

                    break;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _DeleteWinitemByHwnd could note get an item");
            }
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _DeleteWinitemByHwnd has no _hdsaWinitem");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(2, TEXT("_DeleteWinitemByHwnd=%d"), fSuccess);
    return fSuccess;
}

//
// _NewWindow - Add a browser window to the internal list
//
BOOL CIEDDE::_NewWindow(HWND hwnd)
{
    BOOL fSuccess = FALSE;

    ENTERPROC(1, TEXT("NewWindow(hwnd=%08X)"), hwnd);

    ASSERT(IS_VALID_HANDLE(hwnd, WND));

    ENTER_IEDDE_CRIT;

    WINITEM wi;
    if (GetWinitemFromHwnd(hwnd, &wi) == FALSE)
    {
        CIEDDEThread *pidt = new CIEDDEThread();

        if (pidt)
        {
            DDETHREADINFO dti = {0};
            DWORD dwThreadID = GetCurrentThreadId();
            WINITEM wi;
            BOOL fCreatedDTI = FALSE;

            if (_GetWinitemFromThread(dwThreadID, &wi))
            {
                wi.pidt->GetDdeThreadInfo(&dti);
            }
            else
            {
                LEAVE_IEDDE_CRIT;
                _CreateDdeThreadInfo(&dti);
                ENTER_IEDDE_CRIT;
                fCreatedDTI = TRUE;
            }

            if (dti.dwDDEInst)
            {
                static DWORD dwNextWindowID = 1;

                pidt->SetDdeThreadInfo(&dti);

                wi.dwThreadID = dwThreadID;
                wi.pidt = pidt;
                wi.hwnd = hwnd;
                wi.dwWindowID = dwNextWindowID++;

                if (_AddWinitem(&wi))
                {
                    //
                    // Now that we have a (partial) winitem in the winitem
                    // database, we can register our name service.  If we
                    // registered any sooner, there is a risk that an app
                    // will try to connect to us while we are registering,
                    // and we will fail the connect because the winitem
                    // is not in the registry yet.
                    //
                    LEAVE_IEDDE_CRIT;
                    dti.hddNameService = DdeNameService(dti.dwDDEInst, dti.hszService, 0, DNS_REGISTER);
                    ENTER_IEDDE_CRIT;

                    //
                    // Now that we have hddNameService, we can update the
                    // winitem in the database.
                    //
                    if (dti.hddNameService)
                    {
                        pidt->SetDdeThreadInfo(&dti);
                        if (_UpdateWinitem(&wi))
                        {
                            fSuccess = TRUE;
                        }
                        else
                        {
                            TraceMsg(TF_WARNING, "IEDDE: _NewWindow unable to update a win item");
                        }
                    }
                    else
                    {
                        TraceMsg(TF_WARNING, "IEDDE: _NewWindow unable to register service");
                    }
                }
                else
                {
                    TraceMsg(TF_WARNING, "IEDDE: _NewWindow could not append win item");
                }

                if (!fSuccess && fCreatedDTI)
                {
                    LEAVE_IEDDE_CRIT;
                    _DestroyDdeThreadInfo(&dti);
                    ENTER_IEDDE_CRIT;
                }
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _NewWindow could not get/create dde thread info");
            }

            if (!fSuccess)
            {
                delete pidt;
            }
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: _NewWindow could not create iedde thread object");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _NewWindow says window already registered?!?");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(1, TEXT("_NewWindow=%d"), fSuccess);
    return fSuccess;
}

//
// _WindowDestroyed - Remove a browser window from the internal list
//
BOOL CIEDDE::_WindowDestroyed(HWND hwnd)
{
    BOOL fSuccess = FALSE;
    ENTERPROC(1, TEXT("_WindowDestroyed(hwnd=%08X)"), hwnd);

    ENTER_IEDDE_CRIT;

    WINITEM wi;
    if (_DeleteWinitemByHwnd(hwnd, &wi))
    {
        fSuccess = TRUE;

        ASSERT(wi.pidt);
        WINITEM wiThread;

        if (_GetWinitemFromThread(wi.dwThreadID, &wiThread) == FALSE)
        {
            if (wi.dwThreadID == GetCurrentThreadId())
            {
                DDETHREADINFO dti;

                wi.pidt->GetDdeThreadInfo(&dti);
                // Don't hold onto critical section while doing this...
                LEAVE_IEDDE_CRIT;
                _DestroyDdeThreadInfo(&dti);
                ENTER_IEDDE_CRIT;
            }
            else
            {
                TraceMsg(TF_WARNING, "IEDDE: _WindowDestroyed called on wrong thread");
            }
        }

        delete wi.pidt;
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: _WindowDestroyed could not find hwnd");
    }

    LEAVE_IEDDE_CRIT;

    EXITPROC(1, TEXT("_WindowDestroyed=%d"), fSuccess);
    return fSuccess;
}





//
// IEDDE_ functions are those exported for other parts of shdocvw to call.
// They pretty much just call the equivalent function in g_pIEDDE.
//

BOOL IEDDE_Initialize(void)
{
    BOOL fRet = FALSE;

    ENTERPROC(2, TEXT("IEDDE_Initialize()"));

    if (g_pIEDDE == NULL)
    {
        g_pIEDDE = new CIEDDE;

        if (g_pIEDDE)
        {
            fRet = g_pIEDDE->_Initialize();
        }
        else
        {
            TraceMsg(TF_WARNING, "IEDDE: IEDDE_Initialize could not allocate an IEDDE object");
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_Initialize says already initialized");
    }

    EXITPROC(2, TEXT("IEDDE_Initialize=%d"), fRet);
    return fRet;
}

void IEDDE_Uninitialize(void)
{
    ENTERPROC(2, TEXT("IEDDE_Uninitialize()"));

    if (g_pIEDDE)
    {
        g_pIEDDE->_Uninitialize();
        delete g_pIEDDE;
        g_pIEDDE = NULL;
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_Uninitialize has no IEDDE object");
    }

    EXITPROC(2, TEXT("IEDDE_Uninitialize!"));
}

BOOL IEDDE_RunDelayedExecute()
{
    if (g_pIEDDE)
    {
        g_pIEDDE->RunDelayedExecute();
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_RunDelayedExecute has no IEDDE object");
    }
    return TRUE;
}

void IEDDE_AutomationStarted(void)
{
    ENTERPROC(2, TEXT("IEDDE_AutomationStarted()"));

    if (g_pIEDDE)
    {
        g_pIEDDE->_AutomationStarted();
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_AutomationStarted has no IEDDE object");
    }

    EXITPROC(2, TEXT("IEDDE_AutomationStarted!"));
}

HRESULT IEDDE_BeforeNavigate(LPCWSTR pwszURL, BOOL *pfCanceled)
{
    HRESULT hr = E_FAIL;

    ENTERPROC(2, TEXT("IEDDE_BeforeNavigate(pwszURL=%08X,pfCanceled=%08X)"), pwszURL, pfCanceled);

    if (g_pIEDDE)
    {
        LPCTSTR pszURL;

        pszURL = pwszURL;

        if (pszURL)
        {
            hr = g_pIEDDE->_BeforeNavigate(pszURL, pfCanceled);
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_BeforeNavigate has no IEDDE object");
    }

    EXITPROC(2, TEXT("IEDDE_BeforeNavigate=%08X"), hr);
    return hr;
}

HRESULT IEDDE_AfterNavigate(LPCWSTR pwszURL, HWND hwnd)
{
    HRESULT hr = E_FAIL;

    ENTERPROC(2, TEXT("IEDDE_AfterNavigate(pwszURL=%08X,hwnd=%08X)"), pwszURL, hwnd);

    if (g_pIEDDE)
    {
        LPCTSTR pszURL;

        pszURL = pwszURL;

        if (pszURL)
        {
            hr = g_pIEDDE->_AfterNavigate(pszURL, hwnd);
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_AfterNavigate has no IEDDE object");
    }

    EXITPROC(2, TEXT("IEDDE_AfterNavigate=%08X"), hr);
    return hr;
}

BOOL IEDDE_NewWindow(HWND hwnd)
{
    BOOL fRet = FALSE;

    ENTERPROC(2, TEXT("IEDDE_NewWindow(hwnd=%08X)"), hwnd);

    if (g_pIEDDE)
    {
        fRet = g_pIEDDE->_NewWindow(hwnd);
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_NewWindow has no IEDDE object");
    }

    EXITPROC(2, TEXT("IEDDE_NewWindow=%d"), fRet);
    return fRet;
}

BOOL IEDDE_WindowDestroyed(HWND hwnd)
{
    BOOL fRet = FALSE;

    ENTERPROC(2, TEXT("IEDDE_WindowDestroyed(hwnd=%08X)"), hwnd);

    if (g_pIEDDE)
    {
        fRet = g_pIEDDE->_WindowDestroyed(hwnd);
    }
    else
    {
        TraceMsg(TF_WARNING, "IEDDE: IEDDE_WindowDestroyed has no IEDDE object");
    }

    EXITPROC(2, TEXT("IEDDE_WindowDestroyed=%d"), fRet);
    return fRet;
}





#ifdef DEBUG

//
// Move g_dwIEDDETrace into ccshell.ini to prevent recompiles.
//

DWORD g_dwIEDDETrace = 0;
static DWORD g_dwIndent = 0;
static const TCHAR c_szDotDot[] = TEXT("..");

#define MAX_INDENTATION_VALUE   0x10

void EnterProc(DWORD dwTraceLevel, LPTSTR szFmt, ...)
{
    TCHAR szOutput[1000];
    va_list arglist;

    if (dwTraceLevel <= g_dwIEDDETrace)
    {
        szOutput[0] = TEXT('\0');

        for (DWORD i=0; i<g_dwIndent; i++)
        {
            StrCatBuff(szOutput, c_szDotDot, ARRAYSIZE(szOutput));
        }

        va_start(arglist, szFmt);
        wvnsprintf(szOutput + lstrlen(szOutput), ARRAYSIZE(szOutput) - lstrlen(szOutput), szFmt, arglist);
        va_end(arglist);

        TraceMsg(TF_ALWAYS, "%s", szOutput);

        // This value can get out of hand if EnterProc and ExitProc
        // calls do not match. This can trash the stack.
        if(g_dwIndent < MAX_INDENTATION_VALUE)
            g_dwIndent++;
    }
}

void ExitProc(DWORD dwTraceLevel, LPTSTR szFmt, ...)
{
    TCHAR szOutput[1000];
    va_list arglist;

    if (dwTraceLevel <= g_dwIEDDETrace)
    {
        // This can happen if the EnterProc and 
        // ExitProc calls do not match.
        if(g_dwIndent > 0)
            g_dwIndent--;

        szOutput[0] = TEXT('\0');

        for (DWORD i=0; i<g_dwIndent; i++)
        {
            StrCatBuff(szOutput, c_szDotDot, ARRAYSIZE(szOutput));
        }

        va_start(arglist, szFmt);
        wvnsprintf(szOutput + lstrlen(szOutput), ARRAYSIZE(szOutput) - lstrlen(szOutput), szFmt, arglist);
        va_end(arglist);

        TraceMsg(TF_ALWAYS, "%s", szOutput);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\iedisp.cpp ===
#include "priv.h"
#include "sccls.h"

#include "hlframe.h"
#include <iethread.h>
#include <shobjidlp.h>

#include "stdenum.h"
#include "winlist.h"
#include "iedde.h"
#include "bindcb.h"   // for CStubBindStatusCallback
#include "mshtmdid.h"
#include "resource.h"
#include "security.h"
#include "htregmng.h"
#include "mlang.h"  // for GetRfc1766FromLcid
#include "winver.h"
#include "dhuihand.h" // for GetFindDialogUp()
#include <varutil.h>

#include <mluisupp.h>

#define DM_FRAMEPROPERTY 0

#define TO_VARIANT_BOOL(b) (b?VARIANT_TRUE:VARIANT_FALSE)


// If URL contains \1 in the string then the URL is really an empty url with the
// security information following the 0x01.
#define EMPTY_URL   0x01

EXTERN_C const IID IID_IProvideMultipleClassInfo;

#ifndef HLNF_EXTERNALNAVIGATE
#define HLNF_EXTERNALNAVIGATE 0x10000000
#endif

#define NAVFAIL_URL                 TEXT("about:NavigationFailure")
#define NAVFAIL_URL_DESKTOPITEM     TEXT("about:DesktopItemNavigationFailure")

#define CPMSG(psz)           TraceMsg(TF_SHDAUTO, "ief ConnectionPoint::%s", psz)
#define CPMSG2(psz,d)        TraceMsg(TF_SHDAUTO, "ief ConnectionPoint::%s %x", psz, d)
#define DM_CPC 0

// Are there other definitions for these? Particularly MSIE
// We need some reasonable defaults in case we can't get the user agent string from the registry.
//
#define MSIE        L"Microsoft Internet Explorer"
#define APPCODENAME L"Mozilla"
#define APPVERSION  L"4.0 (compatible; MSIE 6.0)"
#define USERAGENT   L"Mozilla/4.0 (compatible; MSIE 6.0)"
#define NO_NAME_NAME L"_No__Name:"
#define EXTENDER_DISPID_BASE ((ULONG)(0x80010000))
#define IS_EXTENDER_DISPID(x) (((ULONG)(x) & 0xFFFF0000) == EXTENDER_DISPID_BASE)


BOOL GetNextOption(BSTR& bstrOptionString, BSTR* optionName, int* piValue);
BSTR GetNextToken(BSTR bstr, BSTR delimiters, BSTR whitespace, BSTR *nextPos);
DWORD OpenAndNavigateToURL(CIEFrameAuto*, BSTR *, const WCHAR*, ITargetNotify*, BOOL bNoHistory, BOOL bSilent);
HRESULT __cdecl DoInvokeParamHelper(IUnknown* punk, IConnectionPoint* pccp, LPBOOL pf, void **ppv, DISPID dispid, UINT cArgs, ...);
BSTR SafeSysAllocStringLen(const WCHAR *pStr, const unsigned int len);

//====================================================================================
// Define a new internal class that is used to manage a set of simple properties that
// we manage as part of the object.  This is mainly used such that pages (or objects
// that manage a page can save state across pages.
class CIEFrameAutoProp
{
public:
    HRESULT Initialize(BSTR szProperty)
    {
        UINT cch = lstrlenW(szProperty);
        if (cch < ARRAYSIZE(_sstr.wsz)) {
            StrCpyNW(_sstr.wsz, szProperty, ARRAYSIZE(_sstr.wsz));
            _sstr.cb = cch * sizeof(WCHAR);
            _szProperty = _sstr.wsz;
            return S_OK;
        }
        _szProperty = SysAllocString(szProperty);
        return _szProperty ? S_OK : E_OUTOFMEMORY;
    }

    HRESULT SetValue(VARIANT *pvtValue, IWebBrowser2* pauto);
    HRESULT CopyValue(VARIANT *pvtValue);
    BOOL IsExpired(DWORD dwCur);
    BOOL IsOurProp(BSTR szProperty) { return StrCmpW(szProperty, _szProperty) == 0;}
    CIEFrameAutoProp * Next() {return _next;}

    CIEFrameAutoProp () { VariantInit(&_vtValue); }
    ~CIEFrameAutoProp()
    {
        if (_szProperty && _szProperty != _sstr.wsz)
            SysFreeString(_szProperty);
        _VariantClear();
    }

    void _VariantClear();

    CIEFrameAutoProp *_next;
protected:
    BSTR             _szProperty;
    VARIANT          _vtValue;
    SA_BSTRGUID      _sstr;
    BOOL             _fDiscardable : 1;
    BOOL             _fOwned : 1;           // call SetSite(NULL) when discard
    DWORD            _dwLastAccessed;
} ;

#ifdef DEBUG
#define MSEC_PROPSWEEP      (1*1000)
#define MSEC_PROPEXPIRE     (5*1000)
#else
#define MSEC_PROPSWEEP      (5*1000*60)     // sweep every 5 min
#define MSEC_PROPEXPIRE     (10*1000*60)    // expire in 10 min
#endif



void CIEFrameAutoProp::_VariantClear()
{
    if (_vtValue.vt == VT_UNKNOWN && _fOwned)
    {
        _fOwned = FALSE;

        HRESULT hr = IUnknown_SetSite(_vtValue.punkVal, NULL);
        ASSERT(SUCCEEDED(hr));
    }
    VariantClearLazy(&_vtValue);
}

HRESULT CIEFrameAutoProp::SetValue(VARIANT *pvtValue, IWebBrowser2* pauto)
{
    TraceMsg(DM_FRAMEPROPERTY, "CIEFAP::SetValue called");
    _dwLastAccessed = GetCurrentTime();

    // In case we have _fOwned==TRUE.
    _VariantClear();

    if (pvtValue->vt == VT_UNKNOWN && pvtValue->punkVal) 
    {
        // Check if this is discardable or not.
        IUnknown* punk;
        if (SUCCEEDED(pvtValue->punkVal->QueryInterface(IID_IDiscardableBrowserProperty, (void **)&punk))) 
        {
            TraceMsg(DM_FRAMEPROPERTY, "CIEFAP::SetValue adding a discardable");
            _fDiscardable = TRUE;
            punk->Release();
        }

        //
        // Check if we need to call SetSite(NULL) when we discard.
        //
        IObjectWithSite* pows;
        HRESULT hresT = pvtValue->punkVal->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows));
        if (SUCCEEDED(hresT)) 
        {
            IUnknown* psite;
            hresT = pows->GetSite(IID_PPV_ARG(IUnknown, &psite));
            if (SUCCEEDED(hresT) && psite) 
            {
                _fOwned = IsSameObject(psite, pauto);
                psite->Release();
            }
            pows->Release();
        }
    }

    if (pvtValue->vt & VT_BYREF)
        return VariantCopyInd(&_vtValue, pvtValue);
    else
        return VariantCopyLazy(&_vtValue, pvtValue);
}

HRESULT CIEFrameAutoProp::CopyValue(VARIANT *pvtValue)
{
    _dwLastAccessed = GetCurrentTime();
    return VariantCopyLazy(pvtValue, &_vtValue);
}

BOOL CIEFrameAutoProp::IsExpired(DWORD dwCur)
{
    BOOL fExpired = FALSE;
    if (_fDiscardable) {
        fExpired = ((dwCur - _dwLastAccessed) > MSEC_PROPEXPIRE);
    }
    return fExpired;
}

//IDispatch functions, now part of IWebBrowserApp

STDAPI SafeGetItemObject(LPSHELLVIEW psv, UINT uItem, REFIID riid, void **ppv);

HRESULT CIEFrameAuto::v_InternalQueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = {
        // perf: last tuned 980728
        QITABENT(CIEFrameAuto, IConnectionPointContainer),     // IID_ConnectionPointContainer
        QITABENT(CIEFrameAuto, IWebBrowser2),          // IID_IWebBrowser2
        QITABENT(CIEFrameAuto, IServiceProvider),      // IID_IServiceProvider
        QITABENTMULTI(CIEFrameAuto, IWebBrowserApp, IWebBrowser2), // IID_IWebBrowserApp
        QITABENT(CIEFrameAuto, IShellService),         // IID_IShellService
        QITABENT(CIEFrameAuto, IEFrameAuto),           // IID_IEFrameAuto
        QITABENT(CIEFrameAuto, IExpDispSupport),       // IID_IExpDispSupport
        QITABENT(CIEFrameAuto, IWebBrowserPriv),       // IID_IWebBrowserPriv
        QITABENT(CIEFrameAuto, ITargetFrame2),         // IID_ITargetFrame2
        QITABENT(CIEFrameAuto, IHlinkFrame),           // IID_IHlinkFrame
        QITABENT(CIEFrameAuto, IOleCommandTarget),     // IID_IOleCommandTarget
        QITABENT(CIEFrameAuto, IUrlHistoryNotify),     // IID_IUrlHistoryNotify
        QITABENTMULTI(CIEFrameAuto, IDispatch, IWebBrowser2),  // rare IID_IDispatch
        QITABENTMULTI(CIEFrameAuto, IWebBrowser, IWebBrowser2),// rare IID_IWebBrowser
        QITABENT(CIEFrameAuto, IExternalConnection),   // rare IID_IExternalConnection
        QITABENT(CIEFrameAuto, ITargetNotify),         // rare IID_ITargetNotify
        QITABENT(CIEFrameAuto, ITargetFramePriv),      // rare IID_ITargetFramePriv
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
    {
        if (IsEqualIID(riid, IID_ITargetFrame))
        {
            *ppvObj = SAFECAST(&_TargetFrame, ITargetFrame*);
            AddRef();
            return S_OK;
        }
    }

    return hres;
}

LONG CIEFrameAuto::s_cIEFrameAuto = 0;

CIEFrameAuto::CIEFrameAuto(IUnknown* punkAgg) :
             m_dwFrameMarginWidth(0xFFFFFFFF)
            ,m_dwFrameMarginHeight(0xFFFFFFFF)
            ,CImpIDispatch(LIBID_SHDocVw, 1, 1, IID_IWebBrowser2)
            ,CAggregatedUnknown(punkAgg)
{
    TraceMsg(TF_SHDLIFE, "ctor CIEFrameAuto %x", this);

    //
    // REVIEW: We don't need to DllAddRef as long as all instances
    // of CIEFrameAuto are scoped by either CShellBrowser/CExplorerBrowser
    // or CWebBrowserOC. We can remove the DllAddRef/Release, but it's not
    // a perf hit so why bother??
    //
    DllAddRef();

    InterlockedIncrement(&s_cIEFrameAuto);

    ASSERT(_cLocks==0);
    ASSERT(_pITI==NULL);
    ASSERT(_pbs==NULL);
    ASSERT(_hwnd==NULL);
    ASSERT(_pProps==NULL);
    ASSERT(_phlbc == NULL);
    ASSERT(_dwRegHLBC == 0);
    ASSERT(m_bOffline==FALSE);
    ASSERT(m_bSilent==FALSE);
    ASSERT(_hinstMSHTML==0);
    ASSERT(_pfnMEGetIDsOfNames==0);
    ASSERT(0==_pwszShortcutPath);

    TraceMsg(TF_SHDLIFE, "ctor CIEFrameAuto(%x) being constructed", this);

    m_cpWebBrowserEvents.SetOwner(_GetInner(), &DIID_DWebBrowserEvents);
    m_cpWebBrowserEvents2.SetOwner(_GetInner(), &DIID_DWebBrowserEvents2);
    m_cpPropNotify.SetOwner(_GetInner(), &IID_IPropertyNotifySink);

    HRESULT hr = _omwin.Init();
    ASSERT(SUCCEEDED(hr));

    hr = _omloc.Init();
    ASSERT(SUCCEEDED(hr));

    hr = _omnav.Init(&_mimeTypes, &_plugins, &_profile);
    ASSERT(SUCCEEDED(hr));

    hr = _omhist.Init();
    ASSERT(SUCCEEDED(hr));

    hr = _mimeTypes.Init();
    ASSERT(SUCCEEDED(hr));

    hr = _plugins.Init();
    ASSERT(SUCCEEDED(hr));

    hr = _profile.Init();
    ASSERT(SUCCEEDED(hr));
}

HRESULT CIEFrameAuto_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk)
{
    CIEFrameAuto * pauto = new CIEFrameAuto(pUnkOuter);
    if (pauto) {
        *ppunk = pauto->_GetInner();
        return S_OK;
    }

    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

STDAPI_(void) DestroyHdpaHooks();     // implemented in url.cpp

CIEFrameAuto::~CIEFrameAuto()
{
    ASSERT(!_psp);

    // We're done with MSHTML's MatchExactGetIDsOfNames
    if (_hinstMSHTML)
    {
        FreeLibrary(_hinstMSHTML);
    }

    // Clear any pending or active navigation contexts
    _SetPendingNavigateContext(NULL, NULL);
    _ActivatePendingNavigateContext();

    // Close the browse context and release it.
    if (_phlbc)
    {
        IHlinkBrowseContext * phlbc = _phlbc;
        phlbc->AddRef();
        SetBrowseContext(NULL);
        phlbc->Close(0);
        phlbc->Release();
    }

    SetOwner(NULL);

    if (m_pszFrameName)
    {
        LocalFree(m_pszFrameName);
        m_pszFrameName = NULL;
    }
    if (m_pszFrameSrc)
    {
        LocalFree(m_pszFrameSrc);
        m_pszFrameSrc = NULL;
    }

    if (_pITI)
        _pITI->Release();

    if (_pbs)
        _pbs->Release();

    if (_pwszShortcutPath)
    {
        LocalFree(_pwszShortcutPath);
        _pwszShortcutPath = NULL;
    }

    if (_pwszShortcutPathPending)
    {
        LocalFree(_pwszShortcutPathPending);
        _pwszShortcutPathPending = NULL;
    }

    // Paranoia
    _ClearPropertyList();

    ASSERT( 0 != s_cIEFrameAuto );
    LONG cRef = InterlockedDecrement(&s_cIEFrameAuto);
    ASSERT(cRef >= 0 );
    if (0 == cRef )
    {
        //
        // we were releasing these guys
        // in DllRelease, but to avoid mem
        // leaks we need to be more aggressive
        // about deleting them.
        //

        DestroyHdpaHooks();
    }

    DllRelease();

    TraceMsg(TF_SHDLIFE, "dtor CIEFrameAuto %x", this);
}

/* IWebBrowserApp methods */

// Display name of the application
HRESULT CIEFrameAuto::get_Name(BSTR * pbstrName)
{
    *pbstrName = LoadBSTR(IDS_NAME);
    return *pbstrName ? S_OK : E_OUTOFMEMORY;
}

HRESULT CIEFrameAuto::get_HWND(LONG_PTR *pHWND)
{
    *pHWND = HandleToLong(_GetHWND());
    return *pHWND ? S_OK : E_FAIL;
}

// Fule filespec of executable, but sample I've seen doesn't give extension
HRESULT CIEFrameAuto::get_FullName(BSTR * pbstrFullName)
{
    // HACK: This is also the way to tell it to update the pidl in the window list.
    if (_pbs)    //Make sure we have a IBrowserService.
        _pbs->UpdateWindowList();

    TCHAR szPath[MAX_PATH];
    if (GetModuleFileName(NULL, szPath, ARRAYSIZE(szPath)) > 0)
    {
        *pbstrFullName = SysAllocStringT(szPath);
        return *pbstrFullName ? S_OK : E_OUTOFMEMORY;
    }
    *pbstrFullName = NULL;
    return E_FAIL;
}

// Path to the executable
STDMETHODIMP CIEFrameAuto::get_Path(BSTR * pbstrPath)
{
    TCHAR szPath[MAX_PATH];
    if (GetModuleFileName(NULL, szPath, ARRAYSIZE(szPath)) > 0)
    {
        *PathFindFileName(szPath) = TEXT('\0');
        *pbstrPath = SysAllocStringT(szPath);
        return *pbstrPath ? S_OK : E_OUTOFMEMORY;
    }
    *pbstrPath = NULL;
    return E_FAIL;
}

HRESULT CIEFrameAuto::get_Application(IDispatch  **ppDisp)
{
    return QueryInterface(IID_PPV_ARG(IDispatch, ppDisp));
}

HRESULT CIEFrameAuto::get_Parent(IDispatch  **ppDisp)
{
    return QueryInterface(IID_PPV_ARG(IDispatch, ppDisp));
}

HRESULT CIEFrameAuto::get_Left(long * pl)
{
    ASSERT(pl);

    HRESULT hr;

    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        *pl = rc.left;
        hr = S_OK;
    }
    else
    {
        *pl = 0;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CIEFrameAuto::put_Left(long Left)
{
    RECT rc;

    if (_pbs)
        _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);

    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        GetWindowRect(hwnd, &rc);
        SetWindowPos(hwnd, NULL, Left, rc.top, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
    }

    return S_OK;
}

HRESULT CIEFrameAuto::get_Top(long * pl)
{
    ASSERT(pl);

    HRESULT hr;

    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        *pl = rc.top;
        hr = S_OK;
    }
    else
    {
        *pl = 0;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CIEFrameAuto::put_Top(long Top)
{
    RECT rc;

    if (_pbs)
        _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);

    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        GetWindowRect(hwnd, &rc);
        SetWindowPos(hwnd, NULL, rc.left, Top, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);
    }

    return S_OK;
}

HRESULT CIEFrameAuto::get_Width(long * pl)
{
    ASSERT(pl);

    HRESULT hr;

    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        *pl = rc.right - rc.left;
        hr = S_OK;
    }
    else
    {
        *pl = 0;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CIEFrameAuto::put_Width(long Width)
{
    if (_pbs)
        _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);


    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        SetWindowPos(hwnd, NULL, 0, 0, Width, rc.bottom-rc.top, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
    }
    return S_OK;
}

HRESULT CIEFrameAuto::get_Height(long * pl)
{
    ASSERT(pl);

    HRESULT hr;

    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        *pl = rc.bottom - rc.top;
        hr = S_OK;
    }
    else
    {
        *pl = 0;
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CIEFrameAuto::put_Height(long Height)
{
    if (_pbs)
        _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);

    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        RECT rc;
        GetWindowRect(hwnd, &rc);
        SetWindowPos(hwnd, NULL, 0, 0, rc.right-rc.left, Height, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);
    }

    return S_OK;
}


HRESULT CIEFrameAuto::put_Titlebar(BOOL fValue)
{
    HWND hwnd;
    HRESULT hres = get_HWND((LONG_PTR*)&hwnd);
    if (SUCCEEDED(hres))
    {
        DWORD dwVal = GetWindowLong(hwnd, GWL_STYLE);
        if (fValue)
            dwVal |= WS_CAPTION;
        else
            dwVal &= ~WS_CAPTION;

        if (SetWindowLong(hwnd, GWL_STYLE, dwVal))
        {
            // We need to do a SetWindowPos in order for the style changes to take effect
            SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
        }
        else
            hres = E_FAIL;
    }
    return hres;
}

HRESULT CIEFrameAuto::get_Visible(VARIANT_BOOL * pBool)
{
    HWND hwnd = _GetHWND();
    *pBool = hwnd ? TO_VARIANT_BOOL(IsWindowVisible(hwnd)) : VARIANT_FALSE;

    return S_OK;
}

HRESULT CIEFrameAuto::put_Visible(VARIANT_BOOL Value)
{
    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        ::ShowWindow(hwnd, Value? SW_SHOW : SW_HIDE);
        if (Value)
            ::SetForegroundWindow(::GetLastActivePopup(hwnd));
        FireEvent_OnAdornment(_GetOuter(), DISPID_ONVISIBLE, Value);
    }

    return S_OK;
}


HRESULT CIEFrameAuto::get_Document(IDispatch **ppDisp)
{
    HRESULT      hres = E_FAIL;
    IShellView * psv  = NULL;

    *ppDisp = NULL;

    if (_psb)
    {
        hres = _psb->QueryActiveShellView(&psv);

        if (FAILED(hres))
        {
            CComVariant cvarUnk;

            hres = _pmsc->Exec(&CGID_ShellDocView, SHDVID_GETPENDINGOBJECT, 0, NULL, &cvarUnk);

            if (SUCCEEDED(hres))
            {
                if ((VT_UNKNOWN == V_VT(&cvarUnk)) && V_UNKNOWN(&cvarUnk))
                {
                    hres = cvarUnk.punkVal->QueryInterface(IID_IShellView, (void**)&psv);
                }
                else
                {
                    hres = E_FAIL;
                }
            }

        }

        if (psv)
        {
            IDispatch * pDisp;

            hres = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_PPV_ARG(IDispatch, &pDisp));
            if (SUCCEEDED(hres))
            {
                // (scotrobe 01/14/2000): We need to QI for IHTMLDocument2 to support
                // bad apps (e.g., HotMetal Pro) that cast the IDispatch to IHTMLDocument2.
                // Casting like this used to work because the object returned from 
                // SafeGetItemObject() used to implement IHTMLDocument2.  Now, it delegates 
                // that implementation to another object. If the QI for IHTMLDocument2 fails, '
                // then the object is not MSHTML. In that case, we just return the
                // IDispatch that was returned from SafeGetItemObject().
                //
                IHTMLDocument2 * pDocument;

                HRESULT hr = pDisp->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDocument));

                if (SUCCEEDED(hr))
                {
                    *ppDisp = pDocument;
                    pDisp->Release();
                }
                else  // Non-html document
                {
                    *ppDisp = pDisp;  // Don't release pDisp
                }
            }

            psv->Release();
        }
    }

    return hres;
}

HRESULT CIEFrameAuto::get_Busy(VARIANT_BOOL *pBool)
{
    if (_pbs == NULL)
    {
        TraceMsg(DM_WARNING, "CIEA::get_Busy called _pbs==NULL");
        return E_FAIL;
    }

    BNSTATE bnstate;
    HRESULT hres = _pbs->GetNavigateState(&bnstate);
    if (SUCCEEDED(hres))
    {
        *pBool = TO_VARIANT_BOOL(bnstate != BNS_NORMAL);
        hres = S_OK;
    }

    return hres;
}


// MSDN97 keeps asking for a location until it gets success, so it
// hangs if we fail.  Make sure no code paths return early from here...
//
HRESULT CIEFrameAuto::_get_Location(BSTR * pbstr, UINT uFlags)
{
    if (_pbs)
    {
        LPITEMIDLIST pidl;
        HRESULT hres = _pbs->GetPidl(&pidl);

        if (SUCCEEDED(hres))
        {
            WCHAR wszTitle[MAX_URL_STRING];

            hres = _pbs->IEGetDisplayName(pidl, wszTitle, uFlags);

            ILFree(pidl);

            if (SUCCEEDED(hres))
            {
                //
                // if url is a pluggable protocol, get the real url by
                // chopping of the base url
                //
                WCHAR *pchUrl = StrChrW(wszTitle, L'\1');
                if (pchUrl)
                    *pchUrl = 0;

                //
                //  if there is already an URL then we just use it
                //
                if ((uFlags & SHGDN_FORPARSING) && !PathIsURLW(wszTitle))
                {
                    int nScheme;
                    //
                    // otherwise we need to treat it as if it were new
                    // and make sure it is a parseable URL.
                    //
                    DWORD cchTitle = ARRAYSIZE(wszTitle);

                    ParseURLFromOutsideSourceW(wszTitle, wszTitle, &cchTitle, NULL);

                    // BUG FIX #12221:
                    // ParseURLFromOutsideSource() was called to turn a file path into
                    // a fully qualified FILE URL.  If the URL was of any other type
                    // (non-URL sections of the name space), then we want to NULL out the
                    // string to indicate that it's invalid.  We don't return E_FAIL because
                    // HotDog Pro appears to have problems with that as indicated by the comment
                    // below.
                    nScheme = GetUrlSchemeW(wszTitle);
                    if (URL_SCHEME_FILE != nScheme)
                        wszTitle[0] = TEXT('\0');
                }
                *pbstr = SysAllocString(wszTitle);
                return *pbstr ? S_OK : E_OUTOFMEMORY;
            }
        }
    }

    // If we're here, the TLGetPidl call failed.  This can happen if get_LocationName
    // or get_LocationURL is called before the first navigate is complete.  HotDog Pro does
    // this, and was failing with E_FAIL.  Now we'll just return an empty string with S_FALSE.
    //
    // Also MSDN97 hangs (NT5 bug 232126) if we return failure.  Guess there hosed on low
    // memory situations...
    //
    *pbstr = SysAllocString(L"");
    return *pbstr ? S_FALSE : E_OUTOFMEMORY;
}

HRESULT CIEFrameAuto::get_LocationName(BSTR * pbstrLocationName)
{
    return _get_Location(pbstrLocationName, SHGDN_NORMAL);
}

HRESULT CIEFrameAuto::get_LocationURL(BSTR * pbstrLocationURL)
{
    return _get_Location(pbstrLocationURL, SHGDN_FORPARSING);
}

HRESULT CIEFrameAuto::Quit()
{
    // try to close it down...
    _fQuitInProgress = 1;
    HWND hwnd = _GetHWND();
    if (hwnd)
        PostMessage(hwnd, WM_CLOSE, 0, 0);

    return S_OK;
}

HRESULT CIEFrameAuto::ClientToWindow(int *pcx, int *pcy)
{
    if (_pbs==NULL)
    {
        TraceMsg(DM_WARNING, "CIEA::ClientToWindow called _pbs==NULL");
        return E_FAIL;
    }

    HWND hwnd;
    RECT rc;
    BOOL b;

    rc.left = 0;
    rc.right = *pcx;
    rc.top = 0;
    rc.bottom = *pcy;

    _pbs->IsControlWindowShown(FCW_MENUBAR, &b);

    HWND hwnd2 = _GetHWND();

    if (hwnd2)
        AdjustWindowRect(&rc, GetWindowLong(hwnd2, GWL_STYLE), b);

    *pcx = rc.right-rc.left;
    *pcy = rc.bottom-rc.top;

    _pbs->IsControlWindowShown(FCW_STATUS, &b);
    if (b)
    {
        _psb->GetControlWindow(FCW_STATUS, &hwnd);
        if (hwnd)
        {
            GetWindowRect(hwnd, &rc);
            *pcy += rc.bottom-rc.top;
        }
    }

    _pbs->IsControlWindowShown(FCW_INTERNETBAR, &b);
    if (b)
    {
        _psb->GetControlWindow(FCW_INTERNETBAR, &hwnd);
        if (hwnd)
        {
            GetWindowRect(hwnd, &rc);
            *pcy += rc.bottom-rc.top;
        }
    }

    //  add in 4 pixels for 3d borders, but don't include scrollbars
    //  'cause Netscape doesn't
    *pcy += 2*GetSystemMetrics(SM_CYEDGE);
    *pcx += 2*GetSystemMetrics(SM_CXEDGE);

    return S_OK;
}

void CIEFrameAuto::_ClearPropertyList()
{
    CIEFrameAutoProp *pprop = _pProps;
    _pProps = NULL;     // cleared out early...

    CIEFrameAutoProp *ppropNext;
    while (pprop)
    {
        ppropNext = pprop->Next();
        delete pprop;
        pprop = ppropNext;
    }
}

HRESULT CIEFrameAuto::PutProperty(BSTR bstrProperty, VARIANT vtValue)
{
    if (!bstrProperty)
    {
        TraceMsg(TF_ERROR, "CIEFrameAuto::PutProperty() - bstrProperty is NULL!");
        return E_INVALIDARG;
    }

#ifdef DEBUG
    // Check if this BSTR is a valid BSTR
    SA_BSTR* psstr = (SA_BSTR*)((LPBYTE)bstrProperty - sizeof(ULONG));
    ASSERT(psstr->cb == lstrlenW(psstr->wsz)*sizeof(WCHAR));
#endif

    HRESULT hres;
    CIEFrameAutoProp *pprop = _pProps;
    while (pprop && !pprop->IsOurProp(bstrProperty))
        pprop=pprop->Next();

    if (!pprop)
    {
        pprop = new CIEFrameAutoProp;
        if (!pprop)
            return E_OUTOFMEMORY;
        if (FAILED(hres=pprop->Initialize(bstrProperty)))
        {
            delete pprop;
            return hres;
        }
        pprop->_next = _pProps;

        _pProps = pprop;
    }

    hres = pprop->SetValue(&vtValue, this);

    // We should now tell anyone who is listening about the change...
    FireEvent_DoInvokeBstr(_GetOuter(), DISPID_PROPERTYCHANGE, bstrProperty);

    return hres;
}

HRESULT CIEFrameAuto::GetProperty(BSTR bstrProperty, VARIANT * pvtValue)
{
    if (!bstrProperty || !pvtValue)
        return E_INVALIDARG;

    VariantInit(pvtValue);

    CIEFrameAutoProp *pprop = _pProps;
    while (pprop && !pprop->IsOurProp(bstrProperty))
        pprop = pprop->Next();
    if (pprop)
    {
        return pprop->CopyValue(pvtValue);
    }

    // Did not find property return empty...
    // Not there.  Probably not worth an error...
    return S_OK;
}


extern HRESULT TargetQueryService(IUnknown *punk, REFIID riid, void **ppvObj);

//+-------------------------------------------------------------------------
//
//  Method    : CIEFrameAuto::Navigate
//
//  Interface : IWebBrowser
//
//--------------------------------------------------------------------------

HRESULT CIEFrameAuto::Navigate(BSTR      URL,
                               VARIANT * Flags,
                               VARIANT * TargetFrameName,
                               VARIANT * PostData,
                               VARIANT * Headers)
{
    return _NavigateHelper(URL, Flags, TargetFrameName, PostData, Headers);
}

//+-------------------------------------------------------------------------
//
//  Method    : CIEFrameAuto::NavigateWithBindCtx
//
//  Interface : IWebBrowserPriv
//
//--------------------------------------------------------------------------

HRESULT CIEFrameAuto::NavigateWithBindCtx(VARIANT FAR * pvarUrl,
                                          VARIANT FAR * pvarFlags,
                                          VARIANT FAR * pvarTargetFrameName,
                                          VARIANT FAR * pvarPostData,
                                          VARIANT FAR * pvarHeaders,
                                          IBindCtx    * pBindCtx,
                                          BSTR          bstrLocation)
{
    return _NavigateHelper(V_BSTR(pvarUrl),
                           pvarFlags,
                           pvarTargetFrameName,
                           pvarPostData,
                           pvarHeaders,
                           pBindCtx,
                           bstrLocation);
}

//+-------------------------------------------------------------------------
//
//  Method    : CIEFrameAuto::NavigateWithBC
//
//  Interface : IWebBrowserPriv
//
//--------------------------------------------------------------------------

HRESULT
CIEFrameAuto::OnClose()
{
    // Clear any pending or active navigation contexts
    //
    _SetPendingNavigateContext(NULL, NULL);
    _ActivatePendingNavigateContext();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method : CIEFrameAuto::_NavigateHelper
//
//--------------------------------------------------------------------------

HRESULT
CIEFrameAuto::_NavigateHelper(BSTR       URL,
                              VARIANT  * Flags,
                              VARIANT  * TargetFrameName,
                              VARIANT  * PostData,
                              VARIANT  * Headers,
                              IBindCtx * pNavBindCtx, /* = NULL */
                              BSTR       bstrLocation /* = NULL */)
{
    if (NULL == _pbs)
    {
        TraceMsg(DM_WARNING, "CIEA::Navigate called _pbs==NULL");
        return E_FAIL;
    }

    if (NULL == URL)
    {
        TraceMsg(TF_SHDAUTO, "Shell automation: CIEFrameAuto::Navigate <NULL> called");
        return(_BrowseObject(PIDL_NOTHING, 0));
    }

    // Special hack for AOL:  They send us the following "url" as a null navigate.
    // Then they immediately follow it with the url for the new window.  That second
    // navigate is failing with RPC_E_CALL_REJECTED because of our message filter.
    // We fix the new window case by special casing this URL and returning S_FALSE.
    // This url will not likely ever be seen in the real world, and if it is typed in,
    // will get normalized and canonicalized long before getting here.
    //
    if (!StrCmpIW(URL, L"x-$home$://null"))
    {
        return S_FALSE;
    }

#ifdef BROWSENEWPROCESS_STRICT // "Nav in new process" has become "Launch in new process", so this is no longer needed
    // if we want ALL navigates to be in a separate process, then we need to
    // pick off URL navigates for CShellBrowser IShellBrowser implementations
    // when we are in the explorer process.  We can wait until IShellBrowser::BrowseObject,
    // but then we may lose TargetFrameName etc...
    //
    if (IsBrowseNewProcessAndExplorer() && !IsShellUrl(URL, TRUE))
    {
    }
#endif


    HRESULT      hres;
    LPITEMIDLIST pidl               = NULL;
    LPBINDCTX    pBindCtx           = NULL;
    DWORD        cbPostData         = 0;
    LPCWSTR      pwzHeaders         = NULL;
    DWORD        dwInFlags          = 0;
    DWORD        dwFlags            = 0;
    LPCBYTE      pPostData          = NULL;
    DWORD        grBindFlags        = 0;
    SAFEARRAY  * pPostDataArray     = NULL;
    BOOL         fOpenWithFrameName = FALSE;
    
    CStubBindStatusCallback * pStubCallback = NULL;

    // get target frame name out of variant
    LPCWSTR pwzTargetFrameName = NULL;
    LPCWSTR pwzUnprefixedTargetFrameName = NULL;

    hres = E_FAIL;
    TraceMsg(TF_SHDAUTO, "Shell automation: CIEFrameAuto::Navigate %s called", URL);

    if (TargetFrameName)
    {
       if ((VT_BSTR | VT_BYREF) == TargetFrameName->vt)
           pwzTargetFrameName = *TargetFrameName->pbstrVal;
       else if (VT_BSTR == TargetFrameName->vt)
           pwzTargetFrameName = TargetFrameName->bstrVal;
    }

    // if a target name was specified, send the navigation to the appropriate target
    // NOTE: for compatibility we can't change the meaning of target here
    // thus we don't attempt to find alias
    if ((pwzTargetFrameName && pwzTargetFrameName[0]))
    {
        LPTARGETFRAME2 pOurTargetFrame = NULL;
        IUnknown *punkTargetFrame;
        IWebBrowserApp * pIWebBrowserApp;
        BOOL fHandled = FALSE;

        // see if there is an existing frame with the specified target name
        // NOTE: we used docked parameter of _self to force navigation of this
        // frame, regardless of whether it is WebBar.
        hres = TargetQueryService((IShellBrowser *)this, IID_PPV_ARG(ITargetFrame2, &pOurTargetFrame));

        ASSERT(SUCCEEDED(hres));

        if (SUCCEEDED(hres))
        {
            // Workaround for the way Compuserve handles the NewWindow event (window.open)
            // They tell the new instance of the web browser to navigate, but they pass the target frame
            // name they received on the NewWindow event.  This confuses us because that frame name
            // has the "_[number]" prefix.
            //
            // If the first two characters are "_[", then look for the "]" and reallocate a string
            // with everthing after that bracket.
            //

            if (StrCmpNW(pwzTargetFrameName, L"_[", 2) == 0)
            {
                pwzUnprefixedTargetFrameName = StrChrW(pwzTargetFrameName, L']');
                if (pwzUnprefixedTargetFrameName)
                {
                    pwzUnprefixedTargetFrameName++;
                    pwzTargetFrameName = SysAllocString(pwzUnprefixedTargetFrameName);
                    if (!pwzTargetFrameName)
                    {
                        hres = E_OUTOFMEMORY;
                        goto exit;
                    }
                }
            }

            hres = pOurTargetFrame->FindFrame(pwzTargetFrameName,
                                              FINDFRAME_JUSTTESTEXISTENCE,
                                              &punkTargetFrame);

            if (SUCCEEDED(hres) && punkTargetFrame) 
            {
                // yes, we found a frame with that name.  QI for the automation
                // interface on that frame and call navigate on it.
                hres = punkTargetFrame->QueryInterface(IID_PPV_ARG(IWebBrowserApp, &pIWebBrowserApp));
                punkTargetFrame->Release();

                ASSERT(SUCCEEDED(hres));

                if (SUCCEEDED(hres)) 
                {
                    VARIANT var;
                    LBSTR::CString      strFrame;

                    VariantInit(&var);

                    var.vt = VT_BSTR;
                    var.bstrVal = strFrame;

                    hres = pIWebBrowserApp->Navigate(URL, Flags, &var, PostData, Headers);

                    var.bstrVal = NULL;
                    VariantClearLazy(&var);

                    pIWebBrowserApp->Release();
                    fHandled = TRUE;
                }
            }
            else if (SUCCEEDED(hres))
            {
                //no target found means we need to open a new window
                //hres = E_FAIL forces parsing of URL into pidl
                //if we have no target frame name, then
                //  BETA1 hack chrisfra 3/3/97.  in BETA 2 TargetFrame2
                //  interface must support aliasing of targets (even if NULL
                //  to support links in desktop components as per PM requirements
                if (!pwzTargetFrameName || !pwzTargetFrameName[0])
                {
                    ASSERT(_fDesktopComponent());
                    pwzTargetFrameName = L"_desktop";
                }

                dwFlags |= HLNF_OPENINNEWWINDOW;
                fOpenWithFrameName = TRUE;
                hres = E_FAIL;
            }

            pOurTargetFrame->Release();
            if (fHandled)
                goto exit;
        }
    }

    if (FAILED(hres))
    {
        hres = _PidlFromUrlEtc(CP_ACP, (LPCWSTR)URL, bstrLocation, &pidl);

        if (FAILED(hres))
            goto exit;
    }

    // to perform the navigation, we either call an internal method
    // (_pbs->NavigateToPidl) or an external interface (IHlinkFrame::Navigate),
    // depending on what data we need to pass.  NavigateToPidl is faster
    // and cheaper, but does not allow us to pass headers or post data, just
    // the URL!  So what we do is call the fast and cheap way if only the URL
    // was specified (the 90% case), and if either headers or post data were
    // specified then we call the external interface.  We have to do a bunch
    // of wrapping of parameters in IMonikers and IHlinks and whatnot only to
    // unwrap them at the other end, so we won't call this unless we need to.

    if (Headers)
    {
       if ((VT_BSTR | VT_BYREF) == Headers->vt)
       {
           pwzHeaders = *Headers->pbstrVal;
       }
       else if (VT_BSTR == Headers->vt)
       {
           pwzHeaders = Headers->bstrVal;
       }
    }

    //
    // HACK: We used to do VT_ARRAY==PostData->vt, which is bogus.
    //  It is supposed to be VT_ARRAY|VT_UI1==PostData->vt. We can't
    //  however do it for backward compatibility with AOL and CompuServe.
    //  Therefore, we do (VT_ARRAY & PostData->vt)
    //
    if (PostData && (VT_ARRAY & PostData->vt))
    {
        if (VT_BYREF & PostData->vt)
        {
            pPostDataArray = *PostData->pparray;
        }
        else
        {
            pPostDataArray = PostData->parray;
        }

        ASSERT(pPostDataArray);

        if (pPostDataArray)
        {
            // lock the array for reading, get pointer to data
            hres = SafeArrayAccessData(pPostDataArray, (void**)&pPostData);

            if (SUCCEEDED(hres)) 
            {
                long nElements = 0;
                DWORD dwElemSize;
                // get number of elements in array
                SafeArrayGetUBound(pPostDataArray,1,(long *) &nElements);
                // SafeArrayGetUBound returns zero-based max index, add one to get element count
                nElements++;
                // get bytes per element
                dwElemSize = SafeArrayGetElemsize(pPostDataArray);
                // bytes per element should be one if we created this array
                ASSERT(dwElemSize == 1);
                // calculate total byte count anyway so that we can handle
                // safe arrays other people might create with different element sizes
                cbPostData = dwElemSize * nElements;

                if (0 == cbPostData)
                    pPostData = NULL;
            }
        }
    }


    // convert from automation interface flags (nav*) to
    // hyperlinking flags (HLNF_*)
    if (Flags)
    {
        if (Flags->vt == VT_I4)
        {
            dwInFlags = Flags->lVal;
        }
        else if (Flags->vt == VT_I2)
        {
            dwInFlags = Flags->iVal;
        }

        if ((dwInFlags & navOpenInNewWindow))
        {
            dwFlags |= HLNF_OPENINNEWWINDOW;
        }

        if (dwInFlags & navNoHistory)
        {
            dwFlags |= HLNF_CREATENOHISTORY;
        }

        if (dwInFlags & navNoReadFromCache)
        {
            grBindFlags |= BINDF_RESYNCHRONIZE | BINDF_PRAGMA_NO_CACHE;
        }

        if (dwInFlags & navNoWriteToCache)
        {
            grBindFlags |= BINDF_NOWRITECACHE;
        }

        if (dwInFlags & navHyperlink)
        {
            grBindFlags |= BINDF_HYPERLINK;
        }

        if (dwInFlags & navEnforceRestricted)
        {
            grBindFlags |= BINDF_ENFORCERESTRICTED;
        }

        // Should call IsBrowserFrameOptionsPidlSet() instead.  Some URL delegate
        //         NSEs may or may not want this feature.
        if (IsURLChild(pidl, TRUE) && (dwInFlags & navAllowAutosearch))
        {
            dwFlags |= HLNF_ALLOW_AUTONAVIGATE;
        }
    }


    // if we have either headers or post data or need to open the page in a
    // new window or pass HLNF_CREATENOHISTORY, we have to do the navigation
    // the hard way (through IHlinkFrame::Navigate) -- here we have to do
    // a bunch of wrapping of parameters into COM objects that IHlinkFrame::
    // Navigate wants.
    if (pwzHeaders || pPostData || dwFlags || grBindFlags)
    {
        // Check to see if this frame is offline.
        // This is the same as doing a get_Offline

        VARIANT_BOOL vtbFrameIsOffline = m_bOffline ? VARIANT_TRUE : VARIANT_FALSE;
        VARIANT_BOOL vtbFrameIsSilent = m_bSilent ? VARIANT_TRUE : VARIANT_FALSE;

        // make a "stub" bind status callback to hold that data and pass it
        // to the URL moniker when requested
        hres = CStubBindStatusCallback_Create(pwzHeaders,pPostData,cbPostData,
                                              vtbFrameIsOffline, vtbFrameIsSilent,
                                              TRUE, grBindFlags, &pStubCallback);

        if (FAILED(hres))
            goto exit;

        // get the canonicalized name back out of the pidl.  Note this is
        // different than the URL passed in... it has been auto-protocol-ized,
        // canonicalized and generally munged in the process of creating the pidl,
        // which is what we want to use.

        // need +3.  +2 for iegetdisplayname call inside failed statment below, and +1 for movememory further below
        WCHAR wszPath[MAX_URL_STRING+3];  // note stomping below if changed to dynalloc
        hres = _pbs->IEGetDisplayName(pidl, wszPath, SHGDN_FORPARSING);
        if (FAILED(hres))
        {
            // On Win9x, IEGetDisplayName(SHGDN_FORPARSING) will return NOT_IMPLEMENTED
            // for \\servername (but not \\servername\share)
            // We need to work around this.
            DWORD ccPath = ARRAYSIZE(wszPath);
            if (SUCCEEDED(PathCreateFromUrl(URL, wszPath, &ccPath, 0))
                && *wszPath==L'\\' 
                && *(wszPath+1)==L'\\')
            {
                hres = _pbs->IEGetDisplayName(pidl, wszPath + 2, SHGDN_FORADDRESSBAR); // assumes MAX_URL_STRING size for the string
            }
        }

        if (FAILED(hres))
        {
            TraceMsg(DM_ERROR, "CIEFrameAuto::Navigate _pbs->IEGetDisplayName failed %x", hres);
            goto exit;
        }

        WCHAR *pwzLocation = (WCHAR *)UrlGetLocationW(wszPath);

        if (pwzLocation)
        {
            //  NOTE: we allocated an extra char, just so we could do the following
            MoveMemory(pwzLocation+1, pwzLocation, (lstrlenW(pwzLocation)+1)*sizeof(WCHAR));
            *pwzLocation++ = TEXT('\0');   // we own wszPath, so we can do this.
        }

        if (!pNavBindCtx)  // A bind ctx was not passed in.
        {
            // Create a bind context to pass to IHlinkFrame::Navigate
            //
            hres = CreateBindCtx(0, &pBindCtx);

            if (FAILED(hres))
                goto exit;
        }
        else
        {
            pBindCtx = pNavBindCtx;
            pBindCtx->AddRef();
        }

        // We have either post data or headers (or we need to open
        // in a new window) to pass in addition to URL.
        // Call IHlinkFrame::Navigate to do the navigation
        //
        hres = NavigateHack(dwFlags,
                            pBindCtx,
                            pStubCallback,
                            fOpenWithFrameName ? pwzTargetFrameName:NULL,
                            wszPath,
                            pwzLocation);
    }
    else
    {
        ASSERT(dwFlags == 0);

        if (pNavBindCtx)
        {
            _SetPendingNavigateContext(pNavBindCtx, NULL);
        }

        //
        // NOTES: We used to call _pbs->NavigatePidl (in IE3.0), now we call
        // _psb->BrowseObject, so that we ALWAYS hit that code path.
        //
        hres = _BrowseObject(pidl, SBSP_SAMEBROWSER|SBSP_ABSOLUTE);
    }

exit:

    // clean up
    if (pPostDataArray)
    {
        // done reading from array, unlock it
        SafeArrayUnaccessData(pPostDataArray);
    }

    // If pwzUnprefixedTargetFrameName is non-null, then we allocated and set our own
    //  pwzTargetFrameName.
    //
    if (pwzUnprefixedTargetFrameName && pwzTargetFrameName)
    {
        SysFreeString((BSTR) pwzTargetFrameName);
    }

    ATOMICRELEASE(pStubCallback);
    ATOMICRELEASE(pBindCtx);

    Pidl_Set(&pidl, NULL);

    return hres;
}

//
// Parameters:
//  pvaClsid Specifies the bar to be shown/hide
//  pvaShow  Specifies whether or not we should show or hide (default is show)
//  pvaSize  Specifies the size (optional)
//  HACK: really hoaky nCmdExecOpt overloading...
//
HRESULT CIEFrameAuto::ShowBrowserBar(VARIANT * pvaClsid, VARIANT *pvaShow, VARIANT *pvaSize)
{
    // Use this convenient, marshalable method to show or hide the Address (URL) band, the tool band,
    //  or the link band.
    //
    if (pvaShow && pvaShow->vt == VT_EMPTY)
        pvaShow = NULL;

    if (pvaShow && pvaShow->vt != VT_BOOL)
        return DISP_E_TYPEMISMATCH;

    if (pvaClsid->vt == VT_I2
        && (pvaClsid->iVal == FCW_ADDRESSBAR
         || pvaClsid->iVal == FCW_TOOLBAND
         || pvaClsid->iVal == FCW_LINKSBAR))
    {
        return IUnknown_Exec(_pbs, &CGID_Explorer, SBCMDID_SHOWCONTROL,
            MAKELONG(pvaClsid->iVal, pvaShow ? pvaShow->boolVal : 1), NULL, NULL);
    }
    else {
        return IUnknown_Exec(_pbs, &CGID_ShellDocView, SHDVID_SHOWBROWSERBAR,
            pvaShow ? pvaShow->boolVal : 1, pvaClsid, NULL);
    }
}

HRESULT CIEFrameAuto::Navigate2(VARIANT * pvURL, VARIANT * pFlags, VARIANT * pTargetFrameName, VARIANT * pPostData, VARIANT * pHeaders)
{
    HRESULT hr = E_INVALIDARG;

    if (pFlags && ((WORD)(VT_I4) == pFlags->vt) && (pFlags->lVal == navBrowserBar))
    {
        hr = IUnknown_Exec(_pbs, &CGID_ShellDocView, SHDVID_NAVIGATEBB, 0, pvURL, NULL);
    }
    else if (!pvURL)
    {
        hr = Navigate(NULL, NULL, NULL, NULL, NULL);
    }
    else
    {
        LPCWSTR pszURL = VariantToStrCast(pvURL);
        if (pszURL)
        {
            hr = Navigate((BSTR)pszURL, pFlags, pTargetFrameName, pPostData, pHeaders);
        }
        else
        {
            LPITEMIDLIST pidl = VariantToIDList(pvURL);
            if (pidl)
            {
                hr = _BrowseObject(pidl, SBSP_SAMEBROWSER | SBSP_ABSOLUTE);
                ILFree(pidl);
            }
        }
    }

    return hr;
}

HRESULT CIEFrameAuto::GoBack()
{
    HRESULT hr;
    IWebBrowser *pwb;

    if (!IsSameObject(_psb, _psbFrameTop) && _psbFrameTop)
    {
        hr = IUnknown_QueryService(_psbFrameTop, IID_ITargetFrame2, IID_PPV_ARG(IWebBrowser, &pwb));
        if (pwb)
        {
            hr = pwb->GoBack();
            pwb->Release();
        }
        else
            hr = E_FAIL;
    }
    else
        hr = _BrowseObject(NULL, SBSP_SAMEBROWSER|SBSP_NAVIGATEBACK);
    return hr;
}


HRESULT CIEFrameAuto::GoForward()
{
    HRESULT hr;
    IWebBrowser *pwb;

    if (!IsSameObject(_psb, _psbFrameTop) && _psbFrameTop)
    {
        hr = IUnknown_QueryService(_psbFrameTop, IID_ITargetFrame2, IID_PPV_ARG(IWebBrowser, &pwb));
        if (pwb)
        {
            hr = pwb->GoForward();
            pwb->Release();
        }
        else
            hr = E_FAIL;
    }
    else
        hr = _BrowseObject(NULL, SBSP_SAMEBROWSER|SBSP_NAVIGATEFORWARD);
    return hr;
}

HRESULT CIEFrameAuto::_GoStdLocation(DWORD dwWhich)
{
    TraceMsg(TF_SHDAUTO, "Shell automation: CIEFrameAuto:GoHome called");

    HRESULT hres;
    LPITEMIDLIST pidl = NULL;
    HWND hwnd = _GetHWND();

    if (hwnd)
    {
        hres = SHDGetPageLocation(hwnd, dwWhich, NULL, 0, &pidl);
        if (SUCCEEDED(hres)) {
            //
            // NOTES: We used to call _pbs->NavigatePidl (in IE3.0), now we call
            // _psb->BrowseObject, so that we ALWAYS hit that code path.
            //
            hres = _BrowseObject(pidl, SBSP_SAMEBROWSER|SBSP_ABSOLUTE);
            ILFree(pidl);
        }
    }
    else
    {
        hres = S_FALSE;
    }

    return hres;
}

HRESULT CIEFrameAuto::GoHome()
{
    return _GoStdLocation(IDP_START);
}

HRESULT CIEFrameAuto::GoSearch()
{
    return _GoStdLocation(IDP_SEARCH);
}

HRESULT CIEFrameAuto::Stop()
{
    //
    //  Calling _CancelPendingNavigation() is not enough here because
    // it does not stop the on-going navigation in the current page.
    // Exec(NULL, OLECMDID_STOP) will cancel pending navigation AND
    // stop the on-going navigation.
    //
    if (_pmsc) {
        return _pmsc->Exec(NULL, OLECMDID_STOP, 0, NULL, NULL);
    }

    return(E_UNEXPECTED);
}

HRESULT CIEFrameAuto::Refresh()
{
    VARIANT v = {0};
    v.vt = VT_I4;
    v.lVal = OLECMDIDF_REFRESH_NO_CACHE;
    return Refresh2(&v);
}

HRESULT CIEFrameAuto::Refresh2(VARIANT * Level)
{
    HRESULT hres = E_FAIL;
    IShellView *psv;

    if (_psb && SUCCEEDED(hres = _psb->QueryActiveShellView(&psv)) && psv)
    {
        hres = IUnknown_Exec(psv, NULL, OLECMDID_REFRESH, OLECMDEXECOPT_PROMPTUSER, Level, NULL);
        psv->Release();
    }


    return hres;
}

STDMETHODIMP CIEFrameAuto::get_Container(IDispatch  **ppDisp)
{
    *ppDisp = NULL;
    return NOERROR;
}

STDMETHODIMP CIEFrameAuto::get_FullScreen(VARIANT_BOOL * pBool)
{
    HRESULT hres;
    BOOL bValue;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::get_FullScreen called _pbs==NULL");
        return E_FAIL;
    }

    // Put the processing of this in the main Frame class
    bValue = (BOOL)*pBool;
    hres = _pbs->IsControlWindowShown((UINT)-1, &bValue);
    *pBool = TO_VARIANT_BOOL(bValue);
    return hres;
}

STDMETHODIMP CIEFrameAuto::put_FullScreen(VARIANT_BOOL Bool)
{
    HRESULT hres;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::put_FullScreen called _pbs==NULL");
        return E_FAIL;
    }

    _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);
    // Put the processing of this in the main Frame class
    hres = _pbs->ShowControlWindow((UINT)-1, (BOOL)Bool);

    FireEvent_OnAdornment(_GetOuter(), DISPID_ONFULLSCREEN, Bool);

    return(hres);
}

STDMETHODIMP CIEFrameAuto::get_StatusBar(VARIANT_BOOL * pBool)
{
    HRESULT hres;
    BOOL bValue;

    if (!pBool)
        return E_INVALIDARG;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::get_StatusBar called _pbs==NULL");
        return E_FAIL;
    }

    // Put the processing of this in the main Frame class
    bValue = (BOOL)*pBool;
    hres = _pbs->IsControlWindowShown(FCW_STATUS, &bValue);
    *pBool = TO_VARIANT_BOOL(bValue);
    return hres;
}

STDMETHODIMP CIEFrameAuto::put_StatusBar(VARIANT_BOOL Bool)
{
    HRESULT hres;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::put_StatusBar called _pbs==NULL");
        return E_FAIL;
    }

    _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);
    hres = _pbs->ShowControlWindow(FCW_STATUS, (BOOL)Bool);

    FireEvent_OnAdornment(_GetOuter(), DISPID_ONSTATUSBAR, Bool);

    return(hres);
}


STDMETHODIMP CIEFrameAuto::get_StatusText(BSTR * pbstr)
{
    HRESULT hr = E_FAIL;

    *pbstr = NULL;  // clear out in case of error...

    if (_pbs)
    {
        IShellBrowser *psb;
        hr = _pbs->QueryInterface(IID_PPV_ARG(IShellBrowser, &psb));
        if (SUCCEEDED(hr))
        {
            LRESULT ret;
            hr = psb->SendControlMsg(FCW_STATUS, SB_GETTEXTLENGTH, 0, 0, &ret);
            if (SUCCEEDED(hr))
            {
                ret++;     // #246956: We need to make 2 extra spaces for the end
                *pbstr = SysAllocStringLen(NULL, LOWORD(ret)+1); // ret doesn't include NULL in count
                if (*pbstr)
                {
                    hr = psb->SendControlMsg(FCW_STATUS, SB_GETTEXTW, 0, (LPARAM)(*pbstr), &ret);
                    if (FAILED(hr))
                    {
                        SysFreeString(*pbstr);
                        *pbstr = NULL;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            psb->Release();
        }
    }
    return hr;
}

STDMETHODIMP CIEFrameAuto::put_StatusText(BSTR bstr)
{
    if (_pbs==NULL) 
    {
        TraceMsg(DM_WARNING, "CIEA::put_StatusText called _pbs==NULL");
        return E_FAIL;
    }

    IShellBrowser *psb;
    HRESULT hres = _pbs->QueryInterface(IID_PPV_ARG(IShellBrowser, &psb));
    if (SUCCEEDED(hres))
    {
        hres = psb->SendControlMsg(FCW_STATUS, SB_SETTEXTW, 0, (LPARAM)bstr, NULL);
        psb->Release();
    }

    return hres;
}

STDMETHODIMP CIEFrameAuto::get_ToolBar(int * pBool)
{
    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::get_ToolBar called _pbs==NULL");
        return E_FAIL;
    }

    // Put the processing of this in the main Frame class
    BOOL fShown;
    HRESULT hres;

    *pBool = 0;
    if (SUCCEEDED(hres = _pbs->IsControlWindowShown(FCW_INTERNETBAR, &fShown)) && fShown)
        *pBool = 1;

    // Don't user hres of next call as this will fail on IE3 which does not
    // have a FCW_TOOLBAR control
    else if (SUCCEEDED(_pbs->IsControlWindowShown(FCW_TOOLBAR, &fShown)) && fShown)
        *pBool = 2;

    return hres;
}

STDMETHODIMP CIEFrameAuto::put_ToolBar(int Bool)
{
    HRESULT hres;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::put_Toolbar called _pbs==NULL");
        return E_FAIL;
    }

    _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);

    // Put the processing of this in the main Frame class
    _pbs->ShowControlWindow(FCW_TOOLBAR, (Bool == 2));

    hres = _pbs->ShowControlWindow(FCW_INTERNETBAR, ((Bool==1)||(Bool == VARIANT_TRUE)));

    FireEvent_OnAdornment(_GetOuter(), DISPID_ONTOOLBAR, Bool);

    return(hres);
}

STDMETHODIMP CIEFrameAuto::get_MenuBar(THIS_ VARIANT_BOOL * pbool)
{
    BOOL bValue;
    HRESULT hres;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::get_MenuBar called _pbs==NULL");
        return E_FAIL;
    }

    if (pbool==NULL)
        return E_INVALIDARG;

    // Put the processing of this in the main Frame class
    bValue = (BOOL)*pbool;
    hres = _pbs->IsControlWindowShown(FCW_MENUBAR, &bValue);
    *pbool = TO_VARIANT_BOOL(bValue);
    return hres;
}

STDMETHODIMP CIEFrameAuto::put_MenuBar(THIS_ VARIANT_BOOL mybool)
{
    HRESULT hres;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::put_MenuBar called _pbs==NULL");
        return E_FAIL;
    }

    _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);
    hres = _pbs->ShowControlWindow(FCW_MENUBAR, (BOOL)mybool);

    FireEvent_OnAdornment(_GetOuter(), DISPID_ONMENUBAR, mybool);

    return(hres);
}


//
// IWebBrowser2
//

HRESULT CIEFrameAuto::QueryStatusWB(OLECMDID cmdID, OLECMDF * pcmdf)
{
    if (_pmsc)
    {
        OLECMD rgcmd;
        HRESULT hr;

        rgcmd.cmdID = cmdID;
        rgcmd.cmdf = *pcmdf;

        hr = _pmsc->QueryStatus(NULL, 1, &rgcmd, NULL);

        *pcmdf = (OLECMDF) rgcmd.cmdf;

        return hr;
    }
    return (E_UNEXPECTED);
}
HRESULT CIEFrameAuto::ExecWB(OLECMDID cmdID, OLECMDEXECOPT cmdexecopt, VARIANT * pvaIn, VARIANT * pvaOut)
{
    if (_pmsc)
    {
        return _pmsc->Exec(NULL, cmdID, cmdexecopt, pvaIn, pvaOut);
    }
    return (E_UNEXPECTED);
}

STDMETHODIMP CIEFrameAuto::get_Offline(THIS_ VARIANT_BOOL * pbOffline)
{
    if (!pbOffline)
        return E_INVALIDARG;

    *pbOffline = TO_VARIANT_BOOL(m_bOffline);
    return S_OK;
}

void SendAmbientPropChange(IOleCommandTarget* pct, int prop)
{
    if (pct)
    {
        VARIANTARG VarArgIn;

        VarArgIn.vt = VT_I4;
        VarArgIn.lVal = prop;

        pct->Exec(&CGID_ShellDocView, SHDVID_AMBIENTPROPCHANGE, 0, &VarArgIn, NULL);
    }
}

STDMETHODIMP CIEFrameAuto::put_Offline(THIS_ VARIANT_BOOL bOffline)
{
    TraceMsg(TF_SHDAUTO, "Shell automation: CIEFrameAuto:put_Offline called");

    if ((m_bOffline && bOffline) || (!(m_bOffline || bOffline))) // The mode is not changing
        return S_OK;

    m_bOffline = bOffline ? TRUE : FALSE;

    // Let children know an ambient property may have changed
    //
    SendAmbientPropChange(_pmsc, DISPID_AMBIENT_OFFLINEIFNOTCONNECTED);

    return S_OK;
}


STDMETHODIMP CIEFrameAuto::get_Silent(THIS_ VARIANT_BOOL * pbSilent)
{
    if (!pbSilent)
        return E_INVALIDARG;
    *pbSilent = TO_VARIANT_BOOL(m_bSilent);
    return S_OK;
}

STDMETHODIMP CIEFrameAuto::put_Silent(THIS_ VARIANT_BOOL bSilent)
{
    TraceMsg(TF_SHDAUTO, "Shell automation: CIEFrameAuto:put_Silent called");

    if ((m_bSilent && bSilent) || (!(m_bSilent || bSilent))) // The mode is not changing
        return S_OK;

    m_bSilent = bSilent ? TRUE : FALSE;

    // Let children know an ambient property may have changed
    //
    SendAmbientPropChange(_pmsc, DISPID_AMBIENT_SILENT);

    return S_OK;
}


//
//  NOTE:  RegisterAsBrowser is a kind of a misnomer here - zekel 8-SEP-97
//  this is used for 3rd party apps to register the browser as being theirs,
//  and not being one of our default shell browsers to use and abuse at
//  our pleasure.  this keeps it out of the reusable winlist.  this fixes
//  the bug where our welcome.exe page gets reused on a shellexec.
//
HRESULT CIEFrameAuto::get_RegisterAsBrowser(VARIANT_BOOL * pbRegister)
{
    if (pbRegister)
    {
        *pbRegister = _fRegisterAsBrowser ? VARIANT_TRUE : VARIANT_FALSE;
        return S_OK;
    }

    return E_INVALIDARG;
}

HRESULT CIEFrameAuto::put_RegisterAsBrowser(VARIANT_BOOL bRegister)
{
    if (bRegister)
    {
        if (_pbs == NULL)    //Make sure we have a IBrowserService.
            return S_FALSE;

        _fRegisterAsBrowser = TRUE;
        _pbs->RegisterWindow(TRUE, SWC_3RDPARTY);
        return S_OK;
    }
    //
    //  we dont support a way to turn it off
    return E_FAIL;
}

HRESULT CIEFrameAuto::get_TheaterMode(VARIANT_BOOL * pbRegister)
{
    if (!pbRegister)
        return E_INVALIDARG;

    if (_pbs) {
        DWORD dw;
        _pbs->GetFlags(&dw);

        *pbRegister = TO_VARIANT_BOOL(dw & BSF_THEATERMODE);
        return S_OK;
    }
    // rgardner poor choice of return error code - need better error
    // This error puts of "undefined error" dialog
    return E_FAIL;
}

HRESULT CIEFrameAuto::put_TheaterMode(VARIANT_BOOL bRegister)
{
    if (_pbs) {
        _pbs->SetFlags(bRegister ? BSF_THEATERMODE : 0, BSF_THEATERMODE);
        return S_OK;
    }
    return S_FALSE;
}


HRESULT CIEFrameAuto::get_RegisterAsDropTarget(VARIANT_BOOL * pbRegister)
{
    if (!pbRegister)
        return E_INVALIDARG;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::get_RegisterAsDropTarget called _pbs==NULL");
        return E_FAIL;
    }

    DWORD dw;
    _pbs->GetFlags(&dw);

    *pbRegister = TO_VARIANT_BOOL(dw & BSF_REGISTERASDROPTARGET);

    return S_OK;
}
HRESULT CIEFrameAuto::put_RegisterAsDropTarget(VARIANT_BOOL bRegister)
{
    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::put_RegisterAsDropTarget called _pbs==NULL");
        return E_FAIL;
    }

    _pbs->SetFlags(bRegister ? BSF_REGISTERASDROPTARGET : 0, BSF_REGISTERASDROPTARGET);

    return S_OK;
}

HRESULT CIEFrameAuto::get_AddressBar(VARIANT_BOOL * pValue)
{
    BOOL bValue;
    HRESULT hres;

    if (!pValue)
        return E_INVALIDARG;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::get_AddressBar called _pbs==NULL");
        return E_FAIL;
    }

    // Put the processing of this in the main Frame class
    bValue = (BOOL)*pValue;

    hres = _pbs->IsControlWindowShown(FCW_ADDRESSBAR, &bValue);

    *pValue = TO_VARIANT_BOOL(bValue);

    return hres;
}

HRESULT CIEFrameAuto::put_AddressBar(VARIANT_BOOL Value)
{
    HRESULT hres;

    if (_pbs==NULL) {
        TraceMsg(DM_WARNING, "CIEA::put_AddressBar called _pbs==NULL");
        return E_FAIL;
    }

    _pbs->SetFlags(BSF_UISETBYAUTOMATION, BSF_UISETBYAUTOMATION);
    hres = _pbs->ShowControlWindow(FCW_ADDRESSBAR, (BOOL)Value);

    FireEvent_OnAdornment(_GetOuter(), DISPID_ONADDRESSBAR, Value);

    return(hres);
}

HRESULT CIEFrameAuto::get_Resizable(VARIANT_BOOL * pValue)
{
    HRESULT hres;
    DWORD   dw;

    if (!pValue)
        return E_INVALIDARG;

    if (_pbs==NULL)
    {
        TraceMsg(DM_WARNING, "CIEA::get_Resizable called _pbs==NULL");
        return E_FAIL;
    }

    hres = _pbs->GetFlags(&dw);

    *pValue = TO_VARIANT_BOOL (dw & BSF_RESIZABLE);
    return hres;
}

HRESULT CIEFrameAuto::put_Resizable(VARIANT_BOOL Value)
{
    HRESULT hres;

    if (_pbs==NULL)
    {
        TraceMsg(DM_WARNING, "CIEA::put_Resizable called _pbs==NULL");
        return E_FAIL;
    }

    hres = _pbs->SetFlags(
                Value ? (BSF_RESIZABLE | BSF_CANMAXIMIZE) : 0, 
                (BSF_RESIZABLE | BSF_CANMAXIMIZE));

    return hres ;
}


void UpdateBrowserReadyState(IUnknown * punk, DWORD dwReadyState)
{
    if (punk)
    {
        IDocNavigate *pdn;
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IDocNavigate, &pdn))))
        {
            pdn->OnReadyStateChange(NULL, dwReadyState);
            pdn->Release();
        }
    }
}

HRESULT CIEFrameAuto::put_DefaultReadyState(DWORD dwDefaultReadyState, BOOL fUpdateBrowserReadyState)
{
    _dwDefaultReadyState = dwDefaultReadyState;

    TraceMsg(TF_SHDNAVIGATE, "CIEA(%x)::psb(%x) new default ReadyState %d", this, _psb, dwDefaultReadyState);

    if (fUpdateBrowserReadyState)
    {
        UpdateBrowserReadyState(_psb, _dwDefaultReadyState);
    }

    return S_OK;
}

HRESULT CIEFrameAuto::OnDocumentComplete(void)
{
    TraceMsg(DM_FRAMEPROPERTY, "CIEFA::OnDocumentComplete called");
    DWORD dwCur = GetCurrentTime();
    VARIANT varEmpty = { 0 };

    if (dwCur - _dwTickPropertySweep > MSEC_PROPSWEEP) {
        TraceMsg(DM_FRAMEPROPERTY, "CIEFA::OnDocumentComplete start sweeping");
        for (CIEFrameAutoProp *pprop = _pProps; pprop;) {
            CIEFrameAutoProp* ppropNext = pprop->Next();
            if (pprop->IsExpired(dwCur)) {
                TraceMsg(DM_FRAMEPROPERTY, "CIEFA::OnDocumentComplete deleting an expired property");
                pprop->SetValue(&varEmpty, this);
            }
            pprop=ppropNext;
        }

        _dwTickPropertySweep = dwCur;
    }
    return S_OK;
}

HRESULT CIEFrameAuto::OnWindowsListMarshalled(void)
{
    _fWindowsListMarshalled = TRUE;
    return S_OK;
}

HRESULT CIEFrameAuto::SetDocHostFlags(DWORD dwDocHostFlags)
{
    _dwDocHostInfoFlags = dwDocHostFlags;
    return S_OK;
}

HRESULT CIEFrameAuto::get_ReadyState(READYSTATE * plReadyState)
{
    READYSTATE lReadyState = (READYSTATE)_dwDefaultReadyState;

    if (_psb)
    {
        IDocNavigate* pdn;
        if (SUCCEEDED(_psb->QueryInterface(IID_PPV_ARG(IDocNavigate, &pdn))))
        {
            pdn->get_ReadyState((LPDWORD)&lReadyState);
            pdn->Release();
        }
    }

    TraceMsg(TF_SHDNAVIGATE, "CIEA(%x)::psb(%x)->get_ReadyState returning %d", this, _psb, lReadyState);
    *plReadyState = lReadyState;
    return S_OK;
}

STDMETHODIMP CIEFrameAuto::get_TopLevelContainer(VARIANT_BOOL * pBool)
{
    *pBool = TRUE;
    return NOERROR;
}

STDMETHODIMP CIEFrameAuto::get_Type(BSTR * pbstrType)
{
    HRESULT hres = E_FAIL;
    *pbstrType = NULL;

    IShellView *psv;

    if (_psb && SUCCEEDED(hres = _psb->QueryActiveShellView(&psv)) && psv)
    {
        IOleObject *pobj;
        hres = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_PPV_ARG(IOleObject, &pobj));
        if (SUCCEEDED(hres))
        {
            LPOLESTR pwszUserType;
            hres = pobj->GetUserType(USERCLASSTYPE_FULL, &pwszUserType);
            if (hres == OLE_S_USEREG)
            {
                CLSID clsid;
                hres = pobj->GetUserClassID(&clsid);
                if (SUCCEEDED(hres))
                {
                    hres = OleRegGetUserType(clsid, USERCLASSTYPE_FULL, &pwszUserType);
                }
            }
            if (SUCCEEDED(hres) && pwszUserType)
            {
                *pbstrType = SysAllocString(pwszUserType);
                if (*pbstrType == NULL)
                {
                    hres = E_OUTOFMEMORY;
                }
                OleFree(pwszUserType);
            }
            pobj->Release();
        }
        psv->Release();
    }
    return hres;
}

HRESULT CIEFrameAuto::SetOwner(IUnknown* punkOwner)
{
    ATOMICRELEASE(_pbs);
    ATOMICRELEASE(_psp);
    ATOMICRELEASE(_psb);
    ATOMICRELEASE(_psbProxy);
    ATOMICRELEASE(_poctFrameTop);
    ATOMICRELEASE(_psbFrameTop);
    ATOMICRELEASE(_psbTop);
    ATOMICRELEASE(_pmsc);

    if (punkOwner)
    {
        //  Check if we're the desktop - if so, we do not act as
        //  parent frame to our children (desktop components)
        _fDesktopFrame = FALSE;

        IUnknown *punkDesktop;
        if (SUCCEEDED(punkOwner->QueryInterface(SID_SShellDesktop, (void **)&punkDesktop)))
        {
            _fDesktopFrame = TRUE;
            punkDesktop->Release();
        }

        punkOwner->QueryInterface(IID_PPV_ARG(IBrowserService, &_pbs));
        punkOwner->QueryInterface(IID_PPV_ARG(IShellBrowser, &_psb));

        UpdateBrowserReadyState(_psb, _dwDefaultReadyState);

        HRESULT hresT = punkOwner->QueryInterface(IID_PPV_ARG(IServiceProvider, &_psp));
        if (SUCCEEDED(hresT))
        {
            _psp->QueryService(SID_SShellBrowser,    IID_PPV_ARG(IOleCommandTarget, &_pmsc));
            _psp->QueryService(SID_STopLevelBrowser, IID_PPV_ARG(IShellBrowser, &_psbTop));
            _psp->QueryService(SID_STopFrameBrowser, IID_PPV_ARG(IShellBrowser, &_psbFrameTop));

            // this is the browser we should tell to navigate if we're asked to navigate
            _psp->QueryService(SID_SProxyBrowser, IID_PPV_ARG(IShellBrowser, &_psbProxy));
            if (!_psbProxy)
            {
                _psbProxy = _psb;
                _psbProxy->AddRef();
            }
            //  we use _poctFrameTop::Exec to set history selection pidl
            if (_psbFrameTop && _psbProxy == _psb)
            {
                _psbFrameTop->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_poctFrameTop));
            }

            // We should always have one of these -- used to notify of frame closing
            // and new window navigation.
            ASSERT(_psbTop);
            ASSERT(_psbFrameTop);

            // Since the desktop does not support IOleCommandTarget (intentionally)
            // _pmsc could be NULL. No need to RIP here.
            //
            // ASSERT(_pmsc);
        }

        ASSERT(_pbs);
        ASSERT(_psp);
        ASSERT(_psb);
    }
    else
    {
        _omwin.DeInit();
        //
        // We need to clear the property list here (than in the destructor)
        // to break the circular ref-count.
        //
        _ClearPropertyList();
    }

    return S_OK;
}

HRESULT CIEFrameAuto::SetOwnerHwnd(HWND hwndOwner)
{
    _hwnd = hwndOwner;
    return S_OK;
}
HWND CIEFrameAuto::_GetHWND()
{
    if (!_hwnd && _pbs)
    {
        IOleWindow * pow;
        if (SUCCEEDED(_pbs->QueryInterface(IID_PPV_ARG(IOleWindow, &pow))))
        {
            pow->GetWindow(&_hwnd);
            pow->Release();
        }
    }

    // people that call this assume that we always succeed
    //
    // ... people who call this better quit making incorrect
    // assumptions.  If we can't guarantee an hwnd the caller
    // can't assume they'll be getting one. (edwardp)
    if (_hwnd == NULL)
    {
        TraceMsg(DM_WARNING, "CIEA::_GetHWND returning NULL");
    }

    return _hwnd;
}


// *** IConnectionPointContainer ***

CConnectionPoint* CIEFrameAuto::_FindCConnectionPointNoRef(BOOL fdisp, REFIID iid)
{
    CConnectionPoint* pccp;

    // VB team claims its safe to fire new dispids to old event sinks.
    // This will cause a fault on an old event sink if they assumed
    // only the dispids in the old typelib would ever be fired and they
    // did no bounds checking and jumped into space. Let's trust the VB
    // team and see if we discover any poor event sinks.
    //
    // They also say we sould just extend our primary dispinterface instead
    // of replace it with an equivalent but different one. That approach
    // unfortunately leaves the offending bad event mechanism sit in
    // the VB programmer's face.
    //
    // I want to do three things:
    //   1. Change the primary dispinterface to see what headaches that causes.
    //      This has nice positives and its easy to change back later. (fdisp==TRUE case)
    //   2. Don't fire old events to consumers of the new dispinterface.
    //      This will flush out any compatability issues of containers
    //      connecting to the default dispinterface when they really
    //      wanted the old DIID.
    //   3. Do fire new events to old sinks. This will flush out any
    //      compatability issues with VBs theory.
    //
    // We can't do all three, so let's choose 1 and 2. We can
    // force 3 by randomly firing out-of-range dispids if this
    // is important...
    //
    if (IsEqualIID(iid, DIID_DWebBrowserEvents2) ||
        (fdisp && IsEqualIID(iid, IID_IDispatch)))
    {
        pccp = &m_cpWebBrowserEvents2;
    }
    else if (IsEqualIID(iid, DIID_DWebBrowserEvents))
    {
        pccp = &m_cpWebBrowserEvents;
    }
    else if (IsEqualIID(iid, IID_IPropertyNotifySink))
    {
        pccp = &m_cpPropNotify;
    }
    else
    {
        pccp = NULL;
    }

    return pccp;
}

STDMETHODIMP CIEFrameAuto::EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum)
{
    return CreateInstance_IEnumConnectionPoints(ppEnum, 3,
                m_cpWebBrowserEvents2.CastToIConnectionPoint(),
                m_cpWebBrowserEvents.CastToIConnectionPoint(),
                m_cpPropNotify.CastToIConnectionPoint());
}


//=============================================================================
// Our class factory
class CIEFrameClassFactory : public IClassFactory
{
public:
    CIEFrameClassFactory(IUnknown* punkAuto, REFCLSID clsid, UINT uFlags);

    // IUnKnown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory
    STDMETHODIMP CreateInstance(
            IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);

    // Helper functions...
    HRESULT CleanUpAutomationObject();
    void Revoke(void);

protected:
    ~CIEFrameClassFactory();

    LONG        _cRef;
    IUnknown   *_punkAuto;      // Only for the first one for the process
    DWORD       _dwRegister;    // The value returned from CoRegisterClassObject;
    UINT        _uFlags;        // extra COF_ bits to pass to our create browser window code
};


#define AssertParking() ASSERT(g_tidParking==0 || g_tidParking == GetCurrentThreadId())

#ifdef NO_MARSHALLING
EXTERN_C void IEFrameNewWindowSameThread(IETHREADPARAM* piei);
#endif

CIEFrameClassFactory::CIEFrameClassFactory(IUnknown* punkAuto, REFCLSID clsid, UINT uFlags)
        : _cRef(1), _dwRegister((DWORD)-1), _uFlags(uFlags)
{
    AssertParking();

    if (punkAuto)
    {
        _punkAuto = punkAuto;
        punkAuto->AddRef();
    }

    HRESULT hres = CoRegisterClassObject(clsid, this, CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER,
        REGCLS_MULTIPLEUSE, &_dwRegister);
    if (FAILED(hres))
    {
        _dwRegister = (DWORD)-1;
    }

    TraceMsg(TF_SHDLIFE, "ctor CIEFrameClassFactory %x", this);
}

CIEFrameClassFactory::~CIEFrameClassFactory()
{
    AssertParking();
    ASSERT(_dwRegister == (DWORD)-1);
    if (_punkAuto)
        _punkAuto->Release();

    TraceMsg(TF_SHDLIFE, "dtor CIEFrameClassFactory %x", this);
}

void CIEFrameClassFactory::Revoke(void)
{
    if (_dwRegister != (DWORD)-1)
    {
        CoRevokeClassObject(_dwRegister);
        _dwRegister = (DWORD)-1;
    }
}

HRESULT CIEFrameClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CIEFrameClassFactory, IClassFactory), // IID_IClassFactory
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CIEFrameClassFactory::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CIEFrameClassFactory::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

//
//  We call this function to clean up the automation object if something
// goes wrong and OLE did not pick it up. Under a normal circumstance,
// _punkAuto is supposed to be NULL.
//
HRESULT CIEFrameClassFactory::CleanUpAutomationObject()
{
    AssertParking();

    ASSERT(_punkAuto==NULL);

    ATOMICRELEASE(_punkAuto);

    return S_OK;
}

class IETHREADHANDSHAKE : public IEFreeThreadedHandShake
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(THIS_ REFIID riid, void ** ppvObj) { *ppvObj = NULL; return E_NOTIMPL; } // HACK: we're not a real com object
    STDMETHODIMP_(ULONG) AddRef(THIS);
    STDMETHODIMP_(ULONG) Release(THIS);

    // *** IIEFreeThreadedHandShake methods ***
    STDMETHODIMP_(void)   PutHevent(THIS_ HANDLE hevent) { _hevent = hevent; }
    STDMETHODIMP_(HANDLE) GetHevent(THIS) { return _hevent; }
    STDMETHODIMP_(void)    PutHresult(THIS_ HRESULT hres) { _hres = hres; }
    STDMETHODIMP_(HRESULT) GetHresult(THIS) { return _hres; }
    STDMETHODIMP_(IStream*) GetStream(THIS) { return _pstm; }

protected:
    LONG    _cRef;       // ref-count (must be thread safe)
    HANDLE  _hevent;
    IStream* _pstm;
    HRESULT _hres;       // result from CoMarshalInterface

    friend IEFreeThreadedHandShake* CreateIETHREADHANDSHAKE();

    IETHREADHANDSHAKE(HANDLE heventIn, IStream* pstmIn);
    ~IETHREADHANDSHAKE();
};

IETHREADHANDSHAKE::IETHREADHANDSHAKE(HANDLE heventIn, IStream* pstmIn)
    : _cRef(1), _hevent(heventIn), _pstm(pstmIn), _hres(E_FAIL)
{
    TraceMsg(TF_SHDLIFE, "ctor IETHREADHANDSHAKE %x", this);
    ASSERT(_hevent);
    ASSERT(_pstm);
    _pstm->AddRef();
}

IETHREADHANDSHAKE::~IETHREADHANDSHAKE()
{
    TraceMsg(TF_SHDLIFE, "dtor IETHREADHANDSHAKE %x", this);
    CloseHandle(_hevent);
    _pstm->Release();
}

ULONG IETHREADHANDSHAKE::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG IETHREADHANDSHAKE::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

IEFreeThreadedHandShake* CreateIETHREADHANDSHAKE()
{
    IEFreeThreadedHandShake* piehs = NULL;

    HANDLE hevent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (hevent)
    {
        IStream* pstm;
        HRESULT hres = CreateStreamOnHGlobal(NULL, TRUE, &pstm);
        if (SUCCEEDED(hres))
        {
            IETHREADHANDSHAKE* p = new IETHREADHANDSHAKE(hevent, pstm);
            if (p)
            {
                // this is free threaded, so we can't know which thread will free it.
                // technically our caller should do this, but we return an
                // interface and not the class itself...
                piehs = SAFECAST(p, IEFreeThreadedHandShake*);
            }
            
            pstm->Release();
        }

        if (!piehs)
            CloseHandle(hevent);
    }

    return piehs;
}

HRESULT CIEFrameClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
    HRESULT hres = E_FAIL;

    //
    // Check if this is the very first automation request.
    //
    if (_punkAuto && g_tidParking == GetCurrentThreadId())
    {
        //
        // Yes, return the first browser object.
        //
        hres = _punkAuto->QueryInterface(riid, ppvObject);

        // We don't want to return it twice.
        ATOMICRELEASE(_punkAuto);
    }
    else
    {
#ifndef NO_MARSHALLING
        //
        // No, create a new browser window in a new thread and
        // return a marshalled pointer.
        //
        hres = E_OUTOFMEMORY;
        IEFreeThreadedHandShake* piehs = CreateIETHREADHANDSHAKE();
        if (piehs)
        {
            IETHREADPARAM *piei = SHCreateIETHREADPARAM(NULL, SW_SHOWNORMAL, NULL, piehs);
            if (piei)
            {
                piei->uFlags |= (_uFlags | COF_CREATENEWWINDOW | COF_NOFINDWINDOW | COF_INPROC);

                DWORD idThread;
                HANDLE hthread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)SHOpenFolderWindow, piei, 0, &idThread);
                if (hthread)
                {
                    // Wait until either
                    //  (1) the thread is terminated
                    //  (2) the event is signaled (by the new thread)
                    //  (3) time-out
                    //
                    //  Note that we call MsgWaitForMultipleObjects
                    // to avoid dead lock in case the other thread
                    // sends a broadcast message to us (unlikely, but
                    // theoreticallly possible).
                    //
                    HANDLE ah[] = { piehs->GetHevent(), hthread };
                    DWORD dwStart = GetTickCount();
#define MSEC_MAXWAIT (30 * 1000)
                    DWORD dwWait = MSEC_MAXWAIT;
                    DWORD dwWaitResult;

                    do {
                        dwWaitResult = MsgWaitForMultipleObjects(ARRAYSIZE(ah), ah, FALSE,
                                dwWait, QS_SENDMESSAGE);
                        if (dwWaitResult == WAIT_OBJECT_0 + ARRAYSIZE(ah)) // msg input
                        {
                            // allow pending SendMessage() to go through
                            MSG msg;
                            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
                        }
                        else
                            break;  // signaled or timed out, exit the loop

                        // Update the dwWait. It will become larger
                        // than MSEC_MAXWAIT if we wait more than that.
                        dwWait = dwStart + MSEC_MAXWAIT - GetTickCount();

                    } while (dwWait <= MSEC_MAXWAIT);

                    switch (dwWaitResult)
                    {
                    default:
                        ASSERT(0);
                    case WAIT_OBJECT_0 + 1:
                        TraceMsg(DM_ERROR, "CIECF::CI thread terminated before signaling us"); // probably leak the IETHREADPARAM and IETHREADHANDSHAKE in this case
                        hres = E_FAIL;
                        break;

                    case WAIT_OBJECT_0 + ARRAYSIZE(ah): // msg input
                    case WAIT_TIMEOUT:
                        TraceMsg(DM_ERROR, "CIECF::CI time out");
                        hres = E_FAIL;
                        break;

                    case WAIT_OBJECT_0: // hevent signaled
                        hres = piehs->GetHresult();
                        if (SUCCEEDED(hres))
                        {
                            IStream* pstm = piehs->GetStream();
                            pstm->Seek(c_li0, STREAM_SEEK_SET, NULL);
                            hres = CoUnmarshalInterface(pstm, riid, ppvObject);
                        }
                        else
                            TraceMsg(DM_ERROR, "CIECF::CI piehs->hres has an error %x", hres);
                        break;
                    }
                    CloseHandle(hthread);
                }
                else
                {
                    SHDestroyIETHREADPARAM(piei);
                    hres = E_OUTOFMEMORY;
                }
            }
            else
            {
                hres = E_OUTOFMEMORY;
                TraceMsg(DM_ERROR, "CIECF::CI new IETHREADPARAM failed");
            }
            piehs->Release();
        }
#else // !NO_MARSHALLING

        //
        // Create a new window on the same thread
        //

        IEFreeThreadedHandShake* piehs = CreateIETHREADHANDSHAKE();
        if (piehs)
        {
            IETHREADPARAM* piei = SHCreateIETHREADPARAM(NULL, SW_SHOWNORMAL, NULL, piehs);
            if (piei)
                IEFrameNewWindowSameThread(piei);


            if (SUCCEEDED(piehs->GetHresult()))
            {
                IUnknown* punk;
                IStream * pstm = piehs->GetStream();

                if (pstm)
                {
                    ULONG pcbRead = 0;
                    pstm->Seek(c_li0, STREAM_SEEK_SET, NULL);
                    hres = pstm->Read(&punk, sizeof(punk), &pcbRead);
                    if (SUCCEEDED(hres))
                    {
                        hres = punk->QueryInterface(riid, ppvObject);
                        punk->Release();
                    }
                }
            }
            else
            {
                hres = piehs->GetHresult();
                TraceMsg(DM_ERROR, "CIECF::CI piehs->hres has an error %x", piehs->GetHresult());
            }
            piehs->Release();
        }
#endif // NO_MARSHALLING
    }
    return hres;
}

HRESULT CIEFrameClassFactory::LockServer(BOOL fLock)
{
    return S_OK;
}

BOOL Is98orEarlier()
{
    BOOL bRet = FALSE;
    OSVERSIONINFOA s_osvi;

    s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
    GetVersionExA(&s_osvi);
   
    bRet = s_osvi.dwPlatformId   == VER_PLATFORM_WIN32_WINDOWS && 
           s_osvi.dwMajorVersion == 4;

    return bRet;
}   

void GetEventURL(LPCITEMIDLIST pidl, LBSTR::CString & p_rstrPath)
{
    HRESULT hres = E_FAIL;

    if (pidl)
    {
        LPTSTR      pstrPath = p_rstrPath.GetBuffer(MAX_URL_STRING);

        if (p_rstrPath.GetAllocLength() < MAX_URL_STRING)
        {
            TraceMsg(TF_WARNING, "GetEventURL() - p_rstrPath Allocation Failed!");

            hres = E_OUTOFMEMORY;
        }
        else
        {
            hres = IEGetDisplayName(pidl, pstrPath, SHGDN_FORPARSING);

            // Let CString class own the buffer again.
            p_rstrPath.ReleaseBuffer();
        }

        if (FAILED(hres) && Is98orEarlier())
        {
            LBSTR::CString  strTempUrl;

            LPTSTR          pstrTempUrl = strTempUrl.GetBuffer(INTERNET_MAX_URL_LENGTH);

            if (strTempUrl.GetAllocLength() < INTERNET_MAX_URL_LENGTH)
            {
                TraceMsg(TF_WARNING, "GetEventURL() - strTempUrl Allocation Failed!");

                hres = E_OUTOFMEMORY;
            }
            else
            {
                hres = IEGetDisplayName(pidl, pstrTempUrl, SHGDN_NORMAL);

                // Let CString class own the buffer again.
                strTempUrl.ReleaseBuffer();
            }

            if (SUCCEEDED(hres))
            {
                LPTSTR  pFoundStr = NULL;
                BOOL    bNotMachineName = FALSE;

                pFoundStr = StrChr(strTempUrl, _T(':'));

                if (pFoundStr)
                {
                    bNotMachineName = TRUE;
                }
                else if ((strTempUrl[0] == _T('\\')) ||
                         (strTempUrl[0] == _T('/')))
                {
                    bNotMachineName = TRUE;
                }   

                if (bNotMachineName)
                {
                    p_rstrPath = strTempUrl;
                }
                else
                {
                    p_rstrPath = _T("\\\\") + strTempUrl;
                }
            }
        }
    }

    if (FAILED(hres))
    {
        p_rstrPath.Empty();
    }
}


HRESULT GetWBConnectionPoints(IUnknown* punk, IConnectionPoint **ppccp1, IConnectionPoint **ppccp2);
HRESULT GetTopWBConnectionPoints(IUnknown* punk, IConnectionPoint **ppccpTop1, IConnectionPoint **ppccpTop2)
{
    HRESULT hres = E_FAIL;

    if (ppccpTop1)
        *ppccpTop1 = NULL;
    if (ppccpTop2)
        *ppccpTop2 = NULL;


    IServiceProvider *pspSB;
    if (punk && SUCCEEDED(IUnknown_QueryService(punk, SID_STopFrameBrowser, IID_PPV_ARG(IServiceProvider, &pspSB))))
    {
        IWebBrowser2 *pwb;
        if (SUCCEEDED(pspSB->QueryService(SID_SInternetExplorer, IID_PPV_ARG(IWebBrowser2, &pwb))))
        {
            // We only want the toplevel interfaces if we're a frameset
            //
            if (!IsSameObject(punk, pwb))
            {
                hres = GetWBConnectionPoints(pwb, ppccpTop1, ppccpTop2);
            }

            pwb->Release();
        }
        pspSB->Release();
    }

    return hres;
}

// Fires a NavigateComplete (DISPID_NAVIGATECOMPLETE)
// event to container if there are any advise sinks

void FireEvent_NavigateComplete(IUnknown* punk, IWebBrowser2* pwb2, LPCITEMIDLIST pidl, HWND hwnd)
{
    IConnectionPoint* pcp1 = NULL;
    IConnectionPoint* pcpTopWBEvt2 = NULL;
    IConnectionPoint* pcpWBEvt2    = NULL;

    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.
    //

    LBSTR::CString      strPath;

    GetEventURL(pidl, strPath);

    //
    // Notify IEDDE of navigate complete.
    //
    IEDDE_AfterNavigate(strPath, hwnd);

    // Fire NavigateComplete2 off the parent and top-level frames.
    // We only fire [Frame]NavigateComplete off the top-level
    // frame for backward compatibility.
    //
    GetTopWBConnectionPoints(punk, &pcp1, &pcpTopWBEvt2);

    DISPID dispid = pcp1 ? DISPID_FRAMENAVIGATECOMPLETE : DISPID_NAVIGATECOMPLETE;

    GetWBConnectionPoints(punk, pcp1 ? NULL : &pcp1, &pcpWBEvt2);

    if (pcpTopWBEvt2 || pcpWBEvt2)
    {
        VARIANT vURL = {0};
        BOOL    bSysAllocated = FALSE;

        // If IEGetDisplayName above failed, pack the PIDL in the variant
        //

        // Try to keep OLEAUT32 unloaded if possible.
        //

        V_VT(&vURL) = VT_BSTR;

        // If OLEAUT32 is already loaded
        if (GetModuleHandle(TEXT("OLEAUT32.DLL")))
        {
            // then do the SysAllocString
            V_BSTR(&vURL) = SysAllocString(strPath);
            // What happens if this comes back NULL?
            bSysAllocated = TRUE;
        }
        else
        {
            // else use the stack version
            V_BSTR(&vURL) = strPath;
        }

        TraceMsg(TF_SHDCONTROL, "Event: NavigateComplete2[%ls]", strPath);

        // Fire the event to the parent first and then the top-level object.
        // For symmetry we fire NavigateComplete2 packed as a Variant.
        //
        if (pcpWBEvt2)
        {
            DoInvokeParamHelper(punk, pcpWBEvt2, NULL, NULL, DISPID_NAVIGATECOMPLETE2, 2,
                                VT_DISPATCH, pwb2,
                                VT_VARIANT|VT_BYREF, &vURL);

            ATOMICRELEASE(pcpWBEvt2);
        }

        if (pcpTopWBEvt2)
        {
            DoInvokeParamHelper(punk, pcpTopWBEvt2, NULL, NULL, DISPID_NAVIGATECOMPLETE2, 2,
                                VT_DISPATCH, pwb2,
                                VT_VARIANT|VT_BYREF, &vURL);

            ATOMICRELEASE(pcpTopWBEvt2);
        }

        // Since we pass the BSTR in a VT_VARIANT|VT_BYREF, OLEAUT32 might have freed and reallocated it.
        //
        ASSERT(V_VT(&vURL) == VT_BSTR);
        if (bSysAllocated)
        {
            SysFreeString(V_BSTR(&vURL));
        }
    }

    if (pcp1)
    {
        //
        // Compuserve History manager compatability: Don't fire NavigateComplete if it's a javascript:
        // or vbscript: URL.
        //
        if (GetUrlSchemeW(strPath) != URL_SCHEME_JAVASCRIPT &&
            GetUrlSchemeW(strPath) != URL_SCHEME_VBSCRIPT)
        {
            // IE3 did not fire on NULL pidl
            if (pidl)
            {
                TraceMsg(TF_SHDCONTROL, "Event: NavigateComplete[%ls]", strPath);

                // call DoInvokeParam to package up parameters and call
                // IDispatch::Invoke on the container.
                //
                // This pseudo-BSTR is passed as a straight BSTR so doesn't need to be SysAllocString'ed.
                //
                DoInvokeParamHelper(punk, pcp1, NULL, NULL, dispid, 1, VT_BSTR, strPath);
            }
        }

        ATOMICRELEASE(pcp1);
    }

}

void FireEvent_DocumentComplete(IUnknown* punk, IWebBrowser2* pwb2, LPCITEMIDLIST pidl)
{
    IConnectionPoint* pcpTopWBEvt2 = NULL;
    IConnectionPoint* pcpWBEvt2    = NULL;

    // TODO: (mwatt) Investigate why we are occasionally getting bogus DocumentComplete events 
    // with null disp pointers.
    
    if (!punk)
    {
        return;
    }

    LBSTR::CString      strPath;

    GetEventURL(pidl, strPath);

    // Fire DocumentComplete off the parent and top-level frames.
    //
    GetTopWBConnectionPoints(punk, NULL, &pcpTopWBEvt2);
    GetWBConnectionPoints(punk, NULL, &pcpWBEvt2);

    if (pcpTopWBEvt2 || pcpWBEvt2)
    {
        VARIANT vURL = {0};
        BOOL    bSysAllocated = FALSE;

        // If IEGetDisplayName above failed, pack the PIDL in the variant
        //

        // Try to keep OLEAUT32 unloaded if possible.
        //

        V_VT(&vURL) = VT_BSTR;

        // If OLEAUT32 is already loaded
        if (GetModuleHandle(TEXT("OLEAUT32.DLL")))
        {
            // then do the SysAllocString
            V_BSTR(&vURL) = SysAllocString(strPath);
            bSysAllocated = TRUE;
        }
        else
        {
            // else use the stack version
            V_BSTR(&vURL) = strPath;
        }

        // Fire the event to the parent first and then the top-level object.
        //
        if (pcpWBEvt2)
        {
            DoInvokeParamHelper(punk, pcpWBEvt2, NULL, NULL, DISPID_DOCUMENTCOMPLETE, 2,
                                VT_DISPATCH, pwb2,
                                VT_VARIANT|VT_BYREF, &vURL);

            ATOMICRELEASE(pcpWBEvt2);
        }

        if (pcpTopWBEvt2)
        {
            DoInvokeParamHelper(punk, pcpTopWBEvt2, NULL, NULL, DISPID_DOCUMENTCOMPLETE, 2,
                                VT_DISPATCH, pwb2,
                                VT_VARIANT|VT_BYREF, &vURL);

            ATOMICRELEASE(pcpTopWBEvt2);
        }

        // Since we pass the BSTR in a VT_VARIANT|VT_BYREF, OLEAUT32 might have freed and reallocated it.
        //
        ASSERT(V_VT(&vURL) == VT_BSTR);
        if (bSysAllocated)
        {
            SysFreeString(V_BSTR(&vURL));
        }
    }

    IEFrameAuto* pief;
    if (SUCCEEDED(pwb2->QueryInterface(IID_PPV_ARG(IEFrameAuto, &pief)))) 
    {
        pief->OnDocumentComplete();
        pief->Release();
    }
}

void AllocEventStuff(LPCTSTR pszFrameName, BSTR * pbstrFrameName,
                     LPCTSTR pszHeaders, BSTR * pbstrHeaders,
                     LPBYTE pPostData, DWORD cbPostData, VARIANTARG * pvaPostData)
{
    SAFEARRAY * psaPostData = NULL;

    // allocate BSTRs for frame name, headers
    *pbstrFrameName = NULL;
    if (pszFrameName && pszFrameName[0])
    {
        *pbstrFrameName = SysAllocStringT(pszFrameName);
    }

    *pbstrHeaders = NULL;
    if (pszHeaders && pszHeaders[0])
    {
        *pbstrHeaders = SysAllocStringT(pszHeaders);
    }

    if (pPostData && cbPostData) {
        // make a SAFEARRAY for post data
        psaPostData = MakeSafeArrayFromData(pPostData,cbPostData);
    }

    // put the post data SAFEARRAY into a variant so we can pass through automation
    VariantInit(pvaPostData);
    if (psaPostData) {
        pvaPostData->vt = VT_ARRAY | VT_UI1;
        pvaPostData->parray = psaPostData;
    }
}
void FreeEventStuff(BSTR bstrFrameName, BSTR bstrHeaders, VARIANTARG * pvaPostData)
{
    // free the things we allocated
    if (bstrFrameName)
        SysFreeString(bstrFrameName);

    if (bstrHeaders)
        SysFreeString(bstrHeaders);

    if (pvaPostData->parray)
    {
        ASSERT(pvaPostData->vt == (VT_ARRAY | VT_UI1));
        VariantClearLazy(pvaPostData);
    }
}

/*******************************************************************

    NAME:       FireEvent_BeforeNavigate

    SYNOPSIS:   Fires a BeforeNavigate (DISPID_BEFORENAVIGATE) event to container
                if there are any advise sinks

    NOTES:      If the container wants to cancel this navigation,
                it fills in pfCancel with TRUE and we should cancel.

********************************************************************/
void FireEvent_BeforeNavigate(IUnknown* punk, HWND hwnd, IWebBrowser2* pwb2,
        LPCITEMIDLIST pidl,LPCWSTR pwzLocation,
        DWORD dwFlags,LPCTSTR pszFrameName,LPBYTE pPostData,
        DWORD cbPostData,LPCTSTR pszHeaders,BOOL * pfProcessedInOut)
{
    HRESULT hres = E_FAIL;
    IConnectionPoint* pcpTopWBEvt1 = NULL;
    IConnectionPoint* pcpTopWBEvt2 = NULL;
    IConnectionPoint* pcpWBEvt2    = NULL;
    BSTR bstrFrameName = NULL;
    BSTR bstrHeaders = NULL;
    VARIANTARG vaPostData;

    ASSERT(pfProcessedInOut);

    //
    // HACKHACK (5.5 bug#98986) for fault caused by FrontPage indexing
    //   past the end of this bool (instead of V_BOOLREF, they
    //   use V_VARIANTREF->boolVal (CIEControl::XEventSink::Invoke))
    //   and trashing our stack.
    //  This has been entered as a bug for Office10, the contact
    //  is TCrowley our PM is KamV.  (marcmill 1/04/2000)
    //
    union tagFrontPageHack {
        BOOL    fCancel;
        VARIANT varBogus;
    } CancelHack = { 0 };
    
    BOOL *pfProcessed = &CancelHack.fCancel;

    // We start with "unprocessed"
    //    
    ASSERT(*pfProcessed == FALSE);

    // Build the URL name
    //
    
    LBSTR::CString      strPath;

    GetEventURL(pidl, strPath);

    // Fire BeforeNavigate2 off the parent and top-level frames.
    // We only fire [Frame]BeforeNavigate off the top-level
    // frame for backward compatibility.
    //
    GetTopWBConnectionPoints(punk, &pcpTopWBEvt1, &pcpTopWBEvt2);

    DISPID dispid = pcpTopWBEvt1 ? DISPID_FRAMEBEFORENAVIGATE : DISPID_BEFORENAVIGATE;

    GetWBConnectionPoints(punk, pcpTopWBEvt1 ? NULL : &pcpTopWBEvt1, &pcpWBEvt2);

    // Our caller couldn't pass in the proper IExpDispSupport since
    // it may have been aggregated. We do the QI here. Only call
    // AllocEventStuff if we really are going to fire an event.
    //
    if (pcpTopWBEvt1 || pcpTopWBEvt2 || pcpWBEvt2)
    {
        AllocEventStuff(pszFrameName, &bstrFrameName, pszHeaders, &bstrHeaders, pPostData, cbPostData, &vaPostData);
    }

    // We fire BeforeNavigate2 before DDE because whoever created us may
    // redirect this navigate by cancelling and trying again. DDE will get
    // notified on the redirected Navigate. IE3 didn't do it this way,
    // so fire the BeforeNavigate event last...
    //
    if (pcpTopWBEvt2 || pcpWBEvt2)
    {
        // For symmetry we pack everything in variants
        //
        // If FAILED(hresGDN) then pack URL as PIDL, not BSTR
        //
        BOOL bSysAllocated = FALSE;

        VARIANT vURL = {0};
        V_VT(&vURL) = VT_BSTR;

        if (GetModuleHandle(TEXT("OLEAUT32.DLL")))
        {
            // then do the SysAllocString
            V_BSTR(&vURL) = SysAllocString(strPath);
            bSysAllocated = TRUE;
        }
        else
        {
            // else use the stack version
            V_BSTR(&vURL) = strPath;
        }

        VARIANT vFlags = {0};
        V_VT(&vFlags) = VT_I4;
        V_I4(&vFlags) = dwFlags;

        VARIANT vFrameName = {0};
        V_VT(&vFrameName) = VT_BSTR;
        V_BSTR(&vFrameName) = bstrFrameName;

        VARIANT vPostData = {0};
        V_VT(&vPostData) = VT_VARIANT | VT_BYREF;
        V_VARIANTREF(&vPostData) = &vaPostData;

        VARIANT vHeaders = {0};
        V_VT(&vHeaders) = VT_BSTR;
        V_BSTR(&vHeaders) = bstrHeaders;

        TraceMsg(TF_SHDCONTROL, "Event: BeforeNavigate2[%ls]", strPath);

        // Fire the event ot the parent first and then the top-level object.
        //
        if (pcpWBEvt2)
        {
            DoInvokeParamHelper(punk, pcpWBEvt2, pfProcessed, NULL, DISPID_BEFORENAVIGATE2, 7,
                                VT_DISPATCH, pwb2,
                                VT_VARIANT | VT_BYREF, &vURL,
                                VT_VARIANT | VT_BYREF, &vFlags,
                                VT_VARIANT | VT_BYREF, &vFrameName,
                                VT_VARIANT | VT_BYREF, &vPostData,
                                VT_VARIANT | VT_BYREF, &vHeaders,
                                VT_BOOL    | VT_BYREF, pfProcessed);
        }

        // Only continue if the parent object didn't cancel.
        //
        if (pcpTopWBEvt2 && !*pfProcessed)
        {
            DoInvokeParamHelper(punk, pcpTopWBEvt2, pfProcessed, NULL, DISPID_BEFORENAVIGATE2, 7,
                                VT_DISPATCH, pwb2,
                                VT_VARIANT | VT_BYREF, &vURL,
                                VT_VARIANT | VT_BYREF, &vFlags,
                                VT_VARIANT | VT_BYREF, &vFrameName,
                                VT_VARIANT | VT_BYREF, &vPostData,
                                VT_VARIANT | VT_BYREF, &vHeaders,
                                VT_BOOL    | VT_BYREF, pfProcessed);
        }

        if (bSysAllocated)
        {
            SysFreeString(V_BSTR(&vURL));
        }

        bstrFrameName = V_BSTR(&vFrameName);
        bstrHeaders = V_BSTR(&vHeaders);
    }
    if (*pfProcessed)
        goto Exit;

    //
    // NOTE: IE3 called the IEDDE hook before BeforeNavigate.
    //
    IEDDE_BeforeNavigate(strPath, pfProcessed);
    if (*pfProcessed)
        goto Exit;

    //
    // Compuserve History manager compatability: Don't fire BeforeNavigate if it's a javascript:
    // or vbscript: URL.
    //
    if (pcpTopWBEvt1
        && GetUrlSchemeW(strPath) != URL_SCHEME_JAVASCRIPT
        && GetUrlSchemeW(strPath) != URL_SCHEME_VBSCRIPT)
    {
        TraceMsg(TF_SHDCONTROL, "Event: BeforeNavigate[%ls]", strPath);

        // call DoInvokeParam to package up these parameters and call
        // IDispatch::Invoke on the container.
        DoInvokeParamHelper(punk, pcpTopWBEvt1, pfProcessed,NULL, dispid, 6,
                     VT_BSTR, strPath, // URL
                     VT_I4, dwFlags,       // flags
                     VT_BSTR, bstrFrameName,  // target frame name
                     VT_VARIANT | VT_BYREF, &vaPostData,  // post data
                     VT_BSTR, bstrHeaders,  // headers
                     VT_BOOL | VT_BYREF, pfProcessed); // BOOL * for indicating "processed"
    }

Exit:
    *pfProcessedInOut = *pfProcessed;  // HACK for FrontPage -- see above for details
    
    if (pcpTopWBEvt1 || pcpTopWBEvt2 || pcpWBEvt2)
    {
        FreeEventStuff(bstrFrameName, bstrHeaders, &vaPostData);

        ATOMICRELEASE(pcpTopWBEvt1);
        ATOMICRELEASE(pcpTopWBEvt2);
        ATOMICRELEASE(pcpWBEvt2);
    }
}

/*******************************************************************

    NAME:       FireEvent_NavigateError

    SYNOPSIS:   Fires a NavigateError (DISPID_NAVIGATEERROR) event 
                to the container if there are any advise sinks

    NOTES:      If the container wants to cancel 
                autosearch and friendly error pages,
                it fills in pfCancel with TRUE and we should cancel.

********************************************************************/

void FireEvent_NavigateError(IUnknown     * punk, 
                             IWebBrowser2 * pwb2,
                             LPCITEMIDLIST  pidl,
                             BSTR           bstrTargetFrameName,
                             DWORD          dwStatusCode,
                             BOOL         * pfCancel)
       
{
    // If we find that the dwStatusCode can legally be 0,
    // we should just return from this method and not
    // fire the event. dwStatusCode == 0 implies no error.
    //
    ASSERT(dwStatusCode != 0);

    BSTR bstrFrameName = NULL;

    if (bstrTargetFrameName && bstrTargetFrameName[0])
    {
        bstrFrameName = SysAllocStringT(bstrTargetFrameName);
    }

    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.

    IConnectionPoint * pcpTopWBEvt2 = NULL;
    IConnectionPoint * pcpWBEvt2    = NULL;

    *pfCancel = FALSE;

    // Fire event off the parent and top-level frames.
    //
    GetTopWBConnectionPoints(punk, NULL, &pcpTopWBEvt2);
    GetWBConnectionPoints(punk, NULL, &pcpWBEvt2);

    // Need to convert the URL to version that matches BN2

    LBSTR::CString      strPath;

    BOOL    bSysAllocated = FALSE;

    GetEventURL(pidl, strPath);

    VARIANT vTargetURL = {0};
    V_VT(&vTargetURL) = VT_BSTR;

    if (GetModuleHandle(TEXT("OLEAUT32.DLL")))
    {
        // then do the SysAllocString
        V_BSTR(&vTargetURL) = SysAllocString(strPath);

        bSysAllocated = TRUE;
    }
    else
    {
        // else use the stack version
        V_BSTR(&vTargetURL) = strPath;
    }

    VARIANT vStatusCode = {0};
    V_VT(&vStatusCode) = VT_I4;
    V_I4(&vStatusCode) = dwStatusCode;

    VARIANT vTargetFrame  = {0};
    V_VT(&vTargetFrame)   = VT_BSTR;
    V_BSTR(&vTargetFrame) = bstrFrameName;

    // Fire the event to the parent first and then the top-level object.
    //
    if (pcpWBEvt2)
    {
        DoInvokeParamHelper(punk, pcpWBEvt2, NULL, NULL, DISPID_NAVIGATEERROR, 5,
                            VT_DISPATCH, pwb2,
                            VT_VARIANT | VT_BYREF, &vTargetURL,
                            VT_VARIANT | VT_BYREF, &vTargetFrame,
                            VT_VARIANT | VT_BYREF, &vStatusCode,
                            VT_BOOL | VT_BYREF, pfCancel);

        ATOMICRELEASE(pcpWBEvt2);
    }

    if (pcpTopWBEvt2)
    {
        DoInvokeParamHelper(punk, pcpTopWBEvt2, NULL, NULL, DISPID_NAVIGATEERROR, 5,
                            VT_DISPATCH, pwb2,
                            VT_VARIANT | VT_BYREF, &vTargetURL,
                            VT_VARIANT | VT_BYREF, &vTargetFrame,
                            VT_VARIANT | VT_BYREF, &vStatusCode,
                            VT_BOOL | VT_BYREF, pfCancel);

        ATOMICRELEASE(pcpTopWBEvt2);
    }

    if (bSysAllocated)
    {
        SysFreeString(V_BSTR(&vTargetURL));
    }
    
    bstrFrameName = V_BSTR(&vTargetFrame);

    if (bstrFrameName)
    {
        SysFreeString(bstrFrameName);
    }
}

/*******************************************************************

    NAME:       FireEvent_PrintTemplateEvent

    SYNOPSIS:   Fires a PrintTemplateInstantiation (DISPID_PRINTTEMPLATEINSTANTIATION) or
                a PrintTemplateTeardown (DISPID_PRINTTEMPLATETEARDOWN) event to container
                if there are any advise sinks

********************************************************************/

void FireEvent_PrintTemplateEvent(IUnknown* punk, IWebBrowser2* pwb2, DISPID dispidPrintEvent) 
{
    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.

    IConnectionPoint* pcpTopWBEvt2 = NULL;
    IConnectionPoint* pcpWBEvt2    = NULL;

    // Fire the event off the parent and top-level frames.
    //
    GetTopWBConnectionPoints(punk, NULL, &pcpTopWBEvt2);
    GetWBConnectionPoints(punk, NULL, &pcpWBEvt2);

    // Fire the event to the parent first and then the top-level object.
    //
    if (pcpWBEvt2)
    {
        DoInvokeParamHelper(punk, pcpWBEvt2, NULL, NULL, dispidPrintEvent, 1,
                            VT_DISPATCH, pwb2);

        ATOMICRELEASE(pcpWBEvt2);
    }

    if (pcpTopWBEvt2)
    {
        DoInvokeParamHelper(punk, pcpTopWBEvt2, NULL, NULL, dispidPrintEvent, 1,
                            VT_DISPATCH, pwb2);

        ATOMICRELEASE(pcpTopWBEvt2);
    }
}

/*******************************************************************

    NAME:       FireEvent_UpdatePageStatus

    SYNOPSIS:   Fires a UpdatePageStatus (DISPID_UPDATEPAGESTATUS) 
                event to container
                if there are any advise sinks

********************************************************************/

void FireEvent_UpdatePageStatus(IUnknown* punk, IWebBrowser2* pwb2, DWORD nPage, BOOL fDone)
{
    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.

    IConnectionPoint* pcpTopWBEvt2 = NULL;
    IConnectionPoint* pcpWBEvt2    = NULL;

    // Fire the event off the parent and top-level frames.
    //
    GetTopWBConnectionPoints(punk, NULL, &pcpTopWBEvt2);
    GetWBConnectionPoints(punk, NULL, &pcpWBEvt2);

    VARIANT vnPage = {0};
    V_VT(&vnPage)  = VT_I4;
    V_I4(&vnPage)  = nPage;

    VARIANT vfDone  = {0};
    V_VT(&vfDone)   = VT_BOOL;
    V_BOOL(&vfDone) = fDone;

    // Fire the event to the parent first and then the top-level object.
    //
    if (pcpWBEvt2)
    {
        DoInvokeParamHelper(punk, pcpWBEvt2, NULL, NULL, DISPID_UPDATEPAGESTATUS, 3,
                            VT_DISPATCH, pwb2,
                            VT_VARIANT|VT_BYREF, &vnPage,
                            VT_VARIANT|VT_BYREF, &vfDone);

        ATOMICRELEASE(pcpWBEvt2);
    }

    if (pcpTopWBEvt2)
    {
        DoInvokeParamHelper(punk, pcpTopWBEvt2, NULL, NULL, DISPID_UPDATEPAGESTATUS, 3,
                            VT_DISPATCH, pwb2,
                            VT_VARIANT|VT_BYREF, &vnPage,
                            VT_VARIANT|VT_BYREF, &vfDone);

        ATOMICRELEASE(pcpTopWBEvt2);
    }
}

/*******************************************************************

    NAME:       FireEvent_PrivacyImpactedStateChange

    SYNOPSIS:   Fires the privacy PrivacyImpactedStateChange event 
                to container if there are any advise sinks

********************************************************************/

void FireEvent_PrivacyImpactedStateChange(IUnknown* punk, BOOL bPrivacyImpacted)
{
    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.

    IConnectionPoint* pcpTopWBEvt2 = NULL;

    //
    // Typically most events fire at the frame or both at frame and top level
    // Since we want to fire at the top level only we just call 
    // GetWBConnectionPoints instead of GetTopWBConnectionPoints  here
    // since we always get passed in the punk for the top level
    // GetTopWBConnectionPoints returns the event interfaces ONLY
    // in a frameset scenario anyway.
    //
    GetWBConnectionPoints(punk, NULL, &pcpTopWBEvt2);

    if (pcpTopWBEvt2)
    {
        DoInvokeParamHelper(punk, pcpTopWBEvt2, NULL, NULL, DISPID_PRIVACYIMPACTEDSTATECHANGE, 1,
                            VT_BOOL, bPrivacyImpacted);

        ATOMICRELEASE(pcpTopWBEvt2);
    }
}

/*******************************************************************

    NAME:       FireEvent_NewWindow

    SYNOPSIS:   Fires an NewWindow (DISPID_NEWWINDOW) event to container
                if there are any advise sinks

    NOTES:      If the container wants to handle new window creation itself,
                pfProcessed is filled in with TRUE on exit and we should not
                create a new window ourselves.

********************************************************************/
void FireEvent_NewWindow(IUnknown* punk, HWND hwnd,
        LPCITEMIDLIST pidl,LPWSTR pwzLocation,
        DWORD dwFlags,LPTSTR pszFrameName,LPBYTE pPostData,
        DWORD cbPostData,LPTSTR pszHeaders,BOOL * pfProcessed)
{
    LBSTR::CString      strPath;

    GetEventURL(pidl, strPath);

    *pfProcessed = FALSE;

    IEDDE_BeforeNavigate(strPath, pfProcessed);
    if (*pfProcessed)
        return;

    // We fire [Frame]NewWindow off the top frame only
    //
    // NOTE: This will break anyone watching navigations within a frameset...
    //       Do we care?
    //
    IConnectionPoint *pccp;
    DISPID dispid = 0;  // init to suppress bogus C4701 warning

    if (S_OK == GetTopWBConnectionPoints(punk, &pccp, NULL))
        dispid = DISPID_FRAMENEWWINDOW;
    else if (S_OK == GetWBConnectionPoints(punk, &pccp, NULL))
        dispid = DISPID_NEWWINDOW;
    if (pccp)
    {
        BSTR bstrFrameName, bstrHeaders;
        VARIANTARG vaPostData;

        AllocEventStuff(pszFrameName, &bstrFrameName, pszHeaders, &bstrHeaders, pPostData, cbPostData, &vaPostData);

        if (pidl != NULL)
        {
            // call DoInvokeParam to package up these parameters and call
            // IDispatch::Invoke on the container.
            DoInvokeParamHelper(punk, pccp, pfProcessed, NULL, dispid, 6,
                         VT_BSTR, strPath,      // URL
                         VT_I4, dwFlags,       // flags
                         VT_BSTR, bstrFrameName,  // target frame name
                         VT_VARIANT | VT_BYREF, &vaPostData,  // post data
                         VT_BSTR, bstrHeaders,  // headers
                         VT_BOOL | VT_BYREF, pfProcessed); // BOOL * for indicating "processed"

        }

        FreeEventStuff(bstrFrameName, bstrHeaders, &vaPostData);

        pccp->Release();
    }

    return;
}

void FireEvent_NewWindow2(IUnknown* punk, IUnknown** ppunkNewWindow, BOOL *pfCancel)
{
    IConnectionPoint* pcpTopWBEvt2 = NULL;
    IConnectionPoint* pcpWBEvt2    = NULL;

    *pfCancel = FALSE;
    *ppunkNewWindow = NULL;

    // Fire NewWindow2 off the parent and top-level frames.
    // We only fire [Frame]NewWindow off the top-level
    // frame for backward compatibility.
    //
    GetTopWBConnectionPoints(punk, NULL, &pcpTopWBEvt2);
    GetWBConnectionPoints(punk, NULL, &pcpWBEvt2);

    if (pcpTopWBEvt2 || pcpWBEvt2)
    {
        //
        //  The AOL browser wants to override the behavior of "Open in New Window"
        //  so it opens a new AOL window instead of a new IE window.  They do this by
        //  responding to this message by creating the AOL window and putting its
        //  IUnknown into *ppunkNewWindow.
        //  Fire the event to the parent and then the top-level window. The
        //  pfCancel and ppunkNewWindow returned by the parent override the ones
        //  returned by the top-level window.
        //
        if (pcpWBEvt2)
        {
            DoInvokeParamHelper(punk, pcpWBEvt2, pfCancel, (void **)ppunkNewWindow, DISPID_NEWWINDOW2, 2,
                                VT_DISPATCH|VT_BYREF, ppunkNewWindow,
                                VT_BOOL    |VT_BYREF, pfCancel);
        }

        // If the parent object cancels or specifies a new window,
        // don't fire the event to the top-level object.
        //
        if (pcpTopWBEvt2 && !*pfCancel && !*ppunkNewWindow)
        {
            DoInvokeParamHelper(punk, pcpTopWBEvt2, pfCancel, (void **)ppunkNewWindow, DISPID_NEWWINDOW2, 2,
                                VT_DISPATCH|VT_BYREF, ppunkNewWindow,
                                VT_BOOL    |VT_BYREF, pfCancel);
        }

        ATOMICRELEASE(pcpWBEvt2);
        ATOMICRELEASE(pcpTopWBEvt2);
    }
}

void FireEvent_FileDownload(IUnknown * punk, BOOL * pfCancel, VARIANT_BOOL bDocObject)
{
    IConnectionPoint * pcpWBEvt2    = NULL;
    IConnectionPoint * pcpTopWBEvt2 = NULL;

    *pfCancel = FALSE;

    GetWBConnectionPoints(punk, NULL, &pcpWBEvt2);
    GetTopWBConnectionPoints(punk, NULL, &pcpTopWBEvt2);

    if (pcpWBEvt2)
    {
        // disp params are reverse ordered, so the additional parameter is passed first
        DoInvokeParamHelper(punk, pcpWBEvt2, pfCancel, NULL, DISPID_FILEDOWNLOAD, 2,
                            VT_BOOL, bDocObject,
                            VT_BOOL | VT_BYREF, pfCancel);
    }

    if (pcpTopWBEvt2 && !*pfCancel)
    {
        // disp params are reverse ordered, so the additional parameter is passed first
        DoInvokeParamHelper(punk, pcpWBEvt2, pfCancel, NULL, DISPID_FILEDOWNLOAD, 2,
                            VT_BOOL, bDocObject,
                            VT_BOOL | VT_BYREF, pfCancel);
    }

    ATOMICRELEASE(pcpWBEvt2);
    ATOMICRELEASE(pcpTopWBEvt2);
}

void FireEvent_DoInvokeString(IExpDispSupport* peds, DISPID dispid, LPSTR psz)
{
    IConnectionPoint* pccp1, * pccp2;

    if (S_OK == GetWBConnectionPoints(peds, &pccp1, &pccp2))
    {
        // send as generic parameter to DoInvokeParam to package up
        LBSTR::CString          strText;

        LPTSTR          pstrText = strText.GetBuffer(MAX_URL_STRING);

        if (strText.GetAllocLength() < MAX_URL_STRING)
        {
            TraceMsg(TF_WARNING, "FireEvent_DoInvokeString() - strText Allocation Failed!");

            strText.Empty();
        }
        else
        {
            SHAnsiToUnicode(psz, pstrText, MAX_URL_STRING);

            // Let CString class own the buffer again.
            strText.ReleaseBuffer();
        }

        if (! strText.IsEmpty())
        {
            if (pccp2)
            {
                DoInvokeParamHelper(SAFECAST(peds, IUnknown*), pccp2, NULL, NULL, dispid, 1, VT_BSTR, strText);
            }

            if (pccp1)
            {
                DoInvokeParamHelper(SAFECAST(peds, IUnknown*), pccp1, NULL, NULL, dispid, 1, VT_BSTR, strText);
            }
        }

        if (pccp2)
        {
            pccp2->Release();
        }

        if (pccp1)
        {
            pccp1->Release();
        }
    }
}

void FireEvent_DoInvokeStringW(IExpDispSupport* peds, DISPID dispid, LPWSTR psz)
{
    IConnectionPoint* pccp1, * pccp2;

    if (S_OK == GetWBConnectionPoints(peds, &pccp1, &pccp2))
    {
        // send as generic parameter to DoInvokeParam to package up
        LBSTR::CString          strText;

        if (psz)
        {
            strText = psz;
        }
        else
        {
            strText.Empty();
        }

        if (pccp2)
        {
            DoInvokeParamHelper(SAFECAST(peds, IUnknown*), pccp2, NULL, NULL, dispid, 1, VT_BSTR, strText);
        }

        if (pccp1)
        {
            DoInvokeParamHelper(SAFECAST(peds, IUnknown*), pccp1, NULL, NULL, dispid, 1, VT_BSTR, strText);
        }

        if (pccp2)
        {
            pccp2->Release();
        }

        if (pccp1)
        {
            pccp1->Release();
        }
    }
}

void FireEvent_DoInvokeBstr(IUnknown* punk, DISPID dispid, BSTR bstr)
{
    IConnectionPoint* pccp1, * pccp2;

    if (S_OK == GetWBConnectionPoints(punk, &pccp1, &pccp2))
    {
        if (pccp2)
        {
            DoInvokeParamHelper(punk, pccp2, NULL, NULL, dispid, 1, VT_BSTR, bstr);
            pccp2->Release();
        }
        if (pccp1)
        {
            DoInvokeParamHelper(punk, pccp1, NULL, NULL, dispid, 1, VT_BSTR, bstr);
            pccp1->Release();
        }
    }
}

void FireEvent_DoInvokeDispid(IUnknown* punk, DISPID dispid)
{
    IConnectionPoint *pccp1, *pccp2;

    if (S_OK == GetWBConnectionPoints(punk, &pccp1, &pccp2))
    {
        if (pccp2)
        {
            DoInvokeParamHelper(punk, pccp2, NULL, NULL, dispid, 0);
            pccp2->Release();
        }
        if (pccp1)
        {
            DoInvokeParamHelper(punk, pccp1, NULL, NULL, dispid, 0);
            pccp1->Release();
        }
    }
}

void FireEvent_DoInvokeDwords(IExpDispSupport* peds, DISPID dispid, DWORD dw1,DWORD dw2)
{
    IConnectionPoint *pccp1, *pccp2;

    if (S_OK == GetWBConnectionPoints(peds, &pccp1, &pccp2))
    {
        if (pccp2)
        {
            DoInvokeParamHelper(SAFECAST(peds, IUnknown*), pccp2, NULL, NULL, dispid, 2, VT_I4, dw1, VT_I4, dw2);
            pccp2->Release();
        }
        if (pccp1)
        {
            DoInvokeParamHelper(SAFECAST(peds, IUnknown*), pccp1, NULL, NULL, dispid, 2, VT_I4, dw1, VT_I4, dw2);
            pccp1->Release();
        }
    }
}

void FireEvent_Quit(IExpDispSupport* peds)
{
    IConnectionPoint *pccp1, *pccp2;

    if (S_OK == GetWBConnectionPoints(peds, &pccp1, &pccp2))
    {
        if (pccp2)
        {
            DoInvokeParamHelper(SAFECAST(peds, IUnknown*), pccp2, NULL, NULL, DISPID_ONQUIT, 0);
            pccp2->Release();
        }
        if (pccp1)
        {
            // IE3 fired the quit event incorrectly. It was supposed to
            // be VT_BOOL|VT_BYREF and we were supposed to honor the return
            // result and not allow the quit. It never worked that way...
            DoInvokeParamHelper(SAFECAST(peds, IUnknown*), pccp1, NULL, NULL, DISPID_QUIT, 1, VT_BOOL, VARIANT_FALSE);
            pccp1->Release();
        }
    }
}

void FireEvent_OnAdornment(IUnknown* punk, DISPID dispid, VARIANT_BOOL f)
{
    VARIANTARG args[1];
    IUnknown_CPContainerInvokeParam(punk, DIID_DWebBrowserEvents2,
                                    dispid, args, 1, VT_BOOL, f);
#ifdef DEBUG
    // Verify that every IExpDispSupport also supports IConnectionPointContainer
    IConnectionPointContainer *pcpc;
    IExpDispSupport* peds;

    if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, &pcpc))))
    {
        pcpc->Release();
    }
    else if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IExpDispSupport, &peds))))
    {
        peds->Release();
        AssertMsg(0, TEXT("IExpDispSupport without IConnectionPointContainer for %08x"), punk);
    }
#endif
}


HRESULT CIEFrameAuto::OnInvoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams,
                 VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    VARIANT_BOOL vtb = FALSE;
    HRESULT hres = S_OK;

     //riid is supposed to be IID_NULL always
    if (IID_NULL != iid)
        return DISP_E_UNKNOWNINTERFACE;

    if (!(wFlags & DISPATCH_PROPERTYGET))
        return E_FAIL; // Currently we only handle Gets for Ambient Properties

    switch (dispidMember)
    {
    case DISPID_AMBIENT_OFFLINEIFNOTCONNECTED:
        get_Offline(&vtb);
        pVarResult->vt = VT_BOOL;
        pVarResult->boolVal = vtb ? TRUE : FALSE;
        break;

    case DISPID_AMBIENT_SILENT:
        get_Silent(&vtb);
        pVarResult->vt = VT_BOOL;
        pVarResult->boolVal = vtb ? TRUE : FALSE;
        break;

    case DISPID_AMBIENT_PALETTE:
        if (_pbs)
        {
            HPALETTE hpal;
            hres = _pbs->GetPalette(&hpal);
            if (SUCCEEDED(hres))
            {
                pVarResult->vt = VT_HANDLE;
                pVarResult->intVal = PtrToLong(hpal);
            }
        }
        else
            hres = E_FAIL;
        break;

    default:
        hres = E_FAIL;
    }

    return hres;
}


// *** IExternalConnection ***

DWORD CIEFrameAuto::AddConnection(DWORD extconn, DWORD reserved)
{
    TraceMsg(TF_SHDLIFE, "shd - TR CIEFrameAuto::AddConnection(%d) called _cLock(before)=%d", extconn, _cLocks);
    if (extconn & EXTCONN_STRONG)
        return ++_cLocks;
    return 0;
}

DWORD CIEFrameAuto::ReleaseConnection(DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses)
{
    TraceMsg(TF_SHDLIFE, "shd - TR CIEFrameAuto::ReleaseConnection(%d,,%d) called _cLock(before)=%d", extconn, fLastReleaseCloses, _cLocks);
    if (!(extconn & EXTCONN_STRONG))
        return 0;

    _cLocks--;

    if (((_cLocks == 0) || (_cLocks == 1 && _fWindowsListMarshalled)) && fLastReleaseCloses)
    {
        // We could/should have the visiblity update the count of locks.
        // but this is implier for now.
        VARIANT_BOOL fVisible;
        get_Visible(&fVisible);
        if (!fVisible)
        {
            HWND hwnd = _GetHWND();
            //
            // Notice that we close it only if that's the top level browser
            // to avoid closing a hidden WebBrowserOC by mistake.
            //
            if (hwnd && _psbTop == _psb && !IsNamedWindow(hwnd, c_szShellEmbedding))
            {
                // The above test is necessary but not sufficient to determine if the item we're looking
                // at is the browser frame or the WebBrowserOC.
                TraceMsg(TF_SHDAUTO, "CIEFrameAuto::ReleaseConnection posting WM_CLOSE to %x", hwnd);
                PostMessage(hwnd, WM_CLOSE, 0, 0);
            }
        }
    }
    return _cLocks;
}

HRESULT CIEFrameAuto::_BrowseObject(LPCITEMIDLIST pidl, UINT wFlags)
{
    if (_psb)
        return _psb->BrowseObject(pidl, wFlags);
    return E_FAIL;
}

//  return interface for riid via pct->Exec(&CGID_ShellDocView, SHDVID_GETPENDINGOBJECT...)
HRESULT ExecPending(IOleCommandTarget *pct, REFIID riid, void **ppvoid, VARIANT *pvarargIn)
{
    HRESULT hres = E_FAIL;
    VARIANT varOut;

    VariantInit(&varOut);
    hres = pct->Exec(&CGID_ShellDocView, SHDVID_GETPENDINGOBJECT, 0, pvarargIn, &varOut);
    if (SUCCEEDED(hres))
    {
        if (varOut.vt == VT_UNKNOWN && varOut.punkVal)
        {
            hres = varOut.punkVal->QueryInterface(riid, ppvoid);

            // Avoid oleaut for this common and known case
            varOut.punkVal->Release();
            return hres;
        }
        else hres = E_FAIL;
    }
    VariantClearLazy(&varOut);
    return hres;
}

//  returns URL for pending shell view iff there is one and there is NOT an
//  active view.  result returned in VT_BSTR variant
HRESULT CIEFrameAuto::_QueryPendingUrl(VARIANT *pvarResult)
{
    HRESULT hres = E_FAIL;

    if (_psb)
    {
        IShellView *psv;

        if (SUCCEEDED(_psb->QueryActiveShellView(&psv)))
        {
            SAFERELEASE(psv);
        }
        else
        {
            IOleCommandTarget *pct;

            //  Use ExecPending to get IOleCommandTarget on pending shell view
            hres = ExecPending(_pmsc, IID_PPV_ARG(IOleCommandTarget, &pct), NULL);
            if (SUCCEEDED(hres))
            {
                // Use Exec to get URL corresponding to pending shell view
                hres = pct->Exec(&CGID_ShellDocView, SHDVID_GETPENDINGURL, 0, NULL, pvarResult);
                pct->Release();
            }
        }
    }

    return hres;
}

HRESULT CIEFrameAuto::_QueryPendingDelegate(IDispatch **ppDisp, VARIANT *pvarargIn)
{
    HRESULT hres = E_FAIL;
    *ppDisp = NULL;
    if (_psb)
    {
        if (_pmsc)
        {
            IOleCommandTarget *pct;

            //  Use ExecPending to get IOleCommandTarget of pending shell view
            hres = ExecPending(_pmsc, IID_PPV_ARG(IOleCommandTarget, &pct), pvarargIn);
            if (SUCCEEDED(hres))
            {
                // Use ExecPending to get IDispatch of DocObject in pending shell view
                hres = ExecPending(pct, IID_PPV_ARG(IDispatch, ppDisp), NULL);
                pct->Release();
            }
        }
    }
    return hres;
}

//  Gets IDispath of either the DocObject of the active shell view or, if there
//  isn't an active shell view, but there is a pending shell view, ask for it's
//  DocObject.  If necessary, one will be created on the fly
HRESULT CIEFrameAuto::_QueryDelegate(IDispatch **ppDisp)
{
    HRESULT hres = E_FAIL;
    IShellView *psv;
    *ppDisp = NULL;
    if (_psb)
    {
        if (SUCCEEDED(_psb->QueryActiveShellView(&psv)) && psv)
        {
            ITargetContainer *ptgcActive;
            HRESULT hrLocal;
            LPOLESTR pwzFrameSrc;

            hres = SafeGetItemObject(psv, SVGIO_BACKGROUND, IID_PPV_ARG(IDispatch, ppDisp));

            //  Hack to support x = window.open("","FRAME");x = window.open("URL","FRAME")
            if (SUCCEEDED(hres) &&
                *ppDisp &&
                SUCCEEDED((*ppDisp)->QueryInterface(IID_PPV_ARG(ITargetContainer, &ptgcActive))))
            {
                hrLocal = ptgcActive->GetFrameUrl(&pwzFrameSrc);
                if (SUCCEEDED(hrLocal) && pwzFrameSrc)
                {
                    if (URL_SCHEME_ABOUT == GetUrlSchemeW(pwzFrameSrc))
                    {
                        IDispatch *pidPending;
                        VARIANT varIn;

                        //  Pass in bool to override safety check for no active shell view
                        VariantInit(&varIn);
                        varIn.vt = VT_BOOL;
                        varIn.boolVal = TRUE;
                        hrLocal = _QueryPendingDelegate(&pidPending, &varIn);
                        if (SUCCEEDED(hrLocal) && pidPending)
                        {
                            (*ppDisp)->Release();
                            *ppDisp = pidPending;
                        }
                        VariantClearLazy(&varIn);
                    }
                    OleFree(pwzFrameSrc);
                }
                ptgcActive->Release();
            }
            psv->Release();
        }
        else
        {
            hres = _QueryPendingDelegate(ppDisp, NULL);
        }
    }
    return hres;
}

extern HRESULT ShowHlinkFrameWindow(IUnknown *pUnkTargetHlinkFrame);

//=========================================================================
// Helper API
//=========================================================================

//
// API: HlinkFrameNavigate{NHL}
//
//  This is a helper function to be called by DocObject implementations
// which are not be able to open itself as a stand-alone app (like MSHTML).
// If their IHlinkTarget::Navigate is called when the client is not set,
// they will call this API to open a separate browser window in a separate
// process (I assume that those DocObjects are all InProc DLLs).
//
//  HLINK.DLL's IHlink implementation will hit this code path when
// a hyperlink object is activated in non-browser window (such as Office
// apps).
//
STDAPI HlinkFrameNavigate(DWORD grfHLNF, LPBC pbc,
                           IBindStatusCallback *pibsc,
                           IHlink* pihlNavigate,
                           IHlinkBrowseContext *pihlbc)
{
    HRESULT hres S_OK;
    IUnknown* punk = NULL;

    TraceMsg(TF_COCREATE, "HlinkFrameNavigate called");
#ifdef DEBUG
    DWORD dwTick = GetCurrentTime();
#endif

    grfHLNF &= ~HLNF_OPENINNEWWINDOW;   // Implied by CreateTargetFrame
    hres = CreateTargetFrame(NULL, &punk);

#ifdef DEBUG
    TraceMsg(TF_COCREATE, "HlinkFrameNavigate called CoCreate %x (took %d msec)",
             hres, GetCurrentTime()-dwTick);
#endif
    if (SUCCEEDED(hres))
    {
        IHlinkFrame* phfrm;

        hres = punk->QueryInterface(IID_PPV_ARG(IHlinkFrame, &phfrm));
        if (SUCCEEDED(hres))
        {
            if (pihlbc)
            {
                phfrm->SetBrowseContext(pihlbc);
                grfHLNF |= HLNF_EXTERNALNAVIGATE;
            }

            hres = phfrm->Navigate(grfHLNF, pbc, pibsc, pihlNavigate);
            if (SUCCEEDED(hres))
            {
                hres = ShowHlinkFrameWindow(punk);
            } else {
                TraceMsg(DM_ERROR, "HlinkFrameNavigate QI(InternetExplorer) failed (%x)", hres);
            }

            TraceMsg(TF_SHDNAVIGATE, "HlinkFrameNavigate phfrm->Navigate returned (%x)", hres);
            phfrm->Release();
        } else {
            TraceMsg(DM_ERROR, "HlinkFrameNavigate QI(IHlinkFrame) failed (%x)", hres);
        }
        punk->Release();
    } else {
        TraceMsg(DM_ERROR, "HlinkFrameNavigate CoCreateInstance failed (%x)", hres);
    }

    return hres;
}

STDAPI HlinkFrameNavigateNHL(DWORD grfHLNF, LPBC pbc,
                           IBindStatusCallback *pibsc,
                           LPCWSTR pszTargetFrame,
                           LPCWSTR pszUrl,
                           LPCWSTR pszLocation)
{
    HRESULT hres S_OK;
    IUnknown* punk = NULL;
#define MAX_CONTENTTYPE MAX_PATH        // This is a good size.

    TraceMsg(TF_COCREATE, "HlinkFrameNavigateNHL called");
#ifdef DEBUG
    DWORD dwTick = GetCurrentTime();
#endif

    //  This should be more general, but we're punting the FILE: case for IE 4
    //  unless the extension is .htm or .html (all that Netscape 3.0 registers for)
    //  we'll go with ShellExecute if IE is not the default browser.  NOTE:
    //  this means POST will not be supported and pszTargetFrame will be ignored
    //  we don't shellexecute FILE: url's because URL.DLL doesn't give a security
    //  warning for .exe's etc.
    if ((!IsIEDefaultBrowser()))
    {
        WCHAR wszUrl[INTERNET_MAX_URL_LENGTH];
        CHAR  aszUrl[INTERNET_MAX_URL_LENGTH];
        int chUrl;
        HINSTANCE hinstRet;
        LPWSTR pwszExt;
        BOOL bSafeToExec = TRUE;
        DWORD dwCodePage = 0;
        if (pibsc)
        {
            DWORD dw = 0;
            BINDINFO bindinfo = { sizeof(BINDINFO) };
            HRESULT hrLocal = pibsc->GetBindInfo(&dw, &bindinfo);

            if (SUCCEEDED(hrLocal)) 
            {
                dwCodePage = bindinfo.dwCodePage;
                ReleaseBindInfo(&bindinfo);
            }

        }
        if (!dwCodePage)
        {
            dwCodePage = CP_ACP;
        }

        chUrl = lstrlenW(pszUrl);

        pwszExt = PathFindExtensionW(pszUrl);
        if (URL_SCHEME_FILE == GetUrlSchemeW(pszUrl))
        {
            WCHAR wszContentType[MAX_CONTENTTYPE];
            DWORD dwSize = ARRAYSIZE(wszContentType);

            bSafeToExec = FALSE;
            // Get Content type.
            if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_CONTENTTYPE, pwszExt, NULL, wszContentType, &dwSize)))
            {
                bSafeToExec = 0 == StrCmpIW(wszContentType, L"text/html");
            }
        }

        if (bSafeToExec)
        {
            StrCpyNW(wszUrl, pszUrl, ARRAYSIZE(wszUrl));
            //  don't attempt unless we have at least enough for '#' {any} '\0'
            //  NOTE: # is included in pszLocation
            if (pszLocation && *pszLocation && ARRAYSIZE(wszUrl) - chUrl >= 3)
            {
               StrCpyNW(&wszUrl[chUrl], pszLocation, ARRAYSIZE(wszUrl) - chUrl - 1);
            }
            //
            // UNICODE - should this get changed to wchar?
            //
            // finally we will get the string in the native codepage
            SHUnicodeToAnsiCP(dwCodePage, wszUrl, aszUrl, ARRAYSIZE(aszUrl));
            hinstRet = ShellExecuteA(NULL, NULL, aszUrl, NULL, NULL, SW_SHOWNORMAL);
            return ((UINT_PTR)hinstRet) <= 32 ? E_FAIL:S_OK;
        }
    }

    grfHLNF &= ~HLNF_OPENINNEWWINDOW;   // Implied by CreateTargetFrame
    hres = CreateTargetFrame(pszTargetFrame, &punk);

#ifdef DEBUG
    TraceMsg(TF_COCREATE, "HlinkFrameNavigateNHL called CoCreate %x (took %d msec)", hres, GetCurrentTime()-dwTick);
#endif
    if (SUCCEEDED(hres))
    {
        ITargetFramePriv *ptgfp;
        hres = punk->QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptgfp));
        if (SUCCEEDED(hres))
        {
            hres = ptgfp->NavigateHack(grfHLNF, pbc, pibsc, NULL, pszUrl, pszLocation);
            if (SUCCEEDED(hres))
            {
                hres = ShowHlinkFrameWindow(punk);
            } 
            else 
            {
                TraceMsg(DM_ERROR, "HlinkFrameNavigate QI(InternetExplorer) failed (%x)", hres);
            }

            TraceMsg(TF_SHDNAVIGATE, "HlinkFrameNavigate phfrm->Navigate returned (%x)", hres);
            ptgfp->Release();
        } 
        else 
        {
            TraceMsg(DM_ERROR, "HlinkFrameNavigate QI(IHlinkFrame) failed (%x)", hres);
        }
        punk->Release();
    } 
    else 
    {
        TraceMsg(DM_ERROR, "HlinkFrameNavigate CoCreateInstance failed (%x)", hres);
    }
    return hres;
}

CIEFrameClassFactory* g_pcfactory = NULL;
CIEFrameClassFactory* g_pcfactoryShell = NULL;

//
//  This function is called when the first browser window is being created.
// punkAuto is non-NULL if and only if the browser is started as the result
// of CoCreateInstance.
//
void IEInitializeClassFactoryObject(IUnknown* punkAuto)
{
    ASSERT(g_pcfactory==NULL);
    ASSERT(g_pcfactoryShell==NULL);
    AssertParking();

    // We don't want to register this local server stuff for the shell process
    // if we are in browse in new process and this is the Explorer process.
    if (!IsBrowseNewProcessAndExplorer())
    {
        g_pcfactory = new CIEFrameClassFactory(punkAuto, CLSID_InternetExplorer, COF_IEXPLORE);
    }
    g_pcfactoryShell = new CIEFrameClassFactory(NULL, CLSID_ShellBrowserWindow, COF_SHELLFOLDERWINDOW);
}

//
//  This function is called when the primaty thread is going away.
// It revokes the class factory object and release it.
//
void IERevokeClassFactoryObject(void)
{
    AssertParking();

    if (g_pcfactory)
    {
        g_pcfactory->Revoke();
        ATOMICRELEASE(g_pcfactory);
    }
    if (g_pcfactoryShell)
    {
        g_pcfactoryShell->Revoke();
        ATOMICRELEASE(g_pcfactoryShell);
    }
}

//
//  This function is called when the first browser window is being destroyed.
// It will remove the registered automation object (via IEInitializeClass...)
// to accidentally return an automation object to closed window.
//
void IECleanUpAutomationObject()
{
    if (g_pcfactory)
        g_pcfactory->CleanUpAutomationObject();

    if (g_pcfactoryShell)
        g_pcfactoryShell->CleanUpAutomationObject();
}

void IEOnFirstBrowserCreation(IUnknown* punk)
{
    // For the desktop case, we DON'T have a g_tidParking set
    // and we don't need one, so this assert is bogus in that
    // case.  But it's probably checking something valid, so
    // I made the assert not fire in the desktop case. Unfortunately
    // this also makes it not fire in most other cases that it
    // checks, but at least it will check a few things (if automated)
    //
    ASSERT(g_tidParking == GetCurrentThreadId() || !punk);

    // If automation, now is good time to register ourself...
    if (g_fBrowserOnlyProcess)
        IEInitializeClassFactoryObject(punk);

    //
    // Tell IEDDE that automation services are now available.
    //
    IEDDE_AutomationStarted();
}

HRESULT CoCreateNewIEWindow(DWORD dwClsContext, REFIID riid, void **ppvunk)
{
    // QFE 2844 -- We don't want to create a new window as a local
    // server off of the registered class object.  Simply create
    // the window in a new thread by a direct createinstance.
    if (dwClsContext & CLSCTX_INPROC_SERVER)
    {
        HRESULT hr = REGDB_E_CLASSNOTREG;
        IClassFactory *pcf = NULL;

        *ppvunk = NULL;
        if (g_pcfactory &&
            SUCCEEDED(hr = g_pcfactory->QueryInterface(IID_PPV_ARG(IClassFactory, &pcf)))) 
        {
            hr = pcf->CreateInstance(NULL, riid, ppvunk);
            pcf->Release();
        }

        if (SUCCEEDED(hr)) 
        {
            return hr;
        }
        else 
        {
            // Try other contexts via CoCreateInstance since inproc failed.
            dwClsContext &= ~CLSCTX_INPROC_SERVER;

            if (!dwClsContext) {
                return hr;
            }
        }
    }
    return CoCreateInstance(CLSID_InternetExplorer, NULL, dwClsContext, riid, ppvunk);
}



SAFEARRAY * MakeSafeArrayFromData(LPCBYTE pData,DWORD cbData)
{
    if (!pData || 0 == cbData)
        return NULL;  // nothing to do

    // create a one-dimensional safe array
    SAFEARRAY *psa = SafeArrayCreateVector(VT_UI1,0,cbData);
    if (psa) 
    {
        // copy data into the area in safe array reserved for data
        // Note we party directly on the pointer instead of using locking/
        // unlocking functions.  Since we just created this and no one
        // else could possibly know about it or be using it, this is OK.

        ASSERT(psa->pvData);
        memcpy(psa->pvData,pData,cbData);
    }
    return psa;
}


/******************************************************************************
                    Helper Functions
******************************************************************************/


/******************************************************************************
 Safe version of the Win32 SysAllocStringLen() function. Allows you to
 pass in a string (pStr) that is smaller than the desired BSTR (len).
******************************************************************************/
BSTR SafeSysAllocStringLen(const WCHAR *pStr, const unsigned int len)
{
    // SysAllocStringLen allocates len + 1
    BSTR pNewStr = SysAllocStringLen(NULL, len);

    if (pStr && pNewStr)
    {
        // StrCpyNW always null terminates so we need to copy len+1
        StrCpyNW(pNewStr, pStr, len + 1);
    }

    return pNewStr;
}

BSTR SysAllocStringFromANSI(const char *pStr, int size = -1)
{
    if (!pStr)
        return 0;

    if (size < 0)
        size = lstrlenA(pStr);

    // Allocates size + 1
    BSTR bstr = SysAllocStringLen(NULL, size);
    if (bstr)
    {
        if (!MultiByteToWideChar(CP_ACP, 0, pStr, -1, bstr, size + 1))
        {
            SysFreeString(bstr);
            bstr = 0;
        }
    }

    return bstr;
}


HRESULT GetDelegateOnIDispatch(IDispatch* pdisp, const DISPID delegateID, IDispatch ** const ppDelegate)
{
    HRESULT hres;

    if (!pdisp || ! ppDelegate)
        return E_POINTER;

    DISPPARAMS dispparams = {0};
    VARIANT VarResult;
    VariantInit(&VarResult);

    hres = pdisp->Invoke(   delegateID,
                            IID_NULL,
                            0,
                            DISPATCH_PROPERTYGET,
                            &dispparams,
                            &VarResult,
                            NULL,
                            NULL);

    if (SUCCEEDED(hres))
    {
        if (VarResult.vt == VT_DISPATCH && VarResult.pdispVal)
        {
            *ppDelegate = VarResult.pdispVal;
            (*ppDelegate)->AddRef();
        }
        else
        {
            // Temporary hack (I think) until Trident always returns IDispatch
            if (VarResult.pdispVal && VarResult.vt == VT_UNKNOWN)
                hres = VarResult.pdispVal->QueryInterface(IID_PPV_ARG(IDispatch, ppDelegate));
            else
                hres = E_FAIL;
        }
        VariantClearLazy(&VarResult);
    }

    return hres;
}

HRESULT GetRootDelegate(CIEFrameAuto* pauto, IDispatch ** const ppRootDelegate)
{
    IDispatch *pdiDocObject;
    HRESULT hres;

    if (!pauto || !ppRootDelegate)
        return E_POINTER;

    //  Get the IHTMLWindow2 of docobject in our frame.  Note: if this is cached
    //  you must put glue into docobjhost to release the cache when deactivating
    //  view.
    hres = pauto->_QueryDelegate(&pdiDocObject);

    if (SUCCEEDED(hres))
    {
        hres = GetDelegateOnIDispatch(pdiDocObject, DISPID_WINDOWOBJECT, ppRootDelegate);
        pdiDocObject->Release();
    }

    return hres;
}

HRESULT GetWindowFromUnknown(IUnknown *pUnk, IHTMLWindow2 **pWinOut)
{
    return IUnknown_QueryService(pUnk, SID_SOmWindow, IID_PPV_ARG(IHTMLWindow2, pWinOut));
}


/******************************************************************************
                    Automation Stub Object
******************************************************************************/

CIEFrameAuto::CAutomationStub::CAutomationStub(DISPID minDispid, DISPID maxDispid, BOOL fOwnDefaultDispid) :
    _MinDispid(minDispid), _MaxDispid(maxDispid), _fOwnDefaultDispid(fOwnDefaultDispid)
{
    ASSERT(!_pInterfaceTypeInfo2);
    ASSERT(!_pCoClassTypeInfo2);
    ASSERT(!_pAuto);
    ASSERT(!_pInstance);
    ASSERT(!_fLoaded);
}

CIEFrameAuto::CAutomationStub::~CAutomationStub()
{
    SAFERELEASE(_pInterfaceTypeInfo2);
    SAFERELEASE(_pCoClassTypeInfo2);
}

HRESULT CIEFrameAuto::CAutomationStub::Init(void *instance, REFIID iid, REFIID clsid, CIEFrameAuto *pauto)
{
    if (!pauto || !instance)
        return E_POINTER;

    _iid = iid;
    _clsid = clsid;

    // Don't need to AddRef this since our lifetime is controled by CIEFrameAuto
    _pAuto = pauto;
    _pInstance = instance;

    return S_OK;
}

STDMETHODIMP CIEFrameAuto::CAutomationStub::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown)   ||
       IsEqualIID(riid, IID_IDispatch)  ||
       IsEqualIID(riid, IID_IDispatchEx))
    {
        *ppv = SAFECAST(this, IDispatchEx*);
    }
    else if (IsEqualIID(riid, IID_IProvideClassInfo))
    {
        *ppv = SAFECAST(this, IProvideClassInfo*);
    }
    else
    {
        return _InternalQueryInterface(riid, ppv);
    }

    AddRef();
    return S_OK;
}

ULONG CIEFrameAuto::CAutomationStub::AddRef(void)
{
    ASSERT(_pAuto);
    return _pAuto->AddRef();
}

ULONG CIEFrameAuto::CAutomationStub::Release(void)
{
    ASSERT(_pAuto);
    return _pAuto->Release();
}

/******************************************************************************
// bradsch 11/8/96
// I don't think typeinfo for the object implemented in the browser should
// live in MSHTML. It should be moved to shdocvw. For now so we don't have
// to worry about hard coded LIBIDs and changing versions this methods gets
// typeinfo from the delegate that lives in Trident. In cases where we have
// not delegate this method tries to load typeinfo directly from MSHTML.
******************************************************************************/
HRESULT CIEFrameAuto::CAutomationStub::ResolveTypeInfo2()
{
    ASSERT(!_pInterfaceTypeInfo2);
    ASSERT(!_pCoClassTypeInfo2);
    ASSERT(_pAuto);

    // Only try once.
    _fLoaded = TRUE;

    // Have we computed MatchExactGetIDsOfNames yet?
    if (!IEFrameAuto()->_hinstMSHTML)
    {
        // No, so look for helper function in mshtml.dll
        IEFrameAuto()->_hinstMSHTML = LoadLibrary(TEXT("mshtml.dll"));
        if (IEFrameAuto()->_hinstMSHTML && !IEFrameAuto()->_pfnMEGetIDsOfNames)
        {
            IEFrameAuto()->_pfnMEGetIDsOfNames =
                (PFN_MatchExactGetIDsOfNames)GetProcAddress(IEFrameAuto()->_hinstMSHTML, "MatchExactGetIDsOfNames");
        }
    }

    ITypeLib *pTypeLib = 0;
    IDispatch *pDisp = 0;

    HRESULT hr = GetRootDelegate(_pAuto, &pDisp);
    if (SUCCEEDED(hr))
    {
        UINT supported;
        hr = pDisp->GetTypeInfoCount(&supported);

        if (SUCCEEDED(hr) && supported)
        {
            ITypeInfo *pTypeInfo = 0;
            hr = pDisp->GetTypeInfo(0, 0, &pTypeInfo);

            if (SUCCEEDED(hr))
            {
                UINT index;
                hr = pTypeInfo->GetContainingTypeLib(&pTypeLib, &index);
                SAFERELEASE(pTypeInfo);
            }
        }

        SAFERELEASE(pDisp);
    }

    if (FAILED(hr))
    {
        // If, for some reason, we failed to load the type library this way,
        // load the type library directly out of MSHTML's resources.

        // We shouldn't hard code this...
        hr = LoadTypeLib(L"mshtml.tlb", &pTypeLib);
    }

    if (FAILED(hr))
        return hr;

    ITypeInfo *pTopTypeInfo = 0;
    ITypeInfo *pTmpTypeInfo = 0;
    ITypeInfo *pCoClassTypeInfo = 0;

    // Get the coclass TypeInfo
    hr = pTypeLib->GetTypeInfoOfGuid(_clsid, &pCoClassTypeInfo);
    if (SUCCEEDED(hr))
        hr = pCoClassTypeInfo->QueryInterface(IID_ITypeInfo2, (void**)&_pCoClassTypeInfo2);

    if (FAILED(hr))
        goto Exit;

    // get the TKIND_INTERFACE
    hr = pTypeLib->GetTypeInfoOfGuid(_iid, &pTopTypeInfo);

    if (SUCCEEDED(hr))
    {
        HREFTYPE hrt;

        // get the TKIND_INTERFACE from a TKIND_DISPATCH
        hr = pTopTypeInfo->GetRefTypeOfImplType(0xffffffff, &hrt);

        if (SUCCEEDED(hr))
        {
            // get the typeInfo associated with the href
            hr = pTopTypeInfo->GetRefTypeInfo(hrt, &pTmpTypeInfo);

            if (SUCCEEDED(hr))
                hr = pTmpTypeInfo->QueryInterface(IID_ITypeInfo2, (void**)&_pInterfaceTypeInfo2);
        }
    }

Exit:
    SAFERELEASE(pCoClassTypeInfo);
    SAFERELEASE(pTmpTypeInfo);
    SAFERELEASE(pTopTypeInfo);
    SAFERELEASE(pTypeLib);
    return hr;
}



// *** IDispatch members ***

HRESULT CIEFrameAuto::CAutomationStub::GetTypeInfoCount(UINT *typeinfo)
{
    if (!typeinfo)
        return E_POINTER;

    if (!_fLoaded)
        ResolveTypeInfo2();

    *typeinfo = _pInterfaceTypeInfo2 ? 1 : 0;

    return S_OK;
}

HRESULT CIEFrameAuto::CAutomationStub::GetTypeInfo(UINT itinfo, LCID, ITypeInfo **typeinfo)
{
    if (!typeinfo)
        return E_POINTER;

    *typeinfo = NULL;

    if (0 != itinfo)
        return TYPE_E_ELEMENTNOTFOUND;

    if (!_fLoaded)
    {
        HRESULT hr = ResolveTypeInfo2();
        if (FAILED(hr))
            return hr;
    }

    if (_pInterfaceTypeInfo2)
    {
        *typeinfo = _pInterfaceTypeInfo2;
        _pInterfaceTypeInfo2->AddRef();
    }

    return *typeinfo ? S_OK : E_FAIL;
}

HRESULT CIEFrameAuto::CAutomationStub::GetIDsOfNames(
  REFIID riid,
  OLECHAR **rgszNames,
  UINT cNames,
  LCID lcid,
  DISPID *rgdispid)
{
    // Since the majority of script operates on built in (non-expando) properties
    // This implementation should be faster than simply passing all lookups to
    // the delegate.

    // Handle it if we can. It is OK to return a DISPID for a method/property
    // that is implemented by Trident. We will simply pass it through in Invoke
    if (!_fLoaded)
        ResolveTypeInfo2();

    if (!_pInterfaceTypeInfo2)
        return TYPE_E_CANTLOADLIBRARY;

    HRESULT  hr = _pInterfaceTypeInfo2->GetIDsOfNames(rgszNames, cNames, rgdispid);

    if (FAILED(hr))
    {
        IDispatchEx *delegate = 0;
        hr = _GetIDispatchExDelegate(&delegate);

        if (SUCCEEDED(hr))
        {
            hr = delegate->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
            delegate->Release();
        }
    }

    return hr;
}

HRESULT CIEFrameAuto::CAutomationStub::InvokeEx (DISPID dispidMember,
   LCID lcid,
   WORD wFlags,
   DISPPARAMS * pdispparams,
   VARIANT * pvarResult,
   EXCEPINFO * pexcepinfo,
   IServiceProvider *pSrvProvider)
{
    HRESULT hr;

    if (dispidMember == DISPID_SECURITYCTX)
    {
        //
        // Return the url of the document as a bstr.
        //

        if (pvarResult)
        {
            hr = _pAuto->_QueryPendingUrl(pvarResult);
            if (SUCCEEDED(hr)) 
                return S_OK;
        }
    }

    if ((dispidMember != DISPID_SECURITYCTX) &&
        ((dispidMember >= _MinDispid && dispidMember <= _MaxDispid) ||
         (_fOwnDefaultDispid && DISPID_VALUE == dispidMember)))
    {
        BOOL    fNamedDispThis = FALSE;
        VARIANTARG *rgOldVarg = NULL;           // init to suppress bogus C4701 warning
        DISPID *rgdispidOldNamedArgs = NULL;    // init to suppress bogus C4701 warning

        if (!_fLoaded)
            ResolveTypeInfo2();

        if (!_pInterfaceTypeInfo2)
            return TYPE_E_CANTLOADLIBRARY;

        // Any invoke call from a script engine might have the named argument
        // DISPID_THIS.  If so then we'll not include this argument in the
        // list of parameters because oleaut doesn't know how to deal with this
        // argument.
        if (pdispparams->cNamedArgs && (pdispparams->rgdispidNamedArgs[0] == DISPID_THIS))
        {
            fNamedDispThis = TRUE;

            pdispparams->cNamedArgs--;
            pdispparams->cArgs--;

            rgOldVarg = pdispparams->rgvarg;
            rgdispidOldNamedArgs = pdispparams->rgdispidNamedArgs;

            pdispparams->rgvarg++;
            pdispparams->rgdispidNamedArgs++;

            if (pdispparams->cNamedArgs == 0)
                pdispparams->rgdispidNamedArgs = NULL;

            if (pdispparams->cArgs == 0)
                pdispparams->rgvarg = NULL;
        }

        // It belongs to us. Use the typelib to call our method.
        hr = _pInterfaceTypeInfo2->Invoke(_pInstance,
                                    dispidMember,
                                    wFlags,
                                    pdispparams,
                                    pvarResult,
                                    pexcepinfo,
                                    NULL);

        // Replace the named DISPID_THIS argument.
        if (fNamedDispThis)
        {
            pdispparams->cNamedArgs++;
            pdispparams->cArgs++;

            pdispparams->rgvarg = rgOldVarg;
            pdispparams->rgdispidNamedArgs = rgdispidOldNamedArgs;
        }
    }
    else
    {
        // Pass it along
        IDispatchEx *delegate = 0;
        hr = _GetIDispatchExDelegate(&delegate);

        if (SUCCEEDED(hr))
        {
            hr = delegate->InvokeEx(dispidMember,
                                    lcid,
                                    wFlags,
                                    pdispparams,
                                    pvarResult,
                                    pexcepinfo,
                                    pSrvProvider);
            delegate->Release();
        }
        else
        {
            // If we're hosting a non-Trident DocObject, we can get here trying to answer an
            // Invoke on the Security Context.  This can cause cross-frame access to fail,
            // even when we want it to succeed.  If we pass back the URL of the active view,
            // then Trident can do the proper cross-frame access checking.
            //
            if (dispidMember == DISPID_SECURITYCTX)
            {
                if (_pAuto && _pAuto->_psb)  // Check them both for paranoia.
                {
                    IShellView *psv;

                    if (SUCCEEDED(_pAuto->_psb->QueryActiveShellView(&psv)))
                    {
                        IOleCommandTarget  *pct;

                        if (SUCCEEDED(psv->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pct))))
                        {
                            // The name of the ID is misleading -- it really returns the URL of the view.  It was
                            // invented for Pending views, but works just as well for active views.
                            //
                            hr = pct->Exec(&CGID_ShellDocView, SHDVID_GETPENDINGURL, 0, NULL, pvarResult);
                            SAFERELEASE(pct);
                        }
                        SAFERELEASE(psv);
                    }
                }
            }
        }
    }

    return hr;

}

HRESULT CIEFrameAuto::CAutomationStub::Invoke(
  DISPID dispidMember,
  REFIID,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS *pdispparams,
  VARIANT *pvarResult,
  EXCEPINFO *pexcepinfo,
  UINT *)
{
    return InvokeEx (dispidMember, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, NULL);
}

// *** IDispatchEx members ***

STDMETHODIMP CIEFrameAuto::CAutomationStub::GetDispID(
  BSTR bstrName,
  DWORD grfdex,
  DISPID *pid)
{
    HRESULT hr;

    if (!_fLoaded)
        ResolveTypeInfo2();

    if (!_pInterfaceTypeInfo2)
        return TYPE_E_CANTLOADLIBRARY;

    // Do a case sensitive compare?
    if (IEFrameAuto()->_pfnMEGetIDsOfNames)
    {
        // Case sensitve GetIDsOfNames.
        hr = (IEFrameAuto()->_pfnMEGetIDsOfNames)(_pInterfaceTypeInfo2,
                                                  IID_NULL,
                                                  &bstrName,
                                                  1, 0, pid,
                                                  grfdex & fdexNameCaseSensitive);
    }
    else
    {
        hr = _pInterfaceTypeInfo2->GetIDsOfNames(&bstrName, 1, pid);
    }

    // If fails then try typelibrary.
    if (FAILED(hr))
    {
        IDispatchEx *delegate = 0;

        // Always delegate which is faster, avoids loading the typelibrary.
        hr = _GetIDispatchExDelegate(&delegate);

        if (SUCCEEDED(hr))
        {
            hr = delegate->GetDispID(bstrName, grfdex, pid);
            delegate->Release();
        }
    }

    return hr;
}


STDMETHODIMP CIEFrameAuto::CAutomationStub::DeleteMemberByName(BSTR bstr, DWORD grfdex)
{
    HRESULT       hr;
    IDispatchEx  *delegate = 0;

    // Always delegate which is faster, avoids loading the typelibrary.
    hr = _GetIDispatchExDelegate(&delegate);

    if (SUCCEEDED(hr))
    {
        hr = delegate->DeleteMemberByName(bstr,grfdex);
        delegate->Release();
    }

    return hr;
}

STDMETHODIMP CIEFrameAuto::CAutomationStub::DeleteMemberByDispID(DISPID id)
{
    HRESULT       hr;
    IDispatchEx  *delegate = 0;

    // Always delegate which is faster, avoids loading the typelibrary.
    hr = _GetIDispatchExDelegate(&delegate);

    if (SUCCEEDED(hr))
    {
        hr = delegate->DeleteMemberByDispID(id);
        delegate->Release();
    }

    return hr;
}

STDMETHODIMP  CIEFrameAuto::CAutomationStub::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
{
    HRESULT       hr;
    IDispatchEx  *delegate = 0;

    // Always delegate which is faster, avoids loading the typelibrary.
    hr = _GetIDispatchExDelegate(&delegate);

    if (SUCCEEDED(hr))
    {
        hr = delegate->GetMemberProperties( id, grfdexFetch, pgrfdex);
        delegate->Release();
    }

    return hr;
}


STDMETHODIMP  CIEFrameAuto::CAutomationStub::GetMemberName(DISPID id, BSTR *pbstrName)
{
    HRESULT       hr;
    IDispatchEx  *delegate = 0;

    // Always delegate which is faster, avoids loading the typelibrary.
    hr = _GetIDispatchExDelegate(&delegate);

    if (SUCCEEDED(hr))
    {
        hr = delegate->GetMemberName( id, pbstrName);
        delegate->Release();
    }

    return hr;
}


STDMETHODIMP CIEFrameAuto::CAutomationStub::GetNextDispID(
  DWORD grfdex,
  DISPID id,
  DISPID *pid)
{
    IDispatchEx *delegate = 0;
    HRESULT hr = _GetIDispatchExDelegate(&delegate);

    if (SUCCEEDED(hr))
    {
        hr = delegate->GetNextDispID(grfdex, id, pid);
        delegate->Release();
    }

    return hr;
}

STDMETHODIMP CIEFrameAuto::CAutomationStub::GetNameSpaceParent(IUnknown **ppunk)
{
    HRESULT hr;

    if (!ppunk)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *ppunk = NULL;
    hr = S_OK;

Cleanup:
    return hr;
}


// *** IProvideClassInfo members ***

STDMETHODIMP CIEFrameAuto::CAutomationStub::GetClassInfo(ITypeInfo **typeinfo)
{
    if (!typeinfo)
        return E_POINTER;

    if (!_fLoaded)
    {
        HRESULT hr = ResolveTypeInfo2();
        if (FAILED(hr))
        {
            *typeinfo = NULL;
            return hr;
        }
    }

    *typeinfo = _pCoClassTypeInfo2;

    if (*typeinfo)
    {
        (*typeinfo)->AddRef();
        return S_OK;
    }
    return E_FAIL;
}

/******************************************************************************
                    Window Object
******************************************************************************/

// Define static variables
unsigned long CIEFrameAuto::COmWindow::s_uniqueIndex = 0;


CIEFrameAuto::COmWindow::COmWindow() :
    CAutomationStub(MIN_BROWSER_DISPID, MAX_BROWSER_DISPID, FALSE)
{
    ASSERT(FALSE == _fCallbackOK);
    ASSERT(!_pOpenedWindow);
    ASSERT(_varOpener.vt == VT_EMPTY);
    ASSERT(!_dwCPCookie);
    ASSERT(!_pCP);
    ASSERT(!_fOnloadFired);
    ASSERT(!_fIsChild);
    ASSERT(!_pIntelliForms);

    _fDelegateWindowOM = TRUE;     // Always delegate, unless told otherwise.

}

HRESULT CIEFrameAuto::COmWindow::Init()
{
    _cpWindowEvents.SetOwner(SAFECAST(SAFECAST(this, CAutomationStub*), IDispatchEx*), &DIID_HTMLWindowEvents);

    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _omwin, this);
    return CAutomationStub::Init(SAFECAST(this, IHTMLWindow2*), IID_IHTMLWindow2, CLSID_HTMLWindow2, pauto);
}


#ifdef NO_MARSHALLING
EXTERN_C  const GUID IID_IWindowStatus;
#endif

HRESULT CIEFrameAuto::COmWindow::_InternalQueryInterface(REFIID riid, void ** const ppv)
{
    ASSERT(!IsEqualIID(riid, IID_IUnknown));

    if (IsEqualIID(riid, IID_IHTMLWindow2) || IsEqualIID(riid, IID_IHTMLFramesCollection2))
        *ppv = SAFECAST(this, IHTMLWindow2*);
    else if (IsEqualIID(riid, IID_IHTMLWindow3))
        *ppv = SAFECAST(this, IHTMLWindow3*);
    else if (IsEqualIID(riid, IID_ITargetNotify))
        *ppv = SAFECAST(this, ITargetNotify*);
    else if (IsEqualIID(riid, IID_IShellHTMLWindowSupport))
        *ppv = SAFECAST(this, IShellHTMLWindowSupport*);
    else if (IsEqualIID(riid, IID_IShellHTMLWindowSupport2))
        *ppv = SAFECAST(this, IShellHTMLWindowSupport2*);
    else if (IsEqualIID(riid, IID_IProvideMultipleClassInfo) ||
             IsEqualIID(riid, IID_IProvideClassInfo2))
        *ppv = SAFECAST(this, IProvideMultipleClassInfo*);
    else if (IsEqualIID(riid, IID_IConnectionPointCB))
        *ppv = SAFECAST(this, IConnectionPointCB*);
    else if (IsEqualIID(riid, IID_IConnectionPointContainer))
        *ppv = SAFECAST(this, IConnectionPointContainer*);
    else if (IsEqualIID(riid, IID_IServiceProvider))
        *ppv = SAFECAST(this, IServiceProvider *);
#ifdef NO_MARSHALLING
    else if (IsEqualIID(riid, IID_IWindowStatus))
        *ppv = SAFECAST(this, IWindowStatus *);
#endif
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}


// ** IProvideMultipleClassInfo

STDMETHODIMP CIEFrameAuto::COmWindow::GetGUID(DWORD dwGuidKind, GUID* pGUID)
{
    if (!pGUID)
        return E_POINTER;

    if (GUIDKIND_DEFAULT_SOURCE_DISP_IID == dwGuidKind)
    {
        *pGUID = DIID_HTMLWindowEvents;
        return S_OK;
    }
    else
        return E_INVALIDARG;
}

/******************************************************************************
 Both IProvideMultipleClassInfo specific methods are passed along to Trident.
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmWindow::GetMultiTypeInfoCount(ULONG *pcti)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        IProvideMultipleClassInfo *pMCI = 0;
        hr = pWindow->QueryInterface(IID_PPV_ARG(IProvideMultipleClassInfo, &pMCI));
        pWindow->Release();

        if (SUCCEEDED(hr))
        {
            hr = pMCI->GetMultiTypeInfoCount(pcti);
            pMCI->Release();
        }
    }

    return hr;
}

STDMETHODIMP CIEFrameAuto::COmWindow::GetInfoOfIndex(ULONG iti, DWORD dwFlags, ITypeInfo **pptiCoClass, DWORD *pdwTIFlags, ULONG *pcdispidReserved,IID *piidPrimary,IID *piidSource)
{
    IHTMLWindow2 *pWindow;
    HRESULT hr = _GetWindowDelegate(&pWindow);
    if (SUCCEEDED(hr))
    {
        IProvideMultipleClassInfo *pMCI = 0;
        hr = pWindow->QueryInterface(IID_PPV_ARG(IProvideMultipleClassInfo, &pMCI));
        pWindow->Release();

        if (SUCCEEDED(hr))
        {
            hr = pMCI->GetInfoOfIndex(iti, dwFlags, pptiCoClass, pdwTIFlags, pcdispidReserved, piidPrimary, piidSource);
            pMCI->Release();
        }
    }
    return hr;
}

STDMETHODIMP CIEFrameAuto::COmWindow::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    IDispatchEx *delegate;
    HRESULT hr = _GetIDispatchExDelegate(&delegate);
    if (SUCCEEDED(hr))
    {
        hr = delegate->GetDispID(bstrName, grfdex, pid);
        delegate->Release();
    }
    else
    {
        return CAutomationStub::GetDispID(bstrName, grfdex, pid);
    }
    return hr;
}

/*****************************************************************************
 IServiceProvider - this is used by mshtml as well as intelliforms in iforms.cpp
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmWindow::QueryService(REFGUID guidService, REFIID riid, void ** ppv)
{
    HRESULT hr = E_NOINTERFACE;

    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    if (IsEqualGUID(guidService,IID_IHTMLWindow2))
    {
        return QueryInterface(riid, ppv);
    }
    else if (IsEqualGUID(guidService, IID_IEnumPrivacyRecords))
    {
        IHTMLWindow2 *pWindow = 0;
        IServiceProvider * pISP = NULL;
        hr = _GetWindowDelegate(&pWindow);

        if (SUCCEEDED(hr))
        {
            hr = pWindow->QueryInterface(IID_PPV_ARG(IServiceProvider, &pISP));
            if (SUCCEEDED(hr))
            {
                hr = pISP->QueryService(IID_IEnumPrivacyRecords, riid, ppv);
                pISP->Release();
            }
            pWindow->Release();
        }

        return hr;
    }

    return hr;
}

STDMETHODIMP CIEFrameAuto::COmWindow::ViewReleaseIntelliForms()
{
    ReleaseIntelliForms();

    return S_OK;
}

/******************************************************************************
 This method is called when the document contained by the browser is being
 deactivated (like when navigating to a new location). Currently we only use
 this knowledge to handle event sourcing.

 This method could also be used to optimize our connections to expando
 implentations in the document (trident). Currently we obtain and release
 the expando implementations for the Navigator, History, and Location objects
 each time they are needed. ViewRelease (along with ViewActivated) would allow
 us to grab and hold expando implementations until the next navigation.
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmWindow::ViewReleased()
{
    UnsinkDelegate();
    ReleaseIntelliForms();

    BSTR bstrName = SysAllocString(STR_FIND_DIALOG_NAME);
    if (bstrName)
    {
        VARIANT varProp;
        if (SUCCEEDED(_pAuto->GetProperty(bstrName, &varProp)))
        {
            if ((varProp.vt == VT_DISPATCH) && (varProp.pdispVal != NULL))
            {
                IUnknown* pWindow = varProp.pdispVal;

                VARIANT vtTmp = {0};
                _pAuto->PutProperty(bstrName, vtTmp);

                //(davemi) see IE5 bug 57060 for why the below line doesn't work and IDispatch must be used instead
                //pWindow->close();
                IDispatch * pdisp;
                if (SUCCEEDED(pWindow->QueryInterface(IID_PPV_ARG(IDispatch, &pdisp))))
                {
                    DISPID dispid;
                    DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

                    BSTR bstrClose = SysAllocString(L"close");

                    if (bstrClose)
                    {
                        HRESULT hr;

                        hr = pdisp->GetIDsOfNames(IID_NULL, &bstrClose, 1, LOCALE_SYSTEM_DEFAULT, &dispid);
                        if (hr == S_OK)
                        {
                            VARIANT varTmp = {0};
                            pdisp->Invoke(dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD, &dispparamsNoArgs, &varTmp, NULL, NULL);
                        }

                        SysFreeString(bstrClose);
                    }

                    pdisp->Release();
                }
            }
            VariantClear(&varProp);
        }
        SysFreeString(bstrName);
    }

    return FireOnUnload();
}

/******************************************************************************
 This method is called when the document contained by the browser is being
 activated. Currently we only use this knowledge to handle event sourcing.

 See comments for ViewReleased()
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmWindow::ViewActivated()
{
    HRESULT hr;

    // These will fail for non-trident documents which is OK.
    SinkDelegate();
    AttachIntelliForms();

    // This call will return TRUE if either:
    // - The document has reached READYSTATE_COMPLETE or
    // - The document does not support the ReadyState property
    // If the delegate is not complete then we will be notified of READYSTATE
    // changes later. These notifications will tell use when the document is
    // complete and the Onload even should be fired.
    if (IsDelegateComplete())
        hr = FireOnLoad();
    else
        hr = S_OK;

    return hr;
}

STDMETHODIMP CIEFrameAuto::COmWindow::ReadyStateChangedTo(long ready_state, IShellView *psv)
{
    HRESULT hr = S_OK;

    // We only want to fire Onload if the ready state has changed to
    // READYSTATE_COMPLETE and the view that has changed states is the
    // currently active view. If the pending view has completed states
    // we can ignore the notification because Onload will be fired when
    // the pending view is activated. Ignoring READYSTATE changes from
    // the pending view garauntees we will never fire onload early for
    // the currently active view.
    if ((READYSTATE_COMPLETE == ready_state) && psv)
    {
        IShellView * const pCurrSV = _pAuto->_GetShellView();

        if (pCurrSV)
        {
            if (IsSameObject(pCurrSV, psv))
            {
                hr = FireOnLoad();
            }
            pCurrSV->Release();
        }
    }

    return hr;
}


// Attach intelliforms to FORM elements on page
HRESULT CIEFrameAuto::COmWindow::AttachIntelliForms()
{
    HRESULT hr = E_FAIL;

    if (_pIntelliForms)
    {
        ReleaseIntelliForms();
        _pIntelliForms = NULL;
    }

    IHTMLDocument2 *pDoc2=NULL;
    IDispatch *pdispDoc=NULL;

    _pAuto->get_Document(&pdispDoc);
    if (pdispDoc)
    {
        pdispDoc->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc2));
        pdispDoc->Release();
    }

    if (pDoc2)
    {
        ::AttachIntelliForms(this, NULL, pDoc2, &_pIntelliForms);

        pDoc2->Release();

        hr = S_OK;
    }

    if (_fIntelliFormsAskUser)
    {
        // Possibly ask user if they'd like to enable this feature
        IntelliFormsDoAskUser(_pAuto->_GetHWND(), NULL); // NULL from _GetHWND() OK
        _fIntelliFormsAskUser=FALSE;
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::ReleaseIntelliForms()
{
    if (_pIntelliForms)
    {
        void *p = _pIntelliForms;
        _pIntelliForms = NULL;
        ::ReleaseIntelliForms(p);
    }

    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::DestroyIntelliForms()
{
    ReleaseIntelliForms();

    return S_OK;
}

// Request from Intelliforms that we prompt user on next load about
//  enabling the Intelliforms feature
HRESULT CIEFrameAuto::COmWindow::IntelliFormsAskUser(LPCWSTR pwszValue)
{
    _fIntelliFormsAskUser = TRUE;

    return S_OK;
}

/******************************************************************************
 This method is called when the browser is no longer busy and we should
 retry any navigate that we had to defer while it was busy.

******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmWindow::CanNavigate()
{
    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _omwin, this);

    pauto->_omloc.RetryNavigate();
    return S_OK;
}

STDMETHODIMP CIEFrameAuto::COmWindow::ActiveElementChanged(IHTMLElement * pHTMLElement)
{
    return IntelliFormsActiveElementChanged(_pIntelliForms, pHTMLElement);
}

STDMETHODIMP CIEFrameAuto::COmWindow::IsGalleryMeta(BOOL bFlag)
{
//    _bIsGalleryMeta = bFlag;
    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::_GetIDispatchExDelegate(IDispatchEx ** const ppdelegate)
{
    if (!ppdelegate)
        return E_POINTER;

    IDispatch *pRootDisp = 0;

    HRESULT hr = GetRootDelegate(_pAuto, &pRootDisp);
    if (SUCCEEDED(hr))
    {
        hr = pRootDisp->QueryInterface(IID_PPV_ARG(IDispatchEx, ppdelegate));
        pRootDisp->Release();
    }

    return hr;
}


// *** IHTMLFramesCollection2 ***

HRESULT CIEFrameAuto::COmWindow::item(
    /* [in] */ VARIANT *pvarIndex,
    /* [retval][out] */ VARIANT *pvarResult)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->item(pvarIndex, pvarResult);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_length(long *pl)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_length(pl);
        pWindow->Release();
    }

    return hr;
}

// *** IHTMLWindow2 ***

HRESULT CIEFrameAuto::COmWindow::get_name(BSTR *retval)
{
    if (!retval)
        return E_POINTER;

    WCHAR *real_frame_name = 0;
    WCHAR *use_frame_name = 0;

    // Why doesn't GetFrameName use BSTR?
    HRESULT hr = _pAuto->GetFrameName(&real_frame_name);

    if (FAILED(hr))
        return hr;

    // If the frame's name is our special NO_NAME_NAME
    // then our name is really be an empty string.
    if (!real_frame_name || !StrCmpNW(real_frame_name, NO_NAME_NAME, ARRAYSIZE(NO_NAME_NAME) -1))
        use_frame_name = L"";
    else
        use_frame_name = real_frame_name;

    ASSERT(use_frame_name);
    *retval = SysAllocString(use_frame_name);

    if (real_frame_name)
        OleFree(real_frame_name);

    return *retval ? S_OK : E_OUTOFMEMORY;
}

HRESULT CIEFrameAuto::COmWindow::put_name(
    /* [in] */ BSTR theName)
{
    if (!theName)
        return E_POINTER;

    return _pAuto->SetFrameName(theName);
}

HRESULT CIEFrameAuto::COmWindow::get_parent(IHTMLWindow2 **retval)
{
    if (!retval)
        return E_POINTER;

    HRESULT hr = E_FAIL;
    IHTMLWindow2 *pWindow = NULL;

    // Attempt to delegate this to the contained object.
    if (_fDelegateWindowOM)
    {
        hr = _GetWindowDelegate(&pWindow);
        if (SUCCEEDED(hr) && pWindow)
        {
            hr = pWindow->get_parent(retval);
        }
    }

    // If delegation fails, use our implementation.
    if (FAILED(hr))
    {
        *retval = 0;
        IUnknown *pUnk = 0;

        hr = _pAuto->GetParentFrame(&pUnk);

        // If we are already the top, GetParentFrame set pUnk to NULL
        if (SUCCEEDED(hr))
        {
            if (pUnk)
            {
                hr = GetWindowFromUnknown(pUnk, retval);
                pUnk->Release();
            }
            else
            {
                *retval = this;
                AddRef();
            }
        }
    }

    SAFERELEASE(pWindow);
    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_self(IHTMLWindow2 **retval)
{
    if (!retval)
        return E_POINTER;

    *retval = this;
    AddRef();

    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::get_top(IHTMLWindow2 **retval)
{
    if (!retval)
        return E_POINTER;

    HRESULT hr = E_FAIL;
    IHTMLWindow2 *pWindow = NULL;

    // Attempt to delegate this to contained object.
    if (_fDelegateWindowOM)
    {
        hr = _GetWindowDelegate(&pWindow);
        if (SUCCEEDED(hr) && pWindow)
        {
            hr = pWindow->get_top(retval);
        }
    }

    // If delegation fails, use our implementation.
    if (FAILED(hr))
    {
        *retval = 0;
        IUnknown *pUnk = 0;

        // AddRef the interface to we can Release it in the while loop
        ITargetFrame2 *pTfr = _pAuto;
        pTfr->AddRef();

        hr = pTfr->GetParentFrame(&pUnk);

        // Keep calling GetParent until we fail or get a NULL (which is the top
        while (SUCCEEDED(hr) && pUnk)
        {
            SAFERELEASE(pTfr);
            hr = pUnk->QueryInterface(IID_PPV_ARG(ITargetFrame2, &pTfr));
            pUnk->Release();

            if (SUCCEEDED(hr))
                hr = pTfr->GetParentFrame(&pUnk);
        }

        if (SUCCEEDED(hr))
            hr = GetWindowFromUnknown(pTfr, retval);

        SAFERELEASE(pTfr);
    }

    SAFERELEASE(pWindow);
    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_window(IHTMLWindow2 **retval)
{
    if (!retval)
        return E_POINTER;

    *retval = this;
    AddRef();
    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::get_frames(IHTMLFramesCollection2 **retval)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_frames(retval);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_location(IHTMLLocation **retval)
{
    if (!retval)
        return E_POINTER;

    *retval = &_pAuto->_omloc;
    (*retval)->AddRef();
    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::get_navigator(IOmNavigator **retval)
{
    if (!retval)
        return E_POINTER;

    *retval = &_pAuto->_omnav;
    (*retval)->AddRef();
    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::get_clientInformation(IOmNavigator **retval)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_clientInformation(retval);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_history(IOmHistory **retval)
{
    if (!retval)
        return E_POINTER;

    *retval = &_pAuto->_omhist;
    (*retval)->AddRef();
    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::put_defaultStatus(BSTR statusmsg)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->put_defaultStatus(statusmsg);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_defaultStatus(BSTR *retval)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_defaultStatus(retval);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_status(BSTR statusmsg)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->put_status(statusmsg);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_status(BSTR *retval)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_status(retval);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::setTimeout(
    /* [in] */ BSTR expression,
    /* [in] */ long msec,
    /* [optional] */ VARIANT *language,
    /* [retval][out] */ long *timerID)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->setTimeout(expression, msec, language, timerID);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::clearTimeout(long timerID)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->clearTimeout(timerID);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::setInterval(
    /* [in] */ BSTR expression,
    /* [in] */ long msec,
    /* [optional] */ VARIANT *language,
    /* [retval][out] */ long *timerID)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->setInterval(expression, msec, language, timerID);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::clearInterval(long timerID)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->clearInterval(timerID);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::alert(BSTR message)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->alert(message);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::focus()
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->focus();
        pWindow->Release();
    }

    return hr;
}


HRESULT CIEFrameAuto::COmWindow::close()
{
    IUnknown *pUnk = 0;
    HRESULT hr;

    if (_pAuto->_psb != _pAuto->_psbProxy) //if it's a band, just hide it
    {
        return IUnknown_ShowBrowserBar(_pAuto->_psbTop, CLSID_SearchBand, FALSE);
    }

    hr = _pAuto->GetParentFrame(&pUnk);

    if (SUCCEEDED(hr))
    {
        if (!pUnk)
        {
            if (_fIsChild ||
                IDYES == MLShellMessageBox(
                                         _pAuto->_GetHWND(),  // NULL from _GetHWND() OK
                                         MAKEINTRESOURCE(IDS_CONFIRM_SCRIPT_CLOSE_TEXT),
                                         MAKEINTRESOURCE(IDS_TITLE),
                                         MB_YESNO | MB_ICONQUESTION))
            {
                _pAuto->Quit();
            }
        }
        else
            pUnk->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::blur()
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->blur();
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::scroll(long x, long y)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->scroll(x, y);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::confirm(
    /* [optional] */ BSTR message,
    /* [retval][out] */VARIANT_BOOL* confirmed)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->confirm(message, confirmed);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::prompt(
    /* [optional] */ BSTR message,
    /* [optional] */ BSTR defstr,
    /* [retval][out] */ VARIANT* textdata)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->prompt(message, defstr, textdata);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_closed(VARIANT_BOOL *pl)
{
    *pl = 0;
    return S_OK;
}

#ifdef NO_MARSHALLING

HRESULT CIEFrameAuto::COmWindow::IsWindowActivated()
{
    ASSERT(_pAuto);

    BOOL fComplete = FALSE;

    // Check for proper readystate support
    IDispatch *pdispatch;
    if (SUCCEEDED(_pAuto->get_Document(&pdispatch)))
    {
        VARIANTARG va;
        EXCEPINFO excp;

        if (SUCCEEDED(pdispatch->Invoke(DISPID_READYSTATE,
                                         IID_NULL,
                                         LOCALE_USER_DEFAULT,
                                         DISPATCH_PROPERTYGET,
                                         (DISPPARAMS *)&g_dispparamsNoArgs,
                                         &va,
                                         &excp,
                                         NULL)))
        {
            if (VT_I4 == va.vt && READYSTATE_COMPLETE == va.lVal)
                fComplete = TRUE;
        }

        pdispatch->Release();
    }

    return (fComplete?S_OK:S_FALSE);
}

#endif

// *** IHTMLWindow2 ***

HRESULT CIEFrameAuto::COmWindow::open(
            /* [in] */ BSTR url,
            /* [in] */ BSTR name,
            /* [in] */ BSTR features,
            /* [in] */ VARIANT_BOOL replace,
            /* [out][retval] */ IHTMLWindow2 **ppomWindowResult)
{
    // bradsch 11/11/96 this needs to be added back in at some point.
/*
    // If the host does not support multiple windows in the same thread,
    // then disable window.open
    if (!g_fMultipleWindowsSupportedByHost)
    {
        // Hide the resulting error message from the user
        if (m_pParser)
            m_pParser->ShowErrors(FALSE);
        return E_NOTIMPL;
    }
*/
    ASSERT(ppomWindowResult);

    if (!ppomWindowResult)
        return E_POINTER;

    HRESULT hr = S_OK;

    BSTR bstrUrl = NULL;
    BSTR bstrWindowName = NULL;
    BSTR bstrUrlAbsolute = NULL;

    _OpenOptions.ReInitialize();

    // Process parameter: url
    if (!url)
    {
        // if the URL is empty, use blank.htm instead
        bstrUrl = SysAllocString(L"");
    }

    // Process parameter: name
    if (name)
    {
        // Make sure we have a legal name
        for(int i = 0; i < lstrlenW(name); i++)
        {
            if (!(IsCharAlphaNumericWrapW(name[i]) || TEXT('_') == name[i]))
            {
                hr = E_INVALIDARG;
                goto Exit;
            }
        }
    }

    // Process parameter: features
    if (features && lstrlenW(features) > 0)
    {
        hr = _ParseOptionString(features);
        if (hr)
            goto Exit;
    }

    //
    // ***TLL*** shdocvw needs to handle the replace parameter.
    //

    // Compute the absolute version of the URL
    if (!bstrUrl || *bstrUrl)
    {
        if (url)
        {
            if (*url == EMPTY_URL)
            {
                bstrUrlAbsolute = SysAllocString(url);
            }
            else
            {
                bstrUrlAbsolute = _pAuto->_omloc.ComputeAbsoluteUrl(bstrUrl ? bstrUrl : url);
            }
        }
    }
    else
    {
        bstrUrlAbsolute = bstrUrl;
        bstrUrl = NULL;
    }

    if (!bstrUrlAbsolute)
        goto Exit;

    // If a window name is not provided we need to assign it a private name
    // so we do not lose track of it. If the window name is "_blank" we need
    // to create a new window each time with a private name. Other portions
    // of this class must be smart enough to return and an empty string when
    // this private name is used.
    if (!name || !*name || (*name && !StrCmpW(name, L"_blank")))
    {
        bstrWindowName = _GenerateUniqueWindowName();
    }

    // Window open state tracking
    _fCallbackOK = FALSE;
    *ppomWindowResult = NULL;

    // Try to navigate a frame in an existing window to the url or open a new one
    hr = OpenAndNavigateToURL(_pAuto,
                               &bstrUrlAbsolute,
                               bstrWindowName ? bstrWindowName : name,
                               SAFECAST(this, ITargetNotify*),
                               replace,
                               BOOLIFY(_pAuto->m_bSilent));

    if (SUCCEEDED(hr))
    {
        if (_fCallbackOK)
        {
            *ppomWindowResult = _pOpenedWindow;
            _pOpenedWindow = NULL;
            ASSERT(*ppomWindowResult);

#ifdef NO_MARSHALLING
            MSG msg;
            while (GetMessage(&msg, NULL, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);

                IWindowStatus *pws;
                if ((*ppomWindowResult) && SUCCEEDED((*ppomWindowResult)->QueryInterface(IID_PPV_ARG(IWindowStatus, &pws))))
                {
                    if (pws->IsWindowActivated() == S_OK)
                    {
                        pws->Release();
                        break;
                    }
                    pws->Release();
                }
                else
                    break;
            }
#endif

        }

        // This might turn an S_FALSE into an S_OK, but is needed to keep Trident happy.
        // Change this back to if (hr != S_FALSE) hr = E_FAIL,
        //         change BASESB.CPP to return S_FALSE instead of S_OK on a busy navigate,
        //         and change Trident to handle S_FALSE from window.open (RRETURN1(hr, S_FALSE));
        // hr = S_OK;
    }


Exit:
    SAFERELEASE(_pOpenedWindow);

    // Clean up the unique name if we generated it ourself
    if (bstrUrl)
        SysFreeString(bstrUrl);
    if (bstrUrlAbsolute)
        SysFreeString(bstrUrlAbsolute);
    if (bstrWindowName)
        SysFreeString(bstrWindowName);

    return hr;
}

BSTR CIEFrameAuto::COmWindow::_GenerateUniqueWindowName()
{
    WCHAR buffer[ ARRAYSIZE(NO_NAME_NAME) + 12 ];

    // Choose a name the user isn't likely to typed. Need to guard
    // this becuase s_uniqueIndex is a shared static variable.
    ENTERCRITICAL;
    unsigned long val = ++s_uniqueIndex;
    LEAVECRITICAL;

    StringCchPrintf(buffer, ARRAYSIZE(buffer), L"%ls%lu", NO_NAME_NAME, val);

    return SysAllocString(buffer);
}

//
// Zhenbinx - Trident only talks OM Unit, not device unit.
//
class CHiResUnitConvert
{
public:
    CHiResUnitConvert(IHTMLWindow2 *pWindow2)
        : _pWindow2(pWindow2)
    {
        if (_pWindow2)
        {
            _pWindow2->AddRef();
        }
        _llogicalXDPI = _llogicalYDPI = 1;
        _ldeviceXDPI = _ldeviceYDPI = 1;
        _fInited = FALSE;
    }
    ~CHiResUnitConvert()
    {
        if (_pWindow2)
        {
            _pWindow2->Release();
        }
    }

    HRESULT Init();
    
    LONG  DeviceFromDocPixelsX(LONG cx)
    {
        if (!_fInited)  Init();
        return cx * _ldeviceXDPI / _llogicalXDPI;
    }
    LONG  DeviceFromDocPixelsY(LONG cy)
    {
        if (!_fInited)  Init();
        return cy * _ldeviceYDPI / _llogicalYDPI;
    }
    
private:
    IHTMLWindow2  *_pWindow2;
    BOOL          _fInited;
    LONG    _llogicalXDPI;
    LONG    _llogicalYDPI;
    LONG    _ldeviceXDPI;
    LONG    _ldeviceYDPI;
};


HRESULT  CHiResUnitConvert::Init()
{
    HRESULT hr = S_OK;
    IHTMLScreen  *pScreen = NULL;
    IHTMLScreen2 *pScreen2 = NULL;

    if (!_pWindow2)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    _fInited = TRUE;
    hr = _pWindow2->get_screen(&pScreen);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pScreen->QueryInterface(IID_PPV_ARG(IHTMLScreen2, &pScreen2));
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pScreen2->get_logicalXDPI(&_llogicalXDPI);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pScreen2->get_logicalYDPI(&_llogicalYDPI);
    if (!SUCCEEDED(hr))
        goto Cleanup;
    
    hr = pScreen2->get_deviceXDPI(&_ldeviceXDPI);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pScreen2->get_deviceYDPI(&_ldeviceYDPI);
    if (!SUCCEEDED(hr))
        goto Cleanup;

#if DBG == 1
    {
        WCHAR wcBuffer[255];    
        StringCchPrintf(wcBuffer, ARRAYSIZE(wcBuffer), _T("logical: [%d]-[%d], device: [%d]-[%d]"), _llogicalXDPI, _llogicalYDPI, _ldeviceXDPI, _ldeviceYDPI);
        OutputDebugString(wcBuffer);
    }
#endif

Cleanup:
    if (pScreen)
        pScreen->Release();
    if (pScreen2)
        pScreen2->Release();
    
    return hr;
}


HRESULT CIEFrameAuto::COmWindow::_ParseOptionString(BSTR bstrOptionString, ITargetNotify2 * ptgnNotify2 /* = NULL */)
{
    BSTR optionName = NULL;
    BSTR optionValue = NULL;
    int fValue = TRUE;
    BOOL fFirstSet = TRUE;
    IHTMLWindow2  *pWindow =  NULL;

    BOOL fFullScreen = FALSE;
    BOOL fChannelMode = FALSE;

    if (!SUCCEEDED(_GetWindowDelegate(&pWindow)) && ptgnNotify2)
    {
        ptgnNotify2->QueryInterface(IID_PPV_ARG(IHTMLWindow2, &pWindow));
    }

    CHiResUnitConvert   unitcvt(pWindow);

    // CHiResUnitConvert's constructor AddRefs pWindow, we can release this here
    if (pWindow)
        pWindow->Release();

    // Parse the options
    while (GetNextOption(bstrOptionString, &optionName, &fValue))
    {
        if (fFirstSet)
        {
            //  Netscape's interpretation is, if you set any open options
            //  then, unless explicitly set, turn off various UI options
            _OpenOptions.fToolbar = FALSE;
            _OpenOptions.fLocation = FALSE;
            _OpenOptions.fDirectories = FALSE;
            _OpenOptions.fStatus = FALSE;
            _OpenOptions.fMenubar = FALSE;
            _OpenOptions.fScrollbars = FALSE;
            _OpenOptions.fResizable = FALSE;
            fFirstSet = FALSE;
        }
        if (!StrCmpIW(L"toolbar", optionName))
            _OpenOptions.fToolbar = fValue;
        else if (!StrCmpIW(L"location", optionName))
            _OpenOptions.fLocation = fValue;
        else if (!StrCmpIW(L"directories", optionName))
            _OpenOptions.fDirectories = fValue;
        else if (!StrCmpIW(L"status", optionName))
            _OpenOptions.fStatus = fValue;
        else if (!StrCmpIW(L"menubar", optionName))
            _OpenOptions.fMenubar = fValue;
        else if (!StrCmpIW(L"scrollbars", optionName))
            _OpenOptions.fScrollbars = fValue;
        else if (!StrCmpIW(L"resizable", optionName))
            _OpenOptions.fResizable = fValue;
        else if (!StrCmpIW(L"width", optionName))
             _OpenOptions.iWidth = unitcvt.DeviceFromDocPixelsX(fValue);
        else if (!StrCmpIW(L"height", optionName))
             _OpenOptions.iHeight = unitcvt.DeviceFromDocPixelsY(fValue);
        else if (!StrCmpIW(L"fullscreen", optionName))
            fFullScreen = fValue;
        else if (!StrCmpIW(L"top", optionName))
            _OpenOptions.iTop = unitcvt.DeviceFromDocPixelsY(fValue);
        else if (!StrCmpIW(L"left", optionName))
            _OpenOptions.iLeft = unitcvt.DeviceFromDocPixelsX(fValue);
        else if (!StrCmpIW(L"channelmode", optionName))
            fChannelMode = fValue;
        else if (!StrCmpIW(L"titlebar", optionName))
            _OpenOptions.fTitlebar = fValue;

        SysFreeString(optionName);
    }

    // We no longer allow fullscreen mode. However,
    // setting channel and fullscreen does something
    // different that we want to keep
    if (fFullScreen && fChannelMode)
    {
        _OpenOptions.fChannelMode = TRUE;
        _OpenOptions.fFullScreen = TRUE;
    }
    else if (fFullScreen || fChannelMode)
    {
        _OpenOptions.fChannelMode = TRUE;
    }

    return S_OK;
}


// *** ITargetNotify members ***

/******************************************************************************
  Called when navigate must create a new window.  pUnkDestination is
  IWebBrowserApp object for new frame (also HLinkFrame,ITargetFrame).
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::OnCreate(IUnknown *pUnkDestination, ULONG cbCookie)
{
    if (!pUnkDestination)
    {
        _fCallbackOK = FALSE;
        return E_FAIL;
    }

    IWebBrowser2 *pNewIE = NULL;
    HRESULT hr = pUnkDestination->QueryInterface(IID_PPV_ARG(IWebBrowser2, &pNewIE));

    if (SUCCEEDED(hr))
    {
        _ApplyOpenOptions(pNewIE);

        SAFERELEASE(_pOpenedWindow);
        // We do not want to release this window. It will be handed out
        // to caller of window.open. It is up to the caller to release it.
        hr = GetWindowFromUnknown(pUnkDestination, &_pOpenedWindow);
        if (SUCCEEDED(hr))
        {
            VARIANT var, varDummy;
            VariantInit(&var);
            VariantInit(&varDummy);
            var.vt = VT_DISPATCH;
            var.pdispVal = static_cast<CAutomationStub*>(this);

            // call dummy put_opener in order to make use of its marshalling to set
            // child flag in opened window
            V_VT(&varDummy) = VT_BOOL;
            V_BOOL(&varDummy) = 666;
            hr = _pOpenedWindow->put_opener(varDummy);

            // set actual opener
            hr = _pOpenedWindow->put_opener(var);
        }

        //bradsch 10/27/96
        //Need some code here that tells the IWebBrowserApp not to persist its state.
        //This capability does not yet exist on IWebBrowserApp, mikesch is adding it.

        pNewIE->Release();
    }

    if (SUCCEEDED(hr))
        _fCallbackOK = TRUE;

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::OnReuse(IUnknown *pUnkDestination)
{
    if (!pUnkDestination)
    {
        _fCallbackOK = FALSE;
        return E_FAIL;
    }

    SAFERELEASE(_pOpenedWindow);

    // We do not want to release this window. It will be handed out
    // to caller of window.open. It is up to the caller to release it.
    HRESULT hr = GetWindowFromUnknown(pUnkDestination, &_pOpenedWindow);

    if (SUCCEEDED(hr))
        _fCallbackOK = TRUE;

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::_ApplyOpenOptions(IWebBrowser2 *pie)
{
    BOOL fMinusOne = FALSE;

    ASSERT(pie);

    // test TRUE explictly, as "2" is used as not inited
    if (TRUE == _OpenOptions.fChannelMode)
    {
        pie->put_TheaterMode(-1);

        if (!SHRestricted2W(REST_NoChannelUI, NULL, 0))
        {
            SA_BSTRGUID  strGuid;
            VARIANT      vaGuid;

            InitFakeBSTR(&strGuid, CLSID_FavBand);

            vaGuid.vt = VT_BSTR;
            vaGuid.bstrVal = strGuid.wsz;

            pie->ShowBrowserBar(&vaGuid, NULL, NULL);
        }
    }
    else if (_OpenOptions.fLocation
        || _OpenOptions.fDirectories
        || (_OpenOptions.fToolbar && _OpenOptions.fToolbar != CIEFrameAuto::COmWindow::BOOL_NOTSET)
        || _OpenOptions.fMenubar)
    {
        // If either "location=yes" (Address bar) or "directories=yes" (Quick Links bar) or
        // "toolbar=yes" are on, we need the internet toolbar to be on.
        // Then we can turn off the bands we don't want.
        //
        pie->put_ToolBar(TRUE);

        // We need to use the ShowBrowserBar method to handle bars/bands for which we don't have individual
        // properties.
        //
        VARIANT varClsid, varShow, varOptional;

        VariantInit(&varClsid);
        VariantInit(&varShow);
        VariantInit(&varOptional);

        varClsid.vt = VT_I2;

        varShow.vt = VT_BOOL;
        varShow.boolVal = VARIANT_FALSE;

        varOptional.vt = VT_ERROR;
        varOptional.scode = DISP_E_PARAMNOTFOUND;

        // "location=yes/no"
        //
        pie->put_AddressBar(BOOLIFY(_OpenOptions.fLocation));
        fMinusOne = fMinusOne || !_OpenOptions.fLocation;

        // "toolbar=yes/no"
        //
        varClsid.iVal = FCW_TOOLBAND;
        varShow.boolVal = TO_VARIANT_BOOL(_OpenOptions.fToolbar);
        pie->ShowBrowserBar(&varClsid, &varShow, &varOptional);
        fMinusOne = fMinusOne || !_OpenOptions.fToolbar;

        // "directories=yes/no"
        //
        varClsid.iVal = FCW_LINKSBAR;
        varShow.boolVal = TO_VARIANT_BOOL(_OpenOptions.fDirectories);
        pie->ShowBrowserBar(&varClsid, &varShow, &varOptional);
        fMinusOne = fMinusOne || !_OpenOptions.fDirectories;
    }
    else
    {
        pie->put_ToolBar(FALSE);
    }

    // "statusbar=yes/no"
    //
    pie->put_StatusBar(BOOLIFY(_OpenOptions.fStatus));
    fMinusOne = fMinusOne || !_OpenOptions.fStatus;

    // "menubar=yes/no"
    //
    pie->put_MenuBar(BOOLIFY(_OpenOptions.fMenubar));
    fMinusOne = fMinusOne || !_OpenOptions.fMenubar;

    if (CIEFrameAuto::COmWindow::BOOL_NOTSET != _OpenOptions.fFullScreen)
        pie->put_FullScreen(_OpenOptions.fFullScreen);

    if (_OpenOptions.fScrollbars == FALSE)
    {
        DWORD dwFlags;
        LPTARGETFRAME2 ptgf;

        if (SUCCEEDED(pie->QueryInterface(IID_PPV_ARG(ITargetFrame2, &ptgf))))
        {
            if (SUCCEEDED(ptgf->GetFrameOptions(&dwFlags)))
            {
                if (_OpenOptions.fScrollbars == FALSE)
                {
                    dwFlags &= ~(FRAMEOPTIONS_SCROLL_YES|FRAMEOPTIONS_SCROLL_NO|FRAMEOPTIONS_SCROLL_AUTO);
                    dwFlags |= FRAMEOPTIONS_SCROLL_NO;
                }
                ptgf->SetFrameOptions(dwFlags);
            }
            ptgf->Release();
        }
    }

    pie->put_Resizable(BOOLIFY(_OpenOptions.fResizable));

    // Only use the position and size information if the
    // the script does not enable full-screen mode
    if (TRUE != _OpenOptions.fFullScreen)
    {
        CIEFrameAuto * pFrameAuto = SAFECAST(pie, CIEFrameAuto *);
        if (pFrameAuto)
            pFrameAuto->put_Titlebar(_OpenOptions.fTitlebar);

        // If the script specifies no size or positional information and
        // the current window is in FullScreen mode then open the new
        // window in FullScreen mode as well.
        if (_OpenOptions.iWidth < 0 && _OpenOptions.iHeight < 0 && _OpenOptions.iTop < 0 && _OpenOptions.iLeft < 0)
        {
            VARIANT_BOOL fs = 0;
            CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _omwin, this);

            HRESULT hr = pauto->get_FullScreen(&fs);
            if (SUCCEEDED(hr) && fs)
                pie->put_FullScreen(fs);
        }
        else
        {
            int iWidth = _OpenOptions.iWidth > 0 ? _OpenOptions.iWidth:300;
            int iHeight = _OpenOptions.iHeight > 0 ? _OpenOptions.iHeight:300;

            // Set a minimum size of 100x100
            iWidth = iWidth > 100 ? iWidth : 100;
            iHeight = iHeight > 100 ? iHeight : 100;

            //  Yes! Netscape doesn't treat the width and height as a content
            //  size when at least one adornment is turned off
            if (fMinusOne) pie->ClientToWindow(&iWidth, &iHeight);
            if (_OpenOptions.iWidth > 0)
                pie->put_Width(iWidth);
            if (_OpenOptions.iHeight > 0)
                pie->put_Height(iHeight);

            if (_OpenOptions.iTop >= 0)
                pie->put_Top(_OpenOptions.iTop);
            if (_OpenOptions.iLeft >= 0)
                pie->put_Left(_OpenOptions.iLeft);
        }
    }

    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::get_document(IHTMLDocument2 **ppomDocumentResult)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_document(ppomDocumentResult);
        pWindow->Release();
    }

    return hr;
}


HRESULT CIEFrameAuto::COmWindow::navigate(BSTR url)
{
    // This will do all the fun things that must be done
    // to an URL before is can be used to navigate.
    return _pAuto->_omloc.put_href(url);
}


/******************************************************************************
get_opener -

    Returns the value of the opener property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_opener(
    /* [retval][out] */ VARIANT *pretval)
{
    if (!pretval)
        return E_POINTER;

    return VariantCopy(pretval, &_varOpener);
}

/******************************************************************************
put_opener -

    Sets the opener property opener of this window. This method may
    be called either internally (from C++ code) or from a script. We must
    Release our current opener if the new opener is valid (or VT_NULL).

    COmWindow's DeInit method ensures this never causes a circular reference
    when this object is in the same thread as "opener".
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::put_opener(VARIANT opener)
{

    // piggy back on put_opener's marshalling to set child flag. This will be called
    // with VT_TYPE==VT_BOOL and a value of 666 only from oncreate(). Chances of this
    // happening from script is very remote.

    if (!_fIsChild && V_VT(&opener) == VT_BOOL && V_BOOL(&opener) == 666)
    {
        _fIsChild = TRUE;
        return S_OK;
    }

    return VariantCopy(&_varOpener, &opener);
}


/******************************************************************************
executScript -

      immediately executes the script passed in. needed for the multimedia
      controls
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::execScript(
    /* [in] */ BSTR bstrCode,
    /* [in] */ BSTR bstrLanguage,
    /* [out] */ VARIANT *pvarRet)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->execScript(bstrCode, bstrLanguage, pvarRet);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_onblur(VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_onblur(p);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onblur(
    /* [in] */ VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->put_onblur(v);
        pWindow->Release();
    }

    return hr;
}

/******************************************************************************
get_onfocus -

    Returns the value of the onfocus property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_onfocus(VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_onfocus(p);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onfocus(
    /* [in] */ VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->put_onfocus(v);
        pWindow->Release();
    }

    return hr;
}

/******************************************************************************
get_onload -

    Returns the value of the onload property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_onload(
    /* [p][out] */ VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_onload(p);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onload(VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->put_onload(v);
        pWindow->Release();
    }

    return hr;
}

/******************************************************************************
get_onunload -

    Returns the value of the onunload property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_onunload(
    /* [p][out] */ VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_onunload(p);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onunload(VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->put_onunload(v);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onbeforeunload(VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->put_onbeforeunload(v);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_onbeforeunload(VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_onbeforeunload(p);
        pWindow->Release();
    }

    return hr;
}

/******************************************************************************
get_onhelp -

    Returns the value of the onhelp property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_onhelp(
    /* [p][out] */ VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_onhelp(p);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onhelp(VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->put_onhelp(v);
        pWindow->Release();
    }

    return hr;
}
/******************************************************************************
get_onresize -

    Returns the value of the resize property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_onresize(
    /* [p][out] */ VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_onresize(p);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onresize(VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->put_onresize(v);
        pWindow->Release();
    }

    return hr;
}
/******************************************************************************
get_onscroll -

    Returns the value of the onscroll property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_onscroll(
    /* [p][out] */ VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_onscroll(p);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onscroll(VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->put_onscroll(v);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_Image(IHTMLImageElementFactory **retval)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_Image(retval);
        pWindow->Release();
    }

    return hr;
}
/******************************************************************************
get_onerror -

    Returns the value of the onerror property.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::get_onerror(
    /* [p][out] */ VARIANT *p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_onerror(p);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onerror(VARIANT v)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->put_onerror(v);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_event(IHTMLEventObj **p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_event(p);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get__newEnum(IUnknown **p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get__newEnum(p);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::showModalDialog(BSTR dialog,
                                                 VARIANT* varArgIn,
                                                 VARIANT* varOptions,
                                                 VARIANT* varArgOut)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->showModalDialog(dialog, varArgIn, varOptions, varArgOut);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::showHelp(BSTR helpURL, VARIANT helpArg, BSTR features)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->showHelp(helpURL, helpArg, features);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_screen(IHTMLScreen **p)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_screen(p);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_Option(IHTMLOptionElementFactory **retval)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_Option(retval);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::toString(BSTR *Str)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->toString(Str);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::scrollBy(long x, long y)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->scrollBy(x, y);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::scrollTo(long x, long y)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->scrollTo(x, y);
        pWindow->Release();
    }

    return hr;
}


HRESULT CIEFrameAuto::COmWindow::get_external(IDispatch **ppDisp)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_external(ppDisp);
        pWindow->Release();
    }

    return hr;
}

// ****  IHTMLWindow3 ****

HRESULT CIEFrameAuto::COmWindow::print()
{
    IHTMLWindow3 *pWindow = NULL;
    HRESULT       hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->print();
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::showModelessDialog(BSTR strUrl,
                                     VARIANT * pvarArgIn,
                                     VARIANT * pvarOptions,
                                     IHTMLWindow2 ** ppDialog)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->showModelessDialog(strUrl,
                                           pvarArgIn,
                                           pvarOptions,
                                           ppDialog);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onbeforeprint(VARIANT v)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->put_onbeforeprint(v);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_onbeforeprint(VARIANT *p)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_onbeforeprint(p);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::put_onafterprint(VARIANT v)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->put_onafterprint(v);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_onafterprint(VARIANT *p)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_onafterprint(p);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_screenTop(long *plVal)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_screenTop(plVal);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_screenLeft(long *plVal)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_screenLeft(plVal);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_clipboardData(IHTMLDataTransfer **ppDataTransfer)
{
    IHTMLWindow3 *pWindow = NULL;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_clipboardData(ppDataTransfer);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::attachEvent(BSTR event, IDispatch* pDisp, VARIANT_BOOL *pResult)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->attachEvent(event, pDisp, pResult);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::detachEvent(BSTR event, IDispatch* pDisp)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->detachEvent(event, pDisp);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::setTimeout(
    /* [in] */ VARIANT *pExpression,
    /* [in] */ long msec,
    /* [optional] */ VARIANT *language,
    /* [retval][out] */ long *timerID)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->setTimeout(pExpression, msec, language, timerID);
        pWindow->Release();
    }

    return hr;
}


HRESULT CIEFrameAuto::COmWindow::setInterval(
    /* [in] */ VARIANT *pExpression,
    /* [in] */ long msec,
    /* [optional] */ VARIANT *language,
    /* [retval][out] */ long *timerID)
{
    IHTMLWindow3 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->setInterval(pExpression, msec, language, timerID);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::moveTo(long x, long y)
{
    HWND hwnd = _pAuto->_GetHWND();

    if (!hwnd)
        return S_OK;

    ::SetWindowPos(hwnd, NULL, x, y, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);

    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::moveBy(long x, long y)
{
    HWND hwnd = _pAuto->_GetHWND();
    RECT rcWindow;

    if (!hwnd)
        return S_OK;

    ::GetWindowRect (hwnd, &rcWindow);

    ::SetWindowPos(hwnd, NULL, rcWindow.left+x, rcWindow.top+y, 0, 0, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOSIZE);

    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::resizeTo(long x, long y)
{
    HWND hwnd = _pAuto->_GetHWND();

    if (!hwnd)
        return S_OK;

    if (x < 100)
        x = 100;

    if (y < 100)
        y = 100;

    ::SetWindowPos(hwnd, NULL, 0, 0, x, y, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);

    return S_OK;
}

HRESULT CIEFrameAuto::COmWindow::resizeBy(long x, long y)
{
    HWND hwnd = _pAuto->_GetHWND();
    RECT rcWindow;
    long w, h;

    if (!hwnd)
        return S_OK;

    ::GetWindowRect (hwnd, &rcWindow);

    w = rcWindow.right - rcWindow.left + x;
    h = rcWindow.bottom - rcWindow.top + y;

    if (w < 100)
        w = 100;

    if (h < 100)
        h = 100;

    ::SetWindowPos(hwnd, NULL, 0, 0, w, h, SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOMOVE);

    return S_OK;
}


HRESULT CIEFrameAuto::COmWindow::_GetWindowDelegate(IHTMLWindow2 **ppomwDelegate)
{
    if (!ppomwDelegate)
        return E_POINTER;

    IDispatch *pRootDisp = 0;

    HRESULT hr = GetRootDelegate(_pAuto, &pRootDisp);
    if (SUCCEEDED(hr))
    {
        hr = pRootDisp->QueryInterface(IID_PPV_ARG(IHTMLWindow2, ppomwDelegate));
        pRootDisp->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::_GetWindowDelegate(IHTMLWindow3 **ppomwDelegate)
{
    if (!ppomwDelegate)
        return E_POINTER;

    IDispatch *pRootDisp = 0;

    HRESULT hr = GetRootDelegate(_pAuto, &pRootDisp);
    if (SUCCEEDED(hr))
    {
        hr = pRootDisp->QueryInterface(IID_PPV_ARG(IHTMLWindow3, ppomwDelegate));
        pRootDisp->Release();
    }

    return hr;
}


HRESULT CIEFrameAuto::COmWindow::SinkDelegate()
{
    // Force an Unadvise if we already have a connection
    if (_pCP)
        UnsinkDelegate();

    // If we do not have anyone sinking us, then we don't need to sink our
    // delegate. If someone sinks us later we will sink our delegate in
    // the IConnectionPointCB::OnAdvise callback.
    if (_cpWindowEvents.IsEmpty())
        return S_OK;

    IHTMLWindow2 *pWindow;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        // We have to connect to the event source to get Trident specific events.
      
        hr = ConnectToConnectionPoint(&_wesDelegate, DIID_HTMLWindowEvents, TRUE, pWindow, &_dwCPCookie, &_pCP);

        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::UnsinkDelegate()
{
    if (_pCP)
    {
        _pCP->Unadvise(_dwCPCookie);
        _pCP->Release();
        _pCP = 0;
        _dwCPCookie = 0;
    }

    return S_OK;
}

/******************************************************************************
 Someone has sinked our events. This means we need to sink the events of our
 delegate docobject if we have not already done so.
******************************************************************************/
HRESULT CIEFrameAuto::COmWindow::OnAdvise(REFIID iid, DWORD cSinks, ULONG_PTR dwCookie)
{
    HRESULT hr;

    if (!_pCP)
        hr = SinkDelegate();
    else
        hr = S_OK;

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::FireOnUnload()
{
    HRESULT hr;
    if (_fOnloadFired)
    {
        hr = _cpWindowEvents.InvokeDispid(DISPID_ONUNLOAD);
        _fOnloadFired = FALSE;
    }
    else
        hr = S_OK;

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::FireOnLoad()
{
    HRESULT hr;
    if (!_fOnloadFired)
    {
        hr = _cpWindowEvents.InvokeDispid(DISPID_ONUNLOAD);
        _fOnloadFired = TRUE;
    }
    else
        hr = S_OK;

    return hr;
}

/******************************************************************************
  Check of the docobject document is complete. The document is considered
  complete if either:
    - The document has reached READYSTATE_COMPLETE or
    - The document does not support the DISPID_READYSTATE property

  If the document is not complete, the caller of this method knows the
  delegate supports the READYSTATE property and will receive a future
  READYSTATE_COMPLETE notification.
******************************************************************************/
BOOL CIEFrameAuto::COmWindow::IsDelegateComplete()
{
    ASSERT(_pAuto);

    BOOL fSupportsReadystate = FALSE;
    BOOL fComplete = FALSE;

    // Check for proper readystate support
    IDispatch *pdispatch;
    if (SUCCEEDED(_pAuto->get_Document(&pdispatch)))
    {
        VARIANTARG va;
        EXCEPINFO excp;

        if (SUCCEEDED(pdispatch->Invoke(DISPID_READYSTATE,
                                         IID_NULL,
                                         LOCALE_USER_DEFAULT,
                                         DISPATCH_PROPERTYGET,
                                         (DISPPARAMS *)&g_dispparamsNoArgs,
                                         &va,
                                         &excp,
                                         NULL)))
        {
            fSupportsReadystate = TRUE;

            if (VT_I4 == va.vt && READYSTATE_COMPLETE == va.lVal)
                fComplete = TRUE;
        }

        pdispatch->Release();
    }

    return !fSupportsReadystate || fComplete;
}


STDMETHODIMP CIEFrameAuto::COmWindow::CWindowEventSink::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IUnknown)          ||
             IsEqualIID(riid, IID_IDispatch)    ||
             IsEqualIID(riid, DIID_HTMLWindowEvents)  )
    {
        *ppv = SAFECAST(this, IDispatch*);
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

/******************************************************************************
 We want to bind the lifetime of our owning object to this object
******************************************************************************/
ULONG CIEFrameAuto::COmWindow::CWindowEventSink::AddRef(void)
{
    COmWindow* pwin = IToClass(COmWindow, _wesDelegate, this);
    return pwin->AddRef();
}

/******************************************************************************
 We want to bind the lifetime of our owning object to this object
******************************************************************************/
ULONG CIEFrameAuto::COmWindow::CWindowEventSink::Release(void)
{
    COmWindow* pwin = IToClass(COmWindow, _wesDelegate, this);
    return pwin->Release();
}

// *** IDispatch ***

STDMETHODIMP CIEFrameAuto::COmWindow::CWindowEventSink::Invoke(
  DISPID dispid,
  REFIID riid,
  LCID lcid,
  WORD wFlags,
  DISPPARAMS *pdispparams,
  VARIANT *pvarResult,
  EXCEPINFO *pexcepinfo,
  UINT *puArgErr       )
{
    HRESULT hr;

    // This object just acts as a pass through for our delegate's
    // window object. Since we interally generated events for both
    //      DISPID_ONLOAD
    //      DISPID_ONUNLOAD
    // we just ignore those that are sourced by our delegate.

    if (DISPID_ONLOAD == dispid ||
        DISPID_ONUNLOAD == dispid      )
    {
        hr = S_OK;
    }
    else
    {
        COmWindow* pwin = IToClass(COmWindow, _wesDelegate, this);
        hr = pwin->_cpWindowEvents.InvokeDispid(dispid);
    }

    return hr;
}


HRESULT CIEFrameAuto::COmWindow::put_offscreenBuffering(VARIANT var)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->put_offscreenBuffering(var);
        pWindow->Release();
    }

    return hr;
}

HRESULT CIEFrameAuto::COmWindow::get_offscreenBuffering(VARIANT *retval)
{
    IHTMLWindow2 *pWindow = 0;
    HRESULT hr = _GetWindowDelegate(&pWindow);

    if (SUCCEEDED(hr))
    {
        hr = pWindow->get_offscreenBuffering(retval);
        pWindow->Release();
    }

    return hr;
}


// *** IConnectionPointContainer ***

STDMETHODIMP CIEFrameAuto::COmWindow::FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT *ppCP)
{
    ASSERT(ppCP);

    if (!ppCP)
        return E_POINTER;

    if (IsEqualIID(iid, DIID_HTMLWindowEvents) || IsEqualIID(iid, IID_IDispatch))
    {
        *ppCP = _cpWindowEvents.CastToIConnectionPoint();
    }
    else
    {
        *ppCP = NULL;
        return E_NOINTERFACE;
    }

    (*ppCP)->AddRef();
    return S_OK;
}

STDMETHODIMP CIEFrameAuto::COmWindow::EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum)
{
    return CreateInstance_IEnumConnectionPoints(ppEnum, 1,
            _cpWindowEvents.CastToIConnectionPoint());
}

/******************************************************************************
                    Location Object

// bradsch 11/12/96
// The entire COmLocation object was copied from MSHTML and is a slimy pig
// dog. It should be replaced with the new URL cracking stuff in SHLWAPI.
******************************************************************************/


CIEFrameAuto::COmLocation::COmLocation() :
    CAutomationStub(MIN_BROWSER_DISPID, MAX_BROWSER_DISPID, TRUE)
{
    ASSERT(!m_bstrFullUrl);
    ASSERT(!m_bstrPort);
    ASSERT(!m_bstrProtocol);
    ASSERT(!m_bstrHostName);
    ASSERT(!m_bstrPath);
    ASSERT(!m_bstrSearch);
    ASSERT(!m_bstrHash);
    ASSERT(FALSE == m_fdontputinhistory);
    ASSERT(FALSE == m_fRetryingNavigate);
}

HRESULT CIEFrameAuto::COmLocation::Init()
{
    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _omloc, this);
    return CAutomationStub::Init(SAFECAST(this, IHTMLLocation*), IID_IHTMLLocation, CLSID_HTMLLocation, pauto);
}

HRESULT CIEFrameAuto::COmLocation::CheckUrl()
{
    BSTR currentUrl = 0;
    HRESULT hr;
    VARIANT varUrl;

    VariantInit(&varUrl);
    hr = _pAuto->_QueryPendingUrl(&varUrl);
    if (FAILED(hr) || varUrl.vt != VT_BSTR || varUrl.bstrVal == NULL)
    {
        VariantClearLazy(&varUrl);
        hr = _pAuto->get_LocationURL(&currentUrl);
    }
    else
    {
        //  No VariantClear, we're extracting the bstrVal
        currentUrl = varUrl.bstrVal;
    }

    if (SUCCEEDED(hr))
    {
        // If our stashed URL does not match the real current URL we need to reparse everything
        if (!m_bstrFullUrl || StrCmpW(m_bstrFullUrl, currentUrl))
        {
            // This code is all going to change, so I am not worried about efficiency
            FreeStuff();

            m_bstrFullUrl = currentUrl;

            hr = ParseUrl();
        }
        else
            SysFreeString(currentUrl);
    }

    return hr;
}

HRESULT CIEFrameAuto::COmLocation::_InternalQueryInterface(REFIID riid, void ** const ppv)
{
    ASSERT(!IsEqualIID(riid, IID_IUnknown));

    if (IsEqualIID(riid, IID_IHTMLLocation))
        *ppv = SAFECAST(this, IHTMLLocation *);
    else if (IsEqualIID(riid, IID_IServiceProvider))
        *ppv = SAFECAST(this, IObjectIdentity *);
    else if (IsEqualIID(riid, IID_IObjectIdentity))
        *ppv = SAFECAST(this, IServiceProvider *);
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}

HRESULT CIEFrameAuto::COmLocation::_GetIDispatchExDelegate(IDispatchEx ** const delegate)
{
    if (!delegate)
        return E_POINTER;

    IDispatch *pRootDisp = 0;

    HRESULT hr = GetRootDelegate(_pAuto, &pRootDisp);
    if (SUCCEEDED(hr))
    {
        IDispatch *pDelegateDisp = 0;
        hr = GetDelegateOnIDispatch(pRootDisp, DISPID_LOCATIONOBJECT, &pDelegateDisp);
        pRootDisp->Release();

        if (SUCCEEDED(hr))
        {
            hr = pDelegateDisp->QueryInterface(IID_IDispatchEx, (void**)delegate);
            pDelegateDisp->Release();
        }
    }

    return hr;
}


/****************************************************************************
 IObjectIdentity  member implemtnation. this is necessary since mshtml has a locatino
 proxy that it returns, whichc is a different pUnk than the location object returned by
 shdocvw.  The script engines use this interface to resolve the difference and allow
 equality test to be perfomed on these objects.
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmLocation::IsEqualObject(IUnknown * pUnk)
{
    HRESULT hr;
    IServiceProvider * pISP = NULL;
    IHTMLLocation    * pLoc = NULL;
    IUnknown         * pUnkThis = NULL;
    IUnknown         * pUnkTarget = NULL;

    if (!pUnk)
        return E_POINTER;

    hr = pUnk->QueryInterface(IID_IServiceProvider, (void**)&pISP);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pISP->QueryService(IID_IHTMLLocation, IID_IHTMLLocation, (void**)&pLoc);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = pLoc->QueryInterface(IID_IUnknown, (void**)&pUnkTarget);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = QueryInterface(IID_IUnknown, (void**)&pUnkThis);
    if (!SUCCEEDED(hr))
        goto Cleanup;

    hr = (pUnkThis == pUnkTarget) ? S_OK : S_FALSE;

Cleanup:
    if (pISP)        ATOMICRELEASE(pISP);
    if (pLoc)        ATOMICRELEASE(pLoc);
    if (pUnkTarget)  ATOMICRELEASE(pUnkTarget);
    if (pUnkThis)    ATOMICRELEASE(pUnkThis);

    return hr;
}

/*****************************************************************************
 IServiceProvider - this is currently only used by the impl of ISEqual object
 on mshtml side,. adn only needs to return *this* when Queryied for location
 service
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmLocation::QueryService(REFGUID guidService, REFIID iid, void ** ppv)
{
    HRESULT hr = E_NOINTERFACE;

    if (!ppv)
        return E_POINTER;

    *ppv = NULL;

    if (IsEqualGUID(guidService, IID_IHTMLLocation))
    {
        *ppv = SAFECAST(this, IHTMLLocation *);
        hr = S_OK;
    }

    return hr;
}

/******************************************************************************
 Helper function for the property access functions
 Makes sure that the URL has been parsed and returns a copy
 of the requested field as a BSTR.
******************************************************************************/
HRESULT CIEFrameAuto::COmLocation::GetField(BSTR* bstrField, BSTR* pbstr)
{
    HRESULT hr;

    if (!pbstr)
        return E_INVALIDARG;

    if (!bstrField)
        return E_FAIL;

    hr = CheckUrl();
    if (FAILED(hr))
        return hr;

    *pbstr = *bstrField ? SysAllocString(*bstrField): SysAllocString(L"");
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CIEFrameAuto::COmLocation::toString (BSTR* pbstr)
{
    return GetField(&m_bstrFullUrl, pbstr);
}


STDMETHODIMP CIEFrameAuto::COmLocation::get_href(BSTR* pbstr)
{
    return GetField(&m_bstrFullUrl, pbstr);
}


STDMETHODIMP CIEFrameAuto::COmLocation::get_protocol(BSTR* pbstr)
{
    return GetField(&m_bstrProtocol, pbstr);
}

STDMETHODIMP CIEFrameAuto::COmLocation::get_hostname(BSTR* pbstr)
{
    return GetField(&m_bstrHostName, pbstr);
}

STDMETHODIMP CIEFrameAuto::COmLocation::get_host(BSTR* pbstr)
{
    HRESULT            hr;
    INT                cch;
    BOOL               fHavePort;

    hr = CheckUrl();
    if (FAILED(hr))
        return hr;

    if (!m_bstrHostName)
        return E_POINTER;

    cch = lstrlenW(m_bstrHostName);
    fHavePort = m_bstrPort && *m_bstrPort;
    if (fHavePort)
        cch += lstrlenW(m_bstrPort) + 1; // for the ":"

    *pbstr = SafeSysAllocStringLen(0, cch); // allocates cch + 1

    if (!*pbstr)
        return E_OUTOFMEMORY;

    // Get the hostname
    StrCpyNW(*pbstr, m_bstrHostName, cch + 1);

    // add additional character for colon
    // concatenate ":" and the port number, if there is a port number
    if (fHavePort)
    {
        StrCatBuffW(*pbstr, L":", cch + 1);
        StrCatBuffW(*pbstr, m_bstrPort, cch + 1);
    }

    return S_OK;
}

STDMETHODIMP CIEFrameAuto::COmLocation::get_pathname(BSTR* pbstr)
{
    // Hack for Netscape compatability -- not in Nav3 or nav4.maybe in nav2?
    // Netscape returned nothing for a path of "/"
    // we used to do this but it looks like we should follow nav3/4 now (for OMCOMPAT)

    return GetField(&m_bstrPath, pbstr);
}

STDMETHODIMP CIEFrameAuto::COmLocation::get_search(BSTR* pbstr)
{
    return GetField(&m_bstrSearch, pbstr);
}

STDMETHODIMP CIEFrameAuto::COmLocation::get_hash(BSTR* pbstr)
{
    return GetField(&m_bstrHash, pbstr);
}

STDMETHODIMP CIEFrameAuto::COmLocation::get_port(BSTR* pbstr)
{
    return GetField(&m_bstrPort, pbstr);
}

STDMETHODIMP CIEFrameAuto::COmLocation::reload(VARIANT_BOOL fFlag)
{
    VARIANT v = {0};
    v.vt = VT_I4;
    v.lVal = fFlag ?
        OLECMDIDF_REFRESH_COMPLETELY|OLECMDIDF_REFRESH_CLEARUSERINPUT :
        OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_CLEARUSERINPUT;
    return _pAuto->Refresh2(&v);
}

STDMETHODIMP CIEFrameAuto::COmLocation::replace(BSTR url)
{
    m_fdontputinhistory = TRUE;
    return put_href(url);
}

STDMETHODIMP CIEFrameAuto::COmLocation::assign(BSTR url)
{
    return put_href(url);
}

void CIEFrameAuto::COmLocation::RetryNavigate()
{
    //
    // If a page does a navigate on an unload event and the unload is happening
    // because the user shutdown the browser we would recurse to death.
    // m_fRetryingNavigate was added to fix this scenario.
    //

    if (m_fPendingNavigate && !m_fRetryingNavigate)
    {
        m_fRetryingNavigate = TRUE;
        DoNavigate();
        m_fRetryingNavigate = FALSE;
    }
}

//
//
// PrvHTParse - wrapper for Internet{Canonicalize/Combine}Url
//           which does a local allocation of our returned string so we can
//           free it as needed.
//
//
//   We start by calling InternetCanonicalizeUrl() to perform any required
//   canonicalization.  If the caller specificed PARSE_ALL, we're done at that
//   point and return the URL.  This is the most common case.
//
//   If the caller wanted parts of the URL, we will then call
//   InternetCrackUrl() to break the URL into it's components, and
//   finally InternetCreateUrl() to give us a string with just those
//   components.
//
//   ICU() has a bug which forces it to always prepend a scheme, so we have
//   some final code at the end which removes the scheme if the caller
//   specifically did not want one.
//

#define STARTING_URL_SIZE        127           // 128 minus 1
#define PARSE_ACCESS            16
#define PARSE_HOST               8
#define PARSE_PATH               4
#define PARSE_ANCHOR             2
#define PARSE_PUNCTUATION        1
#define PARSE_ALL               31

BSTR PrvHTParse(BSTR bstraName, BSTR bstrBaseName, int wanted)
{
    DWORD cchP = STARTING_URL_SIZE+1;
    DWORD cchNeed = cchP;
    BOOL      rc;
    HRESULT hr;

    if ((!bstraName && !bstrBaseName))
        return NULL;

    WCHAR *p = new WCHAR[cchP];
    if (!p)
        return NULL;

    // ICU() does not accept NULL pointers, but it does handle "" strings
    if (!bstrBaseName)
        bstrBaseName = L"";
    if (!bstraName)
        bstraName = L"";

    URL_COMPONENTSW uc = {0};
    uc.dwStructSize = sizeof(uc);

    // We will retry once if the failure was due to an insufficiently large buffer
    hr = UrlCombineW(bstrBaseName, bstraName, p, &cchNeed, 0);
    if (hr == E_POINTER)
    {
        // From the code, cchNeed has the same value as if UrlCombine had succeeded, 
        // which is the length of the combined URL, excluding the null.

        cchP = ++cchNeed;
        delete [] p;
        p = new WCHAR[cchP];
        if (!p)
            goto free_and_exit;
        hr = UrlCombineW(bstrBaseName, bstraName, p, &cchNeed, 0);
    }

    if (SUCCEEDED(hr) && wanted != PARSE_ALL)
    {
        // Since CreateUrl() will ignore our request to not add a scheme,
        // we always ask it to crack one, so we can know the size if we need
        // to remove it ourselves
        uc.dwSchemeLength = INTERNET_MAX_SCHEME_LENGTH;
        uc.lpszScheme = new WCHAR[uc.dwSchemeLength];

        if (wanted & PARSE_HOST) {
            uc.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;
            uc.lpszHostName = new WCHAR[uc.dwHostNameLength];
        }
        if (wanted & PARSE_PATH) {
            uc.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;
            uc.lpszUrlPath = new WCHAR[uc.dwUrlPathLength];
        }
        if (wanted & PARSE_ANCHOR) {
            uc.dwExtraInfoLength = INTERNET_MAX_URL_LENGTH;
            uc.lpszExtraInfo = new WCHAR[uc.dwExtraInfoLength];
        }

        // if any of our allocations fail, fail the whole operation.
        if ((!uc.lpszScheme) ||
             ((wanted & PARSE_HOST) && (!uc.lpszHostName)) ||
             ((wanted & PARSE_PATH) && (!uc.lpszUrlPath)) ||
             ((wanted & PARSE_ANCHOR) && (!uc.lpszExtraInfo)))
            goto free_and_exit;

        rc = InternetCrackUrlW(p, cchNeed, 0, &uc);
        // If we are failing here, we need to figure out why and fix it
        if (!rc)
        {
            //TraceMsg(TF_WARNING, TEXT("PrvHTParse: InternetCrackUrl failed for \"\""), Dbg_SafeStr(p));
            goto free_and_exit;   // Couldn't crack it, so give back what we can
        }

        // InternetCreateUrlW takes in a count of WCHARs but if it 
        // fails, the same variable is set to a count of bytes.  So we'll 
        // call this variable the ambiguous dwLength.  Yuck.

        cchNeed = cchP;
        DWORD dwLength = cchNeed;

        rc = InternetCreateUrlW(&uc, 0, p, &dwLength);
        if (!rc)
        {
            delete [] p;
            p = NULL;
            const DWORD err = GetLastError();
            if ((ERROR_INSUFFICIENT_BUFFER == err) && (dwLength > 0))
            {
                // dwLength comes out in bytes.  We'll turn it into a char count
                // The previous ANSI version allocated one char too many 
                // but it's too risky to correct that now

                dwLength /= sizeof(WCHAR);   
                cchP = ++dwLength;  

                p = new WCHAR[cchP];
                if (!p)
                    goto free_and_exit;
                rc = InternetCreateUrlW(&uc, 0, p, &dwLength);
            }
        }  // if !rc   

        if (rc)
        {
            // The most recent InternetCreateUrl was successful, so dwLength contains
            // the number of wide chars stored in p.
            cchNeed = dwLength;

            // Special case: remove protocol if not requested.  ICU() adds
            // a protocol even if you tell it not to.

            if (!(wanted & PARSE_ACCESS))
            {
               WCHAR *q;

               // Make sure our string is sufficiently large for
               ASSERT(cchNeed > uc.dwSchemeLength);

               // For non-pluggable protocols, Add 3 for the ://, which is not counted in the scheme length, else add 1
               int cch = lstrlenW(p + uc.dwSchemeLength + ((uc.nScheme == INTERNET_SCHEME_UNKNOWN) ? 1 : 3)) + 1;
               q = new WCHAR[cch];
               if (q)
               {
                   StrCpyNW(q, (p + uc.dwSchemeLength + ((uc.nScheme == INTERNET_SCHEME_UNKNOWN) ? 1 : 3)), cch);
                   delete [] p;
                   p = q;
               }
            }
            else
            {
                if ((wanted & (~PARSE_PUNCTUATION)) == PARSE_ACCESS)
                {
                    // Special case #2: When only PARSE_ACCESS is requested,
                    // don't return the // suffix
                    p[uc.dwSchemeLength + 1] = '\0';
                }
            }
        }

    } // if wanted

free_and_exit:
    delete [] uc.lpszScheme;
    delete [] uc.lpszHostName;
    delete [] uc.lpszUrlPath;
    delete [] uc.lpszExtraInfo;

    BSTR bstrp = 0;
    if (p)
    {
        bstrp = SysAllocString(p);
        delete [] p;
    }

    return bstrp;
}


STDMETHODIMP CIEFrameAuto::COmLocation::put_href(BSTR url)
{
    HRESULT hr;

    if (!url)
        return E_INVALIDARG;

    // Call CheckUrl before PrvHTParse to ensure we have a valid URL
    hr = CheckUrl();
    if (FAILED(hr))
        return hr;

    BSTR bstrUrlAbsolute = PrvHTParse(url, m_bstrFullUrl, PARSE_ALL);

    if (!bstrUrlAbsolute )
        return E_OUTOFMEMORY;

    // Actually set the URL field
    hr = SetField(&m_bstrFullUrl, bstrUrlAbsolute, FALSE);

    SysFreeString(bstrUrlAbsolute);

    return hr;
}


STDMETHODIMP CIEFrameAuto::COmLocation::put_protocol(BSTR bstr)
{
    return SetField(&m_bstrProtocol, bstr, TRUE);
}

STDMETHODIMP CIEFrameAuto::COmLocation::put_hostname(BSTR bstr)
{
    return SetField(&m_bstrHostName, bstr, TRUE);
}

STDMETHODIMP CIEFrameAuto::COmLocation::put_host(BSTR bstr)
{
    HRESULT hr = S_OK;
    WCHAR* colonPos = 0;
    WCHAR* portName = NULL;
    WCHAR* hostName = NULL;

    hr = CheckUrl();
    if (FAILED(hr))
        return hr;

    // Parse out the hostname and port and store them in
    // the appropriate fields
    colonPos = StrChrW(bstr, L':');
    // Copy the characters up to the colon in the
    // hostname field

    if (colonPos == 0)
    {
        hostName = SysAllocString(bstr);
        portName = SysAllocString(L"");
    }
    else
    {
        hostName = SafeSysAllocStringLen(bstr, (unsigned int)(colonPos-bstr));
        portName = SafeSysAllocStringLen(colonPos+1, SysStringLen(bstr) - (unsigned int)(colonPos-bstr+1));
    }

    if (hostName && portName)
    {
        if (m_bstrHostName)
            SysFreeString(m_bstrHostName);
        if (m_bstrPort)
            SysFreeString(m_bstrPort);

        m_bstrHostName = hostName;
        m_bstrPort = portName;

        hostName = portName = 0;

        hr = ComposeUrl();
        if (SUCCEEDED(hr))
        {
            hr = DoNavigate();
        }
    }
    else
        hr = E_OUTOFMEMORY;


    if (hostName)
        SysFreeString(hostName);

    if (portName)
        SysFreeString(portName);

    return hr;
}

STDMETHODIMP CIEFrameAuto::COmLocation::put_pathname(BSTR bstr)
{
    return SetField(&m_bstrPath, bstr, TRUE);
}

STDMETHODIMP CIEFrameAuto::COmLocation::put_search(BSTR bstr)
{
    if (!bstr)
        return E_POINTER;

    // If the provided search string begins with a "?" already,
    // just use it "as is"
    if (bstr[0] == L'?')
    {
        return SetField(&m_bstrSearch, bstr, TRUE);
    }
    // Otherwise prepend a question mark
    else
    {
        // Allocate enough space for the string plus one more character ('#')
        UINT cchSearch = lstrlenW(bstr) + 1;
        BSTR bstrSearch = SafeSysAllocStringLen(L"?", cchSearch); // allocates cch + 1
        if (!bstrSearch)
            return E_OUTOFMEMORY;
            
        StrCatBuffW(bstrSearch, bstr, cchSearch + 1);
        HRESULT hr = SetField(&m_bstrSearch, bstrSearch, TRUE);
        SysFreeString(bstrSearch);
        return hr;
    }
}

STDMETHODIMP CIEFrameAuto::COmLocation::put_hash(BSTR bstr)
{
    if (!bstr)
        return E_POINTER;

    // If the provided hash string begins with a "#" already,
    // just use it "as is"
    if (bstr[0] == L'#')
    {
        return SetField(&m_bstrHash, bstr, TRUE);
    }
    // Otherwise prepend a pound sign
    else
    {
        // Allocate enough space for the string plus one more character ('#')
        UINT cchHash = lstrlenW(bstr) + 1;
        BSTR bstrHash = SafeSysAllocStringLen(L"#", cchHash); // allocates cchHash + 1
        if (!bstrHash)
            return E_OUTOFMEMORY;

        StrCatBuffW(bstrHash, bstr, cchHash + 1);
        HRESULT hr = SetField(&m_bstrHash, bstrHash, TRUE);
        SysFreeString(bstrHash);
        return hr;
    }
}

STDMETHODIMP CIEFrameAuto::COmLocation::put_port(BSTR bstr)
{
    return SetField(&m_bstrPort, bstr, TRUE);
}

/******************************************************************************
// Helper function for the property setting functions
// Makes sure that the URL has been parsed
// Sets the field to its new value
// recomposes the URL, IF fRecomposeUrl is true
// If part of a window, tells the window to go to the new URL
//
// @todo JavaScript has some funky behavior on field setting--
// for example, the protocol field can be set to an entire URL.
// We need to make sure this functionality is duplicated
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmLocation::SetField(BSTR* field, BSTR newval, BOOL fRecomposeUrl)
{
    HRESULT hr = S_OK;

    hr = CheckUrl();
    if (FAILED(hr))
        return hr;

    // Copy the current URL!
    BSTR bstrCurrentURL = SysAllocString(m_bstrFullUrl);

    // Make a copy of the new value
    BSTR valCopy = SysAllocString(newval);
    if (!valCopy)
        return E_OUTOFMEMORY;

    // free the old value of field and set it to point to the new string
    if (*field)
        SysFreeString(*field);
    *field = valCopy;

    // Put together a new URL based on its constituents, if requested
    if (fRecomposeUrl)
        hr = ComposeUrl();

    if (SUCCEEDED(hr))
    {
        if (bstrCurrentURL)
        {
            // If the new url is the same as the previous url then we want to navigate but not have it
            // add to the history!
            if (StrCmpW(bstrCurrentURL,m_bstrFullUrl) == 0)
            {
                m_fdontputinhistory = TRUE;
            }

            //
            //clean up the old stuff before navigation
            //
            valCopy = SysAllocString(m_bstrFullUrl);

            FreeStuff();

            // valCopy can be NULL. does everybody else handle
            // the NULL m_bstrFullUrl case?
            m_bstrFullUrl = valCopy;

            ParseUrl();

            SysFreeString(bstrCurrentURL);
        }

        // Go to the new URL
        hr = DoNavigate();
    }
    return hr;
}

/******************************************************************************
// Derive a new m_bstrUrl and m_bstrFullUrl from its constituents
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmLocation::ComposeUrl()
{
    HRESULT hr = S_OK;

    ULONG len =
        SysStringLen(m_bstrProtocol) +
        2 +                                    // //
        SysStringLen(m_bstrHostName) +
        1 +                                    // trailing /
        SysStringLen(m_bstrPort) +
        1 +                                 // :
        SysStringLen(m_bstrPath) +
        1 +                                 // Possible leading /
        (m_bstrSearch ? 1 : 0) +            // ?
        SysStringLen(m_bstrSearch) +
        (m_bstrHash ? 1 : 0) +                // #
        SysStringLen(m_bstrHash) +
        10;                                    // Trailing Termination + some slop

    BSTR bstrUrl = SafeSysAllocStringLen(L"", len); // allocates len + 1
    if (!bstrUrl)
        return E_OUTOFMEMORY;

    StrCatBuffW(bstrUrl, m_bstrProtocol, len + 1);
    StrCatBuffW(bstrUrl, L"//", len + 1);
    StrCatBuffW(bstrUrl, m_bstrHostName, len + 1);

    if (lstrlenW(m_bstrPort))
    {
        StrCatBuffW(bstrUrl, L":", len + 1);
        StrCatBuffW(bstrUrl, m_bstrPort, len + 1);
    }

    if (lstrlenW(m_bstrPath))
    {
        // prepend the leading slash if needed
        if (m_bstrPath[0] != '/')
            StrCatBuffW(bstrUrl, L"/", len + 1);
        StrCatBuffW(bstrUrl, m_bstrPath, len + 1);
    }

    if (lstrlenW(m_bstrSearch) > 0)
    {
        StrCatBuffW(bstrUrl, m_bstrSearch, len + 1);
    }
    if (lstrlenW(m_bstrHash) > 0)
    {
        StrCatBuffW(bstrUrl, m_bstrHash, len + 1);
    }

    // OK, everything has succeeded
    // Assign to member variables
    if (m_bstrFullUrl)
        SysFreeString(m_bstrFullUrl);
    m_bstrFullUrl = bstrUrl;

    return hr;
}

BSTR CIEFrameAuto::COmLocation::ComputeAbsoluteUrl(BSTR bstrUrlRelative)
{
    if (FAILED(CheckUrl()))
        return 0;

    return PrvHTParse(bstrUrlRelative, m_bstrFullUrl, PARSE_ALL);
}


/******************************************************************************
// Tell the window to go to the current URL
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmLocation::DoNavigate()
{
    VARIANT v1;
    v1.vt    = VT_ERROR;
    v1.scode = DISP_E_PARAMNOTFOUND;

    if (m_fdontputinhistory)
    {
        v1.vt = VT_I4;
        v1.lVal = navNoHistory;

        // Reset the flag.
        m_fdontputinhistory = FALSE;
    }

    HRESULT hres = _pAuto->Navigate(m_bstrFullUrl, &v1, PVAREMPTY, PVAREMPTY, PVAREMPTY);

    if (hres == HRESULT_FROM_WIN32(ERROR_BUSY))
    {
        hres = S_OK;
        m_fPendingNavigate = TRUE;
    }
    else
        m_fPendingNavigate = FALSE;
    return hres;
}

/******************************************************************************
// Parse a URL into its constituents and store them in member variables
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmLocation::ParseUrl()
{
    HRESULT hr = S_OK;
    BSTR szProtocol = 0,
         szHost = 0,
         szPath = 0,
         szSearch = 0,
         szHash = 0,
         searchPos = 0,
         portPos = 0,
         hashPos = 0;

    m_bstrSearch = NULL;


    // Strip out the search string and the hash string from the URL--
    // the parser is too dumb to recognize them
    
    searchPos = StrChrW(m_bstrFullUrl, L'?');
    if (searchPos)
    {
        m_bstrSearch = SysAllocString(searchPos);
        *searchPos = 0; // take it away again so it doesn't cause confusion
    }
    else
    {
        m_bstrSearch = SysAllocString(L"");
    }
    
    if (NULL == m_bstrSearch)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }


    // Get the anchor string, including the '#' prefix
    hashPos = StrChrW(m_bstrFullUrl, L'#');
    if (hashPos)
    {
        m_bstrHash = SysAllocString(hashPos);
        *hashPos = 0; // take it away again so it doesn't cause confusion
    }
    else
    {
        m_bstrHash = SysAllocString(L"");
    }
    
    if (NULL == m_bstrHash)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Both m_bstrSearch and m_bstrHash can be NULL at this point
    // does all the affected code handle this case?
    // note there are more cases like this below (m_bstrProtocol for example)

    // Parse the protocol
    szProtocol = PrvHTParse(m_bstrFullUrl, 0, PARSE_ACCESS | PARSE_PUNCTUATION);
    if (!szProtocol)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    m_bstrProtocol = SysAllocString(szProtocol);
    if (NULL == m_bstrProtocol)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }


    // Parse the host name and port number (if any)

    // First look for a port
    szHost = PrvHTParse(m_bstrFullUrl, 0, PARSE_HOST);
    if (!szHost)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    portPos = StrChrW(szHost, L':');
    if (portPos)
    {
        m_bstrHostName = SafeSysAllocStringLen(szHost, (unsigned int)(portPos-szHost));
        m_bstrPort = SysAllocString(portPos + 1);
    }
    else
    {
        m_bstrHostName = SysAllocString(szHost);
        m_bstrPort = SysAllocString(L"");
    }

    if (NULL == m_bstrHostName || NULL == m_bstrPort)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // Parse the path and search string (if any)
    szPath = PrvHTParse(m_bstrFullUrl, 0, PARSE_PATH);
    if (!szPath)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // If the path doesn't start with a '/' then prepend one - Netscape compatibility
    if (StrCmpIW(szProtocol, L"javascript:") && StrCmpIW(szProtocol, L"vbscript:") && szPath[0] != L'/')
    {
        WCHAR *szPath2 = szPath;
        int cchPath = lstrlenW(szPath2)+2;
        szPath = SafeSysAllocStringLen(0, cchPath); // allocates +1 char for the terminator
        if (szPath)
        {
            szPath[0] = L'/';
            szPath[1] = L'\0';
            StrCatBuffW(szPath,szPath2, cchPath+1); //+1 added by alloc above
            szPath[cchPath] = 0;
            SysFreeString(szPath2);
        }
        else
            szPath = szPath2;
    }

    m_bstrPath = SysAllocString(szPath);
    if (NULL == m_bstrPath)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }


exit:
    // Restore hash and search characters
    if (searchPos)
        *searchPos =  L'?';
    if (hashPos)
        *hashPos = L'#';

    // Have to free these using SysFreeString because they come from PrvHTParse
    if (szProtocol)
        SysFreeString(szProtocol);
    if (szHost)
        SysFreeString(szHost);
    if (szPath)
        SysFreeString(szPath);
    if (szHash)
        SysFreeString(szHash);
    return hr;
}

CIEFrameAuto::COmLocation::~COmLocation()
{
    FreeStuff();
}

HRESULT CIEFrameAuto::COmLocation::FreeStuff()
{
    if (m_bstrFullUrl)
    {
        SysFreeString(m_bstrFullUrl);
        m_bstrFullUrl = 0;
    }
    if (m_bstrProtocol)
    {
        SysFreeString(m_bstrProtocol);
        m_bstrProtocol = 0;
    }
    if (m_bstrHostName)
    {
        SysFreeString(m_bstrHostName);
        m_bstrHostName = 0;
    }
    if (m_bstrPort)
    {
        SysFreeString(m_bstrPort);
        m_bstrPort = 0;
    }
    if (m_bstrPath)
    {
        SysFreeString(m_bstrPath);
        m_bstrPath = 0;
    }
    if (m_bstrSearch)
    {
        SysFreeString(m_bstrSearch);
        m_bstrSearch = 0;
    }
    if (m_bstrHash)
    {
        SysFreeString(m_bstrHash);
        m_bstrHash = 0;
    }
    return S_OK;
}

/******************************************************************************
                    Navigator Object
******************************************************************************/


CIEFrameAuto::COmNavigator::COmNavigator() :
    CAutomationStub(MIN_BROWSER_DISPID, MAX_BROWSER_DISPID, TRUE)
{
    ASSERT(!_UserAgent);
    ASSERT(FALSE == _fLoaded);
}

HRESULT CIEFrameAuto::COmNavigator::Init(CMimeTypes *pMimeTypes, CPlugins *pPlugins, COpsProfile *pProfile)
{
    ASSERT(pMimeTypes != NULL);
    _pMimeTypes = pMimeTypes;
    ASSERT(pPlugins != NULL);
    _pPlugins = pPlugins;
    ASSERT(pProfile != NULL);
    _pProfile = pProfile;

    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _omnav, this);
    return CAutomationStub::Init(SAFECAST(this, IOmNavigator*), IID_IOmNavigator, CLSID_HTMLNavigator, pauto);
}

/******************************************************************************
// bradsc 11/5/97
// This method should not use hard coded values. Where can we get this info?

// This method has to use non-unicode junk because of Win95
******************************************************************************/
HRESULT CIEFrameAuto::COmNavigator::LoadUserAgent()
{
    _fLoaded = TRUE;

    CHAR    szUserAgent[MAX_PATH];  // URLMON says the max length of the UA string is MAX_PATH
    DWORD   dwSize = MAX_PATH;

    szUserAgent[0] = '\0';

    if (ObtainUserAgentString(0, szUserAgent, &dwSize) == S_OK)
    {

        // Just figure out the real length since 'size' is ANSI bytes required.
        //
        _UserAgent = SysAllocStringFromANSI(szUserAgent);
    }

    return _UserAgent ? S_OK : E_FAIL;
}

HRESULT CIEFrameAuto::COmNavigator::_InternalQueryInterface(REFIID riid, void ** const ppv)
{
    ASSERT(!IsEqualIID(riid, IID_IUnknown));

    if (IsEqualIID(riid, IID_IOmNavigator))
        *ppv = SAFECAST(this, IOmNavigator *);
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}


STDMETHODIMP CIEFrameAuto::COmNavigator::Invoke(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *dispparams, VARIANT *pvarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    HRESULT hr = CAutomationStub::Invoke(dispid,riid,lcid,wFlags,dispparams,pvarResult,pexcepinfo,puArgErr);

    if (hr == DISP_E_MEMBERNOTFOUND
        && (wFlags & DISPATCH_PROPERTYGET)
        && dispid == DISPID_VALUE
        && pvarResult != NULL && dispparams->cArgs == 0)
    {
        pvarResult->vt = VT_BSTR;
        pvarResult->bstrVal = SysAllocString(L"[object Navigator]");
        hr = pvarResult->bstrVal ? S_OK : E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CIEFrameAuto::COmNavigator::_GetIDispatchExDelegate(IDispatchEx ** const delegate)
{
    if (!delegate)
        return E_POINTER;

    IDispatch *pRootDisp = 0;

    HRESULT hr = GetRootDelegate(_pAuto, &pRootDisp);
    if (SUCCEEDED(hr))
    {
        IDispatch *pDelegateDisp = 0;
        hr = GetDelegateOnIDispatch(pRootDisp, DISPID_NAVIGATOROBJECT, &pDelegateDisp);
        pRootDisp->Release();

        if (SUCCEEDED(hr))
        {
            hr = pDelegateDisp->QueryInterface(IID_PPV_ARG(IDispatchEx, delegate));
            pDelegateDisp->Release();
        }
    }

    return hr;
}

// All of these have hard-coded lengths and locations

STDMETHODIMP CIEFrameAuto::COmNavigator::get_appCodeName(BSTR* retval)
{
    HRESULT hr;

    if (retval)
    {
        if (!_fLoaded)
            LoadUserAgent();

        if (_UserAgent)
        {
            *retval = SafeSysAllocStringLen(_UserAgent, 7);
            hr = S_OK;
        }
        else
        {
            *retval = SysAllocString(APPCODENAME);
            hr = *retval ? S_OK : E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

/******************************************************************************
// bradsch 11/8/96
// We should read this out of the registry instead of hard coding!!
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmNavigator::get_appName(BSTR* retval)
{
    *retval = SysAllocString(MSIE);
    return *retval ? S_OK : E_OUTOFMEMORY;
}

/******************************************************************************
// Netscape defined appVersion to be everything after
// the first 8 characters in the userAgent string.
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmNavigator::get_appVersion(BSTR* retval)
{
    if (retval)
    {
        if (!_fLoaded)
            LoadUserAgent();

        if (_UserAgent)
        {
            // If _UserAgent is less than 8 characters the registry is messed up.
            // If _UserAgent is exactly 8 characters we will just return a NULL string.
            if (lstrlenW(_UserAgent) < 8)
                *retval = SysAllocString(L"");
            else
                *retval = SysAllocString(_UserAgent + 8);

            return *retval ? S_OK : E_OUTOFMEMORY;
        }
        *retval = SysAllocString(APPVERSION);
        return *retval ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        return S_FALSE;
    }
}

STDMETHODIMP CIEFrameAuto::COmNavigator::get_userAgent(BSTR* retval)
{
    if (retval)
    {
        if (!_fLoaded)
            LoadUserAgent();

        if (_UserAgent)
        {
            *retval = SysAllocString(_UserAgent);
        }
        else
        {
            *retval = SysAllocString(USERAGENT);
        }

        return *retval ? S_OK : E_OUTOFMEMORY;
    }
    else
    {
        return S_FALSE;
    }
}

STDMETHODIMP CIEFrameAuto::COmNavigator::get_cookieEnabled(VARIANT_BOOL* enabled)
{
    HRESULT hr = E_POINTER;

    if (enabled)
    {
        BSTR    strUrl;

        *enabled =  VARIANT_FALSE;

        hr = _pAuto->_omloc.get_href(&strUrl);
        if (SUCCEEDED(hr))
        {
            DWORD dwPolicy;

            if (SUCCEEDED(ZoneCheckUrlExW(strUrl, &dwPolicy, sizeof(dwPolicy), NULL, NULL,
                                        URLACTION_COOKIES_ENABLED, PUAF_NOUI, NULL)) &&
                (URLPOLICY_DISALLOW != dwPolicy))
            {
                *enabled = VARIANT_TRUE;
            }

            SysFreeString(strUrl);
        }
        else
            ASSERT(!strUrl);    // If this failed and strUrl isn't NULL, then we are leaking.
    }

    return hr;
}

STDMETHODIMP CIEFrameAuto::COmNavigator::javaEnabled(VARIANT_BOOL* enabled)
{
    HRESULT hr = E_POINTER;

    if (enabled)
    {
        BSTR    strUrl;

        *enabled =  VARIANT_FALSE;

        hr = _pAuto->_omloc.get_href(&strUrl);
        if (SUCCEEDED(hr))
        {
            DWORD dwPolicy;

            if (SUCCEEDED(ZoneCheckUrlExW(strUrl, &dwPolicy, sizeof(dwPolicy), NULL, NULL,
                                        URLACTION_JAVA_PERMISSIONS, PUAF_NOUI, NULL)) &&
                (URLPOLICY_JAVA_PROHIBIT != dwPolicy))
            {
                *enabled = VARIANT_TRUE;
            }

            SysFreeString(strUrl);
        }
        else
            ASSERT(!strUrl);    // If this failed and strUrl isn't NULL, then we are leaking.
    }

    return hr;
}

STDMETHODIMP CIEFrameAuto::COmNavigator::taintEnabled (VARIANT_BOOL *pfEnabled)
{
    if (pfEnabled)
    {
        *pfEnabled = VARIANT_FALSE;
    }
    else
        return E_POINTER;


    return S_OK;
}

STDMETHODIMP CIEFrameAuto::COmNavigator::get_mimeTypes (IHTMLMimeTypesCollection**ppMimeTypes)
{
    if (ppMimeTypes)
    {
        *ppMimeTypes = _pMimeTypes;
        _pMimeTypes->AddRef();
        return S_OK;
    }
    else
        return E_POINTER;
}

/******************************************************************************
//  member: toString method
//  Synopsis : we need to invoke on dispid_value, and coerce the result into
//       a bstr.
//
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmNavigator::toString(BSTR * pbstr)
{
    HRESULT hr = E_POINTER;

    if (pbstr)
    {
       *pbstr= SysAllocString(L"[object Navigator]");

       if (!*pbstr)
           hr = E_OUTOFMEMORY;
       else
           hr = S_OK;
    }

    return hr;
}



CIEFrameAuto::CCommonCollection::CCommonCollection() :
    CAutomationStub(MIN_BROWSER_DISPID, MAX_BROWSER_DISPID, TRUE)
{
}


HRESULT CIEFrameAuto::CMimeTypes::Init()
{
    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _mimeTypes, this);
    return CAutomationStub::Init(SAFECAST(this, IHTMLMimeTypesCollection*), IID_IHTMLMimeTypesCollection,
                        CLSID_CMimeTypes, pauto);
}

HRESULT CIEFrameAuto::CCommonCollection::_GetIDispatchExDelegate(IDispatchEx ** const delegate)
{
    if (!delegate)
        return E_POINTER;

    // We do not handle expandos yet
    *delegate = NULL;

    return DISP_E_MEMBERNOTFOUND;
}

HRESULT CIEFrameAuto::CMimeTypes::_InternalQueryInterface(REFIID riid, void ** const ppv)
{
    if (IsEqualIID(riid, IID_IHTMLMimeTypesCollection))
        *ppv = SAFECAST(this, IHTMLMimeTypesCollection *);
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}


HRESULT CIEFrameAuto::CCommonCollection::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT hr;

    hr = CAutomationStub::GetDispID(bstrName, grfdex, pid);

    if (hr == DISP_E_MEMBERNOTFOUND)
    {
        // We ignore the command we do not understand
        *pid = DISPID_UNKNOWN;
        hr = S_OK;
    }

    return hr;
}

HRESULT CIEFrameAuto::CCommonCollection::InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp, VARIANT *pvarRes, EXCEPINFO *pei, IServiceProvider *pspCaller)
{
    if (id == DISPID_UNKNOWN && pvarRes)
    {
        V_VT(pvarRes) = VT_EMPTY;
        return S_OK;
    }

    return CAutomationStub::InvokeEx(id, lcid, wFlags, pdp, pvarRes, pei, pspCaller);
}


HRESULT CIEFrameAuto::CCommonCollection::get_length(LONG* pLength)
{
    if (pLength == NULL)
        return E_POINTER;

    *pLength = 0;
    return S_OK;
}

HRESULT CIEFrameAuto::COmNavigator::get_plugins (IHTMLPluginsCollection **ppPlugins)
{
    if (ppPlugins)
    {
        *ppPlugins = _pPlugins;
        _pPlugins->AddRef();
        return S_OK;
    }
    else
        return E_POINTER;
}

HRESULT CIEFrameAuto::COmNavigator::get_opsProfile (IHTMLOpsProfile **ppOpsProfile)
{
    if (ppOpsProfile)
    {
        *ppOpsProfile = _pProfile;
        (*ppOpsProfile)->AddRef();
        return S_OK;
    }
    else
        return E_POINTER;
}

HRESULT CIEFrameAuto::COmNavigator::get_cpuClass(BSTR * p)
{
    if (p)
    {
        SYSTEM_INFO SysInfo;
        ::GetSystemInfo(&SysInfo);
        switch(SysInfo.wProcessorArchitecture)
        {
        case PROCESSOR_ARCHITECTURE_INTEL:
            *p = SysAllocString(L"x86");
            break;
        case PROCESSOR_ARCHITECTURE_AMD64:
            *p = SysAllocString(L"AMD64");
            break;
        case PROCESSOR_ARCHITECTURE_IA64:
            *p = SysAllocString(L"IA64");
            break;
        default:
            *p = SysAllocString(L"Other");
            break;
        }

        if (*p == NULL)
            return E_OUTOFMEMORY;
        else
            return S_OK;
    }
    else
        return E_POINTER;
}


#define MAX_VERSION_STRING 30

HRESULT CIEFrameAuto::COmNavigator::get_systemLanguage(BSTR * p)
{
    HRESULT hr = E_POINTER;

    if (p)
    {
        LCID lcid;
        WCHAR strVer[MAX_VERSION_STRING];

        *p = NULL;

        lcid = ::GetSystemDefaultLCID();
        hr = LcidToRfc1766W(lcid, strVer, MAX_VERSION_STRING);
        if (!hr)
        {
            *p = SysAllocString(strVer);
            if (!*p)
                hr = E_OUTOFMEMORY;

        }
    }

    return hr;
}

HRESULT CIEFrameAuto::COmNavigator::get_browserLanguage(BSTR * p)
{
    LCID lcid =0;
    LANGID  lidUI;
    WCHAR strVer[MAX_VERSION_STRING];
    HRESULT hr;

    if (!p)
    {
        return E_POINTER;
    }

    *p = NULL;

    lidUI = MLGetUILanguage();
    lcid = MAKELCID(lidUI, SORT_DEFAULT);

    hr = LcidToRfc1766W(lcid, strVer, MAX_VERSION_STRING);
    if (!hr)
    {
        *p = SysAllocString(strVer);
        if (!*p)
            return E_OUTOFMEMORY;
        else
        {
            return S_OK;
        }
    }
    return E_INVALIDARG;
}

HRESULT CIEFrameAuto::COmNavigator::get_userLanguage(BSTR * p)
{
    HRESULT hr = E_POINTER;

    if (p)
    {
        LCID lcid;
        WCHAR strVer[MAX_VERSION_STRING];

        *p = NULL;

        lcid = ::GetUserDefaultLCID();
        hr = LcidToRfc1766W(lcid, strVer, MAX_VERSION_STRING);
        if (!hr)
        {
            *p = SysAllocString(strVer);
            if (!*p)
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT CIEFrameAuto::COmNavigator::get_platform(BSTR * p)
{
    // Nav compatability item, returns the following in Nav:-
    // Win32,Win16,Unix,Motorola,Max68k,MacPPC
    // shdocvw is Win32 only, so
    if (p)
    {
        *p = SysAllocString (L"Win32");
        return *p ? S_OK : E_OUTOFMEMORY;
    }
    else
        return E_POINTER;
}

HRESULT CIEFrameAuto::COmNavigator::get_appMinorVersion(BSTR * p)
{
    HKEY hkInetSettings;
    long lResult;
    HRESULT hr = S_FALSE;

    if (!p)
    {
        return E_POINTER;
    }

    *p = NULL;

    lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
        0, KEY_QUERY_VALUE, &hkInetSettings);

    if (ERROR_SUCCESS == lResult)
    {
        DWORD dwType;
        TCHAR buffer[MAX_URL_STRING];
        DWORD size = sizeof(buffer);

        // If this is bigger than MAX_URL_STRING the registry is probably hosed.
        lResult = RegQueryValueEx(hkInetSettings, TEXT("MinorVersion"), 0, &dwType, (BYTE*)buffer, &size);

        RegCloseKey(hkInetSettings);

        if (ERROR_SUCCESS == lResult && dwType == REG_SZ)
        {
            // Just figure out the real length since 'size' is ANSI bytes required.
            *p = SysAllocString(buffer);
            hr = *p ? S_OK : E_OUTOFMEMORY;
        }
    }

    if (S_OK != hr)
    {
        *p = SysAllocString (L"0");
        hr = *p ? S_OK : E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CIEFrameAuto::COmNavigator::get_connectionSpeed(long * p)
{
    if (p)
    {
        *p = NULL;
        return E_NOTIMPL;
    }
    else
        return E_POINTER;
}

HRESULT CIEFrameAuto::COmNavigator::get_onLine(VARIANT_BOOL * p)
{
    if (p)
    {
        *p = TO_VARIANT_BOOL(!IsGlobalOffline());
        return S_OK;
    }
    else
        return E_POINTER;
}

HRESULT CIEFrameAuto::CPlugins::Init()
{
    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _plugins, this);
    return CAutomationStub::Init(SAFECAST(this, IHTMLPluginsCollection*), IID_IHTMLPluginsCollection,
                        CLSID_CPlugins, pauto);
}

HRESULT CIEFrameAuto::CPlugins::_InternalQueryInterface(REFIID riid, void ** const ppv)
{
    if (IsEqualIID(riid, IID_IHTMLPluginsCollection))
        *ppv = SAFECAST(this, IHTMLPluginsCollection *);
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}


/******************************************************************************
                    Window Open Support
******************************************************************************/

CIEFrameAuto::COmHistory::COmHistory() :
    CAutomationStub(MIN_BROWSER_DISPID, MAX_BROWSER_DISPID, TRUE)
{
}

HRESULT CIEFrameAuto::COmHistory::Init()
{
    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _omhist, this);
    return CAutomationStub::Init(SAFECAST(this, IOmHistory*), IID_IOmHistory, CLSID_HTMLHistory, pauto);
}

HRESULT CIEFrameAuto::COmHistory::_InternalQueryInterface(REFIID riid, void ** const ppv)
{
    ASSERT(!IsEqualIID(riid, IID_IUnknown));

    if (IsEqualIID(riid, IID_IOmHistory))
        *ppv = SAFECAST(this, IOmHistory *);
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}


HRESULT CIEFrameAuto::COmHistory::_GetIDispatchExDelegate(IDispatchEx ** const delegate)
{
    if (!delegate)
        return E_POINTER;

    IDispatch *pRootDisp = 0;

    HRESULT hr = GetRootDelegate(_pAuto, &pRootDisp);
    if (SUCCEEDED(hr))
    {
        IDispatch *pDelegateDisp = 0;
        hr = GetDelegateOnIDispatch(pRootDisp, DISPID_HISTORYOBJECT, &pDelegateDisp);
        pRootDisp->Release();

        if (SUCCEEDED(hr))
        {
            hr = pDelegateDisp->QueryInterface(IID_IDispatchEx, (void**)delegate);
            pDelegateDisp->Release();
        }
    }

    return hr;
}


/******************************************************************************
// I just tested Nav3 and they simply ignore parameters to back() and forward. They
// do, however, honor the value passed to go(). Hey... Netscape actually followed
// their documented behavior for once!
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmHistory::back(VARIANT*)
{
    //
    // Netscape ignores all errors from these navigation functions
    //

    _pAuto->GoBack();
    return S_OK;
}

STDMETHODIMP CIEFrameAuto::COmHistory::forward(VARIANT*)
{
    //
    // Netscape ignores all errors from these navigation functions
    //

    _pAuto->GoForward();
    return S_OK;
}

/******************************************************************************
Get History Length from TravelLog
******************************************************************************/
STDMETHODIMP CIEFrameAuto::COmHistory::get_length(short* retval)
{
    // Make sure we have an IBrowserService pointer
    if (_pAuto->_pbs==NULL)
    {
        TraceMsg(DM_WARNING, "CIEA::history.go called _pbs==NULL");
        return E_FAIL;
    }

    *retval = 0;
    // The new ITravelLog
    ITravelLog *ptl;

    // Get the new TravelLog from the browser service object.
    if (SUCCEEDED(_pAuto->_pbs->GetTravelLog(&ptl)))
    {
        if (ptl)
            *retval = (short)ptl->CountEntries(_pAuto->_pbs);
        ptl->Release();
    }

    return S_OK;
}

STDMETHODIMP CIEFrameAuto::COmHistory::go(VARIANT *pVargDist)
{
    // Parameter is optional.  If not present, just refresh.
    if (pVargDist->vt == VT_ERROR
        && pVargDist->scode == DISP_E_PARAMNOTFOUND)
        return _pAuto->Refresh();

    // Change type to short if possible.
    //
    HRESULT hr = VariantChangeType(pVargDist, pVargDist, NULL, VT_I2);

    if (SUCCEEDED(hr))
    {
        //
        // If 0, just call Refresh
        //
        if (pVargDist->iVal == 0)
        {
            return _pAuto->Refresh();
        }

        // Make sure we have an IBrowserService pointer
        if (_pAuto->_pbs==NULL)
        {
            TraceMsg(DM_WARNING, "CIEA::history.go called _pbs==NULL");
            return E_FAIL;
        }

        // The new ITravelLog
        ITravelLog *ptl;

        // Get the new TravelLog from the browser service object.
        if (SUCCEEDED(_pAuto->_pbs->GetTravelLog(&ptl)))
        {
            // Tell it to travel.  Pass in the IShellBrowser pointer.
            ptl->Travel(_pAuto->_pbs, pVargDist->iVal);
            ptl->Release();
        }
        return S_OK;
    }

    // Now see if it's a string.
    //
    if (pVargDist->vt == VT_BSTR)
    {
        LPITEMIDLIST  pidl;
        ITravelLog    *ptl;
        ITravelEntry  *pte;

        // Make sure we have an IBrowserService pointer
        if (_pAuto->_pbs==NULL)
        {
            TraceMsg(DM_WARNING, "CIEA::history.go called _pbs==NULL");
            return E_FAIL;
        }

        if (SUCCEEDED(_pAuto->_PidlFromUrlEtc(CP_ACP, pVargDist->bstrVal, NULL, &pidl)))
        {
            if (SUCCEEDED(_pAuto->_pbs->GetTravelLog(&ptl)))
            {
                if (SUCCEEDED(ptl->FindTravelEntry(_pAuto->_pbs, pidl, &pte)))
                {
                    pte->Invoke(_pAuto->_pbs);
                    pte->Release();
                }
                ptl->Release();
            }
            ILFree(pidl);
        }
    }

    //
    // Netscape ignores all errors from these navigation functions
    //

    return S_OK;
}






/******************************************************************************
                    Window Open Support
******************************************************************************/

DWORD OpenAndNavigateToURL(
    CIEFrameAuto *pauto,            // IEFrameAuto of caller. Used to get IWeBrowserApp, ITargetFrame2, and IHlinkFrame methods
    BSTR         *pbstrURL,         // URL to navigate to. Should already be an escaped absolute URL
    const WCHAR *pwzTarget,         // Name of the frame to navigate
    ITargetNotify *pNotify,         // Received callback on open. May be NULL
    BOOL          bNoHistory,       // Don't add to history
    BOOL          bSilent)         // This frame is in silent Mode
{
    ASSERT(*pbstrURL);
    ASSERT(pwzTarget);
    ASSERT(pauto);

    IUnknown *punkTargetFrame = NULL;
    LPTARGETFRAMEPRIV ptgfpTarget = NULL;
    BOOL fOpenInNewWindow = FALSE;
    LPBINDCTX pBindCtx = NULL;
    LPMONIKER pMoniker = NULL;
    LPHLINK pHlink = NULL;
    DWORD dwHlinkFlags = 0;
    DWORD zone_cross = 0;
    const WCHAR *pwzFindLoc = 0;

    // Used to open a new window if there is not an existing frame
    LPTARGETFRAMEPRIV ptgfp = SAFECAST(pauto, ITargetFramePriv*);


    //  Lookup the frame cooresponding to the target - this will give us the
    //  IUnknown for an object that can give us the coresponding IHlinkFrame
    //  via IServiceProvider::QueryService.
    HRESULT hr = pauto->FindFrame(pwzTarget, FINDFRAME_JUSTTESTEXISTENCE, &punkTargetFrame);
    if (punkTargetFrame)
    {
        //    Get the IHlinkFrame for the target'ed frame.
        hr = punkTargetFrame->QueryInterface(IID_PPV_ARG(ITargetFramePriv, &ptgfpTarget));
        if (FAILED(hr))
            goto Exit;

        ptgfp = ptgfpTarget;

        // if URL is empty
        if (!**pbstrURL || **pbstrURL == EMPTY_URL)
        {
            LPTARGETNOTIFY ptgnNotify = NULL;
            if (pNotify)
            {
                if (FAILED(pNotify->QueryInterface(IID_PPV_ARG(ITargetNotify, &ptgnNotify))))
                    ptgnNotify = NULL;
            }
            if (ptgnNotify)
            {
                ptgnNotify->OnReuse(punkTargetFrame);
                ptgnNotify->Release();
            }
            goto Exit;  // Don't navigate.
        }
    }
    else if (SUCCEEDED(hr))
    {
        // No luck, open in new window
        fOpenInNewWindow = TRUE;

        // Now, if the URL is empty, replace it with "about:blank"
        if (!**pbstrURL || **pbstrURL == EMPTY_URL)
        {
            BSTR    bstrOldURL = *pbstrURL;

            *pbstrURL = NULL;

            if (*bstrOldURL == EMPTY_URL)
                // The URL is really empty string however when the 0x01 is the
                // character of the URL this signals that the security information
                // follows.  Therefore, we'll need to append the about:blank +
                // \1 + callerURL.
                CreateBlankURL(pbstrURL, TEXT("about:blank"), bstrOldURL);
            else
                CreateBlankURL(pbstrURL, pauto->_fDesktopComponent() ? NAVFAIL_URL_DESKTOPITEM : NAVFAIL_URL, bstrOldURL);

            SysFreeString(bstrOldURL);
        }
    }
    else
        goto Exit;


    // bradsch 11/12/96
    // Need to figure out Browser-Control stuff for webcheck


    // 11/12/96
    // Need to implment this with Trident... I think "JavaScript:" should be
    // supported as a real protocol. This would provide greater Navigator
    // compatibility and allows us to avoid the following hack.
    /*
    if (!StrCmpNI(pszURL, JAVASCRIPT_PROTOCOL, ARRAY_ELEMENTS(JAVASCRIPT_PROTOCOL)-1))
    {
        if (tw && tw->w3doc && DLCtlShouldRunScripts(tw->lDLCtlFlags))
            ScriptOMExecuteThis(tw->w3doc->dwScriptHandle, JAVASCRIPT, &pszURL[ARRAY_ELEMENTS(JAVASCRIPT_PROTOCOL)-1],
                pszJavascriptTarget);
        return ERROR_SUCCESS;
    }
    */

    LONG_PTR hwnd;
    hr = pauto->get_HWND(&hwnd);
    if (FAILED(hr))
        goto Exit;

    BSTR bstrCurrentURL;
    hr = pauto->get_LocationURL(&bstrCurrentURL);
    if (FAILED(hr))
        goto Exit;

    zone_cross = ERROR_SUCCESS;
    if (!bSilent)
    {
        ASSERT(pauto->_psb);
        if (pauto->_psb)
            pauto->_psb->EnableModelessSB(FALSE);

        zone_cross = InternetConfirmZoneCrossing((HWND) hwnd, bstrCurrentURL, *pbstrURL, FALSE);
        if (pauto->_psb)
            pauto->_psb->EnableModelessSB(TRUE);
    }

    SysFreeString(bstrCurrentURL);

    if (ERROR_CANCELLED == zone_cross)
    {
        hr = HRESULT_FROM_WIN32(zone_cross);
        goto Exit;
    }


    // create a moniker and bind context for this URL
    // use CreateAsyncBindCtxEx so that destination still navigates
    // even if we exit, as in the following code:
    //      window.close()
    //      window.open("http://haha/jokesonyou.html","_blank");
    hr = CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pBindCtx, 0);
    if (FAILED(hr))
        goto Exit;

    if (pNotify)
    {
        hr = pBindCtx->RegisterObjectParam(TARGET_NOTIFY_OBJECT_NAME, pNotify);
        ASSERT(SUCCEEDED(hr));
    }


    // Seperate the base URL from the location (hash)
    if (pwzFindLoc = StrChrW(*pbstrURL, '#'))
    {
        const WCHAR *pwzTemp = StrChrW(pwzFindLoc, '/');
        if (!pwzTemp)
            pwzTemp = StrChrW(pwzFindLoc, '\\');

        // no delimiters past this # marker... we've found a location.
        // break out
        if (pwzTemp)
            pwzFindLoc = NULL;
    }

    WCHAR wszBaseURL[MAX_URL_STRING+1];
    WCHAR wszLocation[MAX_URL_STRING+1];

    if (pwzFindLoc)
    {
        // StrCpyNW alway null terminates to we need to copy len+1
        int cchCopy = (int)(pwzFindLoc-*pbstrURL+1);
        if (cchCopy > ARRAYSIZE(wszBaseURL))
            cchCopy = ARRAYSIZE(wszBaseURL);
        StrCpyNW(wszBaseURL, *pbstrURL, cchCopy);
        StrCpyNW(wszLocation, pwzFindLoc, ARRAYSIZE(wszLocation));
    }
    else
    {
        StrCpyNW(wszBaseURL, *pbstrURL, ARRAYSIZE(wszBaseURL));
        wszLocation[0] = 0;
    }

    ASSERT(pBindCtx);


    if (fOpenInNewWindow)
    {
        dwHlinkFlags |= HLNF_OPENINNEWWINDOW;
    }

    if (bNoHistory)
    {
        dwHlinkFlags |= HLNF_CREATENOHISTORY;
    }

    hr = ptgfp->NavigateHack(dwHlinkFlags,
                              pBindCtx,
                              NULL,
                              fOpenInNewWindow ? pwzTarget : NULL,
                              wszBaseURL,
                              pwzFindLoc ? wszLocation : NULL);

Exit:
    SAFERELEASE(ptgfpTarget);
    SAFERELEASE(punkTargetFrame);
    SAFERELEASE(pBindCtx);

    return hr;
}

HRESULT CreateBlankURL(BSTR *url, LPCTSTR pszErrorUrl, BSTR oldUrl)
{
    ASSERT(url);

    unsigned int cbTotal = 0;

    if (pszErrorUrl)
        cbTotal = lstrlen(pszErrorUrl);
    if (oldUrl)     // Security portion of URL to append.
        cbTotal += lstrlenW(oldUrl);

    if (cbTotal)
    {
        *url = SysAllocStringByteLen(NULL, cbTotal * sizeof(WCHAR)); // adds +1 to cbTotal
        if (*url)
        {
            StrCpyN(*url, pszErrorUrl, cbTotal + 1);
            // Append the security URL to the actual URL.
            if (oldUrl)
            {
                StrCatBuffW(*url, oldUrl, cbTotal + 1);
            }

            return S_OK;
        }
    }

    return E_FAIL;
}


// bradsch 11/14/96
// This parsing code was copied from MSHTML and really bites. It should be replaced.


BOOL GetNextOption(BSTR& bstrOptionString, BSTR* optionName, int* piValue)
{
    WCHAR* delimiter;

    // Get the name of the option being set
    *optionName = GetNextToken(bstrOptionString, L"=,", L" \t\n\r", &delimiter);

    BSTR  optionSetting = NULL;

    if (!*optionName)
        return FALSE;

    // If there is an equal sign, get the value being set
    if (*delimiter=='=')
        optionSetting = GetNextToken(delimiter+1, L"=,", L" \t\n\r", &delimiter);

    if (!optionSetting)
        *piValue = TRUE;
    else
    {
        if (StrCmpIW(optionSetting, L"yes")==0)
            *piValue = 1;    // TRUE
        else if (StrCmpIW(optionSetting, L"no")==0)
            *piValue = 0;    // FALSE
        else
        {
            *piValue = StrToIntW(optionSetting);
        }

        SysFreeString(optionSetting);
    }

    // Advance the option string to the delimiter
    bstrOptionString=delimiter;

    return TRUE;
}

/******************************************************************************
// Return the next token, or NULL if there are no more tokens
******************************************************************************/
BSTR GetNextToken(BSTR bstr, BSTR delimiters, BSTR whitespace, BSTR *nextPos)
{

    BSTR result = NULL;
    WCHAR* curPos = bstr;

    // skip delimiters and whitespace to get the start of the token
    while (*curPos && (StrChrW(delimiters, *curPos) || StrChrW(whitespace, *curPos)))
        curPos++;

    WCHAR* start = curPos;

    // keep scanning until we reach another delimiter or whitespace
    while (*curPos && !StrChrW(delimiters, *curPos) && !StrChrW(whitespace, *curPos))
        curPos++;

    if (curPos > start)
    {
        // copy out the token as the result
        result = SafeSysAllocStringLen(start, (int)(curPos-start)); // allocates +1 for the terminator
    }

    // scan to past the whitespace to the next delimiter
    while (*curPos && StrChrW(whitespace, *curPos))
        curPos++;

    // return the delimiter
    *nextPos = curPos;

    return result;
}

#define MAX_ARGS 10

HRESULT __cdecl DoInvokeParamHelper(IUnknown* punk, IConnectionPoint* pccp, 
                                    BOOL *pf, void **ppv, DISPID dispid, UINT cArgs, ...
                                    /* param pairs of: LPVOID Arg, VARENUM Type, ... */)
{
    HRESULT hr;
    IShellBrowser * psb = NULL;

    if (punk && S_OK == punk->QueryInterface(IID_PPV_ARG(IShellBrowser, &psb)))
        psb->EnableModelessSB(FALSE);

    // Calling with no params is wasteful, they should call DoInvoke directly
    //
    if (cArgs == 0)
    {
        // Can't possible cancel if there are no parameters
        ASSERT(pf == NULL && ppv == NULL);
        IConnectionPoint_SimpleInvoke(pccp, dispid, NULL);
        hr = S_OK;
    }
    else if (cArgs < MAX_ARGS)
    {
        // This function can potentially get called *very frequently*.  It is
        // used, among other things, to set status text and progress barometer
        // values.  We need to make an array of VARIANTARGs to hold a variable
        // number of parameters.  As an optimization since we want to minimize
        // overhead in this function, we will use a static array on the stack
        // rather than allocating memory.  This puts a limit (of MAX_ARGS) on
        // the number of arguments this function can process; but this is just
        // an internal function so that's OK.  Bump up MAX_ARGS if you run out of
        // room.
        VARIANTARG VarArgList[MAX_ARGS];
        DISPPARAMS dispparams = {0};

        va_list ArgList;
        va_start(ArgList, cArgs);

        hr = SHPackDispParamsV(&dispparams, VarArgList, cArgs, ArgList);

        va_end(ArgList);

        // Now Simply Call The DoInvoke to do the real work...
        if (S_OK == hr)
            IConnectionPoint_InvokeWithCancel(pccp, dispid, &dispparams, pf, ppv);

        hr = S_OK;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    if (psb)
    {
        psb->EnableModelessSB(TRUE);
        SAFERELEASE(psb);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\iformsp.h ===
// IForms.h : Declaration of the CIntelliForms class

#ifndef __IFORMS_H_
#define __IFORMS_H_

#include "iforms.h"

const TCHAR c_szRegKeySMIEM[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
const TCHAR c_szRegKeyIntelliForms[] = TEXT("Software\\Microsoft\\Internet Explorer\\IntelliForms");
const WCHAR c_wszRegKeyIntelliFormsSPW[] = TEXT("Software\\Microsoft\\Internet Explorer\\IntelliForms\\SPW");
const TCHAR c_szRegKeyRestrict[] = TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel");

const TCHAR c_szRegValUseFormSuggest[] = TEXT("Use FormSuggest");
const TCHAR c_szRegValFormSuggestRestrict[] = TEXT("FormSuggest");
const TCHAR c_szRegValSavePasswords[] = TEXT("FormSuggest Passwords");
const TCHAR c_szRegValAskPasswords[] = TEXT("FormSuggest PW Ask");
const TCHAR c_szRegValAskUser[] = TEXT("AskUser");

interface IAutoComplete2;
interface IAutoCompleteDropDown;
class CStringList;

#define IF_CHAR             WM_APP  + 0x08
#define IF_KEYDOWN          WM_APP  + 0x09
#define IF_IME_COMPOSITION  WM_APP  + 0x0A

/////////////////////////////////////////////////////////////////////////////
// CIntelliForms
class CEventSinkCallback
{
public:
    typedef enum
    {
        EVENT_BOGUS     = 100,
        EVENT_KEYDOWN   = 0,
        EVENT_KEYPRESS,
        EVENT_MOUSEDOWN,
        EVENT_DBLCLICK,
        EVENT_FOCUS,
        EVENT_BLUR,
        EVENT_SUBMIT,
        EVENT_SCROLL,

        EVENT_COMPOSITION,
        EVENT_NOTIFY,
    }
    EVENTS;

    typedef struct
    {
        EVENTS                      Event;
        LPCWSTR                     pwszEventSubscribe;
        LPCWSTR                     pwszEventName;
    }
    EventSinkEntry;

    virtual HRESULT HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj) = 0;

    static EventSinkEntry EventsToSink[];
};

class CEditEventSinkCallback
{
public:
    virtual HRESULT PreHandleEvent(DISPID inEvtDispId, IHTMLEventObj* pIEventObj) = 0;
};

class CIntelliForms : 
    public CEventSinkCallback,
    public CEditEventSinkCallback
{
    long    m_cRef;

public:
    class CEventSink;
    class CEditEventSink;
    class CAutoSuggest;
    friend CAutoSuggest;

    CIntelliForms();
    ~CIntelliForms();

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


    // CEventSinkCallback
    HRESULT HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj);

    // CEditEventSinkCallback
    HRESULT PreHandleEvent(DISPID inEvtDispId, IHTMLEventObj* pIEventObj);

public:
    HRESULT Init(CIEFrameAuto::COmWindow *pOmWindow, IHTMLDocument2 *pDoc2, HWND hwnd);
    HRESULT UnInit();

    LPCWSTR GetUrl();

    HRESULT UserInput(IHTMLInputTextElement *pTextEle);

    HRESULT WriteToStore(LPCWSTR pwszName, CStringList *psl);
    HRESULT ReadFromStore(LPCWSTR pwszName, CStringList **ppsl, BOOL fPasswordList=FALSE);
    HRESULT DeleteFromStore(LPCWSTR pwszName);
    HRESULT ClearStore(DWORD dwClear);

    BOOL    IsRestricted() { return m_fRestricted; }
    BOOL    IsRestrictedPW() { return m_fRestrictedPW; }

    IUnknown *GetDocument() { return m_punkDoc2; }

    HRESULT ScriptSubmit(IHTMLFormElement *pForm);
    HRESULT HandleFormSubmit(IHTMLFormElement *pForm);

    // for CEnumString
    HRESULT GetPasswordStringList(CStringList **ppslPasswords);
    // for IntelliFormsSaveForm
    CIntelliForms *GetNext() { return m_pNext; }

    BOOL    IsEnabledForPage();

    static HRESULT GetName(IHTMLInputTextElement *pTextEle, BSTR *pbstrName);

    // Default to disabled, since we need to ask the user before enabling it
    static BOOL    IsEnabledInCPL() {
                        return IsEnabledInRegistry(c_szRegKeySMIEM, c_szRegValUseFormSuggest, FALSE); }
    // Default to enabled, since we prompt before saving passwords anyway
    static BOOL    IsEnabledRestorePW() {
                        return IsEnabledInRegistry(c_szRegKeySMIEM, c_szRegValSavePasswords, TRUE); }
    static BOOL    IsEnabledAskPW() {
                        return IsEnabledRestorePW() &&
                            IsEnabledInRegistry(c_szRegKeySMIEM, c_szRegValAskPasswords, TRUE); }

    static BOOL    IsAdminRestricted(LPCTSTR pszRegVal);

    BOOL AskedUserToEnable();
    
    typedef HRESULT (*PFN_ENUM_CALLBACK)(IDispatch *pDispEle, DWORD_PTR dwCBData);
    HRESULT ActiveElementChanged(IHTMLElement * pHTMLElement);

protected:
    enum { LIST_DATA_PASSWORD = 1 };    // Flag to indicate a password list in store

    HRESULT AddToElementList(IHTMLInputTextElement *pITE);
    HRESULT FindInElementList(IHTMLInputTextElement *pITE);
    void    FreeElementList();

    HRESULT AddToFormList(IHTMLFormElement *pFormEle);
    HRESULT FindInFormList(IHTMLFormElement *pFormEle);
    void    FreeFormList();

    static BOOL IsElementEnabled(IHTMLElement *pEle);
    static HRESULT ShouldAttachToElement(IUnknown *, BOOL fCheckForm, 
                                IHTMLElement2**, IHTMLInputTextElement**, IHTMLFormElement**, BOOL *pfPassword);

    HRESULT SubmitElement(IHTMLInputTextElement *pITE, FILETIME ft, BOOL fEnabledInCPL);

    LPCWSTR GetUrlHash();
    
    BOOL ArePasswordsSaved();
    BOOL LoadPasswords();
    void SavePasswords();
    HRESULT FindPasswordEntry(LPCWSTR pwszValue, int *piIndex);
    void SetPasswordsAreSaved(BOOL fSaved);
    HRESULT AutoFillPassword(IHTMLInputTextElement *pTextEle, LPCWSTR pwszUsername);
    HRESULT SavePassword(IHTMLFormElement *pFormEle, FILETIME ftSubmit, IHTMLInputTextElement *pFirstEle);
    HRESULT DeletePassword(LPCWSTR pwszUsername);

    HRESULT AttachToForm(IHTMLFormElement *pFormEle);

    HRESULT CreatePStore();
    HRESULT CreatePStoreAndType();
    void ReleasePStore();

    static BOOL IsEnabledInRegistry(LPCTSTR pszKey, LPCTSTR pszValue, BOOL fDefault);

    inline void EnterModalDialog();
    inline void LeaveModalDialog();


private:
    // CIntelliForms member variables
    CEventSink  *m_pSink;
    CEditEventSink *m_pEditSink;
    CAutoSuggest *m_pAutoSuggest;   // Can attach to one edit control at a time

    HINSTANCE   m_hinstPStore;
    IPStore     *m_pPStore;
    BOOL        m_fPStoreTypeInit : 1;  // Our types initialized

    HDPA        m_hdpaElements;         // Elements user has modified
    HDPA        m_hdpaForms;            // Forms we are sinked to

    BOOL        m_fCheckedIfEnabled : 1; // Checked if we're enabled for this page?
    BOOL        m_fEnabledForPage : 1;   // We're enabled for this page (non-SSL)?
    BOOL        m_fHitPWField : 1;      // Went to a password field?
    BOOL        m_fCheckedPW  : 1;      // Checked if we have a password for this URL?
    CStringList *m_pslPasswords;        // Usernames && Passwords for page, if any
    int         m_iRestoredIndex;       // Index of restored password in m_pslPasswords (-1=none)
    BOOL        m_fRestricted : 1;      // Are we restricted for normal Intelliforms?
    BOOL        m_fRestrictedPW : 1;    // Are save passwords restricted?

    // Lifetime management - see Enter/LeaveModalDialog
    BOOL        m_fInModalDialog : 1;   // Are we in a dialog?
    BOOL        m_fUninitCalled : 1;    // Was Uninit called during dialog?

    // Useful stuff for the attached document
    HWND            m_hwndBrowser;
    IHTMLDocument2 *m_pDoc2;
    IUnknown       *m_punkDoc2;
    
    CIEFrameAuto::COmWindow   *m_pOmWindow;

    BSTR        m_bstrFullUrl;          // Full url if https: protocol (security check)
    BSTR        m_bstrUrl;              // Full url with anchor/query string stripped
    LPCWSTR     m_pwszUrlHash;          // String based on UrlHash(m_bstrUrl)

    // Linked list of objects, to find CIntelliForms object for IHTMLDocument2
    CIntelliForms *m_pNext;

public:
    // GUID to use for subtype of PStore - identity GUID or c_PStoreType
    GUID        m_guidUserId;

public:
    // Helper classes
    template <class TYPE> class CEnumCollection
    {
    public:
        static HRESULT EnumCollection(TYPE *pCollection, PFN_ENUM_CALLBACK pfnCB, DWORD_PTR dwCBData);
    };

    // Sinks regular Trident events. Calls back via CEventSinkCallback
    class CEventSink : public IDispatch
    {
        ULONG   m_cRef;

    public:

        CEventSink(CEventSinkCallback *pParent);
        ~CEventSink();

        HRESULT SinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents);
        HRESULT UnSinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents);
        HRESULT SinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents);
        HRESULT UnSinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents);

        void SetParent(CEventSinkCallback *pParent) { m_pParent = pParent; }

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
        STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo);
        STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
            LCID lcid, DISPID *rgDispId);
        STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pVarResult,
            EXCEPINFO *pExcepInfo, UINT *puArgErr);

    private:
        CEventSinkCallback *m_pParent;
    };

    // Sinks editing Trident events. Required for IME events. Callback CEditEventSinkCallback
    class CEditEventSink : public IHTMLEditDesigner
    {
        ULONG   m_cRef;

    public:
        CEditEventSink(CEditEventSinkCallback *pParent);
        ~CEditEventSink();

        HRESULT Attach(IUnknown *punkElement);  // Attach(NULL) to detach
        void SetParent(CEditEventSinkCallback *pParent) { m_pParent = pParent; }

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IHTMLEditDesigner
        STDMETHODIMP PreHandleEvent(DISPID inEvtDispId, IHTMLEventObj *pIEventObj);
        STDMETHODIMP PostHandleEvent(DISPID inEvtDispId, IHTMLEventObj *pIEventObj);
        STDMETHODIMP TranslateAccelerator(DISPID inEvtDispId, IHTMLEventObj *pIEventObj);
        STDMETHODIMP PostEditorEventNotify(DISPID inEvtDispId, IHTMLEventObj *pIEventObj) {return S_FALSE;}

    private:
        CEditEventSinkCallback  *m_pParent;
        IHTMLEditServices       *m_pEditServices;   // we keep a ref so we can unsink
    };

    class CAutoSuggest : public CEventSinkCallback
    {
        class CEnumString;

    public:
        CAutoSuggest(CIntelliForms *pParent, BOOL fEnabled, BOOL fEnabledSPW);
        ~CAutoSuggest();

        void SetParent(CIntelliForms *pParent) { m_pParent = pParent; }

        HRESULT AttachToInput(IHTMLInputTextElement *pTextEle);
        HRESULT DetachFromInput();

        static LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

        static EVENTS s_EventsToSink[];

    protected:
        // Called by window to perform requests by CAutoComplete to MSHTML
        HRESULT GetText(int cchTextMax, LPWSTR pszTextOut, LRESULT *lcchCopied);
        HRESULT GetTextLength(int *pcch);
        HRESULT SetText(LPCWSTR pszTextIn);

        void CheckAutoFillPassword(LPCWSTR pwszUsername);

        inline void MarkDirty();

    public:
        // Called to pass on events from MSHTML to CAutoComplete
        HRESULT HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj);
        HRESULT UpdateDropdownPosition();

        IHTMLInputTextElement *AttachedElement() { return m_pTextEle; }
        
    private:
        HRESULT CreateAutoComplete();
        
        HRESULT CleanUp();

        CIntelliForms  *m_pParent;          // No refcount
        CEventSink     *m_pEventSink;
        IAutoComplete2 *m_pAutoComplete;
        IAutoCompleteDropDown *m_pAutoCompleteDD;
        HWND            m_hwndEdit;
        IHTMLInputTextElement *m_pTextEle;
        CEnumString    *m_pEnumString;
        long        m_lCancelKeyPress;

        BOOL        m_fAddedToDirtyList : 1;        // Add to list once they hit a key

        BOOL        m_fAllowAutoFillPW : 1;         // Call AutoFillPassword?
        BSTR        m_bstrLastUsername;             // Last Username we called AutoFillPassword for

        BOOL        m_fInitAutoComplete : 1;        // Initialized Auto Complete?

        BOOL        m_fEnabled : 1;                 // Regular intelliforms enabled?
        BOOL        m_fEnabledPW : 1;               // Restore passwords enabled?

        BOOL        m_fEscapeHit : 1;               // Escape key used to dismiss dropdown?

        UINT        m_uMsgItemActivate;             // registered message from autocomplete
        static BOOL s_fRegisteredWndClass;

        // This object is thread-safed because AutoComplete calls on second thread
        class CEnumString : public IEnumString
        {
            long    m_cRef;

        public:
            CEnumString();
            ~CEnumString();

            HRESULT Init(IHTMLInputTextElement *pInputEle, CIntelliForms *pIForms);
            void UnInit();

            HRESULT ResetEnum();

            STDMETHODIMP QueryInterface(REFIID, void **);
            STDMETHODIMP_(ULONG) AddRef(void);
            STDMETHODIMP_(ULONG) Release(void);

            // IEnumString
            virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
            virtual STDMETHODIMP Skip(ULONG celt) { return E_NOTIMPL; }
            virtual STDMETHODIMP Reset();
            virtual STDMETHODIMP Clone(IEnumString **ppenum) { return E_NOTIMPL; }

        protected:
            HRESULT FillEnumerator();       // called on secondary thread

            CRITICAL_SECTION m_crit;
            CStringList *m_pslMain;
            BSTR    m_bstrName;         // name of input field
            LPWSTR  m_pszOpsValue;      // value from profile assistant
            CIntelliForms *m_pIntelliForms;

            int     m_iPtr;

            BOOL    m_fFilledStrings : 1;
            BOOL    m_fInit : 1;
        };
    };
};

template <class TYPE>
HRESULT CIntelliForms::CEnumCollection<TYPE>::EnumCollection(
            TYPE                   *pCollection,
            PFN_ENUM_CALLBACK       pfnCB,
            DWORD_PTR               dwCBData)
{
    IDispatch       *pDispItem;

    HRESULT hr;
    long    l, lCount;
    VARIANT vIndex, vEmpty;

    VariantInit(&vEmpty);
    VariantInit(&vIndex);

    hr = pCollection->get_length(&lCount);

    if (FAILED(hr))
        lCount = 0;

    for (l=0; l<lCount; l++)
    {
        vIndex.vt = VT_I4;
        vIndex.lVal = l;

        hr = pCollection->item(vIndex, vEmpty, &pDispItem);

        if (SUCCEEDED(hr) && pDispItem)
        {
            hr = pfnCB(pDispItem, dwCBData);

            pDispItem->Release();
        }

        if (E_ABORT == hr)
        {
            break;
        }
    }

    return hr;
}

inline void CIntelliForms::CAutoSuggest::MarkDirty()
{
    if (!m_fAddedToDirtyList && m_pParent)
    {
        m_fAddedToDirtyList = TRUE;
        m_pParent->UserInput(m_pTextEle);
    }
}

// These wrap modal dialogs, keeping us alive and attached to the document
//  even if something weird happens while our dlgbox messageloop is alive
inline void CIntelliForms::EnterModalDialog()
{
    ASSERT(!m_fInModalDialog);  // Don't support nested Enter/Leave
    ASSERT(!m_fUninitCalled);

    m_fInModalDialog = TRUE;    // Keep us attached to document
    
    AddRef();                   // Keep us alive
}

inline void CIntelliForms::LeaveModalDialog()
{
    ASSERT(m_fInModalDialog);

    m_fInModalDialog = FALSE;
    
    if (m_fUninitCalled)
    {
        UnInit();           // Detach from document
    }

    Release();
}

// HKCU/S/MS/Win/CV/IForms/Names  /[name]/ SIndex | SData

// CStringList is optimized for appending arbitrary amounts of strings and converting to and
//  from blobs. It is not optimized for deleting or inserting strings.
class CStringList
{
protected:
    CStringList();

public:
    ~CStringList();

    friend static HRESULT CStringList_New(CStringList **ppNew, BOOL fAutoDelete=TRUE);

    // E_FAIL, S_FALSE (duplicate), S_OK
    HRESULT AddString(LPCWSTR lpwstr, int *piNum = NULL);
    HRESULT AddString(LPCWSTR lpwstr, FILETIME ft, int *piNum = NULL);

    // E_FAIL, S_OK   Doesn't check for duplicates
    HRESULT AppendString(LPCWSTR lpwstr, FILETIME ft, int *piNum = NULL);

    // iLen must be length in characters of string, not counting null term.
    // -1 if unknown. *piNum filled in with index if specified
    HRESULT FindString(LPCWSTR lpwstr, int iLen/*=-1*/, int *piNum/*=NULL*/, BOOL fCaseSensitive);

    inline int      NumStrings();
    inline LPCWSTR  GetString(int iIndex);
    inline LPWSTR   GetStringPtr(int iIndex);
    inline DWORD    GetStringLen(int iIndex);
    inline HRESULT  GetStringTime(int iIndex, FILETIME *ft);
    inline HRESULT  SetStringTime(int iIndex, FILETIME ft);
    inline HRESULT  UpdateStringTime(int iIndex, FILETIME ft);

    HRESULT GetBSTR(int iIndex, BSTR *pbstrRet);
    HRESULT GetTaskAllocString(int iIndex, LPOLESTR *pRet);

    inline HRESULT  GetListData(INT64 *piData);
    inline HRESULT  SetListData(INT64 iData);

    // If set to TRUE, CStringList will delete old strings when full
    void SetAutoScavenge(BOOL fAutoScavenge) { m_fAutoScavenge=fAutoScavenge; }

    HRESULT DeleteString(int iIndex);
    HRESULT InsertString(int iIndex, LPCWSTR lpwstr);
    HRESULT ReplaceString(int iIndex, LPCWSTR lpwstr);

    // Functions to read/write to the store; converts to and from BLOBs
    // For efficiencies sake these take and return heap alloced blobs
    HRESULT WriteToBlobs(LPBYTE *ppBlob1, DWORD *pcbBlob1, LPBYTE *ppBlob2, DWORD *pcbBlob2);
    HRESULT ReadFromBlobs(LPBYTE *ppBlob1, DWORD cbBlob1, LPBYTE *ppBlob2, DWORD cbBlob2);

    static HRESULT GetFlagsFromIndex(LPBYTE pBlob1, INT64 *piFlags);

    // Warning: Don't set max strings past the MAX_STRINGS constant our ReadFromBlobs will fail
    //  if you save/restore the string list
    void SetMaxStrings(DWORD dwMaxStrings) { m_dwMaxStrings = dwMaxStrings; }
    DWORD GetMaxStrings() { return m_dwMaxStrings; }
    
    enum { MAX_STRINGS = 200 };
    
protected:
    enum { INDEX_SIGNATURE=0x4B434957 };        // WICK
    enum { INIT_BUF_SIZE=1024 };

#pragma warning (disable: 4200)     // zero-sized array warning
typedef struct 
{
    DWORD   dwSignature;    // Offset: 00
    DWORD   cbSize;         // Offset: 04 (up to not including first StringEntry)
    DWORD   dwNumStrings;   // Offset: 08 (Num of StringEntry present)
                            // Offset: 0C (--PAD--)
    INT64   iData;          // Offset: 10 (Extra data for string list user)

    struct tagStringEntry
    {
        DWORD       dwStringPtr;        // Offset: 18 (Offset of string in buffer)
        FILETIME    ftLastSubmitted;    // Offset: 1C (filetime of last submit) (unaligned)
        DWORD       dwStringLen;        // Offset: 24 (Length of this string)
    }
    StringEntry[];

} StringIndex;
#pragma warning (default: 4200)

// Value for cbSize in StringIndex
#define STRINGINDEX_CBSIZE PtrToUlong(&((StringIndex*)NULL)->StringEntry)
#define STRINGENTRY_SIZE (PtrToUlong(&((StringIndex*)NULL)->StringEntry[1]) - STRINGINDEX_CBSIZE )
// Size of StringIndex for given number of strings 
#define INDEX_SIZE(n) (STRINGINDEX_CBSIZE + (n)*STRINGENTRY_SIZE)


    void    CleanUp();
    HRESULT Init(DWORD dwBufSize=0);
    HRESULT Validate();

    HRESULT EnsureBuffer(DWORD dwSizeNeeded);
    HRESULT EnsureIndex(DWORD dwNumStringsNeeded);

    HRESULT _AddString(LPCWSTR lpwstr, BOOL fCheckDuplicates, int *piNum);

private:
    StringIndex *m_psiIndex;            // Index of strings
    DWORD   m_dwIndexSize;              // size in bytes of m_psiIndex

    LPBYTE  m_pBuffer;                  // Holds all character data
    DWORD   m_dwBufEnd;                 // Last byte used in buffer
    DWORD   m_dwBufSize;                // Size of buffer in bytes

    DWORD   m_dwMaxStrings;             // Max # strings

    BOOL    m_fAutoScavenge:1;          // Automatically remove old strings when full?
};

// We really only use this for comparing to 0, so this method works just as well and does not require alignment.
#define FILETIME_TO_INT(ft) (ft.dwLowDateTime | ft.dwHighDateTime)

inline int     CStringList::NumStrings()
{
    if (!m_psiIndex) return 0;
    return m_psiIndex->dwNumStrings;
}

inline LPCWSTR CStringList::GetString(int iIndex)
{
    if (!m_psiIndex) return NULL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    return (LPCWSTR) (m_pBuffer + m_psiIndex->StringEntry[iIndex].dwStringPtr);
}

inline LPWSTR CStringList::GetStringPtr(int iIndex)
{
    if (!m_psiIndex) return NULL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    return (LPWSTR) (m_pBuffer + m_psiIndex->StringEntry[iIndex].dwStringPtr);
}

inline DWORD CStringList::GetStringLen(int iIndex)
{ 
    if (!m_psiIndex) return E_FAIL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    return m_psiIndex->StringEntry[iIndex].dwStringLen;
}

inline HRESULT CStringList::GetStringTime(int iIndex, FILETIME *ft)
{
    if (!m_psiIndex) return E_FAIL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    *ft = m_psiIndex->StringEntry[iIndex].ftLastSubmitted;
    return S_OK;
}

inline HRESULT CStringList::SetStringTime(int iIndex, FILETIME ft)
{
    if (!m_psiIndex) return E_FAIL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    ASSERT(-1 != CompareFileTime(&ft, &m_psiIndex->StringEntry[iIndex].ftLastSubmitted));
    m_psiIndex->StringEntry[iIndex].ftLastSubmitted = ft;
    return S_OK;
}

inline HRESULT CStringList::UpdateStringTime(int iIndex, FILETIME ft)
{
    if (!m_psiIndex) return E_FAIL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    if (1 == CompareFileTime(&ft, &m_psiIndex->StringEntry[iIndex].ftLastSubmitted))
    {
        m_psiIndex->StringEntry[iIndex].ftLastSubmitted = ft;
        return S_OK;
    }
    return S_FALSE;
}
inline HRESULT CStringList::GetListData(INT64 *piData)
{
    if (m_psiIndex)
    {
        *piData = m_psiIndex->iData;
        return S_OK;
    }
    return E_FAIL;
}
inline HRESULT CStringList::SetListData(INT64 iData)
{
    if (!m_psiIndex && FAILED(Init()))
        return E_FAIL;

    m_psiIndex->iData = iData;
    return S_OK;
}
/*
inline HRESULT CStringList::GetStringData(int iIndex, DWORD *pdwData)
{
    if (!m_psiIndex) return E_FAIL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    *pdwData = m_psiIndex->StringEntry[iIndex].dwData;
    return S_OK;
}

inline HRESULT CStringList::SetStringData(int iIndex, DWORD dwData)
{
    if (!m_psiIndex) return E_FAIL;
    ASSERT((DWORD)iIndex < m_psiIndex->dwNumStrings);
    m_psiIndex->StringEntry[iIndex].dwData = dwData;
    return S_OK;
}
*/
#endif //__IFORMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\impexp.cpp ===
//
// IMPEXP.CPP - Browser Import and Export Code
//
// Imports and Exports Favorites in various formats
//
// julianj  2/16/98
//

//
// *** IMPORT FAVORITES CODE ***
//

   /************************************************************\
    FILE: impext.cpp

    DATE: April 1, 1996

    AUTHOR(S):  Bryan Starbuck (bryanst)

    DESCRIPTION:
    This file contains functions that can be used to upgrade
    settings from the Microsoft Internet Explorer v2.0 to v3.0,
    and some features to import Netscape features into Internet
    Explorer.

    This file will handle the logic to convert Netscape
    bookmarks to Microsoft Internet Explorer favorites.  This
    will happen by finding the location of the Netscape bookmarks
    file and the Microsoft Internet Explorer favorites directory
    from the registry.  Then it will parse the bookmarks file to
    extract the URLs, which will finally be added to the favorites
    directory.

    USAGE:
    This code is designed to be called when the user may
    want Netscape bookmarks imported into system level Favorites
    usable by programs such as Internet Explorer.  External
    users should call ImportBookmarks().  If this is done during
    setup, it should be done after setup specifies the Favorites
    registry entry and directory.  If Netscape is not installed,
    then the ImportBookmarks() is just a big no-op.

  NOTE:
    If this file is being compiled into something other
    than infnist.exe, it will be necessary to include the
    following String Resource:

    #define     IDS_NS_BOOKMARKS_DIR    137
    STRINGTABLE DISCARDABLE
    BEGIN
    ...
    IDS_NS_BOOKMARKS_DIR    "\\Imported Bookmarks"
    END


  UPDATES:  I adopted this file to allow IE4.0 having the abilities
    to upgrade from NetScape's setting.  Two CustomActions will be added
    to call in functions in this file. (inateeg)

    8/14/98: added functions to import or export via an URL,
    8/19/98: added UI to allow user to import/export via browser's File 
            menu/"Import and Exporting..."
\************************************************************/
#include "priv.h"
#include "impexp.h"
#include <regstr.h>
#include "resource.h"

#include <mluisupp.h>

//
// Information about the Netscape Bookmark file format that is shared between
// the import and export code
// 

#define BEGIN_DIR_TOKEN         "<DT><H"
#ifdef UNIX
#define MID_DIR_TOKEN0          "3>"
#endif
#define MID_DIR_TOKEN           "\">"
#define END_DIR_TOKEN           "</H"
#define BEGIN_EXITDIR_TOKEN     "</DL><p>"
#define BEGIN_URL_TOKEN         "<DT><A HREF=\""
#define END_URL_TOKEN           "\" A"
#ifdef UNIX
#define END_URL_TOKEN2          "\">"
#endif
#define BEGIN_BOOKMARK_TOKEN    ">"
#define END_BOOKMARK_TOKEN      "</A>"

#define VALIDATION_STR "<!DOCTYPE NETSCAPE-Bookmark-file-"

//
// Use by export code
// 
#define COMMENT_STR "<!-- This is an automatically generated file.\r\nIt will be read and overwritten.\r\nDo Not Edit! -->"
#define TITLE     "<TITLE>Bookmarks</TITLE>\r\n<H1>Bookmarks</H1>"

// ItemType is going to be the type of entry found in the bookmarks
// file.
typedef enum MYENTRYTYPE
{
    ET_OPEN_DIR     = 531,  // New level in heirarchy
    ET_CLOSE_DIR,           // Close level in heirarchy
    ET_BOOKMARK,            // Bookmark entry.
    ET_NONE,                // End of File
    ET_ERROR                // Bail, we encountered an error
} MyEntryType;

//////////////////////////////////////////////////////////////////
//  Internal Functions
//////////////////////////////////////////////////////////////////
BOOL    ImportNetscapeProxy(void);		// Import Netscape Proxy Setting
BOOL    UpdateHomePage(void);			// Upgrade IE v1.0 Home URL to v3.0
BOOL    ImportBookmarks(TCHAR *pszPathToFavorites, TCHAR *pszPathToBookmarks, HWND hwnd);			//  Import Netscape Bookmarks to IE Favorites
BOOL    ExportFavorites(TCHAR *pszPathToFavorites, TCHAR *pszPathToBookmarks, HWND hwnd);			//  Export IE Favorites to Netscape Bookmarks
BOOL    RegStrValueEmpty(HKEY hTheKey, char * szPath, char * szKey);
BOOL    GetNSProxyValue(char * szProxyValue, DWORD * pdwSize);

BOOL        VerifyBookmarksFile(HANDLE hFile);
BOOL        ConvertBookmarks(TCHAR * szFavoritesDir, HANDLE hFile);
MyEntryType   NextFileEntry(char ** ppStr, char ** ppToken);
BOOL        GetData(char ** ppData, HANDLE hFile);
void        RemoveInvalidFileNameChars(char * pBuf);
BOOL        CreateDir(char *pDirName);
BOOL        CloseDir(void);
BOOL        CreateBookmark(char *pBookmarkName);
BOOL        GetPathFromRegistry(LPTSTR szPath, UINT cbPath, HKEY theHKEY, LPTSTR szKey, LPTSTR szVName);
BOOL        GetNavBkMkDir( LPTSTR lpszDir, int isize);
BOOL        GetTargetFavoritesPath(LPTSTR szPath, UINT cbPath);

BOOL    PostFavorites(TCHAR *pszPathToBookmarks, TCHAR* pszPathToPost);
void    CALLBACK StatusCallback(HINTERNET hInternet, DWORD_PTR dwContext, DWORD dwStatus,
            LPVOID lpvInfo, DWORD dwInfoLength);

//////////////////////////////////////////////////////////////////
//  TYPES:
//////////////////////////////////////////////////////////////////

//typedef enum MYENTRYTYPE MyEntryType;

//////////////////////////////////////////////////////////////////
//  Constants:
//////////////////////////////////////////////////////////////////
#define MAX_URL 2048
#define FILE_EXT 4          // For ".url" at the end of favorite filenames
#define REASONABLE_NAME_LEN     100


#define ANSIStrStr(p, q) StrStrIA(p, q)
#define ANSIStrChr(p, q) StrChrIA(p, q)

//////////////////////////////////////////////////////////////////
//  GLOBALS:
//////////////////////////////////////////////////////////////////
#ifndef UNIX
TCHAR   * szNetscapeBMRegSub        = TEXT("SOFTWARE\\Netscape\\Netscape Navigator\\Bookmark List");
#else
TCHAR   * szNetscapeBMRegSub        = TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\unix\\nsbookmarks");
#endif

TCHAR   * szNetscapeBMRegKey        = TEXT("File Location");
TCHAR   * szIEFavoritesRegSub       = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
TCHAR   * szIEFavoritesRegKey       = TEXT("Favorites");
char    * szInvalidFolderCharacters = "\\/:*?\"<>|";

BOOL    gfValidNetscapeFile = FALSE;
BOOL    gfValidIEDirFile = FALSE;

// Returns the location of the favorites folder in which to import the netscape favorites
BOOL GetTargetFavoritesPath(LPTSTR szPath, UINT cbPath)
{
    if (GetPathFromRegistry(szPath, cbPath, HKEY_CURRENT_USER, szIEFavoritesRegSub, szIEFavoritesRegKey))
    {
        //MLLoadString(IDS_NS_BOOKMARKS_DIR, szSubDir, sizeof(szSubDir))
        //lstrcat(szPath, "\\Imported Netscape Favorites");
        return TRUE;
    }
    return FALSE;
}

///////////////////////////////////////////////////////
//  Import Netscape Bookmarks to Microsoft
//  Internet Explorer's Favorites
///////////////////////////////////////////////////////

/************************************************************\
    FUNCTION: ImportBookmarks

    PARAMETERS:
    HINSTANCE hInstWithStr - Location of String Resources.
    BOOL return - If an error occurs importing the bookmarks, FALSE is returned.

    DESCRIPTION:
    This function will see if it can find a IE Favorite's
    registry entry and a Netscape bookmarks registry entry.  If
    both are found, then the conversion can happen.  It will
    attempt to open the verify that the bookmarks file is
    valid and then convert the entries to favorite entries.
    If an error occures, ImportBookmarks() will return FALSE,
    otherwise it will return TRUE.
\*************************************************************/

BOOL ImportBookmarks(TCHAR *pszPathToFavorites, TCHAR *pszPathToBookmarks, HWND hwnd)
{
    HANDLE  hBookmarksFile        = INVALID_HANDLE_VALUE;
    BOOL    fSuccess              = FALSE;

    // Prompt the user to insert floppy, format floppy or drive, remount mapped partition,
    // or any create sub directories so pszPathToBookmarks becomes valid.
    if (FAILED(SHPathPrepareForWriteWrap(hwnd, NULL, pszPathToBookmarks, FO_COPY, (SHPPFW_DEFAULT | SHPPFW_IGNOREFILENAME))))
        return FALSE;

    if (pszPathToFavorites==NULL || *pszPathToFavorites == TEXT('\0') ||
        pszPathToBookmarks==NULL || *pszPathToBookmarks == TEXT('\0'))
    {
        return FALSE;
    }
    
    hBookmarksFile = CreateFile(pszPathToBookmarks, GENERIC_READ, FILE_SHARE_READ, NULL, 
                                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
    
    if ( hBookmarksFile != INVALID_HANDLE_VALUE ) 
    {
        //
        // Verify it's a valid Bookmarks file
        //
        if (VerifyBookmarksFile( hBookmarksFile ))
        {
            //
            // Do the importing...
            //
            fSuccess = ConvertBookmarks(pszPathToFavorites, hBookmarksFile);

            if (hwnd && !fSuccess)
            {
                MLShellMessageBox(
                    hwnd,
                    MAKEINTRESOURCE(IDS_IMPORTCONVERTERROR),
                    MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV),
                    MB_OK);
            }
        }
        else
        {
            if (hwnd)
            {
                MLShellMessageBox(
                    hwnd,
                    MAKEINTRESOURCE(IDS_NOTVALIDBOOKMARKS),
                    MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV),
                    MB_OK);
            }
        }
        CloseHandle(hBookmarksFile);
    }
    else
    {
        if (hwnd)
        {
            MLShellMessageBox(
                hwnd,
                MAKEINTRESOURCE(IDS_COULDNTOPENBOOKMARKS),
                MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV),
                MB_OK);
        }
    }
    return(fSuccess);
}


/************************************************************\
    FUNCTION: ConvertBookmarks

    PARAMETERS:
    char * szFavoritesDir - String containing the path to
            the IE Favorites directory
    BOOL return - If an error occurs importing the bookmarks, FALSE is returned.

    DESCRIPTION:
    This function will continue in a loop converting each
    entry in the bookmark file.  There are three types of
    entries in the bookmark file, 1) a bookmark, 2) start of
    new level in heirarchy, 3) end of current level in heirarchy.
    The function NextFileEntry() will return these values until
    the file is empty, at which point, this function will end.

    NOTE:
    In order to prevent an infinite loop, it's assumed
    that NextFileEntry() will eventually return ET_NONE or ET_ERROR.
\************************************************************/

BOOL ConvertBookmarks(TCHAR * szFavoritesDir, HANDLE hFile)
{
    BOOL    fDone       = FALSE;
    BOOL    fSuccess    = TRUE;
    BOOL    fIsEmpty    = TRUE;
    char    * szData    = NULL;
    char    * szCurrent = NULL;
    char    * szToken   = NULL;

    fSuccess = GetData(&szData, hFile);
    if (NULL == szData)
        fSuccess = FALSE;

    szCurrent = szData;

    // Verify directory exists or that we can make it.
    if ((TRUE == fSuccess) && ( !SetCurrentDirectory(szFavoritesDir)))
    {
        // If the directory doesn't exist, make it...
        if ( !CreateDirectory(szFavoritesDir, NULL))
            fSuccess = FALSE;
        else
            if (!SetCurrentDirectory(szFavoritesDir))
                fSuccess = FALSE;
    }

   
    while ((FALSE == fDone) && (TRUE == fSuccess))
    {
        switch(NextFileEntry(&szCurrent, &szToken))
        {
            case ET_OPEN_DIR:
                fSuccess = CreateDir(szToken);
                break;
            case ET_CLOSE_DIR:
                fSuccess = CloseDir();
                break;
            case ET_BOOKMARK:
                fSuccess = CreateBookmark(szToken);
                fIsEmpty = FALSE;
                break;
            case ET_ERROR:
                fSuccess = FALSE;
                break;
            case ET_NONE:            
            default:
                fDone = TRUE;
                break;
        }
    }

    if ( fIsEmpty )
    {
        // nothing to import, delete the dir created earlier
        RemoveDirectory(szFavoritesDir);
    }

    if (NULL != szData)
    {
        LocalFree(szData);
        szData = NULL;
        szCurrent = NULL;       // szCurrent no longer points to valid data.
        szToken = NULL;     // szCurrent no longer points to valid data.
    }

    return(fSuccess);
}

/************************************************************\
    FUNCTION: NextFileEntry

    PARAMETERS:
    char ** ppStr   - The data to parse.
    char ** ppToken - The token pointer.
    EntryType return- See below.

    DESCRIPTION:
    This function will look for the next entry in the
    bookmark file to create or act on.  The return value
    will indicate this response:
    ET_OPEN_DIR             Create a new level in heirarchy
    ET_CLOSE_DIR,           Close level in heirarchy
    ET_BOOKMARK,            Create Bookmark entry.
    ET_NONE,                End of File
    ET_ERROR                Error encountered

    Errors will be detected by finding the start of a token,
    but in not finding other parts of the token that are needed
    to parse the data.
\************************************************************/

MyEntryType NextFileEntry(char ** ppStr, char ** ppToken)
{
    MyEntryType   returnVal       = ET_NONE;
    char *      pCurrentToken   = NULL;         // The current token to check if valid.
    char *      pTheToken       = NULL;         // The next valid token.
    char *      pszTemp         = NULL;
#ifdef UNIX
    char        szMidDirToken[8];
#endif

    //ASSERTSZ(NULL != ppStr, "It's an error to pass NULL for ppStr");
    //ASSERTSZ(NULL != *ppStr, "It's an error to pass NULL for *ppStr");
    //ASSERTSZ(NULL != ppToken, "It's an error to pass NULL for ppToken");

    if ((NULL != ppStr) && (NULL != *ppStr) && (NULL != ppToken))
    {
        // Check for begin dir token
        if (NULL != (pCurrentToken = ANSIStrStr(*ppStr, BEGIN_DIR_TOKEN)))
        {
            // Begin dir token found
            // Verify that other needed tokens exist or it's an error
#ifndef UNIX
            if ((NULL == (pszTemp = ANSIStrStr(pCurrentToken, MID_DIR_TOKEN))) ||
#else
	    if (pCurrentToken[7] == ' ')
	        StrCpyNA(szMidDirToken, MID_DIR_TOKEN, ARRAYSIZE(szMidDirToken));
	    else
	        StrCpyNA(szMidDirToken, MID_DIR_TOKEN0, ARRAYSIZE(szMidDirToken));
            if ((NULL == (pszTemp = ANSIStrStr(pCurrentToken, szMidDirToken))) ||
#endif
                (NULL == ANSIStrStr(pszTemp, END_DIR_TOKEN)))
            {
                returnVal = ET_ERROR;       // We can't find all the tokens needed.
            }
            else
            {
                // This function has to set *ppToken to the name of the directory to create
#ifndef UNIX
                *ppToken =  ANSIStrStr(pCurrentToken, MID_DIR_TOKEN) + sizeof(MID_DIR_TOKEN)-1;
#else
                *ppToken =  ANSIStrStr(pCurrentToken, szMidDirToken) + lstrlenA(szMidDirToken);
#endif
                pTheToken = pCurrentToken;
                returnVal = ET_OPEN_DIR;
            }
        }
        // Check for exit dir token
        if ((ET_ERROR != returnVal) &&
            (NULL != (pCurrentToken = ANSIStrStr(*ppStr, BEGIN_EXITDIR_TOKEN))))
        {
            // Exit dir token found
            // See if this token comes before TheToken.
            if ((NULL == pTheToken) || (pCurrentToken < pTheToken))
            {
                // ppToken is not used for Exit Dir
                *ppToken = NULL;
                pTheToken = pCurrentToken;
                returnVal = ET_CLOSE_DIR;
            }
        }
        // Check for begin url token
        if ((ET_ERROR != returnVal) &&
            (NULL != (pCurrentToken = ANSIStrStr(*ppStr, BEGIN_URL_TOKEN))))
        {
            // Bookmark token found
            // Verify that other needed tokens exist or it's an error
#ifndef UNIX
            if ((NULL == (pszTemp = ANSIStrStr(pCurrentToken, END_URL_TOKEN))) ||
#else
            if (((NULL == (pszTemp = ANSIStrStr(pCurrentToken, END_URL_TOKEN))) && 
		 (NULL == (pszTemp = ANSIStrStr(pCurrentToken, END_URL_TOKEN2)))) ||
#endif
                (NULL == (pszTemp = ANSIStrStr(pszTemp, BEGIN_BOOKMARK_TOKEN))) ||
                (NULL == ANSIStrStr(pszTemp, END_BOOKMARK_TOKEN)))
            {
                returnVal = ET_ERROR;       // We can't find all the tokens needed.
            }
            else
            {
                // See if this token comes before TheToken.
                if ((NULL == pTheToken) || (pCurrentToken < pTheToken))
                {
                    // This function has to set *ppToken to the name of the bookmark
                    *ppToken =  pCurrentToken + sizeof(BEGIN_URL_TOKEN)-1;
                    pTheToken = pCurrentToken;
                    returnVal = ET_BOOKMARK;
                }
            }
        }
    }
    else
        returnVal = ET_ERROR;               // We should never get here.

    if (NULL == pTheToken)
        returnVal = ET_NONE;
    else
    {
        // Next time we will start parsing where we left off.
        switch(returnVal)
        {
            case ET_OPEN_DIR:
#ifndef UNIX
                *ppStr = ANSIStrStr(pTheToken, MID_DIR_TOKEN) + sizeof(MID_DIR_TOKEN);
#else
                *ppStr = ANSIStrStr(pTheToken, szMidDirToken) + lstrlenA(szMidDirToken) + 1;
#endif
                break;
            case ET_CLOSE_DIR:
                *ppStr = pTheToken + sizeof(BEGIN_EXITDIR_TOKEN);
                break;
            case ET_BOOKMARK:
                *ppStr = ANSIStrStr(pTheToken, END_BOOKMARK_TOKEN) + sizeof(END_BOOKMARK_TOKEN);
                break;
            default:
                break;
        }
    }

    return(returnVal);
}


/************************************************************\
    FUNCTION: GetPathFromRegistry

    PARAMETERS:
    LPSTR szPath    - The value found in the registry. (Result of function)
    UINT cbPath     - Size of szPath.
    HKEY theHKEY    - The HKEY to look into (HKEY_CURRENT_USER)
    LPSTR szKey     - Path in Registry (Software\...\Explore\Shell Folders)
    LPSTR szVName   - Value to query (Favorites)
    BOOL return     - TRUE if succeeded, FALSE if Error.
    EXAMPLE:
    HKEY_CURRENT_USER\Software\Microsoft\CurrentVersion\Explore\Shell Folders
    Favorites = "C:\WINDOWS\Favorites"

    DESCRIPTION:
    This function will look in the registry for the value
    to look up.  The caller specifies the HKEY, subkey (szKey),
    value to query (szVName).  The caller also sets a side memory
    for the result and passes a pointer to that memory in szPath
    with it's size in cbPath.  The BOOL return value will indicate
    success or failure of this function.
\************************************************************/

BOOL GetPathFromRegistry(LPTSTR szPath, UINT cbPath, HKEY theHKEY,
                LPTSTR szKey, LPTSTR szVName)
{
    DWORD   dwType;
    DWORD   dwSize;

    /*
     * Get Path to program
     *      from the registry
     */
    dwSize = cbPath;
    return (ERROR_SUCCESS == SHGetValue(theHKEY, szKey, szVName, &dwType, (LPBYTE) szPath, &dwSize)
            && (dwType == REG_EXPAND_SZ || dwType == REG_SZ));
}


/************************************************************\
    FUNCTION: RemoveInvalidFileNameChars

    PARAMETERS:
    char * pBuf     - The data to search.

    DESCRIPTION:
    This function will search pBuf until it encounters
    a character that is not allowed in a file name.  It will
    then replace that character with a SPACE and continue looking
    for more invalid chars until they have all been removed.
\************************************************************/

void RemoveInvalidFileNameChars(char * pBuf)
{
    //ASSERTSZ(NULL != pBuf, "Invalid function parameter");

    // Go through the array of chars, replacing offending characters with a space
    if (NULL != pBuf)
    {
        if (REASONABLE_NAME_LEN < strlen(pBuf))
            pBuf[REASONABLE_NAME_LEN] = '\0';   // String too long. Terminate it.

        while ('\0' != *pBuf)
        {
            // Check if the character is invalid
            if (!IsDBCSLeadByte(*pBuf))
            {
                if  (ANSIStrChr(szInvalidFolderCharacters, *pBuf) != NULL)
                    *pBuf = '_';
            }
            pBuf = CharNextA(pBuf);
        }
    }
}



/************************************************************\
    FUNCTION: CreateBookmark

    PARAMETERS:
    char * pBookmarkName- This is a pointer that contains
              the name of the bookmark to create.
              Note that it is not NULL terminated.
    BOOL return     - Return TRUE if successful.

    DESCRIPTION:
    This function will take the data that is passed to
    it and extract the name of the bookmark and it's value to create.
    If the name is too long, it will be truncated.  Then,
    the directory will be created.  Any errors encountered
    will cause the function to return FALSE to indicate
    failure.
\************************************************************/

BOOL CreateBookmark(char *pBookmarkName)
{
    BOOL    fSuccess                = FALSE;
    char    szNameOfBM[REASONABLE_NAME_LEN];
    char    szURL[MAX_URL];
    char    * pstrEndOfStr          = NULL;
    char    * pstrBeginOfName       = NULL;
    long    lStrLen                 = 0;
    HANDLE  hFile                   = NULL;
    DWORD   dwSize;
    char    szBuf[MAX_URL];

    //ASSERTSZ(NULL != pBookmarkName, "Bad input parameter");
    if (NULL != pBookmarkName)
    {

    pstrEndOfStr = ANSIStrStr(pBookmarkName, END_URL_TOKEN);
#ifdef UNIX
    if (!pstrEndOfStr)
        pstrEndOfStr = ANSIStrStr(pBookmarkName, END_URL_TOKEN2);
#endif
    if (NULL != pstrEndOfStr)
    {
        lStrLen = (int) (pstrEndOfStr-pBookmarkName);
        if (MAX_URL < lStrLen)
        lStrLen = MAX_URL-1;

        // Create the name of the Bookmark
        StrCpyNA(szURL, pBookmarkName, ARRAYSIZE(szURL));
        szURL[lStrLen] = '\0';

        // filter out file links, we won't create a bookmark to a file link
        // but remove the link silently and continue
        if (IsFileUrl(szURL))
            return TRUE;

        pstrBeginOfName = ANSIStrStr(pstrEndOfStr, BEGIN_BOOKMARK_TOKEN);
        if (NULL != pstrBeginOfName)
        {
            pstrBeginOfName += sizeof(BEGIN_BOOKMARK_TOKEN) - 1;            // Start at beginning of Name

            pstrEndOfStr = ANSIStrStr(pstrBeginOfName, END_BOOKMARK_TOKEN); // Find end of name
            if (NULL != pstrEndOfStr)
            {
                lStrLen = (int) (pstrEndOfStr-pstrBeginOfName);
                if (REASONABLE_NAME_LEN-FILE_EXT-1 < lStrLen)
                    lStrLen = REASONABLE_NAME_LEN-FILE_EXT-1;

                // Generate the URL
                StrCpyNA(szNameOfBM, pstrBeginOfName, lStrLen+1);
                //szNameOfBM[lStrLen] = '\0';
                StrCatBuffA(szNameOfBM, ".url", ARRAYSIZE(szNameOfBM));
                RemoveInvalidFileNameChars(szNameOfBM);

                // Check to see if Favorite w/same name exists
                if (INVALID_HANDLE_VALUE != (hFile = CreateFileA(szNameOfBM, GENERIC_WRITE, FILE_SHARE_READ, NULL, 
                                    CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL )))
                {
                    WriteFile(hFile, "[InternetShortcut]\n", lstrlenA( "[InternetShortcut]\n" ), &dwSize, NULL);
                    wnsprintfA( szBuf, ARRAYSIZE(szBuf), "URL=%s\n", szURL);
                    WriteFile(hFile, szBuf, lstrlenA(szBuf), &dwSize, NULL );
                    fSuccess = TRUE;
                }
                else
                {
                    fSuccess = TRUE;
                }

                if (NULL != hFile)
                {
                    CloseHandle( hFile );
                    hFile = NULL;
                }

            }
        }
    }
    }

    return(fSuccess);
}


/************************************************************\
    FUNCTION: CreateDir

    PARAMETERS:
    char * pDirName - This is a pointer that contains
              the name of the directory to create.
              Note that it is not NULL terminated.
    BOOL return     - Return TRUE if successful.

    DESCRIPTION:
    This function will take the data that is passed to
    it and extract the name of the directory to create.
    If the name is too long, it will be truncated.  Then,
    the directory will be created.  Any errors encountered
    will cause the function to return FALSE to indicate
    failure.
\************************************************************/
BOOL CreateDir(char *pDirName)
{
    BOOL    fSuccess                = FALSE;
    char    szNameOfDir[REASONABLE_NAME_LEN];
    char    * pstrEndOfName         = NULL;
    long    lStrLen                 = 0;

    //ASSERTSZ(NULL != pDirName, "Bad input parameter");
    if (NULL != pDirName)
    {
        pstrEndOfName = ANSIStrStr(pDirName, END_DIR_TOKEN);
        if (NULL != pstrEndOfName)
        {
            lStrLen = (int) (pstrEndOfName-pDirName);
            if (REASONABLE_NAME_LEN-1 < lStrLen)
                lStrLen = REASONABLE_NAME_LEN-1;

            StrCpyNA(szNameOfDir, pDirName, lStrLen+1);
            //szNameOfDir[lStrLen] = '\0';
            RemoveInvalidFileNameChars(szNameOfDir);

            if ( !SetCurrentDirectoryA(szNameOfDir) )
            {
                if ( CreateDirectoryA(szNameOfDir, NULL) )
                {
                    if ( SetCurrentDirectoryA(szNameOfDir) )
                    {
                        fSuccess = TRUE;// It didn't exist, but now it does.
                    }
                }
            }
            else
                fSuccess = TRUE;        // It exists already.
        }
    }

    return(fSuccess);
}


/************************************************************\
    FUNCTION: CloseDir

    PARAMETERS:
    BOOL return     - Return TRUE if successful.

    DESCRIPTION:
    This function will back out of the current directory.
\************************************************************/
BOOL CloseDir(void)
{
    return( SetCurrentDirectoryA("..") );
}


/************************************************************\
    FUNCTION: VerifyBookmarksFile

    PARAMETERS:
    FILE * pFile    - Pointer to Netscape Bookmarks file.
    BOOL return     - TRUE if No Error and Valid Bookmark file

    DESCRIPTION:
    This function needs to be passed with a valid pointer
    that points to an open file.  Upon return, the file will
    still be open and is guarenteed to have the file pointer
    point to the beginning of the file.
    This function will return TRUE if the file contains
    text that indicates it's a valid Netscape bookmarks file.
\************************************************************/

BOOL VerifyBookmarksFile(HANDLE hFile)
{
    BOOL    fSuccess            = FALSE;
    char    szFileHeader[sizeof(VALIDATION_STR)+1] = "";
    DWORD   dwSize;

    //ASSERTSZ(NULL != pFile, "You can't pass me a NULL File Pointer");
    if (INVALID_HANDLE_VALUE == hFile)
        return(FALSE);

    // Reading the first part of the file.  If the file isn't this long, then
    // it can't possibly be a Bookmarks file.    
    if ( ReadFile( hFile, szFileHeader, sizeof(VALIDATION_STR)-1, &dwSize, NULL ) && (dwSize == sizeof(VALIDATION_STR)-1) )
    {
#ifndef UNIX
        szFileHeader[sizeof(VALIDATION_STR)] = '\0';            // Terminate String.
#else
        // The above statement doesn;t serve the purpose on UNIX.
        // I think we should change for NT also.
        // IEUNIX : NULL character after the buffer read
        szFileHeader[sizeof(VALIDATION_STR)-1] = '\0';          // Terminate String.
#endif

        if (0 == StrCmpA(szFileHeader, VALIDATION_STR))          // See if header is the same as the Validation string.
            fSuccess = TRUE;
    }

    // Reset the point to point to the beginning of the file.
    dwSize = SetFilePointer( hFile, 0, NULL, FILE_BEGIN );
    if ( dwSize == 0xFFFFFFFF )
         fSuccess = FALSE;

    return(fSuccess);
}



/************************************************************\
    FUNCTION: GetData

    PARAMETERS:
    char ** ppData  - Where to put the data
    FILE * pFile    - Pointer to Netscape Bookmarks file.
    BOOL return     - Return TRUE is successful.

    DESCRIPTION:
    This function will find the size of the bookmarks file,
    malloc that much memory, and put the file's contents in
    that buffer.  ppData will be invalid when the function
    is called and will return with malloced memory that
    needs to be freed by the falling function.
\************************************************************/

BOOL GetData(char ** ppData, HANDLE hFile)
{
    DWORD  dwlength, dwRead;
    BOOL   fSuccess = FALSE;

    //ASSERTSZ(NULL != ppData, "Invalid input parameter");

    if (NULL != ppData)
    {
        *ppData = NULL;

        // Find the size of the data
        if ( dwlength = GetFileSize(hFile, NULL))
        {
            *ppData = (PSTR)LocalAlloc(LPTR, dwlength+1 );
            if (NULL != *ppData)
            {                
                if ( ReadFile( hFile, *ppData, dwlength+1, &dwRead, NULL ) &&
                     ( dwlength == dwRead ) )
                {
                    fSuccess = TRUE;
                }

                (*ppData)[dwlength] = '\0';
            }
        }
    }

    return(fSuccess);
}

//
// AddPath - added by julianj when porting from setup code to stand alone
//
void PASCAL AddPath(LPTSTR pszPath, LPCTSTR pszName, int cchPath )
{
    LPTSTR pszTmp;
    int    cchTmp;

    // Find end of the string
    cchTmp = lstrlen(pszPath);
    pszTmp = pszPath + cchTmp;
    cchTmp = cchPath - cchTmp;

        // If no trailing backslash then add one
    if ( pszTmp > pszPath && *(CharPrev( pszPath, pszTmp )) != FILENAME_SEPARATOR )
    {
        *(pszTmp++) = FILENAME_SEPARATOR;
        cchTmp--;
    }

        // Add new name to existing path string
    while ( *pszName == TEXT(' ') ) pszName++;
    StrCpyN( pszTmp, pszName, cchTmp );
}

//
// GetVersionFromFile - added by julianj when porting from setup code to stand alone
//
BOOL GetVersionFromFile(PTSTR pszFileName, PDWORD pdwMSVer, PDWORD pdwLSVer)
{
    DWORD dwVerInfoSize, dwHandle;
    LPVOID lpVerInfo;
    VS_FIXEDFILEINFO *pvsVSFixedFileInfo;
    UINT uSize;

    HRESULT hr = E_FAIL;

    *pdwMSVer = *pdwLSVer = 0;

    if ((dwVerInfoSize = GetFileVersionInfoSize(pszFileName, &dwHandle)))
    {
        if ((lpVerInfo = (LPVOID) LocalAlloc(LPTR, dwVerInfoSize)) != NULL)
        {
            if (GetFileVersionInfo(pszFileName, dwHandle, dwVerInfoSize, lpVerInfo))
            {
                if (VerQueryValue(lpVerInfo, TEXT("\\"), (LPVOID *) &pvsVSFixedFileInfo, &uSize))
                {
                    *pdwMSVer = pvsVSFixedFileInfo->dwFileVersionMS;
                    *pdwLSVer = pvsVSFixedFileInfo->dwFileVersionLS;
                    hr = S_OK;
                }
            }
            LocalFree(lpVerInfo);
            lpVerInfo = NULL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

BOOL GetNavBkMkDir( LPTSTR lpszDir, int isize)
{
    BOOL    bDirFound = FALSE;
#ifndef UNIX
    TCHAR   szDir[MAX_PATH];
    HKEY    hKey;
    HKEY    hKeyUser;
    TCHAR   szUser[MAX_PATH];
    DWORD   dwSize;

    StrCpyN( szUser, REGSTR_PATH_APPPATHS, ARRAYSIZE(szUser) );
    AddPath( szUser, TEXT("NetScape.exe"), ARRAYSIZE(szUser) );
    if ( GetPathFromRegistry( szDir, ARRAYSIZE(szDir), HKEY_LOCAL_MACHINE, szUser, TEXT("") ) &&
         lstrlen(szDir) )
    {
        DWORD dwMV, dwLV;

        if ( SUCCEEDED(GetVersionFromFile( szDir, &dwMV, &dwLV )) )
        {
            if ( dwMV < 0x00040000 )
                bDirFound = GetPathFromRegistry( lpszDir, isize, HKEY_CURRENT_USER,
                                     szNetscapeBMRegSub, szNetscapeBMRegKey);
            else
            {
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Netscape\\Netscape Navigator\\Users"), 0, KEY_READ, &hKey) == ERROR_SUCCESS)
                {
                    dwSize = sizeof(szUser);
                    if (RegQueryValueEx(hKey, TEXT("CurrentUser"), NULL, NULL, (LPBYTE)szUser, &dwSize) == ERROR_SUCCESS)
                    {
                        if (RegOpenKeyEx(hKey, szUser, 0, KEY_READ, &hKeyUser) == ERROR_SUCCESS)
                        {
                            dwSize = sizeof(szDir);
                            if (RegQueryValueEx(hKeyUser, TEXT("DirRoot"), NULL, NULL, (LPBYTE)szDir, &dwSize) == ERROR_SUCCESS)
                            {
                                // Found the directory for the current user.
                                StrCpyN( lpszDir, szDir, isize);
                                AddPath( lpszDir, TEXT("bookmark.htm"), isize );
                                bDirFound = TRUE;
                            }
                            RegCloseKey(hKeyUser);
                        }
                    }
                    RegCloseKey(hKey);
                }
            }
        }
    }
    else
#endif
        bDirFound = GetPathFromRegistry( lpszDir, isize, HKEY_CURRENT_USER,
                                         szNetscapeBMRegSub, szNetscapeBMRegKey);
 
    return bDirFound;
}


//
// *** EXPORT FAVORITES CODE ***
//

// REVIEW REMOVE THESE
#include <windows.h>
//#include <stdio.h>
#include <shlobj.h>
#include <shlwapi.h>

//
// Generate HTML from favorites
//

#define INDENT_AMOUNT 4

int Indent = 0;

HANDLE g_hOutputStream = INVALID_HANDLE_VALUE;
 
void Output(const char *format, ...)
{
    DWORD dwSize;
    char buf[MAX_URL];

    va_list argptr;

    va_start(argptr, format);

    for (int i=0; i<Indent*INDENT_AMOUNT; i++)
    {
        WriteFile(g_hOutputStream, " ", 1, &dwSize, NULL);
    }

    wvnsprintfA(buf, ARRAYSIZE(buf), format, argptr);
    WriteFile(g_hOutputStream, buf, lstrlenA(buf), &dwSize, NULL);
}

void OutputLn(const char *format, ...)
{
    DWORD dwSize;
    char buf[MAX_URL];

    va_list argptr;

    va_start(argptr, format);

    for (int i=0; i<Indent*INDENT_AMOUNT; i++)
    {
        WriteFile(g_hOutputStream, " ", 1, &dwSize, NULL);
    }

    wvnsprintfA(buf, ARRAYSIZE(buf), format, argptr);
    WriteFile(g_hOutputStream, buf, lstrlenA(buf), &dwSize, NULL);
    WriteFile(g_hOutputStream, "\r\n", 2, &dwSize, NULL);
}

#define CREATION_TIME 0
#define ACCESS_TIME   1
#define MODIFY_TIME   2

//
// This nasty looking macro converts a FILETIME structure
// (100-nanosecond intervals since Jan 1st 1601) to a
// unix time_t value (seconds since Jan 1st 1970).
//
// The numbers come from knowledgebase article Q167296
//
#define FILETIME_TO_UNIXTIME(ft) (UINT)((*(LONGLONG*)&ft-116444736000000000)/10000000)

UINT GetUnixFileTime(LPTSTR pszFileName, int mode)
{

    WIN32_FIND_DATA wfd;
    HANDLE hFind;

    hFind = FindFirstFile(pszFileName,&wfd);

    if (hFind == INVALID_HANDLE_VALUE)
        return 0;

    FindClose(hFind);

    switch (mode)
    {

    case CREATION_TIME:
        return FILETIME_TO_UNIXTIME(wfd.ftCreationTime);

    case ACCESS_TIME:
        return FILETIME_TO_UNIXTIME(wfd.ftLastAccessTime);

    case MODIFY_TIME:
        return FILETIME_TO_UNIXTIME(wfd.ftLastWriteTime);

    default:
        ASSERT(0);
        return 0;
        
    }
    
}

void WalkTree(TCHAR * szDir)
{
    WIN32_FIND_DATA findFileData;
    TCHAR buf[MAX_PATH];
    HANDLE hFind;

    Indent++;

    //
    // First iterate through all directories
    //
    wnsprintf(buf, ARRAYSIZE(buf), TEXT("%s") TEXT(FILENAME_SEPARATOR_STR) TEXT("*"), szDir);
    hFind = FindFirstFile(buf, &findFileData);
    if (INVALID_HANDLE_VALUE != hFind)
    {
        do
        {
            if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                if ((StrCmp(findFileData.cFileName, TEXT(".")) != 0  &&
                     StrCmp(findFileData.cFileName, TEXT("..")) != 0 &&
                     StrCmp(findFileData.cFileName, TEXT("History")) != 0 && // REVIEW just for JJ. Should check for system bit on folders
                     StrCmp(findFileData.cFileName, TEXT("Software Updates")) != 0 && // don't export software updates
                     StrCmp(findFileData.cFileName, TEXT("Channels")) != 0))         // don't export channels for now!
                {
                    char thisFile[MAX_PATH];
                    wnsprintf(buf, ARRAYSIZE(buf), TEXT("%s") TEXT(FILENAME_SEPARATOR_STR) TEXT("%s"), szDir, findFileData.cFileName);

                    if (!(GetFileAttributes(buf)&FILE_ATTRIBUTE_SYSTEM))
                    {
                        SHTCharToAnsi(findFileData.cFileName, thisFile, MAX_PATH);
                        OutputLn("<DT><H3 FOLDED ADD_DATE=\"%u\">%s</H3>", GetUnixFileTime(buf,CREATION_TIME), thisFile);
                        OutputLn("<DL><p>");
                        WalkTree(buf);
                        OutputLn(BEGIN_EXITDIR_TOKEN);
                    }

                }
                else
                {
                    ; // ignore . and ..
                }
            }
        } while (FindNextFile(hFind, &findFileData));

        FindClose(hFind);
    }

    //
    // Next iterate through all files
    //
    wnsprintf(buf, ARRAYSIZE(buf), TEXT("%s") TEXT(FILENAME_SEPARATOR_STR) TEXT("*"), szDir);
    hFind = FindFirstFile(buf, &findFileData);
    if (INVALID_HANDLE_VALUE != hFind)
    {
        do
        {
            if (!(findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                wnsprintf(buf, ARRAYSIZE(buf), TEXT("%s") TEXT(FILENAME_SEPARATOR_STR) TEXT("%s"), szDir, findFileData.cFileName);

                //
                // Read the url from the .url file
                //
                TCHAR szUrl[MAX_PATH];

                SHGetIniString(
                    TEXT("InternetShortcut"),
                    TEXT("URL"),
                    szUrl,       // returns url
                    MAX_PATH,
                    buf);        // full path to .url file

                if (*szUrl != 0)
                {
                    //
                    // create a copy of the filename without the extension
                    // note PathFindExtension returns a ptr to the NULL at 
                    // end if '.' not found so its ok to just blast *pch with 0
                    //
                    TCHAR szFileName[MAX_PATH];
                    StrCpyN(szFileName, findFileData.cFileName, ARRAYSIZE(szFileName));
                    TCHAR *pch = PathFindExtension(szFileName);
                    *pch = TEXT('\0'); // 
                    char  szUrlAnsi[MAX_PATH], szFileNameAnsi[MAX_PATH];
                    SHTCharToAnsi(szUrl, szUrlAnsi, MAX_PATH);
                    SHTCharToAnsi(szFileName, szFileNameAnsi, MAX_PATH);
                    OutputLn("<DT><A HREF=\"%s\" ADD_DATE=\"%u\" LAST_VISIT=\"%u\" LAST_MODIFIED=\"%u\">%s</A>", 
						szUrlAnsi, 
						GetUnixFileTime(buf,CREATION_TIME),
						GetUnixFileTime(buf,ACCESS_TIME),
						GetUnixFileTime(buf,MODIFY_TIME),
						szFileNameAnsi);
                }
            }
        } while (FindNextFile(hFind, &findFileData));

        FindClose(hFind);
    }

    Indent--;
}

BOOL ExportFavorites(TCHAR * pszPathToFavorites, TCHAR * pszPathToBookmarks, HWND hwnd)
{
    // Prompt the user to insert floppy, format floppy or drive, remount mapped partition,
    // or any create sub directories so pszPathToBookmarks becomes valid.
    if (FAILED(SHPathPrepareForWriteWrap(hwnd, NULL, pszPathToBookmarks, FO_COPY, (SHPPFW_DEFAULT | SHPPFW_IGNOREFILENAME))))
        return FALSE;

    // Open output file REVIEW redo to use Win32 file apis
    g_hOutputStream = CreateFile(
        pszPathToBookmarks,
        GENERIC_WRITE,
        0, // no sharing,
        NULL, // no security attribs
        CREATE_ALWAYS, // overwrite if present
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (g_hOutputStream == INVALID_HANDLE_VALUE)
        return FALSE;

    //
    // Output bookmark file header stuff
    //
    Output(VALIDATION_STR);
    OutputLn("1>");
    OutputLn(COMMENT_STR);
    OutputLn(TITLE); // REVIEW put/persist users name in Title???

    //
    // Do the walk
    //
    OutputLn("<DL><p>");
    WalkTree(pszPathToFavorites);
    OutputLn(BEGIN_EXITDIR_TOKEN);

    //
    // Close output file handle
    //
    CloseHandle(g_hOutputStream); // REVIEW

    return TRUE;
}

//
// Import/Export User interface dialog routines
//

//
// Standalone app for importing the Netscape Favorites into IE.
//
// julianj 3/9/98
//

#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif
#ifdef _WIN32_WINDOWS
#undef _WIN32_WINDOWS
#endif
#ifdef WINVER
#undef WINVER
#endif
#define _WIN32_WINDOWS      0x0400
#define _WIN32_WINNT        0x0400
#define WINVER              0x0400



TCHAR g_szPathToFavorites[MAX_PATH+1];
TCHAR g_szPathToBookmarks[MAX_PATH+1];
LPITEMIDLIST g_pidlFavorites = NULL;

enum DIALOG_TYPE {FILE_OPEN_DIALOG, FILE_SAVE_DIALOG};

BOOL BrowseForBookmarks(TCHAR *pszPathToBookmarks, int cchPathToBookmarks, HWND hwnd, DIALOG_TYPE dialogType)
{
    TCHAR szFile[MAX_PATH];
    TCHAR szDir[MAX_PATH];
    TCHAR *pszFileName = PathFindFileName(pszPathToBookmarks);
    TCHAR szDialogTitle[MAX_PATH];
    
    //
    // Now copy the filename into the buffer for use with OpenFile
    // and then copy szDir from path to bookmarks and truncate it at filename 
    // so it contains the initial working directory for the dialog
    //
    StrCpyN(szFile, pszFileName, ARRAYSIZE(szFile));
    StrCpyN(szDir,  pszPathToBookmarks, ARRAYSIZE(szDir));
    szDir[pszFileName-pszPathToBookmarks] = TEXT('\0');

    //
    // Use common dialog code to get path to folder
    //
    TCHAR filter[] = TEXT("HTML File\0*.HTM\0All Files\0*.*\0");
    OPENFILENAME ofn = {0};
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = HINST_THISDLL;
    ofn.lpstrFilter = filter;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = ARRAYSIZE(szFile);
    ofn.lpstrInitialDir = szDir;
    ofn.lpstrDefExt = TEXT("htm");

    if (dialogType == FILE_SAVE_DIALOG)
    {
        MLLoadString(IDS_EXPORTDIALOGTITLE, szDialogTitle, ARRAYSIZE(szDialogTitle));

        ofn.lpstrTitle = szDialogTitle;
        ofn.Flags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT;
        if (GetSaveFileName(&ofn))
        {
            StrCpyN(pszPathToBookmarks, szFile, cchPathToBookmarks);
            return TRUE;
        }
    }
    else
    {
        MLLoadString(IDS_IMPORTDIALOGTITLE, szDialogTitle, ARRAYSIZE(szDialogTitle));

        ofn.lpstrTitle = szDialogTitle;
        ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST;
        if (GetOpenFileName(&ofn))
        {
            StrCpyN(pszPathToBookmarks, szFile, cchPathToBookmarks);
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT CreateILFromPath(LPCTSTR pszPath, LPITEMIDLIST* ppidl)
{
    // ASSERT(pszPath);
    // ASSERT(ppidl);

    HRESULT hr;

    IShellFolder* pIShellFolder;

    hr = SHGetDesktopFolder(&pIShellFolder);

    if (SUCCEEDED(hr))
    {
        // ASSERT(pIShellFolder);

        WCHAR wszPath[MAX_PATH];

        if (SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath)))
        {
            ULONG ucch;

            hr = pIShellFolder->ParseDisplayName(NULL, NULL, wszPath, &ucch,
                                                 ppidl, NULL);
        }
        else
        {
            hr = E_FAIL;
        }
        pIShellFolder->Release();
    }
    return hr;
}

#define REG_STR_IMPEXP          TEXT("Software\\Microsoft\\Internet Explorer\\Main")
#define REG_STR_PATHTOFAVORITES TEXT("FavoritesImportFolder")
#define REG_STR_PATHTOBOOKMARKS TEXT("FavoritesExportFile")
#define REG_STR_DESKTOP         TEXT("Desktop")
#define REG_STR_SHELLFOLDERS    TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")

#ifndef UNIX
#define STR_BOOKMARK_FILE       TEXT("\\bookmark.htm")
#else
#define STR_BOOKMARK_FILE       TEXT("/bookmark.html")
#endif

//
// InitializePaths
//
void InitializePaths()
{
    //
    // Read the Netscape users bookmark file location and the
    // current users favorite path from registry
    //
    if (!GetNavBkMkDir(g_szPathToBookmarks, MAX_PATH))
    {
        //
        // If Nav isn't installed then use the desktop
        //
        GetPathFromRegistry(g_szPathToBookmarks, MAX_PATH, HKEY_CURRENT_USER,
            REG_STR_SHELLFOLDERS, REG_STR_DESKTOP);
        StrCatBuff(g_szPathToBookmarks, STR_BOOKMARK_FILE, ARRAYSIZE(g_szPathToBookmarks));
    }

    GetTargetFavoritesPath(g_szPathToFavorites, MAX_PATH);
    
    if (FAILED(CreateILFromPath(g_szPathToFavorites, &g_pidlFavorites)))
        g_pidlFavorites = NULL;

    //
    // Now override these values with values stored in the registry just for
    // this tool, so if the user consistently wants to save their favorites
    // out to a separate .HTM file its easy to do
    //
    HKEY hKey;
    DWORD dwSize;
    DWORD dwType;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, REG_STR_IMPEXP, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        // dsheldon: Setting dwType before RegQueryValueEx doesn't do anything. Should we check it afterwards?
        dwSize = sizeof g_szPathToBookmarks;
        dwType = REG_SZ;
        RegQueryValueEx(hKey, REG_STR_PATHTOBOOKMARKS, 0, &dwType, (LPBYTE)g_szPathToBookmarks, &dwSize);

        dwSize = sizeof g_szPathToFavorites;
        dwType = REG_SZ;
        RegQueryValueEx(hKey, REG_STR_PATHTOFAVORITES, 0, &dwType, (LPBYTE)g_szPathToFavorites, &dwSize);

        RegCloseKey(hKey);
    }
}

void PersistPaths()
{
    HKEY hKey;
    DWORD dwDisp;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, REG_STR_IMPEXP, 0, NULL, 0, KEY_SET_VALUE, NULL, &hKey, &dwDisp) == ERROR_SUCCESS)
    {
        RegSetValueEx(hKey, REG_STR_PATHTOBOOKMARKS, 0, REG_SZ, (LPBYTE)g_szPathToBookmarks, (lstrlen(g_szPathToBookmarks)+1)*sizeof(TCHAR));
        RegSetValueEx(hKey, REG_STR_PATHTOFAVORITES, 0, REG_SZ, (LPBYTE)g_szPathToFavorites, (lstrlen(g_szPathToFavorites)+1)*sizeof(TCHAR));
        RegCloseKey(hKey);
    }
}

#define REG_STR_IE_POLICIES          TEXT("Software\\Policies\\Microsoft\\Internet Explorer")
#define REG_STR_IMPEXP_POLICIES      TEXT("DisableImportExportFavorites")

BOOL IsImportExportDisabled(void)
{
    HKEY  hKey;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType;
    DWORD value = 0;
    BOOL  bret = FALSE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, REG_STR_IE_POLICIES, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        if (RegQueryValueEx(hKey, REG_STR_IMPEXP_POLICIES, 0, &dwType, (PBYTE)&value, &dwSize) == ERROR_SUCCESS &&
                   (dwType == REG_BINARY || dwType == REG_DWORD))
            bret = (value) ? TRUE : FALSE;

        RegCloseKey(hKey);
    }

    return bret;
}

void DoImportOrExport(BOOL fImport, LPCWSTR pwszPath, LPCWSTR pwszImpExpPath, BOOL fConfirm)
{
    BOOL fRemote = FALSE;
    HWND hwnd = NULL;
    TCHAR szImpExpPath[INTERNET_MAX_URL_LENGTH];

    //
    // REVIEW should this be passed in...
    //
    hwnd = GetActiveWindow();

    // Decide if import/export is allowed here
    if (IsImportExportDisabled())
    {
        MLShellMessageBox(
                        hwnd, 
                        (fImport) ? MAKEINTRESOURCE(IDS_IMPORT_DISABLED) :
                                    MAKEINTRESOURCE(IDS_EXPORT_DISABLED),
                        (fImport) ? MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV) :
                                    MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_FAV), 
                        MB_OK);
        return;
    }

 
    InitializePaths();

    //
    // Overwrite path to favorites with passed in one if present
    //
    if (pwszPath && *pwszPath != 0)
    {
        SHUnicodeToTChar(pwszPath, g_szPathToFavorites, ARRAYSIZE(g_szPathToFavorites));
    }

    //
    // Decide if we export/import to/from an URL? or a file
    //   (we expect pwszImpExpPath an absolute path)
    // if it's not a valid URL or filename, we give error message and bail out
    //
    if (pwszImpExpPath && *pwszImpExpPath != 0)
    {
        SHUnicodeToTChar(pwszImpExpPath, szImpExpPath, ARRAYSIZE(szImpExpPath));

        if (PathIsURL(pwszImpExpPath))
        {
            
            TCHAR szDialogTitle[MAX_PATH];
            TCHAR szfmt[MAX_PATH], szmsg[MAX_PATH+INTERNET_MAX_URL_LENGTH];
            fRemote = TRUE;
            
            if (fImport)
            {
                if (fConfirm)
                {
                    //
                    // Show confirmation UI when importing over internet
                    //
                    MLLoadShellLangString(IDS_CONFIRM_IMPTTL_FAV, szDialogTitle, ARRAYSIZE(szDialogTitle));
                    MLLoadShellLangString(IDS_CONFIRM_IMPORT, szfmt, ARRAYSIZE(szfmt));
                    wnsprintf(szmsg, ARRAYSIZE(szmsg), szfmt, szImpExpPath);
                    if (MLShellMessageBox(hwnd, szmsg, szDialogTitle,
                                              MB_YESNO | MB_ICONQUESTION) == IDNO)
                        return;
                }
                // download imported file to cache

                if ( (IsGlobalOffline() && !InternetGoOnline(g_szPathToBookmarks,hwnd,0)) ||
                      FAILED(URLDownloadToCacheFile(NULL, szImpExpPath, g_szPathToBookmarks, MAX_PATH, 0, NULL)))
                {
                    MLShellMessageBox(
                        hwnd, 
                        MAKEINTRESOURCE(IDS_IMPORTFAILURE_FAV), 
                        MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV), 
                        MB_OK);
                    return;
                }
            }
            else
            {
                if (fConfirm)
                {
                    //
                    // Show confirmation UI when exporting over internet
                    //
                    MLLoadShellLangString(IDS_CONFIRM_EXPTTL_FAV, szDialogTitle, ARRAYSIZE(szDialogTitle));
                    MLLoadShellLangString(IDS_CONFIRM_EXPORT, szfmt, ARRAYSIZE(szfmt));
                    wnsprintf(szmsg, ARRAYSIZE(szmsg), szfmt, szImpExpPath);
                    if (MLShellMessageBox(hwnd, szmsg, szDialogTitle,
                                              MB_YESNO | MB_ICONQUESTION) == IDNO)
                        return;
                }
                
                //
                // Create bookmark file name from bookmark directory with favorite name so we can export
                // favorites to local file before posting to URL
                //
                TCHAR *pszFav = PathFindFileName(g_szPathToFavorites);
                TCHAR *pszBMD = PathFindFileName(g_szPathToBookmarks);
                if (pszFav && pszBMD)
                {
                    StrCpyN(pszBMD, pszFav, ARRAYSIZE(g_szPathToBookmarks) - ((int)(pszBMD - g_szPathToBookmarks)));
                    StrCatBuff(pszBMD, TEXT(".htm"), ARRAYSIZE(g_szPathToBookmarks) - ((int)(pszBMD - g_szPathToBookmarks)));
                }
                
            }
        }
        else
        {

            if (fConfirm)
            {
                TCHAR szDialogTitle[MAX_PATH];
                TCHAR szfmt[MAX_PATH], szmsg[MAX_PATH+INTERNET_MAX_URL_LENGTH];

                if (fImport)
                {
                    //
                    // Show confirmation UI when importing
                    //
                    MLLoadShellLangString(IDS_CONFIRM_IMPTTL_FAV, szDialogTitle, ARRAYSIZE(szDialogTitle));
                    MLLoadShellLangString(IDS_CONFIRM_IMPORT, szfmt, ARRAYSIZE(szfmt));
                    wnsprintf(szmsg, ARRAYSIZE(szmsg), szfmt, szImpExpPath);
                    if (MLShellMessageBox(hwnd, szmsg, szDialogTitle,
                                              MB_YESNO | MB_ICONQUESTION) == IDNO)
                        return;
                }
                else
                {
                    //
                    // Show confirmation UI when exporting.
                    //
                    MLLoadShellLangString(IDS_CONFIRM_EXPTTL_FAV, szDialogTitle, ARRAYSIZE(szDialogTitle));
                    MLLoadShellLangString(IDS_CONFIRM_EXPORT, szfmt, ARRAYSIZE(szfmt));
                    wnsprintf(szmsg, ARRAYSIZE(szmsg), szfmt, szImpExpPath);
                    if (MLShellMessageBox(hwnd, szmsg, szDialogTitle,
                                              MB_YESNO | MB_ICONQUESTION) == IDNO)
                        return;
                }
            }
                
            if (PathFindFileName(szImpExpPath) != szImpExpPath)
            {
            
                //override path to bookmarks with passed in one
                StrCpyN(g_szPathToBookmarks, szImpExpPath, ARRAYSIZE(g_szPathToBookmarks));

            }
            else
            {
                MLShellMessageBox(
                    hwnd, 
                    MAKEINTRESOURCE(IDS_IMPORTFAILURE_FAV), 
                    MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV), 
                    MB_OK);
                return;
            }

        }
    }
    else
    {
        if (fImport)
        {
            //
            // Do Import Favorites UI
            //
            if (!BrowseForBookmarks(g_szPathToBookmarks, ARRAYSIZE(g_szPathToBookmarks), hwnd, FILE_OPEN_DIALOG))
                return;
        }
        else
        {
            //
            // Do Export Favorites UI
            //
            if (!BrowseForBookmarks(g_szPathToBookmarks, ARRAYSIZE(g_szPathToBookmarks), hwnd, FILE_SAVE_DIALOG))
                return;
        }
    }
    
    if (fImport)
    {
        if (ImportBookmarks(g_szPathToFavorites, g_szPathToBookmarks, hwnd))
        {
            MLShellMessageBox(
                            hwnd, 
                            MAKEINTRESOURCE(IDS_IMPORTSUCCESS_FAV), 
                            MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV), 
                            MB_OK);
#ifdef UNIX
	    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH | SHCNF_FLUSH, g_szPathToFavorites, 0);
#endif
            if (!fRemote)
                PersistPaths();
        }
        else
        {
            ; // ImportBookmarks will report errors
        }
    }
    else  
    {
        if (ExportFavorites(g_szPathToFavorites, g_szPathToBookmarks, hwnd))
        {
            if (fRemote)
            {
                if ( (!IsGlobalOffline() || InternetGoOnline(g_szPathToBookmarks,hwnd,0)) &&
                       PostFavorites(g_szPathToBookmarks, szImpExpPath))
                {
                    MLShellMessageBox(
                                hwnd, 
                                MAKEINTRESOURCE(IDS_EXPORTSUCCESS_FAV), 
                                MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_FAV), 
                                MB_OK);
                }
                else
                    MLShellMessageBox(
                                hwnd, 
                                MAKEINTRESOURCE(IDS_EXPORTFAILURE_FAV), 
                                MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_FAV), 
                                MB_OK);

                //Remove temp file on local disk
                DeleteFile(g_szPathToBookmarks);
            }
            else
            {
                MLShellMessageBox(
                                hwnd, 
                                MAKEINTRESOURCE(IDS_EXPORTSUCCESS_FAV), 
                                MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_FAV), 
                                MB_OK);
                PersistPaths();
            }
        }
        else
        {
            MLShellMessageBox(
                            hwnd, 
                            MAKEINTRESOURCE(IDS_EXPORTFAILURE_FAV), 
                            MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_FAV), 
                            MB_OK);
        }
    }
}


//
//  *** POST FAVORITES HTML FILE ***
//
HINTERNET g_hInternet = 0;
HINTERNET g_hConnect = 0;
HINTERNET g_hHttpRequest = 0;

HANDLE    g_hEvent = NULL;

typedef struct AsyncRes
{
    DWORD_PTR   Result;
    DWORD_PTR   Error;
} ASYNCRES;

#define STR_USERAGENT          "PostFavorites"

void CloseRequest(void)
{
    if (g_hHttpRequest)
        InternetCloseHandle(g_hHttpRequest);
    if (g_hConnect)
        InternetCloseHandle(g_hConnect);
    if (g_hInternet)
        InternetCloseHandle(g_hInternet);

    g_hInternet = g_hConnect = g_hHttpRequest = 0;

}

HRESULT InitRequest(LPSTR pszPostURL, BOOL bAsync, ASYNCRES *pasyncres)
{
    char    hostName[INTERNET_MAX_HOST_NAME_LENGTH+1];
    char    userName[INTERNET_MAX_USER_NAME_LENGTH+1];
    char    password[INTERNET_MAX_PASSWORD_LENGTH+1];
    char    urlPath[INTERNET_MAX_PATH_LENGTH+1];
    URL_COMPONENTSA     uc;

    memset(&uc, 0, sizeof(URL_COMPONENTS));
    uc.dwStructSize = sizeof(URL_COMPONENTS);
    uc.lpszHostName = hostName;
    uc.dwHostNameLength = sizeof(hostName);
    uc.nPort = INTERNET_INVALID_PORT_NUMBER;
    uc.lpszUserName = userName;
    uc.dwUserNameLength = sizeof(userName);
    uc.lpszPassword = password;
    uc.dwPasswordLength = sizeof(password);
    uc.lpszUrlPath = urlPath;
    uc.dwUrlPathLength = sizeof(urlPath);
    
    if (!InternetCrackUrlA(pszPostURL,lstrlenA(pszPostURL),ICU_DECODE, &uc))
    {
        return E_FAIL;
    }

    if (bAsync)
    {
        // Create an auto-reset event
        g_hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if (g_hEvent == NULL)
            bAsync = FALSE;
    }

    g_hInternet = InternetOpenA(STR_USERAGENT,               // used in User-Agent: header 
                            INTERNET_OPEN_TYPE_PRECONFIG,  //INTERNET_OPEN_TYPE_DIRECT, 
                            NULL,
                            NULL, 
                            (bAsync) ? INTERNET_FLAG_ASYNC : 0
                            );

    if ( !g_hInternet )
    {
        return E_FAIL;
    }

    if (bAsync)
    {
        if (INTERNET_INVALID_STATUS_CALLBACK == InternetSetStatusCallbackA(g_hInternet, StatusCallback))
            return E_FAIL;
    }

    // Connect to host
    g_hConnect = InternetConnectA(g_hInternet, 
                                    uc.lpszHostName,
                                    uc.nPort,           //INTERNET_INVALID_PORT_NUMBER,
                                    uc.lpszUserName, 
                                    uc.lpszPassword,
                                    INTERNET_SERVICE_HTTP, 
                                    0,                  //INTERNET_FLAG_KEEP_CONNECTION, 
                                    (bAsync)? (DWORD_PTR) pasyncres : 0); 

    if ( !g_hConnect )
    {
        if (bAsync && GetLastError() == ERROR_IO_PENDING)
        {
            WaitForSingleObject(g_hEvent, INFINITE);
            if (pasyncres->Result == 0)
                return E_FAIL;

            g_hConnect = (HINTERNET)pasyncres->Result;
        }
        else
            return E_FAIL;
    }                                    
    
    // Create request.
    g_hHttpRequest = HttpOpenRequestA
        (
            g_hConnect, 
            "POST", 
            uc.lpszUrlPath,
            HTTP_VERSIONA, 
            NULL,                     //lpszReferer
            NULL,                     //lpszAcceptTypes
            INTERNET_FLAG_RELOAD
            | INTERNET_FLAG_KEEP_CONNECTION
            | SECURITY_INTERNET_MASK, // ignore SSL warnings 
            (bAsync)? (DWORD_PTR) pasyncres : 0);
                            

    if ( !g_hHttpRequest )
    {
        if (bAsync && GetLastError() == ERROR_IO_PENDING)
        {
            WaitForSingleObject(g_hEvent, INFINITE);
            if (pasyncres->Result == 0)
                return E_FAIL;

            g_hHttpRequest = (HINTERNET)pasyncres->Result;
        }
        else
            return E_FAIL;
    }
    
    return S_OK;
    
}                                                                

const char c_szHeaders[] = "Content-Type: application/x-www-form-urlencoded\r\n";
#define c_ccHearders  (ARRAYSIZE(c_szHeaders) - 1)

BOOL AddRequestHeaders
(
    LPCSTR     lpszHeaders,
    DWORD      dwHeadersLength,
    DWORD      dwAddFlag,
    BOOL       bAsync,
    ASYNCRES   *pasyncres
)
{
    BOOL bRet = FALSE;

    bRet = HttpAddRequestHeadersA(g_hHttpRequest, 
                           lpszHeaders, 
                           dwHeadersLength, 
                           HTTP_ADDREQ_FLAG_ADD | dwAddFlag);

    if (bAsync && !bRet && GetLastError() == ERROR_IO_PENDING) 
    {
        WaitForSingleObject(g_hEvent, INFINITE);
        bRet = (BOOL)pasyncres->Result;
    }

    return bRet;
}

HRESULT SendRequest
(
    LPCSTR     lpszHeaders,
    DWORD      dwHeadersLength,
    LPCSTR     lpszOption,
    DWORD      dwOptionLength,
    BOOL       bAsync,
    ASYNCRES   *pasyncres
)
{
    BOOL bRet=FALSE;

    bRet = AddRequestHeaders((LPCSTR)c_szHeaders, (DWORD)-1L, 0, bAsync, pasyncres);

    if (lpszHeaders && *lpszHeaders)        // don't bother if it's empty
    {

        bRet = AddRequestHeaders( 
                          (LPCSTR)lpszHeaders, 
                          dwHeadersLength, 
                          HTTP_ADDREQ_FLAG_REPLACE,
                          bAsync,
                          pasyncres);
        if ( !bRet )
        {
            return E_FAIL;
        }
    }

    pasyncres->Result = 0;

    bRet = HttpSendRequestA(g_hHttpRequest, 
                          NULL,                            //HEADER_ENCTYPE, 
                          0,                               //sizeof(HEADER_ENCTYPE), 
                          (LPVOID)lpszOption, 
                          dwOptionLength);

    if ( !bRet )
    {
        DWORD_PTR dwLastError = GetLastError();
        if (bAsync && dwLastError == ERROR_IO_PENDING)
        {
            WaitForSingleObject(g_hEvent, INFINITE);
            dwLastError = pasyncres->Error;
            bRet = (BOOL)pasyncres->Result;
            if (!bRet)
            {
                TraceMsg(DM_ERROR, "Async HttpSendRequest returned FALSE");
                if (dwLastError != ERROR_SUCCESS)
                {
                    TraceMsg(DM_ERROR, "Async HttpSendRequest failed: Error = %lx", dwLastError);
                    return E_FAIL;
                }
            }

        }
        else
        {
            TraceMsg(DM_ERROR, "HttpSendRequest failed: Error = %lx", dwLastError);
            return E_FAIL;
        }
    }

    //
    //verify request response here
    //
    DWORD dwBuffLen;
    TCHAR buff[10];

    dwBuffLen = sizeof(buff);

    bRet = HttpQueryInfo(g_hHttpRequest,
                        HTTP_QUERY_STATUS_CODE,   //HTTP_QUERY_RAW_HEADERS,
                        buff,
                        &dwBuffLen,
                        NULL);

    int iretcode = StrToInt(buff);
    TraceMsg(DM_TRACE, "HttpQueryInfo returned %d", iretcode);
    return (iretcode == HTTP_STATUS_OK) ? 
        S_OK : E_FAIL;

}                                                                

DWORD ReadFavoritesFile(LPCTSTR lpFile, LPSTR* lplpbuf)
{
    HANDLE  hFile = NULL;
    DWORD   cbFile = 0;
    DWORD   cbRead;

    hFile = CreateFile(lpFile, 
                GENERIC_READ,
                0,                              //no sharing
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL);

    if (hFile == INVALID_HANDLE_VALUE) 
        return 0;

    cbFile = GetFileSize(hFile, NULL);
    if (cbFile == 0xFFFFFFFF)
    {
        CloseHandle(hFile);
        return 0;
    }
        
    *lplpbuf = (LPSTR)GlobalAlloc(LPTR, (cbFile + 2) * sizeof(CHAR));
    cbRead = 0;
    if (!*lplpbuf || !ReadFile(hFile, *lplpbuf, cbFile, &cbRead, NULL))
    {
        cbRead = 0;
    }    
        
    ASSERT((cbRead == cbFile));
    CloseHandle(hFile);
    return cbRead;
}


BOOL PostFavorites(TCHAR *pszPathToBookmarks, TCHAR* pszPathToPost)
{
    DWORD cbRead = 0;
    LPSTR lpbuf = NULL;
    BOOL  bret = FALSE;
    BOOL  bAsync = TRUE;
    CHAR  szPathToPost[INTERNET_MAX_URL_LENGTH];
    ASYNCRES asyncres = {0, 0};

    cbRead = ReadFavoritesFile(pszPathToBookmarks, &lpbuf);
    if (cbRead == 0)
    {
        if (lpbuf)
        {
            GlobalFree(lpbuf);
            lpbuf = NULL;
        }

        return TRUE;
    }
    SHTCharToAnsi(pszPathToPost, szPathToPost, ARRAYSIZE(szPathToPost));
    if (SUCCEEDED(InitRequest(szPathToPost, bAsync, &asyncres)))
    {
        bret = (SUCCEEDED(SendRequest(NULL, lstrlenA(""), lpbuf, cbRead, bAsync, &asyncres)));
    }

    CloseRequest();

    if (lpbuf)
    {
        GlobalFree( lpbuf );
        lpbuf = NULL;
    }

    return bret;
}

//
// Callback function for Asynchronous HTTP POST request
//
void CALLBACK StatusCallback(
    HINTERNET hInternet,
    DWORD_PTR dwContext,
    DWORD dwStatus,
    LPVOID lpvInfo,
    DWORD dwInfoLength
    )
{
    switch (dwStatus)
    {

    case INTERNET_STATUS_REQUEST_COMPLETE:
    {
        ASYNCRES *pasyncres = (ASYNCRES *)dwContext;

        pasyncres->Result = ((LPINTERNET_ASYNC_RESULT)lpvInfo)->dwResult;
        pasyncres->Error = ((LPINTERNET_ASYNC_RESULT)lpvInfo)->dwError;

        SetEvent(g_hEvent);
    }
        break;

    default:
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\impexp.h ===
/************************************************************\
	FILE: convert.h

	DATE: Apr 1, 1996

	AUTHOR: Bryan Starbuck (bryanst)

	DESCRIPTION:
		This file will handle the logic to convert Netscape
	bookmarks to Microsoft Internet Explorer favorites.  This 
	will happen by finding the location of the Netscape bookmarks
	file and the Microsoft Internet Explorer favorites directory
	from the registry.  Then it will parse the bookmarks file to
	extract the URLs, which will finally be added to the favorites
	directory.

  NOTES:
	This was developed with Netscape 2.0 and IE 2.0.  Future notes
	will be made about compatibility with different versions of
	these browsers.
	
\************************************************************/

#ifndef _IMPEXP_H
#define _IMPEXP_H


//////////////////////////////////////////////////////////////////
//	Exported Functions
//////////////////////////////////////////////////////////////////
BOOL    GetVersionFromFile(PTSTR pszFileName, PDWORD pdwMSVer, PDWORD pdwLSVer);
void    DoImportOrExport(BOOL fImport, LPCWSTR pwszPath, LPCWSTR pwszImpExpDestPath, BOOL fConfirm);

BOOL    ImportBookmarks(TCHAR *pszPathToFavorites, TCHAR *pszPathToBookmarks, HWND hwnd);			//  Import Netscape Bookmarks to IE Favorites
BOOL    ExportFavorites(TCHAR *pszPathToFavorites, TCHAR *pszPathToBookmarks);			//  Export IE Favorites to Netscape Bookmarks

#ifdef UNIX
BOOL        GetNavBkMkDir( LPTSTR lpszDir, int isize);
BOOL        GetPathFromRegistry(LPTSTR szPath, UINT cbPath, HKEY theHKEY, LPTSTR szKey, LPTSTR szVName);
BOOL        VerifyBookmarksFile(HANDLE hFile);
BOOL    ImportBookmarks(TCHAR *pszPathToFavorites, TCHAR *pszPathToBookmarks, HWND hwnd);//  Import Netscape Bookmarks to IE Favorites
#endif
#endif // _IMPEXP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\impexpwz.h ===
#ifndef _IMPEXPWZ_H
#define _IMPEXPWZ_H

BOOL RunImportExportFavoritesWizard(HWND hDlg);

#endif // _IMPEXP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\impexpwz.cpp ===
/*
 * Author: t-franks
 *
 * Last Modified On: Oct 16, 1998
 * Last Modified By: t-joshp
 *
 */

#include "priv.h"
#include "resource.h"
#include "impexp.h"
#include "mluisupp.h"  // for MLLoadString
#include "apithk.h"

//
// Indices into our imagelist
// (used for the open and closed folder icons on the tree view)
//
#define FOLDER_CLOSED 0
#define FOLDER_OPEN   1

#define ImportCookieFile ImportCookieFileW
#define ExportCookieFile ExportCookieFileW

BOOL ImportCookieFileW(IN LPCWSTR szFilename);
BOOL ExportCookieFileW(IN LPCWSTR szFilename, BOOL fAppend);

extern void SetListViewToString (HWND hLV, LPCTSTR pszString);

//
// used to display "file already exists" and "file not found" messages
//
int WarningMessageBox(HWND hwnd, UINT idTitle, UINT idMessage, LPCTSTR szFile, DWORD dwFlags);

//
// Strings that don't need localizing
//

#define NS3_COOKIE_REG_PATH         TEXT("Software\\Netscape\\Netscape Navigator\\Cookies")
#define NS3_COOKIE_REG_KEY          TEXT("Cookie File")

#ifndef UNIX
#define NS3_BOOKMARK_REG_PATH       TEXT("Software\\Netscape\\Netscape Navigator\\Bookmark List")
#else
#define NS3_BOOKMARK_REG_PATH       TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\unix\\nsbookmarks")
#endif

#define NS3_BOOKMARK_REG_KEY        TEXT("File Location")

#define NS4_USERS_REG_PATH          TEXT("Software\\Netscape\\Netscape Navigator\\Users")
#define NS4_USERPATH_REG_KEY        TEXT("DirRoot")

#define NS_FALLBACK_ROOT_REG_KEY    TEXT("Software\\Netscape\\Netscape Navigator")
#define NS_FALLBACK_VERSION_REG_VAL TEXT("CurrentVersion")
#define NS_FALLBACK_MAIN_REG_VAL    TEXT("Main")
#define NS_FALLBACK_INST_REG_VAL    TEXT("Install Directory")

#ifndef UNIX
#define ALL_FILES_WILDCARD          TEXT("\\*.*")
#else
#define ALL_FILES_WILDCARD          TEXT("/*")
#endif

#define DOT_DIR                     TEXT(".")
#define DOT_DOT_DIR                 TEXT("..")

#ifdef UNIX
#define DIR_SEPARATOR_CHAR  TEXT('/')
#else
#define DIR_SEPARATOR_CHAR  TEXT('\\')
#endif

//*************************************************************
//
//      class ListIterator
//
//  Keeps hold on a position in a list.  Allows basic access
//to a list.  The list is set up to map a name to a value.

class NestedList;

class ListIterator
{
    friend NestedList;
    
    struct node
    {
        LPTSTR _sName;
        LPTSTR _sValue;
        DWORD _cNameSize, _cValueSize;
        node* _pnNext;
        node* _pnSublist;
    };

    //  A position is held by pointing to the
    //current node and the pointer that is directed
    //to that node.  The back pointer is kept so the 
    //list can be manipulated at the current element.
    //  when m_pnCurrent == NULL, the iterator is
    //at the end of the list.
    node** m_ppnPrev;
    node* m_pnCurrent;

    //  The invariant could be broken if two iterators
    //point to the same node, and one inserts or deletes
    //an element.  So only one iterator should exist in 
    //a branch of the list at a time.
    BOOL invariant()
    {
        return *m_ppnPrev == m_pnCurrent;
    }

public:
    ListIterator( node** ppnPrev)
    {
        m_ppnPrev = ppnPrev;
        m_pnCurrent = *m_ppnPrev;
    }

    BOOL Insert( LPCTSTR sName, DWORD cNameSize, LPCTSTR sValue, DWORD cValueSize);
    BOOL Remove();

    ListIterator GetSublist();
    void DeleteSublist();

    BOOL Next();
    BOOL AtEndOfList();

    LPCTSTR GetName();
    LPCTSTR GetValue();
    DWORD GetValueSize();
};


//*************************************************************
//
//  class NestedList
//      Keeps a pointer to a node which heads a list,
//  and deletes that list on destruction.


class NestedList
{
    ListIterator::node* m_pnRoot;
    
public:
    NestedList();
    ~NestedList();

    operator ListIterator();
};


NestedList::NestedList()
: m_pnRoot(NULL)
{
}


NestedList::~NestedList()
{
    while( ((ListIterator)*this).Remove())
    {
    }
}


NestedList::operator ListIterator()
{
    return ListIterator( &m_pnRoot);
}

//*************************************************************
//*************************************************************
//
//  ListIterator functions
//


//  Inserts an element before the current one,
//leaves iterator pointing at new node.
BOOL ListIterator::Insert( 
    LPCTSTR sName, 
    DWORD cNameSize, 
    LPCTSTR sValue, 
    DWORD cValueSize)
{
    ASSERT( invariant());

    node* pNewNode = (node*)(new BYTE[ sizeof(node) 
                                       + (( cNameSize + cValueSize)
                                          * sizeof(TCHAR))]);

    if( pNewNode == NULL)
        return FALSE;

    //  the name and value will be appended to the node.
    pNewNode->_sName = (LPTSTR)((BYTE*)pNewNode + sizeof(node));
    pNewNode->_sValue = pNewNode->_sName + cNameSize;

    pNewNode->_cNameSize = cNameSize;
    pNewNode->_cValueSize = cValueSize;

    memcpy( pNewNode->_sName, sName, pNewNode->_cNameSize * sizeof(TCHAR));
    memcpy( pNewNode->_sValue, sValue, pNewNode->_cValueSize * sizeof(TCHAR));

    // insert new node in list
    pNewNode->_pnNext = m_pnCurrent;
    *m_ppnPrev = pNewNode;

    //  The iterator now points to the new element.
    m_pnCurrent = *m_ppnPrev;
    
    ASSERT( invariant());

    return TRUE;
}


//  Deletes the current node.
//  Returns FALSE if at end of list.
BOOL ListIterator::Remove()
{
    ASSERT( invariant());
    
    //  If this list is empty, or if the iterator 
    //points at the end of the list, there is nothing to
    //delete.
    if( m_pnCurrent == NULL)
        return FALSE;

    // remove sublist
    DeleteSublist();
    
    //  Remember where target node is
    //so it can be deleted once out of
    //the list.
    node* pOldNode = m_pnCurrent;

    // take the target node out of the list.
    //(iterator points to next node or end of list)
    *m_ppnPrev = m_pnCurrent->_pnNext;
    m_pnCurrent = *m_ppnPrev;

    //  Get rid of target node.
    delete [] (BYTE*)pOldNode;

    ASSERT( invariant());

    return TRUE;    
}


//  Returns the sublist of the current node.
ListIterator ListIterator::GetSublist()
{
    ASSERT( invariant());
    
    return ListIterator( &(m_pnCurrent->_pnSublist));
}


//  deletes the children of the current node.
void ListIterator::DeleteSublist()
{
    ASSERT( invariant());
    
    ListIterator sublist( &(m_pnCurrent->_pnSublist));
    
    while( sublist.Remove())
    {
    }

    ASSERT( invariant());
}


//  Advances to the next node.
//  Returns FALSE if already at end of list.
BOOL ListIterator::Next()
{
    ASSERT( invariant());

    if( m_pnCurrent == NULL)
        return FALSE;

    m_ppnPrev = &(m_pnCurrent->_pnNext);
    m_pnCurrent = *m_ppnPrev;

    ASSERT( invariant());

    return m_pnCurrent != NULL;
}


//  
BOOL ListIterator::AtEndOfList()
{
    return ( m_pnCurrent == NULL) ? TRUE : FALSE;
};


//
LPCTSTR ListIterator::GetName()
{
    ASSERT( invariant() && m_pnCurrent != NULL);

    return m_pnCurrent->_sName;
}


//
LPCTSTR ListIterator::GetValue()
{
    ASSERT( invariant() && m_pnCurrent != NULL);

    return m_pnCurrent->_sValue;
}


//
DWORD ListIterator::GetValueSize()
{
    ASSERT( invariant() && m_pnCurrent != NULL);

    return m_pnCurrent->_cValueSize;
}


//*************************************************************
//*************************************************************
//
//  class ImpExpUserProcess
//
//      maintains the description of an import/export process
//  for an import/export wizard, and finally executes the
//  the import/export.

enum ExternalType { INVALID_EXTERNAL = 0, COOKIES, BOOKMARKS};
enum TransferType { INVALID_TRANSFER = 0, IMPORT, EXPORT};

class ImpExpUserProcess
{
public:
    ImpExpUserProcess();
    ~ImpExpUserProcess();
    
    //  the first step the wizard should do is identify the type of
    //import/export process to be done.
    void SelectExternalType( ExternalType selection)    { m_ExternalType = selection; }
    void SelectTransferType( TransferType selection)    { m_TransferType = selection; }
    ExternalType GetExternalType()                      { return m_ExternalType; }
    TransferType GetTransferType()                      { return m_TransferType; }

    BOOL PopulateComboBoxForExternalSelection( HWND hComboBox);
    BOOL GetExternalManualDefault( LPTSTR sExternal, DWORD* pcSize);

    //
    // used to fill the listbox with names of netscape profiles
    //
    void purgeExternalList();
    BOOL populateExternalList();
    BOOL populateExternalListForCookiesOrBookmarks();

    //
    // for netscape 3.x
    //
    BOOL populateExternalListForCookiesOrBookmarksWithNS3Entry();

    //
    // for netscape 4.x
    //
    BOOL populateExternalListForCookiesOrBookmarksWithNS4Entries();

    //
    // fallback case for "funny" versions of netscape
    //
    BOOL populateExternalListFromFolders(LPTSTR pszPath);
    BOOL populateExternalListWithNSEntriesFallBack();

    //  If the transfer is for favorites, the wizard needs to specify
    //an internal folder to import to or export from.
    LPCTSTR GetInternalSelection()       { return m_pSelectedInternal; }

    BOOL PopulateTreeViewForInternalSelection( HWND TreeView);
    BOOL populateTreeViewWithInternalList( HWND hTreeView, ListIterator iterator, HTREEITEM hParent);
    BOOL ExpandTreeViewRoot ( HWND hTreeView ) ;

    BOOL SelectInternalSelection( HWND TreeView);

    void purgeInternalList();
    BOOL populateInternalList();
    BOOL populateInternalListForBookmarks();
    BOOL appendSubdirsToInternalList( LPTSTR sPath, DWORD cchPath, ListIterator iterator);
    
    //  And then, the import/export can be completed.
    void PerformImpExpProcess(HWND hwnd);

    //
    // The filename that we're exporting to or 
    // importing from.
    //
    TCHAR m_szFileName[MAX_PATH];

private:
    ExternalType m_ExternalType;
    TransferType m_TransferType;

    //  m_ExternalList is a flat list of names associated with files
    //example: name =  "Netscape 4.0 profile - Dr. Falken"
    //         value =  "c:\netscapeprofiledir\DrFalken.chs"
    NestedList m_ExternalList;

    //  m_InternalList is a nested list favorites' pathnames,
    //associated with the complete path.
    NestedList m_InternalList;

    //  Maintain synchronization between m_ExternalType/m_TransferType 
    //and m_InternalList
    ExternalType m_InternalListExternalType;
    TransferType m_InternalListTransferType;

    // if ExternalType == BOOKMARKS,
    //m_pSelectedInternal is the path of a Favorites folder,
    //residing in m_InternalList somewhere, or NULL if a folder
    //hasn't been selected yet.
    LPTSTR m_pSelectedInternal;

};


ImpExpUserProcess::ImpExpUserProcess()
:   m_ExternalType(INVALID_EXTERNAL), m_TransferType(INVALID_TRANSFER),
    m_InternalListExternalType(INVALID_EXTERNAL), m_InternalListTransferType(INVALID_TRANSFER),
    m_pSelectedInternal(0)
{
}


ImpExpUserProcess::~ImpExpUserProcess()
{
}


//*************************************************************
//   PopulateComboBoxForExternal
//
//  Loads content for list box into memory and into List Box,
//associating value of each element with the list element.

//  returns FALSE if the list box is left empty
BOOL ImpExpUserProcess::PopulateComboBoxForExternalSelection( HWND hComboBox)
{
    ASSERT ( m_ExternalType != INVALID_EXTERNAL ) ;

    ComboBox_ResetContent(hComboBox);
   
    //  If ExternalList is invalid, the list box will be left empty.
    if( !populateExternalList() )
        return FALSE;

    ListIterator iterator = m_ExternalList;

    //  Detect and notify if the list is empty.
    if( iterator.AtEndOfList() )
        return FALSE;

    //  add entries from the new ExternalList to the ComboBox.
    do
    {
        int index = ComboBox_AddString( hComboBox, const_cast<LPTSTR>(iterator.GetName() ) );
        ComboBox_SetItemData( hComboBox, index, const_cast<LPTSTR>(iterator.GetValue() ) );
    } while( iterator.Next());

    // set the first one as selected
    ComboBox_SetCurSel( hComboBox, 0 );

    return TRUE;
}


//*************************************************************
//
//  GetExternalManualDefault
//
//  Allows user interface to offer some sort of default
//  filename/location.
//
BOOL ImpExpUserProcess::GetExternalManualDefault(LPTSTR sExternal, DWORD* pcSize)
{
    ASSERT(NULL != pcSize);

    //
    // We only fill it in if it's blank
    //
    if (m_szFileName[0])
    {
        return FALSE;
    }

    ListIterator iterator = m_ExternalList;

    TCHAR szFileName[MAX_PATH];
    INT cchFileName;
    if(m_ExternalType == BOOKMARKS)
        MLLoadString(IDS_NETSCAPE_BOOKMARK_FILE,szFileName,ARRAYSIZE(szFileName));
    else
        MLLoadString(IDS_NETSCAPE_COOKIE_FILE,szFileName,ARRAYSIZE(szFileName));
    cchFileName = lstrlen(szFileName) + 1;

    //  Grab the first item in the External List and use its value.
    if( ((ListIterator)m_ExternalList).AtEndOfList() == FALSE
        && ((ListIterator)m_ExternalList).GetValue() != NULL
        && *pcSize >= ((ListIterator)m_ExternalList).GetValueSize())
    {
        StrCpyN( sExternal,
                 ((ListIterator)m_ExternalList).GetValue(),
                 ((ListIterator)m_ExternalList).GetValueSize());
        *pcSize = ((ListIterator)m_ExternalList).GetValueSize();

        return TRUE;
    }
    //  If there is enough room, specify some file with the correct name
    //  in the "my documents" directory.
    else 
    {
        ASSERT(m_ExternalType == BOOKMARKS || m_ExternalType == COOKIES);
        
        TCHAR szMyDocsPath[MAX_PATH];

        SHGetSpecialFolderPath(NULL,szMyDocsPath,CSIDL_PERSONAL,TRUE);

        int cchMax = *pcSize;
        *pcSize = wnsprintf(sExternal,cchMax,TEXT("%s%c%s"),szMyDocsPath,DIR_SEPARATOR_CHAR,szFileName);

        return *pcSize > 0;
    }
}


//*************************************************************
//
//
//  purgeExternalList
//
//  Used to clear external target/source list loaded into memory

void ImpExpUserProcess::purgeExternalList()
{
    // delete elements until they're all gone.
    ListIterator iterator = m_ExternalList;

    while( iterator.Remove())
    {
    }

}


//*************************************************************
//
//  populeExternalList
//
//  Used to load external target/source list into memory

BOOL ImpExpUserProcess::populateExternalList()
{
    ASSERT(m_ExternalType != INVALID_EXTERNAL)

    purgeExternalList();

    if(!populateExternalListForCookiesOrBookmarks())
    {
        //
        // If we didn't get any entries using the "standard"
        // techniques, then (and only then) we try the "fallback"
        //
        if (!populateExternalListWithNSEntriesFallBack())
        {
            purgeExternalList();
            return FALSE;
        }

    }

    return TRUE;
}


//*************************************************************
//
//  populateExternalListforCookiesOrBookmarks
//
//  Used to lod external target/source list into memory
//in the case that the content to be transfered is cookies
//or bookmarks.

//  returns TRUE if any elements have been added to the external list
BOOL ImpExpUserProcess::populateExternalListForCookiesOrBookmarks()
{
    ASSERT( m_ExternalType == COOKIES || m_ExternalType == BOOKMARKS);

    BOOL fHasAddedElements = FALSE;

    if( populateExternalListForCookiesOrBookmarksWithNS3Entry())
        fHasAddedElements = TRUE;

    if( populateExternalListForCookiesOrBookmarksWithNS4Entries())
        fHasAddedElements = TRUE;
 
    return fHasAddedElements;
}


//*************************************************************
//
//  populateExternalList..WithNS3Entry
//
//  subfunc of populateExternalListForCookiesOrBookmarks.

//  returns TRUE if any elements have been added to the external list
BOOL ImpExpUserProcess::populateExternalListForCookiesOrBookmarksWithNS3Entry()
{
    BOOL retVal = FALSE;

    //  Determine where to look for reg key
    LPTSTR sNS3RegPath;
    LPTSTR sNS3RegKey;

    if( m_ExternalType == BOOKMARKS)
    {
        sNS3RegPath = NS3_BOOKMARK_REG_PATH;
        sNS3RegKey = NS3_BOOKMARK_REG_KEY;
    }
    else
    {
        sNS3RegPath = NS3_COOKIE_REG_PATH;
        sNS3RegKey = NS3_COOKIE_REG_KEY;
    }

    //  Get the file location and add it to the list
    //  The registry location has the complete path + filename.
    TCHAR sFilePath[MAX_PATH];
    DWORD cbFilePathSize = sizeof(sFilePath);
    DWORD dwType;
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, sNS3RegPath, sNS3RegKey,
                                    &dwType, (BYTE*)sFilePath, &cbFilePathSize)
        && (dwType == REG_SZ || dwType == REG_EXPAND_SZ))
    {
        TCHAR szBuffer[MAX_PATH];

        MLLoadString(IDS_NS3_VERSION_CAPTION, szBuffer, MAX_PATH);
        
        retVal = ((ListIterator)m_ExternalList).Insert( 
                   szBuffer, lstrlen(szBuffer)+1,
                   sFilePath, cbFilePathSize / sizeof(TCHAR));
    }

    return retVal;
}


//*************************************************************
//
//  populateExternalList..WithNS4Entries
//
//  subfunc of populateExternalListForCookiesOrBookmarks.

//  returns TRUE if any elements have been added to the external list
BOOL ImpExpUserProcess::populateExternalListForCookiesOrBookmarksWithNS4Entries()
{
    BOOL retVal = FALSE;

    //  Get an iterator to advance position as items are inserted.
    ListIterator iterator = (ListIterator)m_ExternalList;

    //  Get the filename to be attached and the associated string size.
    TCHAR sFilename[MAX_PATH];
    DWORD cFilenameLength;
    if(m_ExternalType == BOOKMARKS)
        MLLoadString(IDS_NETSCAPE_BOOKMARK_FILE,sFilename,ARRAYSIZE(sFilename));
    else
        MLLoadString(IDS_NETSCAPE_COOKIE_FILE,sFilename,ARRAYSIZE(sFilename));
    cFilenameLength = lstrlen(sFilename);

    //  Get the reg key of the root of the NS profiles for enumeration.
    HKEY hUserRootKey = NULL;

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE, NS4_USERS_REG_PATH, 
                      0, KEY_READ, &hUserRootKey) 
        != ERROR_SUCCESS)
    {
        hUserRootKey = NULL;
        goto donePopulateExternalListForCookiesOrBookmarksWithNS4Entries;
    }

    DWORD dwNumberOfProfiles;
    if( RegQueryInfoKey( hUserRootKey, NULL, NULL, NULL, &dwNumberOfProfiles,
        NULL, NULL, NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS
        || dwNumberOfProfiles == 0)
    {
        goto donePopulateExternalListForCookiesOrBookmarksWithNS4Entries;
    }

    //  Enumerate over the NS profiles, getting their names and
    //directory paths.  Associated the profile name with the path
    //of the desired files by appending the filename to the
    //user's root.
    TCHAR sProfileName[MAX_PATH];
    DWORD cProfileNameSize;  
    cProfileNameSize = MAX_PATH;
    DWORD iEnumIndex = 0;
    while( RegEnumKeyEx( hUserRootKey, (iEnumIndex++), sProfileName, 
                         &cProfileNameSize, NULL, NULL, NULL, NULL) 
           == ERROR_SUCCESS)
    {
        //RegEnumKeyEx gives us the ProfileNameSize w/out the '\0'.
        cProfileNameSize = MAX_PATH;

        HKEY hProfileKey = NULL;

        if( RegOpenKeyEx( hUserRootKey, sProfileName, 0, KEY_READ, &hProfileKey) 
            != ERROR_SUCCESS)
        {
            hProfileKey = NULL;
            goto doneWithEntryInPopulateExternalListForCookiesOrBookmarksWithNS4Entries;
        }

        DWORD dwType;  //  should be REG_SZ when returned from QueryValue
        TCHAR sProfilePath[MAX_PATH];
        DWORD cProfilePathSize;  cProfilePathSize = sizeof(sProfilePath);
        if( (RegQueryValueEx( hProfileKey, NS4_USERPATH_REG_KEY, NULL, &dwType, 
                             (LPBYTE)sProfilePath, &cProfilePathSize) 
                != ERROR_SUCCESS)
            || dwType != REG_SZ)
        {
            goto doneWithEntryInPopulateExternalListForCookiesOrBookmarksWithNS4Entries;
        }
        cProfilePathSize /= sizeof(TCHAR);
        
        if( (ARRAYSIZE(sProfileName) - cProfilePathSize) < cFilenameLength)
        {
            goto doneWithEntryInPopulateExternalListForCookiesOrBookmarksWithNS4Entries;
        }

        //  append "\\sFilename\0" to the path.
        PathAppend(sProfileName, sFilename);
        cProfilePathSize = lstrlen(sProfileName) + 1;

        // we can only import files if they exist!
        if( m_TransferType == IMPORT
            && GetFileAttributes(sProfilePath) == 0xFFFFFFFF)
                goto doneWithEntryInPopulateExternalListForCookiesOrBookmarksWithNS4Entries;

        //
        // construct the string for the combo box
        //
        TCHAR sRawProfileName[MAX_PATH];
        TCHAR sRealProfileName[MAX_PATH];
        UINT cRealProfileName;

        MLLoadString(IDS_NS4_FRIENDLY_PROFILE_NAME, sRawProfileName, ARRAYSIZE(sRawProfileName));

        cRealProfileName = 
            wnsprintf(sRealProfileName, ARRAYSIZE(sRealProfileName), 
                      sRawProfileName, sProfileName);

        //  Insert the profile into the list.  If it inserts, thats
        //enough to consider the whole functions call a success.
        if( iterator.Insert(sRealProfileName, cRealProfileName + 1,
                            sProfilePath, cProfilePathSize))
            retVal = TRUE;

    doneWithEntryInPopulateExternalListForCookiesOrBookmarksWithNS4Entries:
        if( hProfileKey != NULL)
            RegCloseKey(hProfileKey);
    }

donePopulateExternalListForCookiesOrBookmarksWithNS4Entries:
    if( hUserRootKey != NULL)
        RegCloseKey( hUserRootKey);

    return retVal;
}

BOOL ImpExpUserProcess::populateExternalListFromFolders(LPTSTR pszPath)
{

    BOOL retval = FALSE;
    TCHAR szFileName[MAX_PATH];
    TCHAR szPathWithWildcards[MAX_PATH];

    ListIterator iterator = (ListIterator)m_ExternalList;

    HANDLE hFind = NULL;
    WIN32_FIND_DATA wfd;

    //
    // what are we looking for?
    //
    if(m_ExternalType == BOOKMARKS)
        MLLoadString(IDS_NETSCAPE_BOOKMARK_FILE,szFileName,ARRAYSIZE(szFileName));
    else
        MLLoadString(IDS_NETSCAPE_COOKIE_FILE,szFileName,ARRAYSIZE(szFileName));

    //
    // prepare the path variable
    //
    StrCpyN(szPathWithWildcards,pszPath,ARRAYSIZE(szPathWithWildcards));
    StrCatBuff(szPathWithWildcards,ALL_FILES_WILDCARD,ARRAYSIZE(szPathWithWildcards));

    //
    // start the find file thing
    //
    hFind = FindFirstFile(szPathWithWildcards,&wfd);

    if (hFind == INVALID_HANDLE_VALUE)
        goto Cleanup;

    do
    {

        //
        // the actual bookmark or cookie file
        //
        TCHAR szFullPath[MAX_PATH];
        int cchFullPath;

        //
        // a "friendly" name for the corresponding profile
        //
        TCHAR szProfileFormat[MAX_PATH];
        TCHAR szProfileName[MAX_PATH];
        int cchProfileName;

        //
        // skip over "." and ".."
        //
        if(!StrCmp(wfd.cFileName, DOT_DIR) ||
           !StrCmp(wfd.cFileName, DOT_DOT_DIR))
            continue;

        //
        // skip over any non-directories
        //
        if (!(wfd.dwFileAttributes&FILE_ATTRIBUTE_DIRECTORY))
            continue;

        //
        // generate the path
        //
#ifndef UNIX
        cchFullPath = wnsprintf(szFullPath,ARRAYSIZE(szFullPath),TEXT("%s\\%s\\%s"),pszPath,wfd.cFileName,szFileName);
#else
        cchFullPath = wnsprintf(szFullPath,ARRAYSIZE(szFullPath),TEXT("%s/%s/%s"),pszPath,wfd.cFileName,szFileName);
#endif

        //
        // see if the file actually exists
        //
        if (GetFileAttributes(szFullPath) == 0xFFFFFFFF)
            continue;

        //
        // generate the profile name
        //
        MLLoadString(IDS_FB_FRIENDLY_PROFILE_NAME, szProfileFormat, MAX_PATH);
        cchProfileName = wnsprintf(szProfileName, ARRAYSIZE(szProfileName), szProfileFormat, wfd.cFileName);

        //
        // add the entry to the list
        //
        iterator.Insert(
            szProfileName,cchProfileName+1,
            szFullPath,cchFullPath+1);

        retval = TRUE;

    } while(FindNextFile(hFind,&wfd));

Cleanup:

    if (hFind)
        FindClose(hFind);

    return retval;

}

BOOL ImpExpUserProcess::populateExternalListWithNSEntriesFallBack()
{

    BOOL retVal = FALSE;

    HKEY hRoot = NULL;
    HKEY hCurrentVersion = NULL;
    HKEY hCurrentVersionMain = NULL;

    TCHAR szUsersDir[64]; // will contain "..\\Users"

    DWORD dwType;
    TCHAR szVersion[64];
    TCHAR szPath[MAX_PATH];
    DWORD cbSize;

    LONG result;

    //
    // Open the root of netscape's HKLM registry hierarchy
    //
    result = RegOpenKeyEx(
         HKEY_LOCAL_MACHINE, 
         NS_FALLBACK_ROOT_REG_KEY,
         0, 
         KEY_READ, 
         &hRoot);
    
    if (result != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Retrieve the "CurrentVersion" value
    //
    cbSize = sizeof(szVersion);
    result = RegQueryValueEx(
        hRoot, 
        NS_FALLBACK_VERSION_REG_VAL, 
        NULL, 
        &dwType, 
        (LPBYTE)szVersion, 
        &cbSize);

    if (result != ERROR_SUCCESS || dwType != REG_SZ)
        goto Cleanup;

    //
    // Open the sub-hierarchy corresponding to the current version
    //
    result = RegOpenKeyEx(
         hRoot, 
         szVersion, 
         0, 
         KEY_READ, 
         &hCurrentVersion);

    if (result != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Open the "main" sub-hierarchy
    //
    result = RegOpenKeyEx(
         hCurrentVersion, 
         NS_FALLBACK_MAIN_REG_VAL, 
         0, 
         KEY_READ, 
         &hCurrentVersionMain);

    if (result != ERROR_SUCCESS)
        goto Cleanup;

    //
    // Retrieve the "Install Directory" value
    //
    cbSize = sizeof(szPath);
    result = RegQueryValueEx(
        hCurrentVersionMain, 
        NS_FALLBACK_INST_REG_VAL, 
        NULL, 
        &dwType, 
        (LPBYTE)szPath, 
        &cbSize);

    if (result != ERROR_SUCCESS || dwType != REG_SZ)
        goto Cleanup;

    //
    // Take a wild guess at where the "Users" dir might be
    //
    MLLoadString(IDS_NETSCAPE_USERS_DIR,szUsersDir,ARRAYSIZE(szUsersDir));
    StrCatBuff(szPath,szUsersDir,ARRAYSIZE(szPath));

    //
    // Fill in the list
    //
    if (populateExternalListFromFolders(szPath))
        retVal = TRUE;

Cleanup:

    if (hRoot)
        RegCloseKey(hRoot);

    if (hCurrentVersion)
        RegCloseKey(hCurrentVersion);

    if (hCurrentVersionMain)
        RegCloseKey(hCurrentVersionMain);

    return retVal;

}


//*************************************************************
//
//  PopulateTreeViewForInternalSelection
//
//  Load a nested list of the favorites folders into memory
//and then into a Tree View.

//  returns FALSE if TreeView is left empty.
BOOL ImpExpUserProcess::PopulateTreeViewForInternalSelection( HWND hTreeView)
{
    ASSERT( m_TransferType != INVALID_TRANSFER);

    TreeView_DeleteAllItems( hTreeView);

    if( !populateInternalList())
        return FALSE;

    return populateTreeViewWithInternalList
            ( hTreeView, (ListIterator)m_InternalList, TVI_ROOT);
}


//*************************************************************
//
//  populateTreeViewWithInternalList
//
//  Loads list entries at 'iterator' below tree view item 'hParent'
//  into 'hTreeView'.  Associates value of each list entry with 
//  the Param of the Tree View node.
//
BOOL ImpExpUserProcess::populateTreeViewWithInternalList
(
    HWND hTreeView,
    ListIterator iterator,
    HTREEITEM hParent
)
{
    BOOL retVal = FALSE;
    
    if( iterator.AtEndOfList())
        goto donePopulateTreeViewWithInternalList;

    TVINSERTSTRUCT newTV;
    HTREEITEM hNew;
    
    //  declare parent and intent to put at end of list.
    newTV.hParent = hParent;
    newTV.hInsertAfter = TVI_LAST;

    // build info struct
    newTV.itemex.mask = TVIF_TEXT
                        | TVIF_PARAM
                        | TVIF_CHILDREN
                        | TVIF_IMAGE
                        | TVIF_SELECTEDIMAGE;

    // give name
    newTV.itemex.cchTextMax = lstrlen( iterator.GetName()) + 1;
    newTV.itemex.pszText = const_cast<LPTSTR>(iterator.GetName());
    
    // associate the necessary data
    newTV.itemex.lParam = (LPARAM)iterator.GetValue();

    // tell tree view if there are any children.
    newTV.itemex.cChildren = 
        iterator.GetSublist().AtEndOfList() == TRUE ? FALSE : TRUE;

    //  use correct icons
    newTV.itemex.iSelectedImage = FOLDER_OPEN ;
    newTV.itemex.iImage = FOLDER_CLOSED ;

    hNew = TreeView_InsertItem( hTreeView, &newTV );

    if( hNew == NULL)
        goto donePopulateTreeViewWithInternalList;

    //  an element has been added, so we should return TRUE.
    retVal = TRUE;

    //  add children
    populateTreeViewWithInternalList( hTreeView, iterator.GetSublist(), hNew );

    //  add siblings
    if( iterator.Next())
        populateTreeViewWithInternalList( hTreeView, iterator, hParent );

donePopulateTreeViewWithInternalList:
    return retVal;

}

BOOL ImpExpUserProcess::ExpandTreeViewRoot ( HWND hTreeView ) 
{

    HTREEITEM hRoot ;

    hRoot = TreeView_GetRoot ( hTreeView ) ;

    if ( hRoot != NULL )
        TreeView_Expand ( hTreeView, hRoot, TVE_EXPAND ) ;
    else
        return FALSE ;

    return TRUE ;

}

//*************************************************************
//
//  SelectInternalSelection
//
//  Gets the data associated with the current selection of
//'hTreeView'.

BOOL ImpExpUserProcess::SelectInternalSelection( HWND hTreeView)
{
    HTREEITEM hSelection = TreeView_GetSelection( hTreeView);
    
    if( hSelection == NULL)
        return FALSE;

    //TVITEM is built up to query the lParam
    //(the lParam has been associated with a pointer to the path value)
    TVITEM TV;
    TV.mask = TVIF_PARAM;
    TV.hItem = hSelection;
    
    if( !TreeView_GetItem( hTreeView, &TV))
        return FALSE;

    m_pSelectedInternal = (LPTSTR)TV.lParam;

    ASSERT( m_pSelectedInternal != NULL);
    
    return TRUE;
}


//*************************************************************
//
//  purgeInternalList
//
//  Wipes out whatever has been loaded in the internal
//target/source list.

void ImpExpUserProcess::purgeInternalList()
{
    // clear the list.
    ListIterator iterator = (ListIterator)m_InternalList;

    while( iterator.Remove())
    {
    }

    m_pSelectedInternal = NULL;
    m_InternalListExternalType = INVALID_EXTERNAL;
    m_InternalListTransferType = INVALID_TRANSFER;
}


//*************************************************************
//
//  populateInternalList
//
//  Builds the internal list for potential internal target/sources.
//  This currently only makes sense for bookmarks, where a favorites
//directory has to be picked.

//  returns TRUE if any elements have been added to the internal list
BOOL ImpExpUserProcess::populateInternalList()
{
    ASSERT( m_ExternalType != INVALID_EXTERNAL);

    if( m_InternalListExternalType == m_ExternalType
        && m_InternalListTransferType == m_TransferType)
        return TRUE;

    purgeInternalList();

    // (could switch on different m_ExternalTypes here)
    if( !populateInternalListForBookmarks())
    {
        purgeInternalList();
        return FALSE;
    }

    m_InternalListExternalType = m_ExternalType;
    m_InternalListTransferType = m_TransferType;
    return TRUE;
}


//*************************************************************
//
//  populateInternalListForBookmarks

//  returns TRUE if any elements have been added to the internal list
BOOL ImpExpUserProcess::populateInternalListForBookmarks()
{
    TCHAR szFavoritesPath[MAX_PATH];

    if( SHGetSpecialFolderPath( NULL, szFavoritesPath, CSIDL_FAVORITES, FALSE)
        && appendSubdirsToInternalList( szFavoritesPath, ARRAYSIZE(szFavoritesPath), m_InternalList))
    {
        return TRUE;
    }
    else return FALSE;
}


//*************************************************************
//
//  appendSubdirsToInternalList
//
//  Takes 'sPath' as a specification for a file search.  All
//directories that match that are added to the internal list 
//at 'iterator'.
//  Recursively adds subdirectories found.
//
//typical usage:
//     szPath is "c:\Root\Favorites",
//       finds "c:\Root\Favorites",
//   recursively calls itself with
//     szPath = "c:\Root\Favorites\*.*"
//       finding and recursing into all subdirs

//  returns TRUE if any directories have been added to the internal list
//  Edits the contents of the buffer past the last '\\'.
BOOL ImpExpUserProcess::appendSubdirsToInternalList(LPTSTR pszPath, DWORD cchPath, ListIterator iterator)
{
    BOOL fHaveAddedDirectories = FALSE;

    DWORD cPathLength = lstrlen(pszPath);

    HANDLE hEnum;
    WIN32_FIND_DATA currentFile;

    hEnum = FindFirstFile( pszPath, &currentFile);

    //example:
    //given: "c:\root\*.*"  (will find all dirs in root)
    //want: "c:\root\"
    //given: "c:\favorites" (will find favorites in root)
    //want: "c:\"
    //  left search to '\\' to find the path of the files to be found.
    while( cPathLength > 0
           && pszPath[ --cPathLength] != TCHAR(FILENAME_SEPARATOR))
    {
    }
    cPathLength++;

    if( hEnum == INVALID_HANDLE_VALUE)
        return FALSE;

    do
    {
        DWORD cFileNameLength;
        
        // we only handle directories
        if( !(currentFile.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            continue;

        // we don't want '.' and '..' to show up.
        if( !StrCmp( currentFile.cFileName, DOT_DIR)
            || !StrCmp( currentFile.cFileName, DOT_DOT_DIR))
            continue;

        cFileNameLength = lstrlen( currentFile.cFileName);
        StrCpyN(pszPath + cPathLength, currentFile.cFileName, cchPath - cPathLength);

        if( iterator.Insert( currentFile.cFileName, cFileNameLength + 1,
                             pszPath, cPathLength + cFileNameLength + 1))
        {
            StrCpyN(pszPath + cPathLength + cFileNameLength, ALL_FILES_WILDCARD, cchPath - cPathLength - cFileNameLength);
            appendSubdirsToInternalList( pszPath, cchPath, iterator.GetSublist());
            // we know now that a directory has been added
            fHaveAddedDirectories = TRUE;
        }
    } while( FindNextFile( hEnum, &currentFile));
    ASSERT(ERROR_NO_MORE_FILES == GetLastError());

    FindClose(hEnum);
    return fHaveAddedDirectories;
}


//*************************************************************
//
//  PerformImpExpProcess
//
//  Once everything is set up right, this should do the trick.

void ImpExpUserProcess::PerformImpExpProcess(HWND hwnd)
{
    ASSERT( GetExternalType() != INVALID_EXTERNAL);
    ASSERT( GetTransferType() != INVALID_TRANSFER);
    ASSERT( (GetExternalType() == BOOKMARKS) ? (GetInternalSelection() != NULL) : TRUE);

    HCURSOR hOldCursor;

    //
    // This could take a while, so show an hourglass cursor
    //
    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    switch( GetExternalType())
    {
    case COOKIES:

        switch( GetTransferType())
        {
        case IMPORT:
            if (ImportCookieFile(m_szFileName))
            {
                MLShellMessageBox(
                    hwnd, 
                    MAKEINTRESOURCE(IDS_IMPORTSUCCESS_COOK), 
                    MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_COOK),
                    MB_OK);
            }
            else
            {
                MLShellMessageBox(
                    hwnd, 
                    MAKEINTRESOURCE(IDS_IMPORTFAILURE_COOK), 
                    MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_COOK),
                    MB_OK);
            }
            break;

        case EXPORT:
            if (SUCCEEDED(SHPathPrepareForWriteWrap(hwnd, NULL, m_szFileName, FO_COPY, (SHPPFW_DEFAULT | SHPPFW_IGNOREFILENAME))))
            {
                //  FALSE specifies that we will overwrite cookies
                if (ExportCookieFile(m_szFileName, FALSE ))
                {
                    MLShellMessageBox(
                        hwnd, 
                        MAKEINTRESOURCE(IDS_EXPORTSUCCESS_COOK), 
                        MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_COOK),
                        MB_OK);
                }
                else
                {
                    MLShellMessageBox(
                        hwnd, 
                        MAKEINTRESOURCE(IDS_EXPORTFAILURE_COOK), 
                        MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_COOK),
                        MB_OK);
                }
            }
            break;

        default:
            ASSERT(0);
            
        }
        break;
        
    case BOOKMARKS:

        DoImportOrExport(
            GetTransferType()==IMPORT,
            m_pSelectedInternal,
            m_szFileName,
            FALSE);

        break;

    default:
        ASSERT(0);

    }

    //
    // Put the old cursor back when finished
    //
    SetCursor(hOldCursor);

}


//*************************************************************
//*************************************************************
//
//   ImpExpUserDlg
//
//  Handles the user interface side of things, building
//  up an ImpExpUserProcess then executing it.
//  The dialog procedures below will all have a return value
//  which can be set to something besides FALSE if used, or left
//  as FALSE if not used.  Since only one section of code should
//  attempt to give the return value a value before returning,
//  class RetVal is set up to throw an assertion if two pieces
//  of code intended to pass back a return value at the same
//  time.

class ReturnValue
{

private:
    BOOL_PTR m_value;

public:
    ReturnValue()
    { 
        m_value = FALSE;
    }
    
    BOOL_PTR operator =(BOOL_PTR newVal)
    {
        ASSERT( m_value == FALSE);
        m_value = newVal;
        return m_value;
    }
    
    operator BOOL_PTR ()
    {
        return m_value;
    }
};

class ImpExpUserDlg
{

private:

    static HIMAGELIST m_himl ;
    static BOOL InitImageList ( HWND hwndTree ) ;   
    static BOOL DestroyImageList ( HWND hwndTree ) ;    

    static HFONT m_hfont ;
    static BOOL InitFont ( HWND hwndStatic ) ;
    static BOOL DestroyFont ( HWND hwndStatic ) ;

    //  A sheet knows its resource ID and what process
    //it contributes to.
    struct SheetData
    {
        int _idPage;
        ImpExpUserProcess* _pImpExp;

        SheetData( int idPage, ImpExpUserProcess* pImpExp )
        : _idPage( idPage ), _pImpExp( pImpExp )
        {
        }
    };
    //
    //  InitializePropertySheetPage() will associate a dialog 
    //  with an allocated copy of SheetData, which will be
    //  found at PSN_SETACTIVE with and stored with SetWindowLong.
    //  The allocated SheetData will be cleaned up by callback
    //  procedure PropertySheetPageProc().
    //
    //  Callback functions sure are a drag for maintaining identity.
    //  GetWindowLong and SetWindowLong will be used to keep tabs
    //  on who is who, setting 'ghost' member variables.
    //
    // 'ghost' SheetData*         This;
    // 'ghost' ImpExpUserProcess* m_pImpExp;
    // 'ghost' DWORD              m_idPage;
    //
    //  CommonDialogProc retrieves the 'ghost' values and does other 
    //  shared behavior.
    //
    static DWORD CommonDialogProc
    ( 
        IN HWND hwndDlg, IN UINT msg, IN WPARAM wParam, IN LPARAM lParam,
        OUT ImpExpUserProcess** ppImpExp, OUT DWORD* pPageId,
        IN OUT ReturnValue& retVal
    );

    static void InitializePropertySheetPage( PROPSHEETPAGE* psp, DWORD idDialogTemplate, DWORD idTitle, DWORD idSubTitle,DLGPROC dlgProc, ImpExpUserProcess* lParam);
    static UINT CALLBACK PropertySheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);

    //  some dialog procedures
    static BOOL_PTR CALLBACK Wizard97DlgProc( HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL_PTR CALLBACK TransferTypeDlg(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL_PTR CALLBACK InternalDlg(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);
    static BOOL_PTR CALLBACK ExternalDlg(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);

    static void HandleTransferTypeChange ( HWND hwndDlg, ImpExpUserProcess* m_pImpExp, UINT iSelect ) ;

public:
    static BOOL RunNewDialogProcess( HWND hParent ) ;

};

HIMAGELIST ImpExpUserDlg::m_himl = NULL ;

BOOL ImpExpUserDlg::InitImageList ( HWND hwndTree )
{

    //
    // Code to retrieve icons for open and closed folders
    // was based on code in private/samples/sampview/utility.cpp.
    //

    TCHAR       szFolder[MAX_PATH];
    SHFILEINFO  sfi;
    HIMAGELIST  himlOld ;
    DWORD       dwRet ;

    // create the image list
    m_himl = ImageList_Create ( GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), ILC_COLORDDB, 2, 2 ) ;

    if ( m_himl == NULL )
        return FALSE ;

    ImageList_SetBkColor( m_himl, GetSysColor(COLOR_WINDOW) ) ;

    // add the closed folder icon
    GetWindowsDirectory(szFolder, MAX_PATH);
    SHGetFileInfo( szFolder,
                   0,
                   &sfi,
                   sizeof(sfi),
                   SHGFI_ICON | SHGFI_SMALLICON);
    dwRet = ImageList_AddIcon(m_himl, sfi.hIcon);
    ASSERT ( dwRet == FOLDER_CLOSED ) ;

    // add the open folder icon
    SHGetFileInfo( szFolder,
                   0,
                   &sfi,
                   sizeof(sfi),
                   SHGFI_ICON | SHGFI_SMALLICON | SHGFI_OPENICON);
    dwRet = ImageList_AddIcon(m_himl, sfi.hIcon);
    ASSERT ( dwRet == FOLDER_OPEN ) ;

    himlOld = TreeView_SetImageList( hwndTree, m_himl, TVSIL_NORMAL );

    if ( himlOld != NULL )
    {
        BOOL fOk ;
        fOk = ImageList_Destroy ( himlOld ) ;
        ASSERT ( fOk ) ;
    }

    return TRUE ;

}

BOOL ImpExpUserDlg::DestroyImageList ( HWND hwndTree ) 
{
    HIMAGELIST himlOld ;

    himlOld = TreeView_SetImageList( hwndTree, NULL, TVSIL_NORMAL );

    if ( himlOld != NULL )
    {
        BOOL fOk ;
        fOk = ImageList_Destroy ( himlOld ) ;
        ASSERT ( fOk ) ;
    }

    return TRUE ;
}


HFONT ImpExpUserDlg::m_hfont = NULL ;

BOOL ImpExpUserDlg::InitFont ( HWND hwndStatic ) 
{

    HDC hdc = GetDC ( hwndStatic ) ;

    if ( hdc == NULL )
        return FALSE ;

    LOGFONT lf;
    lf.lfEscapement = 0;
    lf.lfOrientation = 0;
    lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
    lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
    lf.lfQuality = DEFAULT_QUALITY;
    lf.lfPitchAndFamily = DEFAULT_PITCH;
    lf.lfItalic = 0;
    lf.lfWeight = FW_BOLD;
    lf.lfStrikeOut = 0;
    lf.lfUnderline = 0;
    lf.lfWidth = 0;
    lf.lfHeight = -MulDiv(13, GetDeviceCaps(hdc, LOGPIXELSY), 72);

    LOGFONT lfTmp;
    HFONT   hFontOrig = (HFONT)SendMessage(hwndStatic, WM_GETFONT, (WPARAM)0, (LPARAM)0);
    if (hFontOrig && GetObject(hFontOrig, sizeof(lfTmp), &lfTmp))
    {
        lf.lfCharSet = lfTmp.lfCharSet;
        StrCpyN(lf.lfFaceName, lfTmp.lfFaceName, ARRAYSIZE(lf.lfFaceName));
    }
    else
    {
        lf.lfCharSet = GetTextCharset(hdc);
        StrCpyN(lf.lfFaceName, TEXT("MS Shell Dlg"), LF_FACESIZE);
    }

    m_hfont = CreateFontIndirect(&lf);

    if ( m_hfont == NULL )
    {
        ReleaseDC(hwndStatic, hdc);
        return FALSE ;
    }

    SendMessage ( hwndStatic, WM_SETFONT, (WPARAM)m_hfont, MAKELPARAM(FALSE, 0) ) ;

    ReleaseDC ( hwndStatic,hdc ) ;

    return TRUE ;

}

BOOL ImpExpUserDlg::DestroyFont ( HWND hwndDlg )
{

    if ( m_hfont )
        DeleteObject ( m_hfont ) ;

    return TRUE ;
}

void ImpExpUserDlg::InitializePropertySheetPage
(
    PROPSHEETPAGE* psp, 
    DWORD idDialogTemplate,
    DWORD idTitle,
    DWORD idSubTitle,
    DLGPROC dlgProc,
    ImpExpUserProcess* lParam
)
{
    psp->dwFlags |= PSP_USECALLBACK | PSP_USETITLE;
    psp->hInstance = MLGetHinst();
    psp->pszTemplate = MAKEINTRESOURCE(idDialogTemplate);
    psp->pfnDlgProc = dlgProc;
    psp->lParam = (LPARAM)(new SheetData(idDialogTemplate,lParam));
    psp->pfnCallback = PropertySheetPageProc;
    psp->pszHeaderTitle = MAKEINTRESOURCE(idTitle);
    psp->pszHeaderSubTitle = MAKEINTRESOURCE(idSubTitle);
    psp->pszTitle = MAKEINTRESOURCE(IDS_IMPEXP_CAPTION);

    if ( idDialogTemplate == IDD_IMPEXPWELCOME ||
         idDialogTemplate == IDD_IMPEXPCOMPLETE )
    {
        psp->dwFlags |= PSP_HIDEHEADER; 
    }
    else
    {
        psp->dwFlags |= (PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE);
    }

}


UINT CALLBACK ImpExpUserDlg::PropertySheetPageProc
(
    HWND hwnd, 
    UINT uMsg, 
    LPPROPSHEETPAGE ppsp
)
{

    switch(uMsg)
    {

    case PSPCB_CREATE:
        break;

    case PSPCB_RELEASE:
        delete (SheetData*)ppsp->lParam;
        ppsp->lParam = NULL;
        break;

    default:
        break;

    }

    return TRUE ;
}


BOOL ImpExpUserDlg::RunNewDialogProcess(HWND hParent)
{


    const int numPages = 9;
    ImpExpUserProcess* pImpExp = new ImpExpUserProcess();

    if( pImpExp == NULL)
        return FALSE;
        
    PROPSHEETPAGE pspOld[numPages];
    PROPSHEETPAGE* psp = pspOld;

    // dwSkip is set in Whistler_AllocatePropertySheetPage to whatever the size of Whistler's PROPSHEETPAGE
    // is. 0x34 last I checked. (IE5 PROPSHEETPAGE is 0x30)
    DWORD dwSkip = sizeof(PROPSHEETPAGE);
    if (IsOS(OS_WHISTLERORGREATER))
    {
        PROPSHEETPAGE* psp2 = Whistler_AllocatePropertySheetPage(numPages, &dwSkip);
        if (psp2)
        {
            psp = psp2;
        }
    }
    if (psp==pspOld)
    {
        for (int i=0; i<numPages; i++)
        {
            memset(&psp[i], 0, sizeof(PROPSHEETPAGE));
            psp[i].dwSize = sizeof(PROPSHEETPAGE);
        }
    }
     
    PROPSHEETHEADER psh;

    PBYTE pspNext = (PBYTE)psp;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPWELCOME,        0,                              0,                                  Wizard97DlgProc, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPTRANSFERTYPE,   IDS_IMPEXPTRANSFERTYPE_TITLE,   IDS_IMPEXPTRANSFERTYPE_SUBTITLE,    TransferTypeDlg, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPIMPFAVSRC,      IDS_IMPEXPIMPFAVSRC_TITLE,      IDS_IMPEXPIMPFAVSRC_SUBTITLE,       ExternalDlg, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPIMPFAVDES,      IDS_IMPEXPIMPFAVDES_TITLE,      IDS_IMPEXPIMPFAVDES_SUBTITLE,       InternalDlg, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPEXPFAVSRC,      IDS_IMPEXPEXPFAVSRC_TITLE,      IDS_IMPEXPEXPFAVSRC_SUBTITLE,       InternalDlg, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPEXPFAVDES,      IDS_IMPEXPEXPFAVDES_TITLE,      IDS_IMPEXPEXPFAVDES_SUBTITLE,       ExternalDlg, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPIMPCKSRC,       IDS_IMPEXPIMPCKSRC_TITLE,       IDS_IMPEXPIMPCKSRC_SUBTITLE,        ExternalDlg, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPEXPCKDES,       IDS_IMPEXPEXPCKDES_TITLE,       IDS_IMPEXPEXPCKDES_SUBTITLE,        ExternalDlg, pImpExp );
    pspNext += dwSkip;
    InitializePropertySheetPage( (PROPSHEETPAGE*)pspNext, IDD_IMPEXPCOMPLETE,       0,                              0,                                  Wizard97DlgProc, pImpExp );

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_WIZARD97 | PSH_PROPSHEETPAGE | PSH_HEADER | PSH_WATERMARK ; 
    psh.hwndParent = hParent;
    psh.hInstance = MLGetHinst();
    psh.pszCaption = MAKEINTRESOURCE(IDS_IMPEXP_CAPTION);
    psh.nPages = numPages;
    psh.nStartPage = 0;
    psh.ppsp = psp;
    psh.pszbmWatermark = MAKEINTRESOURCE(IDB_IMPEXPWATERMARK);
    psh.pszbmHeader = MAKEINTRESOURCE(IDB_IMPEXPHEADER);

    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
    int iResult = (int)PropertySheet(&psh) ;
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
    delete pImpExp;
    if (psp!=pspOld)
    {
        HeapFree(GetProcessHeap(), NULL, psp);
    }
    return iResult;

}


//*************************************************************
//
//  CommonDialogProc
//
//  Prepares 'ghost' member variables of the user dialog process,
//  handles ordering details of wizard pages and initializes common
//  dialog elements.
//
//  retVal passes through CommonDialogProc so that it can be set
//  if necessary.  Clients of CommonDialogProc should not need
//  to specify a new return value if CommonDialogProc has specified
//  a non-FALSE return value.
//
//  If CommonDialogProc returns FALSE dialog procedure should
//  considered 'msg' handled and return retVal immediately.
//
//  If this dialog has yet to receive WM_INITDIALOG, the 'ghost'
//  values will be zero (and invalid).
//

DWORD ImpExpUserDlg::CommonDialogProc
( 
    IN HWND hwndDlg, 
    IN UINT msg,
    IN WPARAM wParam,
    IN LPARAM lParam,
    OUT ImpExpUserProcess** ppImpExp,
    OUT DWORD* pPageId,
    ReturnValue& retVal
)
{

    SheetData* sheetData;
    ImpExpUserProcess* m_pImpExp = NULL;
    DWORD m_idPage = 0;

    //
    // Do init-dialog stuff
    //
    if ( WM_INITDIALOG == msg )
    {
        sheetData = (SheetData*)(((PROPSHEETPAGE*)lParam)->lParam);
        SetWindowLongPtr( hwndDlg, DWLP_USER, (LONG_PTR)sheetData);
    }

    //
    // Initialize the sheetData field
    //
    sheetData = (SheetData*)GetWindowLongPtr( hwndDlg, DWLP_USER ) ;
    if ( sheetData != NULL )
    {
        m_pImpExp = *ppImpExp = sheetData->_pImpExp;
        m_idPage = *pPageId = sheetData->_idPage;
    }

    //
    // Next, we check to make sure we're on the correct page.  If not, simply
    // return -1 and the wizard will automatically advance to the next page.
    //
    if( WM_NOTIFY == msg && PSN_SETACTIVE == ((LPNMHDR)lParam)->code )
    {

        BOOL fPageValidation = TRUE ;

        switch( m_idPage )
        {

        case IDD_IMPEXPWELCOME:
        case IDD_IMPEXPTRANSFERTYPE:
        case IDD_IMPEXPCOMPLETE:                    
            break;

        case IDD_IMPEXPIMPFAVSRC:
        case IDD_IMPEXPIMPFAVDES:
            if(m_pImpExp->GetTransferType() != IMPORT || m_pImpExp->GetExternalType() != BOOKMARKS)
                fPageValidation = FALSE;
            break;
    
        case IDD_IMPEXPEXPFAVSRC:
        case IDD_IMPEXPEXPFAVDES:
            if(m_pImpExp->GetTransferType() != EXPORT || m_pImpExp->GetExternalType() != BOOKMARKS)
                fPageValidation = FALSE;
            break;

        case IDD_IMPEXPIMPCKSRC:
            if(m_pImpExp->GetTransferType() != IMPORT || m_pImpExp->GetExternalType() != COOKIES)
                fPageValidation = FALSE;
            break;

        case IDD_IMPEXPEXPCKDES:
            if(m_pImpExp->GetTransferType() != EXPORT || m_pImpExp->GetExternalType() != COOKIES)
                fPageValidation = FALSE;
            break;
        }

        SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, fPageValidation ? 0 : -1 ) ;
        retVal = TRUE ;
        
        if ( ! fPageValidation )
            return FALSE ;

    }

    //
    // Initialize fonts and image lists (if needed)
    //
    if ( WM_NOTIFY == msg )
    {

        HWND hwndTitle = GetDlgItem ( hwndDlg, IDC_IMPEXPTITLETEXT )  ;
        HWND hwndTree = GetDlgItem ( hwndDlg, IDC_IMPEXPFAVTREE )  ;

        switch ( ((LPNMHDR)lParam)->code )
        {

        case PSN_SETACTIVE:
        
            if ( hwndTitle )
                InitFont ( hwndTitle ) ;

            if ( hwndTree )
                InitImageList( hwndTree ) ;
    
            break ;

        case PSN_KILLACTIVE:
        case PSN_QUERYCANCEL:

            if ( hwndTitle )
                DestroyFont ( hwndTitle ) ;

            if ( hwndTree )
                DestroyImageList( hwndTree ) ;

            break;

        }
    
    }

    if( WM_NOTIFY == msg && PSN_SETACTIVE == ((LPNMHDR)lParam)->code )
    {

        HWND hwndParent = GetParent( hwndDlg);

        switch( m_idPage )
        {
        case IDD_IMPEXPWELCOME:
            PropSheet_SetWizButtons( hwndParent, PSWIZB_NEXT );
            break;
            
        case IDD_IMPEXPCOMPLETE:
            {

                UINT idText ;
                const TCHAR *szInsert = m_pImpExp->m_szFileName ;
                TCHAR szRawString[1024] ;
                TCHAR szRealString[1024] ;

                //
                // First, we need to figure out which string should 
                // be used to describe what the wizard is going to 
                // do (for example "Import the cookies from...")
                //
                if ( m_pImpExp->GetTransferType() == IMPORT )
                {
                    if ( m_pImpExp->GetExternalType() == COOKIES )
                        idText = IDS_IMPEXP_COMPLETE_IMPCK ;
                    else
                        idText = IDS_IMPEXP_COMPLETE_IMPFV ;
                }
                else
                {
                    if ( m_pImpExp->GetExternalType() == COOKIES )
                        idText = IDS_IMPEXP_COMPLETE_EXPCK ;
                    else
                        idText = IDS_IMPEXP_COMPLETE_EXPFV ;
                }

                LoadString(MLGetHinst(), idText, szRawString, ARRAYSIZE(szRawString));
                wnsprintf(szRealString, ARRAYSIZE(szRealString), szRawString, szInsert);

                //
                // Set the text in the listview, and do all the other magic to make
                // the tooltips work, etc.
                //
                SetListViewToString(GetDlgItem(hwndDlg,IDC_IMPEXPCOMPLETECONFIRM), szRealString);

                //
                // The SetListViewToString function helpfully sets the background color to
                // gray instead of the default (white).  But we actually want it white, so 
                // let's reset it here.
                // 
                ListView_SetBkColor(GetDlgItem(hwndDlg,IDC_IMPEXPCOMPLETECONFIRM), GetSysColor(COLOR_WINDOW));
                ListView_SetTextBkColor(GetDlgItem(hwndDlg,IDC_IMPEXPCOMPLETECONFIRM), GetSysColor(COLOR_WINDOW));
                
                PropSheet_SetWizButtons(hwndParent, PSWIZB_BACK|PSWIZB_FINISH);

            }
            break;
            
        default:
            PropSheet_SetWizButtons( hwndParent, PSWIZB_NEXT | PSWIZB_BACK );
            break;
        }

    }

    return TRUE ;
}


//*************************************************************
//
//  Wizard97DlgProc
//
//  Dialog proc for welcome and complete pages.
//  

BOOL_PTR CALLBACK ImpExpUserDlg::Wizard97DlgProc
(
    HWND hwndDlg, 
    UINT msg, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    ReturnValue retVal;

    ImpExpUserProcess* m_pImpExp = NULL;
    DWORD m_idPage = 0;

    if( !CommonDialogProc( hwndDlg, msg, wParam, lParam, 
                        &m_pImpExp, &m_idPage, retVal))
    {
        return retVal;
    }

    if( m_idPage == IDD_IMPEXPCOMPLETE 
        && msg == WM_NOTIFY
        && PSN_WIZFINISH == ((LPNMHDR)lParam)->code)

    m_pImpExp->PerformImpExpProcess(hwndDlg);

    return retVal;
}


//*************************************************************
//
//  TransferTypeDlg
//
//  Dialog proc for dialog where user picks transfer type
//  (import vs. export), (cookies vs. bookmarks)

BOOL_PTR CALLBACK ImpExpUserDlg::TransferTypeDlg
(
    HWND hwndDlg, 
    UINT msg, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    ReturnValue retVal;

    ImpExpUserProcess* m_pImpExp = NULL;
    DWORD m_idPage = 0;

    if( !CommonDialogProc( hwndDlg, msg, wParam, lParam, 
                        &m_pImpExp, &m_idPage, retVal))
    {
        return retVal;
    }

    HWND hwndDlgItem;
   
    switch( msg)
    {
    case WM_INITDIALOG:
        {
            hwndDlgItem = GetDlgItem( hwndDlg, IDC_IMPEXPACTIONLISTBOX);

            LRESULT index;
            TCHAR szBuffer[MAX_PATH];

            if( MLLoadString( IDS_IMPFAVORITES, szBuffer, ARRAYSIZE(szBuffer)))
            {
                index = ListBox_AddString( hwndDlgItem, szBuffer);
                ListBox_SetItemData( hwndDlgItem, index, IDS_IMPFAVORITES);
            }

            if( MLLoadString( IDS_EXPFAVORITES, szBuffer, ARRAYSIZE(szBuffer)))
            {
                index = ListBox_AddString( hwndDlgItem, szBuffer);
                ListBox_SetItemData( hwndDlgItem, index, IDS_EXPFAVORITES);
            }
            
            if( MLLoadString( IDS_IMPCOOKIES, szBuffer, ARRAYSIZE(szBuffer)))
            {
                index = ListBox_AddString( hwndDlgItem, szBuffer);
                ListBox_SetItemData( hwndDlgItem, index, IDS_IMPCOOKIES);
            }
            
            if( MLLoadString( IDS_EXPCOOKIES, szBuffer, ARRAYSIZE(szBuffer)))
            {
                index = ListBox_AddString( hwndDlgItem, szBuffer);
                ListBox_SetItemData( hwndDlgItem, index, IDS_EXPCOOKIES);
            }

            // Select the first list item, by default
            ListBox_SetCurSel(hwndDlgItem, 0);
            HandleTransferTypeChange(hwndDlg, m_pImpExp, IDS_IMPFAVORITES);

        }  // end of WM_INITDIALOG
        break;
        
    case WM_COMMAND:
        //  when the user selects an option, choose it and
        //and update the description box.
        hwndDlgItem = GetDlgItem(hwndDlg, IDC_IMPEXPACTIONLISTBOX);

        if(hwndDlgItem == (HWND)lParam
           && HIWORD(wParam) == LBN_SELCHANGE)
        {

            //  find out which string resource was selected.
            LRESULT index = ListBox_GetCurSel(hwndDlgItem);
            LRESULT selection = ListBox_GetItemData(hwndDlgItem, index);

            HandleTransferTypeChange ( hwndDlg, m_pImpExp, (UINT)selection ) ;
            retVal = TRUE;

        }
        break;
        
    case WM_NOTIFY:

        //
        //  Prevent advancement until user has made valid choices
        //
        if( ((LPNMHDR)lParam)->code == PSN_WIZNEXT && m_pImpExp
            &&  (m_pImpExp->GetExternalType() == INVALID_EXTERNAL
                 || m_pImpExp->GetTransferType() == INVALID_TRANSFER))
        {
            SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, -1);
            retVal = TRUE;
        }

        //
        // otherwise, set the filename to nul (so we get the default)
        // and allow default navigation behavior
        //

        if (m_pImpExp)
            m_pImpExp->m_szFileName[0] = TEXT('\0');

        break;
    }

    return retVal;
}

void ImpExpUserDlg::HandleTransferTypeChange ( HWND hwndDlg, ImpExpUserProcess* pImpExp, UINT iSelect )
{

    TCHAR szBuffer[MAX_PATH];

    if (pImpExp)
    {
        //
        //  Note:  The description of each option has a resource id
        //  which is one higher than the resource id of the option name.
        //
        switch( iSelect )
        {
        case IDS_IMPFAVORITES:
            if( MLLoadString( IDS_IMPFAVORITES + 1, szBuffer, ARRAYSIZE(szBuffer) ) )
                SetWindowText( GetDlgItem( hwndDlg, IDC_IMPEXPACTIONDESCSTATIC ),
                               szBuffer );
            pImpExp->SelectExternalType( BOOKMARKS );
            pImpExp->SelectTransferType( IMPORT );
            break;
        
        case IDS_EXPFAVORITES:
            if( MLLoadString( IDS_EXPFAVORITES + 1, szBuffer, ARRAYSIZE(szBuffer) ) )
                SetWindowText( GetDlgItem( hwndDlg, IDC_IMPEXPACTIONDESCSTATIC ),
                               szBuffer );
            pImpExp->SelectExternalType( BOOKMARKS );
            pImpExp->SelectTransferType( EXPORT );
            break;
        
        case IDS_IMPCOOKIES:
            if( MLLoadString( IDS_IMPCOOKIES + 1, szBuffer, ARRAYSIZE(szBuffer)))
                SetWindowText( GetDlgItem( hwndDlg, IDC_IMPEXPACTIONDESCSTATIC),
                               szBuffer);
            pImpExp->SelectExternalType( COOKIES);
            pImpExp->SelectTransferType( IMPORT);
            break;

        case IDS_EXPCOOKIES:
            if( MLLoadString( IDS_EXPCOOKIES + 1, szBuffer, ARRAYSIZE(szBuffer)))
                SetWindowText( GetDlgItem( hwndDlg, IDC_IMPEXPACTIONDESCSTATIC),
                               szBuffer);
            pImpExp->SelectExternalType( COOKIES);
            pImpExp->SelectTransferType( EXPORT);
            break;
        }
    }

}


//*************************************************************
//
//  InternalDlg
//
//  Allows user to pick internal target/source from tree view.

BOOL_PTR CALLBACK ImpExpUserDlg::InternalDlg
(
    HWND hwndDlg, 
    UINT msg, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    ReturnValue retVal;

    ImpExpUserProcess* m_pImpExp = NULL;
    DWORD m_idPage = 0;

    if( !CommonDialogProc( hwndDlg, msg, wParam, lParam, 
                        &m_pImpExp, &m_idPage, retVal))
    {
        return retVal;
    }


    HWND hwndDlgItem;

    switch( msg)
    {
    case WM_INITDIALOG:

        //
        // Populate the tree control
        //
        hwndDlgItem = GetDlgItem(hwndDlg, IDC_IMPEXPFAVTREE);
        if ( hwndDlgItem )
        {
            if (m_pImpExp)
            {
                m_pImpExp->PopulateTreeViewForInternalSelection(hwndDlgItem);
                m_pImpExp->ExpandTreeViewRoot ( hwndDlgItem ) ;
            }
        }
        else
            ASSERT(0);

        return TRUE;


    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam)->code)
        {

        case PSN_WIZNEXT:

            //  Only allow user to go to next if there is a valid selection.
            if( !m_pImpExp->SelectInternalSelection(GetDlgItem(hwndDlg,IDC_IMPEXPFAVTREE)) )
            {
                SetWindowLongPtr( hwndDlg, DWLP_MSGRESULT, -1);
                retVal = TRUE;
            }

        }
    }

    return retVal;
}

BOOL IsValidFileOrURL(LPTSTR szFileOrURL)
{
    if (szFileOrURL == NULL)
        return FALSE;

    //
    // any URL is ok
    //
    if (PathIsURL(szFileOrURL))
        return TRUE;

    //
    // just a directory is no good, we need a filename too
    //
    if (PathIsDirectory(szFileOrURL))
        return FALSE;

    //
    // just a filename is no good, we need a directory too
    //
    if (PathIsFileSpec(szFileOrURL))
        return FALSE;

    //
    // relative paths are no good
    //
    if (PathIsRelative(szFileOrURL))
        return FALSE;

    //
    // now make sure it parses correctly
    //
    if (PathFindFileName(szFileOrURL) == szFileOrURL)
        return FALSE;

    return TRUE;

}

//*************************************************************
//
//  ExternalDlg
//
//  Allows user to pick external target/source from list box
//or manual browse.

BOOL_PTR CALLBACK ImpExpUserDlg::ExternalDlg
(
    HWND hwndDlg, 
    UINT msg, 
    WPARAM wParam, 
    LPARAM lParam
)
{
    ReturnValue retVal;

    ImpExpUserProcess* m_pImpExp = NULL;
    DWORD m_idPage = 0;

    if( !CommonDialogProc( hwndDlg, msg, wParam, lParam, 
                           &m_pImpExp, &m_idPage, retVal))
    {
        return retVal;
    }

    HWND hwndDlgItem;
    
    switch(msg)
    {

    case WM_COMMAND:

        hwndDlgItem = (HWND) lParam;
        if( HIWORD(wParam) == BN_CLICKED && LOWORD(wParam) == IDC_IMPEXPBROWSE)
        {
            OPENFILENAME ofn;
            TCHAR szFile[MAX_PATH];
            TCHAR szTitle[MAX_PATH];
            TCHAR szFilter[MAX_PATH];
            TCHAR szInitialPath[MAX_PATH];
            int i;

            ZeroMemory(&ofn, sizeof(OPENFILENAME));
            ofn.lStructSize = sizeof(OPENFILENAME);
            ofn.hwndOwner = hwndDlg;
            ofn.hInstance = MLGetHinst();
            ofn.lpstrFilter = szFilter;
            ofn.nFilterIndex = 1;
            ofn.lpstrCustomFilter = NULL;
            ofn.lpstrFile = szFile;
            ofn.nMaxFile = sizeof(szFile);
            ofn.lpstrFileTitle = NULL;
            ofn.lpstrInitialDir = szInitialPath;
            ofn.lpstrTitle = szTitle;
            ofn.lpstrDefExt = (m_pImpExp->GetExternalType()==COOKIES) ? TEXT("txt") : TEXT("htm");

            GetDlgItemText(hwndDlg, IDC_IMPEXPMANUAL, szInitialPath, ARRAYSIZE(szInitialPath));
            szFile[0] = 0;

            if (PathIsDirectory(szInitialPath))
            {
                ofn.lpstrInitialDir = szInitialPath;
                szFile[0] = TEXT('\0');    
            }
            else
            {
                TCHAR *pchFilePart;

                pchFilePart = PathFindFileName(szInitialPath);

                if (pchFilePart == szInitialPath || pchFilePart == NULL)
                {

                    if (PathIsFileSpec(szInitialPath))
                        StrCpyN(szFile,szInitialPath,ARRAYSIZE(szFile));
                    else
                        szFile[0] = TEXT('\0');

                    ofn.lpstrInitialDir = szInitialPath;
                    SHGetSpecialFolderPath(NULL,szInitialPath,CSIDL_DESKTOP,FALSE);

                }
                else
                {
                    pchFilePart[-1] = TEXT('\0');
                    ofn.lpstrInitialDir = szInitialPath;
                    StrCpyN(szFile,pchFilePart,ARRAYSIZE(szFile));
                }

            }
            
            //
            // Work out the title and the filter strings
            //
            if (m_pImpExp->GetExternalType() == BOOKMARKS)
            {
                MLLoadShellLangString(IDS_IMPEXP_CHOSEBOOKMARKFILE,szTitle,ARRAYSIZE(szTitle));
                MLLoadShellLangString(IDS_IMPEXP_BOOKMARKFILTER,szFilter,ARRAYSIZE(szFilter));
            }
            else
            {
                MLLoadShellLangString(IDS_IMPEXP_CHOSECOOKIEFILE,szTitle,ARRAYSIZE(szTitle));
                MLLoadShellLangString(IDS_IMPEXP_COOKIEFILTER,szFilter,ARRAYSIZE(szFilter));
            }

            //
            // Search and replace '@' with nul in the filter string
            //
            for (i=0; szFilter[i]; i++)
                if (szFilter[i]==TEXT('@'))
                    szFilter[i]=TEXT('\0');

            //
            // Set the flags for openfilename
            //
            ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY ;
            if (m_pImpExp->GetTransferType() == IMPORT)
                ofn.Flags |= (OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST);

            //
            // Show the dialog
            //
            if(GetSaveFileName(&ofn))
            {
                if(SetWindowText(GetDlgItem(hwndDlg, IDC_IMPEXPMANUAL), ofn.lpstrFile))
                {
                    Button_SetCheck(GetDlgItem( hwndDlg, IDC_IMPEXPRADIOFILE), BST_CHECKED);
                    Button_SetCheck(GetDlgItem( hwndDlg, IDC_IMPEXPRADIOAPP), BST_UNCHECKED);
                }
            }

            retVal = TRUE;
        }
        break;

    case WM_NOTIFY:
        switch( ((LPNMHDR)lParam)->code )
        {

        case PSN_SETACTIVE:
            {

                TCHAR sBuffer[MAX_PATH];
                DWORD cchSize = ARRAYSIZE(sBuffer);

                hwndDlgItem = GetDlgItem( hwndDlg, IDC_IMPEXPEXTERNALCOMBO );
                
                //
                // Load the "application list" into the combo box.
                // If the list is empty, then disable the combo box, 
                // disable the associated radio button, and select the
                // "to/from file" option (the second radio button).
                //
                if( hwndDlgItem != NULL
                    && m_pImpExp && m_pImpExp->PopulateComboBoxForExternalSelection( hwndDlgItem ) )
                {
                    EnableWindow ( GetDlgItem(hwndDlg, IDC_IMPEXPRADIOAPP), TRUE ) ;
                    EnableWindow ( hwndDlgItem, TRUE ) ;
                    Button_SetCheck( GetDlgItem( hwndDlg, IDC_IMPEXPRADIOAPP), BST_CHECKED);
                    Button_SetCheck( GetDlgItem( hwndDlg, IDC_IMPEXPRADIOFILE), BST_UNCHECKED);
                }
                else if ( hwndDlgItem != NULL)
                {
                    EnableWindow ( GetDlgItem(hwndDlg, IDC_IMPEXPRADIOAPP), FALSE ) ;
                    EnableWindow( hwndDlgItem, FALSE ) ;
                    Button_SetCheck( GetDlgItem( hwndDlg, IDC_IMPEXPRADIOFILE), BST_CHECKED);
                    Button_SetCheck( GetDlgItem( hwndDlg, IDC_IMPEXPRADIOAPP), BST_UNCHECKED);
                }
                
                //  Put a default value in the browse option.
                if(m_pImpExp->GetExternalManualDefault(sBuffer, &cchSize))
                    SetDlgItemText(hwndDlg, IDC_IMPEXPMANUAL, sBuffer);

                SHAutoComplete(GetDlgItem(hwndDlg, IDC_IMPEXPMANUAL), SHACF_FILESYSTEM);
            }
            break;

        case PSN_WIZNEXT:
            
            //    If the application radio button is checked,
            //  select the selection from the application combo box.  If
            //  the manual button is checked, select the selection
            //  using the manual edit box.

            retVal = TRUE;
            
            if (Button_GetCheck(GetDlgItem(hwndDlg,IDC_IMPEXPRADIOAPP)) == BST_CHECKED)
            {
                
                HWND hwndComboBox = GetDlgItem(hwndDlg,IDC_IMPEXPEXTERNALCOMBO);
                
                if (hwndComboBox != NULL)
                {
                    // Find out the index of the selected item
                    INT nIndex = ComboBox_GetCurSel(hwndDlg);
                    
                    if (nIndex != CB_ERR)
                    {
                        // Retrieve a pointer to the filename
                        LPTSTR pszFileName = (LPTSTR)ComboBox_GetItemData(hwndComboBox, nIndex);
                        
                        if (pszFileName != NULL)
                            StrCpyN(m_pImpExp->m_szFileName,pszFileName,ARRAYSIZE(m_pImpExp->m_szFileName));
                        
                    }
                    
                }
            }
            else if (Button_GetCheck(GetDlgItem(hwndDlg,IDC_IMPEXPRADIOFILE)) == BST_CHECKED)
            {
                
                // just get the text from the edit box
                GetDlgItemText(hwndDlg,IDC_IMPEXPMANUAL,m_pImpExp->m_szFileName,ARRAYSIZE(m_pImpExp->m_szFileName));

                //
                // Don't allow "next" if the edit control contains a bogus filename
                //
                if (!IsValidFileOrURL(m_pImpExp->m_szFileName))
                {
                    
                    TCHAR szFmt[128];
                    TCHAR szMsg[INTERNET_MAX_URL_LENGTH+128];
                    MLLoadShellLangString(IDS_INVALIDURLFILE, szFmt, ARRAYSIZE(szFmt));
                    wnsprintf(szMsg, ARRAYSIZE(szMsg), szFmt, m_pImpExp->m_szFileName);
                    MLShellMessageBox(
                        hwndDlg, 
                        szMsg, 
                        (IMPORT == m_pImpExp->GetTransferType()) ? 
                           MAKEINTRESOURCE(IDS_CONFIRM_IMPTTL_FAV) : 
                           MAKEINTRESOURCE(IDS_CONFIRM_EXPTTL_FAV), 
                        MB_OK);
                    
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
                    return retVal;
                }

                //
                // If the user doesn't type an extension, then we add ".htm"
                // or ".txt" as appropriate.  Otherwise, we don't touch it.
                //
                if (*PathFindExtension(m_pImpExp->m_szFileName) == TEXT('\0'))
                {
                    PathRenameExtension(
                        m_pImpExp->m_szFileName,
                        (m_pImpExp->GetExternalType()==COOKIES) ? TEXT(".txt") : TEXT(".htm"));
                }

            }
            else
            {
                ASSERT(0);
                m_pImpExp->m_szFileName[0] = TEXT('\0');
            }

            //
            // Finally, show an overwrite or file-not-found message
            // (but supress it if importing or exporting to a web address)
            //

            if (m_pImpExp->GetExternalType() == COOKIES ||
                !PathIsURL(m_pImpExp->m_szFileName))
            {
                if ( EXPORT == m_pImpExp->GetTransferType() && 
                    GetFileAttributes(m_pImpExp->m_szFileName) != 0xFFFFFFFF )
                {
                    int answer ;
                    UINT idTitle ;
                    
                    if ( m_pImpExp->GetExternalType() == COOKIES )
                        idTitle = IDS_EXPCOOKIES ;
                    else if ( m_pImpExp->GetExternalType() == BOOKMARKS )
                        idTitle = IDS_EXPFAVORITES ;
                    else
                        ASSERT(0);
                    
                    answer = WarningMessageBox(
                        hwndDlg,
                        idTitle,
                        IDS_IMPEXP_FILEEXISTS,
                        m_pImpExp->m_szFileName,
                        MB_YESNO | MB_ICONEXCLAMATION);
                    
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, (IDYES==answer)?0:-1);

                }
                else
                {
                    if (IMPORT == m_pImpExp->GetTransferType())
                    {
                        BOOL fError;

                        fError = FALSE;
                        if (PathIsUNC(m_pImpExp->m_szFileName))
                            ;
                        else
                            // Give the user a chance to insert the floppy if it's not already in.
                            fError = FAILED(SHPathPrepareForWriteWrap(hwndDlg,
                                                                      NULL,
                                                                      m_pImpExp->m_szFileName,
                                                                      FO_COPY,
                                                                      (SHPPFW_DEFAULT | SHPPFW_IGNOREFILENAME)));

                        if (!fError)
                            fError = (0xFFFFFFFF == GetFileAttributes(m_pImpExp->m_szFileName));

                        if (fError)
                        {
                            UINT idTitle ;
                    
                            if ( m_pImpExp->GetExternalType() == COOKIES )
                                idTitle = IDS_IMPCOOKIES ;
                            else if ( m_pImpExp->GetExternalType() == BOOKMARKS )
                                idTitle = IDS_IMPFAVORITES ;
                            else
                                ASSERT(0);

                            WarningMessageBox(
                                hwndDlg,
                                idTitle,
                                IDS_IMPEXP_FILENOTFOUND,
                                m_pImpExp->m_szFileName,
                                MB_OK | MB_ICONEXCLAMATION);
                    
                            SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, -1);
                    
                        }
                    }
                }

            }
            
            break; // PSN_WIZNEXT

        } // WM_NOTIFY

        break;
    
    } // switch(msg)

    return retVal;
}

BOOL WINAPI RunImportExportFavoritesWizard(HWND hDlg)
{

    ImpExpUserDlg::RunNewDialogProcess(hDlg);
    return TRUE;

}

int WarningMessageBox(HWND hwnd, UINT idTitle, UINT idMessage, LPCTSTR szFile, DWORD dwFlags)
{

    TCHAR szBuffer[1024];
    TCHAR szFormat[1024];

    //
    // load the string (must contain "%s")
    //
    MLLoadShellLangString(idMessage, szFormat, ARRAYSIZE(szFormat));
   
    //
    // insert the filename
    //
    wnsprintf(szBuffer,ARRAYSIZE(szBuffer),szFormat,szFile);

    //
    // display the messagebox
    //
    return MLShellMessageBox(
        hwnd,
        szBuffer,
        MAKEINTRESOURCE(idTitle),
        dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\inetnot.cpp ===
#include "priv.h"
#include "inetnot.h"

//+-------------------------------------------------------------------------
// Static initialization
//--------------------------------------------------------------------------
HWND  CWinInetNotify::s_hwnd = NULL;
ULONG CWinInetNotify::s_ulEnabled = 0;
CWinInetNotify* CWinInetNotify::s_pWinInetNotify = NULL;

//+-------------------------------------------------------------------------
// Constructor - Creates invisible top-level window.
//--------------------------------------------------------------------------
CWinInetNotify::CWinInetNotify()
:   _hMutex(NULL),
    _fEnabled(FALSE)
{
}

//+-------------------------------------------------------------------------
// Enables/disables wininet notifications
//--------------------------------------------------------------------------
void CWinInetNotify::Enable(BOOL fEnable)
{
    if (fEnable && !_fEnabled)
    {
        //
        // Enable the notifications
        //
        ENTERCRITICAL;
        ++s_ulEnabled;
        if (NULL == s_hwnd)
        {
            // create an invisible top-level window to receive notifications
            WNDCLASS  wc;
            ZeroMemory(&wc, SIZEOF(wc));

            wc.lpfnWndProc      = _WndProc;
            wc.hInstance        = HINST_THISDLL;
            wc.lpszClassName    = CWinInetNotify_szWindowClass;

            SHRegisterClass(&wc);

            s_hwnd = CreateWindow(CWinInetNotify_szWindowClass, NULL, WS_POPUP,
                        0, 0, 1, 1, NULL, NULL, HINST_THISDLL, this);
        }

        if (s_hwnd)
        {
            _fEnabled = TRUE;
        }

        LEAVECRITICAL;
    }
    else if (!fEnable && _fEnabled)
    {
        //
        // Disable the notifications
        //
        ENTERCRITICAL;
        if (--s_ulEnabled == 0)
        {
            //
            // We use a mutex here because we can have multiple instances of
            // iexplore.  We want to avoid setting up a window to accept wininet 
            // notifications if it is in the process of being destroyed.
            //
            _EnterMutex();

            // Look for another window to receive wininet notifications
            if (EnumWindows(EnumWindowsProc, NULL))
            {
                // No one left so turn off notifications
                RegisterUrlCacheNotification(0, 0, 0, 0, 0);
            }

            //
            // Handle any queued notifications.
            //
            // Note that we have a small window in which a notification
            // can be lost!  Something could be posted to us after we are
            // destroyed!
            //
            MSG msg;
            if (PeekMessage(&msg, s_hwnd, CWM_WININETNOTIFY, CWM_WININETNOTIFY, PM_REMOVE))
            {
                _OnNotify(msg.wParam);
            }

            DestroyWindow(s_hwnd);
            s_hwnd = NULL;

            // Now that our window is gone, we can allow other processes to
            // look for windows to receive notifications.
            _LeaveMutex();
        }
        LEAVECRITICAL;

        _fEnabled = FALSE;
    }
}

//+-------------------------------------------------------------------------
// Destructor - Destroys top-level window when last instance is destroyed
//--------------------------------------------------------------------------
CWinInetNotify::~CWinInetNotify()
{
    Enable(FALSE);
}

//+-------------------------------------------------------------------------
// Called for each top level window to find another one to accept wininet
// notifications.
//--------------------------------------------------------------------------
BOOL CALLBACK CWinInetNotify::EnumWindowsProc
(
    HWND hwnd,      // handle to top-level window
    LPARAM lParam   // application-defined value 
 
)
{
    // Ignore our own window
    if (hwnd == s_hwnd)
        return TRUE;

    // See if it's one of our windows
    TCHAR szWindowClass[30];
    if (GetClassName(hwnd, szWindowClass, ARRAYSIZE(szWindowClass)) &&
        StrCmp(CWinInetNotify_szWindowClass, szWindowClass) == 0)
    {
        _HookInetNotifications(hwnd);
        return FALSE;
    }
    return TRUE;
}
 
//+-------------------------------------------------------------------------
// Hooks up wininet notifications.
//--------------------------------------------------------------------------
void CWinInetNotify::_HookInetNotifications(HWND hwnd)
{
    // We always want to know when cache items become sticky or unstickey
    // or transition between online and offline
    DWORD dwFlags = CACHE_NOTIFY_URL_SET_STICKY |
                    CACHE_NOTIFY_URL_UNSET_STICKY |
                    CACHE_NOTIFY_SET_ONLINE |
                    CACHE_NOTIFY_SET_OFFLINE ;

    //
    // We only care about things being added to or removed from the
    // cache when we are offline.  The name-space-control greys unavailable
    // items when we are offline.
    //
    if (SHIsGlobalOffline())
    {
        dwFlags |= CACHE_NOTIFY_ADD_URL | CACHE_NOTIFY_DELETE_URL | CACHE_NOTIFY_DELETE_ALL;
    }

    RegisterUrlCacheNotification(hwnd, CWM_WININETNOTIFY, 0, dwFlags, 0);
}

//+-------------------------------------------------------------------------
// Re-broadcasts the notification using SHChangeNotify
//--------------------------------------------------------------------------
void CWinInetNotify::_OnNotify(DWORD_PTR dwFlags)
{
    // Remove any other queued notifications
    MSG msg;
    while (PeekMessage(&msg, s_hwnd, CWM_WININETNOTIFY, CWM_WININETNOTIFY, PM_REMOVE))
    {
        // Combine the notification bits
        dwFlags |= msg.wParam;
    }

    SHChangeDWORDAsIDList dwidl;
    // Align for UNIX
    dwidl.cb      = (unsigned short) PtrDiff(& dwidl.cbZero, &dwidl);
    dwidl.dwItem1 = SHCNEE_WININETCHANGED;
    dwidl.dwItem2 = (DWORD)dwFlags;
    dwidl.cbZero  = 0;

    SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, (LPCITEMIDLIST)&dwidl, NULL);

    // If we are switching between online and offline, we need to update the
    // events that we are interested in.
    if (dwFlags & (CACHE_NOTIFY_SET_ONLINE | CACHE_NOTIFY_SET_OFFLINE))
    {
        _HookInetNotifications(s_hwnd);
    }
}

//+-------------------------------------------------------------------------
// Window procedure for our invisible top-level window.  Receives
// notifications from wininet.
//--------------------------------------------------------------------------
LRESULT CALLBACK CWinInetNotify::_WndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage)
    {
        case WM_CREATE:
        {
            // Hook us up to get the notifications
            _HookInetNotifications(hwnd);
            break;
        }

        case CWM_WININETNOTIFY:
        {
            _OnNotify(wParam);
            return 0;
        }
    }

    return DefWindowProcWrap(hwnd, uMessage, wParam, lParam);
}

//+-------------------------------------------------------------------------
// Protect simultaneous access by multiple processes
//--------------------------------------------------------------------------
void CWinInetNotify::_EnterMutex()
{
    ASSERT(_hMutex == NULL);

    // This gets an existing mutex if one exists
    _hMutex = CreateMutex(NULL, FALSE, CWinInetNotify_szWindowClass);

    // Wait for up to 20 seconds
    if (!_hMutex || WaitForSingleObject(_hMutex, 20000) == WAIT_TIMEOUT)
    {
        ASSERT(FALSE);
    }
}

void CWinInetNotify::_LeaveMutex()
{
    if (_hMutex)
    {
        ReleaseMutex(_hMutex);
        CloseHandle(_hMutex);
        _hMutex = NULL;
    }
}


//+-------------------------------------------------------------------------
// Manages a global CWinInetNotify object
//--------------------------------------------------------------------------
void CWinInetNotify::GlobalEnable()
{
    if (s_pWinInetNotify == NULL)
    {
        ENTERCRITICAL;
        if (s_pWinInetNotify == NULL)
        {
            s_pWinInetNotify = new CWinInetNotify();
            if (s_pWinInetNotify)
            {
                s_pWinInetNotify->Enable();
            }
        }
        LEAVECRITICAL;
    }
}

void CWinInetNotify::GlobalDisable()
{
    ENTERCRITICAL;
    if (s_pWinInetNotify)
    {
        delete s_pWinInetNotify;
        s_pWinInetNotify = NULL;
    }
    LEAVECRITICAL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\inetnot.h ===
#ifndef _INETNOT_H
#define _INETNOT_H

//+-------------------------------------------------------------------------
// Wininet currently only support sending notifications of changes to the
// cache to one window.  This class creates one top-level window per process
// for receiving and re-broadcasting these notifications.  When the
// process shuts down, we look for another window to take over these
// messages. 
//
// This is an imperfect solution. It would have been much easier if the
// wininet guys could have been convinced to call SHChangeNotify instead. 
// However, they are planning to enhace this later. (stevepro))
//--------------------------------------------------------------------------
class CWinInetNotify
{
public:
    CWinInetNotify();
    ~CWinInetNotify();

    void Enable(BOOL fEnable = TRUE);

    static void GlobalEnable();
    static void GlobalDisable();

protected:
    void _EnterMutex();
    void _LeaveMutex();

    static void _HookInetNotifications(HWND hwnd);
    static void _OnNotify(DWORD_PTR dwFlags);
    static LRESULT CALLBACK _WndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam);
    enum
    {
        CWM_WININETNOTIFY  = WM_USER + 410
    };

    HANDLE          _hMutex;
    BOOL            _fEnabled;

    static HWND     s_hwnd;
    static ULONG    s_ulEnabled;
    static CWinInetNotify* s_pWinInetNotify;
};

#define CWinInetNotify_szWindowClass TEXT("Inet Notify_Hidden")



#endif //_INETNOT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\infotip.cpp ===
#include "priv.h"
#include "infotip.h"
#include "resource.h"

#include <mluisupp.h>

HRESULT ReadProp(IPropertyStorage *ppropstg, PROPID propid, PROPVARIANT *ppropvar)
{
    PROPSPEC prspec = { PRSPEC_PROPID, propid };

    return ppropstg->ReadMultiple(1, &prspec, ppropvar);
}

STDAPI GetStringProp(IPropertyStorage *ppropstg, PROPID propid, LPTSTR pszBuf, DWORD cchBuf)
{
    PROPVARIANT propvar;

    *pszBuf = 0;

    if (S_OK == ReadProp(ppropstg, propid, &propvar))
    {
        if (VT_LPWSTR == propvar.vt)
        {
            SHUnicodeToTChar(propvar.pwszVal, pszBuf, cchBuf);
        }
        else if (VT_LPSTR == propvar.vt)
        {
            SHAnsiToTChar(propvar.pszVal, pszBuf, cchBuf);
        }
        PropVariantClear(&propvar);
    }

    return *pszBuf ? S_OK : S_FALSE;
}

DWORD AppendTipText(LPTSTR pszBuf, int cchBuf, UINT ids, ...)
{
    DWORD dwRet;
    TCHAR szFmt[64];
    va_list ArgList;

    if (ids == 0 || 0 == MLLoadString(ids, szFmt, SIZECHARS(szFmt)))
    {
        StringCchCopy(szFmt, ARRAYSIZE(szFmt), TEXT("%s%s"));
    }

    va_start(ArgList, ids);
    dwRet = wvnsprintf(pszBuf, cchBuf, szFmt, ArgList);
    va_end(ArgList);

    return dwRet;
}

STDAPI GetInfoTipFromStorage(IPropertySetStorage *ppropsetstg, const ITEM_PROP *pip, WCHAR **ppszTip)
{
    TCHAR szTip[2048];
    LPTSTR psz = szTip;
    LPCTSTR pszCRLF = TEXT("");
    UINT cch, cchMac = SIZECHARS(szTip);
    const GUID *pfmtIdLast = NULL;
    IPropertyStorage *ppropstg = NULL;
    HRESULT hr = E_FAIL;

    *ppszTip = NULL;

    for (; pip->pfmtid; pip++)
    {
        // cache the last FMTID and reuse it if the next FMTID is the same

        if (!ppropstg || !IsEqualGUID(*pfmtIdLast, *pip->pfmtid))
        {
            if (ppropstg)
            {
                ppropstg->Release();
                ppropstg = NULL;
            }

            pfmtIdLast = pip->pfmtid;
            ppropsetstg->Open(*pip->pfmtid, STGM_READ | STGM_SHARE_EXCLUSIVE, &ppropstg);
        }

        if (ppropstg)
        {
            TCHAR szT[256];

            hr = pip->pfnRead(ppropstg, pip->idProp, szT, SIZECHARS(szT));
            if (S_OK == hr) 
            {
                cch = AppendTipText(psz, cchMac, pip->idFmtString, pszCRLF, szT);
                psz += cch;
                cchMac -= cch;
                pszCRLF = TEXT("\r\n");
            }
            else if (hr != S_FALSE)
            {
                break;  // error, exit for loop
            }
        }
    }

    if (ppropstg)
        ppropstg->Release();

    hr = S_FALSE;     // assume no tooltip

    if (psz != szTip)
    {
        hr = SHStrDup(szTip, ppszTip);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\ipstg.cpp ===
#include "priv.h"
#include "ipstg.h"

HRESULT CImpIPersistStorage::InitNew(IStorage *pStg)
{
    return InitNew();
}

HRESULT CImpIPersistStorage::Load(IStorage *pStg)
{
    HRESULT hres = E_INVALIDARG;

    if (EVAL(pStg))
    {
        IStream* pstm = NULL;
        hres = pStg->OpenStream(L"CONTENTS",0,STGM_READ|STGM_SHARE_EXCLUSIVE, 0, &pstm);
        if (EVAL(SUCCEEDED(hres)))
        {
            hres = pstm->Seek(c_li0, STREAM_SEEK_SET, NULL);
            if (SUCCEEDED(hres))
            {
                hres = Load(pstm);
            }
            pstm->Release();
        }
    }

    return hres;
}

HRESULT CImpIPersistStorage::Save(IStorage *pStgSave, BOOL fSameAsLoad)
{
    HRESULT hres = E_INVALIDARG;

    if (EVAL(pStgSave))
    {
        IStream* pstm = NULL;
        hres = pStgSave->CreateStream(L"CONTENTS",STGM_CREATE|STGM_WRITE|STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);
        if (EVAL(SUCCEEDED(hres)))
        {
            hres = pstm->Seek(c_li0, STREAM_SEEK_SET, NULL);
            if (SUCCEEDED(hres))
            {
                hres = Save(pstm, TRUE);
            }
            pstm->Release();
        }
    }

    return hres;
}

HRESULT CImpIPersistStorage::SaveCompleted(IStorage *pStgNew)
{
    return S_OK;
}

HRESULT CImpIPersistStorage::HandsOffStorage(void)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\infotip.h ===
typedef HRESULT (STDAPICALLTYPE *PFNREADPROP)(IPropertyStorage *ppropstg, PROPID propid, LPTSTR pszBuf, DWORD cchBuf);
    
typedef struct {
    const FMTID *pfmtid;    // FMTID_ for property set
    UINT idProp;            // property ID
    PFNREADPROP pfnRead;    // function to fetch the string representation
    UINT idFmtString;       // format string to use, should be "%1String %2"
} ITEM_PROP;

// standard PFNREADPROP callback types
STDAPI GetStringProp(IPropertyStorage *ppropstg, PROPID propid, LPTSTR pszBuf, DWORD cchBuf);
STDAPI GetInfoTipFromStorage(IPropertySetStorage *ppropsetstg, const ITEM_PROP *pip, WCHAR **ppszTip);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\inst.cpp ===
//***   inst.cpp -- 'instance' (CoCreate + initialization) mechanism
// SYNOPSIS
//  CInstClassFactory_Create    create 'stub loader' class factory
//  InstallBrowBandInst install BrowserBand instance into registry
//  InstallInstAndBag   install arbitrary instance into registry
//  - debug
//  DBCreateInitInst    create an
//
// DESCRIPTION
//  the 'instance' mechanism provides an easy way to create and initialize
//  a class from the registry (w/o writing any code).
//
//  an 'instance' consists of an INSTID (unique to the instance), a CLSID
//  (for the code), and an InitPropertyBag (to initialize the instance).
//
//  it is fully transparent to CoCreateInstance; that is, one can do a
//  CCI of an INSTID and it will create it and initialize it w/ the caller
//  none the wiser.  (actually there will be at least one tip-off, namely
//  that IPS::GetClassID on the instance will return the 'code' CLSID not
//  the 'instance' INSTID [which is as it should be, since this is exactly
//  how persistance works when one programmatically creates his own multiple
//  instances and then persists them. 
//
//  the INSTID is in the HKR/CLSID section of the registry (just like a
//  'normal' CLSID).  the code points to shdocvw.  when shdocvw hits the
//  failure case in its DllGetClassObject search, it looks for the magic
//  key 'HKCR/CLSID/{instid}/Instance'.  if it finds it, it knows it's
//  dealing w/ an INSTID, and builds a class factory 'stub loader' which
//  has sufficient information to find the 'code' CLSID and the 'init'
//  property bag.

#include "priv.h"

//***
// NOTES
//  perf: failure case is cheap, only does a RegOpen, no object creation.
//  positions to the 'Instance' part, must 'ChDir' to get to InitXxx part.
HKEY GetInstKey(LPTSTR pszInst)
{
    TCHAR szRegName[MAX_PATH];      // "CLSID/{instid}/Instance" size?

    // "CLSID/{instid}/Instance"
    ASSERT(ARRAYSIZE(szRegName) >= 5 + 1 + GUIDSTR_MAX - 1 + 1 + 8 + 1);
    ASSERT(lstrlen(pszInst) == GUIDSTR_MAX - 1);
    HKEY hk = NULL;
    HRESULT hr = StringCchPrintf(szRegName, ARRAYSIZE(szRegName), TEXT("CLSID\\%s\\Instance"), pszInst);
    if (SUCCEEDED(hr))
    {
        RegOpenKeyEx(HKEY_CLASSES_ROOT, szRegName, 0, KEY_QUERY_VALUE, &hk);
    }
    return hk;
}

class CInstClassFactory : IClassFactory
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFacotry
    STDMETHODIMP CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
    STDMETHODIMP LockServer(BOOL fLock);

    CInstClassFactory() { DllAddRef(); _cRef = 1; };
    HRESULT Init(REFCLSID rclsid);

private:
    ~CInstClassFactory();

    LONG _cRef;
    HKEY _hkey;  // hkey for instance info
};

// NOTES
//  called when class isn't in our sccls.c CCI table.  we see if it's an
// instance, and if so we make a stub for it that gives sufficient info
// for our CreateInstance to create and init it.
//
//  n.b. we keep the failure case as cheap as possible (just a regkey check,
// no object creation etc.).
//
STDAPI CInstClassFactory_Create(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CInstClassFactory *pcf = new CInstClassFactory();
    if (pcf) 
    {
        hr = pcf->Init(rclsid);
        if (SUCCEEDED(hr))
            hr = pcf->QueryInterface(riid, ppv);
        pcf->Release();
    }
    return hr;
}

HRESULT CInstClassFactory::Init(REFCLSID rclsid)
{
    ASSERT(_hkey == NULL);  // only init me once please

    TCHAR szClass[GUIDSTR_MAX];

    // "CLSID/{instid}/Instance"
    SHStringFromGUID(rclsid, szClass, ARRAYSIZE(szClass));
    _hkey = GetInstKey(szClass);
    
    return _hkey ? S_OK : E_OUTOFMEMORY;
}

CInstClassFactory::~CInstClassFactory()
{
    if (_hkey)
        RegCloseKey(_hkey);

    DllRelease();
}

ULONG CInstClassFactory::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CInstClassFactory::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

HRESULT CInstClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CInstClassFactory, IClassFactory), // IID_IClassFactory
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

HRESULT CInstClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;            // the usual optimism :-)
    *ppv = NULL;

    ASSERT(_hkey);          // o.w. shouldn't ever get here
    // get object (vs. instance) CLSID and create it

    // AppCompat: the "RealGuide" explorer bar from Real Audio has an extraneous
    // double quote at the end of its CLSID value.  This causes SHGetValue to fail
    // if given only an szClass[GUIDSTR_MAX] buffer, so we'll bump up the size.  

    TCHAR szClass[GUIDSTR_MAX + 1];

    DWORD cbTmp = sizeof(szClass);
    DWORD err = SHGetValue(_hkey, NULL, TEXT("CLSID"), NULL, szClass, &cbTmp);
    hr = HRESULT_FROM_WIN32(err);

    if (SUCCEEDED(hr))
    {
        // If there's a useless char at the end of the guid, we'll truncate it
        // to avoid making assumptions about GUIDFromString.  GUIDSTR_MAX includes
        // the null terminator, so szClass[GUIDSTR_MAX - 1] should always be 0
        // for a proper guid.

        szClass[GUIDSTR_MAX - 1] = 0;

        CLSID clsid;
        hr = GUIDFromString(szClass, &clsid) ? S_OK : E_FAIL;

        if (SUCCEEDED(hr))
        {
            IUnknown* pUnk;
            if (NOERROR == SHGetValue(_hkey, NULL, TEXT("LoadWithoutCOM"), NULL, NULL, NULL))
                hr = SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IUnknown, &pUnk));
            else
                hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &pUnk));

            if (SUCCEEDED(hr))
            {
                // try to load from propertybag first
                IPropertyBag *pbag;
                hr = SHCreatePropertyBagOnRegKey(_hkey, L"InitPropertyBag", STGM_READ, IID_PPV_ARG(IPropertyBag, &pbag));
                if (SUCCEEDED(hr))
                {
                    hr = SHLoadFromPropertyBag(pUnk, pbag);
                    pbag->Release();
                }

                // Did the property bag interface exist and did it load properly?
                if ( FAILED(hr))
                {
                    // No property bag interface or did not load suyccessfully, try stream
                    // Store this state temporarily, if stream fails too then we'll return the object
                    //  with this hr
                    HRESULT hrPropBag = hr;

                    IPersistStream* pPerStream;

                    hr = pUnk->QueryInterface(IID_PPV_ARG(IPersistStream, &pPerStream));

                    if (SUCCEEDED(hr))
                    {
                        IStream* pStream = SHOpenRegStream(_hkey, TEXT("InitStream"), NULL, STGM_READ);
                        if (pStream)
                        {
                            hr = pPerStream->Load(pStream);

                            pStream->Release();
                        }
                        else
                            hr = E_FAIL;

                        pPerStream->Release();
                    }
                    else
                        hr = hrPropBag;
                }

                if (SUCCEEDED(hr))
                {
                    hr = pUnk->QueryInterface(riid, ppv);
                }

                pUnk->Release();
            }  
        }
    }

    return hr;
}

HRESULT CInstClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\ipstg.h ===
#ifndef __IPSTG_H__
#define __IPSTG_H__

//
// CImpIPersistStorage works very well along-side an IPersistStreamInit
// implementation.
//
// IE30's CShellEmbedding implemented this interface because it was
// an embedding must-have. But none of our objects were marked as
// embeddable, so we really didn't need it.
//
// I pulled the implementation to a new class that can easily be
// included into any object that needs an IPersistStorange implementation
// that delegates to the object's IPersistStreamInit implementation.
//
class CImpIPersistStorage : public IPersistStorage
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;
    virtual STDMETHODIMP_(ULONG) AddRef(void) PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;

    // *** IPersist ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID) PURE;

    // *** IPersistStorage ***
    virtual STDMETHODIMP IsDirty(void) PURE; // matches IPersistStreamInit
    virtual STDMETHODIMP InitNew(IStorage *pStg);
    virtual STDMETHODIMP Load(IStorage *pStg);
    virtual STDMETHODIMP Save(IStorage *pStgSave, BOOL fSameAsLoad);
    virtual STDMETHODIMP SaveCompleted(IStorage *pStgNew);
    virtual STDMETHODIMP HandsOffStorage(void);

    // These happen to match IPersistStreamInit methods.
    // They should update the dirty state of the object as
    // returned from IsDirty().
    //
    virtual STDMETHODIMP Load(IStream *pStm) PURE;
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty) PURE;
    virtual STDMETHODIMP InitNew(void) PURE;
};

#endif // __IPSTG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\isdtobj.cpp ===
#include "priv.h"
#include "ishcut.h"

STDMETHODIMP Intshcut::GetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed)
{
    HRESULT hr;

    ZeroMemory(pstgmed, SIZEOF(*pstgmed));

    if (pfmtetc->cfFormat == g_cfURL || pfmtetc->cfFormat == g_cfURLW)
        hr = TransferUniformResourceLocator(pfmtetc, pstgmed);
    else if ((pfmtetc->cfFormat == CF_TEXT) || (pfmtetc->cfFormat == CF_UNICODETEXT))
        hr = TransferText(pfmtetc, pstgmed);
    else if (pfmtetc->cfFormat == g_cfFileDescA)
        hr = TransferFileGroupDescriptorA(pfmtetc, pstgmed);
    else if (pfmtetc->cfFormat == g_cfFileDescW)
        hr = TransferFileGroupDescriptorW(pfmtetc, pstgmed);
    else if (pfmtetc->cfFormat == g_cfFileContents)
        hr = TransferFileContents(pfmtetc, pstgmed);
    else
        hr = DV_E_FORMATETC;

    return hr;
}

STDMETHODIMP Intshcut::GetDataHere(FORMATETC *pfmtetc, STGMEDIUM *pstgpmed)
{
    return E_NOTIMPL;
}

STDMETHODIMP Intshcut::QueryGetData(FORMATETC *pfmtetc)
{
    HRESULT hr;

    if ((pfmtetc->cfFormat == g_cfURL) ||
        (pfmtetc->cfFormat == g_cfURLW) ||
        (pfmtetc->cfFormat == CF_TEXT) ||
        (pfmtetc->cfFormat == CF_UNICODETEXT) ||
        (pfmtetc->cfFormat == g_cfFileDescA) ||
        (pfmtetc->cfFormat == g_cfFileDescW))
    {
        hr = (pfmtetc->tymed & TYMED_HGLOBAL) ? S_OK : DV_E_TYMED;
    }
    else if (pfmtetc->cfFormat == g_cfFileContents)
    {
        if (pfmtetc->dwAspect == DVASPECT_COPY)
            hr = (pfmtetc->tymed & TYMED_ISTREAM) ? S_OK : DV_E_TYMED;
        else if ((pfmtetc->dwAspect == DVASPECT_CONTENT) ||
                 (pfmtetc->dwAspect == DVASPECT_LINK))
            hr = (pfmtetc->tymed & TYMED_HGLOBAL) ? S_OK : DV_E_TYMED;
        else
            hr = DV_E_FORMATETC;
    }
    else
        hr = DV_E_FORMATETC;

    return hr;
}

STDMETHODIMP Intshcut::GetCanonicalFormatEtc(FORMATETC *pfmtetcIn, FORMATETC *pfmtetcOut)
{
    HRESULT hr = QueryGetData(pfmtetcIn);
    if (hr == S_OK)
    {
        *pfmtetcOut = *pfmtetcIn;

        if (pfmtetcIn->ptd == NULL)
            hr = DATA_S_SAMEFORMATETC;
        else
        {
            pfmtetcIn->ptd = NULL;
            ASSERT(hr == S_OK);
        }
    }
    else
        ZeroMemory(pfmtetcOut, SIZEOF(*pfmtetcOut));

    return hr;
}

STDMETHODIMP Intshcut::SetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed, BOOL bRelease)
{
    return DV_E_FORMATETC;
}

STDMETHODIMP Intshcut::EnumFormatEtc(DWORD dwDirFlags, IEnumFORMATETC **ppiefe)
{
    if (dwDirFlags == DATADIR_GET)
    {
        FORMATETC rgfmtetc[] =
        {
            // the order here defines the accuarcy of rendering
            { g_cfFileContents, NULL, DVASPECT_LINK,  0, TYMED_HGLOBAL },
            { g_cfFileDescW,    NULL, DVASPECT_LINK, -1, TYMED_HGLOBAL },
            { g_cfFileDescA,    NULL, DVASPECT_LINK, -1, TYMED_HGLOBAL },
            { g_cfFileContents, NULL, DVASPECT_COPY,  0, TYMED_ISTREAM },
            { g_cfFileDescW,    NULL, DVASPECT_COPY, -1, TYMED_HGLOBAL },
            { g_cfFileDescA,    NULL, DVASPECT_COPY, -1, TYMED_HGLOBAL },
            { g_cfFileContents, NULL, DVASPECT_CONTENT,  0, TYMED_HGLOBAL },
            { g_cfFileDescW,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { g_cfFileDescA,    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { g_cfURLW,         NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { CF_UNICODETEXT,   NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { g_cfURL,          NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
            { CF_TEXT,          NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL },
        };
        return SHCreateStdEnumFmtEtc(ARRAYSIZE(rgfmtetc), rgfmtetc, ppiefe);
    }
    *ppiefe = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP Intshcut::DAdvise(FORMATETC *pfmtetc, DWORD dwAdviseFlags, IAdviseSink *piadvsink, DWORD *pdwConnection)
{
    *pdwConnection = 0;
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP Intshcut::DUnadvise( DWORD dwConnection)
{
    return OLE_E_ADVISENOTSUPPORTED;
}

STDMETHODIMP Intshcut::EnumDAdvise(IEnumSTATDATA **ppiesd)
{
    *ppiesd = NULL;
    return OLE_E_ADVISENOTSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\isbase.cpp ===
/*
 * isbase.cpp - IUnknown implementation for Intshcut class.
 */

#include "priv.h"
#include "sccls.h"
#include "ishcut.h"

HRESULT IsProtocolRegistered(LPCTSTR pcszProtocol)
{
    HRESULT hres = S_OK;

    ASSERT(IS_VALID_STRING_PTR(pcszProtocol, -1));

    if (NO_ERROR != SHGetValue(HKEY_CLASSES_ROOT, pcszProtocol, TEXT("URL Protocol"),
                               NULL, NULL, NULL))
    {
        TraceMsg(TF_ERROR, "IsProtocolRegistered(): Protocol \"%s\" is not registered.",
                 pcszProtocol);

        hres = URL_E_UNREGISTERED_PROTOCOL;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Takes the given URL and returns an allocated string
         containing the protocol.  Also optionally returns the
         parsed-url structure.

Returns: S_OK if the URL was parsed
Cond:    --
*/
STDAPI
CopyURLProtocol(
    IN  LPCTSTR     pcszURL,
    OUT LPTSTR *    ppszProtocol,
    OUT PARSEDURL * ppu)            OPTIONAL
{
    HRESULT hr;
    PARSEDURL pu;

    ASSERT(IS_VALID_STRING_PTR(pcszURL, -1));
    ASSERT(IS_VALID_WRITE_PTR(ppszProtocol, PTSTR));

    if (NULL == ppu)
        ppu = &pu;

    *ppszProtocol = NULL;

    ppu->cbSize = SIZEOF(*ppu);
    hr = ParseURL(pcszURL, ppu);

    if (hr == S_OK)
    {
        *ppszProtocol = (LPTSTR)LocalAlloc(LPTR, CbFromCch(ppu->cchProtocol + 1));
        if (*ppszProtocol)
        {
            // Just copy the protocol portion of string
            StrCpyN(*ppszProtocol, ppu->pszProtocol, ppu->cchProtocol + 1);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    ASSERT(FAILED(hr) ||
           (hr == S_OK &&
            IS_VALID_STRING_PTR(*ppszProtocol, -1)));

    return(hr);
}


HRESULT ValidateURL(LPCTSTR pcszURL)
{
    HRESULT hr;
    LPTSTR pszProtocol;

    ASSERT(IS_VALID_STRING_PTR(pcszURL, -1));

    hr = CopyURLProtocol(pcszURL, &pszProtocol, NULL);

    if (hr == S_OK)
    {
        hr = IsProtocolRegistered(pszProtocol);

        LocalFree(pszProtocol);
        pszProtocol = NULL;
    }

    return(hr);
}

#define SUBS_DEL_TIMEOUT 3000

void DeleteSubsOnShortcutDelete(void *pData, BOOLEAN)
{
    IS_SUBS_DEL_DATA *pSubsDelData = (IS_SUBS_DEL_DATA *)pData;
    ASSERT(NULL != pData);
    ASSERT(0 != pSubsDelData->m_szFile[0]);
    ASSERT(0 != pSubsDelData->m_pwszURL[0]);

    if ((((DWORD)-1) == GetFileAttributes(pSubsDelData->m_szFile)) &&
        (ERROR_FILE_NOT_FOUND == GetLastError()))
    {
        if (SUCCEEDED(CoInitialize(NULL)))
        {
            ISubscriptionMgr2 *pSubsMgr2;

            if (SUCCEEDED(CoCreateInstance(CLSID_SubscriptionMgr,
                                           NULL,
                                           CLSCTX_INPROC_SERVER,
                                           IID_ISubscriptionMgr2,
                                           (void **)&pSubsMgr2)))
            {
                pSubsMgr2->DeleteSubscription(pSubsDelData->m_pwszURL, NULL);
                pSubsMgr2->Release();
            }
            CoUninitialize();
        }
    }
    delete pSubsDelData;
}

#ifdef DEBUG

BOOL IsValidPCIntshcut(PCIntshcut pcintshcut)
{
    return(IS_VALID_READ_PTR(pcintshcut, CIntshcut) &&
           FLAGS_ARE_VALID(pcintshcut->m_dwFlags, ISF_ALL) &&
           (! pcintshcut->m_pszFile ||
            IS_VALID_STRING_PTR(pcintshcut->m_pszFile, -1)) &&
           EVAL(! pcintshcut->m_pszFolder ||
                IsValidPath(pcintshcut->m_pszFolder)) &&
           EVAL(! pcintshcut->m_pprop ||
                IS_VALID_STRUCT_PTR(pcintshcut->m_pprop, CIntshcutProp)) &&
           EVAL(! pcintshcut->m_psiteprop ||
                IS_VALID_STRUCT_PTR(pcintshcut->m_psiteprop, CIntsiteProp)));
}

#endif

Intshcut::Intshcut(void) : m_cRef(1)
{
    DllAddRef();
   // Intshcut objects should always be allocated
   ASSERT(ISF_DEFAULT == m_dwFlags);
   ASSERT(NULL == m_pszFile);
   ASSERT(NULL == m_pszFolder);
   ASSERT(NULL == m_pprop);
   ASSERT(NULL == m_psiteprop);
   ASSERT(NULL == _punkSite);
   ASSERT(NULL == m_pszTempFileName);
   ASSERT(NULL == m_pszDescription);
   ASSERT(NULL == m_pszFileToLoad);
   ASSERT(!m_fMustLoadSync);
   ASSERT(!m_bCheckForDelete);
   // Init our registered data formats
   InitClipboardFormats();

   ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

   return;
}

Intshcut::~Intshcut(void)
{
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    if (m_bCheckForDelete)
    {
        if (NULL != m_pszFile)
        {
            IS_SUBS_DEL_DATA *pSubsDelData = new IS_SUBS_DEL_DATA;

            if (NULL != pSubsDelData)
            {
                HRESULT hr = GetURL(&pSubsDelData->m_pwszURL);

                if (SUCCEEDED(hr))
                {
                    hr = StringCchCopy(pSubsDelData->m_szFile, ARRAYSIZE(pSubsDelData->m_szFile), m_pszFile);
                    if (SUCCEEDED(hr))
                    {
                        HANDLE hTimer = SHSetTimerQueueTimer(NULL,
                                                            DeleteSubsOnShortcutDelete,
                                                            pSubsDelData,
                                                            SUBS_DEL_TIMEOUT,
                                                            0,
                                                            NULL,
                                                            FALSE);
                        if (NULL == hTimer)
                        {
                            hr = E_FAIL;
                        }
                    }
                }

                if (FAILED(hr))
                {
                    delete pSubsDelData;
                }
            }
        }
        else
        {
            ASSERT(FALSE);  //  m_bCheckForDelete only gets set to TRUE in the context menu code
        }
    }

    Str_SetPtr(&m_pszFile, NULL);
    Str_SetPtr(&m_pszFileToLoad, NULL);
    if (m_pprop)
    {
        delete m_pprop;
        m_pprop = NULL;
    }

    if (m_psiteprop)
    {
        delete m_psiteprop;
        m_psiteprop = NULL;
    }

    if (m_pInitDataObject)
    {
        m_pInitDataObject->Release();
        m_pInitDataObject = NULL;
    }

    SetSite(NULL);

    if(m_pszTempFileName)
    {
        DeleteFile(m_pszTempFileName);
        Str_SetPtr(&m_pszTempFileName, NULL);
    }

    Str_SetPtr(&m_pszFolder, NULL);
    Str_SetPtr(&m_pszDescription, NULL);
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    ATOMICRELEASE(_punkLink);
    
    DllRelease();

    return;
}

/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface handler for Intshcut

Returns:
Cond:    --
*/
STDMETHODIMP Intshcut::QueryInterface(REFIID riid, PVOID *ppvObj)
{
    // We try and delay when we load the file specified by IPersistFile::Load
    // until someone asks for an interface that actually needs that file.
    // So put the "safe" interfaces that don't require this in this first
    // table here, and all the "must load" interfaces in the second table:
    //
    static const QITAB qitDontLoad[] = {
        QITABENT(Intshcut, IExtractIconW),      // IID_IExtractIconW
        QITABENT(Intshcut, IExtractIconA),      // IID_IExtractIconA
        QITABENT(Intshcut, IPersistFile),       // IID_IPersistFile
        QITABENTMULTI(Intshcut, IPersist, IPersistFile), // IID_IPersist
        { 0 },
    };

    static const QITAB qitMustLoad[] = {        
        QITABENT(Intshcut, IContextMenu2),      // IID_IContextMenu2
        QITABENTMULTI(Intshcut, IContextMenu, IContextMenu2), // IID_IContextMenu
        QITABENT(Intshcut, IDataObject),        // IID_IDataObject
        QITABENT(Intshcut, INewShortcutHookW),  // IID_INewShortcutHookW
        QITABENT(Intshcut, INewShortcutHookA),  // IID_INewShortcutHookA
        QITABENT(Intshcut, IPersistStream),     // IID_IPersistStream
        QITABENT(Intshcut, IPropertySetStorage),// IID_IPropertySetStorage
        QITABENT(Intshcut, IShellExtInit),      // IID_IShellExtInit
        QITABENT(Intshcut, IShellLinkA),        // IID_IShellLinkA
        QITABENT(Intshcut, IShellLinkW),        // IID_IShellLinkW
        QITABENT(Intshcut, IShellPropSheetExt), // IID_IShellPropSheetExt
        QITABENT(Intshcut, IUniformResourceLocatorA),   // IID_IUniformResourceLocatorA
        QITABENT(Intshcut, IUniformResourceLocatorW),   // IID_IUniformResourceLocatorW
        QITABENT(Intshcut, IQueryInfo),         // IID_IQueryInfo
        QITABENT(Intshcut, IQueryCodePage),     // IID_IQueryCodePage
        QITABENT(Intshcut, INamedPropertyBag),  // IID_INamedPropertyBag
        QITABENT(Intshcut, IObjectWithSite),    // IID_IObjectWithSite
        QITABENT(Intshcut, IOleCommandTarget),  // IID_IOleCommandTarget
        { 0 },
    };

    HRESULT hres = QISearch(this, qitDontLoad, riid, ppvObj);
    if (FAILED(hres))
    {
        hres = QISearch(this, qitMustLoad, riid, ppvObj);
        if (SUCCEEDED(hres))
        {
            m_fMustLoadSync = TRUE;
            if (m_pszFileToLoad)
            {
                LoadFromAsyncFileNow();
            }
        }
    }
    return hres;
}

STDMETHODIMP_(ULONG) Intshcut::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) Intshcut::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP Intshcut::InitProp()
{
    HRESULT hres;

    if (m_pprop)
        hres = S_OK;
    else
    {
        m_pprop = new IntshcutProp;
        if (m_pprop)
        {
            // m_pszFile may be NULL here
            hres = m_pprop->InitFromFile(m_pszFile);
            if (FAILED(hres))
            {
                delete m_pprop;
                m_pprop = NULL;
            }
        }
        else
            hres = E_OUTOFMEMORY;
    }

    return hres;
}

STDMETHODIMP Intshcut::InitSiteProp(void)
{
    HRESULT hres = InitProp();
    if (SUCCEEDED(hres))
    {
        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        hres = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));
        if (NULL == m_psiteprop && SUCCEEDED( hres ))
        {
            m_psiteprop = new IntsiteProp;
            if (m_psiteprop)
            {
                hres = m_psiteprop->InitFromDB(szURL, this, TRUE);
                if (FAILED(hres))
                {
                    delete m_psiteprop;
                    m_psiteprop = NULL;
                }
            }
            else
                hres = E_OUTOFMEMORY;
        }
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Only copy the property if it is different.  Return
         TRUE if it was.

*/
BOOL CopyChangedProperty(IntshcutProp * pprop, PROPID pid,
                         IntsiteProp * psiteprop, PROPID pidSite,
                         BOOL bCopyToDB)
{
    BOOL bRet = FALSE;
    TCHAR szBuf[1024];
    TCHAR szBufSite[1024];

    pprop->GetProp(pid, szBuf, SIZECHARS(szBuf));
    psiteprop->GetProp(pidSite, szBufSite, SIZECHARS(szBufSite));
    StrTrim(szBuf, TEXT(" "));
    StrTrim(szBufSite, TEXT(" "));
    if (StrCmp(szBuf, szBufSite))
    {
        if (bCopyToDB)
            psiteprop->SetProp(pidSite, szBuf);
        else
            pprop->SetProp(pid, szBufSite);
        bRet = TRUE;
    }
    return bRet;
}


/*----------------------------------------------------------
Purpose: Mirror the following properties between FMTID_INTSHCUT
         and FMTID_INTSITE:

            PID_IS_WHATSNEW     <---->  PID_INTSITE_WHATSNEW
            PID_IS_DESCRIPTION  <---->  PID_INTSITE_DESCRIPTION
            PID_IS_AUTHOR       <---->  PID_INTSITE_AUTHOR
            PID_IS_COMMENT      <---->  PID_INTSITE_COMMENT

Returns:
Cond:    --
*/
STDMETHODIMP Intshcut::MirrorProperties(void)
{
    HRESULT hres = InitSiteProp();
    if (SUCCEEDED(hres))
    {
        STATPROPSETSTG statSite;
        STATPROPSETSTG stat;
        LONG lRet;

        // Get the times that the properties were set.  The later
        // time becomes the source.
        m_psiteprop->Stat(&statSite);
        m_pprop->Stat(&stat);

        // Don't do anything if the times are equal

        lRet = CompareFileTime(&stat.mtime, &statSite.mtime);
        if (0 != lRet)
        {
            BOOL bChanged = FALSE;
            BOOL bCopyToDB = (0 < lRet);

            bChanged |= CopyChangedProperty(m_pprop, PID_IS_WHATSNEW, m_psiteprop, PID_INTSITE_WHATSNEW, bCopyToDB);
            bChanged |= CopyChangedProperty(m_pprop, PID_IS_DESCRIPTION, m_psiteprop, PID_INTSITE_DESCRIPTION, bCopyToDB);
            bChanged |= CopyChangedProperty(m_pprop, PID_IS_AUTHOR, m_psiteprop, PID_INTSITE_AUTHOR, bCopyToDB);
            bChanged |= CopyChangedProperty(m_pprop, PID_IS_COMMENT, m_psiteprop, PID_INTSITE_COMMENT, bCopyToDB);

            if (bChanged)
            {
                if (bCopyToDB)
                {
                    m_psiteprop->SetTimes(&stat.mtime, NULL, NULL);
                    m_psiteprop->Commit(STGC_DEFAULT);

                    TraceMsg(TF_INTSHCUT, "Mirroring properties of %s to the central database", Dbg_SafeStr(m_pszFile));
                }
                else
                {
                    m_pprop->SetTimes(&statSite.mtime, NULL, NULL);
                    m_pprop->Commit(STGC_DEFAULT);

                    TraceMsg(TF_INTSHCUT, "Mirroring properties of %s to the .url file", Dbg_SafeStr(m_pszFile));
                }
            }
        }

        hres = S_OK;
    }

    return hres;
}


STDMETHODIMP_(void) Intshcut::ChangeNotify(LONG wEventId, UINT uFlags)
{
    if (m_pszFile)
        SHChangeNotify(wEventId, uFlags | SHCNF_PATH, m_pszFile, 0);
}


STDAPI
CIntShcut_CreateInstance(
    IUnknown * punkOuter,
    IUnknown ** ppunk,
    LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hres = E_OUTOFMEMORY;
    Intshcut *pis = new Intshcut;
    if (pis)
    {
        *ppunk = SAFECAST(pis, IDataObject *);
        hres = S_OK;
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\isexicon.cpp ===
/*
 * isexicon.cpp - IExtractIcon implementation for URL class.
 */


#include "priv.h"
#include "htregmng.h"
#include "ishcut.h"
#include "resource.h"


// We still have to use url.dll as the source of the internet shortcut
// icons because the icons need to still be valid on uninstall.

#ifndef UNIX
#define c_szIntshcutDefaultIcon     TEXT("url.dll")
#else
// IEUNIX(perf) : use unixstyle dll name
#ifdef ux10 
#define c_szIntshcutDefaultIcon     TEXT("liburl.sl")
#else
#define c_szIntshcutDefaultIcon     TEXT("liburl.so")
#endif
#endif

#define IDEFICON_NORMAL             0

#define II_OVERLAY_UPDATED          1

typedef struct
    {
    HIMAGELIST himl;          
    HIMAGELIST himlSm;
    } URLIMAGES;

HRESULT
URLGetLocalFileName(
    LPCTSTR pszURL,
    LPTSTR szLocalFile,
    int cch,
    FILETIME* pftLastMod);


/*----------------------------------------------------------
Purpose: Initializes the images lists used by the URL icon  
         handler.

         There are just two icons placed in each imagelist:
         the given hicon and an overlay for the updated
         asterisk.

Returns: 
Cond:    --
*/
STDMETHODIMP
InitURLImageLists(
    IN URLIMAGES * pui,
    IN HICON       hicon,
    IN HICON       hiconSm)
    {
    HRESULT hres = E_OUTOFMEMORY;

    LoadCommonIcons();
    _InitSysImageLists();

    pui->himl = ImageList_Create(g_cxIcon, g_cyIcon, ILC_MASK, 2, 2);
    
    if (pui->himl)
    {
        pui->himlSm = ImageList_Create(g_cxSmIcon, g_cySmIcon, ILC_MASK, 2, 2);
        
        if ( !pui->himlSm ) 
            ImageList_Destroy(pui->himl);
        else
        {
            ImageList_SetBkColor(pui->himl, GetSysColor(COLOR_WINDOW));
            ImageList_SetBkColor(pui->himlSm, GetSysColor(COLOR_WINDOW));
         
            // Add the given icons
            ImageList_ReplaceIcon(pui->himl, -1, hicon);
            ImageList_ReplaceIcon(pui->himlSm, -1, hiconSm);

            // Add the overlay icon to the list
            ASSERT(IS_VALID_HANDLE(g_hiconSplat, ICON));
            ASSERT(IS_VALID_HANDLE(g_hiconSplatSm, ICON));

            if (g_hiconSplat)
            {
                int iOverlay = ImageList_ReplaceIcon(pui->himl, -1, g_hiconSplat);
                ImageList_ReplaceIcon(pui->himlSm, -1, g_hiconSplatSm);

                ImageList_SetOverlayImage(pui->himl, iOverlay, II_OVERLAY_UPDATED);
                ImageList_SetOverlayImage(pui->himlSm, iOverlay, II_OVERLAY_UPDATED);
            }
            
            hres = S_OK;
        }
    }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Destroys the url image lists

Returns: 
Cond:    --
*/
STDMETHODIMP
DestroyURLImageLists(
    IN URLIMAGES * pui)
{
    if (pui->himl)       
    {
        ImageList_Destroy(pui->himl);
        pui->himl = NULL;
    }

    if (pui->himlSm)       
    {
        ImageList_Destroy(pui->himlSm);
        pui->himlSm = NULL;
    }

    return S_OK;
}



/*----------------------------------------------------------
Purpose: Gets the icon location (filename and index) from the registry
         of the given key.

Returns: 
Cond:    --
*/
HRESULT 
GetURLIcon(
    IN  HKEY    hkey, 
    IN  LPCTSTR pcszKey, 
    IN  LPTSTR  pszIconFile,
    IN  UINT    cchIconFile, 
    OUT PINT    pniIcon)
{
    HRESULT hres = S_FALSE;
    DWORD dwSize = CbFromCch(cchIconFile);

    ASSERT(IS_VALID_HANDLE(hkey, KEY));
    ASSERT(IS_VALID_STRING_PTR(pcszKey, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(pszIconFile, TCHAR, cchIconFile));
    ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));

    if (NO_ERROR == SHGetValue(hkey, pcszKey, NULL, NULL, pszIconFile, &dwSize))
    {
        *pniIcon = PathParseIconLocation(pszIconFile);
        hres = S_OK;
    }

    ASSERT(IsValidIconIndex(hres, pszIconFile, cchIconFile, *pniIcon));

    return hres;
}


/*
** GetFallBackGenericURLIcon()
**
**
**
** Arguments:
**
** Returns:       S_OK if fallback generic icon information retrieved
**                successfully.
**                E_FAIL if not.
**
** Side Effects:  none
*/
HRESULT 
GetFallBackGenericURLIcon(
    LPTSTR pszIconFile,
    UINT cchIconFile,
    PINT pniIcon)
{
    HRESULT hr;

    ASSERT(IS_VALID_WRITE_BUFFER(pszIconFile, TCHAR, cchIconFile));
    ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));

    // Fall back to first icon in this module.

    StringCchCopy(pszIconFile, cchIconFile, c_szIntshcutDefaultIcon);
    *pniIcon = IDEFICON_NORMAL;

    hr = S_OK;

    TraceMsg(TF_INTSHCUT, "GetFallBackGenericURLIcon(): Using generic URL icon file %s, index %d.",
              pszIconFile, *pniIcon);

    ASSERT(IsValidIconIndex(hr, pszIconFile, cchIconFile, *pniIcon));

    return(hr);
}


/*
** GetGenericURLIcon()
**
**
**
** Arguments:
**
** Returns:       S_OK if generic icon information retrieved successfully.
**                Otherwise error.
**
** Side Effects:  none
*/
HRESULT 
GetGenericURLIcon(
    LPTSTR pszIconFile,
    UINT cchIconFile, 
    PINT pniIcon)
{
    HRESULT hr;

    ASSERT(IS_VALID_WRITE_BUFFER(pszIconFile, TCHAR, cchIconFile));
    ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));

    hr = GetURLIcon(HKEY_CLASSES_ROOT, TEXT("InternetShortcut\\DefaultIcon"), pszIconFile,
                    cchIconFile, pniIcon);

    if (hr == S_FALSE)
        hr = GetFallBackGenericURLIcon(pszIconFile, cchIconFile, pniIcon);

    ASSERT(IsValidIconIndex(hr, pszIconFile, cchIconFile, *pniIcon));

    return(hr);
}


/****************************** Public Functions *****************************/


/*----------------------------------------------------------
Purpose: Given a full URL path, this function returns the 
         registry path to the associated protocol (plus the
         subkey path).

         pszBuf must be MAX_PATH.

Returns: 
Cond:    --
*/
HRESULT 
GetURLKey(
    LPCTSTR pcszURL, 
    LPCTSTR pszSubKey, 
    LPTSTR  pszBuf,
    int cchBuf)
{
    HRESULT hres;
    PTSTR pszProtocol;

    ASSERT(IS_VALID_STRING_PTR(pcszURL, -1));
    ASSERT(IS_VALID_STRING_PTR(pszSubKey, -1));
    ASSERT(IS_VALID_WRITE_BUFFER(pszBuf, TCHAR, MAX_PATH));

    *pszBuf = '\0';

    hres = CopyURLProtocol(pcszURL, &pszProtocol, NULL);

    if (hres == S_OK)
    {
        if (SUCCEEDED(StringCchCopy(pszBuf, cchBuf, pszProtocol)) &&
            cchBuf >= MAX_PATH)
        {
            PathAppend(pszBuf, pszSubKey);
        }
        else
        {
            pszBuf[0]=0;
        }

        LocalFree(pszProtocol);
        pszProtocol = NULL;
    }

    return hres;
}


/********************************** Methods **********************************/

/*----------------------------------------------------------
Purpose : To help determine if the file to which this shortcut
          is persisted is in the favorites hierarchy
          
Returns : Returns TRUE if this shortcut is in the favorites 
         folder
*/


BOOL Intshcut::_IsInFavoritesFolder()
{
    BOOL fRet = FALSE;

    if(m_pszFile)
    {
        TCHAR szPath[MAX_PATH];
        if(SHGetSpecialFolderPath(NULL, szPath, CSIDL_FAVORITES, TRUE))
        {
            // Is szPath (i.e. the favorites dir) a prefix of the file associated with this
            // shortcut ?
            fRet = PathIsPrefix(szPath, m_pszFile);
        }
    }

    return fRet;
    
}
         
/*----------------------------------------------------------
Purpose: Get the icon location of the given url.

Returns: S_FALSE if the location is default for the type
         S_OK if the location is custom

         The way this extracticon stuff works is very strange and not
         well-documented.  In particular, there are multiple levels of
         name munging going on, and it's not clear how information is
         passed between IExtractIcon::GetIconLocation and
         IExtractIcon::Extract.  (In particular, it seems that we maintain
         state in our object in order to do secret communication between
         the two methods, which is out of spec.  The shell is allowed to
         instantiate you, call GetIconLocation, then destroy you.  Then
         the next day, it can instantiate you and call Extract with the
         result from yesterday's GetIconLocation.)

         I'm not going to try to fix it; I'm just
         pointing it out in case somebody has to go debugging into this
         code and wonders what is going on.

Cond:    --
*/
STDMETHODIMP
Intshcut::GetURLIconLocation(
    IN  UINT    uInFlags,
    IN  LPTSTR  pszBuf,
    IN  UINT    cchBuf,
    OUT int *   pniIcon,
    BOOL fRecentlyChanged,
    OUT PUINT  puOutFlags)
{
    // Call the IShellLink::GetIconLocation method
    HRESULT hres = _GetIconLocationWithURLHelper(pszBuf, cchBuf, pniIcon, NULL, 0, fRecentlyChanged);
    BOOL fNeedQualify = TRUE;
    hres = S_FALSE;
    if (*pszBuf)
    {
        if(puOutFlags && (FALSE == PathFileExists(pszBuf)))
            SetFlag(*puOutFlags, GIL_NOTFILENAME);
    }
    else
    {
        
        if(FALSE == _IsInFavoritesFolder() || (IsIEDefaultBrowserQuick()))
        {
            // This shortcut is not in the favorites folder as far as we know 
            TCHAR szURL[INTERNET_MAX_URL_LENGTH];

            *szURL = 0;

            hres = InitProp();
            if (SUCCEEDED(hres))
                m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));

            if (*szURL)
            {
                TCHAR szT[MAX_PATH];

                hres = E_FAIL;

                // If it's a file:// URL, then default to the icon from
                // the file target.  Must use IExtractIconA in case we're
                // on Win95.
                IExtractIconA *pxi;
                if (_TryLink(IID_IExtractIconA, (void **)&pxi))
                {
                    uInFlags |= GIL_FORSHORTCUT;                        // to help break recursion
                    // S_FALSE means "I don't know what icon to use",
                    // so treat only S_OK as successful icon extraction.
                    if (IExtractIcon_GetIconLocation(pxi, uInFlags, pszBuf, cchBuf, pniIcon, puOutFlags) == S_OK)
                    {
                        hres = S_OK;
                        fNeedQualify = FALSE;
                    }

                    pxi->Release();
                }

                // If couldn't get target icon or not a file:// URL, then
                // go get some default icon based on the URL scheme.
                if (FAILED(hres))
                {
                    // Look up URL icon based on protocol handler.

                    hres = GetURLKey(szURL, TEXT("DefaultIcon"), szT, ARRAYSIZE(szT));

                    if (hres == S_OK)
                    {
                        hres = GetURLIcon(HKEY_CLASSES_ROOT, szT, pszBuf, 
                                          cchBuf, pniIcon);
                    }
                }
            }
        }
        
        if (hres == S_FALSE)
        {
            // Use generic URL icon.

            hres = GetFallBackGenericURLIcon(pszBuf, cchBuf, pniIcon); // Make sure we have the E icon and 
                                                                       // Not any of netscape's icons

            if (hres == S_OK)
                TraceMsg(TF_INTSHCUT, "Intshcut::GetIconLocation(): Using generic URL icon.");
        }

        if (hres == S_OK && fNeedQualify)
        {
            TCHAR szFullPath[MAX_PATH];

            if (PathSearchAndQualify(pszBuf, szFullPath, SIZECHARS(szFullPath)))
            {
                hres = StringCchCopy(pszBuf, cchBuf, szFullPath);
            }
            else
                hres = E_FILE_NOT_FOUND;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Helper function that determines the icon location based
         on the flags property of the internet site property set.

Returns: 
Cond:    --
*/
STDMETHODIMP
Intshcut::GetIconLocationFromFlags(
    IN  UINT   uInFlags,
    OUT LPTSTR pszIconFile,
    IN  UINT   cchIconFile,
    OUT PINT   pniIcon,
    OUT PUINT  puOutFlags,
    IN  DWORD  dwPropFlags)
{
    HRESULT hres = S_FALSE;

    *puOutFlags = 0;

    ClearFlag(m_dwFlags, ISF_SPECIALICON);

    // Normally, the icon is the standard icon that is retrieved.
    // If the url has been updated, though, we want to add the
    // overlay, in which case we return GIL_NOTFILENAME so the
    // Extract method will be called.

    hres = GetURLIconLocation(uInFlags, pszIconFile, cchIconFile, pniIcon,
                                IsFlagSet(dwPropFlags, PIDISF_RECENTLYCHANGED), puOutFlags);
    if (SUCCEEDED(hres))
    {
        // (scotth): we don't support red splats on browser
        //                  only because it requires new SHELL32 APIs.

        // Has this item been updated since last viewed? 
        
        if (IsFlagSet(dwPropFlags, PIDISF_RECENTLYCHANGED) && 
                    (FALSE == (*puOutFlags & GIL_NOTFILENAME)))
        {
            // Yes; cache the item as a non-file so we get the
            // dynamically created icon 
            SetFlag(*puOutFlags, GIL_NOTFILENAME);

            // Add the icon index at the end of the filename, so
            // it will be hashed differently from the filename 
            // instance.
            int iIconFileLen = lstrlen(pszIconFile);
            StringCchPrintf(&pszIconFile[iIconFileLen], cchIconFile - iIconFileLen,
                    TEXT(",%d"), *pniIcon);

            // cdturner
            // this is done for browser only mode to stop the shell hacking the path
            // down to the dll and not calling us
            
            // remove the dot from the string
            LPTSTR pszDot = StrRChr( pszIconFile, NULL, TCHAR('.'));
            if ( pszDot )
            {
                *pszDot = TCHAR('*');  // should be DBCS safe as it is in the lower 7 bits ASCII
            }
            
            SetFlag(m_dwFlags, ISF_SPECIALICON);
        }

    }
    else
    {
        // Init to default values
        *pniIcon = IDEFICON_NORMAL;
        if (cchIconFile > 0)
            StringCchCopy(pszIconFile, cchIconFile, c_szIntshcutDefaultIcon);
    }

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IExtractIcon::GetIconLocation handler for Intshcut

Returns: 
Cond:    --
*/
// This is the real one for the platform...
HRESULT
Intshcut::_GetIconLocation(
    IN  UINT   uInFlags,
    OUT LPWSTR pszIconFile,
    IN  UINT   cchIconFile,
    OUT PINT   pniIcon,
    OUT PUINT  puOutFlags)
{
    HRESULT hres;

    if (uInFlags & (GIL_ASYNC | GIL_FORSHORTCUT))
    {
        hres = GetGenericURLIcon(pszIconFile, cchIconFile, pniIcon);

        if (uInFlags & GIL_ASYNC)
            return ((SUCCEEDED(hres)) ? E_PENDING : hres);
        else
            return hres;
    }

    hres = LoadFromAsyncFileNow();
    if(FAILED(hres))
        return hres;

    hres = S_FALSE;

    // We also use this method to perform the mirroring
    // of the values between the internet shortcut file and
    // the central database.  IExtractIcon is a good interface
    // to do this because it is virtually guaranteed to be 
    // called for a URL.
    MirrorProperties();

    // Init to default values
    *puOutFlags = 0;
    *pniIcon = 0;
    if (cchIconFile > 0)
        *pszIconFile = TEXT('\0');


    DWORD dwVal = 0;

    if (m_psiteprop)
        m_psiteprop->GetProp(PID_INTSITE_FLAGS, &dwVal);

    hres = GetIconLocationFromFlags(uInFlags, pszIconFile, cchIconFile, pniIcon,
                                    puOutFlags, dwVal);


    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return hres;
}

HRESULT Intshcut::_CreateShellLink(LPCTSTR pszPath, IUnknown **ppunk)
{
    IUnknown *punk;
    HRESULT hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&punk);
    
    if (SUCCEEDED(hr))
    {
        if (g_fRunningOnNT)
        {
            IShellLink *psl;
            hr = punk->QueryInterface(IID_IShellLink, (void **)&psl);
            if (SUCCEEDED(hr))
            {
                hr = psl->SetPath(pszPath);
                psl->Release();
            }
        }
        else
        {
            IShellLinkA *psl;
            hr = punk->QueryInterface(IID_IShellLinkA, (void **)&psl);
            if (SUCCEEDED(hr))
            {
                CHAR sz[MAX_PATH];
                SHTCharToAnsi(pszPath, sz, SIZECHARS(sz));
                hr = psl->SetPath(sz);
                psl->Release();
            }
        }

        if (SUCCEEDED(hr))
        {
            *ppunk = punk;
        }
        else
            punk->Release();
    }

    return hr;
}
    
HRESULT
Intshcut::GetIconLocation(
    IN  UINT   uInFlags,
    OUT LPTSTR pszIconFile,
    IN  UINT   cchIconFile,
    OUT PINT   pniIcon,
    OUT PUINT  puOutFlags)
{
    HRESULT hr = E_FAIL;
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszIconFile, TCHAR, cchIconFile));
    ASSERT(IS_VALID_WRITE_PTR(pniIcon, INT));
    ASSERT(IS_VALID_WRITE_PTR(puOutFlags, UINT));

    if (FAILED(hr))
    {
        hr = _GetIconLocation(uInFlags, pszIconFile, cchIconFile, pniIcon, puOutFlags);
    }

    return hr;
}

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\
//
// *** URLGetLocalFileName ***
//
//
// Description:
//
//
// Parameters:
//
//
// Return:
//
//
// Comments:
//
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
URLGetLocalFileName(
    LPCTSTR pszURL,
    LPTSTR szLocalFile,
    int cch,
    FILETIME* pftLastMod
)
{
    ASSERT(pszURL);
    ASSERT(szLocalFile || 0 == cch);

    HRESULT hr = E_FAIL;

    if (pftLastMod)
    {
        pftLastMod->dwLowDateTime  = 0;
        pftLastMod->dwHighDateTime = 0;
    }

    // by using the internal shlwapi function, we avoid loading WININET 
    // unless we really really need it...
    DWORD scheme = GetUrlScheme(pszURL);
    if (scheme != URL_SCHEME_INVALID)
    {
        switch(scheme)
        {
        case URL_SCHEME_HTTP:
        case URL_SCHEME_FTP:
        case URL_SCHEME_GOPHER:
            {
                ULONG cbSize  = MAX_CACHE_ENTRY_INFO_SIZE;

                INTERNET_CACHE_ENTRY_INFO* piceiAlloced = 
                (INTERNET_CACHE_ENTRY_INFO*) new BYTE[cbSize];

                if (piceiAlloced)
                {
                    piceiAlloced->dwStructSize =
                                      sizeof(INTERNET_CACHE_ENTRY_INFO);

                    if (GetUrlCacheEntryInfoEx(pszURL, piceiAlloced,
                                               &cbSize, NULL, NULL,
                                               NULL, 0))
                    {
                        if (SUCCEEDED(StringCchCopy(szLocalFile, cch,
                                    piceiAlloced->lpszLocalFileName)))
                        {
                            if (pftLastMod)
                            {
                                *pftLastMod = piceiAlloced->LastModifiedTime;
                            }

                            hr = S_OK;
                        }
                    }

                    delete [] piceiAlloced;
                }
            }
            break;

        case URL_SCHEME_FILE:
            hr = PathCreateFromUrl(pszURL, szLocalFile, (LPDWORD)&cch, 0);
            break;

        }
    }
    else
    {
        hr = StringCchCopy(szLocalFile, cch, pszURL);
    }

    return hr;
}


BOOL
PretendFileIsICONFileAndLoad(
    IN LPTSTR lpszTempBuf,
    OUT HICON * phiconLarge,
    OUT HICON * phiconSmall,
    IN  UINT    ucIconSize)
{
    WORD wSizeSmall = HIWORD(ucIconSize);
    WORD wSizeLarge = LOWORD(ucIconSize);

    BOOL fRet = FALSE;
    // Pretend that the file is a .ico file and load it

    ASSERT(phiconLarge);
    ASSERT(phiconSmall);
    
    *phiconSmall = (HICON)LoadImage(NULL, lpszTempBuf, IMAGE_ICON, wSizeSmall, wSizeSmall, LR_LOADFROMFILE);
    if(*phiconSmall)
    {
        fRet = TRUE;
        *phiconLarge = (HICON)LoadImage(NULL, lpszTempBuf, IMAGE_ICON, wSizeLarge, wSizeLarge, LR_LOADFROMFILE);
    }
                

    return fRet;
}




BOOL
Intshcut::ExtractIconFromWininetCache(
    IN  LPCTSTR pszIconString,
    IN  UINT    iIcon,
    OUT HICON * phiconLarge,
    OUT HICON * phiconSmall,
    IN  UINT    ucIconSize,
    BOOL *pfFoundUrl,
    DWORD dwPropFlags)
{
    IPropertyStorage *ppropstg = NULL;
    BOOL fRet = FALSE;
    INT iTempIconIndex;
    HRESULT hr;
    BOOL fFoundURL = FALSE;


    ASSERT(pfFoundUrl && (FALSE == *pfFoundUrl));
    ASSERT((lstrlen(pszIconString) + 1)<= MAX_PATH);
    
    TCHAR szTempBuf[MAX_URL_STRING + 1];
    *szTempBuf = TEXT('\0');
    TCHAR szTempIconBuf[MAX_PATH + 1];
    *szTempIconBuf = TEXT('\0');
      
    hr =  _GetIconLocationWithURLHelper(
                    szTempIconBuf, ARRAYSIZE(szTempIconBuf), &iTempIconIndex, 
                    szTempBuf, ARRAYSIZE(szTempBuf), IsFlagSet(dwPropFlags, PIDISF_RECENTLYCHANGED));
    
    if((S_OK == hr) && (*szTempIconBuf))
    {
        if((UINT)iTempIconIndex == iIcon)
        {
            if(0 == StrCmp(szTempIconBuf, pszIconString))
            {
                if(*szTempBuf)
                {
                    BOOL fUsesCache=FALSE;
                    DWORD dwBufSize=0;
                    CoInternetQueryInfo(szTempBuf, QUERY_USES_CACHE, 0,
                                     &fUsesCache, sizeof(fUsesCache), &dwBufSize, 0);

                    if(fUsesCache)
                    {
                        fFoundURL = TRUE;
                    }
                }
            }
        }
    }



    if(fFoundURL)
    {
        // Now szTempBuf has the URL of the ICON
        // now look and see if the shortcut file itself has the icon and if so
        // simply use it  --- TBD 
        
        
        // we need to grovel in the cache and see if we can get
        // it there and then convert it to an icon
        TCHAR szIconFile[MAX_PATH + 1];
        hr = URLGetLocalFileName(szTempBuf, szIconFile, ARRAYSIZE(szIconFile), NULL);

        if(S_OK == hr)
        {

            if(PretendFileIsICONFileAndLoad(szIconFile, phiconLarge, phiconSmall, ucIconSize))
            {
                fRet = TRUE;
            }

            // It's a bitmap, gif or a jpeg          
        }
    }
    

    if(pfFoundUrl)
        *pfFoundUrl = fFoundURL;
    return fRet;
}

/*----------------------------------------------------------
Purpose: IExtractIcon::Extract method for Intshcut

         Extract the icon.  This function really returns an icon
         that is dynamically created, based upon the properties
         of the URL (recently changed, etc).

         Expect that for normal cases, when the icon does not
         need to be munged (an overlay added), the GetIconLocation
         method should suffice.  Otherwise, this method will get
         called.

Returns: 
Cond:    --
*/
// This is the real one for the platform...
HRESULT
Intshcut::_Extract(
    IN  LPCTSTR pszIconFile,
    IN  UINT    iIcon,
    OUT HICON * phiconLarge,
    OUT HICON * phiconSmall,
    IN  UINT    ucIconSize)
{
    HRESULT hres;
    HICON hiconLarge = NULL;
    HICON hiconSmall = NULL;
    TCHAR szPath[MAX_PATH];
    int nIndex;
    BOOL fSpecialUrl = FALSE;
    *phiconLarge = NULL;
    *phiconSmall = NULL;
    DWORD dwPropFlags = 0;

    hres = LoadFromAsyncFileNow();
    if(FAILED(hres))
        return hres;

    hres = S_FALSE;    
    
    InitSiteProp();

    // Get the property Flags
    if (m_psiteprop)
            m_psiteprop->GetProp(PID_INTSITE_FLAGS, &dwPropFlags);
    
    // First check to see if this is a special icon
    // This function returns a usable value for fSpecialUrl even if it returns FALSE
    if(ExtractIconFromWininetCache(pszIconFile, iIcon, &hiconLarge, &hiconSmall, ucIconSize, &fSpecialUrl, dwPropFlags))
    {
        hres = S_OK;
    } 
    else 
    {
        if(TRUE == fSpecialUrl)
        {
            // The extract failed even though this was a special URL
            // we need to revert back to using the default IE icon
            hres = GetGenericURLIcon(szPath, MAX_PATH, (int *)(&iIcon));
            
            if (hres == S_OK)
            {
                fSpecialUrl = FALSE; // It's no longer a special URL
                hres = InitProp();
                if (SUCCEEDED(hres))
                {
                    hres = m_pprop->SetProp(PID_IS_ICONFILE, szPath);
                    if (SUCCEEDED(hres))
                    {
                        hres = m_pprop->SetProp(PID_IS_ICONINDEX, (INT)iIcon);
                    }
                }
            }
            
            if(S_OK != hres)
            {
                ASSERT(0);
                goto DefIcons;
            }
        } 
        else
        {
            StringCchCopy(szPath, ARRAYSIZE(szPath), pszIconFile);
            // The path may be munged.  Get the icon index as appropriate.
            if (IsFlagSet(m_dwFlags, ISF_SPECIALICON) && (!fSpecialUrl) )
            {
                // Get the icon location from the munged path
                iIcon = PathParseIconLocation(szPath);

                // cdturner
                // now replace the '*' with the dot
                // this is done for browser only mode to stop the shell hacking the path
                // down to the dll and not calling us
                LPTSTR pszPlus = StrRChr( szPath, NULL, TCHAR('*'));
                if ( pszPlus )
                {
                    *pszPlus = TCHAR('.');
                }
                
                
            }
        }
        
        
        nIndex = iIcon;

        if(!fSpecialUrl)
        {
            if ( WhichPlatform() == PLATFORM_INTEGRATED )
            {
                // Extract the icons 
                CHAR szTempPath[MAX_PATH + 1];
                SHTCharToAnsi(szPath, szTempPath, ARRAYSIZE(szTempPath));
                hres = SHDefExtractIconA(szTempPath, nIndex, 0, &hiconLarge, &hiconSmall, 
                                        ucIconSize);
            }
            else
            {
                // cdturner
                // use a more hacky solution to support browser only mode..
                _InitSysImageLists();
                
                int iIndex = Shell_GetCachedImageIndex( szPath, nIndex, 0 );
                if ( iIndex > 0 )
                {
                    hiconLarge = ImageList_GetIcon( g_himlSysLarge, iIndex, 0 );
                    hiconSmall = ImageList_GetIcon( g_himlSysSmall, iIndex, 0 );

                    hres = NOERROR;
                }
                else 
                {
                    hiconLarge = hiconSmall = NULL;
                    
                    // it will get the windows icon if it should be gleamed, and 
                    // it will the normal icon otherwsie
                    hres = IsFlagSet(dwPropFlags, PIDISF_RECENTLYCHANGED) ? E_FAIL : S_FALSE;
                    goto DefIcons;
                }
            }
        }
    }

    

    if (SUCCEEDED(hres))
    {
        // Has this URL changed recently? 
        if (IsFlagSet(dwPropFlags, PIDISF_RECENTLYCHANGED))
        {
            // Yes 
            URLIMAGES ui;

            if (SUCCEEDED(InitURLImageLists(&ui, hiconLarge, hiconSmall)))
            {
                *phiconLarge = ImageList_GetIcon(ui.himl, 0, INDEXTOOVERLAYMASK(II_OVERLAY_UPDATED));
                *phiconSmall = ImageList_GetIcon(ui.himlSm, 0, INDEXTOOVERLAYMASK(II_OVERLAY_UPDATED));

                DestroyURLImageLists(&ui);

                // these were created, they are not global handles, so they must be cleanedup.
                DestroyIcon( hiconLarge );
                DestroyIcon( hiconSmall );
            }
            else
                goto DefIcons;
        }
        else
        {
            // No
DefIcons:
            *phiconLarge = hiconLarge;
            *phiconSmall = hiconSmall;
        }
    }

    return hres;
}

STDMETHODIMP
Intshcut::Extract(
    IN  LPCTSTR pszIconFile,
    IN  UINT    iIcon,
    OUT HICON * phiconLarge,
    OUT HICON * phiconSmall,
    IN  UINT    ucIconSize)
{
    if (URL_SCHEME_FILE == GetScheme() && _punkLink)
        return IExtractIcon_Extract(_punkLink, pszIconFile, iIcon, phiconLarge, phiconSmall, ucIconSize);
    else
        return _Extract(pszIconFile, iIcon, phiconLarge, phiconSmall, ucIconSize);
}

// Now handle the
// Unicode or Ansi one for the "Other" platform...

STDMETHODIMP
Intshcut::GetIconLocation(UINT uInFlags, LPSTR pszIconFile, UINT cchIconFile,
        PINT pniIcon, PUINT  puOutFlags)
{
    HRESULT hres;
    WCHAR   wszIconFile[MAX_PATH];

    // IconFile is output so...
    // Note, we will only handle up to MAXPATH
    if (cchIconFile > ARRAYSIZE(wszIconFile))
        cchIconFile = ARRAYSIZE(wszIconFile);

    ASSERT(IS_VALID_WRITE_BUFFER(pszIconFile, TCHAR, cchIconFile));
    hres = GetIconLocation(uInFlags, wszIconFile, cchIconFile, pniIcon, puOutFlags);

    if (cchIconFile > 0 && SUCCEEDED(hres))
    {
        WideCharToMultiByte(CP_ACP, 0, wszIconFile, -1, pszIconFile, cchIconFile, NULL, NULL);
    }
    return hres;
}


STDMETHODIMP Intshcut::Extract(IN  LPCSTR pszIconFile, IN  UINT    iIcon,
    OUT HICON * phiconLarge, OUT HICON * phiconSmall, IN  UINT    ucIconSize)
{
    WCHAR wszIconFile[MAX_PATH];

    // First convert the string...
    MultiByteToWideChar(CP_ACP, 0, pszIconFile, -1, wszIconFile, ARRAYSIZE(wszIconFile));

    return Extract(wszIconFile, iIcon, phiconLarge, phiconSmall, ucIconSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\libx.cpp ===
//***   libx.cpp -- 'source library' inclusions
// DESCRIPTION
//  there are some things that we share in source (rather than .obj or .dll)
// form.  this file builds them in the current directory.

#include "priv.h"

#include "..\inc\uassist.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\iscmdt.cpp ===
#include "priv.h"
#include "ishcut.h"
#include "shlwapi.h"
#include "resource.h"
#include "shlguid.h"

STDMETHODIMP Intshcut::QueryStatus(
    const GUID *pguidCmdGroup,
    ULONG cCmds,
    MSOCMD rgCmds[],
    MSOCMDTEXT *pcmdtext
)
{
    return E_NOTIMPL;
}

struct SHORTCUT_ICON_PARAMS
{
    WCHAR *pwszFileName;
    WCHAR *pwszShortcutUrl;
    BSTR   bstrIconUrl;

    ~SHORTCUT_ICON_PARAMS()
    {
        if(pwszFileName)
        {
            LocalFree(pwszFileName);
            pwszFileName = NULL;
        }

        if(bstrIconUrl)
        {
            SysFreeString(bstrIconUrl);
            bstrIconUrl = NULL;
        }

        if(pwszShortcutUrl)
        {
            SHFree(pwszShortcutUrl);
            pwszShortcutUrl = NULL;
        }
    }
};


const WCHAR wszDefaultShortcutIconName[] = ISHCUT_DEFAULT_FAVICONW;
const WCHAR wszDefaultShortcutIconNameAtRoot[] = ISHCUT_DEFAULT_FAVICONATROOTW;
extern const LARGE_INTEGER c_li0 ;

VOID
GetIconUrlFromLinkTag(
    IHTMLDocument2* pHTMLDocument,
    BSTR *pbstrIconUrl
)
{
    HRESULT hres;
    IHTMLLinkElement *pLink = NULL;
    hres = SearchForElementInHead(pHTMLDocument, OLESTR("REL"), OLESTR("SHORTCUT ICON"), IID_IHTMLLinkElement, (LPUNKNOWN *)&pLink);
    if(S_OK == hres)
    {
        hres = pLink->get_href(pbstrIconUrl);
        pLink->Release();
    }

}


BOOL SetIconForShortcut(
    WCHAR *pwszIconUrl,
    INamedPropertyBag *pNamedBag
)
{
 // Do it synchronously on this thread
    BOOL fRet = FALSE;
    WCHAR wszCacheFileName[MAX_PATH];
    HRESULT hr;

    ASSERT(pNamedBag);

    hr = URLDownloadToCacheFileW(NULL, pwszIconUrl, wszCacheFileName, sizeof(wszCacheFileName), NULL, NULL);
    if(S_OK == hr)
    {
        // 77657 security bug: we must not call LoadImage because the Win9x version can
        // crash with buffer overrun if given a corrupt icon.  ExtractIcon helps validate the file
        // to prevent that specific crash.

        HICON hIcon = ExtractIcon(g_hinst, wszCacheFileName, 0);

        if(hIcon) // It is really an Icon
        {
            // Make this icon sticky in cache
            SetUrlCacheEntryGroupW(pwszIconUrl, INTERNET_CACHE_GROUP_ADD,
                                            CACHEGROUP_ID_BUILTIN_STICKY, NULL, 0, NULL);


            DestroyIcon(hIcon);
            // get the file - set the icon and return
            fRet = TRUE; // We Got the icon file - even if we are unable set it
            // Store this url away in the shortcut file
            PROPSPEC rgpropspec[2];
            PROPVARIANT rgpropvar[2];
            PROPVARIANT var;

            LBSTR::CString          strUrl;

            if ( pwszIconUrl )
            {
                strUrl = pwszIconUrl;
            }
            else
            {
                strUrl.Empty();
            }

            var.vt = VT_BSTR;
            var.bstrVal = strUrl;

            hr = pNamedBag->WritePropertyNPB(ISHCUT_INISTRING_SECTIONW, ISHCUT_INISTRING_ICONFILEW,
                                                &var);

            if ( S_OK == hr )
            {
                LBSTR::CString          strIndex;

                strIndex = L"1";

                var.vt = VT_BSTR;
                var.bstrVal = strIndex;

                hr = pNamedBag->WritePropertyNPB(ISHCUT_INISTRING_SECTIONW, ISHCUT_INISTRING_ICONINDEXW,
                                                &var);
            }


            // Update the intsite database - whether or not the
            // shortcut file was updated. This is because we need to
            // ensure that the intsite db is updated even if the shortcut file name is not known

            IPropertySetStorage *ppropsetstg;
            IPropertyStorage *ppropstg;

            rgpropspec[0].ulKind = PRSPEC_PROPID;
            rgpropspec[0].propid = PID_INTSITE_ICONINDEX;
            rgpropspec[1].ulKind = PRSPEC_PROPID;
            rgpropspec[1].propid = PID_INTSITE_ICONFILE;




            rgpropvar[0].vt = VT_I4;
            rgpropvar[0].lVal = 1;
            rgpropvar[1].vt = VT_LPWSTR;
            rgpropvar[1].pwszVal = pwszIconUrl;



            hr = pNamedBag->QueryInterface(IID_IPropertySetStorage,(LPVOID *)&ppropsetstg);


            if(SUCCEEDED(hr))
            {
                hr = ppropsetstg->Open(FMTID_InternetSite, STGM_READWRITE, &ppropstg);
                ppropsetstg->Release();
            }

            if(SUCCEEDED(hr))
            {
                hr = ppropstg->WriteMultiple(2, rgpropspec, rgpropvar, 0);
                ppropstg->Commit(STGC_DEFAULT);
                ppropstg->Release();
            }
       }
    }

    return fRet;
}

HRESULT PreUpdateShortcutIcon(IUniformResourceLocatorW *purlW, LPTSTR pszHashItem, int* piIndex,
                              UINT* puFlags, int* piImageIndex, LPWSTR *ppwszURL)
{
    ASSERT(pszHashItem);
    ASSERT(piIndex);
    ASSERT(puFlags);
    ASSERT(piImageIndex);
    
    HRESULT hr;

    ASSERT(purlW);

    if(purlW)
    {
        hr = purlW->GetURL(ppwszURL);

        if(S_OK == hr)
        {
            hr = GetGenericURLIcon(pszHashItem, MAX_PATH, piIndex);

            if (SUCCEEDED(hr))
            {
                SHFILEINFO fi = {0};

                if (SHGetFileInfo(pszHashItem, 0, &fi, sizeof(SHFILEINFO),
                                  SHGFI_SYSICONINDEX))
                {
                    *piImageIndex = fi.iIcon;
                }
                else
                {
                    *piImageIndex = -1;
                }
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


DWORD
DownloadAndSetIconForShortCutThreadProc(
    LPVOID pIn
)
{
    HINSTANCE hShdocvw = LoadLibrary(TEXT("shdocvw.dll"));
    SHORTCUT_ICON_PARAMS *pParams = (SHORTCUT_ICON_PARAMS *)pIn;
    WCHAR *pwszShortcutFilePath = pParams->pwszFileName;
    WCHAR *pwszIconUrl = pParams->bstrIconUrl;
    WCHAR wszFullUrl[MAX_URL_STRING];
    LPWSTR pwszBaseUrl = NULL;
    DWORD cchFullUrlSize = ARRAYSIZE(wszFullUrl);
    TCHAR  szHash[MAX_PATH];
    IPersistFile *   ppf = NULL;
    BOOL fRet = FALSE;
    INT iImageIndex;
    INT iIconIndex;
    UINT uFlags = 0;
    HRESULT hr;
    IUniformResourceLocatorW *purlW = NULL;
    HRESULT hresCoInit = E_FAIL;

    hresCoInit = CoInitialize(NULL);
    ASSERT(hShdocvw);
    hr = CoCreateInstance(CLSID_InternetShortcut, NULL,
                CLSCTX_INPROC_SERVER,
                IID_IUniformResourceLocatorW, (LPVOID *)&purlW);

    ASSERT(purlW);
    if((S_OK == hr) && purlW)
    {

        if(S_OK == hr)
        {
            if(pwszShortcutFilePath)
            {
                hr = purlW->QueryInterface(IID_IPersistFile, (LPVOID*)&ppf);
                if(S_OK == hr)
                {
                    ASSERT(ppf);
                    hr = ppf->Load(pwszShortcutFilePath, STGM_READWRITE);
                }
            }
            else if(pParams->pwszShortcutUrl)
            {
                // Use the URL to init the shortcut
                hr = purlW->SetURL(pParams->pwszShortcutUrl, IURL_SETURL_FL_GUESS_PROTOCOL);
            }
            else
            {
                hr = E_FAIL;
                // Can't create an object and init it
            }
        }
    }



    if((S_OK == hr) && (purlW))
    {
        hr = PreUpdateShortcutIcon(purlW, szHash, &iIconIndex, &uFlags, &iImageIndex, (LPWSTR *)&pwszBaseUrl);

        INamedPropertyBag   *pNamedBag = NULL;
        hr = purlW->QueryInterface(IID_INamedPropertyBag,(LPVOID *)&pNamedBag);
        if((S_OK == hr) && (pNamedBag))
        {
            if(pwszIconUrl)
            {
                WCHAR *pwszIconFullUrl;
                if(pwszBaseUrl)
                {
                    hr = UrlCombineW(pwszBaseUrl, pwszIconUrl, wszFullUrl, &cchFullUrlSize, 0);
                    ASSERT(S_OK == hr);
                    if(SUCCEEDED(hr))
                    {
                        pwszIconFullUrl = wszFullUrl;
                    }
                 }
                 else
                 {
                    pwszIconFullUrl = pwszIconUrl; // try it as it is
                 }
                 fRet = SetIconForShortcut( pwszIconFullUrl, pNamedBag);

            }

            if((FALSE == fRet) && (pwszBaseUrl))
            {
                 
                hr = UrlCombineW(pwszBaseUrl, wszDefaultShortcutIconNameAtRoot, wszFullUrl, &cchFullUrlSize, 0);
                fRet = SetIconForShortcut(wszFullUrl, pNamedBag);
            }

            pNamedBag->Release();
        }
    }



    if(fRet)
    {
        SHUpdateImage(szHash, iIconIndex, uFlags, iImageIndex);
    }

    if(ppf)
    {
        ppf->Save(NULL, FALSE); // Save off Icon related stuff
        ppf->Release();
    }

    if(purlW)
        purlW->Release();

    if(pParams)
        delete pParams;

    if(pwszBaseUrl)
        SHFree(pwszBaseUrl);

    if(SUCCEEDED(hresCoInit))
        CoUninitialize();


    //FreeLibraryAndExitThread(hShdocvw); -- Need a FreeLibraryAndExitThread for thread pools
    return fRet;
}






STDMETHODIMP Intshcut::_DoIconDownload()
{
    SHORTCUT_ICON_PARAMS *pIconParams;
    BOOL fThreadStarted = FALSE;
    HRESULT hr = S_OK;


    pIconParams = new SHORTCUT_ICON_PARAMS;
    if(pIconParams)
    {
        if(_punkSite)
        {
            IServiceProvider *psp;
            hr = _punkSite->QueryInterface(IID_IServiceProvider, (LPVOID *)&psp);

            if(SUCCEEDED(hr))
            {
                IWebBrowser2 *pwb=NULL;

                hr = psp->QueryService(SID_SHlinkFrame, IID_IWebBrowser2, (LPVOID *)&pwb);
                if(SUCCEEDED(hr))
                {
                    IDispatch *pdisp = NULL;
                    ASSERT(pwb);
                    hr = pwb->get_Document(&pdisp);
                    if(pdisp)
                    {
                        IHTMLDocument2 *pHTMLDocument;
                        ASSERT(SUCCEEDED(hr));
                        hr = pdisp->QueryInterface(IID_IHTMLDocument2, (void **)(&pHTMLDocument));
                        if(SUCCEEDED(hr))
                        {
                            ASSERT(pHTMLDocument);
                            GetIconUrlFromLinkTag(pHTMLDocument, &(pIconParams->bstrIconUrl));
                            pHTMLDocument->Release();
                        }
                        pdisp->Release();
                    }
                    pwb->Release();
                }
                psp->Release();
            }

        }


        if(m_pszFile)
        {
            pIconParams->pwszFileName = StrDupW(m_pszFile);

        }

        // Now fill in the URL of the shortcut
        hr = GetURLW(&(pIconParams->pwszShortcutUrl));

        ASSERT(SUCCEEDED(hr));
        if(S_OK == hr)
        {
            fThreadStarted = SHQueueUserWorkItem(DownloadAndSetIconForShortCutThreadProc,
                                                 (LPVOID)(pIconParams),
                                                 0,
                                                 (DWORD_PTR)NULL,
                                                 (DWORD_PTR *)NULL,
                                                 "shdocvw.dll",
                                                 0
                                                 );
        }


    }

    if(FALSE == fThreadStarted)
    {
        if(pIconParams)
        {
            delete pIconParams;
        }
    }

    return fThreadStarted ? S_OK : E_FAIL;
}



STDMETHODIMP Intshcut::Exec(
    const GUID *pguidCmdGroup,
    DWORD nCmdID,
    DWORD nCmdexecopt,
    VARIANTARG *pvarargIn,
    VARIANTARG *pvarargOut
)
{

    HRESULT hres = S_OK;

    if (pguidCmdGroup && IsEqualGUID(CGID_ShortCut, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
            case ISHCUTCMDID_DOWNLOADICON:
            {
                DWORD dwFlags = 0;
                BOOL fFetch = TRUE;
                WCHAR *pwszUrl;
                // Don't do it for FTP shortcuts

                if(SUCCEEDED(GetURLW(&pwszUrl))) 
                {
                    if((URL_SCHEME_FTP == GetUrlSchemeW(pwszUrl)))
                        fFetch = FALSE;
                    SHFree(pwszUrl);
                }
                
                if(fFetch && (InternetGetConnectedState(&dwFlags, 0)))
                    hres = _DoIconDownload();
            }
                break;

            default:
                break;

        }
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\ishcut.h ===
/*
 * ishcut.h - Internet Shortcut class implementation description.
 */

#ifndef _INTSHCUT_HPP_
#define _INTSHCUT_HPP_

#include "urlprop.h"
#include "subsmgr.h"
#include "cowsite.h"
//
// Define this to enable the integrated history database
//
#define USE_NEW_HISTORYDATA

#ifdef __cplusplus

/* Types
 ********/

// Intshcut flags

#define ISF_DEFAULT             0x00000000
#define ISF_DIRTY               0x00000001      // URL is dirty
#define ISF_DESKTOP             0x00000002      // Located on the desktop
#define ISF_FAVORITES           0x00000004      // Located in favorites folder
#define ISF_WATCH               0x00000008      // Scratch flag for context menu
#define ISF_SPECIALICON         0x00000010      // Icon is munged for splat
#define ISF_CODEPAGE            0x00000020      // Code page is set
#define ISF_ALL                 0x0000003F


// Intshcut Shell extension

class Intshcut : public IDataObject,
                 public IContextMenu2,
                 public IExtractIconA,
                 public IExtractIconW,
                 public IPersistFile,
                 public IPersistStream,
                 public IShellExtInit,
                 public IShellLinkA,
                 public IShellLinkW,
                 public IShellPropSheetExt,
                 public IPropertySetStorage,
                 public INewShortcutHookA,
                 public INewShortcutHookW,
                 public IUniformResourceLocatorA,
                 public IUniformResourceLocatorW,
                 public IQueryInfo,
                 public IQueryCodePage,
                 public CObjectWithSite, 
                 public INamedPropertyBag,
                 public IOleCommandTarget
{


private:

    LONG        m_cRef;
    DWORD       m_dwFlags;              // ISF_* flags
    LPTSTR      m_pszFile;              // Name of internet shortcut
    LPTSTR      m_pszFileToLoad ;        // Name of Internet Shortcut that was 
    IntshcutProp *m_pprop;              // Internal properties
    IntsiteProp  *m_psiteprop;          // Internet Site properties
    LPTSTR      m_pszFolder;            // Used by INewShortcutHook
    UINT        m_uiCodePage;           // Used by IQueryCodePage -- sendmail.dll for send current document
    BOOL        m_bCheckForDelete;      // Used to see if we need to delete a subscription if the
                                        // shortcut is deleted.
    BOOL        m_fMustLoadSync;        // Set to TRUE if any interface other than IPersistFile or
                                        // IExtractIconW/A are given out
    BOOL        m_fProbablyDefCM;       // this shortcut was most likely init'd by defcm
    
    IDataObject *m_pInitDataObject;
    LPTSTR      m_pszTempFileName;      // temporary file to be deleted when ishcut goes away
    LPTSTR      m_pszDescription;
    IUnknown   *_punkLink;                   //  for file: URLs

    STDMETHODIMP InitProp(void);
    STDMETHODIMP InitSiteProp(void);
    STDMETHODIMP OnReadOffline(void);
    STDMETHODIMP OnWatch(void);
    STDMETHODIMP MirrorProperties(void);

    // data transfer methods

    STDMETHODIMP_(DWORD) GetFileContentsAndSize(LPSTR *ppsz);
    STDMETHODIMP TransferUniformResourceLocator(FORMATETC *pfmtetc, STGMEDIUM *pstgmed);
    STDMETHODIMP TransferText(FORMATETC *pfmtetc, STGMEDIUM *pstgmed);
    STDMETHODIMP TransferFileGroupDescriptorA(FORMATETC *pfmtetc, STGMEDIUM *pstgmed);
    STDMETHODIMP TransferFileGroupDescriptorW(FORMATETC *pfmtetc, STGMEDIUM *pstgmed);
    STDMETHODIMP TransferFileContents(FORMATETC *pfmtetc, STGMEDIUM *pstgmed);
    STDMETHODIMP GetDocumentStream(IStream **ppstm);
    STDMETHODIMP GetDocumentName(LPTSTR pszName);

    HRESULT _Extract(LPCTSTR pszIconFile, UINT iIcon, HICON * phiconLarge, HICON * phiconSmall, UINT ucIconSize);
    HRESULT _GetIconLocation(UINT uFlags, LPWSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);

    ~Intshcut(void);    // Prevent this class from being allocated on the stack or it will fault.

public:
    Intshcut(void);

    // IDataObject methods

    STDMETHODIMP GetData(FORMATETC *pfmtetcIn, STGMEDIUM *pstgmed);
    STDMETHODIMP GetDataHere(FORMATETC *pfmtetc, STGMEDIUM *pstgpmed);
    STDMETHODIMP QueryGetData(FORMATETC *pfmtetc);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pfmtetcIn, FORMATETC *pfmtetcOut);
    STDMETHODIMP SetData(FORMATETC *pfmtetc, STGMEDIUM *pstgmed, BOOL bRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC **ppienumFormatEtc);
    STDMETHODIMP DAdvise(FORMATETC *pfmtetc, DWORD dwAdviseFlags, IAdviseSink * piadvsink, PDWORD pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppienumStatData);

    // IExtractIconA methods

    STDMETHODIMP GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);
    STDMETHODIMP Extract(LPCSTR pcszFile, UINT uIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT ucIconSize);

    // IExtractIconW methods

    STDMETHODIMP GetIconLocation(UINT uFlags, LPWSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags);
    STDMETHODIMP Extract(LPCWSTR pcszFile, UINT uIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT ucIconSize);

    // INewShortcutHookA methods

    STDMETHODIMP SetReferent(LPCSTR pcszReferent, HWND hwndParent);
    STDMETHODIMP GetReferent(LPSTR pszReferent, int ncReferentBufLen);
    STDMETHODIMP SetFolder(LPCSTR pcszFolder);
    STDMETHODIMP GetFolder(LPSTR pszFolder, int ncFolderBufLen);
    STDMETHODIMP GetName(LPSTR pszName, int ncNameBufLen);
    STDMETHODIMP GetExtension(LPSTR pszExtension, int ncExtensionBufLen);

    // INewShortcutHookW methods

    STDMETHODIMP SetReferent(LPCWSTR pcszReferent, HWND hwndParent);
    STDMETHODIMP GetReferent(LPWSTR pszReferent, int ncReferentBufLen);
    STDMETHODIMP SetFolder(LPCWSTR pcszFolder);
    STDMETHODIMP GetFolder(LPWSTR pszFolder, int ncFolderBufLen);
    STDMETHODIMP GetName(LPWSTR pszName, int ncNameBufLen);
    STDMETHODIMP GetExtension(LPWSTR pszExtension, int ncExtensionBufLen);

    // IPersist methods

    STDMETHODIMP GetClassID(CLSID *pclsid);

    // IPersistFile methods

    STDMETHODIMP IsDirty(void);
    STDMETHODIMP Save(LPCOLESTR pcwszFileName, BOOL bRemember);
    STDMETHODIMP SaveCompleted(LPCOLESTR pcwszFileName);
    STDMETHODIMP Load(LPCOLESTR pcwszFileName, DWORD dwMode);
    STDMETHODIMP GetCurFile(LPOLESTR *ppwszFileName);

    // IPersistStream methods

    STDMETHODIMP Save(IStream * pistr, BOOL bClearDirty);
    STDMETHODIMP Load(IStream * pistr);
    STDMETHODIMP GetSizeMax(PULARGE_INTEGER pcbSize);

    // IShellExtInit methods

    STDMETHODIMP Initialize(LPCITEMIDLIST pcidlFolder, IDataObject * pidobj, HKEY hkeyProgID);

    // IShellLink methods

    STDMETHODIMP SetPath(LPCSTR pcszPath);
    STDMETHODIMP GetPath(LPSTR pszFile, int ncFileBufLen, PWIN32_FIND_DATAA pwfd, DWORD dwFlags);
    STDMETHODIMP SetRelativePath(LPCSTR pcszRelativePath, DWORD dwReserved);
    STDMETHODIMP SetIDList(LPCITEMIDLIST pcidl);
    STDMETHODIMP GetIDList(LPITEMIDLIST *ppidl);
    STDMETHODIMP SetDescription(LPCSTR pcszDescription);
    STDMETHODIMP GetDescription(LPSTR pszDescription, int ncDesciptionBufLen);
    STDMETHODIMP SetArguments(LPCSTR pcszArgs);
    STDMETHODIMP GetArguments(LPSTR pszArgs, int ncArgsBufLen);
    STDMETHODIMP SetWorkingDirectory(LPCSTR pcszWorkingDirectory);
    STDMETHODIMP GetWorkingDirectory(LPSTR pszWorkingDirectory, int ncbLen);
    STDMETHODIMP SetHotkey(WORD wHotkey);
    STDMETHODIMP GetHotkey(PWORD pwHotkey);
    STDMETHODIMP SetShowCmd(int nShowCmd);
    STDMETHODIMP GetShowCmd(PINT pnShowCmd);
    STDMETHODIMP SetIconLocation(LPCSTR pcszIconFile, int niIcon);
    STDMETHODIMP GetIconLocation(LPSTR pszIconFile, int ncbLen, PINT pniIcon);
    STDMETHODIMP Resolve(HWND hwnd, DWORD dwFlags);

    // IShellLinkW functions that change from the A functions...
    STDMETHODIMP SetPath(LPCWSTR pcszPath);
    STDMETHODIMP GetPath(LPWSTR pszFile, int ncFileBufLen, PWIN32_FIND_DATAW pwfd, DWORD dwFlags);
    STDMETHODIMP SetRelativePath(LPCWSTR pcszRelativePath, DWORD dwReserved);
    STDMETHODIMP SetDescription(LPCWSTR pcszDescription);
    STDMETHODIMP GetDescription(LPWSTR pszDescription, int ncDesciptionBufLen);
    STDMETHODIMP SetArguments(LPCWSTR pcszArgs);
    STDMETHODIMP GetArguments(LPWSTR pszArgs, int ncArgsBufLen);
    STDMETHODIMP SetWorkingDirectory(LPCWSTR pcszWorkingDirectory);
    STDMETHODIMP GetWorkingDirectory(LPWSTR pszWorkingDirectory, int ncbLen);
    STDMETHODIMP SetIconLocation(LPCWSTR pcszIconFile, int niIcon);
    STDMETHODIMP GetIconLocation(LPWSTR pszIconFile, int ncbLen, PINT pniIcon);

    // IShellPropSheetExt methods

    STDMETHODIMP AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);
    STDMETHODIMP ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam);

    // IContextMenu methods

    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(IN LPCMINVOKECOMMANDINFO pici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT * puReserved, LPSTR pszName, UINT cchMax);
    STDMETHODIMP HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IUniformResourceLocatorA methods

    STDMETHODIMP SetURL(LPCSTR pcszURL, DWORD dwFlags);
    STDMETHODIMP GetURL(LPSTR *ppszURL);
    STDMETHODIMP InvokeCommand(PURLINVOKECOMMANDINFOA purlici);
    
    // IUniformResourceLocatorW methods

    STDMETHODIMP SetURL(LPCWSTR pcszURL, DWORD dwFlags);
    STDMETHODIMP GetURL(LPWSTR *ppszURL);
    STDMETHODIMP InvokeCommand(PURLINVOKECOMMANDINFOW purlici);
    
    // IPropertySetStorage methods

    STDMETHODIMP Create(REFFMTID fmtid, const CLSID * pclsid, DWORD grfFlags, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Delete(REFFMTID fmtid);
    STDMETHODIMP Enum(IEnumSTATPROPSETSTG** ppenum);

    // IQueryInfo methods

    STDMETHODIMP GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip);
    STDMETHODIMP GetInfoFlags(DWORD *pdwFlags);

    // IOleCommandTarget
    STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
                                ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT *pcmdtext);
    STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
                        
    // IQueryCodePage methods 
    // Purpose: This is a hack to use the URL to store the codepage for
    // send currenct document and pass it to sendmail.dll
    STDMETHODIMP GetCodePage(UINT * puiCodePage);
    STDMETHODIMP SetCodePage(UINT uiCodePage);

    // *** IObjectWithSite methods from CObjectWithSite***
    /*
    virtual STDMETHODIMP SetSite(IUnknown *pUnkSite);        
    virtual STDMETHODIMP GetSite(REFIID riid, void **ppvSite);
    */

    // INamedPropertyBag Methods
    STDMETHODIMP ReadPropertyNPB(/* [in] */ LPCOLESTR pszSectionname, 
                                       /* [in] */ LPCOLESTR pszPropName, 
                                       /* [out] */ PROPVARIANT *pVar);
                            
    STDMETHODIMP WritePropertyNPB(/* [in] */ LPCOLESTR pszSectionname, 
                                        /* [in] */ LPCOLESTR pszPropName, 
                                        /* [in] */ PROPVARIANT  *pVar);


    STDMETHODIMP RemovePropertyNPB (/* [in] */ LPCOLESTR pszBagname,
                                    /* [in] */ LPCOLESTR pszPropName);
    
    // IUnknown methods
    STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // other methods
    
    STDMETHODIMP SaveToFile(LPCTSTR pcszFile, BOOL bRemember);
    STDMETHODIMP LoadFromFile(LPCTSTR pcszFile);
    STDMETHODIMP LoadFromAsyncFileNow();
    STDMETHODIMP GetCurFile(LPTSTR pszFile, UINT ucbLen);
    STDMETHODIMP Dirty(BOOL bDirty);
    STDMETHODIMP GetURLIconLocation(UINT uInFlags, LPTSTR pszBuf, UINT cchBuf, int * pniIcon, BOOL fRecentlyChanged, OUT PUINT  puOutFlags);
    
    STDMETHODIMP GetIconLocationFromFlags(UINT uInFlags, LPTSTR pszIconFile, UINT ucchMax, PINT pniIcon, PUINT puFlags, DWORD dwPropFlags);
    STDMETHODIMP_(void) ChangeNotify(LONG wEventId, UINT uFlags);
    STDMETHODIMP GetIDListInternal(LPITEMIDLIST *ppidl);
    STDMETHODIMP GetURLW(WCHAR **ppszURL);
    BOOL ExtractIconFromWininetCache(IN  LPCTSTR pszIconString, 
                                     IN  UINT iIcon, 
                                     OUT HICON * phiconLarge, 
                                     OUT HICON * phiconSmall, 
                                     IN  UINT ucIconSize,
                                     BOOL *pfFoundUrl,
                                     DWORD dwPropFlags);
    STDMETHODIMP _GetIconLocationWithURLHelper(IN  LPTSTR pszBuf,
                                               IN  int    cchBuf,
                                               OUT PINT   pniIcon,
                                               IN  LPTSTR pszActualUrl,
                                               UINT cchUrlBufSize,
                                               BOOL fRecentlyChanged);

    STDMETHODIMP _DoIconDownload();
    STDMETHODIMP _SaveOffPersistentDataFromSite();
    STDMETHODIMP _CreateTemporaryBackingFile();
    STDMETHODIMP _SetTempFileName(TCHAR *pszTempFileName);
    STDMETHODIMP _ComputeDescription();
    STDMETHODIMP_(BOOL) _IsInFavoritesFolder();
    IDataObject *GetInitDataObject() { ASSERT(m_pInitDataObject); return m_pInitDataObject; }
    STDMETHODIMP_(BOOL)_TryLink(REFIID riid, void **ppvOut);
    STDMETHODIMP _CreateShellLink(LPCTSTR pszPath, IUnknown **ppunk);


    // Query methods

    STDMETHODIMP_(DWORD) GetScheme(void);

#ifdef DEBUG
    STDMETHODIMP_(void) Dump(void);
    friend BOOL IsValidPCIntshcut(const Intshcut *pcintshcut);
#endif
};

typedef Intshcut * PIntshcut;
typedef const Intshcut CIntshcut;
typedef const Intshcut * PCIntshcut;



/* Prototypes
 *************/

// isbase.cpp

HRESULT ValidateURL(LPCTSTR pcszURL);

HRESULT IsProtocolRegistered(LPCTSTR pcszProtocol);

BOOL    AnyMeatW(LPCWSTR pcsz);
BOOL    AnyMeatA(LPCSTR pcsz);
#ifdef UNICODE
#define AnyMeat     AnyMeatW
#else
#define AnyMeat     AnyMeatA
#endif

#define ISHCUT_INISTRING_SECTION      TEXT("InternetShortcut")
#define ISHCUT_INISTRING_SECTIONW         L"InternetShortcut"
#define ISHCUT_INISTRING_URL          TEXT("URL")
#define ISHCUT_INISTRING_WORKINGDIR   TEXT("WorkingDirectory")
#define ISHCUT_INISTRING_WHATSNEW     TEXT("WhatsNew")
#define ISHCUT_INISTRING_AUTHOR       TEXT("Author")
#define ISHCUT_INISTRING_DESC         TEXT("Desc")
#define ISHCUT_INISTRING_COMMENT      TEXT("Comment")
#define ISHCUT_INISTRING_MODIFIED     TEXT("Modified")
#define ISHCUT_INISTRING_ICONINDEX    TEXT("IconIndex")
#define ISHCUT_INISTRING_ICONINDEXW       L"IconIndex"
#define ISHCUT_INISTRING_ICONFILE     TEXT("IconFile")
#define ISHCUT_INISTRING_ICONFILEW         L"IconFile"

#define ISHCUT_DEFAULT_FAVICONW            L"favicon.ico";
#define ISHCUT_DEFAULT_FAVICONATROOTW      L"/favicon.ico";


HRESULT 
GetGenericURLIcon(
    LPTSTR pszIconFile,
    UINT cchIconFile, 
    PINT pniIcon);


struct IS_SUBS_DEL_DATA
{
    TCHAR m_szFile[MAX_PATH];
    LPWSTR m_pwszURL;

    ~IS_SUBS_DEL_DATA()
    {
        if (m_pwszURL)
        {
            SHFree(m_pwszURL);
        }
    }
};

#endif  // __cplusplus


//
// Prototypes for all modules
//

STDAPI  CopyURLProtocol(LPCTSTR pcszURL, LPTSTR * ppszProtocol, PARSEDURL * ppu);

#endif  // _INTSHCUT_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\isnewshk.cpp ===
/*
 * isnewshk.cpp - INewShortcutHook implementation for URL class.
 */


#include "priv.h"
#include "ishcut.h"

#include "resource.h"

#include <mluisupp.h>

#pragma warning(disable:4100) /* "unreferenced formal parameter" warning */

STDMETHODIMP
Intshcut::SetReferent(
    LPCTSTR pcszReferent,
    HWND hwndParent)
{
    HRESULT hr;
    TCHAR szURL[MAX_URL_STRING];

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_STRING_PTR(pcszReferent, -1));
    ASSERT(IS_VALID_HANDLE(hwndParent, WND));

    hr = IURLQualify(pcszReferent, UQF_IGNORE_FILEPATHS | UQF_GUESS_PROTOCOL, szURL, NULL, NULL);
    if (SUCCEEDED(hr))
    {
        hr = ValidateURL(szURL);

        if (hr == S_OK)
            hr = SetURL(szURL, 0);
    }

    if (S_OK != hr)
    {
        ASSERT(FAILED(hr));

        // Massage result
        switch (hr)
        {
            case URL_E_INVALID_SYNTAX:
            case URL_E_UNREGISTERED_PROTOCOL:
                hr = S_FALSE;
                break;

            default:
                break;
        }

        TraceMsg(TF_INTSHCUT, "Intshcut::SetReferent(): Failed to set referent to %s.",
                   pcszReferent);
    }

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return(hr);
}

#pragma warning(default:4100) /* "unreferenced formal parameter" warning */


STDMETHODIMP Intshcut::GetReferent(PTSTR pszReferent, int cchReferent)
{
    HRESULT hr = InitProp();
    if (SUCCEEDED(hr))
    {
        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        hr = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));
        if (S_OK == hr)
        {
            if (lstrlen(szURL) < cchReferent)
            {
                StrCpyN(pszReferent, szURL, cchReferent);
                hr = S_OK;
            }
            else
                hr = E_FAIL;
        }
        else
            hr = S_FALSE;

        if (hr != S_OK)
        {
            if (cchReferent > 0)
                *pszReferent = '\0';
        }
    }
    return hr;
}


STDMETHODIMP Intshcut::SetFolder(LPCTSTR pcszFolder)
{
    HRESULT hr;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(PathIsDirectory(pcszFolder));

    if (Str_SetPtr(&m_pszFolder, pcszFolder))
    {
        hr = S_OK;

        TraceMsg(TF_INTSHCUT, "Intshcut::SetFolder(): Set folder to %s.",
                   m_pszFolder);
    }
    else
        hr = E_OUTOFMEMORY;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return(hr);
}


STDMETHODIMP
Intshcut::GetFolder(
    LPTSTR pszFolder,
    int cchFolder)
{
    HRESULT hr;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszFolder, TCHAR, cchFolder));

    if (m_pszFolder)
    {
        if (lstrlen(m_pszFolder) < cchFolder)
        {
            StrCpyN(pszFolder, m_pszFolder, cchFolder);

            hr = S_OK;

            TraceMsg(TF_INTSHCUT, "Intshcut::GetFolder(): Returning folder %s.",
                     pszFolder);
        }
        else
            hr = E_FAIL;
    }
    else
        hr = S_FALSE;

    if (hr != S_OK)
    {
        if (cchFolder > 0)
            *pszFolder = '\0';
    }

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT((hr == S_OK &&
            IS_VALID_STRING_PTR(pszFolder, -1) &&
            EVAL(lstrlen(pszFolder) < cchFolder)) ||
           ((hr == S_FALSE ||
             hr == E_FAIL) &&
            EVAL(! cchFolder ||
                 ! *pszFolder)));

    return(hr);
}


STDMETHODIMP
Intshcut::GetName(
    LPTSTR pszName,
    int cchBuf)
{
    HRESULT hr = E_FAIL;
    TCHAR rgchShortName[MAX_PATH];

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszName, TCHAR, cchBuf));

    hr = E_FAIL;

    if (MLLoadString(IDS_SHORT_NEW_INTSHCUT, rgchShortName, SIZECHARS(rgchShortName)))
    {
        TCHAR rgchLongName[MAX_PATH];

        if (MLLoadString(IDS_NEW_INTSHCUT, rgchLongName, SIZECHARS(rgchLongName)))
        {
            TCHAR rgchCurDir[MAX_PATH];
            LPCTSTR pcszFolderToUse;

            // Use current directory if m_pszFolder has not been set.

            pcszFolderToUse = m_pszFolder;

            if (! pcszFolderToUse)
            {
                if (GetCurrentDirectory(SIZECHARS(rgchCurDir), rgchCurDir) > 0)
                    pcszFolderToUse = rgchCurDir;
            }

            if (pcszFolderToUse)
            {
                TCHAR rgchUniqueName[MAX_PATH];

                if (PathYetAnotherMakeUniqueName(rgchUniqueName, pcszFolderToUse,
                                                 rgchShortName, rgchLongName))
                {
                    PTSTR pszFileName;
                    PTSTR pszRemoveExt;

                    pszFileName = (PTSTR)PathFindFileName(rgchUniqueName);
                    pszRemoveExt = (PTSTR)PathFindExtension(pszFileName);
                    *pszRemoveExt = '\0';

                    if (lstrlen(pszFileName) < cchBuf)
                    {
                        StrCpyN(pszName, pszFileName, cchBuf);
                        hr = S_OK;
                    }
                }
            }
        }
    }

    if (hr == S_OK)
        TraceMsg(TF_INTSHCUT, "Intshcut::GetName(): Returning %s.", pszName);

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT((hr == S_OK &&
            IS_VALID_STRING_PTR(pszName, -1) &&
            EVAL(lstrlen(pszName) < cchBuf)) ||
           (hr == E_FAIL &&
            (! cchBuf ||
             ! *pszName)));

    return(hr);
}


STDMETHODIMP
Intshcut::GetExtension(
    LPTSTR pszExtension,
    int cchBufMax)
{
    HRESULT hr;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszExtension, TCHAR, cchBufMax));

    if (SIZECHARS(TEXT(".url")) < cchBufMax)
    {
        StrCpyN(pszExtension, TEXT(".url"), cchBufMax);

        hr = S_OK;

        TraceMsg(TF_INTSHCUT, "Intshcut::GetExtension(): Returning extension %s.",
                   pszExtension);
    }
    else
    {
        if (cchBufMax > 0)
            *pszExtension = '\0';

        hr = E_FAIL;
    }

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT((hr == S_OK &&
            IS_VALID_STRING_PTR(pszExtension, -1) &&
            EVAL(lstrlen(pszExtension) < cchBufMax)) ||
           (hr == E_FAIL &&
            EVAL(! cchBufMax ||
                 ! *pszExtension)));

    return(hr);
}


// Ansi versions.  Needed for W9x

STDMETHODIMP
Intshcut::SetReferent(
    LPCSTR pcszReferent,
    HWND hwndParent)
{
    HRESULT hr;

    WCHAR szReferent[MAX_URL_STRING];
    ASSERT(lstrlenA(pcszReferent) + 1 < ARRAYSIZE(szReferent));

    SHAnsiToUnicode(pcszReferent, szReferent, ARRAYSIZE(szReferent));

    hr = SetReferent(szReferent, hwndParent);

    return hr;
}


STDMETHODIMP Intshcut::GetReferent(PSTR pszReferent, int cchReferent)
{
    HRESULT hr;

    WCHAR szReferent[MAX_URL_STRING];

    ASSERT(cchReferent <= ARRAYSIZE(szReferent));

    hr = GetReferent(szReferent, ARRAYSIZE(szReferent));

    if (SUCCEEDED(hr))
        SHUnicodeToAnsi(szReferent, pszReferent, cchReferent);

    return hr;
}


STDMETHODIMP Intshcut::SetFolder(LPCSTR pcszFolder)
{
    HRESULT hr;

    WCHAR szFolder[MAX_PATH];
    ASSERT(lstrlenA(pcszFolder) + 1 < ARRAYSIZE(szFolder))

    SHAnsiToUnicode(pcszFolder, szFolder, ARRAYSIZE(szFolder));

    hr = SetFolder(szFolder);
    
    return(hr);
}


STDMETHODIMP
Intshcut::GetFolder(
    LPSTR pszFolder,
    int cchFolder)
{
    HRESULT hr;

    WCHAR szFolder[MAX_PATH];
    ASSERT(cchFolder <= ARRAYSIZE(szFolder));

    hr = GetFolder(szFolder, ARRAYSIZE(szFolder));

    if (SUCCEEDED(hr))
        SHUnicodeToAnsi(szFolder, pszFolder, cchFolder);

    return hr;
}


STDMETHODIMP
Intshcut::GetName(
    LPSTR pszName,
    int cchBuf)
{
    HRESULT hr;

    WCHAR szName[MAX_PATH];
    ASSERT(cchBuf <= ARRAYSIZE(szName));

    hr = GetName(szName, ARRAYSIZE(szName));

    if (SUCCEEDED(hr))
        SHUnicodeToAnsi(szName, pszName, cchBuf);

    return hr;
}


STDMETHODIMP
Intshcut::GetExtension(
    LPSTR pszExtension,
    int cchBufMax)
{
    HRESULT hr;

    WCHAR szExtension[MAX_PATH];
    ASSERT(cchBufMax<= ARRAYSIZE(szExtension));

    hr = GetExtension(szExtension, ARRAYSIZE(szExtension));

    if (SUCCEEDED(hr))
        SHUnicodeToAnsi(szExtension, pszExtension, cchBufMax);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\ispersis.cpp ===
/*
 * ispersis.cpp - IPersist, IPersistFile, and IPersistStream implementations for
 *               URL class.
 */


#include "priv.h"
#include "ishcut.h"

#include "resource.h"

// Need to flush the file to prevent win95 from barfing after stuff is written in
VOID FlushFile(LPCTSTR pszFile)
{
    if (!g_fRunningOnNT)
    {
        WritePrivateProfileString(NULL, NULL, NULL, pszFile);
    }
}


// save object to file

STDMETHODIMP Intshcut::SaveToFile(LPCTSTR pszFile, BOOL bRemember)
{
    HRESULT hres = InitProp();
    if (SUCCEEDED(hres))
    {
        m_pprop->SetFileName(pszFile);

        hres = m_pprop->Commit(STGC_DEFAULT);

        // Remember file if requested 

        if (SUCCEEDED(hres))
        {
            if (bRemember)
            {
                Dirty(FALSE);

                if ( !Str_SetPtr(&m_pszFile, pszFile) )
                    hres = E_OUTOFMEMORY;

#ifdef DEBUG
                Dump();
#endif
            }
            SHChangeNotify(SHCNE_UPDATEITEM, (SHCNF_PATH | SHCNF_FLUSHNOWAIT), pszFile, NULL);
        }

        if (!bRemember)
            m_pprop->SetFileName(m_pszFile);
    }

    if(pszFile && (S_OK == hres))
        FlushFile(pszFile);
    return hres;
}

STDMETHODIMP Intshcut::LoadFromFile(LPCTSTR pszFile)
{
    HRESULT hres;

    if (Str_SetPtr(&m_pszFile, pszFile))
    {
        hres = InitProp();
#ifdef DEBUG
        Dump();
#endif
    }
    else
    {
        hres = E_OUTOFMEMORY;
    }

    return hres;
}


STDMETHODIMP Intshcut::LoadFromAsyncFileNow()
{
    HRESULT hres = S_OK;
    if (m_pszFileToLoad)
    {
        hres = LoadFromFile(m_pszFileToLoad);
        Str_SetPtr(&m_pszFileToLoad, NULL);
    }    
    return hres;
}

STDMETHODIMP Intshcut::GetCurFile(LPTSTR pszFile, UINT cchLen)
{
    HRESULT hr;

    if (m_pszFile)
    {
        hr = StringCchCopy(pszFile, cchLen, m_pszFile);
    }
    else
        hr = S_FALSE;

    return hr;
}

STDMETHODIMP Intshcut::Dirty(BOOL bDirty)
{
    HRESULT hres;
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    
    if (bDirty)
    {
        if (IsFlagClear(m_dwFlags, ISF_DIRTY))
            TraceMsg(TF_INTSHCUT, "Intshcut now dirty.");
        
        SetFlag(m_dwFlags, ISF_DIRTY);
    }
    else
    {
        if (IsFlagSet(m_dwFlags, ISF_DIRTY))
            TraceMsg(TF_INTSHCUT, "Intshcut now clean.");
        
        ClearFlag(m_dwFlags, ISF_DIRTY);
    }
    
    hres = S_OK;
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    
    return hres;
}

// IPersist::GetClassID method for Intshcut

STDMETHODIMP Intshcut::GetClassID(CLSID *pclsid)
{
    ASSERT(IS_VALID_WRITE_PTR(pclsid, CLSID));

    *pclsid = CLSID_InternetShortcut;
    return S_OK;
}


// IPersistFile::IsDirty handler for Intshcut

STDMETHODIMP Intshcut::IsDirty(void)
{
    HRESULT hres = LoadFromAsyncFileNow();

    if(SUCCEEDED(hres))
    {
        hres = InitProp();
        if (SUCCEEDED(hres))
        {
            if (IsFlagSet(m_dwFlags, ISF_DIRTY) || S_OK == m_pprop->IsDirty())
                hres = S_OK;
            else
                hres = S_FALSE;
        }
    }
    return hres;
}

// Helper function to save off Trident specific stuff 

STDMETHODIMP Intshcut::_SaveOffPersistentDataFromSite()
{
    IOleCommandTarget *pcmdt = NULL;
    HRESULT hr = S_OK;
    if (_punkSite)
    {
        if(S_OK == _CreateTemporaryBackingFile())
        {
            ASSERT(m_pszTempFileName);
            hr = _punkSite->QueryInterface(IID_IOleCommandTarget, (LPVOID *)&pcmdt);
            if((S_OK == hr))
            {
                ASSERT(pcmdt);
                VARIANT varIn = {0};
                varIn.vt = VT_UNKNOWN;
                varIn.punkVal = (LPUNKNOWN)(SAFECAST(this, IUniformResourceLocator *));
                
                // Tell the site to save off it's persistent stuff
                hr = pcmdt->Exec(&CGID_ShortCut, CMDID_INTSHORTCUTCREATE, 0, &varIn, NULL);
                
                pcmdt->Release();
            }
            FlushFile(m_pszTempFileName);
        }
    }
    return hr;
}

// IPersistFile::Save handler for Intshcut

STDMETHODIMP Intshcut::Save(LPCOLESTR pwszFile, BOOL bRemember)
{
    HRESULT hres = LoadFromAsyncFileNow();
    if (SUCCEEDED(hres))
    {
        TCHAR szFile[MAX_PATH];

        if (pwszFile)
            SHUnicodeToTChar(pwszFile, szFile, SIZECHARS(szFile));
        else if (m_pszFile)
            hres = StringCchCopy(szFile, ARRAYSIZE(szFile), m_pszFile);
        else
            hres = E_FAIL;

        if (FAILED(hres))
        {
            return hres;
        }
        
        // Perhaps there is a site which wants to save off stuff ?
        // However, the site may end up calling via intefaces 
        hres = _SaveOffPersistentDataFromSite();

        if ((S_OK == hres) && (m_pszTempFileName) && (StrCmp(m_pszTempFileName, szFile) != 0))
        {
            // Copy contents of the temp file to the destination
            // if they are different files
            EVAL(CopyFile(m_pszTempFileName, szFile, FALSE));
        }

        // Then save off in memory stuff to this file
        hres = SaveToFile(szFile, bRemember);
    }
    return hres;
}

STDMETHODIMP Intshcut::SaveCompleted(LPCOLESTR pwszFile)
{
    return S_OK;
}

// IPersistFile::Load()

STDMETHODIMP Intshcut::Load(LPCOLESTR pwszFile, DWORD dwMode)
{
    HRESULT hres;

    if (m_pszFile || m_pszFileToLoad)
    {
        hres = E_FAIL; // can't ::Load twice
    }
    else
    {
        if (m_fMustLoadSync)
            hres = LoadFromFile(pwszFile);
        else
        {
            if (Str_SetPtr(&m_pszFileToLoad, pwszFile))
                hres = S_OK;
            else
                hres = E_OUTOFMEMORY;
        }
    }
    return hres;
}

// IPersistFile::GetCurFile method for Intshcut

STDMETHODIMP Intshcut::GetCurFile(WCHAR **ppwszFile)
{
    HRESULT hr;
    TCHAR szTempFile[MAX_PATH];

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_PTR(ppwszFile, LPOLESTR));

    hr = LoadFromAsyncFileNow();
    if (FAILED(hr))
        return hr;

    if (m_pszFile)
    {
        hr = StringCchCopy(szTempFile, ARRAYSIZE(szTempFile), m_pszFile);
    }
    else
    {
        hr = StringCchCopy(szTempFile, ARRAYSIZE(szTempFile), TEXT("*.url"));
        if (SUCCEEDED(hr))
        {
            // This code path returns S_FALSE on success
            hr = S_FALSE;
        }
    }

    HRESULT hrTemp = SHStrDup(szTempFile, ppwszFile);
    if (FAILED(hrTemp))
        hr = hrTemp;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return(hr);
}

// IPersistStream::Load method for Intshcut

STDMETHODIMP Intshcut::Load(IStream *pstm)
{
    // to implement this: 
    //      save stream to temp.ini
    //      IPersistFile::Load() from that
    //      delete temp file
    return E_NOTIMPL;
}

// IPersistStream::Save method for Intshcut
STDMETHODIMP Intshcut::Save(IStream *pstm, BOOL bClearDirty)
{
    HRESULT hr = InitProp();
    if (SUCCEEDED(hr))
    {
        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        hr = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));
        if (SUCCEEDED(hr))
        {
            LPSTR pszContents;
            hr = CreateURLFileContents(szURL, &pszContents);
            if (SUCCEEDED(hr)) {
                ASSERT(hr == lstrlenA(pszContents));
                hr = pstm->Write(pszContents, hr + 1, NULL);
                GlobalFree(pszContents);
                pszContents = NULL;
            } else {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    
    return hr;
}

// IPersistStream::GetSizeMax method for Intshcut

STDMETHODIMP Intshcut::GetSizeMax(PULARGE_INTEGER puliSize)
{
    puliSize->LowPart = 0;
    puliSize->HighPart = 0;

    HRESULT hr = InitProp();
    if (SUCCEEDED(hr))
    {
        puliSize->LowPart = GetFileContentsAndSize(NULL);
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP Intshcut::_SetTempFileName(TCHAR *pszTempFileName)
{
    ASSERT(NULL == m_pszTempFileName);
    if (m_pszTempFileName)
        DeleteFile(m_pszTempFileName);
        
    Str_SetPtr(&m_pszTempFileName, pszTempFileName);
    return (m_pszTempFileName ? S_OK : E_OUTOFMEMORY);
}

STDMETHODIMP Intshcut::_CreateTemporaryBackingFile()
{
    HRESULT hres = E_FAIL;

    if (m_pszTempFileName)
        return S_OK;

    TCHAR szTempFileName[MAX_PATH];
    TCHAR szDirectory[MAX_PATH];
    
    DWORD dwRet = GetTempPath(ARRAYSIZE(szDirectory),  szDirectory);

    if ((FALSE == dwRet) || (FALSE == PathFileExists(szDirectory)))
    {
        szDirectory[0] = TEXT('\\');
        szDirectory[1] = TEXT('\0');
        dwRet = TRUE;
    }

    dwRet =  GetTempFileName(szDirectory, TEXT("www"), 0, szTempFileName);
    if (dwRet)
    {
        hres = _SetTempFileName(szTempFileName);
        // Now copy over the current file from which this was loaded and then save off
        // any changes
        if (S_OK == hres)
        {
            if (m_pszFile)
            {
                EVAL(CopyFile(m_pszFile, m_pszTempFileName, FALSE));
                SaveToFile(m_pszTempFileName, FALSE); // this flushes the file
            }
        }
    }

    return hres;
}

// Calculate the size of the contents to be transferred in a block.
STDMETHODIMP_(DWORD) Intshcut::GetFileContentsAndSize(LPSTR *ppszBuf)
{
    DWORD cbSize = 0;    // this is in bytes, not characters
    TCHAR szURL[INTERNET_MAX_URL_LENGTH];
    BOOL fSuccess = FALSE;
    HRESULT hres;
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(m_pprop);

    if (ppszBuf)
        *ppszBuf = NULL;
    
    // Create a temporary backing File here and save off everything that needs to be 
    // saved off there and use that to satisfy this request
    if (S_OK == _CreateTemporaryBackingFile())
    {
        ASSERT(m_pszTempFileName);
        
        WCHAR wszTemp[MAX_PATH];
        SHTCharToUnicode(m_pszTempFileName, wszTemp, ARRAYSIZE(wszTemp));
        
        hres = Save(wszTemp, FALSE); // So our temp file is now up to date
        
        // Just copy the file
        HANDLE hFile = CreateFile(m_pszTempFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD dwTemp = 0;
            cbSize = GetFileSize(hFile, &dwTemp);
            if (ppszBuf)
            {
                if (0xFFFFFFFF != cbSize)
                {
                    ASSERT(0 == dwTemp);
                    *ppszBuf = (LPSTR)LocalAlloc(LPTR, cbSize);
                    if (*ppszBuf)
                    {
                        dwTemp = 0;
                        if(ReadFile(hFile, *ppszBuf, cbSize, &dwTemp, NULL))
                        {
                            ASSERT(cbSize >= dwTemp);
                            fSuccess = TRUE;
                        }
                    }
                }
            }
            else
            {
                fSuccess = TRUE; // Just want the size - not contents
            }
            CloseHandle(hFile);
        }
        
        if (FALSE == fSuccess)
        {
            cbSize = 0;
            if(ppszBuf && (*ppszBuf))
            {
                LocalFree(*ppszBuf);
                *ppszBuf = NULL;
            }
        }
    }
    
    if (FALSE == fSuccess)
    {
        // if you couldn't read the file, then perhaps atleast this will work ?
        HRESULT hr = InitProp();
        if (SUCCEEDED(hr) && SUCCEEDED(m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL))))
        {
            hr = CreateURLFileContents(szURL, ppszBuf);

            // IEUNIX-This function should return the strlen not including the
            // null characters as this causes the shortcut file  having a null
            // character causing a crash in the execution of the link.
            // Fortunately, that's what CreateURLFileContents returns
            
            cbSize = SUCCEEDED(hr) ? hr : 0;
        }
    }
    
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    
    return cbSize;
}

#ifndef WC_NO_BEST_FIT_CHARS
#define WC_NO_BEST_FIT_CHARS      0x00000400
#endif

// transfer the URL data in URL clipboard 
STDMETHODIMP Intshcut::TransferUniformResourceLocator(FORMATETC *pfmtetc, STGMEDIUM *pstgmed)
{
    HRESULT hr;

    ASSERT(pfmtetc->dwAspect == DVASPECT_CONTENT);
    ASSERT(pfmtetc->lindex == -1);

    if (pfmtetc->tymed & TYMED_HGLOBAL)
    {
        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        ASSERT(m_pprop);
        hr = InitProp();
        if (SUCCEEDED(hr))
        {
            hr = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));
            if (SUCCEEDED(hr))
            {
                int cch = lstrlen(szURL) + 1;
                int cb = (cch-1) * 9 + 1; // the biggest result is an utf8 escaped version of the string
                                          // utf8 encoding can blow the size up to 3 times
                                          // escaping can blow each byte up to 3 times
                LPSTR pszURL = (LPSTR)GlobalAlloc(GPTR, cb);
                if (pszURL)
                {
                    if (pfmtetc->cfFormat == CF_UNICODETEXT || pfmtetc->cfFormat == g_cfURLW)
                    {
                        StrCpyN((LPWSTR)pszURL, szURL, cch);
                    }
                    else
                    {
                        BOOL bUsedDefaultChar = FALSE;
                        DWORD dwFlags = 0;
                        if (IsOS(OS_WIN2000ORGREATER) || IsOS(OS_WIN98ORGREATER))
                        {
                            dwFlags |= WC_NO_BEST_FIT_CHARS;
                        }
                        int wcResult = WideCharToMultiByte(CP_ACP,
                                            dwFlags,
                                            szURL,
                                            cch,
                                            pszURL,
                                            cb,
                                            NULL,
                                            &bUsedDefaultChar);
                        if ((0 == wcResult) || bUsedDefaultChar)
                        {
                            // the string is weird and can't be converted back to unicode
                            // we're going to utf8-escaped encode it
                            ConvertToUtf8Escaped(szURL, ARRAYSIZE(szURL));
                            SHUnicodeToAnsi(szURL, pszURL, cb);
                        }                    
                    }
                    pstgmed->tymed = TYMED_HGLOBAL;
                    pstgmed->hGlobal = pszURL;
                }
            }
        }
    }
    else
        hr = DV_E_TYMED;

    return hr;
}

// transfer the URL data in text
STDMETHODIMP Intshcut::TransferText(FORMATETC *pfmtetc, STGMEDIUM *pstgmed)
{
    return TransferUniformResourceLocator(pfmtetc, pstgmed);
}

// assumes the current seek pos in the stream is at the start

BOOL GetStreamMimeAndExt(LPCWSTR pszURL, IStream *pstm, 
                         LPTSTR pszMime, UINT cchMime, LPTSTR pszExt, UINT cchExt)
{
    BYTE buf[256];
    ULONG cbRead;
    pstm->Read(buf, SIZEOF(buf), &cbRead);

    WCHAR *pwszMimeOut;
    if (SUCCEEDED(FindMimeFromData(NULL, pszURL, buf, cbRead, NULL, 0, &pwszMimeOut, 0)))
    {
        TCHAR szMimeTemp[MAX_PATH];

        if (pszMime == NULL)
        {
            pszMime = szMimeTemp;
            cchMime = ARRAYSIZE(szMimeTemp);
        }

        SHUnicodeToTChar(pwszMimeOut, pszMime, cchMime);
        CoTaskMemFree(pwszMimeOut);

        if (pszExt)
            MIME_GetExtension(pszMime, pszExt, cchExt);
    }

    // const LARGE_INTEGER c_li0 = {0, 0};
    pstm->Seek(c_li0, STREAM_SEEK_SET, NULL);

    return TRUE;
}

// pszName is assumed to be MAX_PATH

STDMETHODIMP Intshcut::GetDocumentName(LPTSTR pszName)
{
    GetDescription(pszName, MAX_PATH);
                
    WCHAR *pszURL;
    if (S_OK == GetURLW(&pszURL))
    {
        IStream *pstm;
        if (SUCCEEDED(URLOpenBlockingStreamW(NULL, pszURL, &pstm, 0, NULL)))
        {
            TCHAR szExt[MAX_PATH];
            GetStreamMimeAndExt(pszURL, pstm, NULL, 0, szExt, ARRAYSIZE(szExt));

            PathRenameExtension(pszName, szExt);
            
            pstm->Release();
        }
        SHFree(pszURL);
    }
    return S_OK;
}

// transfer URL data in file-group-descriptor clipboard format.
STDMETHODIMP Intshcut::TransferFileGroupDescriptorA(FORMATETC *pfmtetc, STGMEDIUM *pstgmed)
{
    HRESULT hr;

    if (pfmtetc->dwAspect != DVASPECT_COPY  &&
        pfmtetc->dwAspect != DVASPECT_LINK  &&
        pfmtetc->dwAspect != DVASPECT_CONTENT)
    {
        hr = DV_E_DVASPECT;
    }
    else if (pfmtetc->tymed & TYMED_HGLOBAL)
    {
        FILEGROUPDESCRIPTORA * pfgd = (FILEGROUPDESCRIPTORA *)GlobalAlloc(GPTR, SIZEOF(FILEGROUPDESCRIPTORA));
        if (pfgd)
        {
            FILEDESCRIPTORA * pfd = &(pfgd->fgd[0]);
            TCHAR szTemp[MAX_PATH]; 

            if (pfmtetc->dwAspect == DVASPECT_COPY)
            {
                pfd->dwFlags = FD_FILESIZE;
                GetDocumentName(szTemp);
            }
            else
            {
                pfd->dwFlags = FD_FILESIZE | FD_LINKUI;
                GetDescription(szTemp, ARRAYSIZE(szTemp));
            }
            SHTCharToAnsi(PathFindFileName(szTemp), pfd->cFileName, SIZECHARS(pfd->cFileName));

            pfd->nFileSizeHigh = 0;
            pfd->nFileSizeLow = GetFileContentsAndSize(NULL);

            pfgd->cItems = 1;

            pstgmed->tymed = TYMED_HGLOBAL;
            pstgmed->hGlobal = pfgd;

            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = DV_E_TYMED;

    return hr;
}

// transfer URL data in file-group-descriptor clipboard format.
STDMETHODIMP Intshcut::TransferFileGroupDescriptorW(FORMATETC *pfmtetc, STGMEDIUM *pstgmed)
{
    HRESULT hr;

    if (pfmtetc->dwAspect != DVASPECT_COPY  &&
        pfmtetc->dwAspect != DVASPECT_LINK  &&
        pfmtetc->dwAspect != DVASPECT_CONTENT)
    {
        hr = DV_E_DVASPECT;
    }
    else if (pfmtetc->tymed & TYMED_HGLOBAL)
    {
        FILEGROUPDESCRIPTORW * pfgd = (FILEGROUPDESCRIPTORW *)GlobalAlloc(GPTR, SIZEOF(FILEGROUPDESCRIPTORW));
        if (pfgd)
        {
            FILEDESCRIPTORW * pfd = &(pfgd->fgd[0]);
            TCHAR szTemp[MAX_PATH];
            
            if (pfmtetc->dwAspect == DVASPECT_COPY)
            {
                pfd->dwFlags = FD_FILESIZE;
                GetDocumentName(szTemp);
            }
            else
            {
                pfd->dwFlags = FD_FILESIZE | FD_LINKUI;
                GetDescription(szTemp, ARRAYSIZE(szTemp));
            }

            SHTCharToUnicode(PathFindFileName(szTemp), pfd->cFileName, SIZECHARS(pfd->cFileName));

            pfd->nFileSizeHigh = 0;
            pfd->nFileSizeLow = GetFileContentsAndSize(NULL);

            pfgd->cItems = 1;

            pstgmed->tymed = TYMED_HGLOBAL;
            pstgmed->hGlobal = pfgd;

            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = DV_E_TYMED;

    return hr;
}

#if defined(BIG_ENDIAN) && defined(BYTE_ORDER)
#if BYTE_ORDER != BIG_ENDIAN
#undef BIG_ENDIAN
#endif
#endif

#ifdef BIG_ENDIAN
#define BOM 0xfffe
#else
#define BOM 0xfeff
#endif

STDMETHODIMP Intshcut::GetDocumentStream(IStream **ppstm)
{
    *ppstm = NULL;

    WCHAR *pszURL;
    HRESULT hres = GetURLW(&pszURL);
    if (S_OK == hres)
    {
        IStream *pstm;
        hres = URLOpenBlockingStreamW(NULL, pszURL, &pstm, 0, NULL);
        if (SUCCEEDED(hres))
        {
            TCHAR szMime[80];

            if (GetStreamMimeAndExt(pszURL, pstm, szMime, ARRAYSIZE(szMime), NULL, 0) &&
                StrCmpI(szMime, TEXT("text/html")) == 0)
            {
                IStream *aStreams[2];

                if(m_uiCodePage == 1200)    // Unicode
                {
                    WCHAR wzBaseTag[INTERNET_MAX_URL_LENGTH + 20];

                    wnsprintfW(wzBaseTag, ARRAYSIZE(wzBaseTag), TEXT("%wc<BASE HREF=\"%ws\">\n"), (WCHAR)BOM, pszURL);
                    aStreams[0] = SHCreateMemStream((BYTE *)wzBaseTag, lstrlenW(wzBaseTag) * SIZEOF(wzBaseTag[0]));
                }
                else
                {
                    CHAR szURL[INTERNET_MAX_URL_LENGTH], szBaseTag[INTERNET_MAX_URL_LENGTH + 20];

                    SHUnicodeToAnsi(pszURL, szURL, ARRAYSIZE(szURL));
                    wnsprintfA(szBaseTag, ARRAYSIZE(szBaseTag), "<BASE HREF=\"%s\">\n", szURL);

                    // NOTE: this is an ANSI stream

                    aStreams[0] = SHCreateMemStream((BYTE *)szBaseTag, lstrlenA(szBaseTag) * SIZEOF(szBaseTag[0]));
                }
                if (aStreams[0])
                {
                    aStreams[1] = pstm;
                    hres = SHCreateStreamWrapperCP(aStreams, ARRAYSIZE(aStreams), STGM_READ, m_uiCodePage, ppstm);
                    aStreams[0]->Release();
                }
                else
                    hres = E_OUTOFMEMORY;
                pstm->Release();
            }
            else
                *ppstm = pstm;
        }
        SHFree(pszURL);
    }
    else
        hres = E_FAIL;
    return hres;
}

// transfer URL data in file-contents clipboard format.
STDMETHODIMP Intshcut::TransferFileContents(FORMATETC *pfmtetc, STGMEDIUM *pstgmed)
{
    HRESULT hr;

    if (pfmtetc->lindex != 0)
        return DV_E_LINDEX;

    if ((pfmtetc->dwAspect == DVASPECT_CONTENT ||
         pfmtetc->dwAspect == DVASPECT_LINK) && 
         (pfmtetc->tymed & TYMED_HGLOBAL))
    {
        LPSTR pszFileContents;
        DWORD cbSize = GetFileContentsAndSize(&pszFileContents);
        if (pszFileContents)
        {
            pstgmed->tymed = TYMED_HGLOBAL;
            pstgmed->hGlobal = pszFileContents;
            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else if ((pfmtetc->dwAspect == DVASPECT_COPY) && (pfmtetc->tymed & TYMED_ISTREAM))
    {
        hr = GetDocumentStream(&pstgmed->pstm);
        if (SUCCEEDED(hr))
        {
            pstgmed->tymed = TYMED_ISTREAM;
            hr = S_OK;
        }
    }
    else
        hr = DV_E_TYMED;

    return hr;
}



#ifdef DEBUG

STDMETHODIMP_(void) Intshcut::Dump(void)
{
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

#define INDENT_STRING   "    "

    if (IsFlagSet(g_dwDumpFlags, DF_INTSHCUT))
    {
        TraceMsg(TF_ALWAYS, "%sm_dwFlags = %#08lx",
                   INDENT_STRING,
                   m_dwFlags);
        TraceMsg(TF_ALWAYS, "%sm_pszFile = \"%s\"",
                   INDENT_STRING,
                   Dbg_SafeStr(m_pszFile));

        if (m_pprop)
            m_pprop->Dump();
    }
}

#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\isshlink.cpp ===
/*
 * isshlink.cpp - IShellLink implementation for Intshcut class.
 */



#include "priv.h"
#include "ishcut.h"
#include "resource.h"

#include <mluisupp.h>

/* Types
 ********/

typedef enum isl_getpath_flags
{
    // flag combinations

    ALL_ISL_GETPATH_FLAGS   = (SLGP_SHORTPATH |
                               SLGP_UNCPRIORITY)
}
ISL_GETPATH_FLAGS;

typedef enum isl_resolve_flags
{
    // flag combinations

    ALL_ISL_RESOLVE_FLAGS   = (SLR_NO_UI |
                               SLR_ANY_MATCH |
                               SLR_UPDATE)
}
ISL_RESOLVE_FLAGS;


/********************************** Methods **********************************/


/*----------------------------------------------------------
Purpose: IShellLink::SetPath method for Intshcut

Note:
    1. SetURL clears the internal pidl.

*/
STDMETHODIMP
Intshcut::SetPath(
    LPCTSTR pcszPath)
{
    HRESULT hr;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_STRING_PTR(pcszPath, -1));

    // Treat path as literal URL.

    hr = SetURL(pcszPath, 0);

    return(hr);
}


/*----------------------------------------------------------
Purpose: IShellLink::GetPath handler for Intshcut

*/
STDMETHODIMP
Intshcut::GetPath(
    IN  LPTSTR           pszBuf,        
    IN  int              cchBuf,
    OUT PWIN32_FIND_DATA pwfd,          OPTIONAL
    IN  DWORD            dwFlags)
{
    HRESULT hres = E_FAIL;

    // We make no distinction between raw paths and cooked paths
    dwFlags &= ~SLGP_RAWPATH;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszBuf, TCHAR, cchBuf));
    ASSERT(NULL == pwfd || IS_VALID_WRITE_PTR(pwfd, WIN32_FIND_DATA));
    ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_ISL_GETPATH_FLAGS));

    // Init to default values
    if (pwfd)
        ZeroMemory(pwfd, SIZEOF(*pwfd));

    if (cchBuf > 0)
        *pszBuf = '\0';

    // Ignore dwFlags.

    hres = InitProp();
    if (SUCCEEDED(hres))
        hres = m_pprop->GetProp(PID_IS_URL, pszBuf, cchBuf);
     
    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::SetRelativePath method for Intshcut

*/
STDMETHODIMP Intshcut::SetRelativePath(LPCTSTR pcszRelativePath, DWORD dwReserved)
{
    HRESULT hr;

    // dwReserved may be any value.

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_STRING_PTR(pcszRelativePath, -1));

    hr = E_NOTIMPL;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return(hr);
}


/*----------------------------------------------------------
Purpose: IShellLink::SetIDList method for Intshcut

Note:
    1. SetIDList also does SetPath implicitly to update the path (URL)
        to match the pidl.
    2. SetPath only clears the pidl to NULL, so internally we know
        if we really have a pidl for the shortcut. Although GetIDList
        will generate a pidl from path (URL) if we don't have a pidl.

*/
STDMETHODIMP Intshcut::SetIDList(LPCITEMIDLIST pcidl)
{
    HRESULT hr;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_READ_PTR(pcidl, ITEMIDLIST));

    hr = InitProp();
    if (SUCCEEDED(hr))
    {
        hr = m_pprop->SetIDListProp(pcidl);
        if (SUCCEEDED(hr))
        {
            // if the pidl was set successfully, update the path.
            TCHAR szURL[INTERNET_MAX_URL_LENGTH];
            
            hr = IEGetDisplayName(pcidl, szURL, SHGDN_FORPARSING);
            if (SUCCEEDED(hr))
                m_pprop->SetURLProp(szURL, 0);
        }
    }

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return(hr);
}


/*----------------------------------------------------------
Purpose: Get the original pidl set by SetIDList.

Note:
    1. Do not generate a pidl from path if we don't have a pidl.
    2. Return S_OK if we have a pidl, caller must NOT check for
        SUCCEEDED() return.

*/
STDMETHODIMP Intshcut::GetIDListInternal(LPITEMIDLIST *ppidl)
{
    HRESULT hres = InitProp();
    if (SUCCEEDED(hres))
    {
        IStream *pStream;
        hres = m_pprop->GetProp(PID_IS_IDLIST, &pStream);
        if ((hres == S_OK) && pStream)
        {
            const LARGE_INTEGER li = {0, 0};
            // reset the seek pointer                                           
            hres = pStream->Seek(li, STREAM_SEEK_SET, NULL);
            if (SUCCEEDED(hres))
                hres = ILLoadFromStream(pStream, ppidl);
        
            pStream->Release();
        }
    }
    return hres;
}


    
/*----------------------------------------------------------
Purpose: IShellLink::GetIDList method for Intshcut

Note:
    1. If we don't have a pidl from SetIDList, generate a pidl
        from path.

*/
STDMETHODIMP Intshcut::GetIDList(LPITEMIDLIST *ppidl)
{
    HRESULT hres;
    ASSERT(IS_VALID_WRITE_PTR(ppidl, LPITEMIDLIST));
    
    if (!ppidl)
        return E_INVALIDARG;

    *ppidl = NULL;

    hres = InitProp();
    if (SUCCEEDED(hres))
    {
        // check if it already as a pidl.
        hres = GetIDListInternal(ppidl);
        if (hres != S_OK)
        {
            // it doesn't have a pidl, get the URL and make a pidl.
            TCHAR szURL[INTERNET_MAX_URL_LENGTH];
    
            hres = m_pprop->GetProp(PID_IS_URL, szURL, ARRAYSIZE(szURL));
            if (SUCCEEDED(hres)) 
            {
                hres = IECreateFromPath(szURL, ppidl);
            }
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::SetDescription method for Intshcut

*/
STDMETHODIMP Intshcut::SetDescription(LPCTSTR pcszDescription)
{
    HRESULT hr;
    BOOL bDifferent;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_STRING_PTR(pcszDescription, -1));

    // Set m_pszFile to description.

    bDifferent = (! m_pszDescription ||
                  StrCmp(pcszDescription, m_pszDescription) != 0);

    if (Str_SetPtr(&m_pszDescription, pcszDescription))
    {
        if (bDifferent)
           Dirty(TRUE);

        hr = S_OK;
    }
    else
        hr = E_OUTOFMEMORY;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return(hr);
}

STDMETHODIMP Intshcut::_ComputeDescription()
{
    HRESULT hres;
    BSTR bstrTitle = NULL;

    if (_punkSite)
    {
        // Get the title element
        IWebBrowser *pwb;
        hres = _punkSite->QueryInterface(IID_IWebBrowser, (void **)&pwb);
        if (S_OK == hres)
        {
            IDispatch *pDisp;
            hres = pwb->get_Document(&pDisp);
            if (S_OK == hres)
            {
                IHTMLDocument2 *pDoc;
                hres = pDisp->QueryInterface(IID_IHTMLDocument2, (void **)&pDoc);
                if (S_OK == hres)
                {
                    hres = pDoc->get_title(&bstrTitle);
                    pDoc->Release();
                }
                pDisp->Release();
            }
            pwb->Release();
        }
    }
    
    TCHAR *pszUrl;  // The url for this shortcut
    hres = GetURL(&pszUrl);
    if (S_OK == hres)
    {
        TCHAR  szDescription[MAX_PATH] = TEXT("");

        // We gamble that the URL will always have displayable characters. 
        // This is a bad assumption but if this assumption is violated then
        // there is a good chance that the URL probably cannot even
        // be navigated to
        
        // This description is used as the name of the file verbatim
        // during drag drop - hence it should look like a .url file name

        GetShortcutFileName(pszUrl, bstrTitle, NULL, szDescription, ARRAYSIZE(szDescription));
        //PathYetAnotherMakeUniqueName(szTempFileName, szTempFileName, NULL, NULL);
        PathCleanupSpec(NULL, szDescription);

        // Sometimes PathCleanupSpec can end up simply mangling the description if
        // it cannot properly convert the title to ANSI
        // hence we check that we have a proper description

        
        
        if((0 == *szDescription) || (0 == StrCmp(szDescription,TEXT(".url"))))
        {
            // recompute the description without the title
            GetShortcutFileName(pszUrl, NULL, NULL, szDescription, ARRAYSIZE(szDescription));
            PathCleanupSpec(NULL, szDescription);
        }
        hres = SetDescription(szDescription);
        SHFree(pszUrl);
    }


    SysFreeString(bstrTitle);
        
    return hres;
}

// IShellLink::GetDescription method for Intshcut
STDMETHODIMP Intshcut::GetDescription(LPTSTR pszDescription, int cchBuf)
{
    HRESULT hr;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszDescription, TCHAR, cchBuf));

    // Get description from m_pszDescription.

    if (NULL == m_pszDescription)
    {
        _ComputeDescription();
    }

    if (m_pszDescription)
        StrCpyN(pszDescription, m_pszDescription, cchBuf);
    else if (m_pszFile)
    {
        StrCpyN(pszDescription, m_pszFile, cchBuf);
    }
    else
    {
        // use default shortcut name 
        MLLoadString(IDS_NEW_INTSHCUT, pszDescription, cchBuf);
    }

    hr = S_OK;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(hr == S_OK &&
           (cchBuf <= 0 ||
            (IS_VALID_STRING_PTR(pszDescription, -1) &&
             EVAL(lstrlen(pszDescription) < cchBuf))));

    return(hr);
}


// IShellLink::SetArguments method for Intshcut
STDMETHODIMP Intshcut::SetArguments(LPCTSTR pcszArgs)
{
    return E_NOTIMPL;
}

// IShellLink::GetArguments for Intshcut
STDMETHODIMP Intshcut::GetArguments(LPTSTR pszArgs, int cchBuf)
{
    return E_NOTIMPL;
}


// IShellLink::SetWorkingDirectory handler for Intshcut
STDMETHODIMP Intshcut::SetWorkingDirectory(LPCTSTR pcszWorkingDirectory)
{
    HRESULT hres = S_OK;
    TCHAR rgchNewPath[MAX_PATH];
    BOOL bChanged = FALSE;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(! pcszWorkingDirectory ||
           IS_VALID_STRING_PTR(pcszWorkingDirectory, -1));

    if (! AnyMeat(pcszWorkingDirectory))
        pcszWorkingDirectory = NULL;

    if (pcszWorkingDirectory)
    {
        LPTSTR pszFileName;

        if (GetFullPathName(pcszWorkingDirectory, SIZECHARS(rgchNewPath),
                            rgchNewPath, &pszFileName) > 0)
            pcszWorkingDirectory = rgchNewPath;
        else
            hres = E_PATH_NOT_FOUND;
    }

    if (hres == S_OK)
    {
        TCHAR szDir[MAX_PATH];

        hres = InitProp();
        if (SUCCEEDED(hres))
        {
            hres = m_pprop->GetProp(PID_IS_WORKINGDIR, szDir, SIZECHARS(szDir));

            bChanged = ! ((! pcszWorkingDirectory && S_FALSE == hres) ||
                          (pcszWorkingDirectory && S_OK == hres &&
                           ! StrCmp(pcszWorkingDirectory, szDir)));

            hres = S_OK;
            if (bChanged)
            {
                hres = m_pprop->SetProp(PID_IS_WORKINGDIR, pcszWorkingDirectory);
            }
        }
    }

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::GetWorkingDirectory handler for Intshcut

*/
STDMETHODIMP
Intshcut::GetWorkingDirectory(
    IN LPTSTR pszBuf,
    IN int    cchBuf)
{
    HRESULT hres;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszBuf, TCHAR, cchBuf));

    if (cchBuf > 0)
        *pszBuf = '\0';

    hres = InitProp();
    if (SUCCEEDED(hres))
        hres = m_pprop->GetProp(PID_IS_WORKINGDIR, pszBuf, cchBuf);

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::SetHotkey handler for Intshcut

*/
STDMETHODIMP
Intshcut::SetHotkey(
    IN WORD wHotkey)
{
    HRESULT hres;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));

    hres = InitProp();
    if (SUCCEEDED(hres))
        hres = m_pprop->SetProp(PID_IS_HOTKEY, wHotkey);

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::GetHotkey handler for Intshcut

*/
STDMETHODIMP
Intshcut::GetHotkey(
    PWORD pwHotkey)
{
    HRESULT hres;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_PTR(pwHotkey, WORD));

    hres = InitProp();
    if (SUCCEEDED(hres))
    {
        m_pprop->GetProp(PID_IS_HOTKEY, pwHotkey);
        hres = S_OK;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::SetShowCmd handler for Intshcut

*/
STDMETHODIMP
Intshcut::SetShowCmd(
    IN int nShowCmd)
{
    HRESULT hres;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IsValidShowCmd(nShowCmd));

    hres = InitProp();
    if (SUCCEEDED(hres))
        hres = m_pprop->SetProp(PID_IS_SHOWCMD, nShowCmd);

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::GetShowCmd handler for Intshcut

*/
STDMETHODIMP
Intshcut::GetShowCmd(
    OUT int *pnShowCmd)
{
    HRESULT hres;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_PTR(pnShowCmd, INT));

    hres = InitProp();
    if (SUCCEEDED(hres))
    {
        hres = m_pprop->GetProp(PID_IS_SHOWCMD, pnShowCmd);
        if (S_OK != hres)
            *pnShowCmd = SW_NORMAL;
        hres = S_OK;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellLink::SetIconLocation handler for Intshcut

*/
STDMETHODIMP
Intshcut::SetIconLocation(
    IN LPCTSTR pszFile,
    IN int     niIcon)
{
    HRESULT hres = S_OK;
    BOOL bNewMeat;
    TCHAR szNewPath[MAX_PATH];

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IsValidIconIndex(pszFile ? S_OK : S_FALSE, pszFile, MAX_PATH, niIcon));

    bNewMeat = AnyMeat(pszFile);

    if (bNewMeat)
    {
        if (PathSearchAndQualify(pszFile, szNewPath, SIZECHARS(szNewPath)))
        {
            hres = S_OK;
        }
        else
        {
            hres = E_FILE_NOT_FOUND;
        }
    }

    if (hres == S_OK)
    {
        TCHAR szOldPath[MAX_PATH];
        int niOldIcon;
        UINT uFlags;

        hres = GetIconLocation(0, szOldPath, SIZECHARS(szOldPath), &niOldIcon,
                             &uFlags);

        if (SUCCEEDED(hres))
        {
            BOOL bOldMeat;
            BOOL bChanged = FALSE;

            bOldMeat = AnyMeat(szOldPath);

            ASSERT(! *szOldPath ||
                   bOldMeat);

            bChanged = ((! bOldMeat && bNewMeat) ||
                        (bOldMeat && ! bNewMeat) ||
                        (bOldMeat && bNewMeat &&
                         (StrCmp(szOldPath, szNewPath) != 0 ||
                          niIcon != niOldIcon)));

            hres = S_OK;
            if (bChanged && bNewMeat)
            {
                hres = InitProp();
                if (SUCCEEDED(hres))
                {
                    hres = m_pprop->SetProp(PID_IS_ICONFILE, szNewPath);
                    if (SUCCEEDED(hres))
                        hres = m_pprop->SetProp(PID_IS_ICONINDEX, niIcon);
                }
            }
        }
    }

    return hres;
}

VOID UrlMunge(
    TCHAR *lpszSrc,
    TCHAR *lpszDest,
    UINT   cchDestBufSize,
    BOOL fRecentlyChanged)
{
   TCHAR *lpszTemp = lpszSrc;

   if(fRecentlyChanged)
        cchDestBufSize--; // Save up a character

   while(*lpszTemp != TEXT('\0') && (cchDestBufSize > 1)) // not End of line and save up one char for \0 in munged string
   {
        if(TEXT('/') == *lpszTemp)
        {
            *lpszDest = TEXT('\1');
        }
        else
        {
            *lpszDest = *lpszTemp;
        }
        lpszDest++;
        lpszTemp++;
        cchDestBufSize--;
   }
   if(fRecentlyChanged)
   {
        *lpszDest = TEXT('\2');  
        lpszDest++;
   }
   *lpszDest =  TEXT('\0');
   return;
}


HRESULT HelperForReadIconInfoFromPropStg(
    IN  LPTSTR pszBuf,
    IN  int    cchBuf,
    OUT int *  pniIcon,
    IPropertyStorage *pPropStg,
    PROPSPEC *ppropspec,
    IN  LPTSTR pszActualUrlBuf,
    IN INT cchActualUrlBuf,
    BOOL fRecentlyChanged)
{

    HRESULT hres;
    PROPVARIANT rgpropvar[2];


    ASSERT((0 == pszActualUrlBuf) || (cchActualUrlBuf >= MAX_URL_STRING));

    if(pszActualUrlBuf)
        *pszActualUrlBuf = TEXT('\0');
        
    // Init to default values
    *pniIcon = 0;
    if (cchBuf > 0)
        *pszBuf = TEXT('\0');

    

    hres = pPropStg->ReadMultiple(2, ppropspec, rgpropvar);
    if (SUCCEEDED(hres))
    {
        if (VT_LPWSTR == rgpropvar[1].vt)
        {
            if(FALSE == PathFileExistsW(rgpropvar[1].pwszVal))
            {
                UrlMunge(rgpropvar[1].pwszVal, pszBuf, cchBuf, fRecentlyChanged);  
            }
            else
            {
                // We will just send the icon file and index back with no attempt
                // to hash it or fill out the URL field
                if(lstrlenW(rgpropvar[1].pwszVal) >= cchBuf)
                {
                     // need a larger buf - simply fail it
                    hres = E_FAIL;
                }
                else
                {
                    StrCpyN(pszBuf, rgpropvar[1].pwszVal, cchBuf);
                }
            }
            if(SUCCEEDED(hres) && pszActualUrlBuf)
            {
                hres = StringCchCopy(pszActualUrlBuf, cchActualUrlBuf, rgpropvar[1].pwszVal);
            }
        }

        if (VT_I4 == rgpropvar[0].vt)
            *pniIcon = rgpropvar[0].lVal;

        FreePropVariantArray(ARRAYSIZE(rgpropvar), rgpropvar);
    }
    return hres;
}

//
// Functions from isexicon.cpp
//

/*----------------------------------------------------------
*
*
Purpose: IShellLink::GetIconLocation handler for Intshcut
*
*----------------------------------------------------------*/
STDMETHODIMP
Intshcut::_GetIconLocationWithURLHelper(
    IN  LPTSTR pszBuf,
    IN  int    cchBuf,
    OUT int *  pniIcon,
    IN  LPTSTR pszActualUrl,
    UINT cchActualUrlBuf,
    BOOL fRecentlyChanged)
{
    HRESULT hres;
    PROPSPEC rgpropspec[2];

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_BUFFER(pszBuf, TCHAR, cchBuf));
    ASSERT(IS_VALID_WRITE_PTR(pniIcon, int));

    if(!pszBuf)
        return E_INVALIDARG;

    rgpropspec[0].ulKind = PRSPEC_PROPID;
    rgpropspec[1].ulKind = PRSPEC_PROPID;

    
    if(pszActualUrl)
        *pszActualUrl = TEXT('\0');
        
    *pszBuf = TEXT('\0');
    
    hres = InitProp();
    if (SUCCEEDED(hres))
    {
        rgpropspec[0].propid = PID_IS_ICONINDEX;
        rgpropspec[1].propid = PID_IS_ICONFILE;
        hres = HelperForReadIconInfoFromPropStg(
                            pszBuf, cchBuf, pniIcon, m_pprop, 
                            rgpropspec, pszActualUrl, cchActualUrlBuf,
                            fRecentlyChanged);
        
    }

    if(TEXT('\0') == *pszBuf) 
    {
        // Didn't find it in the shortcut itself
        // Poke around the intsite database and if it is there,
        // simply stuff it into the shortcut file if you do find
        // one
        IPropertyStorage *ppropstg = NULL;
        hres = Open(FMTID_InternetSite, STGM_READWRITE, &ppropstg);
        if(S_OK == hres)
        {
            // Look for an icon for this specific url
            ASSERT(ppropstg);
            rgpropspec[0].propid = PID_INTSITE_ICONINDEX;
            rgpropspec[1].propid = PID_INTSITE_ICONFILE;
            hres = HelperForReadIconInfoFromPropStg(pszBuf, cchBuf, pniIcon, 
                                                    ppropstg, rgpropspec, pszActualUrl, 
                                                    cchActualUrlBuf, fRecentlyChanged);
            
            
            ppropstg->Release();
        }

        if((S_OK == hres) && (*pszBuf) && pszActualUrl && (*pszActualUrl))
        {
            // Write this info to the shortcut file
            WCHAR *pwszTempBuf;
            pwszTempBuf = pszActualUrl;
            PROPVARIANT var = {0};

            ASSERT(1 == *pniIcon);
            
            var.vt =  VT_BSTR;
            var.bstrVal = SysAllocString(pwszTempBuf);

            if(var.bstrVal)
            {
                hres = WritePropertyNPB(ISHCUT_INISTRING_SECTIONW, ISHCUT_INISTRING_ICONFILEW,
                                            &var);

                SysFreeString(var.bstrVal);
                if(S_OK == hres)
                {
                    var.bstrVal = SysAllocString(L"1");
                    if(var.bstrVal)
                    {
                        hres = WritePropertyNPB(ISHCUT_INISTRING_SECTIONW, ISHCUT_INISTRING_ICONINDEXW,
                                                    &var);
                        SysFreeString(var.bstrVal);
                    }
                }
            } 
            hres = S_OK; // retun OK if you found icon and could not write out for whatever reason
        }
    }

    return hres;
}

// IShellLink::GetIconLocation handler for Intshcut
STDMETHODIMP Intshcut::GetIconLocation(LPTSTR pszBuf, int cchBuf, int *pniIcon)
{
    UINT uTmp;
    return GetIconLocation(0, pszBuf, cchBuf, pniIcon, &uTmp);
}

// IShellLink::Resolve method for Intshcut
STDMETHODIMP Intshcut::Resolve(HWND hwnd,  DWORD dwFlags)
{
    return S_OK;
}

//====================================================================================
// Now the A or W functions that depend on unicode or ansi machines...
// Will setup forwarders to the native one for the OS...
//----------------------------------------------------------
STDMETHODIMP Intshcut::SetPath(LPCSTR pcszPath)
{
    WCHAR wszT[INTERNET_MAX_URL_LENGTH];

    if (!pcszPath)
        return SetPath((LPCWSTR)NULL);

    SHAnsiToUnicode(pcszPath, wszT, ARRAYSIZE(wszT));
    return SetPath(wszT);
}


STDMETHODIMP Intshcut::GetPath(LPSTR pszBuf, int cchBuf, PWIN32_FIND_DATAA pwfd, DWORD dwFlags)
{
    WCHAR wszT[INTERNET_MAX_URL_LENGTH];
    HRESULT hres;

    // Init to default values (Note pwfd is not actually set so don't worry about thunking...
    if (pwfd)
        ZeroMemory(pwfd, SIZEOF(*pwfd));

    hres = GetPath(wszT, ARRAYSIZE(wszT), NULL, dwFlags);
    if (SUCCEEDED(hres))
        SHUnicodeToAnsi(wszT, pszBuf, cchBuf);
    return hres;
}


STDMETHODIMP Intshcut::SetRelativePath(LPCSTR pcszRelativePath, DWORD dwReserved)
{
    WCHAR wszT[MAX_PATH];
    if (!pcszRelativePath)
        return SetRelativePath((LPCWSTR)NULL, dwReserved);

    SHAnsiToUnicode(pcszRelativePath, wszT, ARRAYSIZE(wszT));
    return SetRelativePath(wszT, dwReserved);
}


STDMETHODIMP Intshcut::SetDescription(LPCSTR pcszDescription)
{
    WCHAR wszT[MAX_PATH];
    if (!pcszDescription)
        return SetDescription((LPCWSTR)NULL);

    SHAnsiToUnicode(pcszDescription, wszT, ARRAYSIZE(wszT));
    return SetDescription(wszT);
}

STDMETHODIMP Intshcut::GetDescription(LPSTR pszDescription,int cchBuf)
{
    WCHAR wszT[MAX_PATH];
    HRESULT hres;

    hres = GetDescription(wszT, ARRAYSIZE(wszT));
    if (SUCCEEDED(hres))
        SHUnicodeToAnsi(wszT, pszDescription, cchBuf);
    return hres;
}

STDMETHODIMP Intshcut::SetArguments(LPCSTR pcszArgs)
{
    WCHAR wszT[2*MAX_PATH];
    if (!pcszArgs)
        return SetArguments((LPCWSTR)NULL);

    SHAnsiToUnicode(pcszArgs, wszT, ARRAYSIZE(wszT));
    return SetArguments(wszT);
}


STDMETHODIMP Intshcut::GetArguments(LPSTR pszArgs,int cchBuf)
{
    WCHAR wszT[2*MAX_PATH];
    HRESULT hres;

    hres = GetArguments(wszT, ARRAYSIZE(wszT));
    if (SUCCEEDED(hres))
        SHUnicodeToAnsi(wszT, pszArgs, cchBuf);
    return hres;
} 

STDMETHODIMP Intshcut::SetWorkingDirectory(LPCSTR pcszWorkingDirectory)
{
    WCHAR wszT[MAX_PATH];

    if (!pcszWorkingDirectory)
        return SetWorkingDirectory((LPCWSTR)NULL);

    SHAnsiToUnicode(pcszWorkingDirectory, wszT, ARRAYSIZE(wszT));
    return SetWorkingDirectory(wszT);
}

STDMETHODIMP Intshcut::GetWorkingDirectory(LPSTR pszBuf, int cchBuf)
{
    WCHAR wszT[MAX_PATH];
    HRESULT hres;

    hres = GetWorkingDirectory(wszT, ARRAYSIZE(wszT));
    if (SUCCEEDED(hres))
        SHUnicodeToAnsi(wszT, pszBuf, cchBuf);
    return hres;
}

STDMETHODIMP Intshcut::SetIconLocation(LPCSTR pszFile, int niIcon)
{
    WCHAR wszT[MAX_PATH];

    if (!pszFile)
        return SetIconLocation((LPCWSTR)NULL, niIcon);

    SHAnsiToUnicode(pszFile, wszT, ARRAYSIZE(wszT));
    return SetIconLocation(wszT, niIcon);
}

STDMETHODIMP Intshcut::GetIconLocation(LPSTR pszBuf, int cchBuf, int *pniIcon)
{
    WCHAR wszT[MAX_PATH];
    HRESULT hres;

    hres = GetIconLocation(wszT, ARRAYSIZE(wszT), pniIcon);
    if (SUCCEEDED(hres))
        SHUnicodeToAnsi(wszT, pszBuf, cchBuf);
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\isprsht.cpp ===
/*
 * isprsht.cpp - IPropSheetExt implementation for URL class.
 */


#include "priv.h"
#include "ishcut.h"
#include <limits.h>
#include <trayp.h>          // for WMTRAY_ messages
#include <ntverp.h>         // VER_XXX for FaultInFeature
#include <webcheck.h>       // ISubscriptionMgrPriv

#include <mluisupp.h>

#undef NO_HELP              // for help.h
#include "resource.h"
#include <iehelpid.h>

#ifndef UNIX
const WCHAR c_szPropCrawlActualSize[] = L"ActualSizeKB";
const WCHAR c_szPropStatusString[] = L"StatusString";
const WCHAR c_szPropCompletionTime[] = L"CompletionTime";
#else
#include "unixstuff.h"
#include "shalias.h"
const LPCWSTR c_szPropCrawlActualSize = L"ActualSizeKB";
const LPCWSTR c_szPropStatusString = L"StatusString";
const LPCWSTR c_szPropCompletionTime = L"CompletionTime";
#endif

#include "apithk.h"

/* stuff a point value packed in an LPARAM into a POINT */

#define LPARAM_TO_POINT(lParam, pt)       ((pt).x = GET_X_LPARAM(lParam), \
                                           (pt).y = GET_Y_LPARAM(lParam))


#define ISF_STARTSUBSCRIBED     0x00010000      // URL was subscribed to start with
#define ISF_NOWEBCHECK          0x00020000      // Webcheck is not installed
#define ISF_DISABLEOFFLINE      0x00080000      // Disable "make available offline" menus/checkboxes
#define ISF_SUMMARYEXTRACTED    0x00100000      // Has the summary been extracted
#define ISF_HAVEINITED          0x00200000      // Has the subsmgr extension been inited?




/* Internet Shortcut property sheet data */

/*  
    Mental note(tnoonan): this helper class should be shared with the context menu 
    code soon.
*/

class CSubsHelper
{
    IUniformResourceLocatorW    *m_pIURLW;
    ISubscriptionMgr2           *m_pSubsMgr2;
    HINSTANCE                   m_hinstWebcheck;
    HWND                        m_hwndParent;
    
public:
    DWORD               m_dwFlags;

    ~CSubsHelper()
    {
        if (NULL != m_pSubsMgr2)
        {
            m_pSubsMgr2->Release();
        }

        if (NULL != m_pIURLW)
        {
            m_pIURLW->Release();
        }

        if (NULL != m_hinstWebcheck)
        {
            FreeLibrary(m_hinstWebcheck);
        }
    }

    void SetParentHwnd(HWND hwndParent)
    {
        m_hwndParent = hwndParent;
    }

    void SetIURLW(IUniformResourceLocatorW *pIURLW)
    {
        if (NULL != m_pIURLW)
        {
            m_pIURLW->Release();
        }

        if (NULL != pIURLW)
        {
            pIURLW->AddRef();
        }

        m_pIURLW = pIURLW;
    }

    HRESULT GetIURLW(IUniformResourceLocatorW **ppIURLW)
    {
        HRESULT hr;
        
        ASSERT(NULL != ppIURLW);

        if (NULL != m_pIURLW)
        {
            m_pIURLW->AddRef();
            *ppIURLW = m_pIURLW;
            hr = S_OK;
        }
        else
        {
            *ppIURLW = NULL;
            hr = E_FAIL;
        }

        return hr;
    }
   
    HRESULT Init()
    {
        HRESULT hr;
        WCHAR *pwszURL;

        ASSERT(NULL != m_pIURLW);

        hr = m_pIURLW->GetURL(&pwszURL);

        if (SUCCEEDED(hr))
        {

            hr = LoadSubsMgr2(FIEF_FLAG_PEEK | FIEF_FLAG_FORCE_JITUI);

            if (SUCCEEDED(hr))
            {
                BOOL bSubscribed; 

                if (SUCCEEDED(m_pSubsMgr2->IsSubscribed(pwszURL, &bSubscribed)) && 
                    (TRUE == bSubscribed))
                {
                    m_dwFlags |= ISF_STARTSUBSCRIBED;
                }
            }

            if (m_dwFlags & ISF_STARTSUBSCRIBED)
            {
                if (SHRestricted2W(REST_NoRemovingSubscriptions, pwszURL, 0))
                {
                    m_dwFlags |= ISF_DISABLEOFFLINE;
                }
            }
            else
            {
                if (SHRestricted2W(REST_NoAddingSubscriptions, pwszURL, 0))
                {
                    m_dwFlags |= ISF_DISABLEOFFLINE;
                }
            }

            SHFree(pwszURL);
        }

        return hr;
    }

    HRESULT LoadSubsMgr2(DWORD dwFaultInFlags)
    {
        HRESULT hr;
        uCLSSPEC ucs;
        QUERYCONTEXT qc = { 0 };

        ucs.tyspec = TYSPEC_CLSID;
        ucs.tagged_union.clsid = CLSID_SubscriptionMgr;

        hr = FaultInIEFeature(m_hwndParent, &ucs, &qc, dwFaultInFlags);

        if (SUCCEEDED(hr))
        {
            m_dwFlags &= ~ISF_NOWEBCHECK;
        }
        else
        {
            m_dwFlags |= ISF_NOWEBCHECK;

            if (E_ACCESSDENIED == hr)
            {
                //  Admin has disabled demand install
                m_dwFlags |= ISF_DISABLEOFFLINE;
            }
        }

        if (!(m_dwFlags & ISF_NOWEBCHECK))
        {
            ASSERT(NULL == m_pSubsMgr2)
            
            //  HACKHACKHACK
            hr = CoInitialize(NULL);
            if (SUCCEEDED(hr))
            {
                m_hinstWebcheck = SHPinDllOfCLSID(&CLSID_SubscriptionMgr);
                if (NULL != m_hinstWebcheck)
                {
                    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                                          IID_PPV_ARG(ISubscriptionMgr2, &m_pSubsMgr2));
                }
                else
                {
                    m_dwFlags |= ISF_NOWEBCHECK;
                    hr = E_FAIL;
                }

                //  HACKHACKHACK
                CoUninitialize();
            }
        }

        return hr;
    }

    HRESULT GetSubsMgr2(ISubscriptionMgr2 **ppSubsMgr2, DWORD dwFaultInFlags)
    {
        HRESULT hr = E_FAIL;

        ASSERT(NULL != ppSubsMgr2);
        *ppSubsMgr2 = NULL;

        if ((NULL == m_pSubsMgr2) && (0xffffffff != dwFaultInFlags))
        {
            hr = LoadSubsMgr2(dwFaultInFlags);
        }
        
        if (NULL != m_pSubsMgr2)
        {
            m_pSubsMgr2->AddRef();
            *ppSubsMgr2 = m_pSubsMgr2;
            hr = S_OK;
        }
        return hr;
    }

    HRESULT DeleteSubscription()
    {
        HRESULT hr = S_FALSE;
        
        if (m_pSubsMgr2)
        {
            WCHAR *pwszURL;

            ASSERT(NULL != m_pIURLW);

            hr = m_pIURLW->GetURL(&pwszURL);

            if (SUCCEEDED(hr))
            {
                hr = m_pSubsMgr2->DeleteSubscription(pwszURL, NULL);
                SHFree(pwszURL);
            }
        }

        return hr;
    }

    HRESULT SaveSubscription()
    {
        HRESULT hr;
#ifndef UNIX
        ISubscriptionMgrPriv *psmp;

        if (m_pSubsMgr2)
        {

            hr = m_pSubsMgr2->QueryInterface(IID_PPV_ARG(ISubscriptionMgrPriv, &psmp));

            if (SUCCEEDED(hr))
            {
                hr = psmp->SaveSubscription();
                psmp->Release();
            }
        }
        else
#endif
        {
            hr = E_FAIL;
        }
        return hr;
    }

    HRESULT UpdateSubscription()
    {
        HRESULT hr;
        
        if (m_pSubsMgr2)
        {
            WCHAR *pwszURL;

            ASSERT(NULL != m_pIURLW);

            hr = m_pIURLW->GetURL(&pwszURL);
            if (SUCCEEDED(hr))
            {
                hr = m_pSubsMgr2->UpdateSubscription(pwszURL);
                SHFree(pwszURL);
            }
        }
        else
        {
            hr = E_FAIL;
        }

        return hr;
    }

    HRESULT DoShellExtInit(IDataObject *pdo)
    {
        HRESULT hr = E_FAIL;

        if (NULL != m_pSubsMgr2)
        {
            if (!(m_dwFlags & ISF_HAVEINITED))
            {
                IShellExtInit *psei;

                hr = m_pSubsMgr2->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei));

                if (SUCCEEDED(hr))
                {
                    hr = psei->Initialize(NULL, pdo, NULL);

                    if (SUCCEEDED(hr))
                    {
                        m_dwFlags |= ISF_HAVEINITED;
                    }
                    psei->Release();
                }
            }
            else
            {
                hr = S_FALSE;
            }
        }
        
        return hr;
    }


};

struct ISDATA
{
private:
    Intshcut            *m_pintshcut;
    
public:
    TCHAR               rgchIconFile[MAX_PATH];
    int                 niIcon;
    CSubsHelper         SubsHelper;
    BOOL                bUserEditedPage;

    inline void SetIntshcut(Intshcut *pintshcut)
    {
        IUniformResourceLocatorW *pIURLW;

        ASSERT(NULL == m_pintshcut);
        ASSERT(NULL != pintshcut);

        pintshcut->AddRef();

        if (SUCCEEDED(pintshcut->QueryInterface(IID_PPV_ARG(IUniformResourceLocatorW, &pIURLW))))
        {
            SubsHelper.SetIURLW(pIURLW);
            pIURLW->Release();
        }

        m_pintshcut = pintshcut;
    }

    inline Intshcut *GetIntshcut() const
    { 
        ASSERT(NULL != m_pintshcut);
        return m_pintshcut;
    }

    ~ISDATA()
    {
        if (NULL != m_pintshcut)
        {
            m_pintshcut->Release();
        }
    }
};

typedef ISDATA *PISDATA;


#ifdef DEBUG

BOOL
IsValidPISDATA(
    PISDATA pisdata)
{
    return(IS_VALID_READ_PTR(pisdata, ISDATA) &&
           IS_VALID_STRUCT_PTR(pisdata->GetIntshcut(), CIntshcut) &&
           EVAL(IsValidIconIndex(*(pisdata->rgchIconFile) ? S_OK : S_FALSE, pisdata->rgchIconFile, SIZECHARS(pisdata->rgchIconFile), pisdata->niIcon)));
}

PISDATA ISPS_GetPISDATA(HWND hdlg)
{
    PISDATA pd = (PISDATA) GetWindowLongPtr(hdlg, DWLP_USER);

    IS_VALID_STRUCT_PTR(pd, ISDATA);

    return pd;
}

Intshcut *ISPS_GetThisPtr(HWND hdlg)
{
    Intshcut *pintshcut = ISPS_GetPISDATA(hdlg)->GetIntshcut();

    IS_VALID_STRUCT_PTR(pintshcut, CIntshcut);

    return pintshcut;
}
#else
#define ISPS_GetPISDATA(hdlg)   ((PISDATA)GetWindowLongPtr(hdlg, DWLP_USER))
#define ISPS_GetThisPtr(hdlg)   (ISPS_GetPISDATA(hdlg)->GetIntshcut())
#endif

// help files

TCHAR const s_cszIEHelpFile[]   = TEXT("iexplore.hlp");

// help topics

DWORD const c_rgdwHelpIDs[] =
{
    IDC_ICON,                   IDH_FCAB_LINK_ICON,
    IDC_NAME,                   IDH_FCAB_LINK_NAME,
    IDC_URL_TEXT,               IDH_SUBPROPS_SUBTAB_SUBSCRIBED_URL,
    IDC_URL,                    IDH_SUBPROPS_SUBTAB_SUBSCRIBED_URL,
    IDC_HOTKEY_TEXT,            IDH_FCAB_LINK_HOTKEY,
    IDC_HOTKEY,                 IDH_FCAB_LINK_HOTKEY,
    IDC_CHANGE_ICON,            IDH_FCAB_LINK_CHANGEICON,
    IDC_VISITS_TEXT,            IDH_WEBDOC_VISITS,
    IDC_VISITS,                 IDH_WEBDOC_VISITS,
    IDC_MAKE_OFFLINE,           IDH_MAKE_AVAIL_OFFLINE,
    IDC_SUMMARY,                IDH_GROUPBOX,
    IDC_LAST_SYNC_TEXT,         IDH_SUBPROPS_SUBTAB_LAST,
    IDC_LAST_SYNC,              IDH_SUBPROPS_SUBTAB_LAST,
    IDC_DOWNLOAD_SIZE_TEXT,     IDH_SUBPROPS_DLSIZE,
    IDC_DOWNLOAD_SIZE,          IDH_SUBPROPS_DLSIZE,
    IDC_DOWNLOAD_RESULT_TEXT,   IDH_SUBPROPS_SUBTAB_RESULT,
    IDC_DOWNLOAD_RESULT,        IDH_SUBPROPS_SUBTAB_RESULT,
    0,                          0
};


/***************************** Private Functions *****************************/

void SetEditFocus(HWND hwnd)
{
    SetFocus(hwnd);
    Edit_SetSel(hwnd, 0, -1);
}


#define SetDlgCtlText      SetDlgItemTextW

UINT
CALLBACK
ISPSCallback(
    HWND hwnd, 
    UINT uMsg, 
    LPPROPSHEETPAGE ppsp)
{
    UINT uResult = TRUE;
    PISDATA pisdata = (PISDATA)ppsp->lParam;

    // uMsg may be any value.

    ASSERT(! hwnd ||
           IS_VALID_HANDLE(hwnd, WND));

    switch (uMsg)
    {
        case PSPCB_CREATE:
            break;

        case PSPCB_RELEASE:
            TraceMsg(TF_INTSHCUT, "ISPSCallback(): Received PSPCB_RELEASE.");

            if (pisdata)
            {   
                delete pisdata;         
            }
            break;

        default:
            break;
    }

    return(uResult);
}

HRESULT
CopyDlgItemText(
    HWND hdlg,
    int nControlID, 
    TCHAR * UNALIGNED * ppszText)
{
    HRESULT hr;
    HWND hwndControl;

    // nContolID may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));
    ASSERT(IS_VALID_WRITE_PTR(ppszText, PTSTR));

    *ppszText = NULL;

    hwndControl = GetDlgItem(hdlg, nControlID);

    if (hwndControl)
    {
        int cchTextLen;

        cchTextLen = GetWindowTextLength(hwndControl);

        if (cchTextLen > 0)
        {
            LPTSTR pszText;

            ASSERT(cchTextLen < INT_MAX);
            cchTextLen++;
            ASSERT(cchTextLen > 0);

            pszText = (LPTSTR)LocalAlloc(LPTR, CbFromCch(cchTextLen));

            if (pszText)
            {
                int ncchCopiedLen;

                ncchCopiedLen = GetWindowText(hwndControl, pszText, cchTextLen);
                ASSERT(ncchCopiedLen == cchTextLen - 1);

                if (EVAL(ncchCopiedLen > 0))
                {
                    if (AnyMeat(pszText))
                    {
                        *ppszText = pszText;

                        hr = S_OK;
                    }
                    else
                        hr = S_FALSE;
                }
                else
                    hr = E_FAIL;

                if (hr != S_OK)
                {
                    LocalFree(pszText);
                    pszText = NULL;
                }
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
            // No text.
            hr = S_FALSE;
    }
    else
        hr = E_FAIL;

    return(hr);
}

void
SetISPSIcon(
    HWND hdlg, 
    HICON hicon)
{
    HICON hiconOld;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));
    ASSERT(IS_VALID_HANDLE(hicon, ICON));

    hiconOld = (HICON)SendDlgItemMessage(hdlg, IDC_ICON, STM_SETICON,
                                         (WPARAM)hicon, 0);

    if (hiconOld)
        DestroyIcon(hiconOld);

    TraceMsg(TF_INTSHCUT, "SetISPSIcon(): Set property sheet icon to %#lx.",
               hicon);

    return;
}

void
SetISPSFileNameAndIcon(
    HWND hdlg)
{
    HRESULT hr;
    PIntshcut pintshcut;
    TCHAR rgchFile[MAX_PATH];

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pintshcut = ISPS_GetThisPtr(hdlg);

    hr = pintshcut->GetCurFile(rgchFile, SIZECHARS(rgchFile));

    if (hr == S_OK)
    {
        SHFILEINFO shfi;
        DWORD_PTR dwResult;

        dwResult = SHGetFileInfo(rgchFile, 0, &shfi, SIZEOF(shfi),
                                 (SHGFI_DISPLAYNAME | SHGFI_ICON));

        if (dwResult)
        {
            LPTSTR pszFileName;

            pszFileName = (PTSTR)PathFindFileName(shfi.szDisplayName);

            EVAL(SetDlgItemText(hdlg, IDC_NAME, pszFileName));

            SetISPSIcon(hdlg, shfi.hIcon);
        }
        else
        {
           hr = E_FAIL;

           TraceMsg(TF_INTSHCUT, "SetISPSFileNameAndIcon(): SHGetFileInfo() failed, returning %lu.",
                      dwResult);
        }
    }
    else
        TraceMsg(TF_INTSHCUT, "SetISPSFileNameAndIcon(): GetCurFile() failed, returning %s.",
                   Dbg_GetHRESULTName(hr));

    if (hr != S_OK)
        EVAL(SetDlgItemText(hdlg, IDC_NAME, c_szNULL));

    return;
}

void
SetISPSURL(
    HWND hdlg,
    BOOL *pbSubscribable)
{
    PIntshcut pintshcut;
    HRESULT hr;
    PTSTR pszURL;

    *pbSubscribable = FALSE;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pintshcut = ISPS_GetThisPtr(hdlg);

    hr = pintshcut->GetURL(&pszURL);

    if (hr == S_OK)
    {
        TCHAR szVisits[256];
        EVAL(SetDlgItemText(hdlg, IDC_URL, pszURL));

        TraceMsg(TF_INTSHCUT, "SetISPSURL(): Set property sheet URL to \"%s\".",
                   pszURL);

        *pbSubscribable = IsSubscribable(pszURL);
        
        BYTE cei[MAX_CACHE_ENTRY_INFO_SIZE];
        LPINTERNET_CACHE_ENTRY_INFO pcei = (LPINTERNET_CACHE_ENTRY_INFO)cei;
        DWORD       cbcei = MAX_CACHE_ENTRY_INFO_SIZE;

#ifdef UNIX_FEATURE_ALIAS
        {
            HDPA  aliasList = GetGlobalAliasList();
            if( aliasList )
            {
#ifdef UNICODE
            // TODO :
#else
            CHAR szAlias[ MAX_ALIAS_LENGTH ];
            if(FindAliasByURLA( aliasList, pszURL, szAlias, sizeof(szAlias) ) )
                 SetDlgItemText(hdlg, IDC_ALIAS_NAME, szAlias);
#endif
            }
        }
#endif  /* UNIX_FEATURE_ALIAS */

        if (GetUrlCacheEntryInfo(pszURL, pcei, &cbcei))
        {
            wnsprintf(szVisits, ARRAYSIZE(szVisits), TEXT("%d"), pcei->dwHitRate);
        }
        else
        {
            MLLoadString(IDS_VALUE_UNKNOWN, szVisits, ARRAYSIZE(szVisits));
        }

        EVAL(SetDlgItemText(hdlg, IDC_VISITS, szVisits));

        SHFree(pszURL);
        pszURL = NULL;
    }
    else
        EVAL(SetDlgItemText(hdlg, IDC_URL, c_szNULL));

    return;
}

void 
InitISPSHotkey(
    HWND hdlg)
{
    PIntshcut pintshcut;
    WORD wHotkey;
    HRESULT hr;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    // Set hotkey combinations.

    SendDlgItemMessage(hdlg, IDC_HOTKEY, HKM_SETRULES,
                       (HKCOMB_NONE | HKCOMB_A | HKCOMB_C | HKCOMB_S),
                       (HOTKEYF_CONTROL | HOTKEYF_ALT));

    // Set current hotkey.

    pintshcut = ISPS_GetThisPtr(hdlg);
    ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CIntshcut));

    hr = pintshcut->GetHotkey(&wHotkey);
    SendDlgItemMessage(hdlg, IDC_HOTKEY, HKM_SETHOTKEY, wHotkey, 0);

    return;
}


void ISPS_ShowOfflineSummary(HWND hdlg, BOOL bShow, PISDATA pisdata)
{
    static const int offSumIDs[] =
    {
        IDC_SUMMARY,
        IDC_LAST_SYNC_TEXT,
        IDC_LAST_SYNC,
        IDC_DOWNLOAD_SIZE_TEXT,
        IDC_DOWNLOAD_SIZE,
        IDC_DOWNLOAD_RESULT,
        IDC_DOWNLOAD_RESULT_TEXT,
        IDC_FREESPACE_TEXT
    };

    if (bShow)
    {
        IUniformResourceLocatorW *pIURLW;

        TCHAR szLastSync[128];
        TCHAR szDownloadSize[128];
        TCHAR szDownloadResult[128];

        MLLoadString(IDS_VALUE_UNKNOWN, szLastSync, ARRAYSIZE(szLastSync));
        StrCpyN(szDownloadSize, szLastSync, ARRAYSIZE(szDownloadSize));
        StrCpyN(szDownloadResult, szLastSync, ARRAYSIZE(szDownloadResult));

        if (SUCCEEDED(pisdata->SubsHelper.GetIURLW(&pIURLW)))
        {
            WCHAR *pwszURL;

            if (SUCCEEDED(pIURLW->GetURL(&pwszURL)))
            {            
                ISubscriptionMgr2 *pSubsMgr2;
               
                if (SUCCEEDED(pisdata->SubsHelper.GetSubsMgr2(&pSubsMgr2, FIEF_FLAG_PEEK | FIEF_FLAG_FORCE_JITUI)))
                {
                    ISubscriptionItem *psi;
                    
                    if (SUCCEEDED(pSubsMgr2->GetItemFromURL(pwszURL, &psi)))
                    {
                        enum { spLastSync, spDownloadSize, spDownloadResult };
                        static const LPCWSTR pProps[] =
                        { 
                            c_szPropCompletionTime,
                            c_szPropCrawlActualSize,
                            c_szPropStatusString
                        };
                        VARIANT vars[ARRAYSIZE(pProps)];

                        if (SUCCEEDED(psi->ReadProperties(ARRAYSIZE(pProps), pProps, vars)))
                        {
                            if (VT_DATE == vars[spLastSync].vt)
                            {
                                FILETIME ft, ft2;
                                DWORD dwFlags = FDTF_DEFAULT;
                                SYSTEMTIME st;

                                if (VariantTimeToSystemTime(vars[spLastSync].date, &st))
                                {
                                    SystemTimeToFileTime(&st, &ft);
                                    LocalFileTimeToFileTime(&ft, &ft2);
                                    SHFormatDateTime(&ft2, &dwFlags, szLastSync, ARRAYSIZE(szLastSync));
                                }
                            }

                            if (VT_I4 == vars[spDownloadSize].vt)
                            {
                                StrFormatByteSize(vars[spDownloadSize].lVal * 1024, 
                                                  szDownloadSize, ARRAYSIZE(szDownloadSize));
                            }

                            if (VT_BSTR == vars[spDownloadResult].vt)
                            {
                                wnsprintf(szDownloadResult, ARRAYSIZE(szDownloadResult),
                                          TEXT("%s"), vars[spDownloadResult].bstrVal);
                            }

                            for (int i = 0; i < ARRAYSIZE(pProps); i++)
                            {
                                VariantClear(&vars[i]);
                            }
                        }
                        
                        psi->Release();
                    }

                    pSubsMgr2->Release();
                }
                
                SHFree(pwszURL);
            }
            
            pIURLW->Release();
        }

        EVAL(SetDlgItemText(hdlg, IDC_LAST_SYNC, szLastSync));
        EVAL(SetDlgItemText(hdlg, IDC_DOWNLOAD_SIZE, szDownloadSize));
        EVAL(SetDlgItemText(hdlg, IDC_DOWNLOAD_RESULT, szDownloadResult));
    }

    for (int i = 0; i < ARRAYSIZE(offSumIDs); i++)
    {
        ShowWindow(GetDlgItem(hdlg, offSumIDs[i]), bShow ? SW_SHOW : SW_HIDE);
    }
}

BOOL ISPS_AddSubsPropsCallback(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    return BOOLFROMPTR(PropSheet_AddPage((HWND)lParam, hpage));
}

STDMETHODIMP ISPS_AddSubsProps(HWND hdlg, ISubscriptionMgr2 *pSubsMgr2, PISDATA pisdata)
{
    HRESULT hr = S_OK;
    IShellPropSheetExt *pspse;

    ASSERT(NULL != pisdata);
    ASSERT(NULL != pSubsMgr2);

    hr = pisdata->SubsHelper.DoShellExtInit(pisdata->GetIntshcut()->GetInitDataObject());

    if (SUCCEEDED(hr))
    {
        hr = pSubsMgr2->QueryInterface(IID_PPV_ARG(IShellPropSheetExt, &pspse));

        if (SUCCEEDED(hr))
        {
            hr = pspse->AddPages(ISPS_AddSubsPropsCallback,
                                 (LPARAM)GetParent(hdlg)) ? S_OK : E_FAIL;
            pspse->Release();
        }
    }

    return hr;
}

STDMETHODIMP ISPS_RemoveSubsProps(HWND hdlg, ISubscriptionMgr2 *pSubsMgr2)
{
    HRESULT hr;
    ISubscriptionMgrPriv *psmp;

    ASSERT(NULL != pSubsMgr2);

#ifndef UNIX
    hr = pSubsMgr2->QueryInterface(IID_PPV_ARG(ISubscriptionMgrPriv, &psmp));

    if (SUCCEEDED(hr))
    {
        hr = psmp->RemovePages(GetParent(hdlg));
        psmp->Release();
    }
#else
    hr = E_FAIL;
#endif

    return hr;
}

HRESULT ISPS_OnMakeOfflineClicked(HWND hdlg)
{
#ifndef UNIX
    HRESULT hr;
    BOOL bChecked = IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE);
    PISDATA pisdata = ISPS_GetPISDATA(hdlg);
    ISubscriptionMgr2 *pSubsMgr2;

    hr = pisdata->SubsHelper.GetSubsMgr2(&pSubsMgr2, FIEF_FLAG_FORCE_JITUI);

    ASSERT((SUCCEEDED(hr) && pSubsMgr2) || (FAILED(hr) && !pSubsMgr2));
        
    if (bChecked)
    {
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != pSubsMgr2);
            
            hr = ISPS_AddSubsProps(hdlg, pSubsMgr2, pisdata);
        }
        else
        {
            //  Can't do this without subsmgr
            CheckDlgButton(hdlg, IDC_MAKE_OFFLINE, BST_UNCHECKED);
            bChecked = FALSE;
        }
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            ASSERT(NULL != pSubsMgr2);
            hr = ISPS_RemoveSubsProps(hdlg, pSubsMgr2);
        }
    }

    if (NULL != pSubsMgr2)
    {
        pSubsMgr2->Release();
    }

    ISPS_ShowOfflineSummary(hdlg, bChecked, pisdata);

    return hr;
#else
    // IEUNIX : ( MAKE_OFFLINE disabled )
    return E_FAIL;
#endif
}


BOOL 
ISPS_InitDialog(
    HWND hdlg, 
    WPARAM wParam, 
    LPARAM lParam)
{
    LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE)lParam;
    PIntshcut pintshcut;
    PISDATA pisdata;
    BOOL bSubscribable;
    
    // wParam may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));
    
    pisdata = (PISDATA)ppsp->lParam;
    ASSERT(IS_VALID_STRUCT_PTR(pisdata, ISDATA));

    SetWindowLongPtr(hdlg, DWLP_USER, ppsp->lParam);

    pintshcut = pisdata->GetIntshcut();
    pisdata->SubsHelper.SetParentHwnd(hdlg);
    
    // Cross-lang platform support
    SHSetDefaultDialogFont(hdlg, IDC_START_IN);
    SHSetDefaultDialogFont(hdlg, IDC_URL); // for intra-net

    // Initialize control contents.
    SetISPSFileNameAndIcon(hdlg);

    InitISPSHotkey(hdlg);

    SendDlgItemMessage(hdlg, IDC_URL, EM_LIMITTEXT, INTERNET_MAX_URL_LENGTH - 1, 0);
    SetISPSURL(hdlg, &bSubscribable);

#ifndef UNIX
    // IEUNIX : ( MAKE_OFFLINE disabled )
    if (pisdata->SubsHelper.m_dwFlags & ISF_STARTSUBSCRIBED)
    {
        CheckDlgButton(hdlg, IDC_MAKE_OFFLINE, TRUE);
    }

    if (!bSubscribable)
    {
        pisdata->SubsHelper.m_dwFlags |= ISF_DISABLEOFFLINE;
    }

    if (pisdata->SubsHelper.m_dwFlags & ISF_DISABLEOFFLINE)
    {
        EnableWindow(GetDlgItem(hdlg, IDC_MAKE_OFFLINE), FALSE);
    }

    ISPS_ShowOfflineSummary(hdlg, 
                            pisdata->SubsHelper.m_dwFlags & ISF_STARTSUBSCRIBED, 
                            pisdata);
#endif

    // since we just finished initing the dialog, set pisdata->bUserEditedPage to
    // FALSE. If the user messes with the page (eg clicks a button or types in an edit box),
    // we will set it to TRUE so we know that we actually have changes to apply.
    //
    // NOTE: this must come last since when we call SetDlgItemText above, we will
    // generate WM_COMMAND messages that cause us to set bUserEditedPage to TRUE.
    pisdata->bUserEditedPage = FALSE;

    return(TRUE);
}


BOOL
ISPS_Destroy(
    HWND hdlg, 
    WPARAM wParam, 
    LPARAM lParam)
{
    ASSERT(IS_VALID_HANDLE(hdlg, WND));
    PISDATA pisdata = ISPS_GetPISDATA(hdlg);
    
#ifndef UNIX
    // IEUNIX : ( MAKE_OFFLINE disabled )
    if ((!(pisdata->SubsHelper.m_dwFlags & ISF_STARTSUBSCRIBED)) && 
        IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE))

    {
        pisdata->SubsHelper.UpdateSubscription();
    }
#endif
    

    SetWindowLongPtr(hdlg, DWLP_USER, NULL);
    SHRemoveDefaultDialogFont(hdlg);

    return(TRUE);
}

void
ISPSChanged(
    HWND hdlg)
{
    PISDATA pisdata;
    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pisdata = ISPS_GetPISDATA(hdlg);
    pisdata->bUserEditedPage = TRUE;
    
    PropSheet_Changed(GetParent(hdlg), hdlg);
    
    return;
}

HRESULT
ChooseIcon(
    HWND hdlg)
{
    HRESULT hr;
    PISDATA pisdata;
    PIntshcut pintshcut;
    TCHAR szPath[MAX_PATH], szExpandedPath[MAX_PATH];
    int niIcon;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pisdata = ISPS_GetPISDATA(hdlg);
    pintshcut = pisdata->GetIntshcut();

    ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CIntshcut));

    szPath[0] = TEXT('\0');

    hr = pintshcut->GetIconLocation(szPath, MAX_PATH, (int *)(&niIcon));
                                             
    if((FAILED(hr)) || (FALSE == PathFileExists(szPath)))
    {
        hr = GetGenericURLIcon(szPath, MAX_PATH, (int *)(&niIcon));
        if(FAILED(hr))
        {
            szPath[0] = '\0';
            niIcon = 0;
        }
    }

    ASSERT(lstrlen(szPath) < SIZECHARS(szPath));

    if (PickIconDlg(hdlg, szPath, SIZECHARS(szPath), &niIcon) &&
        SHExpandEnvironmentStrings(szPath, szExpandedPath, SIZECHARS(szExpandedPath)))
    {
        ASSERT(lstrlen(szExpandedPath) < SIZECHARS(pisdata->rgchIconFile));
        hr = StringCchCopy(pisdata->rgchIconFile, ARRAYSIZE(pisdata->rgchIconFile), szExpandedPath);
        pisdata->niIcon = niIcon;
    }
    else
    {
        hr = E_FAIL;

        TraceMsg(TF_INTSHCUT, "ChooseIcon(): PickIconDlg() failed.");
    }

    return(hr);
}

void
UpdateISPSIcon(
    HWND hdlg)
{
    PIntshcut pintshcut;
    PISDATA pisdata;
    HICON hicon;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pisdata = ISPS_GetPISDATA(hdlg);
    pintshcut = pisdata->GetIntshcut();

    ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CIntshcut));

    ASSERT(pisdata->rgchIconFile[0]);

    // This icon does not have the link arrow overlayed.  shell32.dll's
    // Shortcut property sheet has the same bug.

    hicon = ExtractIcon(g_hinst, pisdata->rgchIconFile, pisdata->niIcon);

    if (hicon)
        SetISPSIcon(hdlg, hicon);
    else
        TraceMsg(TF_WARNING, "UpdateISPSIcon(): ExtractIcon() failed for icon %d in file %s.",
                 pisdata->niIcon,
                 pisdata->rgchIconFile);
}

BOOL 
ISPS_Command(
    HWND hdlg, 
    WPARAM wParam, 
    LPARAM lParam)
{
    BOOL bMsgHandled = FALSE;
    WORD wCmd;

    // wParam may be any value.
    // lParam may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    wCmd = HIWORD(wParam);

    switch (LOWORD(wParam))
    {
        case IDC_URL:
        case IDC_HOTKEY:
            if (wCmd == EN_CHANGE)
            {
                ISPSChanged(hdlg);

                bMsgHandled = TRUE;
            }
            break;

#ifndef UNIX
        // IEUNIX : ( MAKE_OFFLINE disabled )
        case IDC_MAKE_OFFLINE:
            if (wCmd == BN_CLICKED)
            {
                ISPS_OnMakeOfflineClicked(hdlg);

                ISPSChanged(hdlg);

                bMsgHandled = TRUE;
            }
            break;


        case IDC_CHANGE_ICON:
            // Ignore return value.
            if (ChooseIcon(hdlg) == S_OK)
            {
                UpdateISPSIcon(hdlg);
                ISPSChanged(hdlg);
            }
            bMsgHandled = TRUE;
            break;
#endif

        default:
            break;
    }

    return(bMsgHandled);
}

HRESULT 
ComplainAboutURL(
    HWND hwndParent, 
    LPCTSTR pcszURL, 
    HRESULT hrError)
{
    HRESULT hr;
    int nResult;

    // Validate hrError below.

    ASSERT(IS_VALID_HANDLE(hwndParent, WND));
    ASSERT(IS_VALID_STRING_PTR(pcszURL, -1));

    switch (hrError)
    {
        case URL_E_UNREGISTERED_PROTOCOL:
        {
            LPTSTR pszProtocol;

            hr = CopyURLProtocol(pcszURL, &pszProtocol, NULL);

            if (hr == S_OK)
            {
                nResult = MLShellMessageBox(
                                          hwndParent, 
                                          MAKEINTRESOURCE(IDS_UNREGISTERED_PROTOCOL),
                                          MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                                          (MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION),
                                          pszProtocol);

                if (-1 != nResult)
                {
                    switch (nResult)
                    {
                        case IDYES:
                            hr = S_OK;
                            TraceMsg(TF_INTSHCUT, "ComplainAboutURL(): Allowing URL %s despite unregistered protocol %s, by request.",
                                       pcszURL,
                                       pszProtocol);
                            break;

                        default:
                            ASSERT(nResult == IDNO);
                            hr = E_FAIL;
                            TraceMsg(TF_INTSHCUT, "ComplainAboutURL(): Not allowing URL %s because of unregistered protocol %s, as directed.",
                                       pcszURL,
                                       pszProtocol);
                            break;
                    }
                }

                LocalFree(pszProtocol);
                pszProtocol = NULL;
            }

            break;
        }

        default:
            ASSERT(hrError == URL_E_INVALID_SYNTAX);

            MLShellMessageBox(
                            hwndParent, 
                            MAKEINTRESOURCE(IDS_INVALID_URL_SYNTAX),
                            MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                            MB_OK | MB_ICONEXCLAMATION,
                            pcszURL);

            hr = E_FAIL;

            TraceMsg(TF_INTSHCUT, "ComplainAboutURL(): Not allowing URL %s because of invalid syntax.",
                       pcszURL);

            break;
    }

    return(hr);
}

HRESULT 
InjectISPSData(
    HWND hdlg)
{
    HRESULT hr;
    PISDATA pisdata;
    PIntshcut pintshcut;
    PTSTR pszURL;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pisdata = ISPS_GetPISDATA(hdlg);
    pintshcut = pisdata->GetIntshcut();

    ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CIntshcut));

    //  TODO: Inform the subsmgr of any URL changes!  IE 4 didn't handle this...

    hr = CopyDlgItemText(hdlg, IDC_URL, &pszURL);

    if (SUCCEEDED(hr))
    {
        LPCTSTR pcszURLToUse;
        TCHAR szURL[MAX_URL_STRING];

        pcszURLToUse = pszURL;

        if (hr == S_OK)
        {
            hr = IURLQualify(pszURL, UQF_DEFAULT, szURL, NULL, NULL);

            if (SUCCEEDED(hr))
            {
                pcszURLToUse = szURL;

                hr = ValidateURL(pcszURLToUse);

                if (FAILED(hr))
                {
                    hr = ComplainAboutURL(hdlg, pcszURLToUse, hr);
                  
                    if (FAILED(hr))
                        SetEditFocus(GetDlgItem(hdlg, IDC_URL));
                }
            }
        }
        else
        {
            // A blank URL is not OK.
            ASSERT(hr == S_FALSE);

            hr = ComplainAboutURL(hdlg, TEXT(""), URL_E_INVALID_SYNTAX);

            if (FAILED(hr))
                SetEditFocus(GetDlgItem(hdlg, IDC_URL));

        }

        if (SUCCEEDED(hr))
        {
            hr = pintshcut->SetURL(pcszURLToUse, 0);

            if (hr == S_OK)
            {
                WORD wHotkey;
                WORD wOldHotkey;
                BOOL bSubscribable;

                // Refresh URL in case it was changed by IURLQualify().

                SetISPSURL(hdlg, &bSubscribable);

#ifndef UNIX
                // IEUNIX : ( MAKE_OFFLINE disabled )
                if (!bSubscribable)
                {
                    EnableWindow(GetDlgItem(hdlg, IDC_MAKE_OFFLINE), FALSE);
                }

                // IEUNIX : Hot key and working directory are N/A on UNIX.
                wHotkey = (WORD)SendDlgItemMessage(hdlg, IDC_HOTKEY, HKM_GETHOTKEY, 0, 0);

                hr = pintshcut->GetHotkey(&wOldHotkey);
                if (hr == S_OK)
                {
                    hr = pintshcut->SetHotkey(wHotkey);
                    if (hr == S_OK)
                    {
                        TCHAR szFile[MAX_PATH];
                        hr = pintshcut->GetCurFile(szFile, SIZECHARS(szFile));
                        if (hr == S_OK)
                        {
                            if (RegisterGlobalHotkey(wOldHotkey, wHotkey, szFile))
                            {
                                if (pisdata->rgchIconFile[0])
                                {
                                    hr = pintshcut->SetIconLocation(pisdata->rgchIconFile, pisdata->niIcon);
                                }
                            }
                            else
                            {
                                hr = E_FAIL;
                            }
                        }
                    }
                }
#endif //!UNIX
                pintshcut->ChangeNotify(SHCNE_UPDATEITEM, 0);
            }
        }

        if (pszURL)
        {
            LocalFree(pszURL);
            pszURL = NULL;
        }
    }

    if (hr == S_OK)
        TraceMsg(TF_INTSHCUT, "InjectISPSData(): Injected property sheet data into Internet Shortcut successfully.");
    else
        TraceMsg(TF_WARNING, "InjectISPSData(): Failed to inject property sheet data into Internet Shortcut, returning %s.",
                     Dbg_GetHRESULTName(hr));

    return(hr);
}

HRESULT 
ISPSSave(
    HWND hdlg)
{
    HRESULT hr;
    PIntshcut pintshcut;

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    pintshcut = ISPS_GetThisPtr(hdlg);

    if (pintshcut->IsDirty() == S_OK)
    {
        hr = pintshcut->Save((LPCOLESTR)NULL, FALSE);

        if (hr == S_OK)
        {
            TraceMsg(TF_INTSHCUT, "ISPSSave(): Saved Internet Shortcut successfully.");
        }
        else
        {
            TraceMsg(TF_WARNING, "ISPSSave(): Save() failed, returning %s.",
                         Dbg_GetHRESULTName(hr));
            MLShellMessageBox(
                            hdlg,
                            MAKEINTRESOURCE(IDS_IS_APPLY_FAILED),
                            MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                            (MB_OK | MB_ICONEXCLAMATION));
        }
    }
    else
    {
        TraceMsg(TF_INTSHCUT, "ISPSSave(): Internet Shortcut unchanged.  No save required.");

        hr = S_OK;
    }

    return(hr);
}

BOOL 
ISPS_Notify(
    HWND hdlg, 
    WPARAM wParam, 
    LPARAM lParam)
{
    BOOL bMsgHandled = FALSE;

    // wParam may be any value.
    // lParam may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    switch (((NMHDR *)lParam)->code)
    {
        case PSN_APPLY:
        {
#ifndef UNIX
            // IEUNIX : ( MAKE_OFFLINE disabled )
            BOOL bSubscribed = IsDlgButtonChecked(hdlg, IDC_MAKE_OFFLINE);
            PISDATA pisdata = ISPS_GetPISDATA(hdlg);
            
            if (!bSubscribed)
            {
                pisdata->SubsHelper.DeleteSubscription();
            }
            else
            {
                pisdata->SubsHelper.SaveSubscription();
            }

#endif /* !UNIX */

            SetWindowLongPtr(hdlg, DWLP_MSGRESULT, ISPSSave(hdlg) == S_OK ?
                                                   PSNRET_NOERROR :
                                                   PSNRET_INVALID_NOCHANGEPAGE);
            bMsgHandled = TRUE;
            break;
        }

        case PSN_KILLACTIVE:
        {
            PISDATA pisdata = ISPS_GetPISDATA(hdlg);

            if (pisdata->bUserEditedPage)
            {
                // only try to inject the data if the user actually changed something
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, FAILED(InjectISPSData(hdlg)));
            }
            bMsgHandled = TRUE;
            break;
        }

        default:
            break;
    }

    return(bMsgHandled);
}

LPCTSTR 
ISPS_GetHelpFileFromControl(
    HWND hwndControl)
{
    LPCTSTR pcszHelpFile = NULL;
    int nControlID = 0;

    ASSERT(! hwndControl ||
           IS_VALID_HANDLE(hwndControl, WND));

    if (hwndControl)
    {
        nControlID = GetDlgCtrlID(hwndControl);

        switch (nControlID)
        {
            default:
                // URL help comes from the iexplore.hlp
                pcszHelpFile = s_cszIEHelpFile;
                break;

            // Other help is borrowed from the default Win95 help file.
            case IDC_ICON:
            case IDC_NAME:
            case IDC_HOTKEY_TEXT:
            case IDC_HOTKEY:
            case IDC_CHANGE_ICON:
                break;
        }
    }

    TraceMsg(TF_INTSHCUT, "ISPS_GetHelpFileFromControl(): Using %s for control %d (HWND %#lx).",
               pcszHelpFile ? pcszHelpFile : TEXT("default Win95 help file"),
               nControlID,
               hwndControl);

    ASSERT(! pcszHelpFile ||
           IS_VALID_STRING_PTR(pcszHelpFile, -1));

    return(pcszHelpFile);
}

INT_PTR 
CALLBACK 
ISPS_DlgProc(
    HWND hdlg, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam)
{
    BOOL bMsgHandled = FALSE;

    // uMsg may be any value.
    // wParam may be any value.
    // lParam may be any value.

    ASSERT(IS_VALID_HANDLE(hdlg, WND));

    switch (uMsg)
    {
        case WM_INITDIALOG:
            bMsgHandled = ISPS_InitDialog(hdlg, wParam, lParam);
            break;

        case WM_DESTROY:
            bMsgHandled = ISPS_Destroy(hdlg, wParam, lParam);
            break;

        case WM_COMMAND:
            bMsgHandled = ISPS_Command(hdlg, wParam, lParam);
            break;

        case WM_NOTIFY:
            bMsgHandled = ISPS_Notify(hdlg, wParam, lParam);
            break;

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND)(((LPHELPINFO)lParam)->hItemHandle),
                    ISPS_GetHelpFileFromControl((HWND)(((LPHELPINFO)lParam)->hItemHandle)),
                    HELP_WM_HELP, (DWORD_PTR)(PVOID)c_rgdwHelpIDs);
            bMsgHandled = TRUE;
            break;

        case WM_CONTEXTMENU:
        {
            HWND hwnd;

            if (!IS_WM_CONTEXTMENU_KEYBOARD(lParam))
            {
                POINT pt;
                LPARAM_TO_POINT(lParam, pt);
                EVAL(ScreenToClient(hdlg, &pt));
                hwnd = ChildWindowFromPoint(hdlg, pt);
            }
            else
            {
                // For some reason on the keyboard case we don't actually
                // come to this WM_CONTEXTMENU handler -- someone somewhere
                // else is popping up the menu at the cursor instead of on
                // this hwnd...
                //
                hwnd = GetFocus();
            }

            SHWinHelpOnDemandWrap((HWND)wParam,
                    ISPS_GetHelpFileFromControl(hwnd),
                    HELP_CONTEXTMENU, (DWORD_PTR)(PVOID)c_rgdwHelpIDs);
            bMsgHandled = TRUE;
            break;
        }
        
        default:
           break;
    }

    return(bMsgHandled);
}

HRESULT AddISPage(HPROPSHEETPAGE * phpsp,
                  PROPSHEETPAGE * ppsp,
                  LPFNADDPROPSHEETPAGE pfnAddPage,
                  LPARAM lParam)
{
    HRESULT hres;
    
    ASSERT(phpsp);
    ASSERT(ppsp);
    
    *phpsp = Whistler_CreatePropertySheetPageW(ppsp);
    
    if (NULL == *phpsp)
    {
        hres = E_OUTOFMEMORY;
    }
    else
    {
        if ( !(*pfnAddPage)(*phpsp, lParam) )
        {
            DestroyPropertySheetPage(*phpsp);
            *phpsp = NULL;
            hres = E_OUTOFMEMORY;
        }
        else
        {
            hres = NO_ERROR;
        }
    }
    return hres;
}

HRESULT AddISPS(PIntshcut pintshcut, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    HRESULT hr;
    PISDATA pisdata;
    
    // lParam may be any value.
    
    ASSERT(IS_VALID_STRUCT_PTR(pintshcut, CIntshcut));
    ASSERT(IS_VALID_CODE_PTR(pfnAddPage, LPFNADDPROPSHEETPAGE));
    
    // Initialize instance data between property pages
    
    pisdata = new ISDATA;
    if ( !pisdata )
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        PROPSHEETPAGE psp;
        HPROPSHEETPAGE hpsp;
        WCHAR *pwszURL;

        hr = pintshcut->GetURLW(&pwszURL);

        if (SUCCEEDED(hr))
        {
            pisdata->SetIntshcut(pintshcut);
            pisdata->SubsHelper.Init();
            SHFree(pwszURL);
            
            ASSERT(IS_VALID_STRUCT_PTR(pisdata, ISDATA));
            
            // Add the Internet Shortcut page
            
            ZeroMemory(&psp, SIZEOF(psp));
            psp.dwSize       = SIZEOF(psp);
            psp.dwFlags      = PSP_DEFAULT | PSP_USECALLBACK;
            psp.hInstance    = MLGetHinst();
            psp.pszTemplate  = MAKEINTRESOURCE(IDD_INTSHCUT_PROP);
            psp.pfnDlgProc   = &ISPS_DlgProc;
            psp.lParam       = (LPARAM)pisdata;
            psp.pfnCallback  = &ISPSCallback;
            
            hr = AddISPage(&hpsp, &psp, pfnAddPage, lParam);

            if (SUCCEEDED(hr) && (pisdata->SubsHelper.m_dwFlags & ISF_STARTSUBSCRIBED))
            {
                HRESULT hrTmp = pisdata->SubsHelper.DoShellExtInit(pisdata->GetIntshcut()->GetInitDataObject());

                if (SUCCEEDED(hrTmp))
                {
                    ISubscriptionMgr2 *pSubsMgr2;

                    hrTmp = pisdata->SubsHelper.GetSubsMgr2(&pSubsMgr2, FIEF_FLAG_PEEK | FIEF_FLAG_FORCE_JITUI);

                    if (SUCCEEDED(hrTmp))
                    {
                        IShellPropSheetExt *pspse;

                        hrTmp = pSubsMgr2->QueryInterface(IID_PPV_ARG(IShellPropSheetExt, &pspse));

                        if (SUCCEEDED(hrTmp))
                        {
                            hrTmp = pspse->AddPages(pfnAddPage, lParam);
                            pspse->Release();
                        }

                        pSubsMgr2->Release();
                    }
                }
            }
        }
        
        if (FAILED(hr))
        {
            delete pisdata;
            pisdata = NULL;
        }
    }
    
    return hr;
}

// IShellExtInit::Initialize method for Intshcut

STDMETHODIMP Intshcut::Initialize(LPCITEMIDLIST pcidlFolder, IDataObject * pido, HKEY hkeyProgID)
{
    HRESULT hr;
    STGMEDIUM stgmed;
    FORMATETC fmtetc = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    ASSERT(NULL != pido);
    
    if (m_pInitDataObject)
    {
        m_pInitDataObject->Release();
    }
    m_pInitDataObject = pido;
    m_pInitDataObject->AddRef();

    hr = pido->GetData(&fmtetc, &stgmed);
    if (hr == S_OK)
    {
        TCHAR szPath[MAX_PATH];
        if (DragQueryFile((HDROP)stgmed.hGlobal, 0, szPath, SIZECHARS(szPath)))
        {
            m_fProbablyDefCM = TRUE;
            hr = LoadFromFile(szPath);
        }

        ReleaseStgMedium(&stgmed);
    }

    return(hr);
}

// IShellPropSheetExt::AddPages method for Intshcut

STDMETHODIMP Intshcut::AddPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_CODE_PTR(pfnAddPage, LPFNADDPROPSHEETPAGE));

    HRESULT hres = AddISPS(this, pfnAddPage, lParam);
    if (SUCCEEDED(hres))
    {
        // Make the Internet Shortcut page be the default page
        hres = ResultFromShort(1);  
    }

    return hres;
}

STDMETHODIMP Intshcut::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE pfnReplaceWith, LPARAM lParam)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\multimon.cpp ===
#include "priv.h"
//=============================================================================
//
// This function defines the MULTIMON stub module that fakes multiple monitor 
// apis on pre Memphis Win32 OSes
// this is the only file that defines COMPILE_MULTIMON_STUBS 
//=============================================================================

#define COMPILE_MULTIMON_STUBS
#include "multimon.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\mruex.cpp ===
#include "priv.h"
#include <strsafe.h>
#pragma hdrstop

// this is swiped from comctl32\mru.c

#define SLOT_LOADED     0x01
#define SLOT_USED       0x02

typedef struct _SLOTITEMDATA
{
    DWORD state;
    DWORD cb;
    BYTE  *p;
} SLOTITEMDATA;


class CMruBase : public IMruDataList
{
public:
    CMruBase() : _cRef(1) {}
    //  IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvOut);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    //  IMruDataList (maybe?)
    STDMETHODIMP InitData(
        UINT uMax,
        MRULISTF flags,
        HKEY hKey,
        LPCWSTR pszSubKey,
        MRUDATALISTCOMPARE pfnCompare);
        
    STDMETHODIMP AddData(const BYTE *pData, DWORD cbData, DWORD *pdwSlot);
    STDMETHODIMP FindData(const BYTE *pData, DWORD cbData, int *piIndex);
    STDMETHODIMP GetData(int iIndex, BYTE *pData, DWORD cbData);
    STDMETHODIMP QueryInfo(int iIndex, DWORD *pdwSlot, DWORD *pcbData);
    STDMETHODIMP Delete(int iItem);
    
protected:
    virtual ~CMruBase();

    HRESULT _GetItem(int iIndex, SLOTITEMDATA **ppitem);
    HRESULT _GetSlotItem(DWORD dwSlot, SLOTITEMDATA **ppitem);
    HRESULT _LoadItem(DWORD dwSlot);
    HRESULT _AddItem(DWORD dwSlot, const BYTE *pData, DWORD cbData);
    void _DeleteItem(DWORD dwSlot);
    HRESULT _UseEmptySlot(DWORD *pdwSlot);
    void _CheckUsedSlots();

    //  virtuals that are optionally implemented
    virtual BOOL _IsEqual(SLOTITEMDATA *pitem, const BYTE *pData, DWORD cbData);
    virtual void _DeleteValue(LPCWSTR psz);

    //  virtuals that must be implemented
    virtual HRESULT _InitSlots() = 0;
    virtual void _SaveSlots() = 0;
    virtual DWORD _UpdateSlots(int iIndex) = 0;
    virtual void _SlotString(DWORD dwSlot, LPWSTR psz, DWORD cch) = 0;
    virtual HRESULT _GetSlot(int iIndex, DWORD *pdwSlot) = 0;
    virtual HRESULT _RemoveSlot(int iIndex, DWORD *pdwSlot) = 0;

protected:
    LONG _cRef;
    MRULISTF _flags;
    BOOL _fDirty;
    BOOL _fSlotsChecked;
    HKEY _hkMru;
    int _cMaxSlots;
    int _cUsedSlots;
    MRUDATALISTCOMPARE _pfnCompare;
    SLOTITEMDATA *_pItems;
};

class CMruLongList : public CMruBase
{

protected:
    virtual ~CMruLongList() { if (_rgdwSlots) { LocalFree(_rgdwSlots); _rgdwSlots = NULL; } }

    void _ImportShortList();

    virtual HRESULT _InitSlots();
    virtual void _SaveSlots();
    virtual DWORD _UpdateSlots(int iIndex);
    virtual void _SlotString(DWORD dwSlot, LPWSTR psz, DWORD cch);
    virtual HRESULT _GetSlot(int iIndex, DWORD *pdwSlot);
    virtual HRESULT _RemoveSlot(int iIndex, DWORD *pdwSlot);

private:
    DWORD *_rgdwSlots;
};

STDMETHODIMP_(ULONG) CMruBase::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

#define szMRUEX         TEXT("MRUListEx")
#define szMRUEX_OLD     TEXT("MRUList")

STDMETHODIMP_(ULONG) CMruBase::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        _SaveSlots();
        delete this;
    }
    return cRef;
}

STDMETHODIMP CMruBase::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMruBase, IMruDataList),                      // IID_IMruDataList
        { 0 },                             
    };

    return QISearch(this, qit, riid, ppvObj);
}

CMruBase::~CMruBase()
{
    if (_hkMru)
        RegCloseKey(_hkMru);

    if (_pItems)
    {
        for (int i = 0; i < _cUsedSlots; i++)
        {
            if (_pItems[i].p)
            {
                LocalFree(_pItems[i].p);
                _pItems[i].p = NULL;
            }
        }

        LocalFree(_pItems);
        _pItems = NULL;
    }
}

class CMruShortList : public CMruBase
{
protected:
    virtual ~CMruShortList() { if (_rgchSlots) { LocalFree(_rgchSlots); _rgchSlots = NULL; } }

    virtual HRESULT _InitSlots();
    virtual void _SaveSlots();
    virtual DWORD _UpdateSlots(int iIndex);
    virtual void _SlotString(DWORD dwSlot, LPWSTR psz, DWORD cch);
    virtual HRESULT _GetSlot(int iIndex, DWORD *pdwSlot);
    virtual HRESULT _RemoveSlot(int iIndex, DWORD *pdwSlot);

    friend class CMruLongList;
    
private:
    WCHAR *_rgchSlots;
};

HRESULT CMruShortList::_InitSlots()
{
    HRESULT hr = E_OUTOFMEMORY;
    
    DWORD cb = (_cMaxSlots + 1) * sizeof(_rgchSlots[0]);
    _rgchSlots = (WCHAR *) LocalAlloc(LPTR, cb);

    if (_rgchSlots)
    {
        // Do we already have the new MRU Index?
        // Then validate it.  You can never trust the registry not to be corrupted.
        // Must be at least the size of a DWORD
        // Must be a multiple of DWORD in length
        // Must end in a -1
        if (NOERROR == SHGetValue(_hkMru, NULL, szMRUEX_OLD, NULL, (LPBYTE)_rgchSlots, &cb))
        {
            ASSERT(!(cb % 2));
            _cUsedSlots = (cb / sizeof(_rgchSlots[0])) - 1;
            ASSERT(_rgchSlots[_cUsedSlots] == 0);
        }

        _rgchSlots[_cUsedSlots] = 0;
        hr = S_OK;
    }

    return hr;
}

void CMruShortList::_SaveSlots()
{
    if (_fDirty)
    {
        SHSetValue(_hkMru, NULL, szMRUEX_OLD, REG_SZ, (BYTE *)_rgchSlots, sizeof(_rgchSlots[0]) * (_cUsedSlots + 1));
        _fDirty = FALSE;
    }
}

#define BASE_CHAR TEXT('a')
void CMruShortList::_SlotString(DWORD dwSlot, LPWSTR psz, DWORD cch)
{
    if (cch > 1)
    {
        psz[0] = (WCHAR) dwSlot + BASE_CHAR;
        psz[1] = 0;
    }
}

HRESULT CMruShortList::_GetSlot(int iIndex, DWORD *pdwSlot)
{
    HRESULT hr = E_FAIL;
    
    if (iIndex < _cUsedSlots)
    {
        //  its in our range of allocated slots
        if (_rgchSlots[iIndex] - BASE_CHAR < _cMaxSlots)
        {
            *pdwSlot = _rgchSlots[iIndex] - BASE_CHAR;
            _pItems[*pdwSlot].state |= SLOT_USED;
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CMruShortList::_RemoveSlot(int iIndex, DWORD *pdwSlot)
{
    HRESULT hr = _GetSlot(iIndex, pdwSlot);

    if (SUCCEEDED(hr))
    {
        //  MoveMemory() handles overlapping ranges
        // Sure it looks like you should use "_cUsedSlots - iIndex - 1" for the size, but
        // _cUsedSlots is the highest used index not the size
        MoveMemory(&_rgchSlots[iIndex], &_rgchSlots[iIndex+1], (_cUsedSlots - iIndex) * sizeof(_rgchSlots[0]));
        _cUsedSlots--;
        //  unuse the slot
        _pItems->state &= ~SLOT_USED;
        _fDirty = TRUE;
    }
    return hr;
}

DWORD CMruShortList::_UpdateSlots(int iIndex)
{
    //  need to move this away
    DWORD dwSlot;
    DWORD cb = iIndex * sizeof(_rgchSlots[0]);

    if (iIndex != _cUsedSlots)
        dwSlot = _rgchSlots[iIndex] - BASE_CHAR;
    else
    {
        //  we are at the end of the list
        //  see if we can grow
        //  find the first unused slot
        if (SUCCEEDED(_UseEmptySlot(&dwSlot)))
        {
            //  need to move the terminator
            cb += sizeof(_rgchSlots[0]);
        }
        else
        {
            //  dont move the the terminator
            //  and dont move the last slot
            dwSlot = _rgchSlots[_cUsedSlots - 1] - BASE_CHAR;
            cb -= sizeof(_rgchSlots[0]);
        }
    }

    if (cb)
    {
        //  MoveMemory() handles overlapping ranges
        MoveMemory(&_rgchSlots[1], &_rgchSlots[0], cb);
        _rgchSlots[0] = (WCHAR) dwSlot + BASE_CHAR;
        _fDirty = TRUE;
    }

    return dwSlot;
}

HRESULT CMruBase::InitData(
        UINT uMax,
        MRULISTF flags,
        HKEY hKey,
        LPCWSTR pszSubKey,
        MRUDATALISTCOMPARE pfnCompare)
{
    HRESULT hr = E_FAIL;
    _flags = flags;
    _pfnCompare = pfnCompare;
    _cMaxSlots = uMax;

    if (pszSubKey)
    {
        RegCreateKeyEx(hKey, pszSubKey, 0L, NULL, 0, MAXIMUM_ALLOWED, NULL, &_hkMru, NULL);
    }
    else
        _hkMru = SHRegDuplicateHKey(hKey);

    if (_hkMru)
    {
        _pItems = (SLOTITEMDATA *) LocalAlloc(LPTR, sizeof(SLOTITEMDATA) * _cMaxSlots);
        if (_pItems)
            hr = _InitSlots();
        else    
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

void CMruBase::_CheckUsedSlots()
{
    ASSERT(!_fSlotsChecked);
    DWORD dwSlot;
    for (int i = 0; i < _cUsedSlots; i++)
    {
        _GetSlot(i, &dwSlot);
    }
    
    _fSlotsChecked = TRUE;
}

HRESULT CMruBase::_AddItem(DWORD dwSlot, const BYTE *pData, DWORD cbData)
{
    SLOTITEMDATA *pitem = &_pItems[dwSlot];
    WCHAR szSlot[12];
    _SlotString(dwSlot, szSlot, ARRAYSIZE(szSlot));

    HRESULT hr = E_OUTOFMEMORY;
    
    if (NOERROR == SHSetValue(_hkMru, NULL, szSlot, REG_BINARY, pData, cbData))
    {
        if (cbData >= pitem->cb || !pitem->p)
        {
            if (pitem->p)
                LocalFree(pitem->p);

            // Binary data has the size at the begining so we'll need a little extra room.
            pitem->p = (BYTE *)LocalAlloc(LPTR, cbData);
        }

        if (pitem->p)
        {
            pitem->cb = cbData;
            pitem->state = (SLOT_LOADED | SLOT_USED);
            memcpy(pitem->p, pData, cbData);
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CMruBase::AddData(const BYTE *pData, DWORD cbData, DWORD *pdwSlot)
{
    HRESULT hr = E_FAIL;
    int iIndex;
    DWORD dwSlot;
    if (SUCCEEDED(FindData(pData, cbData, &iIndex)))
    {
        dwSlot = _UpdateSlots(iIndex);
        hr = S_OK;
    }
    else
    {
        dwSlot = _UpdateSlots(_cUsedSlots);

        hr = _AddItem(dwSlot, pData, cbData);
    }

    if (SUCCEEDED(hr) && pdwSlot)
        *pdwSlot = dwSlot;

    return hr;
}

BOOL CMruBase::_IsEqual(SLOTITEMDATA *pitem, const BYTE *pData, DWORD cbData)
{
    BOOL fRet = FALSE;
    if (_pfnCompare)
    {
        fRet = (0 == _pfnCompare(pData, pitem->p, cbData));
    }
    else
    {
        switch (_flags & 0xf)
        {
        case MRULISTF_USE_MEMCMP:
            if (pitem->cb == cbData)
                fRet = (0 == memcmp(pData, pitem->p, min(cbData, pitem->cb)));
            break;

        case MRULISTF_USE_STRCMPIW:
            fRet = (0 == StrCmpIW((LPCWSTR)pData, (LPCWSTR)pitem->p));
            break;
            
        case MRULISTF_USE_STRCMPW:
            fRet = (0 == StrCmpW((LPCWSTR)pData, (LPCWSTR)pitem->p));
            break;
            
        case MRULISTF_USE_ILISEQUAL:
            fRet = ILIsEqual((LPCITEMIDLIST)pData, (LPCITEMIDLIST)pitem->p);
            break;
        }
    }

    return fRet;
}

HRESULT CMruBase::FindData(const BYTE *pData, DWORD cbData, int *piIndex)
{
    HRESULT hr = E_FAIL;
    
    for (int iIndex = 0; iIndex < _cUsedSlots ; iIndex++)
    {
        SLOTITEMDATA *pitem;
        if (SUCCEEDED(_GetItem(iIndex, &pitem)))
        {
            if (_IsEqual(pitem, pData, cbData))
            {
                hr = S_OK;
                *piIndex = iIndex;
                break;
            }
        }
    }

    return hr;
}

HRESULT CMruBase::_LoadItem(DWORD dwSlot)
{
    SLOTITEMDATA *pitem = &_pItems[dwSlot];
    DWORD cb;
    WCHAR szSlot[12];
    _SlotString(dwSlot, szSlot, ARRAYSIZE(szSlot));

    ASSERT(!(pitem->state & SLOT_LOADED));
    ASSERT(pitem->state & SLOT_USED);
    
    if (NOERROR == SHGetValue(_hkMru, NULL, szSlot, NULL, NULL, &cb) && cb)
    {
        // Binary data has the size at the begining so we'll need a little extra room.
        pitem->p = (BYTE *)LocalAlloc(LPTR, cb);

        if (pitem->p)
        {
            pitem->cb = cb;

            if (NOERROR != SHGetValue(_hkMru, NULL, szSlot, NULL, pitem->p, &cb))
            {
                LocalFree(pitem->p);
                pitem->p = NULL;
            }
        }
    }
    pitem->state |= SLOT_LOADED;

    return pitem->p ? S_OK : E_FAIL;
}

HRESULT CMruBase::_GetSlotItem(DWORD dwSlot, SLOTITEMDATA **ppitem)
{
    HRESULT hr = S_OK;
    ASSERT(dwSlot < (DWORD)_cMaxSlots);
    
    if (!(_pItems[dwSlot].state & SLOT_LOADED))
        _LoadItem(dwSlot);

    if (_pItems[dwSlot].p)
    {
        *ppitem = &_pItems[dwSlot];
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

HRESULT CMruBase::_GetItem(int iIndex, SLOTITEMDATA **ppitem)
{
    DWORD dwSlot;
    HRESULT hr = _GetSlot(iIndex, &dwSlot);

    if (SUCCEEDED(hr))
    {
        hr = _GetSlotItem(dwSlot, ppitem);
    }

    return hr;
}
        
HRESULT CMruBase::GetData(int iIndex, BYTE *pData, DWORD cbData)
{
    SLOTITEMDATA *pitem;
    HRESULT hr = _GetItem(iIndex, &pitem);
    if (SUCCEEDED(hr))
    {
        if (pitem->cb <= cbData)
        {
            memcpy(pData, pitem->p, min(cbData, pitem->cb));
        }
        else
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    return hr;
}

HRESULT CMruBase::QueryInfo(int iIndex, DWORD *pdwSlot, DWORD *pcbData)
{
    DWORD dwSlot;
    HRESULT hr = _GetSlot(iIndex, &dwSlot);

    if (SUCCEEDED(hr))
    {
        if (pdwSlot)
            *pdwSlot = dwSlot;
            
        if (pcbData)
        {
            SLOTITEMDATA *pitem;
            hr = _GetSlotItem(dwSlot, &pitem);
            if (SUCCEEDED(hr))
            {
                *pcbData = pitem->cb;
            }
        }
    }

    return hr;
}
        
HRESULT CMruBase::_UseEmptySlot(DWORD *pdwSlot)
{
    HRESULT hr = E_FAIL;

    if (!_fSlotsChecked)
        _CheckUsedSlots();
        
    for (DWORD dw = 0; dw < (DWORD) _cMaxSlots; dw++)
    {
        if (!(_pItems[dw].state & SLOT_USED))
        {
            _pItems[dw].state |= SLOT_USED;
            *pdwSlot = dw;
            _cUsedSlots++;
            hr = S_OK;
            break;
        }
    }

    return hr;
}

void CMruBase::_DeleteValue(LPCWSTR psz)
{
    SHDeleteValue(_hkMru, NULL, psz);
}

void CMruBase::_DeleteItem(DWORD dwSlot)
{
    ASSERT(dwSlot < (DWORD) _cMaxSlots);

    WCHAR szSlot[12];
    _SlotString(dwSlot, szSlot, ARRAYSIZE(szSlot));
    _DeleteValue(szSlot);

    if (_pItems[dwSlot].p)
    {
        LocalFree(_pItems[dwSlot].p);
        _pItems[dwSlot].p = NULL;
    }
}
    
HRESULT CMruBase::Delete(int iIndex)
{
    DWORD dwSlot;
    HRESULT hr = _RemoveSlot(iIndex, &dwSlot);

    if (SUCCEEDED(hr))
    {
        _DeleteItem(dwSlot);
    }

    return hr;
}

void CMruLongList::_ImportShortList()
{
    CMruShortList *pmru = new CMruShortList();

    if (pmru)
    {
        if (SUCCEEDED(pmru->InitData(_cMaxSlots, 0, _hkMru, NULL, NULL)))
        {
            //  we need to walk the list
            DWORD dwSlot;
            SLOTITEMDATA *pitem;
            
            while (SUCCEEDED(pmru->_GetSlot(_cUsedSlots, &dwSlot))
            &&  SUCCEEDED(pmru->_GetSlotItem(dwSlot, &pitem)))
            {
                //  we just copy to ourselves
                _AddItem(dwSlot, pitem->p, pitem->cb);
                pmru->_DeleteItem(dwSlot);

                //  dont use _UpdateSlots() here
                _rgdwSlots[_cUsedSlots] = dwSlot;
                _cUsedSlots++;
            }

            _fDirty = TRUE;
        }

        pmru->Release();

        //  wipe it out
        SHDeleteValue(_hkMru, NULL, szMRUEX_OLD);
    }
}


HRESULT CMruLongList::_InitSlots()
{
    HRESULT hr = E_OUTOFMEMORY;
    
    DWORD cb = (_cMaxSlots + 1) * sizeof(_rgdwSlots[0]);
    _rgdwSlots = (DWORD *) LocalAlloc(LPTR, cb);

    if (_rgdwSlots)
    {
        // Do we already have the new MRU Index?
        // Then validate it.  You can never trust the registry not to be corrupted.
        // Must be at least the size of a DWORD
        // Must be a multiple of DWORD in length
        // Must end in a -1
        if (NOERROR == SHGetValue(_hkMru, NULL, szMRUEX, NULL, (LPBYTE)_rgdwSlots, &cb))
        {
            ASSERT(!(cb % 4));
            _cUsedSlots = (cb / sizeof(_rgdwSlots[0])) - 1;
            ASSERT(_rgdwSlots[_cUsedSlots] == -1);
        }
        else
        {
            _ImportShortList();
        }

        _rgdwSlots[_cUsedSlots] = (DWORD)-1;
        hr = S_OK;
    }

    return hr;
}

void CMruLongList::_SaveSlots()
{
    if (_fDirty)
    {
        SHSetValue(_hkMru, NULL, szMRUEX, REG_BINARY, (BYTE *)_rgdwSlots, sizeof(_rgdwSlots[0]) * (_cUsedSlots + 1));
        _fDirty = FALSE;
    }
}

void CMruLongList::_SlotString(DWORD dwSlot, LPWSTR psz, DWORD cch)
{
    StringCchPrintf(psz, cch, L"%d", dwSlot);
}

HRESULT CMruLongList::_GetSlot(int iIndex, DWORD *pdwSlot)
{
    HRESULT hr = E_FAIL;
    
    ASSERT(iIndex < _cMaxSlots);
    if (iIndex < _cUsedSlots)
    {
        //  its in our range of allocated slots
        if (_rgdwSlots[iIndex] < (DWORD) _cMaxSlots)
        {
            *pdwSlot = _rgdwSlots[iIndex];
            _pItems[*pdwSlot].state |= SLOT_USED;
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CMruLongList::_RemoveSlot(int iIndex, DWORD *pdwSlot)
{
    HRESULT hr = _GetSlot(iIndex, pdwSlot);

    if (SUCCEEDED(hr))
    {
        //  MoveMemory() handles overlapping ranges
        // Sure it looks like you should use "_cUsedSlots - iIndex - 1" for the size, but
        // _cUsedSlots is the highest used index not the size
        MoveMemory(&_rgdwSlots[iIndex], &_rgdwSlots[iIndex+1], (_cUsedSlots - iIndex) * sizeof(_rgdwSlots[0]));
        _cUsedSlots--;
        //  unuse the slot
        _pItems->state &= ~SLOT_USED;
        _fDirty = TRUE;
    }
    return hr;
}

DWORD CMruLongList::_UpdateSlots(int iIndex)
{
    //  need to move this away
    DWORD dwSlot;
    DWORD cb = iIndex * sizeof(_rgdwSlots[0]);

    if (iIndex != _cUsedSlots)
        dwSlot = _rgdwSlots[iIndex];
    else
    {
        //  we are at the end of the list
        //  see if we can grow
        //  find the first unused slot
        if (SUCCEEDED(_UseEmptySlot(&dwSlot)))
        {
            //  need to move the terminator
            cb += sizeof(_rgdwSlots[0]);
        }
        else
        {
            //  dont move the the terminator
            //  and dont move the last slot
            dwSlot = _rgdwSlots[_cUsedSlots - 1];
            cb -= sizeof(_rgdwSlots[0]);
        }
    }

    if (cb)
    {
        //  MoveMemory() handles overlapping ranges
        MoveMemory(&_rgdwSlots[1], &_rgdwSlots[0], cb);
        _rgdwSlots[0] = dwSlot;
        _fDirty = TRUE;
    }

    return dwSlot;
}

STDAPI  CMruLongList_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    CMruLongList *p = new CMruLongList();
    if (p != NULL)
    {
        *ppunk = SAFECAST(p, IMruDataList *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}


class CMruPidlList;

class CMruNode : public CMruLongList
{
public:
    CMruNode(CMruNode *pnodeParent, DWORD dwSlot);
    HRESULT GetNode(BOOL fCreate, LPCITEMIDLIST pidlChild, CMruNode **ppnode);
    HRESULT RemoveLeast(DWORD *pdwSlotLeast);
    HRESULT BindToSlot(DWORD dwSlot, IShellFolder **ppsf);
    HRESULT Clear(CMruPidlList *proot);

    CMruNode *GetParent() 
        { if (_pnodeParent) _pnodeParent->AddRef(); return _pnodeParent;}

    HRESULT GetNodeSlot(DWORD *pdwNodeSlot)
        {
            DWORD cb = sizeof(*pdwNodeSlot);
            return NOERROR == SHGetValue(_hkMru, NULL, L"NodeSlot", NULL, pdwNodeSlot, pdwNodeSlot ? &cb : NULL) ? S_OK : E_FAIL;
        }

    HRESULT SetNodeSlot(DWORD dwNodeSlot)
        { return NOERROR == SHSetValue(_hkMru, NULL, L"NodeSlot", REG_DWORD, &dwNodeSlot, sizeof(dwNodeSlot)) ? S_OK : E_FAIL; }

protected:
    CMruNode() {}
    virtual ~CMruNode();
    virtual BOOL _IsEqual(SLOTITEMDATA *pitem, const BYTE *pData, DWORD cbData);
    virtual void _DeleteValue(LPCWSTR psz);

    HRESULT _GetPidlSlot(LPCITEMIDLIST pidlChild, BOOL fCreate, DWORD *pdwKidSlot);
    HRESULT _CreateNode(DWORD dwSlot, CMruNode **ppnode);
    BOOL _InitLate();

    HRESULT _FindPidl(LPCITEMIDLIST pidl, int *piIndex)
        { return FindData((LPBYTE)pidl, pidl->mkid.cb + sizeof(pidl->mkid.cb), piIndex); }

    HRESULT _AddPidl(DWORD dwSlot, LPCITEMIDLIST pidl)
        { return _AddItem(dwSlot, (LPBYTE)pidl, pidl->mkid.cb + sizeof(pidl->mkid.cb)); }

#ifdef DEBUG
    HRESULT _GetSlotName(DWORD dwSlot, LPWSTR psz, DWORD cch);
#endif

protected:
    DWORD _dwSlotSelf;
    CMruNode *_pnodeParent;
    IShellFolder *_psf;
};

class CMruPidlList  : public CMruNode
                    , public IMruPidlList
{
public:
    CMruPidlList() {}
    //  IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvOut);
    STDMETHODIMP_(ULONG) AddRef()
    {
        return CMruBase::AddRef();
    }

    STDMETHODIMP_(ULONG) Release()
    {
        return CMruBase::Release();
    }

    //  IMruPidlList
    STDMETHODIMP InitList(UINT uMax, HKEY hKey, LPCWSTR pszSubKey);
    STDMETHODIMP UsePidl(LPCITEMIDLIST pidl, DWORD *pdwSlot);
    STDMETHODIMP QueryPidl(LPCITEMIDLIST pidl, DWORD cSlots, DWORD *rgdwSlots, DWORD *pcSlotsFetched);
    STDMETHODIMP PruneKids(LPCITEMIDLIST pidl);

    HRESULT GetEmptySlot(DWORD *pdwSlot);
    void EmptyNodeSlot(DWORD dwNodeSlot);

protected:
    ~CMruPidlList() 
    { 
        if (_rgbNodeSlots) 
        { 
            LocalFree(_rgbNodeSlots); 
            _rgbNodeSlots = NULL; 
        } 

        if (_hMutex)
            CloseHandle(_hMutex);
    }
    
    BOOL _LoadNodeSlots();
    void _SaveNodeSlots();
    HRESULT _InitNodeSlots();

protected:
    BYTE *_rgbNodeSlots;
    int _cUsedNodeSlots ;
    HANDLE _hMutex;
};

CMruNode::CMruNode(CMruNode *pnodeParent, DWORD dwSlot)
    : _pnodeParent(pnodeParent), _dwSlotSelf(dwSlot)
{
    ASSERT(_cRef);
    _pnodeParent->AddRef();
}

CMruNode::~CMruNode()
{
    if (_pnodeParent)
        _pnodeParent->Release();
    if (_psf)
        _psf->Release();
}


HRESULT CMruNode::BindToSlot(DWORD dwSlot, IShellFolder **ppsf)
{
    SLOTITEMDATA *pitem;
    HRESULT hr = _GetSlotItem(dwSlot, &pitem);
    if (SUCCEEDED(hr))
    {
        hr = _psf->BindToObject((LPCITEMIDLIST)pitem->p, NULL, IID_PPV_ARG(IShellFolder, ppsf));
    }
    return hr;
}

#ifdef DEBUG
HRESULT CMruNode::_GetSlotName(DWORD dwSlot, LPWSTR psz, DWORD cch)
{
    SLOTITEMDATA *pitem;
    HRESULT hr = _GetSlotItem(dwSlot, &pitem);
    if (SUCCEEDED(hr))
    {
        hr = DisplayNameOf(_psf, (LPCITEMIDLIST)pitem->p, 0, psz, cch);
    }
    return hr;
}
#endif 

BOOL CMruNode::_IsEqual(SLOTITEMDATA *pitem, const BYTE *pData, DWORD cbData)
{
    return S_OK == IShellFolder_CompareIDs(_psf, SHCIDS_CANONICALONLY, (LPCITEMIDLIST)pitem->p, (LPCITEMIDLIST)pData);
}

HRESULT CMruNode::_CreateNode(DWORD dwSlot, CMruNode **ppnode)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMruNode *pnode = new CMruNode(this, dwSlot);
    if (pnode)
    {
        WCHAR szSlot[12];
        _SlotString(dwSlot, szSlot, ARRAYSIZE(szSlot));
        hr = pnode->InitData(_cMaxSlots, 0, _hkMru, szSlot, NULL);
        if (SUCCEEDED(hr))
            *ppnode = pnode;
        else
            pnode->Release();
    }
    return hr;
}

BOOL CMruNode::_InitLate()
{
    if (!_psf)
    {
        if (_pnodeParent)
        {
            _pnodeParent->BindToSlot(_dwSlotSelf, &_psf);
#ifdef DEBUG            
            WCHAR sz[MAX_PATH];
            if (SUCCEEDED(_pnodeParent->_GetSlotName(_dwSlotSelf, sz, ARRAYSIZE(sz))))
                SHSetValue(_hkMru, NULL, L"SlotName", REG_SZ, sz, CbFromCchW(lstrlen(sz) + 1));
#endif                
        }
        else
            SHGetDesktopFolder(&_psf);
    }
    return (_psf != NULL);
}

HRESULT CMruNode::_GetPidlSlot(LPCITEMIDLIST pidlChild, BOOL fCreate, DWORD *pdwKidSlot)
{
    HRESULT hr = E_OUTOFMEMORY;
    LPITEMIDLIST pidlFirst = ILCloneFirst(pidlChild);
    if (pidlFirst)
    {
        int iIndex;
        if (SUCCEEDED(_FindPidl(pidlFirst, &iIndex)))
        {
            *pdwKidSlot = _UpdateSlots(iIndex);
            hr = S_OK;
        }
        else if (fCreate)
        {
            *pdwKidSlot = _UpdateSlots(_cUsedSlots);
            hr = _AddPidl(*pdwKidSlot, pidlFirst);
        }
        ILFree(pidlFirst);
    }
    return hr;
}

HRESULT CMruNode::GetNode(BOOL fCreate, LPCITEMIDLIST pidlChild, CMruNode **ppnode)
{
    HRESULT hr = E_FAIL;
    if (ILIsEmpty(pidlChild))
    {
        *ppnode = this;
        AddRef();
        hr = S_OK;
    }
    else  if (_InitLate())
    {
        DWORD dwKidSlot;
        hr = _GetPidlSlot(pidlChild, fCreate, &dwKidSlot);

        if (SUCCEEDED(hr))
        {
            //  need to make another CMruNode
            CMruNode *pnode;
            hr = _CreateNode(dwKidSlot, &pnode);
            if (SUCCEEDED(hr))
            {
                //  need to save so that this node
                //  is updated so that it doesnt get
                //  deleted from under us.
                _SaveSlots();
                hr = pnode->GetNode(fCreate, _ILNext(pidlChild), ppnode);
                pnode->Release();
            }
        }

        if (FAILED(hr) && !fCreate)
        {
            *ppnode = this;
            AddRef();
            hr = S_FALSE;
        }
    }
    
    return hr;
}

void CMruNode::_DeleteValue(LPCWSTR psz)
{
    CMruBase::_DeleteValue(psz);
    SHDeleteKey(_hkMru, psz);
}

HRESULT CMruNode::RemoveLeast(DWORD *pdwSlotLeast)
{
    //  if this node has children
    //  then we attempt to call RemoveLeast on them
    ASSERT(_cUsedSlots >= 0);
    HRESULT hr = S_FALSE;
    if (_cUsedSlots)
    {
        DWORD dwLocalSlot;
        hr = _GetSlot(_cUsedSlots - 1, &dwLocalSlot);
        if (SUCCEEDED(hr))
        {
            CMruNode *pnode;
            hr = _CreateNode(dwLocalSlot, &pnode);
            if (SUCCEEDED(hr))
            {
                hr = pnode->RemoveLeast(pdwSlotLeast);
                pnode->Release();
            }

            //  S_FALSE means that this node needs
            //  needs deleting.  it is empty.
            if (hr == S_FALSE)
            {
                Delete(_cUsedSlots - 1);

                //  if we still have kids, or have a NodeSlot
                //  then we dont want to be deleted
                if (_cUsedSlots || SUCCEEDED(GetNodeSlot(NULL)))
                    hr = S_OK;
            }
        }
    }
    else
    {
        //  this is the empty node
        //  delete me if you can
        ASSERT(!*pdwSlotLeast);
        GetNodeSlot(pdwSlotLeast);
    }
    return hr;
}

HRESULT CMruNode::Clear(CMruPidlList *proot)
{
    DWORD dwLocalSlot;
    while (SUCCEEDED(_GetSlot(0, &dwLocalSlot)))
    {
        CMruNode *pnode;
        if (SUCCEEDED(_CreateNode(dwLocalSlot, &pnode)))
        {
            //  tell the root about it
            DWORD dwNodeSlot;
            if (SUCCEEDED(pnode->GetNodeSlot(&dwNodeSlot)))
                proot->EmptyNodeSlot(dwNodeSlot);

            pnode->Clear(proot);
            pnode->Release();
        }

        Delete(0);

    }
    return S_OK;
}

class CSafeMutex
{
public:
    CSafeMutex() : _h(0) {}
    ~CSafeMutex() { if (_h) ReleaseMutex(_h); }
    
    HRESULT Enter(HANDLE hMutex)
    {
        //  this is usually done on the UI thread
        //  wait for half a second or dont bother
        HRESULT hr;
        DWORD dwWait = WaitForSingleObject(hMutex, 500);
        if (dwWait == WAIT_OBJECT_0)
        {
            _h = hMutex;
            hr = S_OK;
        }
        else
            hr = E_FAIL;
            
        return hr;
    }
private:
    HANDLE _h;
};
    

HRESULT CMruPidlList::UsePidl(LPCITEMIDLIST pidl, DWORD *pdwSlot)
{
    CSafeMutex sm;
    HRESULT hr = sm.Enter(_hMutex);
    if (SUCCEEDED(hr))
    {
        CMruNode *pnode;
        hr = GetNode(TRUE, pidl, &pnode);
        *pdwSlot = 0;
        if (SUCCEEDED(hr))
        {
            ASSERT(hr == S_OK);
            hr = pnode->GetNodeSlot(pdwSlot);

            if (FAILED(hr))
            {
                hr = GetEmptySlot(pdwSlot);
                if (SUCCEEDED(hr))
                {
                    hr = pnode->SetNodeSlot(*pdwSlot);
                }
            }
            pnode->Release();
        }
    }
    return hr;
}
       
HRESULT CMruPidlList::QueryPidl(LPCITEMIDLIST pidl, DWORD cSlots, DWORD *rgdwSlots, DWORD *pcSlotsFetched)
{
    CSafeMutex sm;
    HRESULT hr = sm.Enter(_hMutex);
    if (SUCCEEDED(hr))
    {
        CMruNode *pnode;
        hr = GetNode(FALSE, pidl, &pnode);
        *pcSlotsFetched = 0;
        if (SUCCEEDED(hr))
        {
            while (*pcSlotsFetched < cSlots && pnode)
            {
                CMruNode *pnodeParent = pnode->GetParent();
                if (SUCCEEDED(pnode->GetNodeSlot(&rgdwSlots[*pcSlotsFetched])))
                {
                    (*pcSlotsFetched)++;
                }
                else if (hr == S_OK && !*pcSlotsFetched)
                {
                    //  we found the exact node
                    //  but we couldnt get the NodeSlot from it
                    hr = S_FALSE;
                }
                    
                pnode->Release();
                pnode = pnodeParent;
            }

            if (pnode)
                pnode->Release();
        }

        if (SUCCEEDED(hr) && !*pcSlotsFetched)
            hr = E_FAIL;
    }
    return hr;
}

HRESULT CMruPidlList::PruneKids(LPCITEMIDLIST pidl)
{
    CSafeMutex sm;
    HRESULT hr = sm.Enter(_hMutex);
    if (SUCCEEDED(hr))
    {
        if (_LoadNodeSlots())
        {
            CMruNode *pnode;
            hr = GetNode(FALSE, pidl, &pnode);
            if (SUCCEEDED(hr))
            {    
                if (hr == S_OK)
                {
                    hr = pnode->Clear(this);
                }
                else
                    hr = E_FAIL;
                    
                pnode->Release();
            }
            _SaveNodeSlots();
        }
    }
    return hr;
}

            
STDMETHODIMP CMruPidlList::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMruPidlList, IMruPidlList),                      // IID_IMruDataList
        { 0 },                             
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CMruPidlList::InitList(UINT uMax, HKEY hKey, LPCWSTR pszSubKey)
{
    HRESULT hr = InitData(uMax, 0, hKey, pszSubKey, NULL);
    if (SUCCEEDED(hr))
    {
        hr = _InitNodeSlots();
        if (SUCCEEDED(hr))
        {
            _hMutex = CreateMutex(NULL, FALSE, TEXT("Shell.CMruPidlList"));
            if (!_hMutex)
                hr = ResultFromLastError();
        }
    }
    return hr;
}

BOOL CMruPidlList::_LoadNodeSlots()
{
    DWORD cb = (_cMaxSlots) * sizeof(_rgbNodeSlots[0]);
    if (NOERROR == SHGetValue(_hkMru, NULL, L"NodeSlots", NULL, _rgbNodeSlots , &cb))
    {
        _cUsedNodeSlots = (cb / sizeof(_rgbNodeSlots[0]));
        return TRUE;
    }
    return FALSE;
}

void CMruPidlList::_SaveNodeSlots()
{
    SHSetValue(_hkMru, NULL, L"NodeSlots", REG_BINARY, _rgbNodeSlots , _cUsedNodeSlots);
}

HRESULT CMruPidlList::_InitNodeSlots()
{
    HRESULT hr = E_OUTOFMEMORY;
    
    DWORD cb = (_cMaxSlots) * sizeof(_rgbNodeSlots[0]);
    _rgbNodeSlots = (BYTE *) LocalAlloc(LPTR, cb);

    if (_rgbNodeSlots)
    {
        _LoadNodeSlots();
        _fDirty = TRUE;
        _SaveNodeSlots();
        hr = S_OK;
    }

    return hr;
}

void CMruPidlList::EmptyNodeSlot(DWORD dwNodeSlot)
{
    ASSERT(dwNodeSlot <= (DWORD)_cMaxSlots);
    _rgbNodeSlots[dwNodeSlot-1] = FALSE;
    _fDirty = TRUE;
}

HRESULT CMruPidlList::GetEmptySlot(DWORD *pdwSlot)
{
    HRESULT hr = E_FAIL;
    *pdwSlot = 0;
    if (_LoadNodeSlots())
    {
        if (_cUsedNodeSlots < _cMaxSlots)
        {
            //  then we can just use the next most natural 
            //  node slot
            _rgbNodeSlots[_cUsedNodeSlots] = SLOT_USED;
            *pdwSlot = ++_cUsedNodeSlots;
            hr = S_OK;
        }
        else
        {
            //  if we can find an empty in the list...

            for (int i = 0; i < _cUsedNodeSlots; i++)
            {
                if (!(_rgbNodeSlots[i] & SLOT_USED))
                {
                    _rgbNodeSlots[i] = SLOT_USED;
                    *pdwSlot = i+1;
                    hr = S_OK;
                    break;
                }
            }

            if (FAILED(hr))
            {
                //  we need to find the LRU slot
                if (SUCCEEDED(RemoveLeast(pdwSlot)) && *pdwSlot)
                    hr = S_OK;
            }
        }
        _SaveNodeSlots();
    }

    return hr;
}

STDAPI  CMruPidlList_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    CMruPidlList *p = new CMruPidlList();
    if (p != NULL)
    {
        *ppunk = SAFECAST(p, IMruPidlList *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\isurl.cpp ===
/*
 * isurl.cpp - IUniformResourceLocator implementation for Intshcut class.
 */
#include "priv.h"
#include "ishcut.h"
#include "urlprop.h"
#include "shlwapi.h"
#include "infotip.h"
#include "resource.h"
#include <intshctp.h>

#include <mluisupp.h>

#define DM_PLUGGABLE DM_TRACE
#define DM_SHELLEXECOBJECT         0x80000000

extern HRESULT CreateTargetFrame(LPCOLESTR pszTargetName, LPUNKNOWN /*IN,OUT*/ *ppunk);

BOOL
GetClassDefaultVerb(
    LPCTSTR pcszClass,
    LPTSTR  pszDefaultVerbBuf,
    UINT    cchBufLen)
{
    // No; get the default verb
    TCHAR szKey[MAX_PATH];

    StrCpyN(szKey, pcszClass, SIZECHARS(szKey));
    StrCatBuff(szKey, TEXT("\\"), SIZECHARS(szKey));
    StrCatBuff(szKey, TEXT("shell"), SIZECHARS(szKey));
    DWORD cbSize = CbFromCch(cchBufLen);

    if (NO_ERROR != SHGetValue(HKEY_CLASSES_ROOT, szKey, NULL, NULL, pszDefaultVerbBuf, &cbSize) 
    || !*pszDefaultVerbBuf)
    {
        // Default to "open" if the registry doesn't specify one
        StrCpyN(pszDefaultVerbBuf, TEXT("open"), cchBufLen);
    }

    return TRUE;
}


#ifdef DEBUG
BOOL
IsValidPCURLINVOKECOMMANDINFO(
    PCURLINVOKECOMMANDINFO pcurlici)
{
    return(IS_VALID_READ_PTR(pcurlici, CURLINVOKECOMMANDINFO) &&
           EVAL(pcurlici->dwcbSize >= SIZEOF(*pcurlici)) &&
           FLAGS_ARE_VALID(pcurlici->dwFlags, ALL_IURL_INVOKECOMMAND_FLAGS) &&
           (IsFlagClear(pcurlici->dwFlags, IURL_INVOKECOMMAND_FL_ALLOW_UI) ||
            NULL == pcurlici->hwndParent || 
            IS_VALID_HANDLE(pcurlici->hwndParent, WND)) &&
           (IsFlagSet(pcurlici->dwFlags, IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB) ||
            IS_VALID_STRING_PTR(pcurlici->pcszVerb, -1)));
}

#endif

/********************************** Methods **********************************/

typedef struct
{
    UINT idsVerb;
    UINT idsMenuHelp;
    LPCTSTR pszVerb;
} ISCM;

const static ISCM g_rgiscm[] =
{
    { IDS_MENUOPEN,         IDS_MH_OPEN,            TEXT("open") },         //  IDCMD_ISCM_OPEN 
    { IDS_SYNCHRONIZE,      IDS_MH_SYNCHRONIZE,     TEXT("update now")},    //  IDCMD_ISCM_SYNC 
    { IDS_MAKE_OFFLINE,     IDS_MH_MAKE_OFFLINE,    TEXT("subscribe")},     //  IDCMD_ISCM_SUB  
};

//  WARNING - these must match their index into g_rgiscm
#define IDCMD_ISCM_OPEN   0
#define IDCMD_ISCM_SYNC   1
#define IDCMD_ISCM_SUB    2

BOOL _IsSubscribed(LPCWSTR pszUrl, BOOL *pfSubscribable)
{
    BOOL fRet = FALSE;
    ISubscriptionMgr * pMgr;
    
    *pfSubscribable = FALSE;
    
    if (SUCCEEDED(CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ISubscriptionMgr, &pMgr))))
    {
        pMgr->IsSubscribed(pszUrl, &fRet);

                        
        pMgr->Release();
    }

    if (!fRet)
    {
        //test if we CAN subscribe to this thing
        if (!SHRestricted2W(REST_NoAddingSubscriptions, pszUrl, 0) &&
            IsFeaturePotentiallyAvailable(CLSID_SubscriptionMgr))
        {
            *pfSubscribable = IsSubscribableW(pszUrl);
        }
    }
    else
        *pfSubscribable = TRUE;
    
    return fRet;
}

void _InsertISCM(UINT indexISCM, HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT uFlags)
{
    TCHAR szMenu[CCH_MENUMAX];
    uFlags |= MF_BYPOSITION | MF_STRING;

    MLLoadShellLangString(g_rgiscm[indexISCM].idsVerb, szMenu, SIZECHARS(szMenu));
    InsertMenu_PrivateNoMungeW(hmenu, indexMenu, uFlags, idCmdFirst + indexISCM, szMenu);
}

// IContextMenu::QueryContextMenu handler for Intshcut
// The context menu handler adds the open verb for .url
// files.  This is because we remove the shell\open\command
// key in Nashville for this file type.

STDMETHODIMP Intshcut::QueryContextMenu(
    IN HMENU hmenu,
    IN UINT  indexMenu,
    IN UINT  idCmdFirst,
    IN UINT  idCmdLast,
    IN UINT  uFlags)
{
    //
    //  LEGACY - .URL files have to maintain an open verb in the registry - ZekeL - 14-APR-99
    //  we would like to just use the "open" verb here in the context menu extension,
    //  but we need to not duplicate the open verb that is added by DefCM
    //  on NT5+ shell32 we disable that verb so we can add it here.
    //  on earlier shell32 we want to add "open" any time we arent
    //  initialized by DefCM.  if we think that DefCM added us, 
    //  then we go ahead and allow the DefCM's open from the registry.
    //
    if (!m_fProbablyDefCM || GetUIVersion() >= 5)
    {
        _InsertISCM(IDCMD_ISCM_OPEN, hmenu, indexMenu, idCmdFirst, 0);
        if (-1 == GetMenuDefaultItem(hmenu, MF_BYCOMMAND, 0))
            SetMenuDefaultItem(hmenu, indexMenu, MF_BYPOSITION);
        indexMenu++;
    }

#ifndef UNIX
    /* v-sriran: 12/8/97
     * disabling the context menu item for subscribe, separators etc.
     * because we are not supporting subscriptions right now
     */

    // skip this if we only want default or if there is no room for more.
    if (!(uFlags & CMF_DEFAULTONLY) && (idCmdLast - idCmdFirst >= ARRAYSIZE(g_rgiscm)))
    {
        WCHAR *pwszURL;
        if (SUCCEEDED(GetURLW(&pwszURL)))
        {
            BOOL bSubscribable = FALSE;             //can be subscribed to
            BOOL bSub = _IsSubscribed(pwszURL, &bSubscribable);
            m_bCheckForDelete = bSub && m_pszFile;

            if (bSubscribable || bSub)
            {
                //  add a separator for our subscription stuff
                InsertMenu(hmenu, indexMenu++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
                UINT uMenuFlags = 0;

                if (bSub)
                {
                    uMenuFlags |= MF_CHECKED;

                    if (SHRestricted2W(REST_NoRemovingSubscriptions, pwszURL, 0))
                    {
                        uMenuFlags |= MF_GRAYED;
                    }
                }

                _InsertISCM(IDCMD_ISCM_SUB, hmenu, indexMenu++, idCmdFirst, uMenuFlags);

                if (bSub)
                {
                    uMenuFlags = 0;

                    if (SHRestricted2W(REST_NoManualUpdates, NULL, 0))
                    {
                        uMenuFlags |= MF_GRAYED;
                    }
                    _InsertISCM(IDCMD_ISCM_SYNC, hmenu, indexMenu++, idCmdFirst, uMenuFlags);
                } 
            }
            
            SHFree(pwszURL);
        }
    }

#endif /* UNIX */

    return ResultFromShort(ARRAYSIZE(g_rgiscm));
}

STDMETHODIMP Intshcut::InvokeCommand(IN LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hres = E_INVALIDARG;

    ASSERT(pici);

    if (pici && SIZEOF(*pici) <= pici->cbSize)
    {
        UINT idCmd;

        if (0 == HIWORD(pici->lpVerb))      // Is the ID cmd given?
        {
            idCmd = LOWORD(pici->lpVerb);   // Yes

            //  Old versions of ShellExec() didnt get the right default command - Zekel - 15-MAR-99
            //  since our QCM implementation doesnt add anything to the menu
            //  if we fix the QCM to work correctly, then this problem will go away.
            //  it sent 0xfffe instead.  so just adjust here.
            if (idCmd == 0xfffe && GetUIVersion() <= 4)
                idCmd = IDCMD_ISCM_OPEN;
        }
        else
        {
            // No; a language-independent verb was supplied
            int i;
            LPCTSTR pszVerb;
            LPCMINVOKECOMMANDINFOEX piciex = (LPCMINVOKECOMMANDINFOEX)pici;
            ASSERT(SIZEOF(*piciex) <= piciex->cbSize);

            WCHAR szVerb[40];

            if (piciex->lpVerbW)
            {
                pszVerb = piciex->lpVerbW;
            }
            else
            {
                if (piciex->lpVerb)
                {
                    ASSERT(lstrlenA(piciex->lpVerb) < ARRAYSIZE(szVerb));
                    SHAnsiToUnicode(piciex->lpVerb, szVerb, ARRAYSIZE(szVerb));    
                }
                else
                {
                    szVerb[0] = L'\0';
                }
                    
                pszVerb = szVerb;
            }

            idCmd = (UINT)-1;
            for (i = 0; i < ARRAYSIZE(g_rgiscm); i++)
            {
                if (0 == StrCmpI(g_rgiscm[i].pszVerb, pszVerb))
                {
                    idCmd = i;
                    break;
                }
            }
        }

        switch (idCmd)
        {
        case IDCMD_ISCM_OPEN: 
            {
                URLINVOKECOMMANDINFO urlici;

                urlici.dwcbSize = SIZEOF(urlici);
                urlici.hwndParent = pici->hwnd;
                urlici.pcszVerb = NULL;
                urlici.dwFlags = IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB;

                if (IsFlagClear(pici->fMask, CMIC_MASK_FLAG_NO_UI))
                {
                    SetFlag(urlici.dwFlags, IURL_INVOKECOMMAND_FL_ALLOW_UI);
                }
                if (IsFlagSet(pici->fMask, SEE_MASK_FLAG_DDEWAIT))
                {
                    SetFlag(urlici.dwFlags, IURL_INVOKECOMMAND_FL_DDEWAIT);
                }
                hres = InvokeCommand(&urlici);
                m_bCheckForDelete = FALSE;
            }
            break;

        case IDCMD_ISCM_SUB:
        case IDCMD_ISCM_SYNC:
        {
            hres = S_OK;

            WCHAR *pwszURL;
            if (SUCCEEDED(GetURLW(&pwszURL)))
            {
                ISubscriptionMgr * pMgr;
                if (SUCCEEDED(JITCoCreateInstance(CLSID_SubscriptionMgr, 
                                                  NULL, 
                                                  CLSCTX_INPROC_SERVER, 
                                                  IID_PPV_ARG(ISubscriptionMgr, &pMgr),
                                                  pici->hwnd,
                                                  FIEF_FLAG_FORCE_JITUI))) 
                {
                    if (idCmd == IDCMD_ISCM_SUB)  
                    {
                        BOOL bSubscribed;

                        pMgr->IsSubscribed(pwszURL, &bSubscribed);

                        if (!bSubscribed)
                        {
                            SHFILEINFO  sfi = {0};
                            WCHAR wszName[MAX_PATH];
                            wszName[0] = 0;
                            if (SHGetFileInfo(m_pszFile, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME))
                            {
                                SHTCharToUnicode(sfi.szDisplayName, wszName, ARRAYSIZE(wszName));
                            }

                            if (!wszName[0])
                                StrCpyNW(wszName, pwszURL, ARRAYSIZE(wszName));

                            //all subscriptions to local .urls are treated as subscribing something
                            //that's already in Favorites, so user isn't forced to add it to their
                            //favorites as they subscribe.
                            if (SUCCEEDED(pMgr->CreateSubscription(pici->hwnd, pwszURL, wszName,
                                                                   CREATESUBS_FROMFAVORITES, 
                                                                   SUBSTYPE_URL, 
                                                                   NULL)))
                            {
                                pMgr->UpdateSubscription(pwszURL);
                            }
                        }
                        else
                        {
                            pMgr->DeleteSubscription(pwszURL, pici->hwnd);
                        }
                    } 
                    else if (idCmd == IDCMD_ISCM_SYNC)
                    {
                        pMgr->UpdateSubscription(pwszURL);
                    }
                    pMgr->Release();    
                }
                SHFree(pwszURL);
                m_bCheckForDelete = FALSE;
            }
            break;
        }

        default:
            hres = E_INVALIDARG;
            break;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IContextMenu::GetCommandString handler for Intshcut

*/
STDMETHODIMP Intshcut::GetCommandString(
    IN     UINT_PTR idCmd,
    IN     UINT     uType,
    IN OUT UINT*    puReserved,
    IN OUT LPSTR    pszName,
    IN     UINT     cchMax)
{
    HRESULT hres;
    TCHAR szMenu[CCH_MENUMAX];

    ASSERT(NULL == puReserved);
    ASSERT(IS_VALID_WRITE_BUFFER(pszName, char, cchMax));

    switch (uType)
    {
    case GCS_HELPTEXTA:
    case GCS_HELPTEXTW:
        if (idCmd < ARRAYSIZE(g_rgiscm))
        {
            MLLoadString(g_rgiscm[idCmd].idsMenuHelp, szMenu, SIZECHARS(szMenu));

            if (GCS_HELPTEXTA == uType)
            {
                UnicodeToAnsi(szMenu, pszName, cchMax);
            }
            else
            {
                StrCpyN((LPWSTR)pszName, szMenu, cchMax);
            }
            hres = NOERROR;
        }
        else
        {
            ASSERT(0);
            hres = E_INVALIDARG;
        }
        break;

    case GCS_VALIDATEA:
    case GCS_VALIDATEW:
        hres = idCmd < ARRAYSIZE(g_rgiscm) ? S_OK : S_FALSE;
        break;

    case GCS_VERBA:
    case GCS_VERBW:
        if (idCmd < ARRAYSIZE(g_rgiscm))
        {
            LPCTSTR pszVerb = g_rgiscm[idCmd].pszVerb;

            if (GCS_VERBA == uType)
            {
                UnicodeToAnsi(pszVerb, pszName, cchMax);
            }
            else
            {
                StrCpyN((LPWSTR)pszName, pszVerb, cchMax);
            }
            hres = NOERROR;
        }
        else
        {
            ASSERT(0);
            hres = E_INVALIDARG;
        }
        break;

    default:
        hres = E_NOTIMPL;
        break;
    }

    return hres;
}


// IContextMenu2::HandleMenuMsg handler for Intshcut
STDMETHODIMP Intshcut::HandleMenuMsg(IN UINT uMsg, IN WPARAM wParam, IN LPARAM lParam)
{
    return S_OK;
}

// Returns the protocol scheme value (URL_SCHEME_*).

STDMETHODIMP_(DWORD)
Intshcut::GetScheme(void)
{
    DWORD dwScheme = URL_SCHEME_UNKNOWN;

    if (SUCCEEDED(InitProp()))
    {
        m_pprop->GetProp(PID_IS_SCHEME, &dwScheme);
    }
    return dwScheme;
}


// IUniformResourceLocator::SetURL handler for Intshcut
//
// Note:
//    1. SetURL clears the IDList, so that when we launch this shortcut,
//        we will use the URL.

STDMETHODIMP
Intshcut::SetURL(
    IN LPCTSTR pszURL,      OPTIONAL
    IN DWORD   dwFlags)
{
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(! pszURL ||
           IS_VALID_STRING_PTR(pszURL, -1));
    ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_IURL_SETURL_FLAGS));

    hres = InitProp();
    if (SUCCEEDED(hres))
    {
        hres = m_pprop->SetURLProp(pszURL, dwFlags);
        if (SUCCEEDED(hres))
        {
            // if the path was set successfully, clear the pidl.
            m_pprop->SetIDListProp(NULL);
        }
    }

    return hres;
}



/*----------------------------------------------------------
Purpose: IUniformResourceLocatorA::SetURL handler for Intshcut

         Ansi version

*/
STDMETHODIMP
Intshcut::SetURL(
    IN LPCSTR pcszURL,      OPTIONAL
    IN DWORD  dwInFlags)
{
    if ( !pcszURL )
    {
        return SetURL((LPCTSTR)NULL, dwInFlags);
    }
    else
    {
        WCHAR wszURL[MAX_URL_STRING];

        ASSERT(IS_VALID_STRING_PTRA(pcszURL, -1));

        AnsiToUnicode(pcszURL, wszURL, SIZECHARS(wszURL));

        return SetURL(wszURL, dwInFlags);
    }
}


STDMETHODIMP Intshcut::GetURLW(WCHAR **ppwsz)
{
    LPTSTR  pszURL;
    HRESULT hres = GetURL(&pszURL);
    if (S_OK == hres)
    {
        hres = SHStrDup(pszURL, ppwsz);
        SHFree(pszURL);
    }
    else
        hres = E_FAIL;  // map S_FALSE to FAILED()
    return hres;
}

// IUniformResourceLocator::GetURL handler for Intshcut

STDMETHODIMP Intshcut::GetURL(LPTSTR * ppszURL)
{
    HRESULT hres;
    TCHAR szURL[MAX_URL_STRING];

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_WRITE_PTR(ppszURL, PTSTR));

    *ppszURL = NULL;

    hres = InitProp();
    if (SUCCEEDED(hres))
    {
        hres = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));
        if (S_OK == hres)
        {
            // (+ 1) for null terminator.
            int cch = lstrlen(szURL) + 1;
            *ppszURL = (PTSTR)SHAlloc(CbFromCch(cch));
            if (*ppszURL)
                StrCpyN(*ppszURL, szURL, cch);
            else
                hres = E_OUTOFMEMORY;
        }
    }

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT((hres == S_OK &&
            IS_VALID_STRING_PTR(*ppszURL, -1)) ||
           ((hres == S_FALSE ||
             hres == E_OUTOFMEMORY) &&
            ! *ppszURL));

    return hres;
}



/*----------------------------------------------------------
Purpose: IUniformResourceLocatorA::GetURL handler for Intshcut

         Ansi version

*/
STDMETHODIMP Intshcut::GetURL(LPSTR * ppszURL)
{
    HRESULT hres;
    TCHAR szURL[MAX_URL_STRING];

    ASSERT(IS_VALID_WRITE_PTR(ppszURL, PSTR));

    *ppszURL = NULL;

    hres = InitProp();
    if (SUCCEEDED(hres))
    {
        hres = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));

        if (S_OK == hres)
        {
            DWORD cch = WideCharToMultiByte(CP_ACP, 0, szURL, -1, NULL, 0, NULL, NULL);
            *ppszURL = (LPSTR)SHAlloc(CbFromCchA(cch + 1));

            if (*ppszURL)
                UnicodeToAnsi(szURL, *ppszURL, cch);
            else
                hres = E_OUTOFMEMORY;
        }
    }

    return hres;
}


HRESULT HandlePluggableProtocol(LPCTSTR pszURL, LPCTSTR pszProtocol)
{
    HRESULT hres = E_UNEXPECTED;
    HKEY hkey;
    TraceMsg(DM_PLUGGABLE, "HandlePluggableProtocol called");

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("PROTOCOLS\\Handler"), 0, KEY_READ, &hkey) == ERROR_SUCCESS) {
        HKEY hkeyProtocol;
        if (RegOpenKeyEx(hkey, pszProtocol, 0, KEY_READ, &hkeyProtocol) == ERROR_SUCCESS) {
            TraceMsg(DM_PLUGGABLE, "HandlePluggableProtocol found %s", pszProtocol);
            IUnknown* punk = NULL; // CreateTargetFrame's ppunk is [IN][OUT]
            hres = CreateTargetFrame(NULL, &punk);
            if (SUCCEEDED(hres)) {
                IWebBrowser2* pauto;
                hres = punk->QueryInterface(IID_IWebBrowser2, (LPVOID*)&pauto);
                if (SUCCEEDED(hres))
                {
                    TraceMsg(DM_PLUGGABLE, "HandlePluggableProtocol calling navigate with %s", pszURL);

                    LBSTR::CString          strUrl;

                    LPTSTR          pstrUrl = strUrl.GetBuffer( MAX_URL_STRING );

                    if ( strUrl.GetAllocLength() < MAX_URL_STRING )
                    {
                        TraceMsg( TF_WARNING, "HandlePluggableProtocol() - strUrl Allocation Failed!" );

                        strUrl.Empty();
                    }
                    else
                    {
                        SHTCharToUnicode( pszURL, pstrUrl, MAX_URL_STRING );

                        // Let CString class own the buffer again.
                        strUrl.ReleaseBuffer();
                    }

                    pauto->Navigate( strUrl, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY );
                    pauto->put_Visible(TRUE);
                    pauto->Release();
                }
                punk->Release();
            }
            RegCloseKey(hkeyProtocol);
        } else {
            TraceMsg(DM_WARNING, "HandlePluggableProtocol can't find %s", pszProtocol);
        }
        RegCloseKey(hkey);
    } else {
        ASSERT(0);
    }
    return hres;
}

HRESULT _IEExecFile_TryRunningWindow(VARIANT *pvarIn, DWORD cid)
{
    HRESULT hr = E_FAIL;
    ASSERT(pvarIn);

    IShellWindows *psw = WinList_GetShellWindows(TRUE);
    if (psw)
    {
        IUnknown *punk;
        if (SUCCEEDED(psw->_NewEnum(&punk)))
        {
            VARIANT var = {0};
            IEnumVARIANT *penum;

            //
            //  its too bad _NewEnum doesnt return an penum....
            //  this should never fail.
            //
            punk->QueryInterface(IID_PPV_ARG(IEnumVARIANT, &penum));
            ASSERT(penum);

            //
            //  this can be super spendy since every one of these
            //  items is marshalled.
            //
            //  should we clone the stream here??
            //
            while (FAILED(hr) && S_OK == penum->Next(1, &var, NULL))
            {
                ASSERT(var.vt == VT_DISPATCH);
                ASSERT(var.pdispVal);
                IOleCommandTarget *poct;
                
                if (SUCCEEDED(var.pdispVal->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &poct))))
                {
                    CoAllowSetForegroundWindow(poct, NULL);
                    
                    hr = poct->Exec(&CGID_Explorer, cid, 0, pvarIn, NULL);

                    poct->Release();
                }
                
                //  this should release the pdisp
                VariantClear(&var);
            }

            punk->Release();
            penum->Release();
        }
        
        psw->Release();
    }


    TraceMsgW(DM_SHELLEXECOBJECT, "IEExecFile_Running returns 0x%X", hr);
    return hr;
}

BOOL IsIESchemeHandler(LPTSTR pszVerb, LPTSTR pszScheme)
{
    //  if we fail to get any value at all, the we must assume that it
    //  is some protocol like about: or res: that is not in the registry
    //  so we default to success.
    BOOL fRet = FALSE;
    TCHAR szExe[MAX_PATH];

    if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_EXECUTABLE, pszScheme, pszVerb, szExe, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szExe)))))
    {
        //  if we find something and it aint us, then fail.
        if ((StrStrI(szExe, TEXT("iexplore.exe")) || StrStrI(szExe, TEXT("explorer.exe"))))
        {
            fRet = TRUE;

            TraceMsg(DM_SHELLEXECOBJECT, "IsIEScheme() found %s", szExe);
        }
    }
    else
    {
        // these are unregistered schemes, we are the only ones that 
        //  should ever even use the unregistered schemes like
        //  res: or shell: so return TRUE here too.
        fRet = *pszScheme && *pszScheme != TEXT('.');
    }
    
    TraceMsg(DM_SHELLEXECOBJECT, "IsIEScheme() returns %d for %s", fRet, pszScheme);
    return fRet;
}    

HRESULT IEExecFile(LPTSTR pszVerb, LPTSTR pszScheme, DWORD cid, LPTSTR pszPath)
{
    HRESULT hr = E_FAIL;
    ASSERT(pszVerb);
    ASSERT(pszScheme);
    ASSERT(pszPath);
    
    if (IsIESchemeHandler(pszVerb, pszScheme))
    {
        VARIANT varIn = {0};
        varIn.vt = VT_BSTR;

        SHSTRW str;
        str.SetStr(pszPath);
        varIn.bstrVal = SysAllocString(str.GetStr());
        if (varIn.bstrVal)
        {
            if (!SHRegGetBoolUSValue(REGSTR_PATH_MAIN, TEXT("AllowWindowReuse"), FALSE, TRUE)
            || FAILED(hr = _IEExecFile_TryRunningWindow(&varIn, cid)))
            {
                IOleCommandTarget *poct;
    
                if (SUCCEEDED(CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, 
                        IID_PPV_ARG(IOleCommandTarget, &poct))))
                {
                    hr = poct->Exec(&CGID_Explorer, cid, 0, &varIn, NULL);
                    poct->Release();
                }
            }

            SysFreeString(varIn.bstrVal);
        }

    }

    TraceMsg(DM_SHELLEXECOBJECT, "IEExecFile returns 0x%X for %s", hr, pszPath);

    return hr;
}
                
            
/*----------------------------------------------------------
Purpose: IUniformResourceLocator::InvokeCommand for Intshcut

Note:
    1. If the internet shortcut comes with a pidl, use it to ShellExec,
        otherwise use the URL.

*/
STDMETHODIMP Intshcut::InvokeCommand(PURLINVOKECOMMANDINFO purlici)
{
    HRESULT hr = E_INVALIDARG;
    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(IS_VALID_STRUCT_PTR(purlici, CURLINVOKECOMMANDINFO));

    if (purlici && EVAL(SIZEOF(*purlici) == purlici->dwcbSize))
    {
        //
        // App compat.  Don't use stack space for the URL.  We use up 16-bit app
        // stack space when we they shell exec urls.
        //

        LPWSTR pszURL = (LPWSTR)LocalAlloc(LPTR, MAX_URL_STRING * sizeof(WCHAR));

        if (pszURL)
        {
            hr = InitProp();
            if (SUCCEEDED(hr))
            {
                //
                // App Compat: Don't use up stack space.
                //

                LPWSTR pszT = (LPWSTR)LocalAlloc(LPTR, MAX_PATH * sizeof(WCHAR));

                if (pszT)
                {
                    SHELLEXECUTEINFO sei = {0};
                    LPITEMIDLIST pidl = NULL;
                    LPTSTR pszProtocol = NULL;
                    PARSEDURL pu;
                    pu.nScheme = 0; // init to avoid bogus C4701 warning

                    sei.fMask = SEE_MASK_NO_HOOKS;

                   // check if we have a pidl for the target.        
                    hr = GetIDListInternal(&pidl);
                    if ((hr == S_OK) && pidl)
                    {
                        // yse, use the pidl to ShellExec.
                        sei.fMask |= SEE_MASK_INVOKEIDLIST;
                        sei.lpIDList = pidl;
                    }
                    else
                    {
                        // no, get the URL and invoke class handler.
                        if (SUCCEEDED(hr))
                        {
                            hr = m_pprop->GetProp(PID_IS_URL, pszURL, MAX_URL_STRING);
                        }
                        if (S_OK == hr)
                        {
                            hr = CopyURLProtocol(pszURL, &pszProtocol, &pu);
               
                            if (hr == S_OK)
                            {
                                hr = IsProtocolRegistered(pszProtocol);
                                if (FAILED(hr)) {
                                    if (SUCCEEDED(HandlePluggableProtocol(pszURL, pszProtocol))) {
                                        hr = S_OK;
                                        goto done;
                                    }
                                }

                                if (SUCCEEDED(hr))
                                {
                                    hr = ResultFromWin32(RegOpenKeyExW(HKEY_CLASSES_ROOT, pszProtocol, 0, KEY_READ, &sei.hkeyClass));
                                    sei.fMask |= SEE_MASK_CLASSKEY;
                                }
                            }
                        }
                    }

                    //  the prop code returns S_FALSE when it fails to get anything
                    if (S_FALSE == hr)
                        hr = URL_E_INVALID_SYNTAX;
                
                    if (SUCCEEDED(hr))
                    {
                            //
                            // App Compat: Don't use up stack space.
                            //

                            LPWSTR pszVerb = (LPWSTR)LocalAlloc(LPTR, MAX_PATH * sizeof(WCHAR));

                            if (pszVerb)
                            {
                                int nShowCmd;
   
                                // Execute URL via registered protocol handler.
   
                                if (IsFlagClear(purlici->dwFlags,
                                                IURL_INVOKECOMMAND_FL_ALLOW_UI))
                                    SetFlag(sei.fMask, SEE_MASK_FLAG_NO_UI);

                                if (purlici->dwFlags & IURL_INVOKECOMMAND_FL_DDEWAIT)
                                    SetFlag(sei.fMask, SEE_MASK_FLAG_DDEWAIT);
                        
                                if (IsFlagClear(purlici->dwFlags,
                                                IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB))
                                {
                                    sei.lpVerb = purlici->pcszVerb;
                                }
                                else
                                {
                                    if (pszProtocol &&
                                        GetClassDefaultVerb(pszProtocol, pszVerb,
                                                            MAX_PATH))
                                        sei.lpVerb = pszVerb;
                                    else
                                        ASSERT(! sei.lpVerb);
                                }

                                ASSERT(m_pprop);
                                if (SUCCEEDED(hr))
                                {
                                    m_pprop->GetProp(PID_IS_WORKINGDIR, pszT, MAX_PATH);
                                    m_pprop->GetProp(PID_IS_SHOWCMD, &nShowCmd); // inits to zero if not found
                                
                                    //  if we have a file try using a direct connection
                                    //  to the shell to give the whole shortcut
                                    if (m_pszFile && ((IsIEDefaultBrowser()) || (_IsInFavoritesFolder())))
                                    {
                                        LPTSTR pszType = pszProtocol;
                                        if (pu.nScheme == URL_SCHEME_FILE)
                                            pszType = PathFindExtension(pszURL);
                                            
                                        hr = IEExecFile(pszVerb, pszType, SBCMDID_IESHORTCUT, m_pszFile);
                                    }
                                    else 
                                        hr = E_FAIL;

                                    //  if we failed to pass it to IE, then we should just default 
                                    //  to the old behavior
                                    if (FAILED(hr))
                                    {

                                        sei.cbSize = SIZEOF(sei);
                                        sei.hwnd = purlici->hwndParent;
                                        sei.lpFile = pszURL;
                                        sei.lpDirectory = pszT;
                                        sei.nShow = nShowCmd ? nShowCmd : SW_NORMAL;
           
                                        // We have to special case "file:" URLs,
                                        // because Nashville's Explorer typically handles 
                                        // file: URLs via DDE, which fails for executables
                                        // (eg, "file://c:\windows\notepad.exe") and
                                        // non-hostable docs (like text files).
                                        //
                                        // So in this case, we remove the protocol class
                                        // and execute the suffix.

                                        // App Compat: Don't use up stack space.
                                        DWORD cchPath = MAX_PATH;
                                        LPWSTR  pszPath = (LPWSTR)LocalAlloc(LPTR, cchPath * sizeof(WCHAR));

                                        if (pszPath)
                                        {
                                            if (IsFlagSet(sei.fMask, SEE_MASK_CLASSKEY) &&
                                                (URL_SCHEME_FILE == pu.nScheme) &&
                                                SUCCEEDED(PathCreateFromUrl(pszURL, pszPath, &cchPath, 0)))
                                            {
                                                sei.hkeyClass = NULL;
                                                ClearFlag(sei.fMask, SEE_MASK_CLASSKEY);
                                                sei.lpFile = pszPath;
                                                
                                            }

                                            if (m_pszFile && IsOS(OS_WHISTLERORGREATER))
                                            {
                                                //  this is the security context
                                                //  so that shellexec() can do zone checks
                                                sei.lpClass = m_pszFile;
                                                sei.fMask |= SEE_MASK_HASTITLE | SEE_MASK_HASLINKNAME;
                                            }


                                            TraceMsg(TF_INTSHCUT, "Intshcut::InvokeCommand(): Invoking %s verb on URL %s.",
                                                       sei.lpVerb ? sei.lpVerb : TEXT("open"),
                                                       sei.lpFile);
           
                                            hr = ShellExecuteEx(&sei) ? S_OK : IS_E_EXEC_FAILED;

                                            LocalFree(pszPath);
                                            pszPath = NULL;
                                        }
                                        else
                                        {
                                            hr = E_OUTOFMEMORY;
                                        }
                                    }
                                }
                                if (hr != S_OK)
                                    TraceMsg(TF_WARNING, "Intshcut::InvokeCommand(): ShellExecuteEx() via registered protcol handler failed for %s.",
                                             pszURL);

                                LocalFree(pszVerb);
                                pszVerb = NULL;
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
   
                    }

        done:
                    if (pszProtocol)
                    {
                        LocalFree(pszProtocol);
                        pszProtocol = NULL;
                    }
                
                    if (pidl)
                        ILFree(pidl);
                    
                    if (sei.hkeyClass)
                        RegCloseKey(sei.hkeyClass);
                    
                    if (FAILED(hr) && (purlici->dwFlags & IURL_INVOKECOMMAND_FL_ALLOW_UI))
                    {
                        switch (hr)
                        {
                            case IS_E_EXEC_FAILED:
                                break;
            
                            case URL_E_INVALID_SYNTAX:
                                MLShellMessageBox(
                                                purlici->hwndParent,
                                                MAKEINTRESOURCE(IDS_IS_EXEC_INVALID_SYNTAX),
                                                MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                                                (MB_OK | MB_ICONEXCLAMATION),
                                                pszURL);
            
                                break;
            
                            case URL_E_UNREGISTERED_PROTOCOL:
                            {
                                LPTSTR pszProtocol;
            
                                if (CopyURLProtocol(pszURL, &pszProtocol, NULL) == S_OK)
                                {
                                    MLShellMessageBox(
                                                    purlici->hwndParent,
                                                    MAKEINTRESOURCE(IDS_IS_EXEC_UNREGISTERED_PROTOCOL),
                                                    MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                                                    (MB_OK | MB_ICONEXCLAMATION),
                                                    pszProtocol);
            
                                    LocalFree(pszProtocol);
                                    pszProtocol = NULL;
                                }
            
                                break;
                            }
            
                            case E_OUTOFMEMORY:
                                MLShellMessageBox(
                                                purlici->hwndParent,
                                                MAKEINTRESOURCE(IDS_IS_EXEC_OUT_OF_MEMORY),
                                                MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                                                (MB_OK | MB_ICONEXCLAMATION));
                                break;
            
                            default:
                                ASSERT(hr == E_ABORT);
                                break;
                        }
                    }

                    LocalFree(pszT);
                    pszT = NULL;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

           LocalFree(pszURL);
           pszURL = NULL;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    ASSERT(IS_VALID_STRUCT_PTR(this, CIntshcut));
    ASSERT(hr == S_OK ||
           hr == E_ABORT ||
           hr == E_OUTOFMEMORY ||
           hr == URL_E_INVALID_SYNTAX ||
           hr == URL_E_UNREGISTERED_PROTOCOL ||
           hr == IS_E_EXEC_FAILED ||
           hr == E_INVALIDARG);
    
    return(hr);
}



/*----------------------------------------------------------
Purpose: IUniformResourceLocatorA::InvokeCommand for Intshcut

         Ansi version

*/
STDMETHODIMP
Intshcut::InvokeCommand(
    IN PURLINVOKECOMMANDINFOA purlici)

{
    HRESULT hres = E_INVALIDARG;

    ASSERT(purlici);
    ASSERT(SIZEOF(*purlici) == purlici->dwcbSize);

    if (SIZEOF(*purlici) == purlici->dwcbSize)
    {
        URLINVOKECOMMANDINFOW ici;

        ici.dwcbSize = SIZEOF(ici);
        ici.dwFlags  = purlici->dwFlags;
        ici.hwndParent = purlici->hwndParent;

        ici.pcszVerb = NULL;

        if (purlici->pcszVerb)
        {
            //
            // App compat hack.
            //
            // Note: use local alloc here instead of the stack since 16-bit code
            // can shell exec urls and we don't want to use up their stack.
            //

            int cch = lstrlenA(purlici->pcszVerb) + 1;

            ici.pcszVerb = (LPWSTR)LocalAlloc(LPTR, cch * sizeof(WCHAR));

            if (ici.pcszVerb)
            {
                AnsiToUnicode(purlici->pcszVerb, (LPWSTR)ici.pcszVerb, cch);
            }
        }

        hres = InvokeCommand(&ici);

        if (ici.pcszVerb)
        {
            LocalFree((void*)ici.pcszVerb);
            ici.pcszVerb = NULL;
        }
    }

    return hres;
}



STDMETHODIMP Intshcut::Create(REFFMTID fmtid, const CLSID *pclsid,
                              DWORD grfFlags, DWORD grfMode, IPropertyStorage **pppropstg)
{
    *pppropstg = NULL;
    return E_NOTIMPL;
}


STDMETHODIMP Intshcut::Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage **pppropstg)
{
    HRESULT hres = E_FAIL;      // assume failure

    *pppropstg = NULL;

    if (IsEqualGUID(fmtid, FMTID_Intshcut))
    {
        // Create a URLProp object for this format ID
        hres = CIntshcutProp_CreateInstance(NULL, IID_PPV_ARG(IPropertyStorage, pppropstg));
        if (SUCCEEDED(hres))
        {
            // Initialize this object
            IntshcutProp * pisprop = (IntshcutProp *)*pppropstg;
            hres = pisprop->InitFromFile(m_pszFile);
        }
    }
    else if (IsEqualGUID(fmtid, FMTID_InternetSite))
    {
        // Create a URLProp object for this format ID
        hres = CIntsiteProp_CreateInstance(NULL, IID_PPV_ARG(IPropertyStorage, pppropstg));
        if (SUCCEEDED(hres))
        {
            hres = InitProp();
            if (SUCCEEDED(hres))
            {
                TCHAR szURL[MAX_URL_STRING];
                hres = m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));
                if (SUCCEEDED(hres))
                {
                    IntsiteProp * pisprop = (IntsiteProp *)*pppropstg;
                    hres = pisprop->InitFromDB(szURL, this, FALSE);
                }
            }

            if (FAILED(hres))
            {
                (*pppropstg)->Release();
                *pppropstg = NULL;
            }
        }
    }

    return hres;
}


STDMETHODIMP Intshcut::Delete(REFFMTID fmtid)
{
    return STG_E_ACCESSDENIED;
}


STDMETHODIMP Intshcut::Enum(OUT IEnumSTATPROPSETSTG ** ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDAPI GetStringPropURL(IPropertyStorage *ppropstg, PROPID propid, LPTSTR pszBuf, DWORD cchBuf)
{
    HRESULT hres = GetStringProp(ppropstg, propid, pszBuf, cchBuf);
    if (SUCCEEDED(hres))
    {
        // get rid of the query string for display
        if (UrlIs(pszBuf, URLIS_HASQUERY))
            UrlCombine(pszBuf, TEXT("?..."), pszBuf, &cchBuf, 0);
    }
    return hres;
}

BOOL Intshcut::_TryLink(REFIID riid, void **ppvOut)
{
    HRESULT hr = InitProp();

    if (SUCCEEDED(hr) && URL_SCHEME_FILE == GetScheme())
    {
        // This shortcut is not in the favorites folder as far as we know 
        TCHAR szURL[INTERNET_MAX_URL_LENGTH];
        DWORD cch = SIZECHARS(szURL);

        *szURL = 0;

        m_pprop->GetProp(PID_IS_URL, szURL, SIZECHARS(szURL));

        if (*szURL && SUCCEEDED(PathCreateFromUrl(szURL, szURL, &cch, 0)))
        {
            if (!_punkLink)
            {
                hr = _CreateShellLink(szURL, &_punkLink);
            }

            if (_punkLink)
            {
                if (SUCCEEDED(_punkLink->QueryInterface(riid, ppvOut)))
                    return TRUE;
            }
        }

        if (FAILED(hr))
            ATOMICRELEASE(_punkLink);
    }

    return FALSE;
}

STDMETHODIMP Intshcut::GetInfoTip(DWORD dwFlags, WCHAR **ppwszTip)
{
    HRESULT hr = E_FAIL;
    IQueryInfo *pqi;

    if (_TryLink(IID_PPV_ARG(IQueryInfo, &pqi)))
    {
        hr = pqi->GetInfoTip(dwFlags, ppwszTip);
        pqi->Release();
    }
    
    if (FAILED(hr))
    {
        static const ITEM_PROP c_rgTitleAndURL[] = {
            { &FMTID_InternetSite, PID_INTSITE_TITLE,   GetStringProp, IDS_FAV_STRING },
            { &FMTID_Intshcut, PID_IS_URL,              GetStringPropURL, IDS_FAV_STRING },
            { NULL, 0, 0, 0 },
        };

        hr = GetInfoTipFromStorage(SAFECAST(this, IPropertySetStorage *), c_rgTitleAndURL, ppwszTip);
    }

    return hr;

}

STDMETHODIMP Intshcut::GetInfoFlags(DWORD *pdwFlags)
{
    *pdwFlags = 0;
#if 0    
// This Function is commented out since it has not been tested.
// It can be uncommented if we provide support for providing offline cursor
// for shortucts. I think this needs updates to listview in comctl -- BharatS
        
    LPSTR pszURL;
    if (S_OK == GetURL(&pszURL))
    {
        BOOL fCached = UrlIsCached(pszUrl);
        if (!fCached)
        {
            CHAR szCanonicalizedUrlA[MAX_URL_STRING];
            DWORD dwLen = ARRAYSIZE(szCanonicalizedUrlA);
            InternetCanonicalizeUrlA(pszURL, szCanonicalizedUrlA, &dwLen, 0);
            fCached = UrlIsMappedOrInCache(szCanonicalizedUrlA);
        }
        if (fCached)
            *pdwFlags |= QIF_CACHED;
        SHFree(pszURL);
    }
    return S_OK;
#else
    return E_NOTIMPL;
#endif
}

/*----------------------------------------------------------
IQueryCodePage:
*/
STDMETHODIMP Intshcut::GetCodePage(UINT * puiCodePage)
{
    HRESULT hres = E_FAIL;
    *puiCodePage = 0;     // NULL out the code page. 
    if (IsFlagSet(m_dwFlags, ISF_CODEPAGE))
    {
        *puiCodePage = m_uiCodePage;
        hres = S_OK;
    }

    return hres;
}

STDMETHODIMP Intshcut::SetCodePage(UINT uiCodePage)
{
    SetFlag(m_dwFlags, ISF_CODEPAGE);
    m_uiCodePage = uiCodePage;
    return S_OK;
}

/***************************** Exported Functions ****************************/


// This function was ported from URL.DLL.  Normally, since our
// internet shortcut object has a context menu handler, we don't
// call this function.
//
// Only one thing needs this entry point: Exchange.  Sigh.
//
// Instead of simply calling ShellExecuteEx to handle opening file
// attachments, they grovel thru the registry themselves. Of course,
// their code is incomplete and thinks a file-association needs to
// have an explicit \shell\open\command that works before it executes
// it.  Hmm, it brings to mind a phrase, like:
//
// 
//
// So, we export this API so they will work.  But really the invoke
// occurs in the context menu handler for normal cases.
//


STDAPI_(void) OpenURL(HWND hwndParent, HINSTANCE hinst, LPSTR pszCmdLine, int nShowCmd)
{
   HRESULT hr;
   HRESULT hrCoInit;

   

   Intshcut * pIntshcut = new Intshcut;     // This must be a 0 INITed memory allocation
   WCHAR wszPath[MAX_PATH];

    if (!pIntshcut)
        return;

   hrCoInit = SHCoInitialize(); // gets called from rundll32 in browser only mode - hence we need to
                                // make sure that OLE has been init'ed

 

   ASSERT(IS_VALID_HANDLE(hwndParent, WND));
   ASSERT(IS_VALID_HANDLE(hinst, INSTANCE));
   ASSERT(IS_VALID_STRING_PTRA(pszCmdLine, -1));
   ASSERT(IsValidShowCmd(nShowCmd));

   // Assume the entire command line is an Internet Shortcut file path.

   TrimWhiteSpaceA(pszCmdLine);

   TraceMsgA(TF_INTSHCUT, "OpenURL(): Trying to open Internet Shortcut %s.",
              pszCmdLine);

#ifndef UNIX

   AnsiToUnicode(pszCmdLine, wszPath, SIZECHARS(wszPath));
   hr = pIntshcut->LoadFromFile(wszPath);

#else /* UNIX */

#ifndef ANSI_SHELL32_ON_UNIX
   // IEUNIX : Our Shell32 calls this function with unicode command line
   hr = pIntshcut->LoadFromFile((LPWSTR)pszCmdLine);
#else
   hr = pIntshcut->LoadFromFile(pszCmdLine);
#endif

#endif /* !UNIX */

   if (hr == S_OK)
   {
      URLINVOKECOMMANDINFO urlici;

      urlici.dwcbSize = SIZEOF(urlici);
      urlici.hwndParent = hwndParent;
      urlici.pcszVerb = NULL;
      urlici.dwFlags = (IURL_INVOKECOMMAND_FL_ALLOW_UI |
                        IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB);

      hr = pIntshcut->InvokeCommand(&urlici);
   }

   if (hr != S_OK)
   {
      MLShellMessageBox(
                      hwndParent,
                      MAKEINTRESOURCE(IDS_IS_LOADFROMFILE_FAILED),
                      MAKEINTRESOURCE(IDS_SHORTCUT_ERROR_TITLE),
                      (MB_OK | MB_ICONEXCLAMATION),
                      wszPath);
   }

   pIntshcut->Release();

   SHCoUninitialize(hrCoInit);

}

// INamedPropertyBag Methods
//
// Reads & writes properties from a section in the shortcut ini file


const TCHAR  c_szSizeSuffix[] = TEXT("__Size");


STDMETHODIMP Intshcut::WritePropertyNPB(
                                       LPCOLESTR pszSectionNameW, 
                            /* [in] */ LPCOLESTR pszPropNameW, 
                       /* [out][in] */ PROPVARIANT  *pVar)
{
    const TCHAR *pszSectionName;
    const TCHAR *pszPropName;
    HRESULT hr;
    if((NULL == pszSectionNameW) || (NULL == pszPropNameW) || (NULL == pVar))
    {
        return E_FAIL;
    }


    if(S_OK != _CreateTemporaryBackingFile())
    {
        ASSERT(NULL == m_pszTempFileName);
        return E_FAIL;
    }


    ASSERT(m_pszTempFileName);
    
    pszSectionName = pszSectionNameW;
    pszPropName = pszPropNameW;
    // Write the appropriate value in depending on the type

    switch(pVar->vt)
    {
        // NOTE: (andrewgu) these types we also can round-trip using the same code pass as for
        // unsigned types, except bharats in a codereview recommended we comment these out because
        // they'll look goofy in the *.ini file (you wrote -5 but see 4294967290 junk instead).
        // VT_UINT is not listed as "may appear in an OLE property set" in <wtypes.h>.
     /* case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_INT:
        case VT_UINT: */

        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
            hr = WriteUnsignedToFile(m_pszTempFileName, pszSectionName, pszPropName, pVar->ulVal);
            break;

        case VT_BSTR:
            hr = WriteGenericString(m_pszTempFileName, pszSectionName, pszPropName, pVar->bstrVal);
            break;

        case VT_BLOB:
            {
                TCHAR *pszSizePropName = NULL;
                int  cchPropName = lstrlen(pszPropName) + ARRAYSIZE(c_szSizeSuffix) + 1;
                DWORD dwAllocSize = cchPropName * sizeof(TCHAR);
                
                pszSizePropName = (TCHAR *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, dwAllocSize);
                if(pszSizePropName)
                {
                    DWORD dwBufferSize;
                    StrCpyN(pszSizePropName, pszPropName, cchPropName);
                    StrCatBuff(pszSizePropName, c_szSizeSuffix, cchPropName);

                    // OK Now - we have the name for the size
                    // we write it out

                    dwBufferSize = pVar->blob.cbSize;
                    hr = WriteBinaryToFile(m_pszTempFileName, pszSectionName, pszSizePropName, 
                                                (LPVOID)(&dwBufferSize), sizeof(DWORD));

                    if(S_OK == hr)
                    {
                        // Write out the buffer
                        hr = WriteBinaryToFile(m_pszTempFileName, pszSectionName, pszPropName, 
                                                (LPVOID)(pVar->blob.pBlobData), dwBufferSize);
                    }

                    LocalFree((LPVOID)pszSizePropName);
                    pszSizePropName = NULL;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                
                break;
            }
        default:
            hr = WriteBinaryToFile(m_pszTempFileName, pszSectionName, pszPropName, (LPVOID)pVar, sizeof(PROPVARIANT));
            break;
    }

   
    return hr;
}

STDMETHODIMP Intshcut::ReadPropertyNPB(
                       /* [in] */ LPCOLESTR pszSectionNameW,
                       /* [in] */ LPCOLESTR pszPropNameW,
                       /* [out][in] */ PROPVARIANT  *pVar)
{
    const TCHAR *pszSectionName;
    const TCHAR *pszPropName;
    TCHAR       *pszFileToReadFrom;
    HRESULT hr;

    if((NULL == pszSectionNameW) || (NULL == pszPropNameW) || (NULL == pVar))
    {
        if (NULL != pVar)
            pVar->vt = VT_ERROR;

        return E_FAIL;
    }


    if(m_pszTempFileName)
    {
        pszFileToReadFrom = m_pszTempFileName;
    } 
    else if(m_pszFile)
    {
        pszFileToReadFrom = m_pszFile;
    }
    else
    {
        pVar->vt = VT_EMPTY;
        return S_FALSE;
    }

    pszSectionName = pszSectionNameW;
    pszPropName = pszPropNameW;

    switch(pVar->vt)
    {
        // NOTE: (andrewgu) these types we also can round-trip using the same code pass as for
        // unsigned types, except bharats in a codereview recommended we comment these out because
        // they'll look goofy in the *.ini file (you wrote -5 but see 4294967290 junk instead).
        // VT_UINT is not listed as "may appear in an OLE property set" in <wtypes.h>.
     /* case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_INT:
        case VT_UINT: */

        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
            pVar->ulVal = 0;
            hr          = ReadUnsignedFromFile(pszFileToReadFrom, pszSectionName, pszPropName, &(pVar->ulVal));
            break;

        case VT_BSTR:   
             // It is a string
           pVar->vt = VT_BSTR;
           pVar->bstrVal = NULL;
           hr = ReadBStrFromFile(pszFileToReadFrom, pszSectionName, pszPropName, &(pVar->bstrVal));            
           break;

        case VT_BLOB:
            {
                TCHAR *pszSizePropName = NULL;
                int  cchPropName = lstrlen(pszPropName) + ARRAYSIZE(c_szSizeSuffix) + 1;
                DWORD dwAllocSize = cchPropName * sizeof(TCHAR);
                
                pszSizePropName = (TCHAR *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, dwAllocSize);
                if(pszSizePropName)
                {
                    DWORD dwBufferSize;
                    StrCpyN(pszSizePropName, pszPropName, cchPropName);
                    StrCatBuff(pszSizePropName, c_szSizeSuffix, cchPropName);
                    // Read the Size first
                    hr = ReadBinaryFromFile(pszFileToReadFrom, pszSectionName, pszSizePropName, 
                                            &dwBufferSize, sizeof(DWORD));
                    if(S_OK == hr)
                    {
                        
                        pVar->blob.pBlobData = (unsigned char *)CoTaskMemAlloc(dwBufferSize);
                        if(pVar->blob.pBlobData)
                        {
                            hr = ReadBinaryFromFile(pszFileToReadFrom, pszSectionName, pszPropName, 
                                            pVar->blob.pBlobData, dwBufferSize);

                            if(S_OK == hr)
                            {
                                pVar->blob.cbSize = dwBufferSize;
                            }
                            else
                            {
                                CoTaskMemFree(pVar->blob.pBlobData);
                            }
                        }
                    }

                    LocalFree(pszSizePropName);
                    pszSizePropName = NULL;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

               break;
            }
        default:
            {
                // all else
                PROPVARIANT tmpPropvar = {0};
                
                hr = ReadBinaryFromFile(pszFileToReadFrom, pszSectionName, pszPropName, &tmpPropvar, sizeof(PROPVARIANT));
                if((S_OK == hr) && (tmpPropvar.vt == pVar->vt))
                {
                    memcpy(pVar, &tmpPropvar, sizeof(PROPVARIANT));
                }
                else
                {
                    pVar->vt = VT_ERROR;
                }
                break;
            }

    }

   if(hr != S_OK)
   {
        memset(pVar, 0, sizeof(PROPVARIANT));
        pVar->vt = VT_EMPTY;
   }   

   return hr;
}

STDMETHODIMP Intshcut::RemovePropertyNPB (
                            /* [in] */ LPCOLESTR pszSectionNameW,
                            /* [in] */ LPCOLESTR pszPropNameW)
{
    const TCHAR *pszSectionName;
    const TCHAR *pszPropName;
    HRESULT hr;
    TCHAR *pszFileToDeleteFrom;

    // Return if there is no file name
    if((NULL == pszSectionNameW) || (NULL == pszPropNameW)) 
    {
        return E_FAIL;
    }

     if(m_pszTempFileName)
     {
        pszFileToDeleteFrom = m_pszTempFileName;
     }
     else if(m_pszFile)
     {
        pszFileToDeleteFrom = m_pszFile;
     }
     else
     {
        return E_FAIL;
     }
     
    
    // Just delete the key corresponding to this property name
    pszSectionName = pszSectionNameW;
    pszPropName = pszPropNameW;

    hr = SHDeleteIniString(pszSectionName, pszPropName, pszFileToDeleteFrom)? S_OK : E_FAIL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\msstkppg.h ===
//=--------------------------------------------------------------------------=
// MSStkPPg.H
//=--------------------------------------------------------------------------=
// Copyright  1995  Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for msprop32's property pages.
//
#ifndef _MS_STOCK_PROP_PAGES_H_

// {7EBDAAE0-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockFontPage, 0x7ebdaae0, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

// {7EBDAAE1-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockColorPage, 0x7ebdaae1, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

// {7EBDAAE2-8120-11cf-899F-00AA00688B10}
DEFINE_GUID(CLSID_StockPicturePage, 0x7ebdaae2, 0x8120, 0x11cf, 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10);

#define _MS_STOCK_PROP_PAGES_H_
#endif // _MS_STOCK_PROP_PAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\multinfo.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 2.00.0102 */
/* at Fri Mar 29 16:59:57 1996
 */
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __multinfo_h__
#define __multinfo_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IProvideClassInfo_FWD_DEFINED__
#define __IProvideClassInfo_FWD_DEFINED__
typedef interface IProvideClassInfo IProvideClassInfo;
#endif 	/* __IProvideClassInfo_FWD_DEFINED__ */


#ifndef __IProvideClassInfo2_FWD_DEFINED__
#define __IProvideClassInfo2_FWD_DEFINED__
typedef interface IProvideClassInfo2 IProvideClassInfo2;
#endif 	/* __IProvideClassInfo2_FWD_DEFINED__ */


#ifndef __IProvideMultipleClassInfo_FWD_DEFINED__
#define __IProvideMultipleClassInfo_FWD_DEFINED__
typedef interface IProvideMultipleClassInfo IProvideMultipleClassInfo;
#endif 	/* __IProvideMultipleClassInfo_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [local] */ 


#ifndef _OLECTL_H_
#include <olectl.h>
#endif

// {A7ABA9C1-8983-11cf-8F20-00805F2CD064}
DEFINE_GUID(IID_IProvideMultipleClassInfo,
0xa7aba9c1, 0x8983, 0x11cf, 0x8f, 0x20, 0x0, 0x80, 0x5f, 0x2c, 0xd0, 0x64);


extern RPC_IF_HANDLE __MIDL__intf_0053_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0053_v0_0_s_ifspec;

#ifndef __IProvideMultipleClassInfo_INTERFACE_DEFINED__
#define __IProvideMultipleClassInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideMultipleClassInfo
 * at Fri Mar 29 16:59:57 1996
 * using MIDL 2.00.0102
 ****************************************/
/* [unique][uuid][object] */ 


#define MULTICLASSINFO_GETTYPEINFO           0x00000001
#define MULTICLASSINFO_GETNUMRESERVEDDISPIDS 0x00000002
#define MULTICLASSINFO_GETIIDPRIMARY         0x00000004
#define MULTICLASSINFO_GETIIDSOURCE          0x00000008
#define TIFLAGS_EXTENDDISPATCHONLY           0x00000001

EXTERN_C const IID IID_IProvideMultipleClassInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideMultipleClassInfo : public IProvideClassInfo2
    {
    public:
        virtual HRESULT __stdcall GetMultiTypeInfoCount( 
            /* [out] */ ULONG __RPC_FAR *pcti) = 0;
        
        virtual HRESULT __stdcall GetInfoOfIndex( 
            /* [in] */ ULONG iti,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
            /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
            /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
            /* [out] */ IID __RPC_FAR *piidPrimary,
            /* [out] */ IID __RPC_FAR *piidSource) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvideMultipleClassInfoVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IProvideMultipleClassInfo __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IProvideMultipleClassInfo __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *GetClassInfo )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [out] */ LPTYPEINFO __RPC_FAR *ppTI);
        
        HRESULT ( __stdcall __RPC_FAR *GetGUID )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ DWORD dwGuidKind,
            /* [out] */ GUID __RPC_FAR *pGUID);
        
        HRESULT ( __stdcall __RPC_FAR *GetMultiTypeInfoCount )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcti);
        
        HRESULT ( __stdcall __RPC_FAR *GetInfoOfIndex )( 
            IProvideMultipleClassInfo __RPC_FAR * This,
            /* [in] */ ULONG iti,
            /* [in] */ DWORD dwFlags,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
            /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
            /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
            /* [out] */ IID __RPC_FAR *piidPrimary,
            /* [out] */ IID __RPC_FAR *piidSource);
        
    } IProvideMultipleClassInfoVtbl;

    interface IProvideMultipleClassInfo
    {
        CONST_VTBL struct IProvideMultipleClassInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvideMultipleClassInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideMultipleClassInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideMultipleClassInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideMultipleClassInfo_GetClassInfo(This,ppTI)	\
    (This)->lpVtbl -> GetClassInfo(This,ppTI)


#define IProvideMultipleClassInfo_GetGUID(This,dwGuidKind,pGUID)	\
    (This)->lpVtbl -> GetGUID(This,dwGuidKind,pGUID)


#define IProvideMultipleClassInfo_GetMultiTypeInfoCount(This,pcti)	\
    (This)->lpVtbl -> GetMultiTypeInfoCount(This,pcti)

#define IProvideMultipleClassInfo_GetInfoOfIndex(This,iti,dwFlags,pptiCoClass,pdwTIFlags,pcdispidReserved,piidPrimary,piidSource)	\
    (This)->lpVtbl -> GetInfoOfIndex(This,iti,dwFlags,pptiCoClass,pdwTIFlags,pcdispidReserved,piidPrimary,piidSource)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IProvideMultipleClassInfo_GetMultiTypeInfoCount_Proxy( 
    IProvideMultipleClassInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcti);


void __RPC_STUB IProvideMultipleClassInfo_GetMultiTypeInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT __stdcall IProvideMultipleClassInfo_GetInfoOfIndex_Proxy( 
    IProvideMultipleClassInfo __RPC_FAR * This,
    /* [in] */ ULONG iti,
    /* [in] */ DWORD dwFlags,
    /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *pptiCoClass,
    /* [out] */ DWORD __RPC_FAR *pdwTIFlags,
    /* [out] */ ULONG __RPC_FAR *pcdispidReserved,
    /* [out] */ IID __RPC_FAR *piidPrimary,
    /* [out] */ IID __RPC_FAR *piidSource);


void __RPC_STUB IProvideMultipleClassInfo_GetInfoOfIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideMultipleClassInfo_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\mainloop.cpp ===
#include "priv.h"
#include <iethread.h>
#include "winlist.h"
#include "htregmng.h"
#include "resource.h"
#include "inetnot.h"

#include <mluisupp.h>

// Inststub uses kernel string funcions and unbounded buffer functions
#undef lstrcmp
#undef lstrcmpi

#define lstrcmp    StrCmpW
#define lstrcmpi   StrCmpIW

// need these defined before including <runonce.c> which is included by <inststub.h>
BOOL g_fCleanBoot = FALSE;
BOOL g_fEndSession = FALSE;
#include <inststub.h>

#undef lstrcmp
#undef lstrcmpi

#define lstrcmp        Do_not_use_lstrcmp_use_StrCmp
#define lstrcmpi       Do_not_use_lstrcmpi_use_StrCmpI


/* Old install stub API (no parameters) for compatibility for a few builds */
EXTERN_C void RunInstallUninstallStubs(void)
{
    RunInstallUninstallStubs2(NULL);
}


void IERevokeClassFactoryObject(void);

#ifndef POSTPOSTSPLIT
// This value will be initialized to 0 only when we are under IExplorer.exe
UINT g_tidParking = 0;
#endif


#define DM_FAVORITES 0

#ifdef BETA_WARNING
#pragma message("buidling with time bomb enabled")
void DoTimebomb(HWND hwnd)
{
    SYSTEMTIME st;
    GetSystemTime(&st);

    //
    // Revision History:
    //  End of October, 1996
    //  April, 1997
    //  September, 1997 (for beta-1)
    //  November 15th, 1997 (for beta-2)
    //
    if (st.wYear > 1997 || (st.wYear==1997 && st.wMonth > 11) ||
            (st.wYear==1997 && st.wMonth == 11 && st.wDay > 15))
    {
        TCHAR szTitle[128];
        TCHAR szBeta[512];

        MLLoadShellLangString(IDS_CABINET, szTitle, ARRAYSIZE(szTitle));
        MLLoadShellLangString(IDS_BETAEXPIRED, szBeta, ARRAYSIZE(szBeta));

        MessageBox(hwnd, szBeta, szTitle, MB_OK);
    }
}
#else
#define DoTimebomb(hwnd)
#endif


/*----------------------------------------------------------
Purpose: Initialize the favorites folder if it doesn't exist.

Returns: --

Cond:    As a side-effect, SHGetSpecialFolderPath calls Ole
         functions.  So this function must be called after
         OleInitialize has been called.

Note:    This is only really required on win95 / NT4 in
         browser only mode.  The shell32.dll that ships
         with IE4 can handle CSIDL_FAVORITES with fCreate=TRUE.
*/
void InitFavoritesDir()
{
    TCHAR szPath[MAX_PATH];

    if (!SHGetSpecialFolderPath(NULL, szPath, CSIDL_FAVORITES, TRUE))
    {
        TCHAR szFavorites[80];

        TraceMsg(DM_FAVORITES, "InitFavoritesDir -- no favorites");

        // if this failed, that means we need to create it ourselves
        GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
        MLLoadString(IDS_FAVORITES, szFavorites, ARRAYSIZE(szFavorites));
        PathCombine(szPath, szPath, szFavorites);
        SHCreateDirectory(NULL, szPath);

        HKEY hkExplorer;
        if (RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER, &hkExplorer) == ERROR_SUCCESS)
        {
            HKEY hkUSF;

            if (RegCreateKey(hkExplorer, TEXT("User Shell Folders"), &hkUSF) == ERROR_SUCCESS)
            {
                BOOL f;

                TraceMsg(DM_FAVORITES, "InitFavoritesDir -- created in %s", szPath);

                RegSetValueEx(hkUSF, TEXT("Favorites"), 0, REG_SZ, (LPBYTE)szPath, (1 + lstrlen(szPath)) * SIZEOF(TCHAR));
                f = SHGetSpecialFolderPath(NULL, szPath, CSIDL_FAVORITES, TRUE);
                TraceMsg(DM_FAVORITES, "InitFavoritesDir -- cached at %d %s", f, szPath);

                ASSERT(f);
                RegCloseKey(hkUSF);
            }

            RegCloseKey(hkExplorer);
        }
    }
}


#ifdef ENABLE_CHANNELS
//
// Copy ChanBarSetAutoLaunchRegValue from browseui.
//
//extern void ChanBarSetAutoLaunchRegValue(BOOL fAutoLaunch);
void ChanBarSetAutoLaunchRegValue(BOOL fAutoLaunch)
{
    SHRegSetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), 
                    TEXT("Show_ChannelBand"), REG_SZ, 
                    fAutoLaunch ? TEXT("yes") : TEXT("no"),
                    sizeof(fAutoLaunch ? TEXT("yes") : TEXT("no")), 
                    SHREGSET_HKCU | SHREGSET_FORCE_HKCU);
}

#endif  // ENABLE_CHANNELS

STDAPI SHCreateSplashScreen(ISplashScreen ** pSplash);
typedef BOOL (*PFNISDEBUGGERPRESENT)(void);
void CUrlHistory_CleanUp();

//
// Mean Time To Failure check routines
//
void _TweakCurrentDirectory()
{
    TCHAR szPath[MAX_PATH];
    if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_DESKTOPDIRECTORY, FALSE))
        SetCurrentDirectory(szPath);
}

BOOL _IsDebuggerPresent()
{
    static BOOL bDebugger = -1;
    if (bDebugger == -1)
    {
        bDebugger = FALSE;
        // See if a debugger is present and bail on splash screen
        // so we don't get in the way of people... This api is only
        // present on NT...
        if (g_fRunningOnNT)
        {
            PFNISDEBUGGERPRESENT pfndebugger = (PFNISDEBUGGERPRESENT)GetProcAddress(GetModuleHandle(TEXT("KERNEL32")), "IsDebuggerPresent");
            if (pfndebugger)
                bDebugger = pfndebugger();
        }
    }
    return bDebugger;
}

PCWSTR IEGetArgs(PCWSTR pszCmd)
{
    if (*pszCmd == TEXT('\"'))
    {
        //  just strip the first quoted string
        while (*++pszCmd)
        {
            if (*pszCmd == L'\"')
            {
                pszCmd++;
                break;
            }
        }
    }
    else
    {
         while (*pszCmd > TEXT(' '))
            pszCmd++;
    }

    // strip the leading spaces
    while (*pszCmd && *pszCmd <= L' ')
        pszCmd++;

    return pszCmd;
}

PCWSTR EatIExploreArgs(PCWSTR pszArgs)
{
    //  this switches match the switches that are conumed/checked
    //  in iexplore\mainloop.cpp.  most params are in SHParseIECommandLine
    //  but these few apply only to IExplore.exe
    static const PCWSTR s_pszEatArgs[] = 
    {
        L"-eval",
        L"-new",
        L"-nowait"
    };

    pszArgs = IEGetArgs(pszArgs);

    for (int i = 0; i < ARRAYSIZE(s_pszEatArgs); i++)
    {
        int cch = lstrlenW(s_pszEatArgs[i]);
        if (0 == StrCmpNIW(s_pszEatArgs[i], pszArgs, cch))
        {
            if (!pszArgs[cch] || pszArgs[cch] == L' ')
                pszArgs += cch;
            //  strip the spaces
            while (pszArgs[0] == L' ')
                pszArgs++;

            //  start over, we need to go through this list until we get them all
            i = -1;
        }

    }
    return pszArgs;
}

BOOL g_fBrowserOnlyProcess = FALSE;

// this entry is used by IEXPLORE.EXE to run the browser in a separate process. this is the
// standard setting, but browsers (IE) can also be run in the same process if BrowseInSeparateProcess
// is turned off (for better perf, worse stability)

STDAPI_(int) IEWinMain(LPSTR pszCmdLine, int nCmdShow)
{
    //  this flag indicates that this
    //  browser is running in its own process
    //  and is not integrated with the shell
    //  even if it is running on an intgrated shell
    g_fBrowserOnlyProcess = TRUE;

    _TweakCurrentDirectory();

    if (g_dwProfileCAP & 0x00000001)
        StartCAP();

#ifdef FULL_DEBUG
    // Turn off GDI batching so that paints are performed immediately
    GdiSetBatchLimit(1);
#endif

    ASSERT(g_tidParking == 0);

    g_tidParking = GetCurrentThreadId();

    ISplashScreen *pSplash = NULL;
        
    // Show splash screen, be simple for beta 1...
    if (!_IsDebuggerPresent())
    {
        if (SUCCEEDED(SHCreateSplashScreen(&pSplash)))
        {
            HWND hSplash;
            pSplash->Show( HINST_THISDLL, -1, -1, &hSplash );
        }
    }            

    if (SUCCEEDED(OleInitialize(NULL)))
    {
        BOOL fWeOwnWinList = WinList_Init();
        IETHREADPARAM* piei = SHCreateIETHREADPARAM(NULL, nCmdShow, NULL, NULL);
        if (piei) 
        {
            //
            // Create favorites dir (by hand if necessary).
            //
            InitFavoritesDir();

            //
            //  If we are opening IE with no parameter, check if this is
            // the very first open.
            //
            piei->pSplash = pSplash;
            if (pszCmdLine && pszCmdLine[0])
            {
                USES_CONVERSION;
                //  we are passed the an ANSI cmd line from IExplore.exe
                //  this is lame on NT when we can have UNICODE file names.
                //  on win9x, of course, GetCommandLineW() will return NULL
                //  so we use the one passed to use from IExplore.exe
                LPCWSTR pwszCmdLine;
                if (IsOS(OS_NT))
                    pwszCmdLine = EatIExploreArgs(GetCommandLineW());
                else
                    pwszCmdLine = A2W(pszCmdLine);
                    
                SHParseIECommandLine(&pwszCmdLine, piei);
                // If the "-channelband" option is selected, turn it ON by default
#ifdef ENABLE_CHANNELS
                if (piei->fDesktopChannel)
                    ChanBarSetAutoLaunchRegValue(TRUE);
#endif  // ENABLE_CHANNELS
                piei->pszCmdLine = StrDupW(pwszCmdLine);
            }
            else
            {
                piei->fCheckFirstOpen = TRUE;
            }

            DoTimebomb(NULL);
            piei->uFlags |= (COF_CREATENEWWINDOW | COF_NOFINDWINDOW | COF_INPROC | COF_IEXPLORE);
            
            SHOpenFolderWindow(piei);
        }

        IERevokeClassFactoryObject();
        CUrlHistory_CleanUp();

        if (fWeOwnWinList)
            WinList_Terminate();

        CWinInetNotify::GlobalDisable();
        InternetSetOption(NULL, INTERNET_OPTION_DIGEST_AUTH_UNLOAD, NULL, 0);

        OleUninitialize();
    }

    ATOMICRELEASE(g_psfInternet);

#ifdef DEBUG
    CoFreeUnusedLibraries();
#endif

    TraceMsg(TF_SHDTHREAD, "IEWinMain about to call ExitProcess");

    if (g_dwProfileCAP & 0x00020000)
        StopCAP();

    ExitProcess(0);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\mypics.cpp ===
#include "priv.h"
#include <iehelpid.h>
#include <pstore.h>
#include "hlframe.h"
#include "shldisp.h"
#include "opsprof.h"
#include "resource.h"
#include <mluisupp.h>
#include "htmlstr.h"
#include "mypics.h"
#include "mshtmcid.h"
#include "util.h"
#include "winuser.h"

//////////////////////////////////////////////////////////////////////////////////
//
// filename:    mypics.cpp
//
// description: implements the my pictures exposure hoverbar thingie
//
// notes:       lots of stuff is stolen from iforms.cpp and iformsp.h
//
// history:     06.15.2000 created by t-jdavis
//
//////////////////////////////////////////////////////////////////////////////////

extern HINSTANCE g_hinst;

#define TF_MYPICS TF_CUSTOM2

// we don't actually use all of these, but we COULD, you know, if we wanted too.
CMyPicsEventSinkCallback::EventSinkEntry CMyPicsEventSinkCallback::EventsToSink[] =
{
    { EVENT_MOUSEOVER,  L"onmouseover", L"mouseover"  }, 
    { EVENT_MOUSEOUT,   L"onmouseout",  L"mouseout"   }, 
    { EVENT_SCROLL,     L"onscroll",    L"scroll"     }, 
    { EVENT_RESIZE,     L"onresize",    L"resize"     }
};  

// image toolbar states
enum 
{ 
    HOVERSTATE_HIDING = 0,
    HOVERSTATE_SHOWING,
    HOVERSTATE_LOCKED,
    HOVERSTATE_SCROLLING,
    HOVERSTATE_WAITINGTOSHOW
};

//
// CMyPics
//

// set some stuff
CMyPics::CMyPics()
{
    TraceMsg(TF_MYPICS, "+CMyPics::CMyPics");

    m_Hwnd              = NULL;
    m_hWndMyPicsToolBar = NULL;
    m_hWndHover         = NULL;
    m_pEleCurr          = NULL;
    m_pSink             = NULL;
    m_bIsOffForSession  = FALSE;
    m_cRef              = 1;
    m_bGalleryMeta      = TRUE;

    TraceMsg(TF_MYPICS, "-CMyPics::CMyPics");
}

// destroy whatever needs destroying....
CMyPics::~CMyPics()
{
    TraceMsg(TF_MYPICS, "+CMyPics::~CMyPics");

    DestroyHover();  

    ATOMICRELEASE(m_pEleCurr);

    if (m_hWndMyPicsToolBar)
        DestroyWindow(m_hWndMyPicsToolBar);

    if (m_hWndHover)
    {
        SetWindowPtr(m_hWndHover, GWLP_USERDATA, NULL);
        DestroyWindow(m_hWndHover);
    }

    TraceMsg(TF_MYPICS, "-CMyPics::~CMyPics");
}


// did the user turn this feature off?
BOOL CMyPics::IsOff() 
{
    return (m_bIsOffForSession);
}

void CMyPics::IsGalleryMeta(BOOL bFlag)
{
    m_bGalleryMeta = bFlag;
}

HRESULT CMyPics::Init(IHTMLDocument2 *pDoc2)
{
    HRESULT hr = S_OK;

    TraceMsg(TF_MYPICS, "+CMyPics::Init");

    ASSERT(pDoc2);

    //sink things
    IHTMLElement2           *pEle2       = NULL;
    IHTMLElementCollection  *pCollect    = NULL;
    IHTMLElementCollection  *pSubCollect = NULL;
    IDispatch               *pDisp       = NULL;
    VARIANT                  TagName;
    ULONG                    ulCount     = 0;
    VARIANTARG               va1;
    VARIANTARG               va2;
    IHTMLWindow3            *pWin3       = NULL;
    
    // ...remember this...
    m_pDoc2 = pDoc2;
    pDoc2->AddRef();
    
    // setup variant for finding all the IMG tags...
    TagName.vt      = VT_BSTR;
    TagName.bstrVal = (BSTR)c_bstr_IMG;
    
    //get all tags
    hr = pDoc2->get_all(&pCollect);                   
    if (FAILED(hr))
        goto Cleanup;

    //get all IMG tags
    hr = pCollect->tags(TagName, &pDisp);
    if (FAILED(hr))
        goto Cleanup;
        
    if (pDisp) 
    {
        hr = pDisp->QueryInterface(IID_IHTMLElementCollection,(void **)&pSubCollect);
        ATOMICRELEASE(pDisp);
    }
    if (FAILED(hr))
        goto Cleanup;

    //get IMG tag count
    hr = pSubCollect->get_length((LONG *)&ulCount);
    if (FAILED(hr))
        goto Cleanup;

    va1.vt = VT_I4;
    va2.vt = VT_EMPTY;
        
    //iterate through tags sinking events to elements
    for (int i=0; i<(LONG)ulCount; i++) 
    {
        pDisp    = NULL;                                
        va1.lVal = (LONG)i;
        pSubCollect->item(va1, va2, &pDisp);

        // only create a new CEventSink once
        if (!m_pSink && pDisp)
            m_pSink = new CEventSink(this);

        if (pDisp) 
        {
            hr = pDisp->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);
            if (FAILED(hr))
                goto Cleanup;

            ASSERT(m_pSink);

            if (m_pSink && pEle2) 
            {
                EVENTS events[] = { EVENT_MOUSEOVER, EVENT_MOUSEOUT, EVENT_RESIZE };
                m_pSink->SinkEvents(pEle2, ARRAYSIZE(events), events);
            }
            ATOMICRELEASE(pEle2);
            ATOMICRELEASE(pDisp);
        }
    }
    

    // sink scroll event from the window, because it doesn't come from elements.
    if (m_pSink) 
    {
        Win3FromDoc2(m_pDoc2, &pWin3);

        if (pWin3) 
        {
            m_pWin3 = pWin3;
            m_pWin3->AddRef();

            EVENTS eventScroll[] = { EVENT_SCROLL };
            m_pSink->SinkEvents(pWin3, ARRAYSIZE(eventScroll), eventScroll);
        }
    }
    
    //end sinking things

Cleanup:

    ATOMICRELEASE(pCollect);
    ATOMICRELEASE(pSubCollect);
    ATOMICRELEASE(pWin3);
    ATOMICRELEASE(pDisp);
    ATOMICRELEASE(pEle2);

    TraceMsg(TF_MYPICS, "-CMyPics::Init");

    return hr;
}

HRESULT CMyPics::UnInit()
{
    // Unhook regular event sink

    TraceMsg(TF_MYPICS, "+CMyPics::UnInit");

    if (m_pSink) 
    {
        if (m_pWin3) 
        {
            EVENTS events[] = { EVENT_SCROLL };
            m_pSink->UnSinkEvents(m_pWin3, ARRAYSIZE(events), events);
            SAFERELEASE(m_pWin3);
        }

        m_pSink->SetParent(NULL);
        ATOMICRELEASE(m_pSink);
    }

    SAFERELEASE(m_pEleCurr);
    SAFERELEASE(m_pDoc2);
    
    TraceMsg(TF_MYPICS, "-CMyPics::UnInit");

    return S_OK;
}

ULONG CMyPics::AddRef(void) 
{
    return ++m_cRef;
}

ULONG CMyPics::Release(void) 
{
    if (--m_cRef == 0) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

// has this been disabled by some administrator or something via IEAK?
BOOL MP_IsEnabledInIEAK()
{
    DWORD dwType = REG_DWORD;
    DWORD dwSize;
    DWORD dwEnabled;  // dsheldon - should this var be called dwDisabled since we say (dwEnabled != 1) == enabled?
    DWORD dwRet;
    
    const TCHAR c_szSPMIEPS[] = TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\PhotoSupport");
    const TCHAR c_szVal[]     = TEXT("MyPics_Hoverbar");

    dwSize = sizeof(dwEnabled);

    dwRet = SHGetValue(HKEY_CURRENT_USER, c_szSPMIEPS, c_szVal, &dwType, &dwEnabled, &dwSize);

    if ((dwType == REG_DWORD) && (dwRet == ERROR_SUCCESS)) 
    {
        if (dwEnabled!=1)
            return TRUE;  // enabled
        else
            return FALSE; // disabled
    }

    // value not found...
    return TRUE;
}

// has the user explicitly disabled this feature for now and all time via intern control panel?
BOOL MP_IsEnabledInRegistry()
{
    DWORD dwType = REG_SZ;
    DWORD dwSize;
    TCHAR szEnabled[16];
    DWORD dwRet;
    
    const TCHAR c_szSMIEM[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
    const TCHAR c_szVal[]   = TEXT("Enable_MyPics_Hoverbar");

    dwSize = sizeof(szEnabled);

    dwRet = SHGetValue(HKEY_CURRENT_USER, c_szSMIEM, c_szVal, &dwType, szEnabled, &dwSize);

    if (dwRet == ERROR_INSUFFICIENT_BUFFER) 
    {
        ASSERT(dwRet == ERROR_SUCCESS); // this is wacky...
        return FALSE;
    }

    if ((dwType == REG_SZ) && (dwRet == ERROR_SUCCESS)) 
    {
        if (!StrCmp(szEnabled, TEXT("yes")))
            return TRUE;  // enabled
        else
            return FALSE; // disabled
    }

    // value not found...
    return TRUE;
}

DWORD MP_GetFilterInfoFromRegistry()
{

    const TCHAR c_szSMIEAOMM[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
    const TCHAR c_szVal[]      = TEXT("Image_Filter");
   
    DWORD dwType, dwSize, dwFilter, dwRet;
    
    dwSize = sizeof(dwFilter);

    dwRet = SHGetValue(HKEY_CURRENT_USER, c_szSMIEAOMM, c_szVal, &dwType, &dwFilter, &dwSize);

    if ((dwRet != ERROR_SUCCESS) || (dwType != REG_DWORD))
    {
        dwFilter = MP_MIN_SIZE;
    }

    return dwFilter;
}

DWORD MP_GetOffsetInfoFromRegistry()
{

    const TCHAR c_szSMIEAOMM[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
    const TCHAR c_szVal[]      = TEXT("Offset");
   
    DWORD dwType, dwSize, dwOffset, dwRet;
    
    dwSize = sizeof(dwOffset);

    dwRet = SHGetValue(HKEY_CURRENT_USER, c_szSMIEAOMM, c_szVal, &dwType, &dwOffset, &dwSize);

    if ((dwRet != ERROR_SUCCESS) || (dwType != REG_DWORD))
    {
        dwOffset = MP_HOVER_OFFSET;
    }

    return dwOffset;
}

BOOL_PTR CALLBACK DisableMPDialogProc(HWND hDlg, UINT uMsg, WPARAM wparam, LPARAM lparam) 
{
    BOOL bMsgHandled = FALSE;

    switch (uMsg) 
    {
        case WM_INITDIALOG:
        {
            // center dialog... yay msdn...
            RECT rc;
            GetWindowRect(hDlg, &rc);
            SetWindowPos(hDlg, HWND_TOP,
            ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
            ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
            0, 0, SWP_NOSIZE);
        } 
        break;

    case WM_COMMAND:
        switch (LOWORD(wparam)) 
        {
            case IDC_MP_ALWAYS:
                EndDialog(hDlg, IDC_MP_ALWAYS);
                break;

            case IDC_MP_THISSESSION:
                EndDialog(hDlg, IDC_MP_THISSESSION);
                break;

            case IDC_MP_CANCEL:
                EndDialog(hDlg, IDC_MP_CANCEL);
                break;
        }
        break;

    case WM_CLOSE:
        EndDialog(hDlg, IDC_MP_CANCEL);
        break;

    default:
        break;
    }
    return(bMsgHandled);
}


LRESULT CALLBACK CMyPics::s_WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CMyPics* pThis = (CMyPics*)GetWindowPtr(hWnd, GWLP_USERDATA);    

    TraceMsg(TF_MYPICS, "+CMyPics::s_WndProc  hWnd=%x, pThis=%p", hWnd, pThis);

    HRESULT             hr                = S_OK;
    IOleCommandTarget  *pOleCommandTarget = NULL;   
    switch (uMsg) 
    {
        case WM_SIZE:
            
            if (!pThis)
                break;

            SetWindowPos(pThis->m_hWndMyPicsToolBar, NULL, 0, 0, LOWORD(lParam), HIWORD(lParam), SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);
            break;

        case WM_ERASEBKGND:

            if (!pThis)
                break;

            {
                RECT rc;
                HBRUSH hb = GetSysColorBrush(COLOR_3DFACE);

                GetClientRect(pThis->m_hWndMyPicsToolBar, &rc);
                FillRect((HDC)wParam, &rc, hb);
                return TRUE;
            }

        case WM_COMMAND:

            if (!pThis)
                break;

            switch(LOWORD(wParam))
            {
                case IDM_MYPICS_SAVE:   //Save As... dialogue
                    
                    ASSERT(pThis->m_pEleCurr);

                    // the evil QI call... 
                    hr = pThis->m_pEleCurr->QueryInterface(IID_IOleCommandTarget, (void **)&pOleCommandTarget);
                    if (FAILED(hr))
                        return(hr);

                    // hide the hoverthing so it doesn't cause us any nasty problems
                    pThis->HideHover();
                    
                    // launch the Save As dialogue thingie...
                    pOleCommandTarget->Exec(&CGID_MSHTML, IDM_SAVEPICTURE, 0, 0, NULL);
                    ATOMICRELEASE(pOleCommandTarget);

                break;
                
                case IDM_MYPICS_PRINT:
                {
                    // get the cmd target
                    hr = pThis->m_pEleCurr->QueryInterface(IID_IOleCommandTarget, (void **)&pOleCommandTarget);
                    if (FAILED(hr))
                        return(hr);
                    
                    pThis->HideHover();
                    //pThis->m_hoverState = HOVERSTATE_SHOWING; // kludge to keep hover from appearing under print dialogue

                    pOleCommandTarget->Exec(&CGID_MSHTML, IDM_MP_PRINTPICTURE, 0, 0, NULL);
                    ATOMICRELEASE(pOleCommandTarget);
                    
                    //pThis->m_hoverState = HOVERSTATE_HIDING;
                }
                    
                break;
                
                case IDM_MYPICS_EMAIL:
                {
                    // get the cmd target...
                    hr = pThis->m_pEleCurr->QueryInterface(IID_IOleCommandTarget, (void **)&pOleCommandTarget);
                    if (FAILED(hr)) 
                        return(hr);

                    // ... and then hide the hover bar...
                    pThis->HideHover();
                    //pThis->m_hoverState = HOVERSTATE_SHOWING; // kludge to keep hover from appearing under print dialogue

                    // ... and pray this works...
                    pOleCommandTarget->Exec(&CGID_MSHTML, IDM_MP_EMAILPICTURE, 0, 0, NULL);
                    ATOMICRELEASE(pOleCommandTarget);

                    // ... and cleanup
                    //pThis->m_hoverState = HOVERSTATE_HIDING;
                }
                    
                break;
                
                case IDM_MYPICS_MYPICS:   // Open My Pictures folder

                    // get the cmd target
                    hr = pThis->m_pEleCurr->QueryInterface(IID_IOleCommandTarget, (void **)&pOleCommandTarget);
                    if (FAILED(hr)) 
                        return(hr);
                    
                    pOleCommandTarget->Exec(&CGID_MSHTML, IDM_MP_MYPICS, 0, 0, NULL);
                    ATOMICRELEASE(pOleCommandTarget);

                    hr = S_OK;
                    pThis->HideHover();

                break;

                default:
                    break;
            }
            break;
            

        case WM_NOTIFY:  // tooltips...

            if (!pThis)
                break;
            
            switch (((LPNMHDR)lParam)->code) 
            {
                case TTN_NEEDTEXT:
                {
                    LPTOOLTIPTEXT lpToolTipText;
                    TCHAR szBuf[MAX_PATH];
                    lpToolTipText = (LPTOOLTIPTEXT)lParam;
                    hr = MLLoadString((UINT)lpToolTipText->hdr.idFrom,   
                                      szBuf,
                                      ARRAYSIZE(szBuf));
                    lpToolTipText->lpszText = szBuf;
                    break;
                }
            }
            break;

        case WM_SETTINGCHANGE:

            if (!pThis)
                break;

            {
                pThis->DestroyHover();                                 // to stop wierd window distortion
                break;
            }

        case WM_CONTEXTMENU:

            if (!pThis)
                break;

            {
                // load the menu
                HMENU hMenu0 = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(IDR_MYPICS_CONTEXT_MENU));
                HMENU hMenu1 = GetSubMenu(hMenu0, 0);

                if(!hMenu1)
                    break;
                
                POINT point;

                point.x = (LONG)GET_X_LPARAM(lParam);
                point.y = (LONG)GET_Y_LPARAM(lParam);

                ASSERT(pThis->m_hoverState=HOVERSTATE_SHOWING);

                // lock against mouseouts
                pThis->m_hoverState = HOVERSTATE_LOCKED;

                // display it, get choice (if any)
                int   iPick = TrackPopupMenu(hMenu1, 
                                             TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                                             point.x,
                                             point.y,
                                             0,
                                             hWnd,
                                             (RECT *)NULL);

                DestroyMenu(hMenu0);
                DestroyMenu(hMenu1);

                pThis->m_hoverState = HOVERSTATE_SHOWING;

                if (iPick) 
                {
                    switch(iPick) 
                    {
                        case IDM_DISABLE_MYPICS:
                            {
                                pThis->HideHover();
                                
                                // create dialog to ask user if they want to turn this stuff off...
                                // (explicit cast to make Win64 builds happy)
                                int iResult = (int)DialogBoxParam(MLGetHinst(),
                                                             MAKEINTRESOURCE(DLG_DISABLE_MYPICS),
                                                             pThis->m_Hwnd,
                                                             DisableMPDialogProc,
                                                             NULL);
                                
                                // deal with their choice...
                                if (iResult) 
                                {
                                    switch (iResult) 
                                    {
                                        case IDC_MP_ALWAYS:
                                            {
                                                pThis->m_bIsOffForSession = TRUE;
                                                DWORD dwType = REG_SZ;
                                                DWORD dwSize;
                                                TCHAR szEnabled[16] = TEXT("no");
                                                DWORD dwRet;
     
                                                const TCHAR c_szSMIEM[] = 
                                                            TEXT("Software\\Microsoft\\Internet Explorer\\Main");
                                                const TCHAR c_szVal[]   = TEXT("Enable_MyPics_Hoverbar");

                                                dwSize = sizeof(szEnabled);

                                                dwRet = SHSetValue(HKEY_CURRENT_USER, 
                                                                   c_szSMIEM, 
                                                                   c_szVal,
                                                                   dwType, 
                                                                   szEnabled, 
                                                                   dwSize);
                                            }
                                            break;
                                        case IDC_MP_THISSESSION:
                                            // twiddle member var flag
                                            // this is propagated back up to COmWindow via ReleaseMyPics() function.
                                            pThis->m_bIsOffForSession = TRUE;
                                            
                                            break;

                                        default:
                                            break;
                                    }
                                }
                            }
                            break;
                        case IDM_HELP_MYPICS:
                                pThis->HideHover();
                                SHHtmlHelpOnDemandWrap(hWnd, TEXT("iexplore.chm > iedefault"), 0, (DWORD_PTR) TEXT("pic_tb_ovr.htm"), ML_CROSSCODEPAGE);
                            break;
                        default:
                            // um, do nothing
                            break;
                    }
                }
            }

            break;

        default:
            return (DefWindowProc(hWnd, uMsg, wParam, lParam));
    }


    TraceMsg(TF_MYPICS, "-CMyPics::s_WndProc  hWnd=%x, pThis=%p", hWnd, pThis);

    return (hr);
}

VOID CALLBACK CMyPics::s_TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime) 
{
    TraceMsg(TF_MYPICS, "+CMyPics::TimerProc");

    CMyPics* pThis = (CMyPics*)GetWindowPtr(hwnd, GWLP_USERDATA);

    switch (uMsg) 
    {
        case WM_TIMER:
            KillTimer(hwnd, IDT_MP_TIMER);  
            if (pThis && (pThis->m_hoverState == HOVERSTATE_WAITINGTOSHOW))
            {
                // Our hover bar is waiting to be shown.
                if (pThis->m_pEleCurr)
                {
                    // We still have an element.  Show it.
                    pThis->m_hoverState = HOVERSTATE_SHOWING;

                    pThis->ShowHover();
                } 
                else
                {
                    // Our timer popped, but we don't have an element.
                    pThis->HideHover();
                }
            }
            break;
        
        default:
            break;
    }
    TraceMsg(TF_MYPICS, "-CMyPics::TimerProc");
}


BOOL CMyPics::ShouldAppearOnThisElement(IHTMLElement *pEle) 
{
    BOOL                  bRet              = TRUE; // appear by default
    VARIANT               varVal            = {0};
    BSTR                  bstrAttribute     = NULL; // to check img tags for expando
    IHTMLRect            *pRect             = NULL; // to get screen coords
    IHTMLElement2        *pEle2             = NULL;
    IHTMLElement3        *pEle3             = NULL; // to check for contenteditable mode
    VARIANT_BOOL          bEdit             = FALSE;// becomes true if contenteditable mode is true
    LONG                  lLeft;                    // these are the screen coords
    LONG                  lRight;                   // we get right and bottom to det size of image
    LONG                  lTop;
    LONG                  lBottom;
    DWORD                 dwFilter;
    IOleCommandTarget    *pOleCommandTarget = NULL;

    TraceMsg(TF_MYPICS, "+CMyPics::ShouldAppearOnThisElement");

    // don't create it if it already exists.  thats bad.
    if ((HOVERSTATE_SHOWING == m_hoverState) || (HOVERSTATE_LOCKED == m_hoverState))
    {
        bRet = FALSE;
        goto Cleanup;
    }

    m_bGalleryImg = FALSE;

    if (!pEle)
    {
        bRet = FALSE;
        goto Cleanup;
    }

    // find out if the image didn't load or is unrenderable
    if (SUCCEEDED(pEle->QueryInterface(IID_IOleCommandTarget, (void **)&pOleCommandTarget)))
    {
        OLECMD rgCmd;

        rgCmd.cmdID = IDM_SAVEPICTURE;  // this is the same check the context menu uses
        rgCmd.cmdf = 0;

        pOleCommandTarget->QueryStatus(&CGID_MSHTML, 1, &rgCmd, NULL);

        if (!(OLECMDF_ENABLED & rgCmd.cmdf))
        {
            bRet = FALSE;
            goto Cleanup;
        }
    }

    // check for explicit enable/disable attribute in img tag...
    bstrAttribute=SysAllocString(L"galleryimg"); 
    if (!bstrAttribute) 
        goto Cleanup;

    if (SUCCEEDED(pEle->getAttribute(bstrAttribute, 0, &varVal))) 
    {
        if (varVal.vt == VT_BSTR) 
        {
            if (StrCmpIW(varVal.bstrVal, L"true") == 0 
                || StrCmpIW(varVal.bstrVal, L"on") == 0 
                || StrCmpIW(varVal.bstrVal, L"yes") == 0
                )
            {
                // Explicitly turned on.  Honor it and leave.
                bRet = TRUE;
                m_bGalleryImg = TRUE;
                goto Cleanup;
            }
            if (StrCmpIW(varVal.bstrVal, L"false") == 0 
                || StrCmpIW(varVal.bstrVal, L"off") == 0 
                || StrCmpIW(varVal.bstrVal, L"no") == 0
                )
            {
                // Explicitly turned off.  Honor it and leave.
                bRet = FALSE;
                goto Cleanup;
            }
        } 
        else if (varVal.vt == VT_BOOL)
        {
            if (varVal.boolVal == VARIANT_TRUE)
            {
                bRet = TRUE;
                m_bGalleryImg = TRUE;
                goto Cleanup;
            } 
            else
            {
                bRet = FALSE;
                goto Cleanup;
            }
        }
    } 

    VariantClear(&varVal);
    SysFreeString(bstrAttribute);

    // After checking "galleryimg" tag, check to see if turned off by the META tag
    if (m_bGalleryMeta == FALSE)
        return FALSE;

    // check for mappings on the image...
    bstrAttribute=SysAllocString(L"usemap"); 
    if (!bstrAttribute) 
        return (bRet);

    if (SUCCEEDED(pEle->getAttribute(bstrAttribute, 0, &varVal))) 
    {
        if (varVal.vt == VT_BSTR) 
        {
            // What do we do here?
            bRet = (varVal.bstrVal == NULL);
            if (!bRet)
                goto Cleanup;
        } 
    } 
    VariantClear(&varVal);
    SysFreeString(bstrAttribute);

    // check for mappings on the image...
    bstrAttribute=SysAllocString(L"ismap"); 
    if (!bstrAttribute) 
        return (bRet);

    if (SUCCEEDED(pEle->getAttribute(bstrAttribute, 0, &varVal))) 
    {
        // If the attribute exists, then we need to return FALSE *unless* we see a value of FALSE
        bRet = FALSE;
        if (varVal.vt == VT_BOOL 
            && varVal.boolVal == VARIANT_FALSE)
        {
            // "ismap" is false, so we can show the hover bar over this image.
            bRet = TRUE;
        }
    } 
    if (!bRet)
        goto Cleanup;

    bRet = FALSE;  // If any of the calls below fail, we'll exit with "FALSE".
    
    // Now check to see if we pass the size filter.
    // get an IHTMLElement2 from the IHTMLElement passed in...
    if (FAILED(pEle->QueryInterface(IID_IHTMLElement2, (void **)&pEle2) ))
        goto Cleanup;

    // get coords...
    if (FAILED(pEle2->getBoundingClientRect(&pRect) ))
        goto Cleanup;

    if (FAILED(pRect->get_left(&lLeft) )) 
        goto Cleanup;

    if (FAILED(pRect->get_right(&lRight) ))
        goto Cleanup;

    if (FAILED(pRect->get_top(&lTop) ))
        goto Cleanup;

    if (FAILED(pRect->get_bottom(&lBottom) ))
        goto Cleanup;

    dwFilter = MP_GetFilterInfoFromRegistry();

    // see if this picture is big enough to qualify as a "Photo"... 
    // TODO: decide if we like checking aspect ratio or not
    if ( (lRight - lLeft >= (LONG)dwFilter && lBottom - lTop >= (LONG)dwFilter)
       /*&& !(2*(min(lRight-lLeft,lBottom-lTop)) < max(lRight-lLeft,lBottom-lTop)) */)
        bRet = TRUE;

    if (FAILED(pEle2->QueryInterface(IID_IHTMLElement3, (void **)&pEle3) ))
        goto Cleanup;

    if (FAILED(pEle3->get_isContentEditable(&bEdit) ))
        goto Cleanup;

    if (bEdit)
        bRet = FALSE;

Cleanup:
    VariantClear(&varVal);
    if (bstrAttribute)
        SysFreeString(bstrAttribute);

    SAFERELEASE(pOleCommandTarget);

    SAFERELEASE(pEle3);
    SAFERELEASE(pRect);
    SAFERELEASE(pEle2);
    
    TraceMsg(TF_MYPICS, "-CMyPics::ShouldAppearOnThisElement");

    return bRet;
}

HRESULT CMyPics::CreateHover() 
{
    HRESULT hr      = S_OK;               
    SIZE    size    = {0,0};
    WORD    wImage;
    HBITMAP hbmp    = NULL;
    HBITMAP hbmpHot = NULL;

    TraceMsg(TF_MYPICS, "+CMyPics::CreateHover, this=%p, m_hoverState=%d", this, m_hoverState);

    InitCommonControls();

    WNDCLASS wc = {0};
    wc.style = CS_HREDRAW | CS_VREDRAW;
    wc.lpszClassName = TEXT("MyPicturesHost");
    wc.lpfnWndProc = s_WndProc;
    wc.hInstance = g_hinst;
    wc.hbrBackground = HBRUSH(COLOR_BTNFACE);
    RegisterClass(&wc);


    // create the rebar to hold the toolbar...
    if (!m_hWndHover)
    {

        m_hWndHover = CreateWindow(TEXT("MyPicturesHost"), TEXT(""), WS_DLGFRAME | WS_VISIBLE | WS_CHILD, 
                                   0, 0, 0, 0, m_Hwnd, NULL, g_hinst, NULL);

        if (!m_hWndHover)
        {
            TraceMsg(TF_MYPICS | TF_WARNING, "CMyPics::CreateHover, unable to create m_hWndHover");
            hr = E_FAIL;
            goto Cleanup;
        }

        ASSERT(GetWindowPtr(m_hWndHover, GWLP_USERDATA) == NULL);
        SetWindowPtr(m_hWndHover, GWLP_USERDATA, this);

        // set cc version
        SendMessage(m_hWndHover, CCM_SETVERSION, COMCTL32_VERSION, 0);
    }
    
    // create the toolbar...
    if (!m_hWndMyPicsToolBar)
    {

        m_hWndMyPicsToolBar = CreateWindow(TOOLBARCLASSNAME, TEXT(""), TBSTYLE_TOOLTIPS | CCS_NODIVIDER | TBSTYLE_FLAT | WS_VISIBLE | WS_CHILD,
                                           0,0,0,0, m_hWndHover, NULL, g_hinst, NULL);

        if (!m_hWndMyPicsToolBar)
        {
            TraceMsg(TF_MYPICS | TF_WARNING, "CMyPics::CreateHover, unable to create m_hWndMyPicsToolBar");
            hr = E_FAIL;
            goto Cleanup;
        }
        SetWindowPtr(m_hWndMyPicsToolBar, GWLP_USERDATA, this); // for the timer proc

        // set cc version for this too, and the sizeof tbbutton struct...
        SendMessage(m_hWndMyPicsToolBar, CCM_SETVERSION,      COMCTL32_VERSION, 0);
        SendMessage(m_hWndMyPicsToolBar, TB_BUTTONSTRUCTSIZE, (WPARAM)sizeof(TBBUTTON), 0);
    }

    // create image lists...
    wImage      = ((IsOS(OS_WHISTLERORGREATER)) ? IDB_MYPICS_TOOLBARGW : IDB_MYPICS_TOOLBARG);

    if (!m_himlHover)
    {
        m_himlHover = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(wImage), 16, 0, CLR_DEFAULT, IMAGE_BITMAP, LR_CREATEDIBSECTION);
        if (!m_himlHover)
        {
            TraceMsg(TF_MYPICS | TF_WARNING, "CMyPics::CreateHover, unable to create m_himlHover");
        }
    }


    wImage = ((IsOS(OS_WHISTLERORGREATER)) ? IDB_MYPICS_TOOLBARW : IDB_MYPICS_TOOLBAR);

    if (!m_himlHoverHot)
    {
        m_himlHoverHot = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(wImage) , 16, 0, CLR_DEFAULT, IMAGE_BITMAP, LR_CREATEDIBSECTION);
        if (!m_himlHoverHot)
        {
            TraceMsg(TF_MYPICS | TF_WARNING, "CMyPics::CreateHover, unable to create m_himlHoverHot");
        }
    }

    // set image list and hot image list
    SendMessage(m_hWndMyPicsToolBar, TB_SETIMAGELIST,    0, (LPARAM)m_himlHover   );
    SendMessage(m_hWndMyPicsToolBar, TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlHoverHot);

    TBBUTTON tbButton;

    // set bitmap indexes in tbbutton structure (this may not be necessary)
    for (int i=0;i<MP_NUM_TBBITMAPS;i++)
    {
        tbButton.iBitmap = MAKELONG(i,0);
        tbButton.fsState = TBSTATE_ENABLED;
        tbButton.fsStyle = TBSTYLE_BUTTON;
        tbButton.dwData  = 0;
        tbButton.iString = 0;
        switch(i)
        {
            case 0: tbButton.idCommand = IDM_MYPICS_SAVE; break;
            case 1: tbButton.idCommand = IDM_MYPICS_PRINT; break;
            case 2: tbButton.idCommand = IDM_MYPICS_EMAIL; break;
            case 3: tbButton.idCommand = IDM_MYPICS_MYPICS; break;
        }
        
        SendMessage(m_hWndMyPicsToolBar, TB_INSERTBUTTON, i, (LPARAM)&tbButton);
    }

Cleanup:

    TraceMsg(TF_MYPICS, "-CMyPics::CreateHover, this=%p, m_hoverState=%d", this, m_hoverState);

    return hr;
}

HRESULT CMyPics::DestroyHover() 
{
    HRESULT hr = S_OK;

    TraceMsg(TF_MYPICS, "+CMyPics::DestroyHover, this=%p, m_hoverState=%d", this, m_hoverState);

    // If we have a MyPicsToolBar...
    if (m_hWndMyPicsToolBar)
    {
        // first destroy the toolbar
        if (!DestroyWindow(m_hWndMyPicsToolBar))
        {
            TraceMsg(TF_MYPICS, "In CMyPics::DestroyHover, DestroyWindow(m_hWndMyPicsToolBar) failed");
            hr = E_FAIL;
        }
        m_hWndMyPicsToolBar=NULL;
    }

    // If we have a hover window...
    if (m_hWndHover)
    {
        // Clear the window word
        SetWindowPtr(m_hWndHover, GWLP_USERDATA, NULL);

        // then destroy the rebar
        if (!DestroyWindow(m_hWndHover))
        {
            hr = E_FAIL;
            goto Cleanup;
        }
        m_hWndHover = NULL;
    }

    // and destroy the image lists...
    if (m_himlHover)
    {
        ImageList_Destroy(m_himlHover);
        m_himlHover = NULL;
    }

    if (m_himlHoverHot)
    {
        ImageList_Destroy(m_himlHoverHot);
        m_himlHoverHot = NULL;
    }


Cleanup:
    TraceMsg(TF_MYPICS, "-CMyPics::DestroyHover, this=%p, hr=%x", this, hr);

    return hr;
}

HRESULT CMyPics::HideHover()
{
    HRESULT    hr = S_OK;

    TraceMsg(TF_MYPICS, "+CMyPics::HideHover, this=%p, m_hoverState=%d", this, m_hoverState);

    if (m_hWndHover)
    {
        ShowWindow(m_hWndHover, SW_HIDE);
        m_hoverState = HOVERSTATE_HIDING;
    }
    else
        hr = E_FAIL;

    TraceMsg(TF_MYPICS, "-CMyPics::HideHover, this=%p, m_hoverState=%d", this, m_hoverState);

    return hr;
}


IHTMLElement *CMyPics::GetIMGFromArea(IHTMLElement *pEleIn, POINT ptEvent)
{
    // someone got an IHTMLElement and decided it was an area tag
    // so find the img tag associated and return it as an IHTMLElement

    BSTR                     bstrName    = NULL;
    BSTR                     bstrUseMap  = NULL;
    IHTMLElement            *pEleParent  = NULL;
    IHTMLElement            *pEleMisc    = NULL;
    IHTMLElement2           *pEle2Misc   = NULL;
    IHTMLElement            *pEleMiscPar = NULL;
    IHTMLMapElement         *pEleMap     = NULL;
    IHTMLImgElement         *pEleImg     = NULL;
    IHTMLElement            *pEleOut     = NULL;
    IHTMLElementCollection  *pCollect    = NULL;
    IHTMLElementCollection  *pSubCollect = NULL;
    IDispatch               *pDisp       = NULL;
    VARIANT                  TagName;
    ULONG                    ulCount     = 0;
    VARIANTARG               va1;
    VARIANTARG               va2;
    HRESULT                  hr;
    POINT                    ptMouse,
                             ptScr;
    LONG                     xInIMG      = 0,
                             yInIMG      = 0,
                             lOffset     = 0,
                             lOffsetLeft = 0,
                             lOffsetTop  = 0,
                             lScrollLeft = 0,
                             lScrollTop  = 0,
                             lOffsetW    = 0,
                             lOffsetH    = 0;


    TagName.vt      = VT_BSTR;
    TagName.bstrVal = (BSTR)c_bstr_IMG;

    
    // first get the map element
    if (SUCCEEDED(pEleIn->get_offsetParent(&pEleParent)))
    {
        // get the map element
        hr=pEleParent->QueryInterface(IID_IHTMLMapElement, (void **)&pEleMap);
        if (FAILED(hr))
            goto Cleanup;

        // next get the name of the map
        if (SUCCEEDED(pEleMap->get_name(&bstrName)))
        {
            //next get all tags
            hr = m_pDoc2->get_all(&pCollect);                   
            if (FAILED(hr))
                goto Cleanup;

            //get all IMG tags
            hr = pCollect->tags(TagName, &pDisp);
            if (FAILED(hr))
                goto Cleanup;
        
            if (pDisp) 
            {
                hr = pDisp->QueryInterface(IID_IHTMLElementCollection,(void **)&pSubCollect);
                ATOMICRELEASE(pDisp);
            }
            if (FAILED(hr))
                goto Cleanup;

            //get IMG tag count
            hr = pSubCollect->get_length((LONG *)&ulCount);
            if (FAILED(hr))
                goto Cleanup;
            
            va1.vt = VT_I4;
            va2.vt = VT_EMPTY;

            ASSERT(pDisp==NULL);
        
            //iterate through tags looking for images that have the right usemap set
            for (int i=0; i<(LONG)ulCount; i++) 
            {
                ATOMICRELEASE(pEleImg);
                ATOMICRELEASE(pDisp);
                
                pDisp       = NULL;                                
                bstrUseMap  = NULL;
                xInIMG      = 0;
                yInIMG      = 0;
                lOffset     = 0;
                lOffsetLeft = 0;
                lOffsetTop  = 0;
                lScrollLeft = 0;
                lScrollTop  = 0;
                lOffsetW    = 0;
                lOffsetH    = 0;
                va1.lVal    = (LONG)i;

                pSubCollect->item(va1, va2, &pDisp);

                if (pDisp) 
                {
                    hr = pDisp->QueryInterface(IID_IHTMLImgElement, (void **)&pEleImg);
                    if (FAILED(hr))
                        goto Cleanup;

                    hr = pEleImg->get_useMap(&bstrUseMap);
                    if (FAILED(hr))
                        goto Cleanup;

                    // this will be non-null if set for this IMG element...
                    if (bstrUseMap){
                        // skip the prepended '#' and see if this is what we're looking for...
                        if (StrCmp(bstrUseMap + 1, bstrName) == 0)
                        {
                            m_pWin3->get_screenLeft(&ptScr.x);
                            m_pWin3->get_screenTop (&ptScr.y);

                            //Ok, we found a candidate.  See if the mouse is here...
                            ptMouse.x = ptEvent.x - ptScr.x;
                            ptMouse.y = ptEvent.y - ptScr.y;

                            hr = pDisp->QueryInterface(IID_IHTMLElement, (void **)&pEleMisc);
                            if (FAILED(hr))
                                goto Cleanup;

                            while (pEleMisc)
                            {
                                hr = pEleMisc->QueryInterface(IID_IHTMLElement2, (void **)&pEle2Misc);
                                if (FAILED(hr))
                                    goto Cleanup;

                                pEleMisc->get_offsetLeft(&lOffsetLeft);
                                pEle2Misc->get_scrollLeft(&lScrollLeft);

                                lOffset += lOffsetLeft - lScrollLeft;

                                pEleMisc->get_offsetParent(&pEleMiscPar);
                                ATOMICRELEASE(pEleMisc);
                                ATOMICRELEASE(pEle2Misc);
                                pEleMisc=pEleMiscPar;

                            }

                            ATOMICRELEASE(pEleMiscPar);

                            hr = pDisp->QueryInterface(IID_IHTMLElement, (void **)&pEleMisc);
                            if (FAILED(hr))
                                goto Cleanup;

                            xInIMG = ptMouse.x - lOffset;
                            pEleMisc->get_offsetWidth(&lOffsetW);

                            if ((xInIMG < 0) || (xInIMG > lOffsetW))
                                continue;

                            lOffset = 0;

                            while (pEleMisc)
                            {
                                hr = pEleMisc->QueryInterface(IID_IHTMLElement2, (void **)&pEle2Misc);
                                if (FAILED(hr))
                                    goto Cleanup;

                                pEleMisc->get_offsetTop(&lOffsetTop);
                                pEle2Misc->get_scrollTop(&lScrollTop);

                                lOffset += lOffsetTop - lScrollTop;

                                pEleMisc->get_offsetParent(&pEleMiscPar);
                                ATOMICRELEASE(pEleMisc);
                                ATOMICRELEASE(pEle2Misc);
                                pEleMisc=pEleMiscPar;

                            }

                            ATOMICRELEASE(pEleMiscPar);

                            hr = pDisp->QueryInterface(IID_IHTMLElement, (void **)&pEleMisc);
                            if (FAILED(hr))
                                goto Cleanup;

                            yInIMG = ptMouse.y - lOffset;
                            pEleMisc->get_offsetHeight(&lOffsetH);

                            ATOMICRELEASE(pEleMisc);

                            if ((yInIMG < 0) || (yInIMG > lOffsetH))
                                continue;

                            // if we get to this point we found our IMG element so...
                            // ...do the QI...
                            pEleImg->QueryInterface(IID_IHTMLElement, (void **)&pEleOut);
                            
                            // ...and we're done.
                            break;

                        }
                        SysFreeString(bstrUseMap);
                        bstrUseMap = NULL;
                    }
                }
            }
        }
    }

Cleanup:

    ATOMICRELEASE(pCollect);
    ATOMICRELEASE(pSubCollect);
    ATOMICRELEASE(pEleMap);
    ATOMICRELEASE(pEleParent);
    ATOMICRELEASE(pDisp);
    ATOMICRELEASE(pEleImg);
    ATOMICRELEASE(pEleMisc);
    ATOMICRELEASE(pEle2Misc);
    ATOMICRELEASE(pEleMiscPar);
    SysFreeString(bstrUseMap);
    SysFreeString(bstrName);

    return (pEleOut);  
}

// sometimes coordinates are relative to a parent object, like in frames, etc.  so this gets their real position relative
// to the browser window...
HRESULT CMyPics::GetRealCoords(IHTMLElement2 *pEle2, HWND hwnd, LONG *plLeft, LONG *plTop, LONG *plRight, LONG *plBottom)
{
    LONG       lScreenLeft = 0, 
               lScreenTop  = 0;
    HRESULT    hr          = E_FAIL;
    IHTMLRect *pRect       = NULL;
  
    *plLeft = *plTop = *plRight = *plBottom = 0;

    if (!pEle2)
        return hr;

    if (SUCCEEDED(pEle2->getBoundingClientRect(&pRect)) && pRect)
    {
        LONG lLeft, lRight, lTop, lBottom;

        pRect->get_left(&lLeft);
        pRect->get_right(&lRight);
        pRect->get_top(&lTop);
        pRect->get_bottom(&lBottom);

        // if its an iframe and it scrolls past the top of the frame, we should correct a bit.
        if (lTop <= 0)
            lTop = 0;

        // dito for left side
        if (lLeft <= 0)
            lLeft = 0;
        
        POINT pointTL, pointBR;  // TL=Top,Left BR=Bottom,Right

        ASSERT(m_pWin3);
        m_pWin3->get_screenLeft(&lScreenLeft);
        m_pWin3->get_screenTop(&lScreenTop);

        // convert coords relative to the frame window to screen coords
        pointTL.x = lScreenLeft + lLeft;
        pointTL.y = lScreenTop  + lTop;
        pointBR.x = lScreenLeft + lRight;
        pointBR.y = lScreenTop  + lBottom;

        // now convert from screen coords to client coords and assign...
        if (ScreenToClient(hwnd, &pointTL) && ScreenToClient(hwnd, &pointBR)) 
        {
            *plLeft   = pointTL.x;
            *plRight  = pointBR.x;
            *plTop    = pointTL.y;
            *plBottom = pointBR.y;

            hr = S_OK;
        }

        pRect->Release();
    }
    return hr;
}

HRESULT CMyPics::ShowHover()
{
    HRESULT               hr = S_OK;
    IHTMLElement2        *pEle2        = NULL; // cause we need an ele2 to get screen coords
    IHTMLRect            *pRect        = NULL; // to get screen coords
    LONG                  lLeft;               // these are the screen coords
    LONG                  lRight;              // we get right and bottom to det size of image
    LONG                  lTop;
    LONG                  lBottom;
    DWORD                 dwOffset;

    DWORD dw;
    SIZE  sz;
    RECT  rc;   
    
    TraceMsg(TF_MYPICS, "+CMyPics::ShowHover, this=%p, m_hoverState=%d", this, m_hoverState);

    ASSERT(m_pEleCurr);
    ASSERT(m_Hwnd);

    // get an IHTMLElement2 from the IHTMLElement cached...
    hr = m_pEleCurr->QueryInterface(IID_IHTMLElement2, (void **)&pEle2);
    if (FAILED(hr))
        goto Cleanup;

    // get correct coords...
    hr = GetRealCoords(pEle2, m_Hwnd, &lLeft, &lTop, &lRight, &lBottom);
    if (FAILED(hr))
        goto Cleanup;

    // adjust for offset...
    dwOffset = MP_GetOffsetInfoFromRegistry();
    lLeft += dwOffset;
    lTop  += dwOffset;

    // need to do some sanity checks to make sure the hover bar appears in a visible location...
    RECT rcBrowserWnd;
    if (GetClientRect(m_Hwnd, &rcBrowserWnd)) 
    {
        // check to make sure it'll appear somewhere we'll see it...
        if (lLeft < rcBrowserWnd.left)
            lLeft = rcBrowserWnd.left + dwOffset;

        if (lTop < rcBrowserWnd.top)
            lTop = rcBrowserWnd.top + dwOffset;

        // check to make sure the entire hoverbar is over the image (so the user
        // doesn't mouseout trying to get to the buttons!)

        // If "galleryimg" was explicitly turned on, then bypass this code, which ensures that the entire
        // toolbar will fit within the image.

        if (!m_bGalleryImg)
        {
            if (lRight - lLeft < MP_MIN_CX + 10 - (LONG)dwOffset)
                goto Cleanup;

            if (lBottom - lTop < MP_MIN_CY + 10)
                goto Cleanup;

            // now check to make sure there is enough horiz and vert room for it to appear...
            // if there isn't enough room, we just don't display it...
            if ((rcBrowserWnd.right  - MP_SCROLLBAR_SIZE)     - lLeft < MP_MIN_CX)
                goto Cleanup;

            if ((rcBrowserWnd.bottom - (MP_SCROLLBAR_SIZE+2)) - lTop  < MP_MIN_CY)
                goto Cleanup;
        }
    }

    dw = (DWORD)SendMessage(m_hWndMyPicsToolBar, TB_GETBUTTONSIZE, 0, 0);
    sz.cx = LOWORD(dw); sz.cy = HIWORD(dw);
    rc.left = rc.top = 0; 

    SendMessage(m_hWndMyPicsToolBar, TB_GETIDEALSIZE, FALSE, (LPARAM)&sz);

    rc.right  = sz.cx; 
    rc.bottom = sz.cy;
    
    AdjustWindowRectEx(&rc, GetWindowLong(m_hWndHover, GWL_STYLE), FALSE, GetWindowLong(m_hWndHover, GWL_EXSTYLE));

    if (SetWindowPos(m_hWndHover, NULL, lLeft, lTop, rc.right-rc.left, rc.bottom-rc.top, SWP_NOZORDER | SWP_SHOWWINDOW))
    {
        m_hoverState = HOVERSTATE_SHOWING;
    }

Cleanup:
    ATOMICRELEASE(pRect);
    ATOMICRELEASE(pEle2);

    TraceMsg(TF_MYPICS, "-CMyPics::ShowHover, this=%p, m_hoverState=%d", this, m_hoverState);

    return hr;
}


HRESULT CMyPics::HandleScroll() 
{
    TraceMsg(TF_MYPICS, "+CMyPics::HandleScroll, this=%p, m_hoverState=%d", this, m_hoverState);

    HRESULT hr = S_OK;

    switch(m_hoverState)
    {
        // I don't think we need to do anything in these cases.
        //
        case HOVERSTATE_HIDING:
        case HOVERSTATE_LOCKED:
        case HOVERSTATE_WAITINGTOSHOW:
            break;

        case HOVERSTATE_SHOWING:
            {
                IHTMLElement2 *pEle2=NULL;
                IHTMLRect     *pRect=NULL;
                RECT           rect;

                ASSERT(m_pEleCurr);
                ASSERT(m_Hwnd);
                ASSERT(m_hWndHover);  // Ensure we do have a window

                HideHover();
                ShowHover();                

                // Redraw client area to get rid of window droppings scrolling causes.
                // Try to redraw just the part where its likely to need it.
                if (FAILED(m_pEleCurr->QueryInterface(IID_IHTMLElement2, (void **)&pEle2)))
                {
                    goto CleanUp;
                }
                
                if (FAILED(pEle2->getBoundingClientRect(&pRect)))
                {
                    goto CleanUp;
                }
                
                pRect->get_left(&rect.left);
                pRect->get_right(&rect.right);
                pRect->get_top(&rect.top);
                pRect->get_bottom(&rect.bottom);

                rect.top -= 2*MP_MIN_CY; 
                if (rect.top < 0)
                    rect.top = 0;

                rect.left -= 2*MP_MIN_CX;
                if (rect.left <0)
                    rect.left = 0;
                
                rect.bottom *= 2; rect.right *= 2;

                RedrawWindow(m_Hwnd, &rect, NULL, RDW_INVALIDATE | RDW_UPDATENOW);
CleanUp:
                SAFERELEASE(pRect);
                SAFERELEASE(pEle2);

            }
            break;
    }

    TraceMsg(TF_MYPICS, "-CMyPics::HandleScroll, this=%p, m_hoverState=%d", this, m_hoverState);

    return hr;
}

HRESULT CMyPics::HandleMouseover(IHTMLElement *pEle)
{
    HRESULT               hr = S_OK;
    IOleWindow           *pOleWindow;

    TraceMsg(TF_MYPICS, "+CMyPics::HandleMouseover");

    if (m_hoverState != HOVERSTATE_HIDING)
    {
        // Ensure we really have a hover window
        ASSERT(m_hWndHover);
        return (S_OK);
    }
    else
    {
        // No bar.  Release current element, if any.
        ATOMICRELEASE(m_pEleCurr);

        if (ShouldAppearOnThisElement(pEle))
        {
            m_pEleCurr = pEle;
            pEle->AddRef();

            // set m_Hwnd once...
            if (!m_Hwnd) 
            {
                // Get the Hwnd for the document...
                hr = m_pDoc2->QueryInterface(IID_IOleWindow,(void **)&pOleWindow);
                if (FAILED(hr))
                    return hr;

                pOleWindow->GetWindow(&m_Hwnd);
                pOleWindow->Release();
            }

            if (!m_hWndHover)
            {
                // We need a hover window now to conveniently set a timer.
                hr = CreateHover();  // review: do we need to pass member variables as params?
            }

            // We're all set up.  Set the state and start the timer.
            m_hoverState=HOVERSTATE_WAITINGTOSHOW;
            SetTimer(m_hWndMyPicsToolBar, IDT_MP_TIMER, MP_TIMER, s_TimerProc);
        }
    }

    TraceMsg(TF_MYPICS, "-CMyPics::HandleMouseover");

    return hr;
}


HRESULT CMyPics::HandleMouseout()
{
    TraceMsg(TF_MYPICS, "+CMyPics::HandleMouseout");

    switch(m_hoverState)
    {
    case HOVERSTATE_HIDING:
        // Nothing to do
        break;

    case HOVERSTATE_SHOWING:
        // Hide it
        HideHover();
        break;

    case HOVERSTATE_LOCKED:
        // Noop
        break;

    case HOVERSTATE_WAITINGTOSHOW:
        m_hoverState = HOVERSTATE_HIDING;
        KillTimer(m_hWndMyPicsToolBar, IDT_MP_TIMER);
        break;
    }

    TraceMsg(TF_MYPICS, "-CMyPics::HandleMouseout");

    return S_OK;
}

HRESULT CMyPics::HandleResize()
{
    HRESULT hr = S_OK;

    if (m_pEleCurr && (HOVERSTATE_SHOWING == m_hoverState))
    {
        HideHover();
        ShowHover();
    }

    return hr;
}

HRESULT CMyPics::HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj) 
{
    TraceMsg(TF_MYPICS, "CMyPics::HandleEvent Event=%ws", EventsToSink[Event].pwszEventName);

    HRESULT       hr          = S_OK;
    BSTR          bstrTagName = NULL;
    IHTMLElement *pEleUse     = NULL;
    BOOL          fWasArea    = FALSE;
    
    // if this is an area tag we need to find the IMG tag that corresponds
    if (pEle && SUCCEEDED(pEle->get_tagName(&bstrTagName)))
    {
        // if its an area tag, we need to find the img tag associated with it...
        if (StrCmpNI(bstrTagName, TEXT("area"), 4)==0)
        {
            POINT ptEvent;

            if (FAILED(pEventObj->get_screenX(&ptEvent.x)) ||
                FAILED(pEventObj->get_screenY(&ptEvent.y)))
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }

            fWasArea = TRUE;
            pEleUse  = GetIMGFromArea(pEle, ptEvent);
        }
    }

    // has the user turned this off?
    if (m_bIsOffForSession)
        goto Cleanup;

    switch(Event) 
    {
        case EVENT_SCROLL:
            HandleScroll();
            break;

        case EVENT_MOUSEOVER:
            hr = HandleMouseover(fWasArea ? pEleUse : pEle);
            break;

        case EVENT_MOUSEOUT:
            hr = HandleMouseout();
            break;

        case EVENT_RESIZE:
            hr = HandleResize();
            break;

        default:
            //do nothing?
            break;
    }

Cleanup:
    if (pEleUse)
        ATOMICRELEASE(pEleUse);

    if (bstrTagName)
        SysFreeString(bstrTagName);

    return (hr);
}

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////

// this is stolen from iforms.cpp:

//=========================================================================
//
// Event sinking class
//
//  We simply implement IDispatch and make a call into our parent when
//   we receive a sinked event.
//
//=========================================================================

CMyPics::CEventSink::CEventSink(CMyPicsEventSinkCallback *pParent)
{
    TraceMsg(TF_MYPICS, "CMyPics::CEventSink::CEventSink");
    DllAddRef();
    m_cRef = 1;
    m_pParent = pParent;
}

CMyPics::CEventSink::~CEventSink()
{
    TraceMsg(TF_MYPICS, "CMyPics::CEventSink::~CEventSink");
    ASSERT( m_cRef == 0 );
    DllRelease();
}

STDMETHODIMP CMyPics::CEventSink::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if ((IID_IDispatch == riid) ||
        (IID_IUnknown == riid))
    {
        *ppv = (IDispatch *)this;
    }

    if (NULL != *ppv)
    {
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CMyPics::CEventSink::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CMyPics::CEventSink::Release(void)
{
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CMyPics::CEventSink::SinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents)
{
    VARIANT_BOOL bSuccess = VARIANT_TRUE;

    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CMyPicsEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pEle2->attachEvent(bstrEvent, (IDispatch *)this, &bSuccess);

            SysFreeString(bstrEvent);
        }
        else
        {
            bSuccess = VARIANT_FALSE;
        }

        if (!bSuccess)
            break;
    }

    return (bSuccess) ? S_OK : E_FAIL;
}

HRESULT CMyPics::CEventSink::SinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents)
{
    VARIANT_BOOL bSuccess = VARIANT_TRUE;

    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CMyPicsEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pWin3->attachEvent(bstrEvent, (IDispatch *)this, &bSuccess);

            SysFreeString(bstrEvent);
        }
        else
        {
            bSuccess = VARIANT_FALSE;
        }

        if (!bSuccess)
            break;
    }

    return (bSuccess) ? S_OK : E_FAIL;
}


HRESULT CMyPics::CEventSink::UnSinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents)
{
    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CMyPicsEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pEle2->detachEvent(bstrEvent, (IDispatch *)this);

            SysFreeString(bstrEvent);
        }
    }

    return S_OK;
}

HRESULT CMyPics::CEventSink::UnSinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents)
{
    for (int i=0; i<iNum; i++)
    {
        BSTR bstrEvent = SysAllocString(CMyPicsEventSinkCallback::EventsToSink[(int)(pEvents[i])].pwszEventSubscribe);

        if (bstrEvent)
        {
            pWin3->detachEvent(bstrEvent, (IDispatch *)this);

            SysFreeString(bstrEvent);
        }
    }

    return S_OK;
}

// IDispatch
STDMETHODIMP CMyPics::CEventSink::GetTypeInfoCount(UINT* /*pctinfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMyPics::CEventSink::GetTypeInfo(/* [in] */ UINT /*iTInfo*/,
            /* [in] */ LCID /*lcid*/,
            /* [out] */ ITypeInfo** /*ppTInfo*/)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMyPics::CEventSink::GetIDsOfNames(
                REFIID          riid,
                OLECHAR**       rgszNames,
                UINT            cNames,
                LCID            lcid,
                DISPID*         rgDispId)
{
    return E_NOTIMPL;
}

STDMETHODIMP CMyPics::CEventSink::Invoke(
            DISPID dispIdMember,
            REFIID, LCID,
            WORD wFlags,
            DISPPARAMS* pDispParams,
            VARIANT* pVarResult,
            EXCEPINFO*,
            UINT* puArgErr)
{
    if (m_pParent && pDispParams && pDispParams->cArgs>=1)
    {
        if (pDispParams->rgvarg[0].vt == VT_DISPATCH)
        {
            IHTMLEventObj *pObj=NULL;

            if (SUCCEEDED(pDispParams->rgvarg[0].pdispVal->QueryInterface(IID_IHTMLEventObj, (void **)&pObj) && pObj))
            {
                EVENTS Event=EVENT_BOGUS;
                BSTR bstrEvent=NULL;

                pObj->get_type(&bstrEvent);

                if (bstrEvent)
                {
                    for (int i=0; i<ARRAYSIZE(CMyPicsEventSinkCallback::EventsToSink); i++)
                    {
                        if (!StrCmpCW(bstrEvent, CMyPicsEventSinkCallback::EventsToSink[i].pwszEventName))
                        {
                            Event = (EVENTS) i;
                            break;
                        }
                    }

                    SysFreeString(bstrEvent);
                }

                if (Event != EVENT_BOGUS)
                {
                    IHTMLElement *pEle=NULL;

                    pObj->get_srcElement(&pEle);

                    // EVENT_SCROLL comes from our window so we won't have an
                    //  element for it
                    if (pEle || (Event == EVENT_SCROLL))
                    {
                        // Call the event handler here
                        m_pParent->HandleEvent(pEle, Event, pObj);

                        if (pEle)
                        {
                            pEle->Release();
                        }
                    }
                }

                pObj->Release();
            }
        }
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////

// {9E56BE60-C50F-11CF-9A2C-00A0C90A90CE}
EXTERN_C const GUID MP_CLSID_MailRecipient = {0x9E56BE60L, 0xC50F, 0x11CF, 0x9A, 0x2C, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xCE};

HRESULT DropPicOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState)
{
    IDropTarget *pdrop;
    HRESULT hres = CoCreateInstance(MP_CLSID_MailRecipient,
        NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
        IID_PPV_ARG(IDropTarget, &pdrop));

    if (SUCCEEDED(hres))
    {
        hres = SHSimulateDrop(pdrop, pdtobj, grfKeyState, NULL, NULL);
        pdrop->Release();
    }
    return hres;
}


//
// This function cannot return Non -NULL pointers if
// it returns a FAILED(hr)
//

HRESULT CreateShortcutSetSiteAndGetDataObjectIfPIDLIsNetUrl(
    LPCITEMIDLIST pidl,
    IUnknown *pUnkSite,
    IUniformResourceLocator **ppUrlOut,
    IDataObject **ppdtobj
)
{
    HRESULT hr;
    TCHAR szUrl[MAX_URL_STRING];
    TCHAR *szTemp = NULL;

    ASSERT(ppUrlOut);
    ASSERT(ppdtobj);
    *ppUrlOut = NULL;
    *ppdtobj = NULL;
    szUrl[0] = TEXT('\0');

    hr = IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szUrl, SIZECHARS(szUrl), NULL);

    if ((S_OK == hr) && (*szUrl))
    {

       BOOL fIsHTML = FALSE;
       BOOL fHitsNet = UrlHitsNetW(szUrl);

       if (!fHitsNet)
       {
            if (URL_SCHEME_FILE == GetUrlScheme(szUrl))
            {
                TCHAR *szExt = PathFindExtension(szUrl);
                if (szExt)
                {
                    fIsHTML = ((0 == StrCmpNI(szExt, TEXT(".htm"),4)) ||
                              (0 == StrCmpNI(szExt, TEXT(".html"),5)));
                }
            }
       }

       if (fHitsNet || fIsHTML)
       {
            // Create a shortcut object and
            HRESULT hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                            IID_PPV_ARG(IUniformResourceLocator, ppUrlOut));
            if (SUCCEEDED(hr))
            {

                hr = (*ppUrlOut)->SetURL(szUrl, 0);
                if (S_OK == hr)
                {

                    // Get the IDataObject and send that back for the Drag Drop
                    hr = (*ppUrlOut)->QueryInterface(IID_PPV_ARG(IDataObject, ppdtobj));
                    if (SUCCEEDED(hr))
                    {
                        IUnknown_SetSite(*ppUrlOut, pUnkSite); // Only set the site if we're sure of
                                                          // returning SUCCESS
                    }
                }
           }
       }
       else
       {
            hr = E_FAIL;
       }
    }

    if (FAILED(hr))
    {
        SAFERELEASE(*ppUrlOut);
        SAFERELEASE(*ppdtobj);
    }
    return hr;
}

HRESULT SendDocToMailRecipient(LPCITEMIDLIST pidl, UINT uiCodePage, DWORD grfKeyState, IUnknown *pUnkSite)
{
    IDataObject *pdtobj = NULL;
    IUniformResourceLocator *purl = NULL;
    HRESULT hr = CreateShortcutSetSiteAndGetDataObjectIfPIDLIsNetUrl(pidl, pUnkSite, &purl, &pdtobj);
    if (FAILED(hr))
    {
        ASSERT(NULL == pdtobj);
        ASSERT(NULL == purl);
        hr = GetDataObjectForPidl(pidl, &pdtobj);
    }

    if (SUCCEEDED(hr))
    {
        IQueryCodePage * pQcp;
        if (SUCCEEDED(pdtobj->QueryInterface(IID_PPV_ARG(IQueryCodePage, &pQcp))))
        {
            pQcp->SetCodePage(uiCodePage);
            pQcp->Release();
        }
        hr = DropPicOnMailRecipient(pdtobj, grfKeyState);
        pdtobj->Release();
    }

    if (purl)
    {
        IUnknown_SetSite(purl, NULL);
        purl->Release();
    }
    return hr;
}


//////////////////////////////////////////////////////////////////////////////

#undef TF_MYPICS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\nscband.h ===
/**************************************************************\
    FILE: NSCBand.h

    DESCRIPTION:  the class CNscBand exists to support name 
        space control bands.  A name space control uses IShellFolder
        rooted in various namespaces including Favorites, history, 
        Shell Name Space, etc. to depict a hierarchical UI 
        representation of the given name space.  
    
    AUTHOR:  chrisny

\**************************************************************/
#include "bands.h"
#include "nsc.h"
#include "uemapp.h"

#ifndef _NSCBAND_H
#define _NSCBAND_H

// for degug trace messages.
#define DM_PERSIST      0           // trace IPS::Load, ::Save, etc.
#define DM_MENU         0           // menu code
#define DM_FOCUS        0           // focus
#define DM_FOCUS2       0           // like DM_FOCUS, but verbose

const short CSIDL_NIL = -32767;

////////////////
///  NSC band

class CNSCBand : public CToolBand
               , public IContextMenu
               , public IBandNavigate
               , public IWinEventHandler
               , public INamespaceProxy
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CToolBand::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void) { return CToolBand::Release(); };

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IPersistStream methods ***
    // (others use base class implementation) 
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg
                                    , WPARAM wParam, LPARAM lParam
                                    , LRESULT *plres);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IContextMenu methods ***
    STDMETHOD(QueryContextMenu)(HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags);

    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR    idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) { return E_NOTIMPL; };

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);

    // *** IBandNavigate methods ***
    virtual STDMETHODIMP Select(LPCITEMIDLIST pidl);
    

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** INamespaceProxy ***
    virtual STDMETHODIMP GetNavigateTarget(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib);
    virtual STDMETHODIMP Invoke(LPCITEMIDLIST pidl);
    virtual STDMETHODIMP OnSelectionChanged(LPCITEMIDLIST pidl);
    virtual STDMETHODIMP RefreshFlags(DWORD *pdwStyle, DWORD *pdwExStyle, DWORD *pdwEnum) 
        {*pdwStyle = _GetTVStyle(); *pdwExStyle = _GetTVExStyle(); *pdwEnum = _GetEnumFlags(); return S_OK; };
    virtual STDMETHODIMP CacheItem(LPCITEMIDLIST pidl) { return S_OK; };
    
protected:    
    void _SetNscMode(UINT nMode) { _pns->SetNscMode(nMode); };
    virtual DWORD _GetTVStyle();
    virtual DWORD _GetTVExStyle() { return 0; };
    virtual DWORD _GetEnumFlags() { return SHCONTF_FOLDERS | SHCONTF_NONFOLDERS; };
    
    HRESULT _Init(LPCITEMIDLIST pidl);
    virtual HRESULT _InitializeNsc();
    
    virtual ~CNSCBand();
    virtual HRESULT _OnRegisterBand(IOleCommandTarget *poctProxy) { return S_OK; } // meant to be overridden
    
    void _UnregisterBand();
    void _EnsureImageListsLoaded();

    virtual HRESULT _TranslatePidl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib);
    virtual BOOL _ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib);
    virtual HRESULT _NavigateRightPane(IShellBrowser *psb, LPCITEMIDLIST pidl);
    HRESULT _QueryContextMenuSelection(IContextMenu ** ppcm);
    HRESULT _InvokeCommandOnItem(LPCTSTR pszVerb);

    friend HRESULT CHistBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk
                                            , LPCOBJECTINFO poi);      

    LPITEMIDLIST        _pidl;
    WCHAR               _szTitle[40];
                        
    INSCTree2 *         _pns;               // name space control data.
    IWinEventHandler *  _pweh;              // name space control's OnWinEvent handler
    BITBOOL             _fInited :1;        // true if band has been inited.
    BITBOOL             _fVisible :1;       // true if band is showing
    DWORD              _dwStyle;         // Treeview style
    LPCOBJECTINFO       _poi;               // cached object info.
    HACCEL              _haccTree;

    HIMAGELIST          _himlNormal;        // shared image list
    HIMAGELIST          _himlHot;
};

#endif /* _NSCBAND_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\nsc.h ===
#ifndef _NSC_C
#define _NSC_C

#include "droptgt.h"
#include "iface.h"
#include "dpastuff.h"
#include "cwndproc.h"
#include "resource.h"
#include "inetnot.h"
#include "cowsite.h"
#include <shlobj.h>
#include <cfdefs.h> // LPCOBJECTINFO

#define ID_CONTROL  100  
#define ID_HEADER   101

typedef enum
{
    NSIF_HITEM              = 0x0001,
    NSIF_FOLDER             = 0x0002,
    NSIF_PARENTFOLDER       = 0x0004,
    NSIF_IDLIST             = 0x0008,
    NSIF_FULLIDLIST         = 0x0010,
    NSIF_ATTRIBUTES         = 0x0020
} NSI_FLAGS;

typedef enum
{
    NSSR_ENUMBELOWROOT  = 0x0001,
    NSSR_CREATEPIDL     = 0x0002
} NSSR_FLAGS;

typedef struct
{
    PORDERITEM  poi;
    DWORD       dwSig;          // Signature of the item, so we can find it back after async processing
    BITBOOL     fPinned:1;      // is this url pinned in the cache?
    BITBOOL     fGreyed:1;      // draw the item greyed (if offline & not in cache)
    BITBOOL     fFetched:1;     // have we fetched the pinned/greyed state?
    BITBOOL     fDontRefetch:1; // can't be cached by wininet
    BOOL        fNavigable:1;   // item can be navigated to
} ITEMINFO;

typedef struct
{
    const SHCOLUMNID  *pscid;
    int               iFldrCol;       // index for this column in GetDetailsOf
    TCHAR             szName[MAX_COLUMN_NAME_LEN];
    DWORD             fmt;
    int               cxChar;
} HEADERINFO;

// Forward decls
struct NSC_BKGDENUMDONEDATA;

// _FrameTrack flags
#define TRACKHOT        0x0001
#define TRACKEXPAND     0x0002
#define TRACKNOCHILD    0x0004

// _DrawItem flags
#define DIICON          0x0001
#define DIRTLREADING    0x0002
#define DIHOT           0x0004
#define DIFIRST         0x0020
#define DISUBITEM       0x0040
#define DILAST          0x0080
#define DISUBLAST       (DISUBITEM | DILAST)
#define DIACTIVEBORDER  0x0100
#define DISUBFIRST      (DISUBITEM | DIFIRST)
#define DIPINNED        0x0400                  // overlay pinned glyph
#define DIGREYED        0x0800                  // draw greyed
#define DIFOLDEROPEN    0x1000      
#define DIFOLDER        0x2000      //item is a folder
#define DIFOCUSRECT     0x4000
#define DIRIGHT         0x8000      //right aligned

#define NSC_TVIS_MARKED 0x1000

// async icon/url extract flags
#define NSCICON_GREYED      0x0001
#define NSCICON_PINNED      0x0002
#define NSCICON_DONTREFETCH 0x0004

#define WM_NSCUPDATEICONINFO       WM_USER + 0x700
#define WM_NSCBACKGROUNDENUMDONE   WM_USER + 0x701
#define WM_NSCUPDATEICONOVERLAY    WM_USER + 0x702

HRESULT GetNavTargetName(IShellFolder* pFolder, LPCITEMIDLIST pidl, LPTSTR pszUrl, UINT cMaxChars);
BOOL    MayBeUnavailableOffline(LPTSTR pszUrl);
INSCTree2 * CNscTree_CreateInstance(void);
STDAPI CNscTree_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
BOOL IsExpandableChannelFolder(IShellFolder *psf, LPCITEMIDLIST pidl);

// class wrapper for tree control component of nscband.
class ATL_NO_VTABLE CNscTree :    
                    public CComObjectRootEx<CComMultiThreadModelNoCS>,
                    public CComCoClass<CNscTree, &CLSID_ShellNameSpace>,
                    public CComControl<CNscTree>,
                    public IDispatchImpl<IShellNameSpace, &IID_IShellNameSpace, &LIBID_SHDocVw, 1, 0, CComTypeInfoHolder>,
                    public IProvideClassInfo2Impl<&CLSID_ShellNameSpace, &DIID_DShellNameSpaceEvents, &LIBID_SHDocVw, 1, 0, CComTypeInfoHolder>,
                    public IPersistStreamInitImpl<CNscTree>,
                    public IPersistPropertyBagImpl<CNscTree>,
                    public IQuickActivateImpl<CNscTree>,
                    public IOleControlImpl<CNscTree>,
                    public IOleObjectImpl<CNscTree>,
                    public IOleInPlaceActiveObjectImpl<CNscTree>,
                    public IViewObjectExImpl<CNscTree>,
                    public IOleInPlaceObjectWindowlessImpl<CNscTree>,
                    public ISpecifyPropertyPagesImpl<CNscTree>,
                    public IConnectionPointImpl<CNscTree, &DIID_DShellNameSpaceEvents, CComDynamicUnkArray>,
                    public IConnectionPointContainerImpl<CNscTree>,
                    public IShellChangeNotify, 
                    public CDelegateDropTarget, 
                    public CNotifySubclassWndProc, 
                    public CObjectWithSite,
                    public INSCTree2, 
                    public IWinEventHandler, 
                    public IShellBrowser,
                    public IFolderFilterSite
{
public:

DECLARE_WND_CLASS(TEXT("NamespaceOC Window"))
DECLARE_NO_REGISTRY();

BEGIN_COM_MAP(CNscTree)
    COM_INTERFACE_ENTRY(IShellNameSpace)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IShellChangeNotify)         // IID_IShellChangeNotify
    COM_INTERFACE_ENTRY(INSCTree)                   // IID_INSCTree
    COM_INTERFACE_ENTRY(INSCTree2)                  // IID_INSCTree2
    COM_INTERFACE_ENTRY(IShellFavoritesNameSpace)   // IID_IShellFavoritesNameSpace
    COM_INTERFACE_ENTRY(IShellNameSpace)            // IID_IShellNameSpace
    COM_INTERFACE_ENTRY(IWinEventHandler)           // IID_IWinEventHandler
    COM_INTERFACE_ENTRY(IDropTarget)                // IID_IDropTarget
    COM_INTERFACE_ENTRY(IObjectWithSite)            // IID_IObjectWithSite
    COM_INTERFACE_ENTRY(IShellBrowser)              // IID_IShellBrowser
    COM_INTERFACE_ENTRY(IFolderFilterSite)          // IID_IFolderFilterSite

END_COM_MAP()

BEGIN_PROPERTY_MAP(CNscTree)
    PROP_ENTRY("Root", DISPID_ROOT, CLSID_NULL)
    PROP_ENTRY("EnumOptions", DISPID_ENUMOPTIONS, CLSID_NULL)
    PROP_ENTRY("Flags", DISPID_FLAGS, CLSID_NULL)
    PROP_ENTRY("Depth", DISPID_DEPTH, CLSID_NULL)
    PROP_ENTRY("Mode", DISPID_MODE, CLSID_NULL)
    PROP_ENTRY("TVFlags", DISPID_TVFLAGS, CLSID_NULL)
    PROP_ENTRY("Columns", DISPID_NSCOLUMNS, CLSID_NULL)
END_PROPERTY_MAP()

BEGIN_MSG_MAP(CNscTree)
    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(CWM_GETISHELLBROWSER, OnGetIShellBrowser)
END_MSG_MAP()

BEGIN_CONNECTION_POINT_MAP(CNscTree)
    CONNECTION_POINT_ENTRY(DIID_DShellNameSpaceEvents)
END_CONNECTION_POINT_MAP()

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown *punkSite);

    // INSCTree
    STDMETHODIMP CreateTree(HWND hwndParent, DWORD dwStyles, HWND *phwnd);         // create window of tree view.
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlRoot, DWORD grfFlags, DWORD dwFlags);           // init the treeview control with data.
    STDMETHODIMP ShowWindow(BOOL fShow);
    STDMETHODIMP Refresh(void);
    STDMETHODIMP GetSelectedItem(LPITEMIDLIST * ppidl, int nItem);
    STDMETHODIMP SetSelectedItem(LPCITEMIDLIST pidl, BOOL fCreate, BOOL fReinsert, int nItem);
    STDMETHODIMP GetNscMode(UINT * pnMode) { *pnMode = _mode; return S_OK;};
    STDMETHODIMP SetNscMode(UINT nMode) { _mode = nMode; return S_OK;};
    STDMETHODIMP GetSelectedItemName(LPWSTR pszName, DWORD cchName);
    STDMETHODIMP BindToSelectedItemParent(REFIID riid, void **ppv, LPITEMIDLIST *ppidl);
    STDMETHODIMP_(BOOL) InLabelEdit(void) {return _fInLabelEdit;};
    // INSCTree2
    STDMETHODIMP RightPaneNavigationStarted(LPITEMIDLIST pidl);
    STDMETHODIMP RightPaneNavigationFinished(LPITEMIDLIST pidl);
    STDMETHODIMP CreateTree2(HWND hwndParent, DWORD dwStyle, DWORD dwExStyle, HWND *phwnd);         // create window of tree view.

    // IShellBrowser (Hack)
    STDMETHODIMP InsertMenusSB(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths) {return E_NOTIMPL;};
    STDMETHODIMP SetMenuSB(HMENU hmenuShared, HOLEMENU holemenu, HWND hwnd) {return E_NOTIMPL;};
    STDMETHODIMP RemoveMenusSB(HMENU hmenuShared) {return E_NOTIMPL;};
    STDMETHODIMP SetStatusTextSB(LPCOLESTR lpszStatusText) {return E_NOTIMPL;};
    STDMETHODIMP EnableModelessSB(BOOL fEnable) {return E_NOTIMPL;};
    STDMETHODIMP TranslateAcceleratorSB(LPMSG lpmsg, WORD wID) {return E_NOTIMPL;};
    STDMETHODIMP BrowseObject(LPCITEMIDLIST pidl, UINT wFlags) {return E_NOTIMPL;};
    STDMETHODIMP GetViewStateStream(DWORD grfMode, LPSTREAM  *ppStrm) {return E_NOTIMPL; };
    STDMETHODIMP GetControlWindow(UINT id, HWND * lphwnd) {return E_NOTIMPL;};
    STDMETHODIMP SendControlMsg(UINT id, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *pret) {return E_NOTIMPL;};
    STDMETHODIMP QueryActiveShellView(struct IShellView ** ppshv) {return E_NOTIMPL;};
    STDMETHODIMP OnViewWindowActive(struct IShellView * ppshv) {return E_NOTIMPL;};
    STDMETHODIMP SetToolbarItems(LPTBBUTTON lpButtons, UINT nButtons, UINT uFlags) {return E_NOTIMPL;};
    //STDMETHODIMP GetWindow(HWND * lphwnd) {return E_NOTIMPL;}; //already defined in IOleWindow
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) {return E_NOTIMPL;};

    // IWinEventHandler
    STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);
    STDMETHODIMP IsWindowOwner(HWND hwnd) {return E_NOTIMPL;};

    // IShellChangeNotify
    STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    // IShellNameSpace
    STDMETHODIMP get_SubscriptionsEnabled(VARIANT_BOOL *pVal);
    STDMETHODIMP Import() {return DoImportOrExport(TRUE);};
    STDMETHODIMP Export() {return DoImportOrExport(FALSE);};
    STDMETHODIMP Synchronize();
    STDMETHODIMP NewFolder();
    STDMETHODIMP ResetSort();
    STDMETHODIMP MoveSelectionDown() {MoveItemUpOrDown(FALSE); return S_OK;};
    STDMETHODIMP MoveSelectionUp() {MoveItemUpOrDown(TRUE); return S_OK;};
    STDMETHODIMP InvokeContextMenuCommand(BSTR strCommand);
    STDMETHODIMP MoveSelectionTo();
    STDMETHODIMP CreateSubscriptionForSelection(/*[out, retval]*/ VARIANT_BOOL *pBool);    
    STDMETHODIMP DeleteSubscriptionForSelection(/*[out, retval]*/ VARIANT_BOOL *pBool);    
    STDMETHODIMP get_EnumOptions(LONG *pVal);
    STDMETHODIMP put_EnumOptions(LONG lVal);
    STDMETHODIMP get_SelectedItem(IDispatch **ppItem);
    STDMETHODIMP put_SelectedItem(IDispatch *pItem);
    STDMETHODIMP get_Root(VARIANT *pvar);
    STDMETHODIMP put_Root(VARIANT pItem);
    STDMETHODIMP SetRoot(BSTR bstrRoot);
    STDMETHODIMP put_Depth(int iDepth){ return S_OK;};
    STDMETHODIMP get_Depth(int *piDepth){ *piDepth = 1; return S_OK;};
    STDMETHODIMP put_Mode(UINT uMode);
    STDMETHODIMP get_Mode(UINT *puMode) { *puMode = _mode; return S_OK;};
    STDMETHODIMP put_Flags(DWORD dwFlags);
    STDMETHODIMP get_Flags(DWORD *pdwFlags) { *pdwFlags = _dwFlags; return S_OK;};
    STDMETHODIMP put_TVFlags(DWORD dwFlags) { _dwTVFlags = dwFlags; return S_OK;};
    STDMETHODIMP get_TVFlags(DWORD *dwFlags) { *dwFlags = _dwTVFlags; return S_OK;};
    STDMETHODIMP put_Columns(BSTR bstrColumns);
    STDMETHODIMP get_Columns(BSTR *bstrColumns);
    STDMETHODIMP get_CountViewTypes(int *piTypes);
    STDMETHODIMP SetViewType(int iType);
    STDMETHODIMP SelectedItems(IDispatch **ppItems);
    STDMETHODIMP Expand(VARIANT var, int iDepth);
    //STDMETHODIMP get_ReadyState(READYSTATE *plReady);
    STDMETHODIMP UnselectAll();

    // IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

    // IOleInPlaceObject
    STDMETHODIMP SetObjectRects(LPCRECT prcPos, LPCRECT prcClip);

    // IOleInPlaceActiveObjectImpl
    STDMETHODIMP TranslateAccelerator(MSG *pMsg);

    // IOleWindow
    STDMETHODIMP GetWindow(HWND *phwnd);

    // IOleObject
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

    // CDelegateDropTarget
    virtual HRESULT GetWindowsDDT(HWND * phwndLock, HWND * phwndScroll);
    virtual HRESULT HitTestDDT(UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD * pdwDropEffect);
    virtual HRESULT GetObjectDDT(DWORD_PTR dwId, REFIID riid, void ** ppvObj);
    virtual HRESULT OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);

    // IFolderFilterSite
    STDMETHODIMP SetFilter(IUnknown* punk);

    CNscTree();

    // override ATL default handlers
    HRESULT OnDraw(ATL_DRAWINFO& di);
    LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
    LRESULT OnKillFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
    LRESULT OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
    LRESULT OnGetIShellBrowser(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled);
    HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL);
    HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR pszWindowName = NULL, 
                DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
                DWORD dwExStyle = 0, UINT nID = 0);
    HRESULT GetEventInfo(IShellFolder *psf, LPCITEMIDLIST pidl,
                         UINT *pcItems, LPWSTR pszUrl, DWORD cchUrl, 
                         UINT *pcVisits, LPWSTR pszLastVisited, BOOL *pfAvailableOffline);


protected:
    ~CNscTree();

    class CSelectionContextMenu : public IContextMenu2
    {
        friend CNscTree;
    protected:
        // IUnknown
        STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);
        STDMETHODIMP_(ULONG) AddRef(void) ;
        STDMETHODIMP_(ULONG) Release(void);

        // IContextMenu
        STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
        STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
        STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType,
                                UINT * pwRes, LPSTR pszName, UINT cchMax) { return E_NOTIMPL; };
        // IContextMenu2
        STDMETHODIMP HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam);


    protected:
        ~CSelectionContextMenu();

        IContextMenu *_pcmSelection;
        IContextMenu2 *_pcm2Selection;
        ULONG         _ulRefs;
    public:
        CSelectionContextMenu() : _pcmSelection(NULL),_ulRefs(0) {}
    };

    friend class CSelectionContextMenu;
    CSelectionContextMenu _scm;

private:
    void _FireFavoritesSelectionChange(long cItems, long hItem, BSTR strName,
        BSTR strUrl, long cVisits, BSTR strDate, long fAvailableOffline);
    HRESULT _InvokeContextMenuCommand(BSTR strCommand);
    void _InsertMarkedChildren(HTREEITEM htiParent, LPCITEMIDLIST pidlParent, IInsertItem *pii);
    HRESULT _GetEnumFlags(IShellFolder *psf, LPCITEMIDLIST pidlFolder, DWORD *pgrfFlags, HWND *phwnd);
    HRESULT _GetEnum(IShellFolder *psf, LPCITEMIDLIST pidlFolder, IEnumIDList **ppenum);
    BOOL _ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem);
    HWND _CreateTreeview();
    HWND _CreateHeader();
    void _SubClass(LPCITEMIDLIST pidlRoot);
    void _UnSubClass(void);
    int _GetChildren(IShellFolder *psf, LPCITEMIDLIST pidl, ULONG ulAttrs);
    HRESULT _LoadSF(HTREEITEM htiRoot, LPCITEMIDLIST pidl, BOOL * pfOrdered);
    HRESULT _StartBackgroundEnum(HTREEITEM htiRoot, LPCITEMIDLIST pidl,
        BOOL * pfOrdered, BOOL fUpdatePidls);
    void _GetDefaultIconIndex(LPCITEMIDLIST pidl, ULONG ulAttrs, TVITEM *pitem, BOOL fFolder);
    BOOL _LabelEditIsNewValueValid(TV_DISPINFO *ptvdi);
    LRESULT _OnEndLabelEdit(TV_DISPINFO *ptvdi);
    LRESULT _OnBeginLabelEdit(TV_DISPINFO *ptvdi);
    LPITEMIDLIST _CacheParentShellFolder(HTREEITEM hti, LPITEMIDLIST pidl);
    BOOL _CacheShellFolder(HTREEITEM hti);
    void _CacheDetails();
    void _ReleaseRootFolder(void );
    void _ReleasePidls(void);
    void _ReleaseCachedShellFolder(void);
    void _TvOnHide();
    void _TvOnShow();
    void _ReorderChildren(HTREEITEM htiParent);
    void _Sort(HTREEITEM hti, IShellFolder *psf);
    void MoveItemUpOrDown(BOOL fUp);
    LPITEMIDLIST _FindHighestDeadItem(LPCITEMIDLIST pidl);
    void _RemoveDeadBranch(LPCITEMIDLIST pidl);
    HRESULT CreateNewFolder(HTREEITEM hti);
    BOOL MoveItemsIntoFolder(HWND hwndParent);
    HRESULT DoImportOrExport(BOOL fImport);
    HRESULT DoSubscriptionForSelection(BOOL fCreate);
    LRESULT _OnNotify(LPNMHDR pnm);
    HRESULT _OnPaletteChanged(WPARAM wPAram, LPARAM lParam);
    HRESULT _OnWindowCleanup(void);
    HRESULT _HandleWinIniChange(void);
    HRESULT _EnterNewFolderEditMode(LPCITEMIDLIST pidlNewFolder);
    HTREEITEM _AddItemToTree(HTREEITEM htiParent, LPITEMIDLIST pidl, int cChildren, int iPos, 
        HTREEITEM htiAfter = TVI_LAST, BOOL fCheckForDups = TRUE, BOOL fMarked = FALSE);
    HTREEITEM _FindChild(IShellFolder *psf, HTREEITEM htiParent, LPCITEMIDLIST pidlChild);
    LPITEMIDLIST _GetFullIDList(HTREEITEM hti);
    ITEMINFO *_GetTreeItemInfo(HTREEITEM hti);
    PORDERITEM _GetTreeOrderItem(HTREEITEM hti);
    BOOL _SetRoot(LPCITEMIDLIST pidlRoot, int iExpandDepth, LPCITEMIDLIST pidlExpandTo, NSSR_FLAGS flags);
    DWORD _SetStyle(DWORD dwStyle);
    DWORD _SetExStyle(DWORD dwExStyle);
    void _OnGetInfoTip(NMTVGETINFOTIP *pnm);
    LRESULT _OnSetCursor(NMMOUSE* pnm);
    void _ApplyCmd(HTREEITEM hti, IContextMenu *pcm, UINT cmdId);
    HRESULT _QuerySelection(IContextMenu **ppcm, HTREEITEM *phti);
    HMENU   _CreateContextMenu(IContextMenu *pcm, HTREEITEM hti);
    LRESULT _OnContextMenu(short x, short y);
    void _OnBeginDrag(NM_TREEVIEW *pnmhdr);
    void _OnChangeNotify(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);
    HRESULT _OnDeleteItem(NM_TREEVIEW *pnm);
    void _OnGetDisplayInfo(TV_DISPINFO *pnm);
    HRESULT _ChangePidlRoot(LPCITEMIDLIST pidl);
    BOOL _IsExpandable(HTREEITEM hti);
    BOOL _OnItemExpandingMsg(NM_TREEVIEW *pnm);
    BOOL _OnItemExpanding(HTREEITEM htiToActivate, UINT action, BOOL fExpandedOnce, BOOL fIsExpandPartial);
    BOOL _OnSelChange(BOOL fMark);
    void _OnSetSelection();
    BOOL _FIsItem(IShellFolder * psf, LPCITEMIDLIST pidlTarget, HTREEITEM hti);
    HTREEITEM _FindFromRoot(HTREEITEM htiRoot, LPCITEMIDLIST pidl);
    HRESULT _OnSHNotifyRename(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlNew);
    HRESULT _OnSHNotifyDelete(LPCITEMIDLIST pidl, int *piPosDeleted, HTREEITEM *phtiParent);
    void _OnSHNotifyUpdateItem(LPCITEMIDLIST pidl, LPITEMIDLIST pidlReal);
    HRESULT _OnSHNotifyUpdateDir(LPCITEMIDLIST pidl);
    HRESULT _OnSHNotifyCreate(LPCITEMIDLIST pidl, int iPosition, HTREEITEM htiParent);
    void _OnSHNotifyOnlineChange(HTREEITEM htiRoot, BOOL fGoingOnline);
    void _OnSHNotifyCacheChange(HTREEITEM htiRoot, DWORD_PTR dwChanged);

    HRESULT _IdlRealFromIdlSimple(IShellFolder * psf, LPCITEMIDLIST pidlSimple, LPITEMIDLIST * ppidlReal);
    void _DtRevoke();
    void _DtRegister();
    int _TreeItemIndexInHDPA(HDPA hdpa, IShellFolder *psfParent, HTREEITEM hti, int iReverseStart);
    BOOL _IsItemExpanded(HTREEITEM hti);
    HRESULT _UpdateDir(HTREEITEM hti, BOOL bUpdatePidls);

    HRESULT _GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSHELLDETAILS pdetails);
    HRESULT _ParentFromItem(LPCITEMIDLIST pidl, IShellFolder** ppsfParent, LPCITEMIDLIST *ppidlChild);
    HRESULT _CompareIDs(IShellFolder *psf, LPITEMIDLIST pidl1, LPITEMIDLIST pidl2);
    static int CALLBACK _TreeCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
    static LRESULT CALLBACK s_SubClassTreeWndProc(
                                  HWND hwnd, UINT uMsg, 
                                  WPARAM wParam, LPARAM lParam,
                                  UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
    LRESULT _SubClassTreeWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _InitHeaderInfo();
    HRESULT    _Expand(LPCITEMIDLIST pidl, int iDepth);
    HTREEITEM  _ExpandToItem(LPCITEMIDLIST pidl, BOOL fCreate = TRUE, BOOL fReinsert = FALSE);
    HRESULT    _ExpandNode(HTREEITEM htiParent, int iCode, int iDepth);

    HRESULT _PutRootVariant(VARIANT *pvar);
    BOOL _IsItemNameInTree(LPCITEMIDLIST pidl);
    COLORREF _GetRegColor(COLORREF clrDefault, LPCTSTR pszName);
    void _AssignPidl(PORDERITEM poi, LPITEMIDLIST pidlNew);

protected:
    // used for background thread icon + draw info extraction
    static void s_NscIconCallback(CNscTree *pns, UINT_PTR uId, int iIcon, int iOpenIcon, DWORD dwFlags, UINT uMagic);
    static void s_NscOverlayCallback(CNscTree *pns, UINT_PTR uId, int iOverlayIndex, UINT uMagic);

    // used for background enumeration
    static void s_NscEnumCallback(CNscTree *pns, LPITEMIDLIST pidl, UINT_PTR uId, DWORD dwSig, HDPA hdpa, 
                                    LPITEMIDLIST pidlExpandingTo, DWORD dwOrderSig, 
                                    UINT uDepth, BOOL fUpdate, BOOL fUpdatePidls);

private:
    void _EnumBackgroundDone(NSC_BKGDENUMDONEDATA *pbedd);

#ifdef DEBUG
    void TraceHTREE(HTREEITEM hti, LPCTSTR pszDebugMsg);
    void TracePIDL(LPCITEMIDLIST pidl, LPCTSTR pszDebugMsg);
    void TracePIDLAbs(LPCITEMIDLIST pidl, LPCTSTR pszDebugMsg);
#endif

    static int CALLBACK _TreeOrder(LPARAM lParam1, LPARAM lParam2
                                            , LPARAM lParamSort);
    BOOL _IsOrdered(HTREEITEM htiRoot);
    void _SelectPidl(LPCITEMIDLIST pidl, BOOL fCreate, BOOL fReinsert = FALSE);
    void _SelectNoExpand(HWND hwnd, HTREEITEM hti);
    HRESULT _InsertChild(HTREEITEM htiParent, IShellFolder *psfParent, LPCITEMIDLIST pidlChild, BOOL fExpand, BOOL fSimpleToRealIDL, int iPosition, HTREEITEM *phti);
    LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);

    IStream *GetOrderStream(LPCITEMIDLIST pidl, DWORD grfMode);
    HRESULT _PopulateOrderList(HTREEITEM htiRoot);
    void _FreeOrderList(HTREEITEM htiRoot);

    void _Dropped(void);

    LRESULT _OnCDNotify(LPNMCUSTOMDRAW pnm);
    BOOL _IsTopParentItem(HTREEITEM hti);
    BOOL _MoveNode(int _iDragSrc, int iNewPos, LPITEMIDLIST pidl);
    void _TreeInvalidateItemInfo(HTREEITEM hItem, UINT mask);
    void _InvalidateImageIndex(HTREEITEM hItem, int iImage);

    void _DrawItem(HTREEITEM hti, TCHAR * psz, HDC hdc, LPRECT prc, 
        DWORD dwFlags, int iLevel, COLORREF clrbk, COLORREF clrtxt);
    void _DrawIcon(HTREEITEM hti,HDC hdc, int iLevel, RECT *prc, DWORD dwFlags);

    void _UpdateActiveBorder(HTREEITEM htiSelected);
    void _MarkChildren(HTREEITEM htiParent, BOOL fOn);
    BOOL _IsMarked(HTREEITEM hti);

    void _UpdateItemDisplayInfo(HTREEITEM hti);
    void _TreeSetItemState(HTREEITEM hti, UINT stateMask, UINT state);
    void _TreeNukeCutState();
    BOOL _IsChannelFolder(HTREEITEM hti);

    BOOL _LoadOrder(HTREEITEM hti, LPCITEMIDLIST pidl, IShellFolder* psf, HDPA* phdpa);

    HWND                _hwndParent;            // parent window to notify
    HWND                _hwndTree;              // tree or combo box
    HWND                _hwndNextViewer;
    HWND                _hwndHdr;
    DWORD               _style;
    DWORD               _dwExStyle;
    DWORD              _grfFlags;              // Flags to filter what goes in the tree.
    DWORD              _dwFlags;               // Behavior Flags (NSS_*)
    DWORD              _dwTVFlags;
    BITBOOL             _fInitialized : 1;      // Has INSCTree::Initialize() been called at least once yet?
    BITBOOL             _fIsSelectionCached: 1; // If the WM_NCDESTROY has been processed, then we squired the selected pidl(s) in _pidlSelected
    BITBOOL             _fCacheIsDesktop : 1;   // state flags
    BITBOOL             _fAutoExpanding : 1;    // tree is auto-expanding
    BITBOOL             _fDTRegistered:1;       // have we registered as droptarget?
    BITBOOL             _fpsfCacheIsTopLevel : 1;   // is the cached psf a root channel ?
    BITBOOL             _fDragging : 1;         // one o items being dragged
    BITBOOL             _fStartingDrag : 1;     // starting to drag an item
    BITBOOL             _fDropping : 1;         // a drop occurred in the nsc
    BITBOOL             _fInSelectPidl : 1;     // we are performing a SelectPidl
    BITBOOL             _fInserting : 1;        // we're on the insertion edge.
    BITBOOL             _fInsertBefore : 1;     // a drop occurred in the nsc
    BITBOOL             _fClosing : 1;          // are we closing ?
    BITBOOL             _fOkToRename : 1;           // are we right clicking.
    BITBOOL             _fInLabelEdit:1;
    BITBOOL             _fCollapsing:1;         // is a node collapsing.
    BITBOOL             _fOnline:1;             // is inet online?
    BITBOOL             _fWeChangedOrder:1;     // did we change the order?
    BITBOOL             _fHandlingShellNotification:1; //are we handing a shell notification?
    BITBOOL             _fSingleExpand:1;       // are we in single expand mode
    BITBOOL             _fHasFocus:1;           // does nsc have the focus?
    BITBOOL             _fIgnoreNextSelChange:1;// hack to get around treeview keydown bug
    BITBOOL             _fIgnoreNextItemExpanding:1; //hack to get around annoying single expand behavior
    BITBOOL             _fInExpand:1;           // TRUE while we are doing delayed expansion (called back from the secondary thread)
    BITBOOL             _fSubClassed:1;         // Have we subclassed the window yet?
    BITBOOL             _fAsyncDrop:1;          // async drop from outside or another inside folder.
    BITBOOL             _fOrdered:1;              // is root folder ordered.
    BITBOOL             _fExpandNavigateTo:1;     //  Do we need to expand when the right pane navigation comes back?
    BITBOOL             _fNavigationFinished:1;   // TRUE when the right hand pane has finished its navigation
    BITBOOL             _fSelectFromMouseClick:1; //  Did we use the mouse to select the item? (as opposed to the keyboard)
    BITBOOL             _fShouldShowAppStartCursor:1; // TRUE to show the appstart cursor while there is a background task going
    BOOL                _fUpdate; // true if we are enumerating so that we can update the tree (refresh)
    int                 _cxOldWidth;
    UINT                _mode;
    UINT                _csidl;
    IContextMenu*       _pcm;                  // context menu currently being displayed
    IContextMenu2*      _pcmSendTo;            // deal with send to hack so messages tgo right place.
    LPITEMIDLIST        _pidlRoot;
    LPITEMIDLIST        _pidlSelected;          // Valid if _fIsSelectionCached is true.  Used for INSCTree::GetSelectedItem() after tree is gone.
    HTREEITEM           _htiCache;              // tree item associated with Current shell folder
    IShellFolder*       _psfCache;             // cache of the last IShellFolder I needed...
    IShellFolder2*      _psf2Cache;             // IShellDetails2 for _psfISD2Cache
    IFolderFilter*      _pFilter;    
    INamespaceProxy*    _pnscProxy;
    ULONG               _ulDisplayCol;          // Default display col for _psfCache
    ULONG               _ulSortCol;             // Default sort col for _psfCache
    ULONG               _nChangeNotifyID;       // SHChangeNotify registration ID
    HDPA                _hdpaOrd;               // dpa order for current shell folder.
// drop target privates
    HTREEITEM           _htiCur;                // current tree item (dragging over)
    DWORD               _dwLastTime;
    DWORD               _dwEffectCur;           // current drag effect
    int                 _iDragSrc;              // dragging from this pos.
    int                 _iDragDest;             // destination drag point
    HTREEITEM           _htiDropInsert;         // parent of inserted item.
    HTREEITEM           _htiDragging;           // the tree item being dragged during D&D.
    HTREEITEM           _htiCut;                // Used for Clipboard and Visuals    
    LPITEMIDLIST        _pidlDrag;              // pidl of item being dragged from within.
    HTREEITEM           _htiFolderStart;        // what folder do we start in.
    HICON               _hicoPinned;            // drawn over items that are sticky in the inet cache
    HWND                _hwndDD;                // window to draw custom drag cursors on.
    HTREEITEM           _htiActiveBorder;       // the folder to draw the active border around
    CWinInetNotify      _inetNotify;            // hooks up wininet notifications (online/offline, etc)
    IShellTaskScheduler* _pTaskScheduler;       // background task icon/info extracter
    int                 _iDefaultFavoriteIcon;  // index of default favorite icon in system image list
    int                 _iDefaultFolderIcon;    // index of default folder icon in system image list
    HTREEITEM           _htiRenaming;           // hti of item being renamed in rename mode
    LPITEMIDLIST        _pidlNewFolderParent;   // where the new folder will be arriving (when user picks "Create New Folder")

    DWORD               _dwSignature;           // Signature used to track items in the tree, even after they've moved
    DWORD               _dwOrderSig;            // Signature that lets us detect changes in ordering of items
    BYTE                _bSynchId;              // magic number for validating tree during background icon extraction
    HDPA                _hdpaColumns;           // visible columns when NSS_HEADER is set
    HDPA                _hdpaViews; // ishellfolderviewtype view pidls

    LPITEMIDLIST        _pidlExpandingTo;       // During expansion of the tree, this is the pidl of the item we want to reach.
    LPITEMIDLIST        _pidlNavigatingTo;      // This is the pidl to which the right pane is currently navigating to
    UINT                _uDepth;                // depth of recursive expansion
    CRITICAL_SECTION    _csBackgroundData;      // protects the data from the background tasks.
    NSC_BKGDENUMDONEDATA * _pbeddList;          // List of tasks that are done.

    BITBOOL             _fShowCompColor:1;      // Show compressed files in different color

    enum 
    {
        RSVIDM_CONTEXT_START    = RSVIDM_LAST + 1,        // our private menu items end here
    };

};

int DPADeleteItemCB(void *pItem, void *pData);
int DPADeletePidlsCB(void *pItem, void *pData);
// util macros.

#define GetPoi(p)   (((ITEMINFO *)p)->poi)
#define GetPii(p)   ((ITEMINFO *)p)

#include "nscband.h"

#endif  // _NSC_C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\mypics.h ===
#ifndef __IEMYPICS_H_
#define __IEMYPICS_H_

// other constants: 
#define MP_BMP_CX                       16      // bitmap size
#define MP_BMP_CY                       16
#define MP_NUM_TBBUTTONS                4       // number buttons
#define MP_NUM_TBBITMAPS                4       
#define MP_MIN_CX                       114     // minimum x size of toolbar
#define MP_MIN_CY                       28      // minimum y size of toolbar
#define MP_MIN_SIZE                     200     // minimum square size in pixels for hoverbar to appear
#define MP_HOVER_OFFSET                 10      // offset +x +y from (x,y) of image's upper lefthand corner
#define MP_TIMER                        700     // time in milliseconds to delay on the mouseover/out events
#define MP_SCROLLBAR_SIZE               GetSystemMetrics(SM_CXVSCROLL)      // size of the scrollbars in pixels

// e-mail picture stuff called via ITridentService2
HRESULT DropOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState);
HRESULT CreateShortcutSetSiteAndGetDataObjectIfPIDLIsNetUrl(LPCITEMIDLIST pidl, IUnknown *pUnkSite, IUniformResourceLocator **ppUrlOut, IDataObject **ppdtobj);
HRESULT SendDocToMailRecipient(LPCITEMIDLIST pidl, UINT uiCodePage, DWORD grfKeyState, IUnknown *pUnkSite);

// need this to get scroll event, it lives in iforms.cpp...
void Win3FromDoc2(IHTMLDocument2 *pDoc2, IHTMLWindow3 **ppWin3);

// well, yeah.
BOOL    MP_IsEnabledInRegistry();
BOOL    MP_IsEnabledInIEAK();
DWORD   MP_GetFilterInfoFromRegistry();

// EventSink Callback Class (glorified array)...
class CMyPicsEventSinkCallback
{
public:
    typedef enum
    {
        EVENT_BOGUS     = 100,
        EVENT_MOUSEOVER = 0,
        EVENT_MOUSEOUT,
        EVENT_SCROLL,
        EVENT_RESIZE
    }
    EVENTS;

    typedef struct
    {
        EVENTS  Event;
        LPCWSTR pwszEventSubscribe;
        LPCWSTR pwszEventName;
    }
    EventSinkEntry;

    virtual HRESULT HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj) = 0;

    static  EventSinkEntry EventsToSink[];
};

class CMyPics : public CMyPicsEventSinkCallback
{
    long   m_cRef;

public:
    class CEventSink;
    
    CMyPics();
   ~CMyPics();

    // Ref-counted object, though not COM
    ULONG AddRef();
    ULONG Release();

    // CMyPicsEventSinkCallback...
    HRESULT HandleEvent(IHTMLElement *pEle, EVENTS Event, IHTMLEventObj *pEventObj);

    HRESULT Init(IHTMLDocument2 *pDoc2);

    HRESULT UnInit();

    static  HRESULT GetName(IHTMLInputTextElement *pTextEle, BSTR *pbstrName);

    static  BOOL    IsAdminRestricted(LPCTSTR pszRegVal);

    typedef HRESULT (*PFN_ENUM_CALLBACK)(IDispatch *pDispEle, DWORD_PTR dwCBData);

    BOOL    IsOff();

    static  VOID CALLBACK s_TimerProc(HWND hwnd, UINT uMsg, UINT_PTR idEvent, DWORD dwTime);

    void    IsGalleryMeta(BOOL bFlag);

protected:

    // Methods for managing the Hover bar
    HRESULT CreateHover();
    HRESULT DestroyHover();
    HRESULT HideHover();
    HRESULT ShowHover();

    // Event handlers
    HRESULT HandleScroll();
    HRESULT HandleMouseout();
    HRESULT HandleMouseover(IHTMLElement *pEle);
    HRESULT HandleResize();
        
    static  LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    LRESULT CALLBACK DisableWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);    

    BOOL ShouldAppearOnThisElement(IHTMLElement *pEle);

    HRESULT GetRealCoords(IHTMLElement2 *pEle2, HWND hwnd, LONG *plLeft, LONG *plTop, LONG *plRight, LONG *plBottom);

    IHTMLElement *GetIMGFromArea(IHTMLElement *pEleIn, POINT ptEvent);

private:
    // CMyPics member variables
    CEventSink     *m_pSink;
        
    // Floating Toolbar stuff...
    HWND            m_Hwnd,                  // Hwnd for the m_pdoc2
                    m_hWndHover,             // Hover rebar thing
                    m_hWndMyPicsToolBar;     // Toolbar that lives in the hover thing
                    
    UINT            m_hoverState;            // Current state of the HoverBar thing 
                                             
    UINT_PTR        m_uidTimer;              // The Timer
    HIMAGELIST      m_himlHover;             // For the image list
    HIMAGELIST      m_himlHoverHot;          // for the hot images
    
    // Useful stuff for the attached document
    IHTMLDocument2         *m_pDoc2;
    IHTMLElement           *m_pEleCurr;              // current element we are hovering over
    IHTMLWindow3           *m_pWin3;                 // for unsinking scroll event
    EVENTS                  m_eventsCurr;            // event currently being processed
    BOOL                    m_bIsOffForSession : 1;  // have we disabled feature for this session?
    BOOL                    m_bGalleryMeta : 1;      // TRUE if there was a META tag disabling image bar for this doc
    BOOL                    m_bGalleryImg : 1;       // TRUE if the current element has a galleryimg value set to TRUE

public:

    // Sinks regular Trident events. Calls back via CMyPicsEventSinkCallback...
    class CEventSink : public IDispatch
    {
        ULONG   m_cRef;

    public:

        CEventSink(CMyPicsEventSinkCallback *pParent);
       ~CEventSink();

        HRESULT SinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents);
        HRESULT UnSinkEvents(IHTMLElement2 *pEle2, int iNum, EVENTS *pEvents);
        HRESULT SinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents);
        HRESULT UnSinkEvents(IHTMLWindow3 *pWin3, int iNum, EVENTS *pEvents);

        void SetParent(CMyPicsEventSinkCallback *pParent) { m_pParent = pParent; }

        STDMETHODIMP QueryInterface(REFIID, void **);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IDispatch
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
        STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo);
        STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
            LCID lcid, DISPID *rgDispId);
        STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pVarResult,
            EXCEPINFO *pExcepInfo, UINT *puArgErr);

    private:
        CMyPicsEventSinkCallback *m_pParent;
    };

};

#endif //__IEMYPICS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\nsctask.cpp ===
#include "priv.h"
#include "nsc.h"
#include "nsctask.h"

#define PRIORITY_ENUM       ITSAT_DEFAULT_PRIORITY
#define PRIORITY_ICON       PRIORITY_ENUM + 1      //needs to be slightly higher priority
#define PRIORITY_OVERLAY    ITSAT_DEFAULT_PRIORITY

/////////////////////////////////////////////////////////////////////////
// COPY AND PASTE ALERT

// this code is mostly copied and pasted from browseui/icotask.cpp
// see lamadio and/or davemi for why these aren't combined or shared
/////////////////////////////////////////////////////////////////////////

// {7DB7F689-BBDB-483f-A8A9-C6E963E8D274}
EXTERN_C const GUID TASKID_BackgroundEnum = { 0x7db7f689, 0xbbdb, 0x483f, { 0xa8, 0xa9, 0xc6, 0xe9, 0x63, 0xe8, 0xd2, 0x74 } };

// {EB30900C-1AC4-11d2-8383-00C04FD918D0}
EXTERN_C const GUID TASKID_IconExtraction = { 0xeb30900c, 0x1ac4, 0x11d2, { 0x83, 0x83, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0 } };

// {EB30900D-1AC4-11d2-8383-00C04FD918D0}
EXTERN_C const GUID TASKID_OverlayExtraction = { 0xeb30900d, 0x1ac4, 0x11d2, { 0x83, 0x83, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0 } };

class CNscIconTask : public CRunnableTask
{
public:
    CNscIconTask(LPITEMIDLIST pidl, PFNNSCICONTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId);

    // IRunnableTask
    STDMETHODIMP RunInitRT(void);
    
protected:
    virtual ~CNscIconTask();

    virtual void _Extract(IShellFolder *psf, LPCITEMIDLIST pidlItem);

    BOOL                   _bOverlayTask;
    LPITEMIDLIST           _pidl;
    PFNNSCICONTASKBALLBACK _pfnIcon;
    CNscTree              *_pns;
    UINT_PTR               _uId;
    UINT                   _uSynchId;
};

CNscIconTask::CNscIconTask(LPITEMIDLIST pidl, PFNNSCICONTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId):
    _pidl(pidl), _pfnIcon(pfn), _uId(uId), _uSynchId(uSynchId), CRunnableTask(RTF_DEFAULT)
{
    _pns = pns;
    if (_pns)
        _pns->AddRef();
}

CNscIconTask::~CNscIconTask()
{
    if (_pns)
        _pns->Release();

    ILFree(_pidl);
}

// IRunnableTask methods (override)
STDMETHODIMP CNscIconTask::RunInitRT(void)
{
    IShellFolder* psf;
    LPCITEMIDLIST pidlItem;
    // We need to rebind because shell folders may not be thread safe.
    if (SUCCEEDED(IEBindToParentFolder(_pidl, &psf, &pidlItem)))
    {
        _Extract(psf, pidlItem);
        psf->Release();
    }

    return S_OK;
}

void CNscIconTask::_Extract(IShellFolder *psf, LPCITEMIDLIST pidlItem)
{
    int iIconOpen = -1;
    int iIcon = IEMapPIDLToSystemImageListIndex(psf, pidlItem, &iIconOpen);
 
    // REARCHITECT : This is no good.  We are attempted to see if the content is offline.  That should
    // be done by using IQueryInfo::xxx().  This should go in the InternetShortcut object.
    // IShellFolder2::GetItemData or can also be used.
    //
    // See if it is a link. If it is not, then it can't be in the wininet cache and can't
    // be pinned (sticky cache entry) or greyed (unavailable when offline)
    DWORD dwFlags = 0;
    BOOL fAvailable;
    BOOL fSticky;
    
    // GetLinkInfo() will fail if the SFGAO_FOLDER or SFGAO_BROWSER bits aren't set.
    if (pidlItem && SUCCEEDED(GetLinkInfo(psf, pidlItem, &fAvailable, &fSticky)))
    {
        if (!fAvailable)
        {
            dwFlags |= NSCICON_GREYED;
        }

        if (fSticky)
        {
            dwFlags |= NSCICON_PINNED;
        }
    }
    else
    {
        //item is not a link
        dwFlags |= NSCICON_DONTREFETCH;
    }

    _pfnIcon(_pns, _uId, iIcon, iIconOpen, dwFlags, _uSynchId);
}

// takes ownership of pidl
HRESULT AddNscIconTask(IShellTaskScheduler* pts, LPITEMIDLIST pidl, PFNNSCICONTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId)
{
    HRESULT hr;
    CNscIconTask* pTask = new CNscIconTask(pidl, pfn, pns, uId, uSynchId);
    if (pTask)
    {
        hr = pts->AddTask(SAFECAST(pTask, IRunnableTask*), TASKID_IconExtraction, 
            ITSAT_DEFAULT_LPARAM, PRIORITY_ICON);
        pTask->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        ILFree(pidl);
    }

    return hr;
}

class CNscOverlayTask : public CNscIconTask
{
public:
    CNscOverlayTask(LPITEMIDLIST pidl, PFNNSCOVERLAYTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId);

protected:
    virtual void _Extract(IShellFolder *psf, LPCITEMIDLIST pidlItem);
    
    PFNNSCOVERLAYTASKBALLBACK _pfnOverlay;
};

CNscOverlayTask::CNscOverlayTask(LPITEMIDLIST pidl, PFNNSCOVERLAYTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId) :
    CNscIconTask(pidl, NULL, pns, uId, uSynchId), _pfnOverlay(pfn)
{   
}

void CNscOverlayTask::_Extract(IShellFolder *psf, LPCITEMIDLIST pidlItem)
{
    IShellIconOverlay *psio;
    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellIconOverlay, &psio))))
    {
        int iOverlayIndex = 0;
        if (psio->GetOverlayIndex(pidlItem, &iOverlayIndex) == S_OK && iOverlayIndex > 0)
        {
            _pfnOverlay(_pns, _uId, iOverlayIndex, _uSynchId);
        }
        psio->Release();
    }
}

// takes ownership of pidl
HRESULT AddNscOverlayTask(IShellTaskScheduler* pts, LPITEMIDLIST pidl, PFNNSCOVERLAYTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId)
{
    HRESULT hr;
    CNscOverlayTask *pTask = new CNscOverlayTask(pidl, pfn, pns, uId, uSynchId);
    if (pTask)
    {
        hr = pts->AddTask(SAFECAST(pTask, IRunnableTask*), TASKID_OverlayExtraction, 
                          ITSAT_DEFAULT_LPARAM, PRIORITY_OVERLAY);
        pTask->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        ILFree(pidl);   // we own it, clean up here
    }

    return hr;
}

class CNscEnumTask : public CRunnableTask
{
public:
    CNscEnumTask(PFNNSCENUMTASKBALLBACK pfn, 
        CNscTree *pns, UINT_PTR uId, DWORD dwSig, DWORD grfFlags, HDPA hdpaOrder,
        DWORD dwOrderSig, BOOL fForceExpand, UINT uDepth, BOOL fUpdate, BOOL fUpdatePidls);
    HRESULT Init(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExpandingTo);

    // IRunnableTask
    STDMETHODIMP RunInitRT(void);
    STDMETHODIMP InternalResumeRT(void);
    
private:
    virtual ~CNscEnumTask();

    LPITEMIDLIST           _pidl;
    PFNNSCENUMTASKBALLBACK _pfn;
    CNscTree *             _pns;
    UINT_PTR               _uId;
    DWORD                  _dwSig;
    DWORD                  _grfFlags;
    HDPA                   _hdpaOrder;
    LPITEMIDLIST           _pidlExpandingTo;
    DWORD                  _dwOrderSig;
    BOOL                   _fForceExpand;
    BOOL                   _fUpdate;
    BOOL                   _fUpdatePidls;
    UINT                   _uDepth;
    HDPA                   _hdpa;
    IShellFolder *         _psf;
    IEnumIDList *          _penum;

    static DWORD           s_dwMaxItems;
};

DWORD CNscEnumTask::s_dwMaxItems = 0;

CNscEnumTask::CNscEnumTask(PFNNSCENUMTASKBALLBACK pfn, CNscTree *pns, 
                           UINT_PTR uId, DWORD dwSig, DWORD grfFlags, HDPA hdpaOrder, 
                           DWORD dwOrderSig, BOOL fForceExpand, UINT uDepth, 
                           BOOL fUpdate, BOOL fUpdatePidls) :
    CRunnableTask(RTF_SUPPORTKILLSUSPEND), _pfn(pfn), _uId(uId), _dwSig(dwSig), _grfFlags(grfFlags), 
    _hdpaOrder(hdpaOrder), _dwOrderSig(dwOrderSig),  _fForceExpand(fForceExpand), _uDepth(uDepth), 
    _fUpdate(fUpdate), _fUpdatePidls(fUpdatePidls)
{
    _pns = pns;
    if (_pns)
        _pns->AddRef();
}

HRESULT CNscEnumTask::Init(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExpandingTo)
{
    if (pidlExpandingTo)
        SHILClone(pidlExpandingTo, &_pidlExpandingTo);  // failure OK
    return SHILClone(pidl, &_pidl);
}

CNscEnumTask::~CNscEnumTask()
{
    if (_pns)
        _pns->Release();
    
    ILFree(_pidl);
    ILFree(_pidlExpandingTo);
    OrderList_Destroy(&_hdpaOrder, TRUE);        // calls DPA_Destroy(_hdpaOrder)
    ATOMICRELEASE(_psf);
    ATOMICRELEASE(_penum);
    if (_hdpa)
        OrderList_Destroy(&_hdpa, TRUE);        // calls DPA_Destroy(hdpa)
}

BOOL OrderList_AppendCustom(HDPA hdpa, LPITEMIDLIST pidl, int nOrder, DWORD dwAttrib)
{
    PORDERITEM poi = OrderItem_Create(pidl, nOrder);
    if (poi)
    {
        poi->lParam = dwAttrib;
        if (-1 != DPA_AppendPtr(hdpa, poi))
            return TRUE;

        OrderItem_Free(poi, FALSE); //don't free pidl because caller will do it
    }
    return FALSE;
}

// IRunnableTask methods (override)
STDMETHODIMP CNscEnumTask::RunInitRT(void)
{
    if (!s_dwMaxItems)
    {
        DWORD dwDefaultLimit = 100; // Default value for the limit
        DWORD dwSize = sizeof(s_dwMaxItems);
        SHRegGetUSValue(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                        TEXT("PartialExpandLimit"), NULL, &s_dwMaxItems, &dwSize,
                        FALSE, &dwDefaultLimit, sizeof(dwDefaultLimit));
        if (!s_dwMaxItems)
            s_dwMaxItems = dwDefaultLimit;
    }

    HRESULT hr = E_OUTOFMEMORY;
    _hdpa = DPA_Create(2);
    if (_hdpa)
    {
        // We need to rebind because shell folders may not be thread safe.
        hr = IEBindToObject(_pidl, &_psf);
        if (SUCCEEDED(hr))
        {
            hr = _psf->EnumObjects(NULL, _grfFlags, &_penum);
            if (S_OK != hr)
            {
                // Callback function takes ownership of the pidls and hdpa
                _pfn(_pns, _pidl, _uId, _dwSig, _hdpa, _pidlExpandingTo, _dwOrderSig, _uDepth, _fUpdate, _fUpdatePidls);
                _pidl = NULL;
                _pidlExpandingTo = NULL;
                _hdpa = NULL;
                if (SUCCEEDED(hr))
                    hr = E_FAIL;
            }
        }
    }

    return hr;
}

#define FILE_JUNCTION_FOLDER_FLAGS   (SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_STREAM)

STDMETHODIMP CNscEnumTask::InternalResumeRT(void)
{
    HRESULT hr = S_OK;
    ULONG celt;
    LPITEMIDLIST pidlTemp;
    while (S_OK == _penum->Next(1, &pidlTemp, &celt))
    {
        // filter out zip files (they are both folders and files but we treat them as files)
        // on downlevel SFGAO_STREAM is the same as SFGAO_HASSTORAGE so we'll let zip files slide through (oh well)
        // better than not adding filesystem folders (that have storage)
        if (!(_grfFlags & SHCONTF_NONFOLDERS) && IsOS(OS_WHISTLERORGREATER) && 
            (SHGetAttributes(_psf, pidlTemp, FILE_JUNCTION_FOLDER_FLAGS) & FILE_JUNCTION_FOLDER_FLAGS) == FILE_JUNCTION_FOLDER_FLAGS)
        {
            ILFree(pidlTemp);
        }
        else if (!OrderList_AppendCustom(_hdpa, pidlTemp, -1, 0))
        {
            hr = E_OUTOFMEMORY;
            ILFree(pidlTemp);
            break;
        }
        
        if (!_fForceExpand && (DPA_GetPtrCount(_hdpa) > (int)s_dwMaxItems))
        {
            hr = E_ABORT;
            break;
        }

        // we were told to either suspend or quit...
        if (WaitForSingleObject(_hDone, 0) == WAIT_OBJECT_0)
        {
            return (_lState == IRTIR_TASK_SUSPENDED) ? E_PENDING : E_FAIL;
        }
    }

    if (hr == S_OK)
    {
        ORDERINFO oinfo;
        oinfo.psf = _psf;
        oinfo.dwSortBy = OI_SORTBYNAME; // merge depends on by name.
        if (_hdpaOrder && DPA_GetPtrCount(_hdpaOrder) > 0)
        {
            OrderList_Merge(_hdpa, _hdpaOrder,  -1, (LPARAM)&oinfo, NULL, NULL);
            oinfo.dwSortBy = OI_SORTBYORDINAL;
        }
        else
            oinfo.dwSortBy = OI_SORTBYNAME;

        DPA_Sort(_hdpa, OrderItem_Compare, (LPARAM)&oinfo);
        OrderList_Reorder(_hdpa);
        
        // Callback function takes ownership of the pidls and hdpa
        _pfn(_pns, _pidl, _uId, _dwSig, _hdpa, _pidlExpandingTo, _dwOrderSig, _uDepth, _fUpdate, _fUpdatePidls);
        _pidl = NULL;
        _pidlExpandingTo = NULL;
        _hdpa = NULL;
    }
    
    return S_OK;        // return S_OK even if we failed
}


HRESULT AddNscEnumTask(IShellTaskScheduler* pts, LPCITEMIDLIST pidl, PFNNSCENUMTASKBALLBACK pfn, 
                       CNscTree *pns, UINT_PTR uId, DWORD dwSig, DWORD grfFlags, HDPA hdpaOrder, 
                       LPCITEMIDLIST pidlExpandingTo, DWORD dwOrderSig, 
                       BOOL fForceExpand, UINT uDepth, BOOL fUpdate, BOOL fUpdatePidls)
{
    HRESULT hr;
    CNscEnumTask *pTask = new CNscEnumTask(pfn, pns, uId, dwSig, grfFlags, 
                                         hdpaOrder, dwOrderSig, fForceExpand, uDepth, 
                                         fUpdate, fUpdatePidls);
    if (pTask)
    {
        hr = pTask->Init(pidl, pidlExpandingTo);
        if (SUCCEEDED(hr))
        {
            hr = pts->AddTask(SAFECAST(pTask, IRunnableTask*), TASKID_BackgroundEnum, 
                              ITSAT_DEFAULT_LPARAM, PRIORITY_ENUM);
        }
        pTask->Release();
    }
    else
    {
        OrderList_Destroy(&hdpaOrder, TRUE);        // calls DPA_Destroy(hdpaOrder)
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

#ifdef DEBUG
#define TF_NSC      0x00002000
void DumpOrderItem(IShellFolder *psf, PORDERITEM poi)
{
    if (poi)
    {
        TCHAR szDebugName[MAX_URL_STRING] = TEXT("Desktop");
        DisplayNameOf(psf, poi->pidl, SHGDN_FORPARSING, szDebugName, ARRAYSIZE(szDebugName));
        TraceMsg(TF_NSC, "OrderItem (%d, %s)\n", poi->nOrder, szDebugName);
    }
}

void DumpOrderList(IShellFolder *psf, HDPA hdpa)
{
    if (psf && hdpa)
    {
        TraceMsg(TF_NSC, "OrderList dump: #of items:%d\n", DPA_GetPtrCount(hdpa));
        for (int i = 0; i < DPA_GetPtrCount(hdpa); i++)
        {
            PORDERITEM poi = (PORDERITEM)DPA_GetPtr(hdpa, i);
            DumpOrderItem(psf, poi);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\nsctask.h ===
#ifndef CIconTask_h
#define CIconTask_h
#include <runtask.h>

#ifdef DEBUG
void DumpOrderList(IShellFolder *psf, HDPA hdpa);
#endif

typedef void (*PFNNSCICONTASKBALLBACK)(CNscTree *pns, UINT_PTR uId, int iIcon, int iOpenIcon, DWORD dwFlags, UINT uSynchId);
HRESULT AddNscIconTask(IShellTaskScheduler* pts, LPITEMIDLIST pidl, PFNNSCICONTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId);

typedef void (*PFNNSCOVERLAYTASKBALLBACK)(CNscTree *pns, UINT_PTR uId, int iOverlayIndex, UINT uSynchId);
HRESULT AddNscOverlayTask(IShellTaskScheduler* pts, LPITEMIDLIST pidl, PFNNSCOVERLAYTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId, UINT uSynchId);


typedef void (*PFNNSCENUMTASKBALLBACK)(CNscTree *pns, LPITEMIDLIST pidl, UINT_PTR uId, DWORD dwSig, HDPA hdpa, 
                                       LPITEMIDLIST pidlExpandingTo, DWORD dwOrderSig, UINT uDepth, 
                                       BOOL fUpdate, BOOL fUpdatePidls);

HRESULT AddNscEnumTask(IShellTaskScheduler* pts, LPCITEMIDLIST pidl,
                       PFNNSCENUMTASKBALLBACK pfn, CNscTree *pns, UINT_PTR uId,
                       DWORD dwSig, DWORD grfFlags, HDPA hdpaOrder, LPCITEMIDLIST pidlExpandingTo, 
                       DWORD dwOrderSig, BOOL fForceExpand, UINT uDepth, 
                       BOOL fUpdate, BOOL fUpdatePidls);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\nsc.cpp ===
#include "priv.h"
#include "nsc.h"
#include "resource.h"
#include "subsmgr.h"
#include "favorite.h" //for IsSubscribed()
#include "chanmgr.h"
#include "chanmgrp.h"
#include <mstask.h>    // TASK_TRIGGER
#include "dpastuff.h"
#include <findhlp.h>
#include <ntquery.h>    // defines some values used for fmtid and pid
#include "nsctask.h"
#include <mluisupp.h>
#include <varutil.h>
#include <dobjutil.h>

#define IDH_ORGFAVS_LIST    50490   // defined in iehelpid.h (can't include due to conflicts)

#define TF_NSC      0x00002000

#define ID_NSC_SUBCLASS 359
#define ID_NSCTREE  (DWORD)'NSC'

#define IDT_SELECTION 135

#ifndef UNIX
#define DEFAULT_PATHSTR "C:\\"
#else
#define DEFAULT_PATHSTR "/"
#endif

#define LOGOGAP 2   // all kinds of things 
#define DYITEM  17
#define DXYFRAMESEL 1                             
const DEFAULTORDERPOSITION = 32000;

// HTML displays hard scripting errors if methods on automation interfaces
// return FAILED().  This macro will fix these.
#define FIX_SCRIPTING_ERRORS(hr)        (FAILED(hr) ? S_FALSE : hr)

#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }

DEFINE_SCID(SCID_NAME,          PSGUID_STORAGE, PID_STG_NAME); // defined in shell32!prop.cpp
DEFINE_SCID(SCID_ATTRIBUTES,    PSGUID_STORAGE, PID_STG_ATTRIBUTES);
DEFINE_SCID(SCID_TYPE,          PSGUID_STORAGE, PID_STG_STORAGETYPE);
DEFINE_SCID(SCID_SIZE,          PSGUID_STORAGE, PID_STG_SIZE);
DEFINE_SCID(SCID_CREATETIME,    PSGUID_STORAGE, PID_STG_CREATETIME);

#define IsEqualSCID(a, b)   (((a).pid == (b).pid) && IsEqualIID((a).fmtid, (b).fmtid))

HRESULT CheckForExpandOnce(HWND hwndTree, HTREEITEM hti);

// from util.cpp
// same guid as in bandisf.cpp
// {F47162A0-C18F-11d0-A3A5-00C04FD706EC}
static const GUID TOID_ExtractImage = { 0xf47162a0, 0xc18f, 0x11d0, { 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec } };
//from nsctask.cpp
EXTERN_C const GUID TASKID_IconExtraction; // = { 0xeb30900c, 0x1ac4, 0x11d2, { 0x83, 0x83, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0 } };


BOOL IsChannelFolder(LPCWSTR pwzPath, LPWSTR pwzChannelURL);

typedef struct
{
    DWORD   iIcon     : 12;
    DWORD   iOpenIcon : 12;
    DWORD   nFlags    : 4;
    DWORD   nMagic    : 4;
} NSC_ICONCALLBACKINFO;

typedef struct
{
    DWORD   iOverlayIndex : 28;
    DWORD   nMagic       : 4;
} NSC_OVERLAYCALLBACKINFO;

struct NSC_BKGDENUMDONEDATA
{
    ~NSC_BKGDENUMDONEDATA()
    {
        ILFree(pidl);
        ILFree(pidlExpandingTo);
        OrderList_Destroy(&hdpa, TRUE);
    }

    NSC_BKGDENUMDONEDATA * pNext;

    LPITEMIDLIST pidl;
    HTREEITEM    hitem;
    DWORD        dwSig;
    HDPA         hdpa;
    LPITEMIDLIST pidlExpandingTo;
    DWORD        dwOrderSig;
    UINT         uDepth;
    BOOL         fUpdate;
    BOOL         fUpdatePidls;
};

//if you don't remove the selection, treeview will expand everything below the current selection
void TreeView_DeleteAllItemsQuickly(HWND hwnd)
{
    TreeView_SelectItem(hwnd, NULL);
    TreeView_DeleteAllItems(hwnd);
}

#define NSC_CHILDREN_REMOVE     0
#define NSC_CHILDREN_ADD        1
#define NSC_CHILDREN_FORCE      2
#define NSC_CHILDREN_CALLBACK   3

void TreeView_SetChildren(HWND hwnd, HTREEITEM hti, UINT uFlag)
{
    TV_ITEM tvi;
    tvi.mask = TVIF_CHILDREN | TVIF_HANDLE;   // only change the number of children
    tvi.hItem = hti;

    switch (uFlag)
    {
    case NSC_CHILDREN_REMOVE:
        tvi.cChildren = IsOS(OS_WHISTLERORGREATER) ? I_CHILDRENAUTO : 0;
        break;
        
    case NSC_CHILDREN_ADD:
        tvi.cChildren = IsOS(OS_WHISTLERORGREATER) ? I_CHILDRENAUTO : 1;
        break;

    case NSC_CHILDREN_FORCE:
        tvi.cChildren = 1;
        break;

    case NSC_CHILDREN_CALLBACK:
        tvi.cChildren = I_CHILDRENCALLBACK;
        break;

    default:
        ASSERTMSG(FALSE, "wrong parameter passed to TreeView_SetChildren in nsc");
        break;
    }

    TreeView_SetItem(hwnd, &tvi);
}

void TreeView_DeleteChildren(HWND hwnd, HTREEITEM hti)
{
    for (HTREEITEM htiTemp = TreeView_GetChild(hwnd, hti); htiTemp;)
    {
        HTREEITEM htiDelete = htiTemp;
        htiTemp = TreeView_GetNextSibling(hwnd, htiTemp);
        TreeView_DeleteItem(hwnd, htiDelete);
    }
}

BOOL IsParentOfItem(HWND hwnd, HTREEITEM htiParent, HTREEITEM htiChild)
{
    for (HTREEITEM hti = htiChild; (hti != TVI_ROOT) && (hti != NULL); hti = TreeView_GetParent(hwnd, hti))
        if (hti == htiParent)
            return TRUE;

    return FALSE;
}

STDAPI CNscTree_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr;
    CComObject<CNscTree> *pnsct;

    CComObject<CNscTree>::CreateInstance(&pnsct);
    if (pnsct)
    {
        hr = S_OK;
        *ppunk = pnsct->GetUnknown();
        ASSERT(*ppunk);
        (*ppunk)->AddRef(); // atl doesn't addref in create instance or getunknown about 
    }
    else
    {
        *ppunk = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

INSCTree2 *CNscTree_CreateInstance(void)
{
    INSCTree2 *pnsct = NULL;
    IUnknown *punk;
    if (SUCCEEDED(CNscTree_CreateInstance(NULL, &punk, NULL)))
    {
        punk->QueryInterface(IID_PPV_ARG(INSCTree2, &pnsct));
        punk->Release();
    }
    return pnsct;
}

//////////////////////////////////////////////////////////////////////////////

CNscTree::CNscTree() : _iDragSrc(-1), _iDragDest(-1), _fOnline(!SHIsGlobalOffline())
{
    // This object is a COM object so it will always be on the heap.
    // ASSERT that our member variables were zero initialized.
    ASSERT(!_fInitialized);
    ASSERT(!_dwTVFlags);
    ASSERT(!_hdpaColumns);
    ASSERT(!_hdpaViews);
    
    m_bWindowOnly = TRUE;

    _mode = MODE_FAVORITES | MODE_CONTROL; //everyone sets the mode except organize favorites
    _csidl = CSIDL_FAVORITES;
    _dwFlags = NSS_DROPTARGET | NSS_BROWSERSELECT; //this should be default only in control mode
    _grfFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;

    _ulSortCol = _ulDisplayCol = (ULONG)-1;

    // Enable the notifications from wininet that tell us when to gray items 
    // or update a pinned glyph
    _inetNotify.Enable();

    InitializeCriticalSection(&_csBackgroundData);
}

CNscTree::~CNscTree()
{
    Pidl_Set(&_pidlSelected, NULL);

    // This needs to be destroyed or we leak the icon handle.
    if (_hicoPinned) 
        DestroyIcon(_hicoPinned);

    if (_hdpaColumns)
    {
        DPA_DestroyCallback(_hdpaColumns, DPADeleteItemCB, NULL);
        _hdpaColumns = NULL;
    }

    if (_hdpaViews)
    {
        DPA_DestroyCallback(_hdpaViews, DPADeletePidlsCB, NULL);
        _hdpaViews = NULL;
    }

    EnterCriticalSection(&_csBackgroundData);
    while (_pbeddList)
    {
        // Extract the first element of the list
        NSC_BKGDENUMDONEDATA * pbedd = _pbeddList;
        _pbeddList = pbedd->pNext;
        delete pbedd;
    }
    LeaveCriticalSection(&_csBackgroundData);

    DeleteCriticalSection(&_csBackgroundData);
}

void CNscTree::_ReleaseCachedShellFolder()
{
    ATOMICRELEASE(_psfCache);
    ATOMICRELEASE(_psf2Cache);
    _ulSortCol = _ulDisplayCol = (ULONG)-1;
    _htiCache = NULL;
}

#ifdef DEBUG
void CNscTree::TraceHTREE(HTREEITEM hti, LPCTSTR pszDebugMsg)
{
    TCHAR szDebug[MAX_PATH] = TEXT("Root");

    if (hti != TVI_ROOT && hti)
    {
        TVITEM tvi;
        tvi.mask = TVIF_TEXT | TVIF_HANDLE;
        tvi.hItem = hti;
        tvi.pszText = szDebug;
        tvi.cchTextMax = MAX_PATH;
        TreeView_GetItem(_hwndTree, &tvi);
    }

    TraceMsg(TF_NSC, "NSCBand: %s - %s", pszDebugMsg, szDebug);
}

void CNscTree::TracePIDL(LPCITEMIDLIST pidl, LPCTSTR pszDebugMsg)
{
    TCHAR szDebugName[MAX_URL_STRING] = TEXT("Desktop");
    STRRET str;
    if (_psfCache &&
        SUCCEEDED(_psfCache->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str)))
    {
        StrRetToBuf(&str, pidl, szDebugName, ARRAYSIZE(szDebugName));
    }
    TraceMsg(TF_NSC, "NSCBand: %s - %s", pszDebugMsg, szDebugName);
}

void CNscTree::TracePIDLAbs(LPCITEMIDLIST pidl, LPCTSTR pszDebugMsg)
{
    TCHAR szDebugName[MAX_URL_STRING] = TEXT("Desktop");
    IEGetDisplayName(pidl, szDebugName, SHGDN_FORPARSING);
    TraceMsg(TF_NSC, "NSCBand: %s - %s", pszDebugMsg, szDebugName);
}
#endif

void CNscTree::_AssignPidl(PORDERITEM poi, LPITEMIDLIST pidlNew)
{
    if (poi && pidlNew)
    {    
        // We are assuming that its only replacing the last element...
        ASSERT(ILFindLastID(pidlNew) == pidlNew);

        LPITEMIDLIST pidlParent = ILCloneParent(poi->pidl);
        if (pidlParent)
        { 
            LPITEMIDLIST pidlT = ILCombine(pidlParent, pidlNew);
            if (pidlT)
            {
                Pidl_Set(&poi->pidl, pidlT);
                ILFree(pidlT);
            }
            ILFree(pidlParent);
        }
    }
}

/*****************************************************\
    DESCRIPTION:
        We want to unsubclass/subclass everytime we
    change roots so we get the correct notifications
    for everything in that subtree of the shell
    name space.
\*****************************************************/
void CNscTree::_SubClass(LPCITEMIDLIST pidlRoot)
{
    LPITEMIDLIST pidlToFree = NULL;
    
    if (NULL == pidlRoot)       // (NULL == CSIDL_DESKTOP)
    {
        SHGetSpecialFolderLocation(NULL, CSIDL_DESKTOP, (LPITEMIDLIST *) &pidlRoot);
        pidlToFree = (LPITEMIDLIST) pidlRoot;
    }
        
    // It's necessary 
    if (!_fSubClassed && pidlRoot)
    {
        if (_SubclassWindow(_hwndTree))
        {
            _RegisterWindow(_hwndTree, pidlRoot,
                SHCNE_DRIVEADD|SHCNE_CREATE|SHCNE_MKDIR|SHCNE_DRIVEREMOVED|
                SHCNE_DELETE|SHCNE_RMDIR|SHCNE_RENAMEITEM|SHCNE_RENAMEFOLDER|
                SHCNE_MEDIAINSERTED|SHCNE_MEDIAREMOVED|SHCNE_NETUNSHARE|SHCNE_NETSHARE|
                SHCNE_UPDATEITEM|SHCNE_UPDATEIMAGE|SHCNE_ASSOCCHANGED|
                SHCNE_UPDATEDIR | SHCNE_EXTENDED_EVENT, 
                ((_mode & MODE_HISTORY) ? SHCNRF_ShellLevel : SHCNRF_ShellLevel | SHCNRF_InterruptLevel));
        }

        ASSERT(_hwndTree);
        _fSubClassed = SetWindowSubclass(_hwndTree, s_SubClassTreeWndProc, 
            ID_NSCTREE, (DWORD_PTR)this);
    }

    if (pidlToFree) // Did we have to alloc our own pidl?
        ILFree(pidlToFree); // Yes.
}


/*****************************************************\
    DESCRIPTION:
        We want to unsubclass/subclass everytime we
    change roots so we get the correct notifications
    for everything in that subtree of the shell
    name space.
\*****************************************************/
void CNscTree::_UnSubClass(void)
{
    if (_fSubClassed)
    {
        _fSubClassed = FALSE;
        RemoveWindowSubclass(_hwndTree, s_SubClassTreeWndProc, ID_NSCTREE);
        _UnregisterWindow(_hwndTree);
        _UnsubclassWindow(_hwndTree);
    }
}


void CNscTree::_ReleasePidls(void)
{
    Pidl_Set(&_pidlRoot, NULL);
    Pidl_Set(&_pidlNavigatingTo, NULL);
}


HRESULT CNscTree::ShowWindow(BOOL fShow)
{
    if (fShow)
        _TvOnShow();
    else
        _TvOnHide();

    return S_OK;
}


HRESULT CNscTree::SetSite(IUnknown *punkSite)
{
    ATOMICRELEASE(_pnscProxy);

    if (!punkSite)
    {
        // We need to prepare to go away and squirel
        // away the currently selected pidl(s) because
        // the caller may call INSCTree::GetSelectedItem()
        // after the tree is gone.
        _OnWindowCleanup();
    }
    else
    {
        punkSite->QueryInterface(IID_PPV_ARG(INamespaceProxy, &_pnscProxy));
    }
    
    return CObjectWithSite::SetSite(punkSite);
}

DWORD BackgroundDestroyScheduler(void *pvData)
{
    IShellTaskScheduler *pTaskScheduler = (IShellTaskScheduler *)pvData;

    pTaskScheduler->Release();
    return 0;
}

EXTERN_C const GUID TASKID_BackgroundEnum;

HRESULT CNscTree::_OnWindowCleanup(void)
{
    _fClosing = TRUE;

    if (_hwndTree)
    {
        ASSERT(::IsWindow(_hwndTree));    // make sure it has not been destroyed (it is a child)
        _TvOnHide();

        ::KillTimer(_hwndTree, IDT_SELECTION);
        ::SendMessage(_hwndTree, WM_SETREDRAW, FALSE, 0);
        TreeView_DeleteAllItemsQuickly(_hwndTree);
        _UnSubClass();

        _hwndTree = NULL;
    }

    // Squirel away the selected pidl in case the caller asks for it after the
    // treeview is gone.
    if (!_fIsSelectionCached)
    {
        _fIsSelectionCached = TRUE;
        Pidl_Set(&_pidlSelected, NULL);
        GetSelectedItem(&_pidlSelected, 0);
    }

    ATOMICRELEASE(_pFilter);
    
    if (_pTaskScheduler)
    {
        _pTaskScheduler->RemoveTasks(TOID_NULL, ITSAT_DEFAULT_LPARAM, FALSE);
        if (_pTaskScheduler->CountTasks(TASKID_BackgroundEnum) == 0)
        {
            _pTaskScheduler->Release();
        }
        // We need to keep Browseui loaded because we depend on the CShellTaskScheduler
        // to be still around when our background task executes. Browseui can be unloaded by COM when
        // we CoUninit from this thread.
        else if (!SHQueueUserWorkItem(BackgroundDestroyScheduler, (void *)_pTaskScheduler, 0, NULL, NULL, "browseui.dll", 0))
        {
            _pTaskScheduler->Release();
        }

        _pTaskScheduler = NULL;
    }

    _ReleasePidls();
    _ReleaseCachedShellFolder();

    return S_OK;
}

ITEMINFO *CNscTree::_GetTreeItemInfo(HTREEITEM hti)
{
    TV_ITEM tvi;
    
    tvi.mask = TVIF_PARAM | TVIF_HANDLE;
    tvi.hItem = hti;
    if (!TreeView_GetItem(_hwndTree, &tvi))
        return NULL;
    return (ITEMINFO *)tvi.lParam;
}

PORDERITEM CNscTree::_GetTreeOrderItem(HTREEITEM hti)
{
    ITEMINFO *pii = _GetTreeItemInfo(hti);
    return pii ? pii->poi : NULL;
}

// builds a fully qualified IDLIST from a given tree node by walking up the tree
// be sure to free this when you are done!

LPITEMIDLIST CNscTree::_GetFullIDList(HTREEITEM hti)
{
    LPITEMIDLIST pidl, pidlT = NULL;

    if ((hti == TVI_ROOT) || (hti == NULL)) // evil root
    {
        pidlT = ILClone(_pidlRoot);
        return pidlT;
    }
    // now lets get the information about the item
    PORDERITEM poi = _GetTreeOrderItem(hti);
    if (!poi)
    {
        return NULL;
    }
    
    pidl = ILClone(poi->pidl);
    if (pidl && _pidlRoot)
    {
        while ((hti = TreeView_GetParent(_hwndTree, hti)))
        {
            poi = _GetTreeOrderItem(hti);
            if (!poi)
                return pidl;   // will assume I messed up...
            
            if (poi->pidl)
                pidlT = ILCombine(poi->pidl, pidl);
            else 
                pidlT = NULL;
            
            ILFree(pidl);
            pidl = pidlT;
            if (pidl == NULL)
                break;          // outta memory
        }
        if (pidl) 
        {
            // MODE_NORMAL has the pidl root in the tree
            if (_mode != MODE_NORMAL)
            {
                pidlT = ILCombine(_pidlRoot, pidl);    // gotta get the silent root
                ILFree(pidl);
            }
            else
                pidlT = pidl;
        }
    }
    return pidlT;
}


BOOL _IsItemFileSystem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return (SHGetAttributes(psf, pidl, SFGAO_FOLDER | SFGAO_FILESYSTEM) == (SFGAO_FOLDER | SFGAO_FILESYSTEM));
}

HTREEITEM CNscTree::_AddItemToTree(HTREEITEM htiParent, LPITEMIDLIST pidl, 
                                   int cChildren, int iPos, HTREEITEM htiAfter, /* = TVI_LAST*/
                                   BOOL fCheckForDups, /* = TRUE */ BOOL fMarked /*= FALSE */)
{
    HTREEITEM htiRet = NULL;

    BOOL fCached;
    
    // So we need to cached the shell folder of the parent item. But, this is a little interesting:
    if (_mode == MODE_NORMAL && htiParent == TVI_ROOT)
    {
        // In "Normal" mode, or "Display root in NSC" mode, there is only 1 item that is parented to
        // TVI_ROOT. So when we do an _AddItemToTree, we need the shell folder that contains _pidlRoot or
        // the Parent of TVI_ROOT.
        fCached = (NULL != _CacheParentShellFolder(htiParent, NULL));
    }
    else
    {
        // But, in the "Favorites, Control or History" if htiParent is TVI_ROOT, then we are not adding _pidlRoot,
        // so we actually need the folder that IS TVI_ROOT.
        fCached = _CacheShellFolder(htiParent);
    }

    if (fCached)
    {
        LPITEMIDLIST pidlNew = ILClone(pidl);
        if (pidlNew)
        {
            PORDERITEM poi = OrderItem_Create(pidlNew, iPos);
            if (poi)
            {
                ITEMINFO *pii = (ITEMINFO *)LocalAlloc(LPTR, sizeof(*pii));
                if (pii)
                {
                    pii->dwSig = _dwSignature++;
                    pii->poi = poi;

                    // For the normal case, we need a relative pidl for this add, but the lParam needs to have a full
                    // pidl (This is so that arbitrary mounting works, as well as desktop case).
                    pidl = pidlNew; //reuse variable
                    if (_mode == MODE_NORMAL && htiParent == TVI_ROOT)
                    {
                        pidl = ILFindLastID(pidl);
                    }

                    if (!fCheckForDups || (NULL == (htiRet = _FindChild(_psfCache, htiParent, pidl))))
                    {
                        TV_INSERTSTRUCT tii;
                        // Initialize item to add with callback for everything
                        tii.item.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM | TVIF_CHILDREN | TVIF_STATE;
                        tii.hParent = htiParent;
                        tii.hInsertAfter = htiAfter;
                        tii.item.iImage = I_IMAGECALLBACK;
                        tii.item.iSelectedImage = I_IMAGECALLBACK;
                        tii.item.pszText = LPSTR_TEXTCALLBACK;
                        tii.item.cChildren = cChildren;
                        tii.item.lParam = (LPARAM)pii;
                        tii.item.stateMask = TVIS_STATEIMAGEMASK;
                        tii.item.state = (fMarked ? NSC_TVIS_MARKED : 0);

#ifdef DEBUG
                        TracePIDL(pidl, TEXT("Inserting"));
                        TraceMsg(TF_NSC, "_AddItemToTree(htiParent=%#08lx, htiAfter=%#08lx, fCheckForDups=%d, _psfCache=%#08lx)", 
                                    htiParent, htiAfter, fCheckForDups, _psfCache);
                    
#endif // DEBUG

                        pii->fNavigable = !_IsItemFileSystem(_psfCache, pidl);

                        htiRet = TreeView_InsertItem(_hwndTree, &tii);
                        if (htiRet)
                        {
                            pii = NULL;        // don't free
                            poi = NULL;        // don't free
                            pidlNew = NULL;
                        }
                    }
                    if (pii)
                    {
                        LocalFree(pii);
                        pii = NULL;
                    }
                }
                if (poi)
                    OrderItem_Free(poi, FALSE);
            }
            ILFree(pidlNew);
        }
    }
    
    return htiRet;
}

DWORD CNscTree::_SetExStyle(DWORD dwExStyle)
{
    DWORD dwOldStyle = _dwExStyle;

    _dwExStyle = dwExStyle;
    return dwOldStyle;
}

DWORD CNscTree::_SetStyle(DWORD dwStyle)
{
    dwStyle |= TVS_EDITLABELS | TVS_SHOWSELALWAYS | TVS_NONEVENHEIGHT;

    if (dwStyle & WS_HSCROLL)
        dwStyle &= ~WS_HSCROLL;
    else
        dwStyle |= TVS_NOHSCROLL;


    if (TVS_HASLINES & dwStyle)
        dwStyle &= ~TVS_FULLROWSELECT;       // If it has TVS_HASLINES, it can't have TVS_FULLROWSELECT

    // If the parent window is mirrored then the treeview window will inheret the mirroring flag
    // And we need the reading order to be Left to right, which is the right to left in the mirrored mode.

    if (((_mode & MODE_HISTORY) || (MODE_NORMAL == _mode)) && IS_WINDOW_RTL_MIRRORED(_hwndParent)) 
    {
        // This means left to right reading order because this window will be mirrored.
        dwStyle |= TVS_RTLREADING;
    }

    // According to Bug#241601, Tooltips display too quickly. The problem is
    // the original designer of the InfoTips in the Treeview merged the "InfoTip" tooltip and
    // the "I'm too small to display correctly" tooltips. This is really unfortunate because you
    // cannot control the display of these tooltips independantly. Therefore we are turning off
    // infotips in normal mode. (lamadio) 4.7.99
    AssertMsg(_mode != MODE_NORMAL || !(dwStyle & TVS_INFOTIP), TEXT("can't have infotip with normal mode in nsc"));

    DWORD dwOldStyle = _style;
    _style = dwStyle | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | WS_VSCROLL | WS_TABSTOP;
    _fSingleExpand = BOOLIFY(_style & TVS_SINGLEEXPAND);

    return dwOldStyle;

}

HRESULT CNscTree::CreateTree(HWND hwndParent, DWORD dwStyles, HWND *phwnd)
{
    return CreateTree2(hwndParent, dwStyles, 0, phwnd);
}

HRESULT CNscTree::CreateTree2(HWND hwndParent, DWORD dwStyle, DWORD dwExStyle, HWND *phwnd)
{
    _fIsSelectionCached = FALSE;
    if (*phwnd)
        return S_OK;                                

    _hwndParent = hwndParent;
    _SetStyle(dwStyle);
    _SetExStyle(dwExStyle);
    *phwnd = _CreateTreeview();
    if (*phwnd == NULL)
    {
        return E_OUTOFMEMORY;
    }
    ::ShowWindow(_hwndTree, SW_SHOW);
    return S_OK;
}

HWND CNscTree::_CreateTreeview()
{
    ASSERT(_hwndTree == NULL);

    LONG lTop = 0;
    RECT rcParent;
    ::GetClientRect(_hwndParent, &rcParent);

    TCHAR szTitle[40];
    if (_mode & (MODE_HISTORY | MODE_FAVORITES))
    {
        // create with a window title so that msaa can expose name
        int id = (_mode & MODE_HISTORY) ? IDS_BAND_HISTORY : IDS_BAND_FAVORITES;
        MLLoadString(id, szTitle, ARRAYSIZE(szTitle));
    }
    else
    {
        szTitle[0] = 0;
    }

    _hwndTree = CreateWindowEx(0, WC_TREEVIEW, szTitle, _style | WS_VISIBLE,
        0, lTop, rcParent.right, rcParent.bottom, _hwndParent, (HMENU)ID_CONTROL, HINST_THISDLL, NULL);
    
    if (_hwndTree)
    {
        ::SendMessage(_hwndTree, TVM_SETSCROLLTIME, 100, 0);
        ::SendMessage(_hwndTree, CCM_SETUNICODEFORMAT, DLL_IS_UNICODE, 0);
        if (_dwExStyle)
            TreeView_SetExtendedStyle(_hwndTree, _dwExStyle, _dwExStyle);
    }
    else
    {
        TraceMsg(TF_ERROR, "_hwndTree failed");
    }

    return _hwndTree;
} 

UINT GetControlCharWidth(HWND hwnd)
{
    SIZE siz = {0};
    CClientDC       dc(HWND_DESKTOP);

    if (dc.m_hDC)
    {
        HFONT hfOld = dc.SelectFont(FORWARD_WM_GETFONT(hwnd, SendMessage));

        if (hfOld)
        {
            GetTextExtentPoint(dc.m_hDC, TEXT("0"), 1, &siz);

            dc.SelectFont(hfOld);
        }
    }

    return siz.cx;
}

HWND CNscTree::_CreateHeader()
{
    if (!_hwndHdr)
    {
        _hwndHdr = CreateWindowEx(0, WC_HEADER, NULL, HDS_HORZ | WS_CHILD, 0, 0, 0, 0, 
                                  _hwndParent, (HMENU)ID_HEADER, HINST_THISDLL, NULL);
        if (_hwndHdr)
        {
            HD_LAYOUT layout;
            WINDOWPOS wpos;
            RECT rcClient;
            int  cxChar = GetControlCharWidth(_hwndTree);

            layout.pwpos = &wpos;
            ::GetClientRect(_hwndParent, &rcClient);
            layout.prc = &rcClient;
            if (Header_Layout(_hwndHdr, &layout))
            {
                ::MoveWindow(_hwndTree, 0, wpos.cy, RECTWIDTH(rcClient), RECTHEIGHT(rcClient)-wpos.cy, TRUE);
                for (int i = 0; i < DPA_GetPtrCount(_hdpaColumns);)
                {
                    HEADERINFO *phinfo = (HEADERINFO *)DPA_GetPtr(_hdpaColumns, i);
                    if (EVAL(phinfo))
                    {
                        HD_ITEM item;
          
                        item.mask = HDI_TEXT | HDI_FORMAT | HDI_WIDTH;
                        item.pszText = phinfo->szName;
                        item.fmt = phinfo->fmt;
                        item.cxy = cxChar * phinfo->cxChar;

                        if (Header_InsertItem(_hwndHdr, i, &item) == -1)
                        {
                            DPA_DeletePtr(_hdpaColumns, i);
                            LocalFree(phinfo);
                            phinfo = NULL;
                        }
                        else
                        {
                            i++;
                        }
                    }
                }
                if (_hwndTree)
                {
                    HFONT hfont = (HFONT)::SendMessage(_hwndTree, WM_GETFONT, 0, 0);

                    if (hfont)
                        ::SendMessage(_hwndHdr, WM_SETFONT, (WPARAM)hfont, MAKELPARAM(TRUE, 0));
                }
                ::SetWindowPos(_hwndHdr, wpos.hwndInsertAfter, wpos.x, wpos.y,
                             wpos.cx, wpos.cy, wpos.flags | SWP_SHOWWINDOW);
            }
        }
    }

    return _hwndHdr;
}

void CNscTree::_TvOnHide()
{
    _DtRevoke();
    ::SetWindowPos(_hwndTree, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
}

void CNscTree::_TvOnShow()
{
    ::SetWindowPos(_hwndTree, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
    _DtRegister();
}

HRESULT IUnknown_GetAmbientProperty(IUnknown *punk, DISPID dispid, VARTYPE vt, void *pData)
{
    HRESULT hr = E_FAIL;
    if (punk)
    {
        IDispatch *pdisp;
        hr = punk->QueryInterface(IID_PPV_ARG(IDispatch, &pdisp));
        if (SUCCEEDED(hr))
        {
            DISPPARAMS dp = {0};
            VARIANT v;
            VariantInit(&v);
            hr = pdisp->Invoke(dispid, IID_NULL, 0, DISPATCH_PROPERTYGET, &dp, &v, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                VARIANT vDest;
                VariantInit(&vDest);
                // we've got the variant, so now go an coerce it to the type
                // that the user wants.
                //
                hr = VariantChangeType(&vDest, &v, 0, vt);
                if (SUCCEEDED(hr))
                {
                    *((DWORD *)pData) = *((DWORD *)&vDest.lVal);
                    VariantClear(&vDest);
                }
                VariantClear(&v);
            }
            pdisp->Release();
        }
    }
    return hr;
}

HRESULT CNscTree::_HandleWinIniChange()
{
    COLORREF clrBk;

    if (FAILED(IUnknown_GetAmbientProperty(_punkSite, DISPID_AMBIENT_BACKCOLOR, VT_I4, &clrBk)))
        clrBk = GetSysColor(COLOR_WINDOW);

    TreeView_SetBkColor(_hwndTree, clrBk);
    
    if (!(_dwFlags & NSS_NORMALTREEVIEW))
    {
        // make things a bit more spaced out
        int cyItem = TreeView_GetItemHeight(_hwndTree);
        cyItem += LOGOGAP + 1;
        TreeView_SetItemHeight(_hwndTree, cyItem);
    }

    // Show compressed files in different color...
    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_SHOWCOMPCOLOR, FALSE);
    _fShowCompColor = ss.fShowCompColor;

    return S_OK;
}

HRESULT CNscTree::Initialize(LPCITEMIDLIST pidlRoot, DWORD grfEnumFlags, DWORD dwFlags)
{
    HRESULT hr;

    _grfFlags = grfEnumFlags;       // IShellFolder::EnumObjects() flags.
    if (!(_mode & MODE_CUSTOM))
    {
        if (_mode != MODE_NORMAL)
        {
            dwFlags |= NSS_BORDER;
        }
        else
        {
            dwFlags |= NSS_NORMALTREEVIEW;
        }
    }
    _dwFlags = dwFlags;             // Behavior Flags
    if (_dwFlags & NSS_NORMALTREEVIEW)
        _dwFlags &= ~NSS_HEADER;// multi-select requires owner draw

    if (!_fInitialized)
    {
        ::SendMessage(_hwndTree, WM_SETREDRAW, FALSE, 0);

        _fInitialized = TRUE;
    
        HIMAGELIST himl;
        Shell_GetImageLists(NULL, &himl);
    
        TreeView_SetImageList(_hwndTree, himl, TVSIL_NORMAL);
        _DtRegister();
    
        //failure ignored intentionally
        THR(CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC_SERVER,
                             IID_PPV_ARG(IShellTaskScheduler, &_pTaskScheduler)));
        if (_pTaskScheduler)
            _pTaskScheduler->Status(ITSSFLAG_KILL_ON_DESTROY, ITSS_THREAD_TIMEOUT_NO_CHANGE);

        hr = Init();  // init lock and scroll handles for CDelegateDropTarget
    
        ASSERT(SUCCEEDED(hr));
    
        if (_dwFlags & NSS_BORDER)
        {
            // set borders and space out for all, much cleaner.
            TreeView_SetBorder(_hwndTree, TVSBF_XBORDER, 2 * LOGOGAP, 0);   
        }
    
        // init some settings
        _HandleWinIniChange();

        // pidlRoot may equal NULL because that is equal to CSIDL_DESKTOP.
        if ((LPITEMIDLIST)INVALID_HANDLE_VALUE != pidlRoot)
        {
            _UnSubClass();
            _SetRoot(pidlRoot, 1, NULL, NSSR_CREATEPIDL);
            _SubClass(pidlRoot);
        }
    
        // need top level frame available for D&D if possible.
    
        _hwndDD = ::GetParent(_hwndTree);
        IOleWindow *pOleWindow;
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IOleWindow, &pOleWindow))))
        { 
            pOleWindow->GetWindow(&_hwndDD);
            pOleWindow->Release();
        }

        //this is a non-ML resource
        _hicoPinned = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_PINNED), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
        ASSERT(_hicoPinned);

        ::SendMessage(_hwndTree, WM_SETREDRAW, TRUE, 0);
    }
    else
        hr = _ChangePidlRoot(pidlRoot);

    return hr;
}

// set the root of the name space control.
//
// in:
//  pidlRoot    NULL means the desktop
//    HIWORD 0 -> LOWORD == ID of special folder (CSIDL_* values)
//
//  flags,
//  pidlRoot,       PIDL, NULL for desktop, or CSIDL for shell special folder
//  iExpandDepth,   how many levels to expand the tree
//  pidlExpandTo    NULL, or PIDL to expand to
//

BOOL CNscTree::_SetRoot(LPCITEMIDLIST pidlRoot, int iExpandDepth, LPCITEMIDLIST pidlExpandTo, NSSR_FLAGS flags)
{
    _ReleasePidls();
    // review chrisny:  clean up this psr stuff.
    // HIWORD/LOWORD stuff is to support pidl IDs instead of full pidl here
    if (HIWORD(pidlRoot))
    {
        _pidlRoot = ILClone(pidlRoot);
    }
    else
    {
        SHGetSpecialFolderLocation(NULL, LOWORD(pidlRoot) ? LOWORD(pidlRoot) : CSIDL_DESKTOP, &_pidlRoot);
    }
    
    if (_pidlRoot)
    {
        HTREEITEM htiRoot = TVI_ROOT;
        if (_mode == MODE_NORMAL)
        {
            // Since we'll be adding this into the tree, we need
            // to clone it: We have a copy for the class, and we
            // have one for the tree itself (Makes life easier so
            // we don't have to special case TVI_ROOT).
            htiRoot = _AddItemToTree(TVI_ROOT, _pidlRoot, 1, 0);
            if (htiRoot)
            {
                TreeView_SelectItem(_hwndTree, htiRoot);
                TraceMsg(TF_NSC, "NSCBand: Setting Root to \"Desktop\"");
            }
            else
            {
                htiRoot = TVI_ROOT;
            }
        }

        BOOL fOrdered = _fOrdered;
        _LoadSF(htiRoot, _pidlRoot, &fOrdered);   // load the roots (actual children of _pidlRoot.
        // this is probably redundant since _LoadSF->_LoadOrder sets this
        _fOrdered = BOOLIFY(fOrdered);

#ifdef DEBUG
        TracePIDLAbs(_pidlRoot, TEXT("Setting Root to"));
#endif // DEBUG

        return TRUE;
    }

    TraceMsg(DM_ERROR, "set root failed");
    _ReleasePidls();
    return FALSE;
}


// cache the shell folder for a given tree item
// in:
//  hti tree node to cache shell folder for. this my be
//      NULL indicating the root item.
//

BOOL CNscTree::_CacheShellFolder(HTREEITEM hti)
{
    // in the cache?
    if ((hti != _htiCache) || (_psfCache == NULL))
    {
        // cache miss, do the work
        LPITEMIDLIST pidl;
        BOOL fRet = FALSE;
        
        _fpsfCacheIsTopLevel = FALSE;
        _ReleaseCachedShellFolder();
        
        if ((hti == NULL) || (hti == TVI_ROOT))
        {
            pidl = ILClone(_pidlRoot);
        }
        else
        {
            pidl = _GetFullIDList(hti);
        }
            
        if (pidl)
        {
            if (SUCCEEDED(IEBindToObject(pidl, &_psfCache)))
            {
                if (_pnscProxy)
                    _pnscProxy->CacheItem(pidl);
                ASSERT(_psfCache);
                _htiCache = hti;    // this is for the cache match
                _fpsfCacheIsTopLevel = (hti == TVI_ROOT || hti == NULL);
                _psfCache->QueryInterface(IID_PPV_ARG(IShellFolder2, &_psf2Cache));
                fRet = TRUE;
            }      
            
            ILFree(pidl);
        }
        
        return fRet;
    }
    return TRUE;
}

#define TVI_ROOTPARENT ((HTREEITEM)(ULONG_PTR)-0xF000)

// pidlItem is typically a relative pidl, except in the case of the root where
// it can be a fully qualified pidl

LPITEMIDLIST CNscTree::_CacheParentShellFolder(HTREEITEM hti, LPITEMIDLIST pidl)
{
    // need parent shell folder of TVI_ROOT, special case for drop insert into root level of tree.
    if (hti == TVI_ROOT || 
        hti == NULL || 
        (_mode == MODE_NORMAL &&
        TreeView_GetParent(_hwndTree, hti) == NULL))    // If we have a null parent and we're a normal, 
                                                        // than that's the same as root.
    {
        if (_htiCache != TVI_ROOTPARENT) 
        {
            _ReleaseCachedShellFolder();
            IEBindToParentFolder(_pidlRoot, &_psfCache, NULL);

            if (!ILIsEmpty(_pidlRoot))
                _htiCache = TVI_ROOTPARENT;
        }
        return ILFindLastID(_pidlRoot);
    }

    if (_CacheShellFolder(TreeView_GetParent(_hwndTree, hti)))
    {
        if (pidl == NULL)
        {
            PORDERITEM poi = _GetTreeOrderItem(hti);
            if (!poi)
                return NULL;

            pidl = poi->pidl;
        }
        
        return ILFindLastID(pidl);
    }
    
    return NULL;
}

typedef struct _SORTPARAMS
{
    CNscTree *pnsc;
    IShellFolder *psf;
} SORTPARAMS;

int CALLBACK CNscTree::_TreeCompare(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    SORTPARAMS *pSortParams = (SORTPARAMS *)lParamSort;
    PORDERITEM poi1 = GetPoi(lParam1), poi2 = GetPoi(lParam2);
    
    HRESULT hr = pSortParams->pnsc->_CompareIDs(pSortParams->psf, poi1->pidl, poi2->pidl);
    return (short)SCODE_CODE(hr);
}

int CALLBACK CNscTree::_TreeOrder(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    HRESULT hr;
    PORDERITEM poi1 = GetPoi(lParam1), poi2 = GetPoi(lParam2);
    
    ASSERT((poi1 != NULL) && (poi1 != NULL));
    if (poi1->nOrder == poi2->nOrder)
        hr = 0;
    else
        // do unsigned compare so -1 goes to end of list
        hr = (poi1->nOrder < poi2->nOrder ? -1 : 1);
    
    return (short)SCODE_CODE(hr);
}
// review chrisny:  instead of sort, insert items on the fly.
void CNscTree::_Sort(HTREEITEM hti, IShellFolder *psf)
{
    TV_SORTCB   scb;
    SORTPARAMS  SortParams = {this, psf};
    BOOL        fOrdering = _IsOrdered(hti);
#ifdef DEBUG
    TraceHTREE(hti, TEXT("Sorting"));
#endif
    
    scb.hParent = hti;
    scb.lpfnCompare = !fOrdering ? _TreeCompare : _TreeOrder;
    
    scb.lParam = (LPARAM)&SortParams;
    TreeView_SortChildrenCB(_hwndTree, &scb, FALSE);
}

BOOL CNscTree::_IsOrdered(HTREEITEM htiRoot)
{
    if ((htiRoot == TVI_ROOT) || (htiRoot == NULL))
        return _fOrdered;
    else
    {
        PORDERITEM poi = _GetTreeOrderItem(htiRoot);
        if (poi)
        {
            // LParam Is a Boolean: 
            // TRUE: It has an order.
            // FALSE: It does not have an order.
            // Question: Where is that order stored? _hdpaOrder?
            return poi->lParam;
        }
    }
    return FALSE;
}

//helper function to init _hdpaOrd
//MUST be followed by a call to _FreeOrderList
HRESULT CNscTree::_PopulateOrderList(HTREEITEM htiRoot)
{
    int        i = 0;
    HTREEITEM  hti = NULL;
#ifdef DEBUG
    TraceHTREE(htiRoot, TEXT("Populating Order List from tree node"));
#endif
    
    if (_hdpaOrd)
        DPA_Destroy(_hdpaOrd);
    
    _hdpaOrd = DPA_Create(4);
    if (_hdpaOrd == NULL)
        return E_FAIL;
    
    for (hti = TreeView_GetChild(_hwndTree, htiRoot); hti; hti = TreeView_GetNextSibling(_hwndTree, hti))
    {
        PORDERITEM poi = _GetTreeOrderItem(hti);
        if (poi)
        {
            poi->nOrder = i;        // reset the positions of the nodes.
            DPA_SetPtr(_hdpaOrd, i++, (void *)poi);
        }
    }
    
    //set the root's ordered flag
    if (htiRoot == TVI_ROOT)
    {
        _fOrdered = TRUE;
    }
    else
    {
        PORDERITEM poi = _GetTreeOrderItem(htiRoot);
        if (poi)
        {
            poi->lParam = TRUE;
        }
    }
    
    return S_OK;
}

//helper function to free _hdpaOrd
//MUST be preceded by a call to _PopulateOrderList

void CNscTree::_FreeOrderList(HTREEITEM htiRoot)
{
    ASSERT(_hdpaOrd);
#ifdef DEBUG
    TraceHTREE(htiRoot, TEXT("Freeing OrderList"));
#endif

    _ReleaseCachedShellFolder();
    
    // Persist the new order out to the registry
    LPITEMIDLIST pidl = _GetFullIDList(htiRoot);
    if (pidl)
    {
        IStream* pstm = GetOrderStream(pidl, STGM_WRITE | STGM_CREATE);
        if (pstm)
        {
            if (_CacheShellFolder(htiRoot))
            {
#ifdef DEBUG
                for (int i=0; i<DPA_GetPtrCount(_hdpaOrd); i++)
                {
                    PORDERITEM poi = (PORDERITEM)DPA_GetPtr(_hdpaOrd, i);
                    if (poi)
                    {
                        ASSERTMSG(poi->nOrder >= 0, "nsc saving bogus order list nOrder (%d), get reljai", poi->nOrder);
                    }
                }
#endif
                OrderList_SaveToStream(pstm, _hdpaOrd, _psfCache);
                pstm->Release();
                
                // Notify everyone that the order changed
                SHSendChangeMenuNotify(this, SHCNEE_ORDERCHANGED, SHCNF_FLUSH, _pidlRoot);
                _dwOrderSig++;

                TraceMsg(TF_NSC, "NSCBand: Sent SHCNE_EXTENDED_EVENT : SHCNEE_ORDERCHANGED");
                
                // Remove this notify message immediately (so _fDropping is set
                // and we'll ignore this event in above OnChange method)
                //
                // _FlushNotifyMessages(_hwndTree);
            }
            else
                pstm->Release();
        }
        ILFree(pidl);
    }
    
    DPA_Destroy(_hdpaOrd);
    _hdpaOrd = NULL;
}

//removes any order the user has set and goes back to alphabetical sort
HRESULT CNscTree::ResetSort(void)
{
    return S_OK;
}

void CNscTree::MoveItemUpOrDown(BOOL fUp)
{
    HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);
    HTREEITEM htiToSwap = (fUp) ? TreeView_GetPrevSibling(_hwndTree, htiSelected) : 
                        TreeView_GetNextSibling(_hwndTree, htiSelected);
    HTREEITEM htiParent = TreeView_GetParent(_hwndTree, htiSelected);
    if (htiParent == NULL)
        htiParent = TVI_ROOT;
    ASSERT(htiSelected);
    
    _fWeChangedOrder = TRUE;
    if (FAILED(_PopulateOrderList(htiParent)))
        return;
    
    if (htiSelected && htiToSwap)
    {
        PORDERITEM poiSelected = _GetTreeOrderItem(htiSelected);
        PORDERITEM poiToSwap   = _GetTreeOrderItem(htiToSwap);
    
        if (poiSelected && poiToSwap)
        {
            int iOrder = poiSelected->nOrder;
            poiSelected->nOrder = poiToSwap->nOrder;
            poiToSwap->nOrder   = iOrder;
        }
        
        _CacheShellFolder(htiParent);
        
        if (_psfCache)
            _Sort(htiParent, _psfCache);
    }
    TreeView_SelectItem(_hwndTree, htiSelected);
    
    _FreeOrderList(htiParent);
    _fWeChangedOrder = FALSE;
}

BOOL CNscTree::_OnItemExpandingMsg(NM_TREEVIEW *pnm)
{
    HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    
    BOOL bRet = _OnItemExpanding(pnm->itemNew.hItem, pnm->action, 
        (pnm->itemNew.state & TVIS_EXPANDEDONCE), (pnm->itemNew.state & TVIS_EXPANDPARTIAL));

    SetCursor(hCursorOld);

    return bRet;
}

//
//  The NSC item is expandable if it is a regular folder and it's not one
//  of those funky non-expandable channel folders.
//
BOOL CNscTree::_IsExpandable(HTREEITEM hti)
{
    BOOL fExpandable = FALSE;
    LPCITEMIDLIST pidlItem = _CacheParentShellFolder(hti, NULL);
    if (pidlItem)
    {
        // make sure item is actually a folder and not a non-expandable channel folder
        // except: in org favs, never expand channel folders
        LPITEMIDLIST pidlTarget = NULL;
        DWORD dwAttr = SHGetAttributes(_psfCache, pidlItem, SFGAO_FOLDER);
        if (dwAttr &&
            !(SUCCEEDED(SHGetNavigateTarget(_psfCache, pidlItem, &pidlTarget, &dwAttr)) &&
                  ((_mode & MODE_CONTROL) ? TRUE : !IsExpandableChannelFolder(_psfCache, pidlItem))))
        {
            fExpandable = TRUE;
        }
        ILFree(pidlTarget);
    }
    return fExpandable;
}

BOOL CNscTree::_OnItemExpanding(HTREEITEM htiToActivate, UINT action, BOOL fExpandedOnce, BOOL fIsExpandPartial)
{
    BOOL fReturn = FALSE; // false means let treeview proceed
    if (action != TVE_EXPAND)
    {
        htiToActivate = TreeView_GetParent(_hwndTree, htiToActivate);
    }
    else if (fExpandedOnce && !fIsExpandPartial)
    {
        // Do nothing
    }
    else
    {
        if (_IsExpandable(htiToActivate))
        {
            LPITEMIDLIST pidlParent = _GetFullIDList(htiToActivate);
            if (pidlParent)
            {
                BOOL fOrdered;
                // If we were previously partially expanded, then we need to do a full expand
                _LoadSF(htiToActivate, pidlParent, &fOrdered);
               ILFree(pidlParent);
            }
        }

        // do not remove + on downlevel because inserting items would not expand htiToActivate
        // instead we will remove the plus if nothing gets added
        if (!fIsExpandPartial && MODE_NORMAL == _mode && IsOS(OS_WHISTLERORGREATER))
        {
            // If we did not add anything we should update this item to let
            // the user know something happened.
            TreeView_SetChildren(_hwndTree, htiToActivate, NSC_CHILDREN_REMOVE);
        }

        // keep the old behavior for favorites/history/...
        if (MODE_NORMAL == _mode)
        {
            // cannot let treeview proceed with expansion, nothing will be added
            // until background thread is done enumerating
            fReturn = TRUE; 
        }
    }
    
    _UpdateActiveBorder(htiToActivate);
    return fReturn; 
}

HTREEITEM CNscTree::_FindFromRoot(HTREEITEM htiRoot, LPCITEMIDLIST pidl)
{
    HTREEITEM    htiRet = NULL;
    LPITEMIDLIST pidlParent, pidlChild;
    BOOL         fFreePidlParent = FALSE;
#ifdef DEBUG
    TracePIDLAbs(pidl, TEXT("Finding this pidl"));
    TraceHTREE(htiRoot, TEXT("from this root"));
#endif
    
    if (!htiRoot) 
    {
        // When in "Normal" mode, we need to use the first child, not the root
        // in order to calculate, because there is no "Invisible" root. On the
        // other hand, History and Favorites have an invisible root: Their
        // parent folder, so they need this fudge.
        htiRoot = (MODE_NORMAL == _mode) ? TreeView_GetChild(_hwndTree, 0) : TVI_ROOT;
        pidlParent = _pidlRoot;    // the invisible root.
    }
    else 
    {
        pidlParent = _GetFullIDList(htiRoot);
        fFreePidlParent = TRUE;
    }
    
    if (pidlParent == NULL)
        return NULL;
    
    if (ILIsEqual(pidlParent, pidl)) 
    {
        if (fFreePidlParent)
            ILFree(pidlParent);
        return htiRoot;
    }
    
    pidlChild = ILFindChild(pidlParent, pidl);
    if (pidlChild == NULL) 
    {
        if (fFreePidlParent)
            ILFree(pidlParent);
        return NULL;    // not root match, no hti
    }
    
    // root match, carry on . . .
    
    // Are we rooted under the Desktop (i.e. Empty pidl or ILIsEmpty(_pidlRoot))
    IShellFolder *psf = NULL;
    HRESULT hr = IEBindToObject(pidlParent, &psf);

    if (FAILED(hr))
    {
        if (fFreePidlParent)
            ILFree(pidlParent);
        return htiRet;
    }
    
    while (htiRoot && psf)
    {
        LPITEMIDLIST pidlItem = ILCloneFirst(pidlChild);
        if (!pidlItem)
            break;
        
        htiRoot = _FindChild(psf, htiRoot, pidlItem);
        IShellFolder *psfNext = NULL;
        hr = psf->BindToObject(pidlItem, NULL, IID_PPV_ARG(IShellFolder, &psfNext));
        ILFree(pidlItem);
        if (!htiRoot)
        {
            ATOMICRELEASE(psfNext);
            break;
        }
        psf->Release();
        psf = psfNext;
        pidlChild = _ILNext(pidlChild);
        // if we're down to an empty pidl, we've found it!
        if (ILIsEmpty(pidlChild)) 
        {
            htiRet = htiRoot;
            break;
        }
        if (FAILED(hr))
        {
            ASSERT(psfNext == NULL);
            break;
        }
    }
    if (psf) 
        psf->Release();
    if (fFreePidlParent)
        ILFree(pidlParent);
#ifdef DEBUG
    TraceHTREE(htiRet, TEXT("Found at"));
#endif

    return htiRet;
}

BOOL CNscTree::_FIsItem(IShellFolder *psf, LPCITEMIDLIST pidl, HTREEITEM hti)
{
    PORDERITEM poi = _GetTreeOrderItem(hti);
    return poi && poi->pidl && 0 == ShortFromResult(psf->CompareIDs(0, poi->pidl, pidl));
}

HRESULT CNscTree::_OnSHNotifyDelete(LPCITEMIDLIST pidl, int *piPosDeleted, HTREEITEM *phtiParent)
{
    HRESULT hr = S_FALSE;
    HTREEITEM hti = _FindFromRoot(NULL, pidl);
    
    if (hti == TVI_ROOT)
        return E_INVALIDARG;        // invalid arg, DELETION OF TVI_ROOT
    // need to clear _pidlDrag if the one being deleted is _pidlDrag.
    // handles case where dragging into another folder from within or dragging out.
    if (_pidlDrag)
    {
        LPCITEMIDLIST pidltst = _CacheParentShellFolder(hti, NULL);
        if (pidltst)
        {
            if (0 == ShortFromResult(_psfCache->CompareIDs(0, pidltst, _pidlDrag)))
                _pidlDrag = NULL;
        }
    }

    if (pidl && (hti != NULL))
    {
        _fIgnoreNextItemExpanding = TRUE;

        HTREEITEM htiParent = TreeView_GetParent(_hwndTree, hti);
        
        if (phtiParent)
            *phtiParent = htiParent;

        //if caller wants the position of the deleted item, don't reorder the other items
        if (piPosDeleted)
        {
            PORDERITEM poi = _GetTreeOrderItem(hti);
            if (poi)
            {
                *piPosDeleted = poi->nOrder;
                hr = S_OK;
            }
            TreeView_DeleteItem(_hwndTree, hti);
        }
        else
        {
            if (htiParent == NULL)
                htiParent = TVI_ROOT;
            if (TreeView_DeleteItem(_hwndTree, hti))
            {
                _ReorderChildren(htiParent);
                hr = S_OK;
            }
        }

        _fIgnoreNextItemExpanding = FALSE;

        if (hti == _htiCut)
        {
            _htiCut = NULL;
            _TreeNukeCutState();
        }
    }
    return hr;
}

BOOL CNscTree::_IsItemNameInTree(LPCITEMIDLIST pidl)
{
    BOOL fReturn = FALSE;
    HTREEITEM hti = _FindFromRoot(NULL, pidl);
    if (hti)
    {
        WCHAR szTree[MAX_PATH];
        TV_ITEM tvi;
        
        tvi.mask       = TVIF_TEXT;
        tvi.hItem      = hti;
        tvi.pszText    = szTree;
        tvi.cchTextMax = ARRAYSIZE(szTree);
        if (TreeView_GetItem(_hwndTree, &tvi))
        {
            IShellFolder* psf;
            LPCITEMIDLIST pidlChild;
            if (SUCCEEDED(_ParentFromItem(pidl, &psf, &pidlChild)))
            {
                WCHAR szName[MAX_PATH];
                if (SUCCEEDED(DisplayNameOf(psf, pidlChild, SHGDN_INFOLDER, szName, ARRAYSIZE(szName))))
                {
                    fReturn = (StrCmp(szName, szTree) == 0);
                }
                psf->Release();
            }
        }
    }

    return fReturn;
}
//
//  Attempt to perform a rename-in-place.  Returns
//
//  S_OK - rename succeeded
//  S_FALSE - original object not found
//  error - rename failed
//

HRESULT CNscTree::_OnSHNotifyRename(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlNew)
{
    HTREEITEM hti, htiParent = NULL;
    HRESULT hr = S_FALSE;

    //
    //  If the source and destination belong to the same folder, then
    //  it's an in-folder rename.
    //
    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    LPITEMIDLIST pidlNewParent = ILCloneParent(pidlNew);

    if (pidlParent && pidlNewParent && IEILIsEqual(pidlParent, pidlNewParent, TRUE) && (hti = _FindFromRoot(NULL, pidl)))
    {
        // to avoid reentering problems
        if (!_IsItemNameInTree(pidlNew))
        {
            HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);

            ::SendMessage(_hwndTree, WM_SETREDRAW, FALSE, 0);
            if ((_OnSHNotifyDelete(pidl, NULL, &htiParent) != E_INVALIDARG)   // invalid arg indication of bogus rename, do not continue.
                && (_OnSHNotifyCreate(pidlNew, DEFAULTORDERPOSITION, htiParent) == S_OK))
            {
                if (hti == htiSelected)
                {
                    hti = _FindFromRoot(NULL, pidlNew);
                    _SelectNoExpand(_hwndTree, hti); // do not expand this guy
                }
                // NTRAID 89444: If we renamed the item the user is sitting on,
                // SHBrowseForFolder doesn't realize it and doesn't update the
                // edit control.

                hr = S_OK;
            }
            ::SendMessage(_hwndTree, WM_SETREDRAW, TRUE, 0);
        }
    }
    // rename can be a move, so do not depend on the delete happening successfully.
    else if ((_OnSHNotifyDelete(pidl, NULL, &htiParent) != E_INVALIDARG)   // invalid arg indication of bogus rename, do not continue.
        && (_OnSHNotifyCreate(pidlNew, DEFAULTORDERPOSITION, htiParent) == S_OK))
    {
        hr = S_OK;
    }

    ILFree(pidlParent);
    ILFree(pidlNewParent);

    // if user created a new folder and changed the default name but is still in edit mode in defview
    // and then clicked on the + of the parent folder we start enumerating the folder (or stealing items
    // from defview) before defview had time to change the name of the new folder.  The result is
    // we enumerate the old name and before we transfer it to the foreground thread shell change notify rename
    // kicks in and we change the item already in the tree.  We then merge the items from the enumeration
    // which results in extra folder with the old name.
    // to avoid this we force the reenumeration...
    _dwOrderSig++;

    return hr;
    
}

//
//  To update an item, just find it and invalidate it.
//
void CNscTree::_OnSHNotifyUpdateItem(LPCITEMIDLIST pidl, LPITEMIDLIST pidlReal)
{
    HTREEITEM hti = _FindFromRoot(NULL, pidl);
    if (hti)
    {
        _TreeInvalidateItemInfo(hti, TVIF_TEXT);

        if (pidlReal && hti != TVI_ROOT)
        {
            PORDERITEM poi = _GetTreeOrderItem(hti);
            _AssignPidl(poi, pidlReal);
        }
    }
}

LPITEMIDLIST CNscTree::_FindHighestDeadItem(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlRet    = NULL;
    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    if (pidlParent)
    {
        IShellFolder* psf;
        LPCITEMIDLIST pidlChild;
        if (SUCCEEDED(_ParentFromItem(pidlParent, &psf, &pidlChild)))
        {
            DWORD dwAttrib = SFGAO_VALIDATE;
            if (FAILED(psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlChild, &dwAttrib)))
            {
                pidlRet = _FindHighestDeadItem(pidlParent);
            }

            psf->Release();
        }
        ILFree(pidlParent);
    }
    return pidlRet ? pidlRet : ILClone(pidl);
}

void CNscTree::_RemoveDeadBranch(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlTop = _FindHighestDeadItem(pidl);
    if (pidlTop)
    {
        HTREEITEM hti = _FindFromRoot(NULL, pidlTop);
        if (hti)
        {
            if (!TreeView_DeleteItem(_hwndTree, hti))
            {
                ASSERTMSG(FALSE, "CNscTree::_RemoveDeadBranch: DeleteItem failed in tree control");       // somethings hosed in the tree.
            }
        }
        ILFree(pidlTop);
    }
}

HRESULT CNscTree::_OnSHNotifyUpdateDir(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_FALSE;
    HTREEITEM hti = _FindFromRoot(NULL, pidl);
    if (hti)
    {   // folder exists in tree refresh folder now if had been loaded by expansion.
        IShellFolder* psf = NULL;
        LPCITEMIDLIST pidlChild;
        if (SUCCEEDED(_ParentFromItem(pidl, &psf, &pidlChild)))
        {
            LPITEMIDLIST pidlReal;
            DWORD dwAttrib = SFGAO_VALIDATE;
            //  pidlChild is read-only, so we start
            //  off our double validation with getting the "real"
            //  pidl which will fall back to a clone 
            if (SUCCEEDED(_IdlRealFromIdlSimple(psf, pidlChild, &pidlReal))
            &&  SUCCEEDED(psf->GetAttributesOf(1, (LPCITEMIDLIST *)&pidlReal, &dwAttrib)))
            {
                TV_ITEM tvi;
                tvi.mask = TVIF_STATE;
                tvi.stateMask = (TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
                tvi.hItem = (HTREEITEM)hti;
                if (hti != TVI_ROOT)
                {
                    if (!TreeView_GetItem(_hwndTree, &tvi))
                        tvi.state = 0;
                }

                if (hti == TVI_ROOT || tvi.state & TVIS_EXPANDEDONCE)
                {
                    hr = _UpdateDir(hti, TRUE);
                }
                else if (!(tvi.state & TVIS_EXPANDEDONCE))
                {
                    TreeView_SetChildren(_hwndTree, hti, NSC_CHILDREN_CALLBACK);
                }

                if (hti != TVI_ROOT)
                {
                    PORDERITEM poi = _GetTreeOrderItem(hti);
                    _AssignPidl(poi, pidlReal);
                }

                ILFree(pidlReal);
            }
            else
            {
                _RemoveDeadBranch(pidl);
            }

            psf->Release();
        }
    }
    return hr;
}

HRESULT CNscTree::_GetEnumFlags(IShellFolder *psf, LPCITEMIDLIST pidlFolder, DWORD *pgrfFlags, HWND *phwnd)
{
    HWND hwnd = NULL;
    DWORD grfFlags = _grfFlags;

    if (_pFilter)
    {
        LPITEMIDLIST pidlFree = NULL;
        if (pidlFolder == NULL)
        {
            SHGetIDListFromUnk(psf, &pidlFree);
            pidlFolder = pidlFree;
        }
        _pFilter->GetEnumFlags(psf, pidlFolder, &hwnd, &grfFlags);

        ILFree(pidlFree);
    }
    *pgrfFlags = grfFlags;
    
    if (phwnd)
        *phwnd = hwnd;
    
    return S_OK;
}

HRESULT CNscTree::_GetEnum(IShellFolder *psf, LPCITEMIDLIST pidlFolder, IEnumIDList **ppenum)
{
    HWND hwnd = NULL;
    DWORD grfFlags;

    _GetEnumFlags(psf, pidlFolder, &grfFlags, &hwnd);

    // get the enumerator and add the child items for any given pidl
    // REARCHITECT: right now, we don't detect if we actually are dealing with a folder (shell32.dll
    // allows you to create an IShellfolder to a non folder object, so we get bad
    // dialogs, by not passing the hwnd, we don't get the dialogs. we should fix this better. by caching
    // in the tree whether it is a folder or not.
    return psf->EnumObjects(/* _fAutoExpanding ?*/ hwnd, grfFlags, ppenum);
}

BOOL CNscTree::_ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem)
{
    BOOL bRet = TRUE;
    if (_pFilter)
    {
        LPITEMIDLIST pidlFree = NULL;
        if (pidlFolder == NULL)
        {
            SHGetIDListFromUnk(psf, &pidlFree);
            pidlFolder = pidlFree;
        }
        bRet = (S_OK == _pFilter->ShouldShow(psf, pidlFolder, pidlItem));

        if (pidlFree)
            ILFree(pidlFree);
    }
    return bRet;
}

// updates existing dir only.  Not new load.
HRESULT CNscTree::_UpdateDir(HTREEITEM hti, BOOL fUpdatePidls)
{
    HRESULT hr = S_FALSE;
    LPITEMIDLIST pidlParent = _GetFullIDList(hti);
    if (pidlParent)
    {
        BOOL fOrdered;
        _fUpdate = TRUE;
        hr = _StartBackgroundEnum(hti, pidlParent, &fOrdered, fUpdatePidls);
        _fUpdate = FALSE;
        ILFree(pidlParent);
    }
    return hr;
}

int CNscTree::_TreeItemIndexInHDPA(HDPA hdpa, IShellFolder *psfParent, HTREEITEM hti, int iReverseStart)
{
    int iIndex = -1;
    
    ASSERT(hti);

    PORDERITEM poi = _GetTreeOrderItem(hti);
    if (poi)
    {
        int celt = DPA_GetPtrCount(hdpa);
        ASSERT(iReverseStart <= celt && iReverseStart >= 0);
        for (int i = iReverseStart-1; i >= 0; i--)
        {
            PORDERITEM poi2 = (PORDERITEM)DPA_GetPtr(hdpa, i);
            if (poi2)
            {
                if (ShortFromResult(_psfCache->CompareIDs(0, poi->pidl, poi2->pidl)) == 0)
                {
                    iIndex = i;
                    break;
                }
            }
        }
    }
    return iIndex;
}

HRESULT CNscTree::_Expand(LPCITEMIDLIST pidl, int iDepth)
{
    HRESULT hr = E_FAIL;
    HTREEITEM hti = _ExpandToItem(pidl);
    if (hti)
    {
        hr = _ExpandNode(hti, TVE_EXPAND, iDepth);
        // tvi_root is not a pointer and treeview doesn't check for special
        // values so don't select root to prevent fault
        if (hti != TVI_ROOT)
            _SelectNoExpand(_hwndTree, hti);
    }

    return hr;
}

HRESULT CNscTree::_ExpandNode(HTREEITEM htiParent, int iCode, int iDepth)
{
    // nothing to expand
    if (!iDepth)
        return S_OK;

    _fInExpand = TRUE;
    _uDepth = (UINT)iDepth-1;
    HRESULT hr = TreeView_Expand(_hwndTree, htiParent, iCode) ? S_OK : E_FAIL;
    _uDepth = 0;
    _fInExpand = FALSE;

    return hr;
}

HTREEITEM CNscTree::_FindChild(IShellFolder *psf, HTREEITEM htiParent, LPCITEMIDLIST pidlChild)
{
    HTREEITEM hti;
    for (hti = TreeView_GetChild(_hwndTree, htiParent); hti; hti = TreeView_GetNextSibling(_hwndTree, hti))
    {
        if (_FIsItem(psf, pidlChild, hti))
            break;
    }
    return hti;
}

void CNscTree::_ReorderChildren(HTREEITEM htiParent)
{
    int i = 0;
    HTREEITEM hti;
    for (hti = TreeView_GetChild(_hwndTree, htiParent); hti; hti = TreeView_GetNextSibling(_hwndTree, hti))
    {
        PORDERITEM poi = _GetTreeOrderItem(hti);
        if (poi)
        {
            poi->nOrder = i++;        // reset the positions of the nodes.
        }
    }
}


HRESULT CNscTree::_InsertChild(HTREEITEM htiParent, IShellFolder *psfParent, LPCITEMIDLIST pidlChild, 
                               BOOL fExpand, BOOL fSimpleToRealIDL, int iPosition, HTREEITEM *phti)
{
    LPITEMIDLIST pidlReal;
    HRESULT hr;
    HTREEITEM   htiNew = NULL;
    
    if (fSimpleToRealIDL)
    {
        hr = _IdlRealFromIdlSimple(psfParent, pidlChild, &pidlReal);
    }
    else
    {
        hr = SHILClone(pidlChild, &pidlReal);
    }

    // review chrisny:  no sort here, use compareitems to insert item instead.
    if (SUCCEEDED(hr))
    {
        HTREEITEM htiAfter = TVI_LAST;
        BOOL fOrdered = _IsOrdered(htiParent);
        if (iPosition != DEFAULTORDERPOSITION || !fOrdered)
        {
            if (iPosition == 0)
                htiAfter = TVI_FIRST;
            else
            {
                if (!fOrdered)
                    htiAfter = TVI_FIRST;
                
                for (HTREEITEM hti = TreeView_GetChild(_hwndTree, htiParent); hti; hti = TreeView_GetNextSibling(_hwndTree, hti))
                {
                    PORDERITEM poi = _GetTreeOrderItem(hti);
                    if (poi)
                    {
                        if (fOrdered)
                        {
                            if (poi->nOrder == iPosition-1)
                            {
                                htiAfter = hti;
#ifdef DEBUG
                                TraceHTREE(htiAfter, TEXT("Inserting After"));
#endif
                                break;
                            }
                        }
                        else
                        {
                            if (ShortFromResult(_CompareIDs(psfParent, pidlReal, poi->pidl)) > 0)
                                htiAfter = hti;
                            else
                                break;
                        }
                    }
                }
            }
        }

        if ((_FindChild(psfParent, htiParent, pidlReal) == NULL))
        {
            int cChildren = 1;
            if (MODE_NORMAL == _mode)
            {
                DWORD dwAttrib = SFGAO_FOLDER | SFGAO_STREAM;
                hr = psfParent->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlReal, &dwAttrib);
                if (SUCCEEDED(hr))
                    cChildren = _GetChildren(psfParent, pidlReal, dwAttrib);
            }

            if (SUCCEEDED(hr))
            {
                htiNew = _AddItemToTree(htiParent, pidlReal, cChildren, iPosition, htiAfter, TRUE, _IsMarked(htiParent));
                if (htiNew)
                {
                    _ReorderChildren(htiParent);

                    if (fExpand) 
                        _ExpandNode(htiParent, TVE_EXPAND, 1);    // force expansion to show new item.

                    //ensure the item is visible after a rename (or external drop, but that should always be a noop)
                    if (iPosition != DEFAULTORDERPOSITION)
                        TreeView_EnsureVisible(_hwndTree, htiNew);

                    hr = S_OK;
                }
                else
                {
                    hr = S_FALSE;
                }
            }
        }
        ILFree(pidlReal);
    }
    
    if (phti)
        *phti = htiNew;
    
    return hr;
}


HRESULT CheckForExpandOnce(HWND hwndTree, HTREEITEM hti)
{
    // Root node always expanded.
    if (hti == TVI_ROOT)
        return S_OK;
    
    TV_ITEM tvi;
    tvi.mask = TVIF_STATE | TVIF_CHILDREN;
    tvi.stateMask = (TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
    tvi.hItem = (HTREEITEM)hti;
    
    if (TreeView_GetItem(hwndTree, &tvi))
    {
        if (!(tvi.state & TVIS_EXPANDEDONCE) && (tvi.cChildren == 0))
        {
            TreeView_SetChildren(hwndTree, hti, NSC_CHILDREN_FORCE);
        }
    }
    
    return S_OK;
}


HRESULT _InvokeCommandThunk(IContextMenu * pcm, HWND hwndParent)
{
    CMINVOKECOMMANDINFOEX ici = {0};

    ici.cbSize = sizeof(ici);
    ici.hwnd = hwndParent;
    ici.nShow = SW_NORMAL;
    ici.lpVerb = CMDSTR_NEWFOLDERA;
    ici.fMask = CMIC_MASK_UNICODE | CMIC_MASK_FLAG_NO_UI;
    ici.lpVerbW = CMDSTR_NEWFOLDERW;

    return pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)(&ici));
}

BOOL CNscTree::_IsItemExpanded(HTREEITEM hti)
{
    // if it's not open, then use it's parent
    TV_ITEM tvi;
    tvi.mask = TVIF_STATE;
    tvi.stateMask = TVIS_EXPANDED;
    tvi.hItem = (HTREEITEM)hti;
    
    return (TreeView_GetItem(_hwndTree, &tvi) && (tvi.state & TVIS_EXPANDED));
}

HRESULT CNscTree::CreateNewFolder(HTREEITEM hti)
{
    HRESULT hr = E_FAIL;

    if (hti)
    {
        // If the user selected a folder item (file), we need
        // to bind set the cache to the parent folder.
        LPITEMIDLIST pidl = _GetFullIDList(hti);
        if (pidl)
        {
            ULONG ulAttr = SFGAO_FOLDER;    // make sure item is actually a folder
            if (SUCCEEDED(IEGetAttributesOf(pidl, &ulAttr)))
            {
                HTREEITEM htiTarget;   // tree item in which new folder is created
                
                // Is it a folder?
                if (ulAttr & SFGAO_FOLDER)
                {
                    // non-Normal modes (!MODE_NORMAL) wants the new folder to be created as
                    // a sibling instead of as a child of the selected folder if it's
                    // closed.  I assume their reasoning is that closed folders are often
                    // selected by accident/default because these views are mostly 1 level.
                    // We don't want this functionality for the normal mode.
                    if ((MODE_NORMAL != _mode) && !_IsItemExpanded(hti))
                    {
                        htiTarget = TreeView_GetParent(_hwndTree, hti);  // yes, so fine.
                    }
                    else
                    {
                        htiTarget = hti;
                    }
                }
                else
                {
                    htiTarget = TreeView_GetParent(_hwndTree, hti); // No, so bind to the parent.
                }

                if (NULL == htiTarget)
                {
                    htiTarget = TVI_ROOT;  // should be synonymous
                }
                
                // ensure that this pidl has MenuOrder information (see IE55 #94868)
                if (!_IsOrdered(htiTarget) && _mode != MODE_NORMAL)
                {
                    // its not "ordered" (doesn't have reg key persisting order of folder)
                    //   then create make it ordered
                    if (SUCCEEDED(_PopulateOrderList(htiTarget)))
                    {
                        ASSERT(_hdpaOrd);
                        
                        _FreeOrderList(htiTarget);
                    }
                }

                _CacheShellFolder(htiTarget);
            }

            ILFree(pidl);
        }
    }

    // If no item is selected, we should still create a folder in whatever
    // the user most recently dinked with.  This is important if the
    // Favorites folder is completely empty.

    if (_psfCache)
    {
        IContextMenu *pcm;
        hr = CoCreateInstance(CLSID_NewMenu, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IContextMenu, &pcm));        
        if (SUCCEEDED(hr))
        {
            HMENU hmContext = CreatePopupMenu();
            hr = pcm->QueryContextMenu(hmContext, 0, 1, 256, 0);
            if (SUCCEEDED(hr))
            {
                _pidlNewFolderParent = _GetFullIDList(_htiCache);

                IShellExtInit *psei;
                if (SUCCEEDED(pcm->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei))))
                {
                    psei->Initialize(_pidlNewFolderParent, NULL, NULL);
                    psei->Release();
                }
                hr = _InvokeCommandThunk(pcm, _hwndParent);
                SHChangeNotifyHandleEvents(); // Flush the events to it doesn't take forever to shift into edit mode
                Pidl_Set(&_pidlNewFolderParent, NULL);
            }

            IUnknown_SetSite(pcm, NULL);
            DestroyMenu(hmContext);
            pcm->Release();
        }
    }

    return hr;
}


HRESULT CNscTree::_EnterNewFolderEditMode(LPCITEMIDLIST pidlNewFolder)
{
    HTREEITEM htiNewFolder = _FindFromRoot(NULL, pidlNewFolder);
    LPITEMIDLIST pidlParent = NULL;
    
    // 1. Flush all the notifications.
    // 2. Find the new dir in the tree.
    //    Expand the parent if needed.
    // 3. Put it into the rename mode.     
    SetSelectedItem(pidlNewFolder, FALSE, FALSE, 0);

    if (htiNewFolder == NULL) 
    {
        pidlParent = ILClone(pidlNewFolder);
        ILRemoveLastID(pidlParent);
        HTREEITEM htiParent = _FindFromRoot(NULL, pidlParent);

        // We are looking for the parent folder. If this is NOT
        // the root, then we need to expand it to show it.

        // NOTE: If it is root, Tree view will
        // try and deref TVI_ROOT and faults.
        if (htiParent != TVI_ROOT)
        {
            // Try expanding the parent and finding again.
            CheckForExpandOnce(_hwndTree, htiParent);
            TreeView_SelectItem(_hwndTree, htiParent);
            _ExpandNode(htiParent, TVE_EXPAND, 1);
        }
        
        htiNewFolder = _FindFromRoot(NULL, pidlNewFolder);
    }

    if (htiNewFolder == NULL) 
    {
        // Something went very wrong here. We are not able to find newly added node.
        // One last try after refreshing the entire tree. (slow)
        // May be we didn't get notification.
        Refresh();

        htiNewFolder = _FindFromRoot(NULL, pidlNewFolder);
        if (htiNewFolder && (htiNewFolder != TVI_ROOT))
        {
            HTREEITEM htiParent = _FindFromRoot(NULL, pidlParent);

            // We are looking for the parent folder. If this is NOT
            // the root, then we need to expand it to show it.

            // NOTE: If it is root, Tree view will
            // try and deref TVI_ROOT and faults.
            if (htiParent != TVI_ROOT)
            {
                CheckForExpandOnce(_hwndTree, htiParent);
                TreeView_SelectItem(_hwndTree, htiParent);
                _ExpandNode(htiParent, TVE_EXPAND, 1);
            }
        }

        htiNewFolder = _FindFromRoot(NULL, pidlNewFolder);
    }

    // Put Edit label on the item for possible renaming by user.
    if (htiNewFolder) 
    {
        _fOkToRename = TRUE;  //otherwise label editing is canceled
        TreeView_EditLabel(_hwndTree, htiNewFolder);
        _fOkToRename = FALSE;
    }

    if (pidlParent)
        ILFree(pidlParent);

    return S_OK;
}


HRESULT CNscTree::_OnSHNotifyCreate(LPCITEMIDLIST pidl, int iPosition, HTREEITEM htiParent)
{
    HRESULT hr = S_OK;
    HTREEITEM hti = NULL;
    
    if (ILIsParent(_pidlRoot, pidl, FALSE))
    {
        LPITEMIDLIST pidlParent = ILCloneParent(pidl);
        if (pidlParent)
        {
            hti = _FindFromRoot(NULL, pidlParent);
            ILFree(pidlParent);
        }

        if (hti)
        {   
            // folder exists in tree, if item expanded, load the node, else bag out.
            if (_mode != MODE_NORMAL)
            {
                TV_ITEM tvi;
                if (hti != TVI_ROOT)
                {
                    tvi.mask = TVIF_STATE | TVIF_CHILDREN;
                    tvi.stateMask = (TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
                    tvi.hItem = (HTREEITEM)hti;
                
                    if (!TreeView_GetItem(_hwndTree, &tvi))
                        return hr;
                
                    // If we drag and item over to a node which has never beem expanded
                    // before we will always fail to add the new node.
                    if (!(tvi.state & TVIS_EXPANDEDONCE)) 
                    {
                        CheckForExpandOnce(_hwndTree, hti);
                    
                        tvi.mask = TVIF_STATE;
                        tvi.stateMask = (TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
                        tvi.hItem = (HTREEITEM)hti;

                        // We need to reset this. This is causing some weird behaviour during drag and drop.
                        _fAsyncDrop = FALSE;
                    
                        if (!TreeView_GetItem(_hwndTree, &tvi))
                            return hr;
                    }
                }
                else
                    tvi.state = (TVIS_EXPANDEDONCE);    // evil root is always expanded.
            
                if (tvi.state & TVIS_EXPANDEDONCE)
                {
                    LPCITEMIDLIST   pidlChild;
                    IShellFolder    *psf;
                    hr = _ParentFromItem(pidl, &psf, &pidlChild);
                    if (SUCCEEDED(hr))
                    {
                        if (_fAsyncDrop)    // inserted via drag/drop
                        {
                            int iNewPos =   _fInsertBefore ? (_iDragDest - 1) : _iDragDest;
                            LPITEMIDLIST pidlReal;
                            if (SUCCEEDED(_IdlRealFromIdlSimple(psf, pidlChild, &pidlReal)))
                            {
                                if (_MoveNode(_iDragSrc, iNewPos, pidlReal))
                                {
                                    TraceMsg(TF_NSC, "NSCBand:  Reordering Item");
                                    _fDropping = TRUE;
                                    _Dropped();
                                    _fAsyncDrop = FALSE;
                                    _fDropping = FALSE;
                                }
                                ILFree(pidlReal);
                            }
                            _htiCur = NULL;
                            _fDragging = _fInserting = _fDropping = FALSE;
                            _iDragDest = _iDragSrc = -1;
                        }
                        else   // standard shell notify create or drop with no insert, rename.
                        {
                            if (SUCCEEDED(hr))
                            {
                                if (_iDragDest >= 0)
                                    iPosition = _iDragDest;
                                hr = _InsertChild(hti, psf, pidlChild, BOOLIFY(tvi.state & TVIS_SELECTED), TRUE, iPosition, NULL);
                                if (_iDragDest >= 0 &&
                                    SUCCEEDED(_PopulateOrderList(hti)))
                                {
                                    _fDropping = TRUE;
                                    _Dropped();
                                    _fDropping = FALSE;
                                }
                            }
                        }
                        psf->Release();
                    }
                }
            }
            else    // MODE_NORMAL
            {
                // no need to do anything, this item hasn't been expanded yet
                if (TreeView_GetItemState(_hwndTree, hti, TVIS_EXPANDEDONCE) & TVIS_EXPANDEDONCE)
                {
                    LPCITEMIDLIST   pidlChild;
                    IShellFolder    *psf;
                    if (SUCCEEDED(_ParentFromItem(pidl, &psf, &pidlChild)))
                    {
                        LPITEMIDLIST pidlReal;
                        if (SUCCEEDED(_IdlRealFromIdlSimple(psf, pidlChild, &pidlReal)))
                        {
                            do // scope
                            {
                                DWORD dwEnumFlags;
                                _GetEnumFlags(psf, pidlChild, &dwEnumFlags, NULL);

                                DWORD dwAttributes = SHGetAttributes(psf, pidlReal, SFGAO_FOLDER | SFGAO_HIDDEN | SFGAO_STREAM);
                                // filter out zip files (they are both folders and files but we treat them as files)
                                // on downlevel SFGAO_STREAM is the same as SFGAO_HASSTORAGE so we'll let zip files slide through (oh well)
                                // better than not adding filesystem folders (that have storage)
                                DWORD dwFlags = SFGAO_FOLDER | SFGAO_STREAM;
                                if ((dwAttributes & dwFlags) == SFGAO_FOLDER)
                                {
                                    if (!(dwEnumFlags & SHCONTF_FOLDERS))
                                        break;   // item is folder but client does not want folders
                                }
                                else if (!(dwEnumFlags & SHCONTF_NONFOLDERS))
                                    break;   // item is file, but client only wants folders

                                if (!(dwEnumFlags & SHCONTF_INCLUDEHIDDEN) &&
                                     (dwAttributes & SFGAO_HIDDEN))
                                     break;

                                hr = _InsertChild(hti, psf, pidlReal, FALSE, TRUE, iPosition, NULL);
                                if (S_OK == hr)
                                {
                                    TreeView_SetChildren(_hwndTree, hti, NSC_CHILDREN_ADD);
                                }
                            } while (0); // Execute the block only once

                            ILFree(pidlReal);
                        }
                        psf->Release();
                    }
                }
                else
                {
                    TreeView_SetChildren(_hwndTree, hti, NSC_CHILDREN_CALLBACK);
                }
            }
        }
    }

    //if the item is being moved from a folder and we have it's position, we need to fix up the order in the old folder
    if (_mode != MODE_NORMAL && iPosition >= 0) //htiParent && (htiParent != hti) && 
    {
        //item was deleted, need to fixup order info
        _ReorderChildren(htiParent);
    }

    _UpdateActiveBorder(_htiActiveBorder);
    return hr;
}

//FEATURE: make this void
HRESULT CNscTree::_OnDeleteItem(NM_TREEVIEW *pnm)
{
    if (_htiActiveBorder == pnm->itemOld.hItem)
        _htiActiveBorder = NULL;

    ITEMINFO *  pii = (ITEMINFO *) pnm->itemOld.lParam;
    pnm->itemOld.lParam = NULL;

    OrderItem_Free(pii->poi, TRUE);
    LocalFree(pii);
    pii = NULL;

    return S_OK;
}

void CNscTree::_GetDefaultIconIndex(LPCITEMIDLIST pidl, ULONG ulAttrs, TVITEM *pitem, BOOL fFolder)
{
    if (_iDefaultFavoriteIcon == 0)
    {
        int iTemp = 0;
        WCHAR psz[MAX_PATH];
        DWORD cchSize = ARRAYSIZE(psz);
        if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_DEFAULTICON, TEXT("InternetShortcut"), NULL, psz, &cchSize)))
            iTemp = PathParseIconLocation(psz);

        _iDefaultFavoriteIcon = Shell_GetCachedImageIndex(psz, iTemp, 0);

        cchSize = ARRAYSIZE(psz);

        if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_DEFAULTICON, TEXT("Folder"), NULL, psz, &cchSize)))
            iTemp = PathParseIconLocation(psz);

        _iDefaultFolderIcon = Shell_GetCachedImageIndex(psz, iTemp, 0);
    }

    pitem->iImage = pitem->iSelectedImage = (fFolder) ? _iDefaultFolderIcon : _iDefaultFavoriteIcon;
}

BOOL CNscTree::_LoadOrder(HTREEITEM hti, LPCITEMIDLIST pidl, IShellFolder* psf, HDPA* phdpa)
{
    BOOL fOrdered = FALSE;
    HDPA hdpaOrder = NULL;
    IStream *pstm = GetOrderStream(pidl, STGM_READ);
    if (pstm)
    {
        OrderList_LoadFromStream(pstm, &hdpaOrder, psf);
        pstm->Release();
    }

    fOrdered = !((hdpaOrder == NULL) || (DPA_GetPtrCount(hdpaOrder) == 0));

    //set the tree item's ordered flag
    PORDERITEM poi;
    if (hti == TVI_ROOT)
    {
        _fOrdered = fOrdered;
    }
    else if ((poi = _GetTreeOrderItem(hti)) != NULL)
    {
        poi->lParam = fOrdered;
    }

    *phdpa = hdpaOrder;

    return fOrdered;
}

// load shell folder and deal with persisted ordering.
HRESULT CNscTree::_LoadSF(HTREEITEM htiRoot, LPCITEMIDLIST pidl, BOOL *pfOrdered)
{
    ASSERT(pfOrdered);
#ifdef DEBUG
    TraceHTREE(htiRoot, TEXT("Loading the Shell Folder for"));
#endif
    HRESULT hr = S_OK;
    IDVGetEnum *pdvge;
    if (_pidlNavigatingTo && ILIsEqual(pidl, _pidlNavigatingTo) && SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IDVGetEnum, &pdvge))))
    {
        pdvge->Release(); // we don't need this, just checking if view supports enumeration stealing
        // If we want to expand the item that we are navigating to,
        // then let's wait for the CDefView to populate so that we
        // can go steal its contents
        _fExpandNavigateTo = TRUE;
        if (_fNavigationFinished)
        {
            _CacheShellFolder(htiRoot); // make sure we cache folder in case it is misbehaving shell extension
            LPITEMIDLIST pidlClone;
            hr = SHILClone(pidl, &pidlClone);
            if (SUCCEEDED(hr))
                hr = RightPaneNavigationFinished(pidlClone); // function takes ownership of pidl
        }
    }
    else
    {
        hr = _StartBackgroundEnum(htiRoot, pidl, pfOrdered, FALSE);
    }
    
    return hr;
}

HRESULT CNscTree::_StartBackgroundEnum(HTREEITEM htiRoot, LPCITEMIDLIST pidl, 
    BOOL *pfOrdered, BOOL fUpdatePidls)
{
    HRESULT hr = E_OUTOFMEMORY;
    if (_CacheShellFolder(htiRoot))
    {    
        HDPA hdpaOrder = NULL;
        IShellFolder *psfItem = _psfCache;

        psfItem->AddRef();  // hang on as adding items may change the cached psfCache

        *pfOrdered = _LoadOrder(htiRoot, pidl, psfItem, &hdpaOrder);
        DWORD grfFlags;
        DWORD dwSig = 0;
        _GetEnumFlags(psfItem, pidl, &grfFlags, NULL);
        if (htiRoot && htiRoot != TVI_ROOT)
        {
            ITEMINFO *pii = _GetTreeItemInfo(htiRoot);
            if (pii)
                dwSig = pii->dwSig;
        }
        else
        {
            htiRoot = TVI_ROOT;
        }

        if (_pTaskScheduler)
        {
            // AddNscEnumTask takes ownership of hdpaOrder, but not the pidls
            hr = AddNscEnumTask(_pTaskScheduler, pidl, s_NscEnumCallback, this,
                                    (UINT_PTR)htiRoot, dwSig, grfFlags, hdpaOrder, 
                                    _pidlExpandingTo, _dwOrderSig, !_fInExpand, 
                                    _uDepth, _fUpdate, fUpdatePidls);
            if (SUCCEEDED(hr) && !_fInExpand)
            {
                _fShouldShowAppStartCursor = TRUE;
            }
        }

        psfItem->Release();
    }
    return hr;
}


// s_NscEnumCallback : Callback function for the background enumration.
//           This function takes ownership of the hdpa and the pidls.
void CNscTree::s_NscEnumCallback(CNscTree *pns, LPITEMIDLIST pidl, UINT_PTR uId, DWORD dwSig, HDPA hdpa, 
                                 LPITEMIDLIST pidlExpandingTo, DWORD dwOrderSig, UINT uDepth, 
                                 BOOL fUpdate, BOOL fUpdatePidls)
{
    NSC_BKGDENUMDONEDATA * pbedd = new NSC_BKGDENUMDONEDATA;
    if (pbedd)
    {
        pbedd->pidl = pidl;
        pbedd->hitem = (HTREEITEM)uId;
        pbedd->dwSig = dwSig;
        pbedd->hdpa = hdpa;
        pbedd->pidlExpandingTo = pidlExpandingTo;
        pbedd->dwOrderSig = dwOrderSig;
        pbedd->uDepth = uDepth;
        pbedd->fUpdate = fUpdate;
        pbedd->fUpdatePidls = fUpdatePidls;

        // get the lock so that we can add the data to the end of the list
        NSC_BKGDENUMDONEDATA **ppbeddWalk = NULL;
        EnterCriticalSection(&pns->_csBackgroundData);

        // Start at the head. We use a pointer to pointer here to eliminate special cases
        ppbeddWalk = &pns->_pbeddList;

        // First walk to the end of the list
        while (*ppbeddWalk)
            ppbeddWalk = &(*ppbeddWalk)->pNext;

        *ppbeddWalk = pbedd;
        LeaveCriticalSection(&pns->_csBackgroundData);

        // It's ok to ignore the return value here. The data will be cleaned up when the
        // CNscTree object gets destroyed
        if (::IsWindow(pns->_hwndTree))
            ::PostMessage(pns->_hwndTree, WM_NSCBACKGROUNDENUMDONE, (WPARAM)NULL, (LPARAM)NULL);
    }
    else
    {
        ILFree(pidl);
        ILFree(pidlExpandingTo);
        OrderList_Destroy(&hdpa, TRUE);
    }
}

BOOL OrderList_Insert(HDPA hdpa, int iIndex, LPITEMIDLIST pidl, int nOrder)
{
    PORDERITEM poi = OrderItem_Create(pidl, nOrder);
    if (poi)
    {
        if (-1 != DPA_InsertPtr(hdpa, iIndex, poi))
            return TRUE;

        OrderItem_Free(poi, TRUE); // free pid
    }
    return FALSE;
}

void CNscTree::_EnumBackgroundDone(NSC_BKGDENUMDONEDATA *pbedd)
{
    HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    HTREEITEM hti = pbedd->hitem;
    TVITEM    tvi;
    tvi.mask = TVIF_PARAM;
    tvi.hItem = hti;

    // This can fail if the item was moved before the async icon
    // extraction finished for that item.
    ITEMINFO* pii = NULL;
    if (hti != TVI_ROOT && TreeView_GetItem(_hwndTree, &tvi))
    {
        pii = GetPii(tvi.lParam);

        // Check if we have the right guy
        if (pii->dwSig != pbedd->dwSig)
        {
            // Try to find it using the pidl
            hti = _FindFromRoot(NULL, pbedd->pidl);
            if (hti)
                pii = _GetTreeItemInfo(hti);
        }
    }

    if ((hti == TVI_ROOT || (pii && pii->dwSig == pbedd->dwSig)) && _CacheShellFolder(hti))
    {
        // Check if the ordering has changed while we were doing the background enumeration
        if (pbedd->dwOrderSig == _dwOrderSig)
        {
            IShellFolder *psfItem = _psfCache;
            psfItem->AddRef(); // hang on as adding items may change the cached psfCache

            BOOL fInRename = _fInLabelEdit;
            HTREEITEM htiWasRenaming = fInRename ? _htiRenaming : NULL;

            HTREEITEM htiExpandTo = NULL;
            if (pbedd->pidlExpandingTo)
                htiExpandTo = _FindChild(psfItem, hti, pbedd->pidlExpandingTo);

            BOOL fParentMarked = _IsMarked(hti);
            BOOL fItemWasAdded = FALSE;
            BOOL fItemAlreadyIn = FALSE;

            ::SendMessage(_hwndTree, WM_SETREDRAW, FALSE, 0);

            HTREEITEM htiTemp;
            HTREEITEM htiLast = NULL;
            // find last child
            for (htiTemp = TreeView_GetChild(_hwndTree, hti); htiTemp;)
            {
                htiLast = htiTemp;
                htiTemp = TreeView_GetNextSibling(_hwndTree, htiTemp);
            }

            HTREEITEM htiCur = htiLast;
            BOOL bReorder = FALSE;
            int iCur = DPA_GetPtrCount(pbedd->hdpa);
            for (htiTemp = htiLast; htiTemp;)
            {
                HTREEITEM htiNextChild = TreeView_GetPrevSibling(_hwndTree, htiTemp);
                // must delete in this way or break the linkage of tree.
                int iIndex = _TreeItemIndexInHDPA(pbedd->hdpa, psfItem, htiTemp, iCur);
                if (-1 == iIndex)
                {
                    PORDERITEM poi = _GetTreeOrderItem(htiTemp);
                    if (poi)
                    {
                        DWORD dwAttrib = SFGAO_VALIDATE;
                        if (FAILED(psfItem->GetAttributesOf(1, (LPCITEMIDLIST*)&poi->pidl, &dwAttrib)))
                        {
                            TreeView_DeleteItem(_hwndTree, htiTemp);
                            if (htiCur == htiTemp)
                            {
                                htiCur = htiNextChild;
                            }
                        }
                        else
                        {
                            // the item is valid but it didn't get enumerated (possible in partial network enumeration)
                            // we need to add it to our list of new items
                            LPITEMIDLIST pidl = ILClone(poi->pidl);
                            if (pidl)
                            {
                                if (!OrderList_Insert(pbedd->hdpa, iCur, pidl, -1)) //frees the pidl
                                {
                                    // must delete item or our insertion below will be out of whack
                                    TreeView_DeleteItem(_hwndTree, htiTemp);
                                    if (htiCur == htiTemp)
                                    {
                                        htiCur = htiNextChild;
                                    }
                                }
                                else
                                {
                                    bReorder = TRUE; // we reinserted the item into the order list, must reorder
                                }
                            }
                        }
                    }
                }
                else
                {
                    iCur = iIndex; // our next orderlist insertion point
                }

                htiTemp = htiNextChild;
            }

            if (!_fOrdered)
            {
                int cAdded = DPA_GetPtrCount(pbedd->hdpa);

                // htiCur contains the last sibling in that branch
                HTREEITEM htiInsertPosition = htiCur ? htiCur : TVI_FIRST;

                // Now adding all the new elements starting from the last, since adding at the end of the tree
                // is very slow
                for (int i = cAdded-1; i >= 0; i--)
                {
                    PORDERITEM pitoi = (PORDERITEM)DPA_FastGetPtr(pbedd->hdpa, i);
                    if (pitoi == NULL)
                        break;

                    if (htiCur)
                    {
                        PORDERITEM poi = _GetTreeOrderItem(htiCur);
                        if (poi)
                        {
                            HRESULT hr = psfItem->CompareIDs(0, pitoi->pidl, poi->pidl);
                            // If the item is already there, let's not add it again
                            if (ShortFromResult(hr) == 0)
                            {
                                fItemAlreadyIn = TRUE;
                                if (pbedd->fUpdatePidls)
                                {
                                    _AssignPidl(poi, pitoi->pidl);
                                }
                                // Get to the next item
                                htiCur = TreeView_GetPrevSibling(_hwndTree, htiCur);
                                htiInsertPosition = htiCur;
                                if (!htiCur)
                                    htiInsertPosition = TVI_FIRST;

                                continue;
                            }
                        }
                    }

                    if (_ShouldShow(psfItem, pbedd->pidl, pitoi->pidl))
                    {
                        int cChildren = 1;
                        if (MODE_NORMAL == _mode)
                        {
                            DWORD dwAttrib = SHGetAttributes(psfItem, pitoi->pidl, SFGAO_FOLDER | SFGAO_STREAM);
                            cChildren = _GetChildren(psfItem, pitoi->pidl, dwAttrib);
                        }

                        // If this is a normal NSC, we need to display the plus sign correctly.
                        if (_AddItemToTree(hti, pitoi->pidl, cChildren, pitoi->nOrder, htiInsertPosition, FALSE, fParentMarked))
                        {
                            fItemWasAdded = TRUE;
                        }
                        else
                        {
                            break;
                        }
                    }
                }
            }
            else  // _fOrdered
            {
                if (bReorder)
                {
                    OrderList_Reorder(pbedd->hdpa);
                }
                
                LPITEMIDLIST pidlParent = _GetFullIDList(hti);
                if (pidlParent)
                {
                    int celt = DPA_GetPtrCount(pbedd->hdpa);
                    for (int i = 0; i < celt; i++)
                    {
                        PORDERITEM pitoi = (PORDERITEM)DPA_FastGetPtr(pbedd->hdpa, i);
                        if (pitoi == NULL)
                            break;

                        LPITEMIDLIST pidlFull = ILCombine(pidlParent, pitoi->pidl);
                        if (pidlFull)
                        {
                            htiTemp = _FindFromRoot(hti, pidlFull);
                            // if we DON'T FIND IT add it to the tree . . .
                            if (!htiTemp)
                            {
                                if (_AddItemToTree(hti, pitoi->pidl, 1, pitoi->nOrder, TVI_LAST, FALSE, fParentMarked))
                                {
                                    fItemWasAdded = TRUE;
                                }
                                else
                                {
                                    ILFree(pidlFull);
                                    break;
                                }
                            }
                            else
                            {
                                PORDERITEM poiItem = _GetTreeOrderItem(htiTemp);
                                if (poiItem)
                                {
                                    poiItem->nOrder = pitoi->nOrder;
                                }
                                fItemAlreadyIn = TRUE;
                            }
                            ILFree(pidlFull);
                        }
                    }
                    ILFree(pidlParent);
                }
                _Sort(hti, _psfCache);
            }

            if (fItemWasAdded || fItemAlreadyIn)
            {
                //make sure something is selected, otherwise first click selects instead of expanding/collapsing/navigating
                HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);
                if (!htiSelected)
                {
                    htiSelected = TreeView_GetFirstVisible(_hwndTree);
                    _SelectNoExpand(_hwndTree, htiSelected); // do not expand this guy
                }
                
                if (hti != TVI_ROOT)
                {
                    // if this is updatedir, don't expand the node
                    if (!pbedd->fUpdate)
                    {
                        // Check to see if it's expanded.
                        tvi.mask = TVIF_STATE;
                        tvi.stateMask = (TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
                        tvi.hItem = hti;
                        if (TreeView_GetItem(_hwndTree, &tvi))
                        {
                            if (!(tvi.state & TVIS_EXPANDED) || (tvi.state & TVIS_EXPANDPARTIAL))
                            {
                                _fIgnoreNextItemExpanding = TRUE;
                                _ExpandNode(hti, TVE_EXPAND, 1);
                                _fIgnoreNextItemExpanding = FALSE;
                            }
                        }
                    }

                    // Handle full recursive expansion case.
                    if (pbedd->uDepth)
                    {
                        for (htiTemp = TreeView_GetChild(_hwndTree, hti); htiTemp;) 
                        {
                            HTREEITEM htiNextChild = TreeView_GetNextSibling(_hwndTree, htiTemp);
                            _ExpandNode(htiTemp, TVE_EXPAND, pbedd->uDepth);
                            htiTemp = htiNextChild;
                        }

                        if (TVI_ROOT != htiSelected)
                            TreeView_EnsureVisible(_hwndTree, htiSelected);
                    }
                }
            }
            
            // we're doing refresh/update dir, we don't care if items were added or not
            if (pbedd->fUpdate)
            {
                for (htiTemp = TreeView_GetChild(_hwndTree, hti); htiTemp; htiTemp = TreeView_GetNextSibling(_hwndTree, htiTemp))
                {
                    PORDERITEM pitoi = _GetTreeOrderItem(htiTemp);
                    if (!pitoi)
                        break;
                
                    if (SHGetAttributes(psfItem, pitoi->pidl, SFGAO_FOLDER | SFGAO_STREAM) == SFGAO_FOLDER)
                    {
                        UINT uState = TVIS_EXPANDED;
                        if (TVI_ROOT != htiTemp)
                            uState = TreeView_GetItemState(_hwndTree, htiTemp, TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
                            
                        if (uState & TVIS_EXPANDED)
                        {
                            LPITEMIDLIST pidlFull = ILCombine(pbedd->pidl, pitoi->pidl);
                            if (pidlFull)
                            {
                                BOOL fOrdered;
                                _fUpdate = TRUE;
                                _fInExpand = BOOLIFY(uState & TVIS_EXPANDPARTIAL);
                                _StartBackgroundEnum(htiTemp, pidlFull, &fOrdered, pbedd->fUpdatePidls);
                                _fInExpand = FALSE;
                                _fUpdate = FALSE;
                                ILFree(pidlFull);
                            }
                        }
                        else if (uState & TVIS_EXPANDEDONCE)
                        {
                            TreeView_DeleteChildren(_hwndTree, htiTemp);
                            TreeView_SetChildren(_hwndTree, htiTemp, NSC_CHILDREN_CALLBACK);
                        }
                    }
                }
            }

            ::SendMessage(_hwndTree, WM_SETREDRAW, TRUE, 0);
            if (htiExpandTo)
                TreeView_EnsureVisible(_hwndTree, htiExpandTo);

            if (fItemWasAdded && fInRename)
            {
                _fOkToRename = TRUE;  //otherwise label editing is canceled
                TreeView_EditLabel(_hwndTree, htiWasRenaming);
                _fOkToRename = FALSE;
            }


            psfItem->Release();
        }
        else
        {
            BOOL fOrdered;
            // The order has changed, we need start over again using the new order
            _StartBackgroundEnum(hti, pbedd->pidl, &fOrdered, pbedd->fUpdatePidls);
        }
    }

    delete pbedd;

    SetCursor(hCursorOld);
}


// review chrisny:  get rid of this function.
int CNscTree::_GetChildren(IShellFolder *psf, LPCITEMIDLIST pidl, ULONG ulAttrs)
{
    int cChildren = 0;  // assume none

    // treat zip folders as files (they are both folders and files but we treat them as files)
    // on downlevel SFGAO_STREAM is the same as SFGAO_HASSTORAGE so we'll let zip files slide through (oh well)
    // better than not adding filesystem folders (that have storage)

    if (ulAttrs & SFGAO_FOLDER)
    {
        cChildren = I_CHILDRENAUTO; // let treeview handle +'s
            
        if (_grfFlags & SHCONTF_FOLDERS)
        {
            // if just folders we can peek at the attributes
            if (SHGetAttributes(psf, pidl, SFGAO_HASSUBFOLDER))
                cChildren = 1;
        }
        
        if (cChildren != 1 && (_grfFlags & SHCONTF_NONFOLDERS))
        {
            // there is no SFGAO_ bit that includes non folders so we need to enum
            IShellFolder *psfItem;
            if (SUCCEEDED(psf->BindToObject(pidl, NULL, IID_PPV_ARG(IShellFolder, &psfItem))))
            {
                // if we are showing non folders we have to do an enum to peek down at items below
                IEnumIDList *penum;
                if (S_OK == _GetEnum(psfItem, NULL, &penum))
                {
                    ULONG celt;
                    LPITEMIDLIST pidlTemp;
                    
                    if (penum->Next(1, &pidlTemp, &celt) == S_OK && celt == 1)
                    {
                        //do not call ShouldShow here because we will end up without + if the item is filtered out
                        //it's better to have an extra + that is going to go away when user clicks on it
                        //than to not be able to expand item with valid children
                        cChildren = 1;
                        ILFree(pidlTemp);
                    }
                    penum->Release();
                }
                psfItem->Release();
            }
        }
    }
    
    return cChildren;
}

void CNscTree::_OnGetDisplayInfo(TV_DISPINFO *pnm)
{
    PORDERITEM poi = GetPoi(pnm->item.lParam);
    LPCITEMIDLIST pidl = _CacheParentShellFolder(pnm->item.hItem, poi->pidl);
    ASSERT(pidl);
    if (pidl == NULL)
        return;
    ASSERT(_psfCache);
    ASSERT(pnm->item.mask & (TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN));
    if (pnm->item.mask & TVIF_TEXT)
    {
        SHELLDETAILS details;
        if (SUCCEEDED(_GetDisplayNameOf(pidl, SHGDN_INFOLDER, &details)))
            StrRetToBuf(&details.str, pidl, pnm->item.pszText, pnm->item.cchTextMax);
    }
    // make sure we set the attributes for those flags that need them
    if (pnm->item.mask & (TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE))
    {
        ULONG ulAttrs = SHGetAttributes(_psfCache, pidl, SFGAO_FOLDER | SFGAO_STREAM | SFGAO_NEWCONTENT);
        // review chrisny:  still need to handle notify of changes from
        //  other navs.
        
        // HACKHACK!!!  we're using the TVIS_FOCUSED bit to stored whether there's
        // new content or not. 
        if (ulAttrs & SFGAO_NEWCONTENT)
        {
            pnm->item.mask |= TVIF_STATE;
            pnm->item.stateMask = TVIS_FOCUSED;  // init state mask to bold
            pnm->item.state = TVIS_FOCUSED;  // init state mask to bold
        }
        // Also see if this guy has any child folders
        if (pnm->item.mask & TVIF_CHILDREN)
            pnm->item.cChildren = _GetChildren(_psfCache, pidl, ulAttrs);
        
        if (pnm->item.mask & (TVIF_IMAGE | TVIF_SELECTEDIMAGE))
            // We now need to map the item into the right image index.
            _GetDefaultIconIndex(pidl, ulAttrs, &pnm->item, (ulAttrs & SFGAO_FOLDER));

        _UpdateItemDisplayInfo(pnm->item.hItem);
    }
    // force the treeview to store this so we don't get called back again
    pnm->item.mask |= TVIF_DI_SETITEM;
}

#define SZ_CUTA                 "cut"
#define SZ_CUT                  TEXT(SZ_CUTA)
#define SZ_RENAMEA              "rename"
#define SZ_RENAME               TEXT(SZ_RENAMEA)

void CNscTree::_ApplyCmd(HTREEITEM hti, IContextMenu *pcm, UINT idCmd)
{
    TCHAR szCommandString[40];
    BOOL fHandled = FALSE;
    BOOL fCutting = FALSE;
    
    // We need to special case the rename command
    if (SUCCEEDED(ContextMenu_GetCommandStringVerb(pcm, idCmd, szCommandString, ARRAYSIZE(szCommandString))))
    {
        if (StrCmpI(szCommandString, SZ_RENAME)==0) 
        {
            TreeView_EditLabel(_hwndTree, hti);
            fHandled = TRUE;
        } 
        else if (!StrCmpI(szCommandString, SZ_CUT)) 
        {
            fCutting = TRUE;
        }
    }
    
    if (!fHandled)
    {
        CMINVOKECOMMANDINFO ici = {
            sizeof(CMINVOKECOMMANDINFO),
                0,
                _hwndTree,
                MAKEINTRESOURCEA(idCmd),
                NULL, NULL,
                SW_NORMAL,
        };
        
        HRESULT hr = pcm->InvokeCommand(&ici);
        if (fCutting && SUCCEEDED(hr))
        {
            TV_ITEM tvi;
            tvi.mask = TVIF_STATE;
            tvi.stateMask = TVIS_CUT;
            tvi.state = TVIS_CUT;
            tvi.hItem = hti;
            TreeView_SetItem(_hwndTree, &tvi);
            
            // _hwndNextViewer = SetClipboardViewer(_hwndTree);
            // _htiCut = hti;
        }
        
        //hack to force a selection update, so oc can update it's status text
        if (_mode & MODE_CONTROL)
        {
            HTREEITEM hti = TreeView_GetSelection(_hwndTree);
            
            ::SendMessage(_hwndTree, WM_SETREDRAW, FALSE, 0);
            TreeView_SelectItem(_hwndTree, NULL);
            
            //only select the item if the handle is still valid
            if (hti)
                TreeView_SelectItem(_hwndTree, hti);
            ::SendMessage(_hwndTree, WM_SETREDRAW, TRUE, 0);
        }
    }
}


// perform actions like they were chosen from the context menu, but without showing the menu
// review: this shouldn't be bstr, we only pass const strings here
HRESULT CNscTree::_InvokeContextMenuCommand(BSTR strCommand)
{
    ASSERT(strCommand);
    HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);
    
    if (htiSelected)
    {
        if (StrCmpIW(strCommand, L"rename") == 0) 
        {
            _fOkToRename = TRUE;  //otherwise label editing is canceled
            TreeView_EditLabel(_hwndTree, htiSelected);
            _fOkToRename = FALSE;
        }
        else
        {
            LPCITEMIDLIST pidl = _CacheParentShellFolder(htiSelected, NULL);
            if (pidl)
            {
                IContextMenu *pcm;
                if (SUCCEEDED(_psfCache->GetUIObjectOf(_hwndTree, 1, &pidl, IID_PPV_ARG_NULL(IContextMenu, &pcm))))
                {
                    CHAR szCommand[MAX_PATH];
                    SHUnicodeToAnsi(strCommand, szCommand, ARRAYSIZE(szCommand));
                    
                    // QueryContextMenu, even though unused, initializes the folder properly (fixes delete subscription problems)
                    HMENU hmenu = CreatePopupMenu();
                    if (hmenu)
                        pcm->QueryContextMenu(hmenu, 0, 0, 0x7fff, CMF_NORMAL);

                    /* Need to try twice, in case callee is ANSI-only */
                    CMINVOKECOMMANDINFOEX ici = 
                    {
                        CMICEXSIZE_NT4,         /* Be NT4-compat */
                        CMIC_MASK_UNICODE,
                        _hwndTree,
                        szCommand,
                        NULL, NULL,
                        SW_NORMAL,
                        0, NULL,
                        NULL,
                        strCommand,
                        NULL, NULL,
                        NULL,
                    };
                    
                    HRESULT hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);
                    if (hr == E_INVALIDARG) 
                    {
                        // Recipient didn't like the unicode command; send an ANSI one
                        ici.cbSize = sizeof(CMINVOKECOMMANDINFO);
                        ici.fMask &= ~CMIC_MASK_UNICODE;
                        hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);
                    }

                    // do any visuals for cut state
                    if (SUCCEEDED(hr) && StrCmpIW(strCommand, L"cut") == 0) 
                    {
                        HTREEITEM hti = TreeView_GetSelection(_hwndTree);
                        if (hti) 
                        {
                            _TreeSetItemState(hti, TVIS_CUT, TVIS_CUT);
                            ASSERT(!_hwndNextViewer);
                            _hwndNextViewer = ::SetClipboardViewer(_hwndTree);
                            _htiCut = hti;
                        }
                    }
                    if (hmenu)
                        DestroyMenu(hmenu);
                    pcm->Release();
                }
            }
        }
        
        //if properties was invoked, who knows what might have changed, so force a reselect
        if (StrCmpNW(strCommand, L"properties", 10) == 0)
        {
            TreeView_SelectItem(_hwndTree, htiSelected);
        }
    }

    return S_OK;
}

//
//  pcm = IContextMenu for the item the user selected
//  hti = the item the user selected
//
//  Okay, this menu thing is kind of funky.
//
//  If "Favorites", then everybody gets "Create new folder".
//
//  If expandable:
//      Show "Expand" or "Collapse"
//      (accordingly) and set it as the default.
//
//  If not expandable:
//      The default menu of the underlying context menu is
//      used as the default; or use the first item if nobody
//      picked a default.
//
//      We replace the existing "Open" command with our own.
//

HMENU CNscTree::_CreateContextMenu(IContextMenu *pcm, HTREEITEM hti)
{
    BOOL fExpandable = _IsExpandable(hti);
    HMENU hmenu = CreatePopupMenu();
    if (hmenu)
    {
        pcm->QueryContextMenu(hmenu, 0, RSVIDM_CONTEXT_START, 0x7fff, CMF_EXPLORE | CMF_CANRENAME);

        //  Always delete "Create shortcut" from the context menu.
        ContextMenu_DeleteCommandByName(pcm, hmenu, RSVIDM_CONTEXT_START, L"link");

        //  Sometimes we need to delete "Open":
        //
        //  History mode always.  The context menu for history mode folders
        //  has "Open" but it doesn't work, so we need to replace it with
        //  Expand/Collapse.  And the context menu for history mode items
        //  has "Open" but it opens in a new window.  We want to navigate.
        //
        //  Favorites mode, expandable:  Leave "Open" alone -- it will open
        //  the expandable thing in a new window.
        //
        //  Favorites mode, non-expandable: Delete the original "Open" and
        //  replace it with ours that does a navigate.
        //
        BOOL fReplaceOpen = (_mode & MODE_HISTORY) || (!fExpandable && (_mode & MODE_FAVORITES));
        if (fReplaceOpen)
            ContextMenu_DeleteCommandByName(pcm, hmenu, RSVIDM_CONTEXT_START, L"open");

        // Load the NSC part of the context menu and party on it separately.
        // By doing this, we save the trouble of having to do a SHPrettyMenu
        // after we dork it -- Shell_MergeMenus does all the prettying
        // automatically.  NOTE: this is totally bogus reasoning - cleaner code the other way around...

        HMENU hmenuctx = LoadMenuPopup_PrivateNoMungeW(POPUP_CONTEXT_NSC);
        if (hmenuctx)
        {
            // create new folder doesn't make sense outside of favorites
            // (actually, it does, but there's no interface to it)
            if (!(_mode & MODE_FAVORITES))
                DeleteMenu(hmenuctx, RSVIDM_NEWFOLDER, MF_BYCOMMAND);

            //  Of "Expand", "Collapse", or "Open", we will keep at most one of
            //  them.  idmKeep is the one we choose to keep.
            //
            UINT idmKeep;
            if (fExpandable)
            {
                // Even if the item has no children, we still show Expand.
                // The reason is that an item that has never been expanded
                // is marked as "children: unknown" so we show an Expand
                // and then the user picks it and nothing expands.  And then
                // the user clicks it again and the Expand option is gone!
                // (Because the second time, we know that the item isn't
                // expandable.)
                //
                // Better to be consistently wrong than randomly wrong.
                //
                if (_IsItemExpanded(hti))
                    idmKeep = RSVIDM_COLLAPSE;
                else
                    idmKeep = RSVIDM_EXPAND;
            }
            else if (!(_mode & MODE_CONTROL))
            {
                idmKeep = RSVIDM_OPEN;
            }
            else
            {
                idmKeep = 0;
            }

            //  Now go decide which of RSVIDM_COLLAPSE, RSVIDM_EXPAND, or
            //  RSVIDM_OPEN we want to keep.
            //
            if (idmKeep != RSVIDM_EXPAND)
                DeleteMenu(hmenuctx, RSVIDM_EXPAND,   MF_BYCOMMAND);
            if (idmKeep != RSVIDM_COLLAPSE)
                DeleteMenu(hmenuctx, RSVIDM_COLLAPSE, MF_BYCOMMAND);
            if (idmKeep != RSVIDM_OPEN)
                DeleteMenu(hmenuctx, RSVIDM_OPEN,     MF_BYCOMMAND);

            // in normal mode we want to gray out expand if folder cannot be expanded
            if (idmKeep == RSVIDM_EXPAND && _mode == MODE_NORMAL)
            {
                TV_ITEM tvi;
                tvi.mask = TVIF_CHILDREN;
                tvi.hItem = hti;
                if (TreeView_GetItem(_hwndTree, &tvi) && !tvi.cChildren)
                {
                    EnableMenuItem(hmenuctx, RSVIDM_EXPAND, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
                }
            }
            
            Shell_MergeMenus(hmenu, hmenuctx, 0, 0, 0xFFFF, fReplaceOpen ? 0 : MM_ADDSEPARATOR);

            DestroyMenu(hmenuctx);

            if (idmKeep)
                SetMenuDefaultItem(hmenu, idmKeep, MF_BYCOMMAND);
        }

        // Menu item "Open in New Window" needs to be disabled if the restriction is set
        if( SHRestricted2W(REST_NoOpeninNewWnd, NULL, 0))
        {
            EnableMenuItem(hmenu, RSVIDM_CONTEXT_START + RSVIDM_OPEN_NEWWINDOW, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        _SHPrettyMenu(hmenu);
    }
    return hmenu;
}

LRESULT CNscTree::_OnContextMenu(short x, short y)
{
    if (!SHRestricted(REST_NOVIEWCONTEXTMENU))
    {
        HTREEITEM hti;
        POINT ptPopup;  // in screen coordinate

        //assert that the SetFocus() below won't be ripping focus away from anyone
        ASSERT((_mode & MODE_CONTROL) ? (GetFocus() == _hwndTree) : TRUE);

        if (x == -1 && y == -1)
        {
            // Keyboard-driven: Get the popup position from the selected item.
            hti = TreeView_GetSelection(_hwndTree);
            if (hti)
            {
                RECT rc;
                //
                // Note that TV_GetItemRect returns it in client coordinate!
                //
                TreeView_GetItemRect(_hwndTree, hti, &rc, TRUE);
                //cannot point to middle of item rect because if item name cannot fit into control rect
                //treeview puts tooltip on top and rect returned above is from tooltip whose middle
                //may not be in Treeview which causes problems later in the function
                ptPopup.x = rc.left + 1;
                ptPopup.y = (rc.top + rc.bottom) / 2;
                ::MapWindowPoints(_hwndTree, HWND_DESKTOP, &ptPopup, 1);
            }
            //so we can go into rename mode
            _fOkToRename = TRUE;
        }
        else
        {
            TV_HITTESTINFO tvht;

            // Mouse-driven: Pick the treeitem from the position.
            ptPopup.x = x;
            ptPopup.y = y;

            tvht.pt = ptPopup;
            ::ScreenToClient(_hwndTree, &tvht.pt);

            hti = TreeView_HitTest(_hwndTree, &tvht);
        }

        if (hti)
        {
            LPCITEMIDLIST pidl = _CacheParentShellFolder(hti, NULL);
            if (pidl)
            {
                IContextMenu *pcm;

                TreeView_SelectDropTarget(_hwndTree, hti);

                if (SUCCEEDED(_psfCache->GetUIObjectOf(_hwndTree, 1, &pidl, IID_PPV_ARG_NULL(IContextMenu, &pcm))))
                {
                    pcm->QueryInterface(IID_PPV_ARG(IContextMenu2, &_pcmSendTo));

                    HMENU hmenu = _CreateContextMenu(pcm, hti);
                    if (hmenu)
                    {
                        _pcm = pcm; // for IContextMenu2 code

                        // use _hwnd so menu msgs go there and I can forward them
                        // using IContextMenu2 so "Sent To" works

                        // review chrisny:  useTrackPopupMenuEx for clipping etc.  
                        UINT idCmd = TrackPopupMenu(hmenu,
                            TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                            ptPopup.x, ptPopup.y, 0, _hwndTree, NULL);
                        // Note:  must requery selected item to verify that the hti is good.  This
                        // solves the problem where the hti was deleted, hence pointed to something
                        // bogus, then we write to it causing heap corruption, while the menu was up.  
                        TV_HITTESTINFO tvht;
                        tvht.pt = ptPopup;
                        ::ScreenToClient(_hwndTree, &tvht.pt);
                        hti = TreeView_HitTest(_hwndTree, &tvht);
                        if (hti && idCmd)
                        {
                            switch (idCmd)
                            {
                            case RSVIDM_OPEN:
                            case RSVIDM_EXPAND:
                            case RSVIDM_COLLAPSE:
                                TreeView_SelectItem(_hwndTree, hti);
                                //  turn off flag, so select will have an effect.
                                _fOkToRename = FALSE;
                                _OnSelChange(FALSE);     // selection has changed, force the navigation.
                                //  SelectItem may not expand (if was closed and selected)
                                TreeView_Expand(_hwndTree, hti, idCmd == RSVIDM_COLLAPSE ? TVE_COLLAPSE : TVE_EXPAND);
                                break;

                            // This WAS unix only, now win32 does it too
                            // IEUNIX : We allow new folder creation from context menu. since
                            // this control was used to organize favorites in IEUNIX4.0
                            case RSVIDM_NEWFOLDER:
                                CreateNewFolder(hti);
                                break;

                            default:
                                _ApplyCmd(hti, pcm, idCmd-RSVIDM_CONTEXT_START);
                                break;
                            }

                            //we must have had focus before (asserted above), but we might have lost it after a delete.
                            //get it back.
                            //this is only a problem in the nsc oc.
                            if ((_mode & MODE_CONTROL) && !_fInLabelEdit)
                                ::SetFocus(_hwndTree);
                        }
                        ATOMICRELEASE(_pcmSendTo);
                        DestroyMenu(hmenu);
                        _pcm = NULL;
                    }
                    pcm->Release();
                }
                TreeView_SelectDropTarget(_hwndTree, NULL);
            }
        }

        if (x == -1 && y == -1)
            _fOkToRename = FALSE;
    }

    return S_FALSE;       // So WM_CONTEXTMENU message will not come.
}


HRESULT CNscTree::_QuerySelection(IContextMenu **ppcm, HTREEITEM *phti)
{
    HRESULT hr = E_FAIL;
    HTREEITEM hti = TreeView_GetSelection(_hwndTree);
    if (hti)
    {
        LPCITEMIDLIST pidl = _CacheParentShellFolder(hti, NULL);
        if (pidl)
        {
            if (ppcm)
            {
                hr = _psfCache->GetUIObjectOf(_hwndTree, 1, &pidl, IID_PPV_ARG_NULL(IContextMenu, ppcm));
            }
            else
            {
                hr = S_OK;
            }
        }
    }
    
    if (phti)
        *phti = hti;
    
    return hr;
}

LRESULT NSCEditBoxSubclassWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam,
                                  UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    if (uIdSubclass == ID_NSC_SUBCLASS && uMsg == WM_GETDLGCODE)
    {
        return DLGC_WANTMESSAGE;
    }
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CNscTree::_OnBeginLabelEdit(TV_DISPINFO *ptvdi)
{
    BOOL fCantRename = TRUE;
    LPCITEMIDLIST pidl = _CacheParentShellFolder(ptvdi->item.hItem, NULL);
    if (pidl)
    {
        if (SHGetAttributes(_psfCache, pidl, SFGAO_CANRENAME))
            fCantRename = FALSE;
    }

    HWND hwndEdit = (HWND)::SendMessage(_hwndTree, TVM_GETEDITCONTROL, 0, 0);
    if (hwndEdit)
    {
        WCHAR szName[MAX_PATH];
        if (SUCCEEDED(DisplayNameOf(_psfCache, pidl, SHGDN_INFOLDER|SHGDN_FOREDITING, szName, ARRAYSIZE(szName))))
        {
            SHLimitInputEdit(hwndEdit, _psfCache);
            ::SetWindowText(hwndEdit, szName);
        }
        
        SetWindowSubclass(hwndEdit, NSCEditBoxSubclassWndProc, ID_NSC_SUBCLASS, NULL);
    }
    
    _fInLabelEdit = !fCantRename;
    if (_fInLabelEdit)
        _htiRenaming = ptvdi->item.hItem;
        
    return fCantRename;
}

//
// Utility function for CNSCTree::_OnEndLabelEdit
//  Does not set the new value in the tree view if the old
//   value is the same.
//
BOOL CNscTree::_LabelEditIsNewValueValid(TV_DISPINFO *ptvdi)
{
    ASSERT(ptvdi && ptvdi->item.hItem);
    
    TCHAR szOldValue[MAX_PATH];

    szOldValue[0] = '\0';
    
    TV_ITEM tvi;
    tvi.mask       = TVIF_TEXT;
    tvi.hItem      = (HTREEITEM)ptvdi->item.hItem;
    tvi.pszText    = szOldValue;
    tvi.cchTextMax = ARRAYSIZE(szOldValue);
    TreeView_GetItem(_hwndTree, &tvi);
    
    //
    // is the old value in the control unequal to the new one?
    //
    return (0 != StrCmp(tvi.pszText, ptvdi->item.pszText));
}

LRESULT CNscTree::_OnEndLabelEdit(TV_DISPINFO *ptvdi)
{
    HWND hwndEdit = (HWND)::SendMessage(_hwndTree, TVM_GETEDITCONTROL, 0, 0);
    if (hwndEdit)
    {
        RemoveWindowSubclass(hwndEdit, NSCEditBoxSubclassWndProc, ID_NSC_SUBCLASS);
    }

    if ((ptvdi->item.pszText != NULL) && _LabelEditIsNewValueValid(ptvdi))
    {
        ASSERT(ptvdi->item.hItem);
        
        LPCITEMIDLIST pidl = _CacheParentShellFolder(ptvdi->item.hItem, NULL);
        if (pidl)
        {
            WCHAR wszName[MAX_PATH - 5]; //-5 to work around nt4 shell32 bug
            SHTCharToUnicode(ptvdi->item.pszText, wszName, ARRAYSIZE(wszName));
            
            if (SUCCEEDED(_psfCache->SetNameOf(_hwndTree, pidl, wszName, 0, NULL)))
            {
                // NOTES: pidl is no longer valid here.
                
                // Set the handle to NULL in the notification to let
                // the system know that the pointer is probably not
                // valid anymore.
                ptvdi->item.hItem = NULL;
                _FlushNotifyMessages(_hwndTree);    // do this last, else we get bad results
                _fInLabelEdit = FALSE;
            }
            else
            {
                // not leaving label edit mode here, so do not set _fInLabelEdit to FALSE or we
                // will not get ::TranslateAcceleratorIO() and backspace, etc, will not work.
                _fOkToRename = TRUE;  //otherwise label editing is canceled
                ::SendMessage(_hwndTree, TVM_EDITLABEL, (WPARAM)ptvdi->item.pszText, (LPARAM)ptvdi->item.hItem);
                _fOkToRename = FALSE;
            }
        }
    }
    else
        _fInLabelEdit = FALSE;

    if (!_fInLabelEdit)
        _htiRenaming = NULL;
        
    //else user cancelled, nothing to do here.
    return 0;   // We always return 0, "we handled it".
}    
    
BOOL _DidDropOnRecycleBin(IDataObject *pdtobj)
{
    CLSID clsid;
    return SUCCEEDED(DataObj_GetBlob(pdtobj, g_cfTargetCLSID, &clsid, sizeof(clsid))) &&
           IsEqualCLSID(clsid, CLSID_RecycleBin);
}

void CNscTree::_OnBeginDrag(NM_TREEVIEW *pnmhdr)
{
    LPCITEMIDLIST pidl = _CacheParentShellFolder(pnmhdr->itemNew.hItem, NULL);
    _htiDragging = pnmhdr->itemNew.hItem;   // item we are dragging.
    if (pidl)
    {
        if (_pidlDrag)
        {
            ILFree(_pidlDrag);
            _pidlDrag = NULL;
        }

        DWORD dwEffect = SHGetAttributes(_psfCache, pidl, DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK);
        if (dwEffect)
        {
            IDataObject *pdtobj;
            HRESULT hr = _psfCache->GetUIObjectOf(_hwndTree, 1, &pidl, IID_PPV_ARG_NULL(IDataObject, &pdtobj));
            if (SUCCEEDED(hr))
            {
                HWND hwndTT;
                
                _fDragging = TRUE;
                if (hwndTT = TreeView_GetToolTips(_hwndTree))
                    ::SendMessage(hwndTT, TTM_POP, (WPARAM) 0, (LPARAM) 0);
                PORDERITEM poi = _GetTreeOrderItem(pnmhdr->itemNew.hItem);
                if (poi)
                {
                    _iDragSrc = poi->nOrder;
                    TraceMsg(TF_NSC, "NSCBand: Starting Drag");
                    _pidlDrag = ILClone(poi->pidl);
                    _htiFolderStart = TreeView_GetParent(_hwndTree, pnmhdr->itemNew.hItem);
                    if (_htiFolderStart == NULL)
                        _htiFolderStart = TVI_ROOT;
                }
                else
                {
                    _iDragSrc = -1;
                    _pidlDrag = NULL;
                    _htiFolderStart = NULL;
                }

                //
                // Don't allow drag and drop of channels if
                // REST_NoRemovingChannels is set.
                //
                if (!SHRestricted2(REST_NoRemovingChannels, NULL, 0) ||
                    !_IsChannelFolder(_htiDragging))
                {
                    HIMAGELIST himlDrag;
                
                    SHLoadOLE(SHELLNOTIFY_OLELOADED); // Browser Only - our shell32 doesn't know ole has been loaded

                    _fStartingDrag = TRUE;
                    IDragSourceHelper* pdsh = NULL;
                    if (SUCCEEDED(CoCreateInstance(CLSID_DragDropHelper, NULL, CLSCTX_INPROC_SERVER, 
                        IID_PPV_ARG(IDragSourceHelper, &pdsh))))
                    {
                        pdsh->InitializeFromWindow(_hwndTree, &pnmhdr->ptDrag, pdtobj);
                        _fStartingDrag = FALSE;
                    }
                    else
                    {
                        himlDrag = TreeView_CreateDragImage(_hwndTree, pnmhdr->itemNew.hItem);
                        _fStartingDrag = FALSE;
                
                        if (himlDrag) 
                        {
                            DAD_SetDragImage(himlDrag, NULL);
                        }
                    }
           
                    hr = SHDoDragDrop(_hwndTree, pdtobj, NULL, dwEffect, &dwEffect);

                    // the below follows the logic in defview for non-filesystem deletes.
                    InitClipboardFormats();
                    if ((DRAGDROP_S_DROP == hr) &&
                        (DROPEFFECT_MOVE == dwEffect) &&
                        (DROPEFFECT_MOVE == DataObj_GetDWORD(pdtobj, g_cfPerformedEffect, DROPEFFECT_NONE)))
                    {
                        // enable UI for the recycle bin case (the data will be lost
                        // as the recycle bin really can't recycle stuff that is not files)

                        UINT uFlags = _DidDropOnRecycleBin(pdtobj) ? 0 : CMIC_MASK_FLAG_NO_UI;
                        SHInvokeCommandOnDataObject(_hwndTree, NULL, pdtobj, uFlags, "delete");
                    }
                    else if (dwEffect == DROPEFFECT_NONE)
                    {
                        // nothing happened when the d&d terminated, so clean up you fool.
                        ILFree(_pidlDrag);
                        _pidlDrag = NULL;
                    }

                    if (pdsh)
                    {
                        pdsh->Release();
                    }
                    else
                    {
                        DAD_SetDragImage((HIMAGELIST)-1, NULL);
                        ImageList_Destroy(himlDrag);
                    }
                }

                _iDragSrc = -1;
                pdtobj->Release();
            }
        }
    }
    _htiDragging = NULL;
}

BOOL IsExpandableChannelFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    if (WhichPlatform() == PLATFORM_INTEGRATED)
        return SHIsExpandableFolder(psf, pidl);

    ASSERT(pidl);
    ASSERT(psf);

    BOOL          fExpand = FALSE;
    IShellFolder* psfChannelFolder;
    if (pidl && psf && SUCCEEDED(SHBindToObject(psf, IID_X_PPV_ARG(IShellFolder, pidl, &psfChannelFolder))))
    {
        IEnumIDList *penum;
        if (S_OK == psfChannelFolder->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &penum))
        {
            ULONG celt;
            LPITEMIDLIST pidlTemp;

            if (penum->Next(1, &pidlTemp, &celt) == S_OK && celt == 1)
            {
                ILFree(pidlTemp);
                fExpand = FALSE;
            }
            if (penum->Next(1, &pidlTemp, &celt) == S_OK && celt == 1)
            {
                ILFree(pidlTemp);
                fExpand = TRUE;
            }
            penum->Release();
        }
        psfChannelFolder->Release();
    }

    return fExpand;
}

BOOL CNscTree::_OnSelChange(BOOL fMark)
{
    BOOL fExpand = TRUE;
    HTREEITEM hti = TreeView_GetSelection(_hwndTree);
    BOOL fMultiSelect = _dwFlags & NSS_MULTISELECT;

    //if we're in control mode (where pnscProxy always null), never navigate
    if (hti)
    {
        LPCITEMIDLIST pidlItem = _CacheParentShellFolder(hti, NULL);
        if (pidlItem && !fMultiSelect)
        {
            if (_pnscProxy && !_fInSelectPidl)
            {
                ULONG ulAttrs = SFGAO_FOLDER | SFGAO_NEWCONTENT;
                LPITEMIDLIST pidlTarget;
                LPITEMIDLIST pidlFull = _GetFullIDList(hti);
                HRESULT hr = _pnscProxy->GetNavigateTarget(pidlFull, &pidlTarget, &ulAttrs);
                if (SUCCEEDED(hr))
                {
                    if (hr == S_OK)
                    {
                        _pnscProxy->Invoke(pidlTarget);
                        ILFree(pidlTarget);
                    }
                    // review chrisny:  still need to handle notify of changes from
                    //  other navs.
                    if (ulAttrs & SFGAO_NEWCONTENT)
                    {
                        TV_ITEM tvi;
                        tvi.hItem = hti;
                        tvi.mask = TVIF_STATE | TVIF_HANDLE;
                        tvi.stateMask = TVIS_FOCUSED;  // the BOLD bit is to be
                        tvi.state = 0;              // cleared
                    
                        TreeView_SetItem(_hwndTree, &tvi);
                    }
                }
                else
                {
                    if (!(SHGetAttributes(_psfCache, pidlItem, SFGAO_FOLDER)))
                        SHInvokeDefaultCommand(_hwndTree, _psfCache, pidlItem);
                }

                ILFree(pidlFull);
                fExpand = hr != S_OK && (ulAttrs & SFGAO_FOLDER);
            }
        }
    }

    if (fMultiSelect)
    {
        if (fMark)
        {
            UINT uState = TreeView_GetItemState(_hwndTree, hti, NSC_TVIS_MARKED) & NSC_TVIS_MARKED;

            uState ^= NSC_TVIS_MARKED;
            _MarkChildren(hti, uState == NSC_TVIS_MARKED);
            _htiActiveBorder = NULL;
        }
    }
    else if (!_fSingleExpand && fExpand && (_mode != MODE_NORMAL))
    {
        TreeView_Expand(_hwndTree, hti, TVE_TOGGLE);
    }

    if (!fMultiSelect)
        _UpdateActiveBorder(hti);

    return TRUE;
}

void CNscTree::_OnSetSelection()
{
    HTREEITEM hti = TreeView_GetSelection(_hwndTree);
    LPITEMIDLIST pidlItem = _GetFullIDList(hti);

    if (_pnscProxy && !_fInSelectPidl)
    {
        _pnscProxy->OnSelectionChanged(pidlItem);
    }    

    ILFree(pidlItem);
}

void CNscTree::_OnGetInfoTip(NMTVGETINFOTIP* pnm)
{
    // No info tip operation on drag/drop
    if (_fDragging || _fDropping || _fClosing || _fHandlingShellNotification || _fInSelectPidl)
        return;

    PORDERITEM poi = GetPoi(pnm->lParam);
    if (poi)
    {
        LPITEMIDLIST pidl = _CacheParentShellFolder(pnm->hItem, poi->pidl);
        if (pidl)
        {
            // Use the imported Browseui function because the one in shell\lib does
            // not work on browser-only platforms
            GetInfoTip(_psfCache, pidl, pnm->pszText, pnm->cchTextMax);
        }
    }
}

LRESULT CNscTree::_OnSetCursor(NMMOUSE* pnm)
{
    if (_mode == MODE_NORMAL && _fShouldShowAppStartCursor)
    {
        SetCursor(LoadCursor(NULL, IDC_APPSTARTING));
        return 1;
    }

    if (!pnm->dwItemData)
    {
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return 1;
    }

    if (!(_mode & MODE_CONTROL) && (_mode != MODE_NORMAL))
    {
        ITEMINFO* pii = GetPii(pnm->dwItemData);
        if (pii) 
        {
            if (!pii->fNavigable)
            {
                //folders always get the arrow
                SetCursor(LoadCursor(NULL, IDC_ARROW));
            }
            else
            {
                //favorites always get some form of the hand
                HCURSOR hCursor = pii->fGreyed ? (HCURSOR)LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_OFFLINE_HAND)) :
                                         LoadHandCursor(0);
                if (hCursor)
                    SetCursor(hCursor);
            }
        }
    }
    else
    {
        //always show the arrow in org favs
        SetCursor(LoadCursor(NULL, IDC_ARROW));
    }
    
    return 1; // 1 if We handled it, 0 otherwise
}

BOOL CNscTree::_IsTopParentItem(HTREEITEM hti)
{
    return (hti && (!TreeView_GetParent(_hwndTree, hti)));
}

LRESULT CNscTree::_OnNotify(LPNMHDR pnm)
{
    LRESULT lres = 0;

    switch (pnm->idFrom)
    {
    case ID_CONTROL:
        {
            switch (pnm->code) 
            {
            case NM_CUSTOMDRAW:
                return _OnCDNotify((LPNMCUSTOMDRAW)pnm);

            case TVN_GETINFOTIP:
                // no info tips on drag/drop ops
                // According to Bug#241601, Tooltips display too quickly. The problem is
                // the original designer of the InfoTips in the Treeview merged the "InfoTip" tooltip and
                // the "I'm too small to display correctly" tooltips. This is really unfortunate because you
                // cannot control the display of these tooltips independantly. Therefore we are turning off
                // infotips in normal mode.
                if (!_fInLabelEdit && _mode != MODE_NORMAL)
                    _OnGetInfoTip((NMTVGETINFOTIP*)pnm);
                else 
                    return FALSE;
                break;
                
            case NM_SETCURSOR:
                lres = _OnSetCursor((NMMOUSE*)pnm);
                break;
                
            case NM_SETFOCUS:
            case NM_KILLFOCUS:
                if (pnm->code == NM_KILLFOCUS)
                {
                    _fHasFocus = FALSE;

                    //invalidate the item because tabbing away doesn't
                    RECT rc;

                    // Tree can focus and not have any items.
                    HTREEITEM hti = TreeView_GetSelection(_hwndTree);
                    if (hti)
                    {
                        TreeView_GetItemRect(_hwndTree, hti, &rc, FALSE);
                        //does this need to be UpdateWindow? only if focus rect gets left behind.
                        ::InvalidateRect(_hwndTree, &rc, FALSE);
                    }
                }
                else
                {
                    _fHasFocus = TRUE;
                }

                // do this for both set and kill focus...
                if (_dwFlags & NSS_MULTISELECT)
                {
                    HTREEITEM hti = TreeView_GetNextItem(_hwndTree, NULL, TVGN_FIRSTVISIBLE);
                    while (hti)
                    {
                        UINT uState = TreeView_GetItemState(_hwndTree, hti, NSC_TVIS_MARKED);
                        if (uState & NSC_TVIS_MARKED)
                        {
                            RECT rc;

                            TreeView_GetItemRect(_hwndTree, hti, &rc, FALSE);
                            //does this need to be UpdateWindow? only if focus rect gets left behind.
                            ::InvalidateRect(_hwndTree, &rc, FALSE);
                        }
                        hti = TreeView_GetNextItem(_hwndTree, hti, TVGN_NEXTVISIBLE);
                    }
                }
                break;

            case TVN_KEYDOWN:
                {
                    TV_KEYDOWN *ptvkd = (TV_KEYDOWN *) pnm;
                    switch (ptvkd->wVKey)
                    {
                    case VK_RETURN:
                    case VK_SPACE:
                        _OnSelChange(TRUE);
                        lres = TRUE;
                        break;

                    case VK_DELETE:
                        if (!((_mode & MODE_HISTORY) && IsInetcplRestricted(L"History")))
                        {
                            // in explorer band we never come here
                            // and in browse for folder we cannot ignore the selection
                            // because we will end up with nothing selected
                            if (_mode != MODE_NORMAL)
                                _fIgnoreNextSelChange = TRUE;
                            InvokeContextMenuCommand(L"delete");
                        }
                        break;

                    case VK_UP:
                    case VK_DOWN:
                        //VK_MENU == VK_ALT
                        if ((_mode != MODE_HISTORY) && (_mode != MODE_NORMAL) && (GetKeyState(VK_MENU) < 0))
                        {
                            MoveItemUpOrDown(ptvkd->wVKey == VK_UP);
                            lres = 0;
                            _fIgnoreNextSelChange = TRUE;
                        }
                        break;
                    
                    case VK_F2:
                        //only do this in org favs, because the band accel handler usually processes this
                        //SHBrowseForFolder doesn't have band to process it so do it in normal mode as well
                        if ((_mode & MODE_CONTROL) || _mode == MODE_NORMAL)
                            InvokeContextMenuCommand(L"rename");
                        break;

                    default:
                        break;
                    }
                        
                    if (!_fSingleExpand && !(_dwFlags & NSS_MULTISELECT))
                        _UpdateActiveBorder(TreeView_GetSelection(_hwndTree));
                }
                break;

            case TVN_SELCHANGINGA:
            case TVN_SELCHANGING:
                {
                    //hack because treeview keydown ALWAYS does it's default processing
                    if (_fIgnoreNextSelChange)
                    {
                        _fIgnoreNextSelChange = FALSE;
                        return TRUE;
                    }

                    NM_TREEVIEW * pnmtv = (NM_TREEVIEW *) pnm;

                    //if it's coming from somewhere weird (like a WM_SETFOCUS), don't let it select
                    return (pnmtv->action != TVC_BYKEYBOARD) && (pnmtv->action != TVC_BYMOUSE) && (pnmtv->action != TVC_UNKNOWN);
                }
                break;
                
            case TVN_SELCHANGEDA:
            case TVN_SELCHANGED:
                if (_fSelectFromMouseClick)
                {
                    _OnSetSelection();
                }
                else
                {
                    ::KillTimer(_hwndTree, IDT_SELECTION);
                    ::SetTimer(_hwndTree, IDT_SELECTION, GetDoubleClickTime(), NULL);
                }
                break;

            case TVN_GETDISPINFO:
                _OnGetDisplayInfo((TV_DISPINFO *)pnm);
                break;

            case TVN_ITEMEXPANDING: 
                TraceMsg(TF_NSC, "NSCBand: Expanding");
                if (!_fIgnoreNextItemExpanding)
                {
                    lres = _OnItemExpandingMsg((LPNM_TREEVIEW)pnm);
                }
                else if (!_fInExpand) // pretend we processed it if we are expanding to avoid recursion
                {
                    lres = TRUE;
                }
                break;
                
            case TVN_DELETEITEM:
                _OnDeleteItem((LPNM_TREEVIEW)pnm);
                break;
                
            case TVN_BEGINDRAG:
            case TVN_BEGINRDRAG:
                _OnBeginDrag((NM_TREEVIEW *)pnm);
                break;
                
            case TVN_BEGINLABELEDIT:
                //this is to prevent slow double-click rename in favorites and history
                if (_mode != MODE_NORMAL && !_fOkToRename)
                    return 1;

                lres = _OnBeginLabelEdit((TV_DISPINFO *)pnm);

                if (_punkSite)
                    IUnknown_UIActivateIO(_punkSite, TRUE, NULL);
                break;
                
            case TVN_ENDLABELEDIT:
                lres = _OnEndLabelEdit((TV_DISPINFO *)pnm);
                break;
                
            case TVN_SINGLEEXPAND:
            case NM_DBLCLK:
                break;
                
            case NM_CLICK:
            {
                //if someone clicks on the selected item, force a selection change (to force a navigate)
                DWORD dwPos = GetMessagePos();
                TV_HITTESTINFO tvht;
                HTREEITEM hti;
                tvht.pt.x = GET_X_LPARAM(dwPos);
                tvht.pt.y = GET_Y_LPARAM(dwPos);
                ::ScreenToClient(_hwndTree, &tvht.pt);
                hti = TreeView_HitTest(_hwndTree, &tvht);

                // But not if they click on the button, since that means that they
                // are merely expanding/contracting and not selecting
                if (hti && !(tvht.flags & TVHT_ONITEMBUTTON))
                {
                    _fSelectFromMouseClick = TRUE;
                    TreeView_SelectItem(_hwndTree, hti);
                    _OnSelChange(TRUE);
                    _fSelectFromMouseClick = FALSE;
                }
                break;
            }
                
            case NM_RCLICK:
            {
                DWORD dwPos = GetMessagePos();
                _fOkToRename = TRUE;
                lres = _OnContextMenu(GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos));
                _fOkToRename = FALSE;
                break;
            }
                
            default:
                break;
            }
        } // case ID_CONTROL

    case ID_HEADER:
        {
            switch (pnm->code) 
            {
            case HDN_TRACK:
                break;
                
            case HDN_ENDTRACK:
                ::InvalidateRect(_hwndTree, NULL, TRUE);
                break;
                
            default:
                break;
            }
        }

    default:
        break;
    }
    
    return lres;
}

HRESULT CNscTree::OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // review chrisny:  better error return here.
    _fHandlingShellNotification = TRUE;
    _OnChangeNotify(lEvent, pidl1, pidl2);
    _fHandlingShellNotification = FALSE;
    return S_OK;
}

// in comctl32 v5 there is no way to programmatically select an item (in single expand mode)
// without expanding it, so we fake it here by setting _fIgnoreNextItemExpanding to true and then
// rejecting expansion when it is set
void CNscTree::_SelectNoExpand(HWND hwnd, HTREEITEM hti)
{
    _fInExpand = TRUE; // Treeview will force expand the parents, make sure we know it's not the user clicking on items   
    TreeView_Select(hwnd, hti, TVGN_CARET | TVSI_NOSINGLEEXPAND);
    _fInExpand = FALSE;
    _fIgnoreNextItemExpanding = FALSE;
}

void CNscTree::_SelectPidl(LPCITEMIDLIST pidl, BOOL fCreate, BOOL fReinsert)
{ 
    HTREEITEM hti;
    // _ExpandToItem doesn't play well with empty pidl (i.e. desktop)
    if (_mode == MODE_NORMAL && ILIsEqual(pidl, _pidlRoot))
        hti = _FindFromRoot(NULL, pidl);
    else
        hti = _ExpandToItem(pidl, fCreate, fReinsert);
        
    if (hti != NULL)
    {
        _SelectNoExpand(_hwndTree, hti);
#ifdef DEBUG
        TraceHTREE(hti, TEXT("Found"));
#endif
    }
}

HTREEITEM CNscTree::_ExpandToItem(LPCITEMIDLIST pidl, BOOL fCreate /*= TRUE*/, BOOL fReinsert /*= FALSE*/)
{
    HTREEITEM       hti = NULL;
    LPITEMIDLIST    pidlItem = NULL;
    LPCITEMIDLIST   pidlTemp = NULL;
    LPITEMIDLIST pidlParent;
    TV_ITEM         tvi;
    IShellFolder    *psf = NULL;
    IShellFolder    *psfNext = NULL;
    HRESULT hr = S_OK;

#ifdef DEBUG
    TracePIDLAbs(pidl, TEXT("Attempting to select"));
#endif
    
    // We need to do this so items that are rooted at the Desktop, are found 
    // correctly.
    HTREEITEM htiParent = (_mode == MODE_NORMAL) ? TreeView_GetRoot(_hwndTree) : TVI_ROOT;
    ASSERT((_hwndTree != NULL) && (pidl != NULL));
    
    if (_hwndTree == NULL) 
        goto LGone;

    // We should unify the "FindFromRoot" code path and this one.
    pidlParent = _pidlRoot;
    if (ILIsEmpty(pidlParent))
    {
        pidlTemp = pidl;
        SHGetDesktopFolder(&psf);
    }
    else
    {
        if ((pidlTemp = ILFindChild(pidlParent, pidl)) == NULL)
        {
            goto LGone;    // not root match, no hti
        }

        // root match, carry on . . .   
        hr = IEBindToObject(pidlParent, &psf);
    }

    if (FAILED(hr))
    {
        goto LGone;
    }
    
    while (!ILIsEmpty(pidlTemp))
    {
        if ((pidlItem = ILCloneFirst(pidlTemp)) == NULL)
            goto LGone;
        pidlTemp = _ILNext(pidlTemp);

        // Since we are selecting a pidl, we need to make sure it's parent is visible.
        // We do it this before the insert, so that we don't have to check for duplicates.
        // when enumerating NTDev it goes from about 10min to about 8 seconds.
        if (htiParent != TVI_ROOT)
        {
            // Check to see if it's expanded.
            tvi.mask = TVIF_STATE;
            tvi.stateMask = (TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
            tvi.hItem = htiParent;
            if (!TreeView_GetItem(_hwndTree, &tvi))
            {
                goto LGone;
            }

            // If not, Expand it.
            if (!(tvi.state & TVIS_EXPANDED))
            {
                _pidlExpandingTo = pidlItem;
                _ExpandNode(htiParent, TVE_EXPAND, 1);
                _pidlExpandingTo = NULL;
            }
        }

        // Now that we have it enumerated, check to see if the child if there.
        hti = _FindChild(psf, htiParent, pidlItem);
        // fReinsert will allow us to force the item to be reinserted
        if (hti && fReinsert) 
        {
            ASSERT(fCreate);
            TreeView_DeleteItem(_hwndTree, hti);
            hti = NULL;
        }

        // Do we have a child in the newly expanded tree?
        if (NULL == hti)
        {
            // No. We must have to create it.
            if (!fCreate)
            {
                // But, we're not allowed to... Shoot.
                goto LGone;
            }

            if (S_OK != _InsertChild(htiParent, psf, pidlItem, FALSE, FALSE, DEFAULTORDERPOSITION, &hti))
            {
                goto LGone;
            }
        }

        if (htiParent != TVI_ROOT)
        {
            tvi.mask = TVIF_STATE;
            tvi.stateMask = (TVIS_EXPANDEDONCE | TVIS_EXPANDED | TVIS_EXPANDPARTIAL);
            tvi.hItem = htiParent;
            if (TreeView_GetItem(_hwndTree, &tvi))
            {
                if (!(tvi.state & TVIS_EXPANDED))
                {
                    TreeView_SetChildren(_hwndTree, htiParent, NSC_CHILDREN_ADD);  // Make sure the expand will do something
                    _fIgnoreNextItemExpanding = TRUE;
                    _ExpandNode(htiParent, TVE_EXPAND | TVE_EXPANDPARTIAL, 1);
                    _fIgnoreNextItemExpanding = FALSE;
                }
            }
        }

        // we don't need to bind if its the last one
        //   -- a half-implemented ISF might not like this bind...
        if (!ILIsEmpty(pidlTemp))
            hr = psf->BindToObject(pidlItem, NULL, IID_PPV_ARG(IShellFolder, &psfNext));

        ILFree(pidlItem);
        pidlItem = NULL;
        if (FAILED(hr))
            goto LGone;

        htiParent = hti;
        psf->Release();
        psf = psfNext;
        psfNext = NULL;
    }
LGone:
    
    if (psf != NULL)
        psf->Release();
    if (psfNext != NULL)
        psfNext->Release();
    if (pidlItem != NULL)
        ILFree(pidlItem);

    return hti;    
}


HRESULT CNscTree::GetSelectedItem(LPITEMIDLIST * ppidl, int nItem)
{
    HRESULT hr = E_INVALIDARG;

    // nItem will be used in the future when we support multiple selections.
    // GetSelectedItem() returns S_FALSE and (NULL == *ppidl) if not that many
    // items are selected.  Not yet implemented.
    if (nItem > 0)
    {
        *ppidl = NULL;
        return S_FALSE;
    }

    if (ppidl)
    {
        *ppidl = NULL;
        // Is the ListView still there?
        if (_fIsSelectionCached)
        {
            // No, so get the selection that was saved before
            // the listview was destroyed.
            if (_pidlSelected)
            {
                *ppidl = ILClone(_pidlSelected);
                hr = S_OK;
            }
            else
                hr = S_FALSE;
        }
        else
        {
            HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);
            if (htiSelected)
            {
                *ppidl = _GetFullIDList(htiSelected);
                hr = S_OK;
            }
            else
                hr = S_FALSE;
        }
    }

    return hr;
}


HRESULT CNscTree::SetSelectedItem(LPCITEMIDLIST pidl, BOOL fCreate, BOOL fReinsert, int nItem)
{
    // nItem will be used in the future when we support multiple selections.
    // Not yet implemented.
    if (nItem > 0)
    {
        return S_FALSE;
    }
    
    //  Override fCreate if the object no longer exists
    DWORD dwAttributes = SFGAO_VALIDATE;
    fCreate = fCreate && SUCCEEDED(IEGetAttributesOf(pidl, &dwAttributes));
    
    //  We probably haven't seen the ChangeNotify yet, so we tell
    //  _SelectPidl to create any folders that are there
    //  Then select the pidl, expanding as necessary
    _fInSelectPidl = TRUE;
    _SelectPidl(pidl, fCreate, fReinsert);
    _fInSelectPidl = FALSE;

    return S_OK;
}

//***   CNscTree::IWinEventHandler
HRESULT CNscTree::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    HRESULT hr = E_FAIL;

    ULONG_PTR cookie = 0;
    // FUSION: When nsc calls out to 3rd party code we want it to use 
    // the process default context. This means that the 3rd party code will get
    // v5 in the explorer process. However, if shell32 is hosted in a v6 process,
    // then the 3rd party code will still get v6. 
    // Future enhancements to this codepath may include using the fusion manifest
    // tab <noinherit> which basically surplants the activat(null) in the following
    // codepath. This disables the automatic activation from user32 for the duration
    // of this wndproc, essentially doing this null push.
    // we need to do this here as well as in _SubClassTreeWndProc as someone could have
    // set v6 context before getting in here (band site,...)
    NT5_ActivateActCtx(NULL, &cookie); 

    switch (uMsg) 
    {
    case WM_NOTIFY:
        *plres = _OnNotify((LPNMHDR)lParam);
        hr = S_OK;
        break;
        
    case WM_PALETTECHANGED:
        _OnPaletteChanged(wParam, lParam);
        // are we really supposed to return E_FAIL here?
        break;

    default:
        break;
    }

    if (cookie != 0)
        NT5_DeactivateActCtx(cookie);

    return hr;
}


void CNscTree::_OnChangeNotify(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra)
{
    switch (lEvent)
    {
    case SHCNE_RENAMEFOLDER:
    case SHCNE_RENAMEITEM:
        if (pidl && pidlExtra)
            _OnSHNotifyRename(pidl, pidlExtra);
        else
            ASSERT(FALSE);
        
        break;
        
    case SHCNE_DELETE:
    case SHCNE_RMDIR:
    case SHCNE_DRIVEREMOVED:
        if (pidl)
            _OnSHNotifyDelete(pidl, NULL, NULL);
        else
            ASSERT(FALSE);
        break;


    case SHCNE_UPDATEITEM:
        // when nsc browses other namespaces, sometimes an updateitem could be fired
        // on a pidl thats actually expanded in the tree, so check for it.
        if (pidl)
        {
            IShellFolder* psf = NULL;
            LPCITEMIDLIST pidlChild;
            if (SUCCEEDED(_ParentFromItem(pidl, &psf, &pidlChild)))
            {
                LPITEMIDLIST pidlReal;
                if (SUCCEEDED(_IdlRealFromIdlSimple(psf, pidlChild, &pidlReal)) && pidlReal)
                {
                    // zip files receive updateitem when they really mean updatedir
                    if (SHGetAttributes(psf, pidlReal, SFGAO_FOLDER | SFGAO_STREAM) == (SFGAO_FOLDER | SFGAO_STREAM))
                    {
                        _OnSHNotifyUpdateDir(pidl);
                    }
                    _OnSHNotifyUpdateItem(pidl, pidlReal);
                    ILFree(pidlReal);
                }
                psf->Release();
            }
        }
        break;

    case SHCNE_NETSHARE:
    case SHCNE_NETUNSHARE:
        if (pidl)
            _OnSHNotifyUpdateItem(pidl, NULL);
        break;

    case SHCNE_CREATE:
    case SHCNE_MKDIR:
    case SHCNE_DRIVEADD:
        if (pidl)
        {
            _OnSHNotifyCreate(pidl, DEFAULTORDERPOSITION, NULL);
            if (SHCNE_MKDIR == lEvent &&
                _pidlNewFolderParent &&
                ILIsParent(_pidlNewFolderParent, pidl, TRUE)) // TRUE = immediate parent only
            {
                _EnterNewFolderEditMode(pidl);
            }
        }
        break;

    case SHCNE_UPDATEDIR:
        if (pidl)
        {
            _OnSHNotifyUpdateDir(pidl);
        }
        break;

    case SHCNE_MEDIAREMOVED:
    case SHCNE_MEDIAINSERTED:
        if (pidl)
        {
            HTREEITEM hti = _FindFromRoot(NULL, pidl);
            if (hti)
            {
                if (lEvent == SHCNE_MEDIAREMOVED)
                {
                    TreeView_DeleteChildren(_hwndTree, hti);
                    TreeView_Expand(_hwndTree, hti, TVE_COLLAPSE | TVE_COLLAPSERESET); // reset the item
                    TreeView_SetChildren(_hwndTree, hti, NSC_CHILDREN_REMOVE);
                }
                else
                {
                    TreeView_SetChildren(_hwndTree, hti, NSC_CHILDREN_CALLBACK);
                }
                
                _TreeInvalidateItemInfo(hti, TVIF_TEXT);
            }
        }
        break;
        
    case SHCNE_DRIVEADDGUI:
    case SHCNE_SERVERDISCONNECT:
    case SHCNE_ASSOCCHANGED:
        break;

    case SHCNE_UPDATEIMAGE:
        if (pidl) 
        {
            int iIndex;
            if (pidlExtra)
            {   // new style update image notification.....
                iIndex = SHHandleUpdateImage(pidlExtra);
                if (iIndex == -1)
                    break;
            }
            else
                iIndex = *(int UNALIGNED *)((BYTE*)pidl + 2);
            
            _InvalidateImageIndex(NULL, iIndex);
        }
        break;
    case SHCNE_EXTENDED_EVENT:
        {
            SHChangeDWORDAsIDList UNALIGNED *pdwidl = (SHChangeDWORDAsIDList UNALIGNED *)pidl;
            
            INT_PTR iEvent = pdwidl->dwItem1;

            switch (iEvent)
            {
            case SHCNEE_ORDERCHANGED:
                if (pidl)
                {
                    if (_fDropping ||                           // If WE are dropping.
                        _fInLabelEdit ||                        // We're editing a name (Kicks us out)
                        SHChangeMenuWasSentByMe(this, pidl)  || // Ignore if we sent it.
                        (_mode == MODE_HISTORY))                // Always ignore history changes
                    {
                        TraceMsg(TF_NSC, "NSCBand: Ignoring Change Notify: We sent");
                        //ignore the notification                    
                    }
                    else
                    {
                        TraceMsg(TF_BAND, "NSCBand: OnChange SHCNEE_ORDERCHANGED accepted");
                        
                        _dwOrderSig++;

                        HTREEITEM htiRoot = _FindFromRoot(TVI_ROOT, pidlExtra);
                        if (htiRoot != NULL)
                            _UpdateDir(htiRoot, FALSE);
                    }
                }
                break;
            case SHCNEE_WININETCHANGED:
                {
                    if (pdwidl->dwItem2 & (CACHE_NOTIFY_SET_ONLINE | CACHE_NOTIFY_SET_OFFLINE))
                    {
                        BOOL fOnline = !SHIsGlobalOffline();
                        if ((fOnline && !_fOnline) || (!fOnline && _fOnline))
                        {
                            // State changed
                            _fOnline = fOnline;
                            _OnSHNotifyOnlineChange(TVI_ROOT, _fOnline);
                        }
                    }
                    
                    if (pdwidl->dwItem2 & (CACHE_NOTIFY_ADD_URL |
                        CACHE_NOTIFY_DELETE_URL |   
                        CACHE_NOTIFY_DELETE_ALL |
                        CACHE_NOTIFY_URL_SET_STICKY |
                        CACHE_NOTIFY_URL_UNSET_STICKY))
                    {
                        // Something in the cache changed
                        _OnSHNotifyCacheChange(TVI_ROOT, pdwidl->dwItem2);
                    }
                    break;
                }
            }
            break;
        }
        break;
    }
    return;
}

// note, this duplicates SHGetRealIDL() so we work in non integrated shell mode
// WARNING: if it is not a file system pidl SFGAO_FILESYSTEM, we don't need to do this...
// but this is only called in the case of SHCNE_CREATE for shell notify
// and all shell notify pidls are SFGAO_FILESYSTEM
HRESULT CNscTree::_IdlRealFromIdlSimple(IShellFolder *psf, LPCITEMIDLIST pidlSimple, LPITEMIDLIST *ppidlReal)
{
    WCHAR wszPath[MAX_PATH];
    ULONG cbEaten;
    HRESULT hr = S_OK;
    if (ILIsEmpty(pidlSimple) ||
        FAILED(DisplayNameOf(psf, pidlSimple, SHGDN_FORPARSING | SHGDN_INFOLDER, wszPath, ARRAYSIZE(wszPath))) ||
        FAILED(psf->ParseDisplayName(NULL, NULL, wszPath, &cbEaten, ppidlReal, NULL)))
    {
        hr = SHILClone(pidlSimple, ppidlReal);   // we don't own the lifetime of pidlSimple
    }
    return hr;
}


HRESULT CNscTree::Refresh(void)
{
    _bSynchId++;
    if (_bSynchId >= 16)
        _bSynchId = 0;

    TraceMsg(TF_NSC, "Expensive Refresh of tree");
    _htiActiveBorder = NULL;
    HRESULT hr = S_OK;
    if (_pnscProxy)
    {
        DWORD dwStyle, dwExStyle;
        if (SUCCEEDED(_pnscProxy->RefreshFlags(&dwStyle, &dwExStyle, &_grfFlags)))
        {
            dwStyle = _SetStyle(dwStyle); // initializes new _style and returns old one
            if ((dwStyle ^ _style) & ~WS_VISIBLE) // don't care if only visible changed
            {
                DWORD dwMask = (_style | dwStyle) & ~WS_VISIBLE; // don't want to change visible style
                SetWindowBits(_hwndTree, GWL_STYLE, dwMask, _style);
            }

            dwExStyle = _SetExStyle(dwExStyle);
            if (dwExStyle != _dwExStyle)
                TreeView_SetExtendedStyle(_hwndTree, _dwExStyle, dwExStyle | _dwExStyle);
        }
    }

    if (MODE_NORMAL == _mode)
    {
        BOOL fOrdered;
        _fUpdate = TRUE;
        _StartBackgroundEnum(TreeView_GetChild(_hwndTree, TVI_ROOT), _pidlRoot, &fOrdered, TRUE);
        _fUpdate = FALSE;
    }
    else
    {
        LPITEMIDLIST pidlRoot;
        hr = SHILClone(_pidlRoot, &pidlRoot);    // Need to do this because it's freed
        if (SUCCEEDED(hr))
        {
            HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);
            TV_ITEM tvi;
            tvi.mask = TVIF_HANDLE | TVIF_STATE;
            tvi.stateMask = TVIS_EXPANDED;
            tvi.hItem = (HTREEITEM)htiSelected;
            BOOL fExpanded = (TreeView_GetItem(_hwndTree, &tvi) && (tvi.state & TVIS_EXPANDED));

            LPITEMIDLIST pidlSelect;
            GetSelectedItem(&pidlSelect, 0);
            
            _ChangePidlRoot(pidlRoot);
            if (pidlSelect)
            {
                _Expand(pidlSelect, fExpanded ? 1 : 0);
                ILFree(pidlSelect);
            }

            ILFree(pidlRoot);
        }
    }

    return hr;
}

void CNscTree::_CacheDetails()
{
    if (_ulDisplayCol == (ULONG)-1)
    {        
        _ulSortCol = _ulDisplayCol = 0;
        
        if (_psf2Cache)
        {
            _psf2Cache->GetDefaultColumn(0, &_ulSortCol, &_ulDisplayCol);
        }
    }
}

HRESULT CNscTree::_GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, 
                                    LPSHELLDETAILS pdetails)
{
    ASSERT(_psfCache);
    _CacheDetails();
    if (_ulDisplayCol)
        return _psf2Cache->GetDetailsOf(pidl, _ulDisplayCol, pdetails);
    return _psfCache->GetDisplayNameOf(pidl, uFlags, &pdetails->str);
}

// if fSort, then compare for sort, else compare for existence.
HRESULT CNscTree::_CompareIDs(IShellFolder *psf, LPITEMIDLIST pidl1, LPITEMIDLIST pidl2)
{
    _CacheDetails();

    return psf->CompareIDs(_ulSortCol, pidl1, pidl2);
}

HRESULT CNscTree::_ParentFromItem(LPCITEMIDLIST pidl, IShellFolder** ppsfParent, LPCITEMIDLIST *ppidlChild)
{
    return IEBindToParentFolder(pidl, ppsfParent, ppidlChild);
} 

COLORREF CNscTree::_GetRegColor(COLORREF clrDefault, LPCTSTR pszName)
{
    // Fetch the specified alternate color

    COLORREF clrValue;
    DWORD cbData = sizeof(clrValue);
    if (FAILED(SKGetValue(SHELLKEY_HKCU_EXPLORER, NULL, pszName, NULL, &clrValue, &cbData)))
    {
        return clrDefault;
    }
    return clrValue;
}

LRESULT CNscTree::_OnCDNotify(LPNMCUSTOMDRAW pnm)
{
    LRESULT     lres = CDRF_DODEFAULT;

    ASSERT(pnm->hdr.idFrom == ID_CONTROL);

    if (_dwFlags & NSS_NORMALTREEVIEW)
    {
        LPNMTVCUSTOMDRAW pnmTVCustomDraw = (LPNMTVCUSTOMDRAW) pnm;
        if (pnmTVCustomDraw->nmcd.dwDrawStage == CDDS_PREPAINT)
        {
            if (_fShowCompColor)
            {
                return CDRF_NOTIFYITEMDRAW;
            }
            else
            {
                return lres;
            }
        }

        if (pnmTVCustomDraw->nmcd.dwDrawStage == CDDS_ITEMPREPAINT)
        {
            PORDERITEM pOrderItem = GetPoi(pnmTVCustomDraw->nmcd.lItemlParam);
            if (pOrderItem && pOrderItem->pidl)
            {
                LPCITEMIDLIST pidl = _CacheParentShellFolder((HTREEITEM)pnmTVCustomDraw->nmcd.dwItemSpec, pOrderItem->pidl);
                if (pidl)
                {
                    DWORD dwAttribs = SHGetAttributes(_psfCache, pidl, SFGAO_COMPRESSED | SFGAO_ENCRYPTED);
                    // either compressed, or encrypted, can never be both
                    if (dwAttribs & SFGAO_COMPRESSED)
                    {
                        // If it is the item is hi-lited (selected, and has focus), blue text is not visible with the hi-lite...
                        if ((pnmTVCustomDraw->nmcd.uItemState & CDIS_SELECTED) && (pnmTVCustomDraw->nmcd.uItemState & CDIS_FOCUS))
                            pnmTVCustomDraw->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                        else
                            pnmTVCustomDraw->clrText = _GetRegColor(RGB(0, 0, 255), TEXT("AltColor"));  // default Blue
                    }
                    else if (dwAttribs & SFGAO_ENCRYPTED)
                    {
                        if ((pnmTVCustomDraw->nmcd.uItemState & CDIS_SELECTED) && (pnmTVCustomDraw->nmcd.uItemState & CDIS_FOCUS))
                            pnmTVCustomDraw->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                        else
                            pnmTVCustomDraw->clrText = _GetRegColor(RGB(19, 146, 13), TEXT("AltEncryptionColor")); // default Luna Mid Green
                    }
                }
            }
        }

        return lres;
    }

    switch (pnm->dwDrawStage) 
    {
    case CDDS_PREPAINT:
        if (NSS_BROWSERSELECT & _dwFlags)
            lres = CDRF_NOTIFYITEMDRAW;
        break;
        
    case CDDS_ITEMPREPAINT:
        {
            //APPCOMPAT davemi: why is comctl giving us empty rects?
            if (IsRectEmpty(&(pnm->rc)))
                break;
            PORDERITEM poi = GetPoi(pnm->lItemlParam);
            DWORD dwFlags = 0;
            COLORREF    clrBk, clrText;
            LPNMTVCUSTOMDRAW pnmtv = (LPNMTVCUSTOMDRAW)pnm;             
            TV_ITEM tvi;
            TCHAR sz[MAX_URL_STRING];
            tvi.mask = TVIF_TEXT | TVIF_HANDLE | TVIF_STATE;
            tvi.stateMask = TVIS_EXPANDED | TVIS_STATEIMAGEMASK | TVIS_DROPHILITED;
            tvi.pszText = sz;
            tvi.cchTextMax = ARRAYSIZE(sz);
            tvi.hItem = (HTREEITEM)pnm->dwItemSpec;
            if (!TreeView_GetItem(_hwndTree, &tvi))
                break;
            //
            //  See if we have fetched greyed/pinned information for this item yet 
            //
            ITEMINFO * pii = GetPii(pnm->lItemlParam);
            pii->fFetched = TRUE;

            if (pii->fGreyed && !(_mode & MODE_CONTROL))
                dwFlags |= DIGREYED;
            if (pii->fPinned)
                dwFlags |= DIPINNED;

            if (!pii->fNavigable)
                dwFlags |= DIFOLDER;
            
            dwFlags |= DIICON;
            
            if (_style & TVS_RTLREADING)
                dwFlags |= DIRTLREADING;

            clrBk   = TreeView_GetBkColor(_hwndTree);
            clrText = GetSysColor(COLOR_WINDOWTEXT);

            //if we're renaming an item, don't draw any text for it (otherwise it shows behind the item)
            if (tvi.hItem == _htiRenaming)
                sz[0] = 0;

            if (tvi.state & TVIS_EXPANDED)
                dwFlags |= DIFOLDEROPEN;
            
            if (!(_dwFlags & NSS_MULTISELECT) && ((pnm->uItemState & CDIS_SELECTED) || (tvi.state & TVIS_DROPHILITED)))
            {
                if (_fHasFocus || tvi.state & TVIS_DROPHILITED)
                {
                    clrBk = GetSysColor(COLOR_HIGHLIGHT);
                    clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                }
                else
                {
                    clrBk = GetSysColor(COLOR_BTNFACE);
                }
//                    dwFlags |= DIFOCUSRECT;
            }

            if (pnm->uItemState & CDIS_HOT)
            {
                if (!(_mode & MODE_CONTROL))
                    dwFlags |= DIHOT;
                clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);

                if (clrText == clrBk)
                    clrText = GetSysColor(COLOR_HIGHLIGHT);
            }

            if ((_dwFlags & NSS_MULTISELECT) && (pnm->uItemState & CDIS_SELECTED))
                dwFlags |= DIACTIVEBORDER | DISUBFIRST | DISUBLAST;

            if (tvi.state & NSC_TVIS_MARKED)
            {                
                if (_dwFlags & NSS_MULTISELECT)
                {
                    if (_fHasFocus)
                    {
                        clrBk = GetSysColor(COLOR_HIGHLIGHT);
                        clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                    }
                    else
                    {
                        clrBk = GetSysColor(COLOR_BTNFACE);
                    }
                }
                else
                {
                    dwFlags |= DIACTIVEBORDER;
                    //top level item
                    if (_IsTopParentItem((HTREEITEM)pnm->dwItemSpec)) 
                    {
                        dwFlags |= DISUBFIRST;
                        if (!(tvi.state & TVIS_EXPANDED))
                            dwFlags |= DISUBLAST;
                    }
                    else    // lower level items
                    {                                                                
                        dwFlags |= DISUBITEM;
                        if (((HTREEITEM)pnm->dwItemSpec) == _htiActiveBorder)
                            dwFlags |= DISUBFIRST;
                        
                        HTREEITEM hti = TreeView_GetNextVisible(_hwndTree, (HTREEITEM)pnm->dwItemSpec);
                        if ((hti && !_IsMarked(hti)) || (hti == NULL))
                            dwFlags |= DISUBLAST;
                    }
                }
            }

            if ((_dwFlags & NSS_HEADER) && _hwndHdr && 
                    _CacheParentShellFolder((HTREEITEM)pnm->dwItemSpec, poi->pidl) && 
                    _psf2Cache)
            {
                // with header we don't draw active order because it looks ugly,
                // but with multiselect we do because that's how we differentiate selected items
                if (!(_dwFlags & NSS_MULTISELECT))
                    dwFlags &= ~DIACTIVEBORDER;
                    
                RECT rc;

                CopyRect(&rc, &(pnm->rc));
                for (int i=0; i<DPA_GetPtrCount(_hdpaColumns); i++)
                {
                    RECT rcHeader;
                    int iLevel = 0;
                    HEADERINFO *phinfo = (HEADERINFO *)DPA_GetPtr(_hdpaColumns, i);
                    
                    ASSERT(phinfo);
                    Header_GetItemRect(_hwndHdr, i, &rcHeader);
                    rc.left = rcHeader.left;
                    rc.right = rcHeader.right;
                    if (i == 0) //it is name column
                    {
                        iLevel = pnmtv->iLevel;
                        //use sz set above in the function
                    }
                    else
                    {
                        // in multiselect draw border only around the name
                        dwFlags &= ~DIACTIVEBORDER;
                        dwFlags = 0;
                        if (phinfo->fmt & LVCFMT_RIGHT)
                            dwFlags |= DIRIGHT;
                        clrBk   = TreeView_GetBkColor(_hwndTree);
                        clrText = GetSysColor(COLOR_WINDOWTEXT);

                        sz[0] = 0;

                        VARIANT var;
                        if (SUCCEEDED(_psf2Cache->GetDetailsEx(poi->pidl, phinfo->pscid, &var)))
                        {
                            VariantToStr(&var, sz, ARRAYSIZE(sz));
                        }
                    }
                    _DrawItem((HTREEITEM)pnm->dwItemSpec, sz, pnm->hdc, &rc, dwFlags, iLevel, clrBk, clrText);
                }
            }
            else
            {
                _DrawItem((HTREEITEM)pnm->dwItemSpec, sz, pnm->hdc, &(pnm->rc), dwFlags, pnmtv->iLevel, clrBk, clrText);
            }
            lres = CDRF_SKIPDEFAULT;
            break;
        }
    case CDDS_POSTPAINT:
        break;
    }
    
    return lres;
} 

// *******droptarget implementation.
void CNscTree::_DtRevoke()
{
    if (_fDTRegistered)
    {
        RevokeDragDrop(_hwndTree);
        _fDTRegistered = FALSE;
    }
}

void CNscTree::_DtRegister()
{
    if (!_fDTRegistered && (_dwFlags & NSS_DROPTARGET))
    {
        if (::IsWindow(_hwndTree))
        {
            HRESULT hr = THR(RegisterDragDrop(_hwndTree, SAFECAST(this, IDropTarget*)));
            _fDTRegistered = BOOLIFY(SUCCEEDED(hr));
        }
        else
            ASSERT(FALSE);
    }
}

HRESULT CNscTree::GetWindowsDDT(HWND * phwndLock, HWND * phwndScroll)
{
    if (!::IsWindow(_hwndTree))
    {
        ASSERT(FALSE);
        return S_FALSE;
    }
    *phwndLock = /*_hwndDD*/_hwndTree;
    *phwndScroll = _hwndTree;
    return S_OK;
}
const int iInsertThresh = 6;

// We use this as the sentinal "This is where you started"
#define DDT_SENTINEL ((DWORD_PTR)(INT_PTR)-1)

HRESULT CNscTree::HitTestDDT(UINT nEvent, LPPOINT ppt, DWORD_PTR *pdwId, DWORD * pdwDropEffect)
{                                              
    switch (nEvent)
    {
    case HTDDT_ENTER:
        break;
        
    case HTDDT_LEAVE:
    {
        _fDragging = FALSE; 
        _fDropping = FALSE; 
        DAD_ShowDragImage(FALSE);
        TreeView_SetInsertMark(_hwndTree, NULL, !_fInsertBefore);
        TreeView_SelectDropTarget(_hwndTree, NULL);
        DAD_ShowDragImage(TRUE);
        break;
    }
        
    case HTDDT_OVER: 
        {
            // review chrisny:  make function TreeView_InsertMarkHittest!!!!!
            RECT rc;
            TV_HITTESTINFO tvht;
            HTREEITEM htiOver;     // item to insert before or after.
            BOOL fWasInserting = BOOLIFY(_fInserting);
            BOOL fOldInsertBefore = BOOLIFY(_fInsertBefore);
            TV_ITEM tvi;
            PORDERITEM poi = NULL;
            IDropTarget     *pdtgt = NULL;
            HRESULT hr;
            LPITEMIDLIST    pidl;
        
            _fDragging = TRUE;
            *pdwDropEffect = DROPEFFECT_NONE;   // dropping from without.
            tvht.pt = *ppt;
            htiOver = TreeView_HitTest(_hwndTree, &tvht);
            // if no hittest assume we are dropping on the evil root.
            if (htiOver != NULL)
            {
                TreeView_GetItemRect(_hwndTree, (HTREEITEM)htiOver, &rc, TRUE);
                tvi.mask = TVIF_STATE | TVIF_PARAM | TVIF_HANDLE;
                tvi.stateMask = TVIS_EXPANDED;
                tvi.hItem = (HTREEITEM)htiOver;
                if (TreeView_GetItem(_hwndTree, &tvi))
                    poi = GetPoi(tvi.lParam);
                if (poi == NULL)
                {
                    ASSERT(FALSE);
                    return S_FALSE;
                }
            }
            else if (_mode != MODE_NORMAL) //need parity with win2k Explorer band
            {
                htiOver = TVI_ROOT;
            }

            // NO DROPPY ON HISTORY
            if (_mode & MODE_HISTORY)   
            {
                *pdwId = (DWORD_PTR)(htiOver);
                *pdwDropEffect = DROPEFFECT_NONE;   // dropping from without.
                return S_OK;
            }

            pidl = (poi == NULL) ? _pidlRoot : poi->pidl;
            pidl = _CacheParentShellFolder(htiOver, pidl);
            if (pidl)
            {
                // Is this the desktop pidl?
                if (ILIsEmpty(pidl))
                {
                    // Desktop's GetUIObject does not support the Empty pidl, so
                    // create the view object.
                    hr = _psfCache->CreateViewObject(_hwndTree, IID_PPV_ARG(IDropTarget, &pdtgt));
                }
                else
                    hr = _psfCache->GetUIObjectOf(_hwndTree, 1, (LPCITEMIDLIST *)&pidl, IID_PPV_ARG_NULL(IDropTarget, &pdtgt));
            }

            _fInserting = ((htiOver != TVI_ROOT) && ((ppt->y < (rc.top + iInsertThresh) 
                || (ppt->y > (rc.bottom - iInsertThresh)))  || !pdtgt));
            // review chrisny:  do I need folderstart == folder over?
            // If in normal mode, we never want to insert before, always _ON_...
            if (_mode != MODE_NORMAL && _fInserting)
            {
                ASSERT(poi);
                _iDragDest = poi->nOrder;   // index of item within folder pdwId
                if ((ppt->y < (rc.top + iInsertThresh)) || !pdtgt)
                    _fInsertBefore = TRUE;
                else
                {
                    ASSERT (ppt->y > (rc.bottom - iInsertThresh));
                    _fInsertBefore = FALSE;
                }
                if (_iDragSrc != -1)
                    *pdwDropEffect = DROPEFFECT_MOVE;   // moving from within.
                else
                    *pdwDropEffect = DROPEFFECT_NONE;   // dropping from without.
                // inserting, drop target is actually parent folder of this item
                if (_fInsertBefore || ((htiOver != TVI_ROOT) && !(tvi.state & TVIS_EXPANDED)))
                {
                    _htiDropInsert = TreeView_GetParent(_hwndTree, (HTREEITEM)htiOver);
                }
                else
                    _htiDropInsert = htiOver;
                if (_htiDropInsert == NULL)
                    _htiDropInsert = TVI_ROOT;
                *pdwId = (DWORD_PTR)(_htiDropInsert);
            }
            else
            {
                _htiDropInsert = htiOver;
                *pdwId = (DWORD_PTR)(htiOver);
                _iDragDest = -1;     // no insertion point.
                *pdwDropEffect = DROPEFFECT_NONE;
            }

            // if we're over the item we're dragging, don't allow drop here
            if ((_htiDragging == htiOver) || (IsParentOfItem(_hwndTree, _htiDragging, htiOver)))
            {
                *pdwDropEffect = DROPEFFECT_NONE;
                *pdwId = DDT_SENTINEL;
                _fInserting = FALSE;
                ATOMICRELEASE(pdtgt);
            }

            // update UI
            if (_htiCur != (HTREEITEM)htiOver || fWasInserting != BOOLIFY(_fInserting) || fOldInsertBefore != BOOLIFY(_fInsertBefore))
            {
                // change in target
                _dwLastTime = GetTickCount();     // keep track for auto-expanding the tree
                DAD_ShowDragImage(FALSE);
                if (_fInserting)
                {
                    TraceMsg(TF_NSC, "NSCBand: drop insert now");
                    if (htiOver != TVI_ROOT)
                    {
                        if (_mode != MODE_NORMAL)
                        {
                            TreeView_SelectDropTarget(_hwndTree, NULL);
                            TreeView_SetInsertMark(_hwndTree, htiOver, !_fInsertBefore);
                        }
                    }
                }
                else
                {
                    TraceMsg(TF_NSC, "NSCBand: drop select now");
                    if (_mode != MODE_NORMAL)
                        TreeView_SetInsertMark(_hwndTree, NULL, !_fInsertBefore);

                    if (htiOver != TVI_ROOT)
                    {
                        if (pdtgt)
                        {
                            TreeView_SelectDropTarget(_hwndTree, htiOver);       
                        }
                        else if (_mode != MODE_NORMAL)
                        {
                            // We do not want to select the drop target in normal mode
                            // because it causes a weird flashing of some item unrelated
                            // to the drag and drop when the drop is not supported.
                            TreeView_SelectDropTarget(_hwndTree, NULL);
                        }
                    }
                }
                ::UpdateWindow(_hwndTree);
                DAD_ShowDragImage(TRUE);
            }
            else
            {
                // No target change
                // auto expand the tree
                if (_htiCur)
                {
                    DWORD dwNow = GetTickCount();
                    if ((dwNow - _dwLastTime) >= 1000)
                    {
                        _dwLastTime = dwNow;
                        DAD_ShowDragImage(FALSE);
                        _fAutoExpanding = TRUE;
                        if (_htiCur != TVI_ROOT)
                            TreeView_Expand(_hwndTree, _htiCur, TVE_EXPAND);
                        _fAutoExpanding = FALSE;
                        ::UpdateWindow(_hwndTree);
                        DAD_ShowDragImage(TRUE);
                    }
                }
            }
            _htiCur = (HTREEITEM)htiOver; 
            ATOMICRELEASE(pdtgt);
        }
        break;
    }
    
    return S_OK;
}

HRESULT CNscTree::GetObjectDDT(DWORD_PTR dwId, REFIID riid, void **ppv)
{
    HRESULT hr = S_FALSE;

    if (dwId != DDT_SENTINEL)
    {
        LPCITEMIDLIST pidl = _CacheParentShellFolder((HTREEITEM)dwId, NULL);
        if (pidl)
        {
            if (ILIsEmpty(pidl))
                hr = _psfCache->CreateViewObject(_hwndTree, riid, ppv);
            else
                hr = _psfCache->GetUIObjectOf(_hwndTree, 1, &pidl, riid, NULL, ppv);
        }
    }
    return hr;
}

HRESULT CNscTree::OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr;
    
    _fAsyncDrop = FALSE;                //ASSUME
    _fDropping = TRUE;

    // move within same folder, else let Drop() handle it.
    if (_iDragSrc >= 0)
    {
        if (_htiFolderStart == _htiDropInsert && _mode != MODE_NORMAL)
        {
            if (_iDragSrc != _iDragDest)    // no moving needed
            {
                int iNewPos = _fInsertBefore ? (_iDragDest - 1) : _iDragDest;
                if (_MoveNode(_iDragSrc, iNewPos, _pidlDrag))
                {
                    TraceMsg(TF_NSC, "NSCBand:  Reordering");
                    _fDropping = TRUE;
                    _Dropped();
                    // Remove this notify message immediately (so _fDropping is set
                    // and we'll ignore this event in above OnChange method)
                    //
                    _FlushNotifyMessages(_hwndTree);
                    _fDropping = FALSE;
                }
                Pidl_Set(&_pidlDrag, NULL);
            }
            DragLeave();
            _htiCur = _htiFolderStart = NULL;
            _htiDropInsert =  (HTREEITEM)-1;
            _fDragging = _fInserting = _fDropping = FALSE;
            _iDragDest = -1;
            hr = S_FALSE;     // handled 
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        // the item will get created in SHNotifyCreate()
        TraceMsg(TF_NSC, "NSCBand:  Dropped and External Item");

        BOOL         fSafe = TRUE;
        LPITEMIDLIST pidl;

        if (SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0)))
        {
            fSafe = IEIsLinkSafe(_hwndParent, pidl, ILS_ADDTOFAV);
            ILFree(pidl);
        }

        if (fSafe)
        {
            _fAsyncDrop = TRUE;
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    TreeView_SetInsertMark(_hwndTree, NULL, !_fInsertBefore);
    TreeView_SelectDropTarget(_hwndTree, NULL);

    ILFree(_pidlDrag);
    _pidlDrag = NULL;

    return hr;
}

IStream * CNscTree::GetOrderStream(LPCITEMIDLIST pidl, DWORD grfMode)
{
    // only do this for favorites
    if (!ILIsEmpty(pidl) && (_mode & MODE_FAVORITES))
        return OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, pidl, REG_SUBKEY_FAVORITESA, grfMode);
    return NULL;
}

BOOL CNscTree::_MoveNode(int iDragSrc, int iNewPos, LPITEMIDLIST pidl)
{
    HTREEITEM hti, htiAfter = TVI_LAST, htiDel = NULL;
    
    // if we are not moving and not dropping directly on a folder with no insert.
    if ((iDragSrc == iNewPos) && (iNewPos != -1))
        return FALSE;       // no need to move

    int i = 0;
    for (hti = TreeView_GetChild(_hwndTree, _htiDropInsert); hti; hti = TreeView_GetNextSibling(_hwndTree, hti), i++) 
    {
        if (i == iDragSrc)
            htiDel = hti;       // save node to be deleted, can't deelete it while enumerating
        // cuz the treeview will go down the tubes.  
        if (i == iNewPos)
            htiAfter = hti;
    }
    
    if (iNewPos == -1)  // must be the first item
        htiAfter = TVI_FIRST;
    // add before delete to handle add after deleteable item case.
    _AddItemToTree(_htiDropInsert, pidl, I_CHILDRENCALLBACK, _iDragDest, htiAfter, FALSE);
    if (htiDel)
        TreeView_DeleteItem(_hwndTree, htiDel);

    _PopulateOrderList(_htiDropInsert);

    _fWeChangedOrder = TRUE;
    return TRUE;
}

void CNscTree::_Dropped(void)
{
    // Persist the new order out to the registry
    LPITEMIDLIST pidl = _GetFullIDList(_htiDropInsert);
    if (pidl)
    {
        IStream* pstm = GetOrderStream(pidl, STGM_WRITE | STGM_CREATE);
        if (pstm)
        {
            if (_CacheShellFolder(_htiDropInsert))
            {
#ifdef DEBUG
                if (_hdpaOrd)
                {
                    for (int i=0; i<DPA_GetPtrCount(_hdpaOrd); i++)
                    {
                        PORDERITEM poi = (PORDERITEM)DPA_GetPtr(_hdpaOrd, i);
                        if (poi)
                        {
                            ASSERTMSG(poi->nOrder >= 0, "nsc saving bogus order list nOrder (%d), get reljai", poi->nOrder);
                        }
                    }
                }
#endif

                OrderList_SaveToStream(pstm, _hdpaOrd, _psfCache);
                // remember we are now ordered.
                if (_htiDropInsert == TVI_ROOT)
                {
                    _fOrdered = TRUE;
                }
                else
                {
                    PORDERITEM poi = _GetTreeOrderItem(_htiDropInsert);
                    if (poi)
                    {
                        poi->lParam = (DWORD)FALSE;
                    }
                }
                // Notify everyone that the order changed
                SHSendChangeMenuNotify(this, SHCNEE_ORDERCHANGED, 0, pidl);
                _dwOrderSig++;
            }
            pstm->Release();
        }
        ILFree(pidl);
    }
    
    DPA_Destroy(_hdpaOrd);
    _hdpaOrd = NULL;

    _UpdateActiveBorder(_htiDropInsert);
}

CNscTree::CSelectionContextMenu::~CSelectionContextMenu()
{
    ATOMICRELEASE(_pcmSelection);
    ATOMICRELEASE(_pcm2Selection);
}

HRESULT CNscTree::CSelectionContextMenu::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CNscTree::CSelectionContextMenu, IContextMenu2),                      // IID_IContextMenu2
        QITABENTMULTI(CNscTree::CSelectionContextMenu, IContextMenu, IContextMenu2),   // IID_IContextMenu
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}


ULONG CNscTree::CSelectionContextMenu::AddRef(void)
{
    CComObject<CNscTree> *pnsc = IToClass(CComObject<CNscTree>, _scm, this);
    _ulRefs++;
    return pnsc->AddRef();
}

ULONG CNscTree::CSelectionContextMenu::Release(void)
{
    CComObject<CNscTree> *pnsc = IToClass(CComObject<CNscTree>, _scm, this);
    ASSERT(_ulRefs > 0);
    _ulRefs--;
    if (0 == _ulRefs)
    {
        ATOMICRELEASE(_pcmSelection);
        ATOMICRELEASE(_pcm2Selection);
    }
    return pnsc->Release();
}

HRESULT CNscTree::CSelectionContextMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, 
                                                          UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    if (NULL == _pcmSelection)
    {
        return E_FAIL;
    }
    else
    {
        return _pcmSelection->QueryContextMenu(hmenu, indexMenu, idCmdFirst, idCmdLast, uFlags);
    }
}

HRESULT CNscTree::CSelectionContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HTREEITEM hti;
    CNscTree* pnsc = IToClass(CNscTree, _scm, this);
    UINT idCmd;
    
    if (!HIWORD(pici->lpVerb))
    {
        idCmd = LOWORD(pici->lpVerb);
    }
    else
    {
        return E_FAIL;
    }
    
    HRESULT hr = pnsc->_QuerySelection(NULL, &hti);
    if (SUCCEEDED(hr))
    {
        pnsc->_ApplyCmd(hti, _pcmSelection, idCmd);
    }
    return hr;
}

HRESULT CNscTree::CSelectionContextMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_FAIL;
    if (_pcm2Selection)
    {
        hr = _pcm2Selection->HandleMenuMsg(uMsg,wParam,lParam);
    }
    return hr;
}

LRESULT CALLBACK CNscTree::s_SubClassTreeWndProc(
                                  HWND hwnd, UINT uMsg, 
                                  WPARAM wParam, LPARAM lParam,
                                  UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{

    CNscTree* pns = (CNscTree*)dwRefData;
    ASSERT(pns);
    if (pns == NULL)
        return 0;

    ULONG_PTR cookie = 0;
    // FUSION: When nsc calls out to 3rd party code we want it to use 
    // the process default context. This means that the 3rd party code will get
    // v5 in the explorer process. However, if shell32 is hosted in a v6 process,
    // then the 3rd party code will still get v6. 
    // Future enhancements to this codepath may include using the fusion manifest
    // tab <noinherit> which basically surplants the activat(null) in the following
    // codepath. This disables the automatic activation from user32 for the duration
    // of this wndproc, essentially doing this null push.
    NT5_ActivateActCtx(NULL, &cookie); 
    LRESULT lres = pns->_SubClassTreeWndProc(hwnd, uMsg, wParam, lParam);
    if (cookie != 0)
        NT5_DeactivateActCtx(cookie);

    return lres;
}

LRESULT CNscTree::_SubClassTreeWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    BOOL fCallDefWndProc = TRUE;
 
    switch (uMsg)
    {
    case WM_COMMAND:
        lres = _OnCommand(wParam, lParam);
        break;

    case WM_SIZE:
        // if the width changes, we need to invalidate to redraw the ...'s at the end of the lines
        if (GET_X_LPARAM(lParam) != _cxOldWidth) {
            //FEATURE: be a bit more clever and only inval the right part where the ... can be
            ::InvalidateRect(_hwndTree, NULL, FALSE);
            _cxOldWidth = GET_X_LPARAM(lParam);
        }
        break;
        
    case WM_CONTEXTMENU:
        _OnContextMenu(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        return TRUE;
        break;
        
    case WM_INITMENUPOPUP:
    case WM_MEASUREITEM:
    case WM_DRAWITEM:
        if (_pcmSendTo)
        {
            _pcmSendTo->HandleMenuMsg(uMsg, wParam, lParam);
            return TRUE;
        }
        break;

    case WM_NSCUPDATEICONOVERLAY:
        {
            NSC_OVERLAYCALLBACKINFO noci = {(DWORD) (lParam & 0x0FFFFFFF),
                                              (DWORD) ((lParam & 0xF0000000) >> 28) };
            // make sure the magic numbers match
            if (noci.nMagic == _bSynchId)
            {
                TVITEM    tvi;
                tvi.mask = TVIF_STATE;
                tvi.stateMask = TVIS_OVERLAYMASK;
                tvi.state = 0;
                tvi.hItem = (HTREEITEM)wParam;
                // This can fail if the item was moved before the async icon
                // extraction finished for that item.
                if (TreeView_GetItem(_hwndTree, &tvi))
                {
                    tvi.state = INDEXTOOVERLAYMASK(noci.iOverlayIndex);
                    TreeView_SetItem(_hwndTree, &tvi);
                }
            }
        }
        break;

    case WM_NSCUPDATEICONINFO:
        {
            NSC_ICONCALLBACKINFO nici = {(DWORD) (lParam&0x00000FFF),
                                         (DWORD) ((lParam&0x00FFF000) >> 12),
                                         (DWORD) ((lParam&0x0F000000) >> 24),
                                         (DWORD) ((lParam&0xF0000000) >> 28) };
            // make sure the magic numbers match
            if (nici.nMagic == _bSynchId)
            {
                TVITEM    tvi;
                tvi.mask = TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
                tvi.hItem = (HTREEITEM)wParam;

                // This can fail if the item was moved before the async icon
                // extraction finished for that item.
                if (TreeView_GetItem(_hwndTree, &tvi))
                {
                    ITEMINFO* pii = GetPii(tvi.lParam);

                    pii->fGreyed      = BOOLIFY(nici.nFlags & NSCICON_GREYED);
                    pii->fPinned      = BOOLIFY(nici.nFlags & NSCICON_PINNED);
                    pii->fDontRefetch = BOOLIFY(nici.nFlags & NSCICON_DONTREFETCH);

                    tvi.iImage         = nici.iIcon;
                    tvi.iSelectedImage = nici.iOpenIcon;

                    TreeView_SetItem(_hwndTree, &tvi);
                }
            }
        }
        break;

    case WM_NSCBACKGROUNDENUMDONE:
        {
            if (_fShouldShowAppStartCursor)
            {
                // Restore cursor now
                _fShouldShowAppStartCursor = FALSE;
                SetCursor(LoadCursor(NULL, IDC_ARROW));
            }
            NSC_BKGDENUMDONEDATA * pbedd;
            do
            {
                EnterCriticalSection(&_csBackgroundData);
                // Extract the first element of the list
                pbedd = _pbeddList;
                if (pbedd)
                {
                    _pbeddList = pbedd->pNext;
                }
                LeaveCriticalSection(&_csBackgroundData);
                if (pbedd)
                {
                    pbedd->pNext = NULL;
                    _EnumBackgroundDone(pbedd);
                }
            } while (pbedd);
        }
        break;


    // UGLY: Win95/NT4 shell DefView code sends this msg and does not deal
    // with the failure case. other ISVs do the same so this needs to stay forever
    case CWM_GETISHELLBROWSER:
        return (LRESULT)SAFECAST(this, IShellBrowser*);  // not ref counted!

    case WM_TIMER:
        if (wParam == IDT_SELECTION)
        {
            ::KillTimer(_hwndTree, IDT_SELECTION);
            _OnSetSelection();
        }
        break;
        
    case WM_HELP:
        {
            // Let controls provide thier own help (organize favorites). The default help
            // also doesn't make sence for history (really need separate help id for history)
            if (!(_mode & (MODE_CONTROL | MODE_HISTORY)))
            {
                if (_mode & MODE_FAVORITES)
                {
                    const static DWORD aBrowseHelpIDs[] = 
                    {  // Context Help IDs
                        ID_CONTROL,         IDH_ORGFAVS_LIST,
                        0,                  0
                    };
                    ::WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aBrowseHelpIDs);
                }
                else
                {
                    // default help
                    const static DWORD aBrowseHelpIDs[] = 
                    {  // Context Help IDs
                        ID_CONTROL,         IDH_BROWSELIST,
                        0,                  0
                    };
                    ::WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aBrowseHelpIDs);
                }
            }
        }
        break;

    case WM_SYSCOLORCHANGE:
    case WM_WININICHANGE:
        // _HandleWinIniChange does an item height calculation that
        // depends on treeview having computed the default item height
        // already.  So we need to let treeview handle the settings
        // change before calling _HandleWinIniChange.  Also, we need
        // to reset the height to default so that treeview will
        // calculate a new default.
        TreeView_SetItemHeight(hwnd, -1);
        lres = DefSubclassProc(hwnd, uMsg, wParam, lParam);
        _HandleWinIniChange();
        break;

    case WM_KEYDOWN:
        // Only do this when the CTRL key is not down
        if (GetKeyState(VK_CONTROL) >= 0)
        {
            if (wParam == VK_MULTIPLY)
            {
                // We set _pidlNavigatingTo to NULL here to ensure that we will be doing full expands.
                // When _pidlNavigatingTo is non null, we are doing partial expands by default, which is not
                // what we want here.
                Pidl_Set(&_pidlNavigatingTo, NULL);

                _uDepth = (UINT)-1; // to recursive expand all the way to the end
                lres = DefSubclassProc(hwnd, uMsg, wParam, lParam);
                _uDepth = 0;
                fCallDefWndProc = FALSE;        // Don't call DefSubclassProc again.
            }
        }
        break;

    default:
        break;
    }
    
    if (fCallDefWndProc && lres == 0)
       lres = DefSubclassProc(hwnd, uMsg, wParam, lParam);

    return lres;
}

HRESULT CNscTree::_OnPaletteChanged(WPARAM wParam, LPARAM lParam)
{
    // forward this to our child view by invalidating their window (they should never realize their palette
    // in the foreground so they don't need the message parameters.) ...
    RECT rc;
    ::GetClientRect(_hwndTree, &rc);
    ::InvalidateRect(_hwndTree, &rc, FALSE);
    
    return NOERROR;
}

void CNscTree::_InvalidateImageIndex(HTREEITEM hItem, int iImage)
{
    HTREEITEM hChild;
    TV_ITEM tvi;
    
    if (hItem)
    {
        tvi.mask = TVIF_SELECTEDIMAGE | TVIF_IMAGE;
        tvi.hItem = hItem;
        
        TreeView_GetItem(_hwndTree, &tvi);
        if (iImage == -1 || tvi.iImage == iImage || tvi.iSelectedImage == iImage) 
            _TreeInvalidateItemInfo(hItem, 0);
    }
    
    hChild = TreeView_GetChild(_hwndTree, hItem);
    if (!hChild)
        return;
    
    for (; hChild; hChild = TreeView_GetNextSibling(_hwndTree, hChild))
        _InvalidateImageIndex(hChild, iImage);
}

void CNscTree::_TreeInvalidateItemInfo(HTREEITEM hItem, UINT mask)
{
    TV_ITEM tvi;

    tvi.mask =  mask | TVIF_CHILDREN | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_STATE;
    tvi.stateMask = TVIS_OVERLAYMASK;
    tvi.state = 0;
    tvi.hItem = hItem;
    tvi.cChildren = I_CHILDRENCALLBACK;
    tvi.iImage = I_IMAGECALLBACK;
    tvi.iSelectedImage = I_IMAGECALLBACK;
    tvi.pszText = LPSTR_TEXTCALLBACK;
    TreeView_SetItem(_hwndTree, &tvi);
}

#define DXLEFT      8
#define MAGICINDENT 3
void CNscTree::_DrawIcon(HTREEITEM hti, HDC hdc, int iLevel, RECT *prc, DWORD dwFlags)
{
    HIMAGELIST  himl = TreeView_GetImageList(_hwndTree, TVSIL_NORMAL);
    TV_ITEM     tvi;
    int         dx, dy, x, y;
    
    tvi.mask = TVIF_SELECTEDIMAGE | TVIF_IMAGE | TVIF_HANDLE;
    tvi.hItem = hti;
    if (TreeView_GetItem(_hwndTree, &tvi))
    {
        ImageList_GetIconSize(himl, &dx, &dy);    
        if (!_fStartingDrag)
            x = DXLEFT;
        else
            x = 0;
        x += (iLevel * TreeView_GetIndent(_hwndTree)); // - ((dwFlags & DIFOLDEROPEN) ? 1 : 0);
        y = prc->top + (((prc->bottom - prc->top) - dy) >> 1);
        int iImage = (dwFlags & DIFOLDEROPEN) ? tvi.iSelectedImage : tvi.iImage;
        ImageList_DrawEx(himl, iImage, hdc, x, y, 0, 0, CLR_NONE, GetSysColor(COLOR_WINDOW), (dwFlags & DIGREYED) ? ILD_BLEND50 : ILD_TRANSPARENT); 
        
        if (dwFlags & DIPINNED)
        {
            ASSERT(_hicoPinned);    
            DrawIconEx(hdc, x, y, _hicoPinned, 16, 16, 0, NULL, DI_NORMAL);
        }
    }
    return;
}

#define TreeView_GetFont(hwnd)  (HFONT)::SendMessage(hwnd, WM_GETFONT, 0, 0)

void CNscTree::_DrawItem(HTREEITEM hti, TCHAR * psz, HDC hdc
                         , LPRECT prc, DWORD dwFlags, int iLevel, COLORREF clrbk, COLORREF clrtxt)
{
    SIZE        size;
    HIMAGELIST  himl = TreeView_GetImageList(_hwndTree, TVSIL_NORMAL);
    HFONT       hfont = NULL;
    HFONT       hfontOld = NULL;
    int         x, y, dx, dy;
    LOGFONT     lf;
    
    COLORREF clrGreyed = GetSysColor(COLOR_BTNSHADOW);
    if ((dwFlags & DIGREYED) && (clrbk != clrGreyed))
    {
        clrtxt = clrGreyed;
    }

    // For the history and favorites bars, we use the default
    // font (for UI consistency with the folders bar).

    if (_mode != MODE_FAVORITES && _mode != MODE_HISTORY)
        hfont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);

    if ((dwFlags & DIHOT) && !(dwFlags & DIFOLDER))
    {
        if (!hfont)
            hfont = TreeView_GetFont(_hwndTree);

        // create the underline font
        GetObject(hfont, sizeof(lf), &lf);
        lf.lfUnderline = TRUE;
        hfont = CreateFontIndirect(&lf);
    }
    
    if (hfont)
        hfontOld = (HFONT)SelectObject(hdc, hfont);
    GetTextExtentPoint32(hdc, psz, lstrlen(psz), &size);
    if (himl)
        ImageList_GetIconSize(himl, &dx, &dy);    
    else 
    {
        dx = 0;
        dy = 0;
    }
    x = prc->left + ((dwFlags & DIICON) ? (iLevel * TreeView_GetIndent(_hwndTree) + dx + DXLEFT + MAGICINDENT) : DXLEFT);
    if (_fStartingDrag)
        x -= DXLEFT;
    y = prc->top + (((prc->bottom - prc->top) - size.cy) >> 1);

    UINT eto = ETO_CLIPPED;
    RECT rc;
    rc.left = prc->left + 2;
    rc.top = prc->top;
    rc.bottom = prc->bottom;
    rc.right = prc->right - 2;

    SetBkColor(hdc, clrbk);
    eto |= ETO_OPAQUE;
    ExtTextOut(hdc, 0, 0, eto, &rc, NULL, 0, NULL);

    SetTextColor(hdc, clrtxt);
    rc.left = x;
    rc.top = y;
    rc.bottom = rc.top + size.cy;

    UINT uFormat = DT_VCENTER | DT_END_ELLIPSIS | DT_NOPREFIX;
    if (dwFlags & DIRIGHT)
        uFormat |= DT_RIGHT;
    if (dwFlags & DIRTLREADING)
        uFormat |= DT_RTLREADING;        
    DrawTextWrap(hdc, psz, lstrlen(psz), &rc, uFormat);

    if (dwFlags & DIICON)
        _DrawIcon(hti, hdc, iLevel, prc, dwFlags);
    if (hfontOld)
        SelectObject(hdc, hfontOld);

    if (dwFlags & DIACTIVEBORDER)
    {
        if (dwFlags & DIFIRST)
        {
            rc = *prc;
            rc.left += 2;
            rc.bottom = rc.top + 1;
            rc.right -= 2;
            SHFillRectClr(hdc, &rc, GetSysColor(COLOR_BTNSHADOW));
        }
        if (dwFlags & DISUBITEM)
        {
            rc = *prc;
            rc.left += 2;
            rc.right = rc.left + 1;
            SHFillRectClr(hdc, &rc, GetSysColor(COLOR_BTNSHADOW));
            rc.right = prc->right - 2;
            rc.left = rc.right - 1;
            SHFillRectClr(hdc, &rc, GetSysColor(COLOR_BTNSHADOW));
        }
        if (dwFlags & DILAST)
        {
            rc = *prc;
            rc.left += 2;
            rc.top = rc.bottom - 1;
            rc.right -= 2;
            SHFillRectClr(hdc, &rc, GetSysColor(COLOR_BTNSHADOW));
        }
    }

    if (hfont)
        DeleteObject(hfont);
}

//+-------------------------------------------------------------------------
// If going online, ungreys all items that were unavailable.  If going
// offline, refreshes all items to see if they are still available.
//--------------------------------------------------------------------------
void CNscTree::_OnSHNotifyOnlineChange(HTREEITEM htiRoot, BOOL fGoingOnline)
{
    HTREEITEM hItem;

    for (hItem = TreeView_GetChild(_hwndTree, htiRoot); hItem
        ; hItem = TreeView_GetNextSibling(_hwndTree, hItem)) 
    {
        ITEMINFO *pii = _GetTreeItemInfo(hItem);
        if (pii)
        {
            if (fGoingOnline)
            {
                // Going online, if previously greyed then ungrey it
                if (pii->fGreyed)
                {
                    pii->fGreyed = FALSE;
                    _UpdateItemDisplayInfo(hItem);
                }
            }
            else
            {
                // Recheck each item to see if they should be greyed
                if (pii->fFetched && !pii->fDontRefetch)
                {
                    pii->fFetched = FALSE;
                    _UpdateItemDisplayInfo(hItem);
                }
            }
        }
        // Inform children too
        _OnSHNotifyOnlineChange(hItem, fGoingOnline);
    }
}

//+-------------------------------------------------------------------------
// Force items to recheck to see if the should be pinned or greyed
//--------------------------------------------------------------------------
void CNscTree::_OnSHNotifyCacheChange
(
 HTREEITEM htiRoot,      // recurse through all children
 DWORD_PTR dwFlags       // CACHE_NOTIFY_* flags
)
{
    HTREEITEM hItem;

    for (hItem = TreeView_GetChild(_hwndTree, htiRoot); hItem
        ; hItem = TreeView_GetNextSibling(_hwndTree, hItem)) 
    {
        ITEMINFO *pii = _GetTreeItemInfo(hItem);
        if (pii)
        {
            // If we have cached info for this item, refresh it if it's state may have toggled
            if ((pii->fFetched && !pii->fDontRefetch) &&
                ((pii->fGreyed && (dwFlags & CACHE_NOTIFY_ADD_URL)) ||
                
                // We only need to check ungreyed items for changes to the 
                // stickey bit in the cache!
                (!pii->fGreyed &&
                ((dwFlags & (CACHE_NOTIFY_DELETE_URL | CACHE_NOTIFY_DELETE_ALL))) ||
                (!pii->fPinned && (dwFlags & CACHE_NOTIFY_URL_SET_STICKY)) ||
                (pii->fPinned && (dwFlags & CACHE_NOTIFY_URL_UNSET_STICKY))
               )
               ))
            {
                pii->fFetched = FALSE;
                _UpdateItemDisplayInfo(hItem);
            }
        }
        
        // Do it's children too
        _OnSHNotifyCacheChange(hItem, dwFlags);
    }
}

//
// Calls the appropriate routine in shdocvw to favorites import or export on
// the currently selected item
//
HRESULT CNscTree::DoImportOrExport(BOOL fImport)
{
    HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);
    LPITEMIDLIST pidl = _GetFullIDList(htiSelected);
    if (pidl)
    {
        //
        // If current selection is not a folder get the parent pidl
        //
        if (!ILIsFileSysFolder(pidl))
            ILRemoveLastID(pidl);
    
        //
        // Create the actual routine in shdocvw to do the import/export work
        //
        IShellUIHelper *pShellUIHelper;
        HRESULT hr = CoCreateInstance(CLSID_ShellUIHelper, NULL, CLSCTX_INPROC_SERVER,  IID_PPV_ARG(IShellUIHelper, &pShellUIHelper));
        if (SUCCEEDED(hr))
        {
            VARIANT_BOOL vbImport = fImport ? VARIANT_TRUE : VARIANT_FALSE;
            WCHAR wszPath[MAX_PATH];

            SHGetPathFromIDListW(pidl, wszPath);
        
            hr = pShellUIHelper->ImportExportFavorites(vbImport, wszPath);
            if (SUCCEEDED(hr) && fImport)
            {
                //
                // Successfully imported favorites so need to update view
                // FEATURE ie5 24973 - flicker alert, should optimize to just redraw selected
                //
                Refresh();
                //TreeView_SelectItem(_hwndTree, htiSelected);
            }
        
            pShellUIHelper->Release();
        }
        ILFree(pidl);
    }
    return S_OK;
}


HRESULT CNscTree::GetSelectedItemName(LPWSTR pszName, DWORD cchName)
{
    HRESULT hr = E_FAIL;
    TV_ITEM tvi = {0};

    tvi.hItem = TreeView_GetSelection(_hwndTree);
    if (tvi.hItem != NULL)
    {
        TCHAR szPath[MAX_PATH];
        
        tvi.mask = TVIF_HANDLE | TVIF_TEXT;
        tvi.pszText = szPath;
        tvi.cchTextMax = ARRAYSIZE(szPath);
        
        if (TreeView_GetItem(_hwndTree, &tvi))
        {
            SHTCharToUnicode(szPath, pszName, cchName);
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT CNscTree::BindToSelectedItemParent(REFIID riid, void **ppv, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_FAIL;
    if (!_fClosing)
    {
        LPCITEMIDLIST pidlItem = _CacheParentShellFolder(TreeView_GetSelection(_hwndTree), NULL);
        if (pidlItem)
        {
            hr = _psfCache->QueryInterface(riid, ppv);
            if (SUCCEEDED(hr) && ppidl)
            {
                *ppidl = ILClone(pidlItem);
                if (*ppidl == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    ((IUnknown *)*ppv)->Release();
                    *ppv = NULL;
                }
            }
        }
    }
    return hr;
}

// takes ownership of pidl
HRESULT CNscTree::RightPaneNavigationStarted(LPITEMIDLIST pidl)
{
    _fExpandNavigateTo = FALSE;
    _fNavigationFinished = FALSE;
    
    Pidl_Set(&_pidlNavigatingTo, pidl);
    return S_OK;
}

// takes ownership of pidl
HRESULT CNscTree::RightPaneNavigationFinished(LPITEMIDLIST pidl)
{
    HRESULT hr = S_OK;

    _fNavigationFinished = TRUE;
    if (_fExpandNavigateTo)
    {
        _fExpandNavigateTo = FALSE; // only do this once

        hr = E_OUTOFMEMORY;
        HDPA hdpa = DPA_Create(2);
        if (hdpa)
        {
            IDVGetEnum *pdvge;  // private defview interface
            hr = IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IDVGetEnum, &pdvge));
            if (SUCCEEDED(hr))
            {
                HTREEITEM hti = _FindFromRoot(NULL, pidl);
                // Try to find the tree item using the pidl
                if (hti)
                {
                    IShellFolder* psf;
                    hr = IEBindToObject(pidl, &psf);
                    if (S_OK == hr)
                    {
                        ITEMINFO *pii = _GetTreeItemInfo(hti);
                        DWORD grfFlags;
                        _GetEnumFlags(psf, pidl, &grfFlags, NULL);
                        IEnumIDList *penum;
                        hr = pdvge->CreateEnumIDListFromContents(pidl, grfFlags, &penum);
                        if (S_OK == hr)
                        {
                            ULONG celt;
                            LPITEMIDLIST pidlTemp;
                            while (S_OK == penum->Next(1, &pidlTemp, &celt))
                            {
                                if (!OrderList_Append(hdpa, pidlTemp, -1))
                                {
                                    hr = E_OUTOFMEMORY;
                                    ILFree(pidlTemp);
                                    break;
                                }
                            }
                            penum->Release();
                        }

                        if (hr == S_OK)
                        {
                            ORDERINFO oinfo;
                            oinfo.psf = psf;
                            oinfo.dwSortBy = OI_SORTBYNAME; // merge depends on by name.

                            DPA_Sort(hdpa, OrderItem_Compare, (LPARAM)&oinfo);
                            OrderList_Reorder(hdpa);

                            LPITEMIDLIST pidlExpClone = ILClone(_pidlExpandingTo);  // NULL is OK

                            s_NscEnumCallback(this, pidl, (UINT_PTR)hti, pii->dwSig, hdpa, pidlExpClone, _dwOrderSig, 0, FALSE, FALSE);
                            hdpa = NULL;
                            pidl = NULL;
                        }
                        psf->Release();
                    }
                }
                pdvge->Release();
            }
        }

        if (hr != S_OK)
        {
            if (hdpa)
                OrderList_Destroy(&hdpa, TRUE);        // calls DPA_Destroy(hdpa)

            if (pidl)
            {
                HTREEITEM hti = _FindFromRoot(NULL, pidl);
                if (hti)
                {
                    BOOL fOrdered;
                    hr = _StartBackgroundEnum(hti, pidl, &fOrdered, FALSE);
                }
            }
        }
    }
    ILFree(pidl);
    return hr;
}

HRESULT CNscTree::MoveSelectionTo(void)
{
    return MoveItemsIntoFolder(::GetParent(_hwndParent)) ? S_OK : S_FALSE;
}

BOOL CNscTree::MoveItemsIntoFolder(HWND hwndParent)
{
    BOOL         fSuccess = FALSE;
    BROWSEINFO   browse = {0};
    TCHAR        szDisplayName[MAX_PATH];
    TCHAR        szInstructionString[MAX_PATH];
    LPITEMIDLIST pidlDest = NULL, pidlSelected = NULL;
    HTREEITEM    htiSelected = NULL;
    
    //Initialize the BROWSEINFO struct.
    browse.pidlRoot = ILClone(_pidlRoot);
    if (!browse.pidlRoot)
        return FALSE;
    
    htiSelected = TreeView_GetSelection(_hwndTree);
    pidlSelected = _GetFullIDList(htiSelected);
    if (!pidlSelected)
    {
        ILFree((LPITEMIDLIST)browse.pidlRoot);
        return FALSE;
    }
    
    MLLoadShellLangString(IDS_FAVORITEBROWSE, szInstructionString, ARRAYSIZE(szInstructionString));
    
    browse.pszDisplayName = szDisplayName;
    browse.hwndOwner = hwndParent;
    browse.lpszTitle = szInstructionString;
    browse.ulFlags = BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS;
    browse.lpfn = NULL;
    browse.lParam = 0;
    browse.iImage = 0;
    
    pidlDest = SHBrowseForFolder(&browse);
    if (pidlDest)
    {
        TCHAR szFrom[MAX_PATH+1];  // +1 for double null
        TCHAR szDest[MAX_PATH+1];
        SHGetPathFromIDList(pidlDest, szDest);
        SHGetPathFromIDList(pidlSelected, szFrom);
        
        ASSERT(szDest[0]);  // must be a file system thing...
        ASSERT(szFrom[0]);
        
        szDest[lstrlen(szDest) + 1] = 0;   // double null
        szFrom[lstrlen(szFrom) + 1] = 0;   // double null
        
        
        SHFILEOPSTRUCT  shop = {hwndParent, FO_MOVE, szFrom, szDest, 0, };
        SHFileOperation(&shop);
        
        fSuccess = TRUE;
        
        ILFree(pidlDest);
    }
    ILFree((LPITEMIDLIST)browse.pidlRoot);
    ILFree(pidlSelected);
    
    return fSuccess;
}

// the following guid goo and IsChannelFolder are mostly lifted from cdfview
#define     GUID_STR_LEN            80
const GUID  CLSID_CDFINI = {0xf3aa0dc0, 0x9cc8, 0x11d0, {0xa5, 0x99, 0x0, 0xc0, 0x4f, 0xd6, 0x44, 0x34}};
// {f3aa0dc0-9cc8-11d0-a599-00c04fd64434}

// REARCHITECT: total hack. looks into the desktop.ini for this guy
//
// pwzChannelURL is assumed to be INTERNET_MAX_URL_LENGTH
BOOL IsChannelFolder(LPCWSTR pwzPath, LPWSTR pwzChannelURL)
{
    ASSERT(pwzPath);
    
    BOOL fRet = FALSE;
    
    WCHAR wzFolderGUID[GUID_STR_LEN];
    WCHAR wzIniFile[MAX_PATH];
    
    if (!PathCombineW(wzIniFile, pwzPath, L"desktop.ini"))
        return FALSE;
    
    if (GetPrivateProfileString(L".ShellClassInfo", L"CLSID", L"", wzFolderGUID, ARRAYSIZE(wzFolderGUID), wzIniFile))
    {
        WCHAR wzChannelGUID[GUID_STR_LEN];
        
        //it's only a channel if it's got the right guid and an url
        if (SHStringFromGUID(CLSID_CDFINI, wzChannelGUID, ARRAYSIZE(wzChannelGUID)))
        {
            fRet = (StrCmpN(wzFolderGUID, wzChannelGUID, ARRAYSIZE(wzChannelGUID)) == 0);
            if (fRet && pwzChannelURL)
            {
                fRet = (SHGetIniStringW(L"Channel", L"CDFURL", pwzChannelURL, INTERNET_MAX_URL_LENGTH, wzIniFile) != 0);
            }
        }
    }
    return fRet;
}

BOOL CNscTree::_IsChannelFolder(HTREEITEM hti)
{
    BOOL fRet = FALSE;

    LPITEMIDLIST pidl = _GetFullIDList(hti);
    if (pidl)
    {
        WCHAR szPath[MAX_PATH];
        if (SUCCEEDED(IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
        {
            fRet = IsChannelFolder(szPath, NULL);
        }
        ILFree(pidl);
    }
    return fRet;
}


HRESULT CNscTree::CreateSubscriptionForSelection(/*[out, retval]*/ VARIANT_BOOL *pBool)
{
    HRESULT hr = DoSubscriptionForSelection(TRUE);
    
    if (pBool)
        *pBool = (SUCCEEDED(hr) ? TRUE : FALSE);

    return FIX_SCRIPTING_ERRORS(hr);
}


HRESULT CNscTree::DeleteSubscriptionForSelection(/*[out, retval]*/ VARIANT_BOOL *pBool)
{
    HRESULT hr = DoSubscriptionForSelection(FALSE);
    
    if (pBool)
        *pBool = (SUCCEEDED(hr) ? TRUE : FALSE);

    return FIX_SCRIPTING_ERRORS(hr);
}


//
// 1. get the selected item
// 2. get it's name
// 3. get it's url
// 4. create a Subscription manager and do the right thing for channels
// 5. return Subscription manager's result
HRESULT CNscTree::DoSubscriptionForSelection(BOOL fCreate)
{
#ifndef DISABLE_SUBSCRIPTIONS

    HRESULT hr = E_FAIL;
    WCHAR wzUrl[MAX_URL_STRING];
    WCHAR wzName[MAX_PATH];
    HTREEITEM htiSelected = TreeView_GetSelection(_hwndTree);
    if (htiSelected == NULL)
        return E_FAIL;
    
    TV_ITEM tvi;
    
    tvi.mask = TVIF_HANDLE | TVIF_TEXT;
    tvi.hItem = htiSelected;
    tvi.pszText = wzName;
    tvi.cchTextMax = ARRAYSIZE(wzName);
    
    TreeView_GetItem(_hwndTree, &tvi);
    
    WCHAR wzPath[MAX_PATH];
    
    LPITEMIDLIST pidlItem = _CacheParentShellFolder(htiSelected, NULL);
    if (pidlItem)
    {
        GetPathForItem(_psfCache, pidlItem, wzPath, NULL);
        hr = GetNavTargetName(_psfCache, pidlItem, wzUrl, ARRAYSIZE(wzUrl));
    }
    
    if (FAILED(hr))     //if we couldn't get an url, not much to do
        return hr;
    
    ISubscriptionMgr *psm;
    
    hr = JITCoCreateInstance(CLSID_SubscriptionMgr, NULL,
        CLSCTX_INPROC_SERVER, IID_PPV_ARG(ISubscriptionMgr, &psm),
        _hwndTree, FIEF_FLAG_FORCE_JITUI);
    if (SUCCEEDED(hr))
    {
        HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
        //IsChannelFolder will fixup wzUrl if it's a channel
        BOOL fChannel = IsChannelFolder(wzPath, wzUrl);
        
        if (fCreate)
        {
            SUBSCRIPTIONINFO si = { sizeof(SUBSCRIPTIONINFO) };
            TASK_TRIGGER tt;
            BOOL bIsSoftware = FALSE;
            
            if (fChannel)
            {
                IChannelMgrPriv *pChannelMgrPriv;
                
                hr = JITCoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER, 
                    IID_PPV_ARG(IChannelMgrPriv, &pChannelMgrPriv),
                    _hwndTree, FIEF_FLAG_PEEK);

                if (SUCCEEDED(hr))
                {
                    WCHAR wszTitle[MAX_PATH];
                    
                    si.fUpdateFlags |= SUBSINFO_SCHEDULE;
                    si.schedule     = SUBSSCHED_AUTO;
                    si.pTrigger     = (void *)&tt;
                    
                    hr = pChannelMgrPriv->DownloadMinCDF(_hwndTree, wzUrl, 
                        wszTitle, ARRAYSIZE(wszTitle), 
                        &si, &bIsSoftware);
                    pChannelMgrPriv->Release();
                }
            }

            if (SUCCEEDED(hr))
            {
                DWORD dwFlags = CREATESUBS_NOUI | CREATESUBS_FROMFAVORITES | 
                    ((!bIsSoftware) ? 0 : CREATESUBS_SOFTWAREUPDATE);
                
                hr = psm->CreateSubscription(_hwndTree, wzUrl, wzName, dwFlags, 
                    (fChannel ? SUBSTYPE_CHANNEL : SUBSTYPE_URL), 
                    &si);
            }
        }
        else
        {
            hr = psm->DeleteSubscription(wzUrl, NULL);
        }
        
        //  This is in case subscribing or unsubscribing return a failed result even
        //  though the action succeeded from our standpoint (ie. item was subscribed
        //  successfully but creating a schedule failed or the item was unsubscribed 
        //  successfully but we couldn't abort a running download in syncmgr).
        
        BOOL bSubscribed;
        psm->IsSubscribed(wzUrl, &bSubscribed);
        
        hr = ((fCreate && bSubscribed) || (!fCreate && !bSubscribed)) ? S_OK : E_FAIL;
        
        psm->Release();
        
        SetCursor(hCursorOld);
    }
    
    return hr;

#else  /* !DISABLE_SUBSCRIPTIONS */

    return E_FAIL;

#endif /* !DISABLE_SUBSCRIPTIONS */

}


// Causes NSC to re-root on a different pidl --
HRESULT CNscTree::_ChangePidlRoot(LPCITEMIDLIST pidl)
{
    _fClosing = TRUE;
    ::SendMessage(_hwndTree, WM_SETREDRAW, FALSE, 0);
    _bSynchId++;
    if (_bSynchId >= 16)
        _bSynchId = 0;
    TreeView_DeleteAllItemsQuickly(_hwndTree);
    _htiActiveBorder = NULL;
    _fClosing = FALSE;
    if (_psfCache)
        _ReleaseCachedShellFolder();

    // We do this even for (NULL == pidl) because (CSIDL_DESKTOP == NULL)
    if ((LPCITEMIDLIST)INVALID_HANDLE_VALUE != pidl)
    {
        _UnSubClass();
        _SetRoot(pidl, 3/*random*/, NULL, NSSR_CREATEPIDL);
        _SubClass(pidl);
    }
    ::SendMessage(_hwndTree, WM_SETREDRAW, TRUE, 0);

    return S_OK;
}

BOOL CNscTree::_IsMarked(HTREEITEM hti)
{
    if ((hti == NULL) || (hti == TVI_ROOT))
        return FALSE;
        
    TVITEM tvi;
    tvi.mask = TVIF_HANDLE | TVIF_STATE;
    tvi.stateMask = TVIS_STATEIMAGEMASK;
    tvi.state = 0;
    tvi.hItem = hti;
    TreeView_GetItem(_hwndTree, &tvi);

    return BOOLIFY(tvi.state & NSC_TVIS_MARKED);
}

void CNscTree::_MarkChildren(HTREEITEM htiParent, BOOL fOn)
{
    TVITEM tvi;
    tvi.mask = TVIF_HANDLE | TVIF_STATE;
    tvi.stateMask = TVIS_STATEIMAGEMASK;
    tvi.state = (fOn ? NSC_TVIS_MARKED : 0);
    tvi.hItem = htiParent;
    TreeView_SetItem(_hwndTree, &tvi);

    for (HTREEITEM htiTemp = TreeView_GetChild(_hwndTree, htiParent); htiTemp; htiTemp = TreeView_GetNextSibling(_hwndTree, htiTemp)) 
    {
        tvi.hItem = htiTemp;
        TreeView_SetItem(_hwndTree, &tvi);
    
        _MarkChildren(htiTemp, fOn);
    }
}

//Updates the tree and internal state for the active border (the 1 pixel line)
// htiSelected is the item that was just clicked on/selected
void CNscTree::_UpdateActiveBorder(HTREEITEM htiSelected)
{
    HTREEITEM htiNewBorder;
    if (MODE_NORMAL == _mode)
        return;

    //if an item is a folder, then it should have the border
    if (htiSelected != TVI_ROOT)
    {
        if (TreeView_GetChild(_hwndTree, htiSelected))
            htiNewBorder = htiSelected;
        else
            htiNewBorder = TreeView_GetParent(_hwndTree, htiSelected);
    }
    else
        htiNewBorder = NULL;
        
    //clear the old state
    // in multiselect mode we don't unselect the previously selected folder
    if ((!(_dwFlags & NSS_MULTISELECT)) && (_htiActiveBorder != TVI_ROOT) && (_htiActiveBorder != NULL) 
    && (htiNewBorder != _htiActiveBorder))
        _MarkChildren(_htiActiveBorder, FALSE);
   
    //set the new state
    BOOL bMark = TRUE;
    if (_dwFlags & NSS_MULTISELECT)
    {
        bMark = TreeView_GetItemState(_hwndTree, htiNewBorder, NSC_TVIS_MARKED) & NSC_TVIS_MARKED;
    }
    
    if (bMark && (htiNewBorder != TVI_ROOT) && (htiNewBorder != NULL))
        _MarkChildren(htiNewBorder, TRUE);

    //treeview knows to invalidate itself

    _htiActiveBorder = htiNewBorder;
}

void CNscTree::_UpdateItemDisplayInfo(HTREEITEM hti)
{
    if (_GetTreeItemInfo(hti) && _pTaskScheduler)
    {
        LPITEMIDLIST pidl = _GetFullIDList(hti);
        if (pidl)
        {
            LPITEMIDLIST pidl2 = _mode == MODE_NORMAL ? ILClone(pidl) : NULL;
            
            AddNscIconTask(_pTaskScheduler, pidl, s_NscIconCallback, this, (UINT_PTR) hti, (UINT)_bSynchId);
            if (pidl2)
            {
                AddNscOverlayTask(_pTaskScheduler, pidl2, &s_NscOverlayCallback, this, (UINT_PTR)hti, (UINT)_bSynchId);
            }
        }
    }
    //pidls get freed by CNscIconTask
}

void CNscTree::s_NscOverlayCallback(CNscTree *pns, UINT_PTR uId, int iOverlayIndex, UINT uMagic)
{
    ASSERT(pns);
    ASSERT(uId);

    //this function gets called on a background thread, so use PostMessage to do treeview ops
    //on the main thread only.

    //assert that wacky packing is going to work
    ASSERT(((iOverlayIndex & 0x0fffffff) == iOverlayIndex) && (uMagic < 16));

    LPARAM lParam = (uMagic << 28) + iOverlayIndex;

    if (uMagic == pns->_bSynchId && ::IsWindow(pns->_hwndTree))
        ::PostMessage(pns->_hwndTree, WM_NSCUPDATEICONOVERLAY, (WPARAM)uId, lParam);
}

void CNscTree::s_NscIconCallback(CNscTree *pns, UINT_PTR uId, int iIcon, int iIconOpen, DWORD dwFlags, UINT uMagic)
{
    ASSERT(pns);
    ASSERT(uId);

    //this function gets called on a background thread, so use PostMessage to do treeview ops
    //on the main thread only.

    //assert that wacky packing is going to work
    ASSERT((iIcon < 4096) && (iIconOpen < 4096) && (dwFlags < 16) && (uMagic < 16));

    LPARAM lParam = (uMagic << 28) + (dwFlags << 24) + (iIconOpen << 12) + iIcon;

    if (uMagic == pns->_bSynchId && ::IsWindow(pns->_hwndTree))
        ::PostMessage(pns->_hwndTree, WM_NSCUPDATEICONINFO, (WPARAM)uId, lParam);
}

LRESULT CNscTree::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);

    switch(idCmd)
    {
    case FCIDM_MOVE:
        InvokeContextMenuCommand(L"cut");
        break;

    case FCIDM_COPY:
        InvokeContextMenuCommand(L"copy");
        break;

    case FCIDM_PASTE:
        InvokeContextMenuCommand(L"paste");
        break;

    case FCIDM_LINK:
        InvokeContextMenuCommand(L"link");
        break;

    case FCIDM_DELETE:
        InvokeContextMenuCommand(L"delete");
        if (_hwndTree) 
        {
            SHChangeNotifyHandleEvents();
        }
        break;

    case FCIDM_PROPERTIES:
        InvokeContextMenuCommand(L"properties");
        break;

    case FCIDM_RENAME:
        {
            // HACKHACK (lamadio): This is to hack around tree view renaming on click and hover
            _fOkToRename = TRUE;
            HTREEITEM hti = TreeView_GetSelection(_hwndTree);
            if (hti)
                TreeView_EditLabel(_hwndTree, hti);
            _fOkToRename = FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void CNscTree::_TreeSetItemState(HTREEITEM hti, UINT stateMask, UINT state)
{
    if (hti) 
    {
        TV_ITEM tvi;
        tvi.mask = TVIF_STATE;
        tvi.stateMask = stateMask;
        tvi.hItem = hti;
        tvi.state = state;
        TreeView_SetItem(_hwndTree, &tvi);
    }

}

void CNscTree::_TreeNukeCutState()
{
    _TreeSetItemState(_htiCut, TVIS_CUT, 0);
    _htiCut = NULL;

    ::ChangeClipboardChain(_hwndTree, _hwndNextViewer);
    _hwndNextViewer = NULL;
}

    // *** IFolderFilterSite methods ***
HRESULT CNscTree::SetFilter(IUnknown* punk)
{
    HRESULT hr = S_OK;
    ATOMICRELEASE(_pFilter);

    if (punk)
        hr = punk->QueryInterface(IID_PPV_ARG(IFolderFilter, &_pFilter));

    return hr;
}

int DPADeletePidlsCB(void *pItem, void *pData)
{
    if (pItem)
        ILFree((LPITEMIDLIST)pItem);
    return TRUE;
}

int DPADeleteItemCB(void *pItem, void *pData)
{
    if (pItem)
    {
        LocalFree(pItem);
        pItem = NULL;
    }

    return TRUE;
}

HRESULT CNscTree::get_SubscriptionsEnabled(VARIANT_BOOL * pVal)
{
    *pVal = BOOLIFY(!SHRestricted2(REST_NoAddingSubscriptions, NULL, 0));
    return S_OK;
}

HRESULT CNscTree::Synchronize()
{
    return S_OK;
}

HRESULT CNscTree::NewFolder()
{
    //we should do this activates stuff only in control mode
    //hack to get control to be activated fully
    m_bUIActive = FALSE;
    InPlaceActivate(OLEIVERB_UIACTIVATE);

    return CreateNewFolder(TreeView_GetSelection(_hwndTree));
}

HRESULT CNscTree::InvokeContextMenuCommand(BSTR strCommand)
{
    ASSERT(strCommand);

    if (strCommand)
    {
        //again activate only if in control mode
        //only if renaming, activate control
        if (StrStr(strCommand, L"rename") != NULL)
        {
            //hack to get control to be activated fully
            m_bUIActive = FALSE;
            InPlaceActivate(OLEIVERB_UIACTIVATE);
        }

        return _InvokeContextMenuCommand(strCommand);
    }

    return S_OK;
}

HRESULT CNscTree::get_EnumOptions(LONG *pVal)
{
    *pVal = _grfFlags;
    return S_OK;
}

HRESULT CNscTree::put_EnumOptions(LONG lVal)
{
    _grfFlags = lVal;
    return S_OK;
}

HRESULT CreateFolderItem(LPCITEMIDLIST pidl, IDispatch **ppItem)
{
    *ppItem = NULL;

    IPersistFolder *ppf;
    HRESULT hr = CoCreateInstance(CLSID_FolderItem, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPersistFolder, &ppf));
    if (SUCCEEDED(hr))
    {
        if (S_OK == ppf->Initialize(pidl))
        {
            hr = ppf->QueryInterface(IID_PPV_ARG(IDispatch, ppItem));
        }
        else
            hr = E_FAIL;
        ppf->Release();
    }
    return hr;
}

HRESULT CNscTree::get_SelectedItem(IDispatch **ppItem)
{
    *ppItem = NULL;

    LPITEMIDLIST pidl;
    if (SUCCEEDED(GetSelectedItem(&pidl, 0)) && pidl)
    {
        CreateFolderItem(pidl, ppItem);
        ILFree(pidl);
    }
    return *ppItem ? S_OK : S_FALSE;
}

HRESULT CNscTree::put_SelectedItem(IDispatch *pItem)
{
    return S_FALSE;
}

HRESULT CNscTree::get_Root(VARIANT *pvar)
{
    pvar->vt = VT_EMPTY;
    return S_OK;
}

HRESULT CNscTree::put_Root(VARIANT var)
{
    if (_csidl != -1)
    {
        SetNscMode(MODE_CONTROL);
        _csidl = -1;    // unknown
    }

    return _PutRootVariant(&var);
}

HRESULT CNscTree::_PutRootVariant(VARIANT *pvar)
{
    BOOL bReady = _pidlRoot != NULL;
    LPITEMIDLIST pidl = VariantToIDList(pvar);
    if (_hdpaViews)
    {
        DPA_DestroyCallback(_hdpaViews, DPADeletePidlsCB, NULL);
        _hdpaViews = NULL;
    }
    
    HRESULT hr = S_OK;
    if (bReady)
        hr = _ChangePidlRoot(pidl);

    ILFree(pidl);

    return S_OK;
}

HRESULT CNscTree::SetRoot(BSTR bstrFullPath)
{
    // SetRoot is from IShellFavoritesNamespace so turn on Favorites mode
    _csidl = CSIDL_FAVORITES;
    SetNscMode(MODE_FAVORITES | MODE_CONTROL);

    CComVariant varPath(bstrFullPath);

    return FIX_SCRIPTING_ERRORS(_PutRootVariant(&varPath));
}


HRESULT CNscTree::put_Mode(UINT uMode)
{
    SetNscMode(uMode);
    _csidl = -1;
    return S_OK;
}

HRESULT CNscTree::put_Flags(DWORD dwFlags)
{
    _dwFlags = dwFlags;
    return S_OK;
}

HRESULT CNscTree::get_Columns(BSTR *pbstrColumns)
{
    *pbstrColumns = SysAllocString(TEXT(""));
    return *pbstrColumns? S_OK: E_FAIL;
}

typedef struct
{
    TCHAR szName[20];
    const SHCOLUMNID *pscid;
} COLUMNS;

static COLUMNS s_Columns[] = 
{ 
    {TEXT("name"), &SCID_NAME},
    {TEXT("attribs"), &SCID_ATTRIBUTES},
    {TEXT("size"), &SCID_SIZE},
    {TEXT("type"), &SCID_TYPE},
    {TEXT("create"), &SCID_CREATETIME},
};

int _SCIDsFromNames(LPTSTR pszNames, int nSize, const SHCOLUMNID *apscid[])
{
    int cItems = 0;

    if (!pszNames || !apscid || !nSize)
        return -1;
        
    do
    {
        BOOL bInsert = FALSE;
        LPTSTR pszTemp = StrChr(pszNames, TEXT(';'));

        if (pszTemp)
        {
            *pszTemp = 0;
            pszTemp++;
        }
        
        for (int i = 0; i < ARRAYSIZE(s_Columns); i++)
        {
            if (StrCmpI(pszNames, s_Columns[i].szName) == 0)
            {
                bInsert = TRUE;
#ifdef NO_DUPLICATES
                for (int j = 0; j < cItems; j++)
                {
                    if (IsEqualSCID(*(s_Columns[i].pscid), *apscid[j]))
                    {
                        bInsert = FALSE;
                        break;
                    }
                }
#endif
                break;
            }
        }
        if (bInsert)
        {
            apscid[cItems++] = s_Columns[i].pscid;
            if (cItems >= nSize)
                break;
        }
        pszNames = pszTemp;
    }
    while(pszNames);

    return cItems;
}

HRESULT CNscTree::put_Columns(BSTR bstrColumns)
{
    HRESULT hr = E_FAIL;

    if (_dwFlags & NSS_HEADER)
    {
        if (!_hdpaColumns)
        {
            _hdpaColumns = DPA_Create(3);
            hr = E_OUTOFMEMORY;
        }
        else
        {
            DPA_EnumCallback(_hdpaColumns, DPADeleteItemCB, NULL);
            DPA_DeleteAllPtrs(_hdpaColumns);
        }

        if (_hdpaColumns)
        {
            const SHCOLUMNID *apscid[5];
            int cItems = _SCIDsFromNames(bstrColumns, ARRAYSIZE(apscid), apscid);
            
            hr = S_OK;
            
            for (int i = 0; i < cItems; i++)
            {
                HEADERINFO *phinfo = (HEADERINFO *)LocalAlloc(LPTR, sizeof(HEADERINFO));
                if (phinfo)
                {
                    phinfo->pscid = apscid[i];
                    phinfo->iFldrCol = -1;
                    if (DPA_AppendPtr(_hdpaColumns, (void *)phinfo) == -1)
                    {
                        hr = E_FAIL;
                        LocalFree(phinfo);
                        phinfo = NULL;
                        break;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    break;
                }
            }
            if (DPA_GetPtrCount(_hdpaColumns) > 0)
                _CreateHeader();
        }
    }
    return hr;
}

HRESULT CNscTree::get_CountViewTypes(int *piTypes)
{
    *piTypes = 0;
    
    if (_pidlRoot && !_hdpaViews)
    {
        IShellFolder *psf;
        if (SUCCEEDED(IEBindToObject(_pidlRoot, &psf))) //do we have this cached?
        {
            IShellFolderViewType *psfvt;
            if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolderViewType, &psfvt))))
            {
                IEnumIDList *penum;
                if (SUCCEEDED(psfvt->EnumViews(0, &penum)))
                {
                    LPITEMIDLIST pidl;
                    ULONG cFetched;

                    _hdpaViews = DPA_Create(4);
                    if (_hdpaViews)
                    {
                        while (penum->Next(1, &pidl, &cFetched) == S_OK && cFetched == 1)
                        {
                            if (DPA_AppendPtr(_hdpaViews, pidl) == -1)
                            {
                                ILFree(pidl);
                                break;
                            }
                        }
                    }
                    penum->Release();
                }
                psfvt->Release();
            }
            psf->Release();
        }
    }

    if (_hdpaViews)
        *piTypes = DPA_GetPtrCount(_hdpaViews);
        
    return S_OK;
}

HRESULT CNscTree::SetViewType(int iType)
{
    HRESULT hr = S_FALSE;
    
    if (_hdpaViews && iType < DPA_GetPtrCount(_hdpaViews))  // allow negative types to reset to _pidlRoot
    {        
        LPITEMIDLIST pidl = (LPITEMIDLIST)DPA_GetPtr(_hdpaViews, iType);
        LPITEMIDLIST pidlType;

        if (pidl)
            pidlType = ILCombine(_pidlRoot, pidl);
        else
            pidlType = _pidlRoot;

        if (pidlType)
        {
            hr = _ChangePidlRoot(pidlType);
            if (pidlType != _pidlRoot)
                ILFree(pidlType);
        }
    }
    return hr;
}

HRESULT CreateFolderItemsFDF(LPCITEMIDLIST pidl, IDispatch **ppItems)
{
    *ppItems = NULL;

    IPersistFolder *ppf;
    HRESULT hr = CoCreateInstance(CLSID_FolderItemsFDF, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPersistFolder, &ppf));
    if (SUCCEEDED(hr))
    {
        if (S_OK == ppf->Initialize(pidl))
        {
            hr = ppf->QueryInterface(IID_PPV_ARG(IDispatch, ppItems));
        }
        else
            hr = E_FAIL;
        ppf->Release();
    }
    return hr;
}

void CNscTree::_InsertMarkedChildren(HTREEITEM htiParent, LPCITEMIDLIST pidlParent, IInsertItem *pii)
{
    TV_ITEM tvi = {0};
    
    tvi.mask = TVIF_PARAM | TVIF_HANDLE;
    for (HTREEITEM htiTemp = TreeView_GetChild(_hwndTree, htiParent); htiTemp; htiTemp = TreeView_GetNextSibling(_hwndTree, htiTemp)) 
    {
        BOOL bMarked = TreeView_GetItemState(_hwndTree, htiTemp, NSC_TVIS_MARKED) & NSC_TVIS_MARKED;

        tvi.hItem = htiTemp;
        if (TreeView_GetItem(_hwndTree, &tvi))
        {
            if (tvi.lParam)
            {
                PORDERITEM poi = ((ITEMINFO *)tvi.lParam)->poi;
                if (poi)
                {
                    LPITEMIDLIST pidl = ILCombine(pidlParent, poi->pidl);
                    if (pidl)
                    {
                        if (bMarked)
                        {
                            pii->InsertItem(pidl);
                        }
                        _InsertMarkedChildren(htiTemp, pidl, pii);
                        ILFree(pidl);
                    }
                }
            }
        }
    }
}

HRESULT CNscTree::SelectedItems(IDispatch **ppItems)
{
    HRESULT hr = CreateFolderItemsFDF(_pidlRoot, ppItems);
    // poke all marked items in ppitems)
    if (SUCCEEDED(hr) && _hwndTree)
    {
        IInsertItem *pii;
        hr = (*ppItems)->QueryInterface(IID_PPV_ARG(IInsertItem, &pii));
        if (SUCCEEDED(hr))
        {
            if (!(_mode & MODE_NORMAL) && (_dwFlags & NSS_MULTISELECT))
            {
                _InsertMarkedChildren(TVI_ROOT, NULL, pii);
            }
            else
            {
                LPITEMIDLIST pidl;
                if (SUCCEEDED(GetSelectedItem(&pidl, 0)) && pidl)
                {
                    hr = pii->InsertItem(pidl);
                    ILFree(pidl);
                }
            }
            pii->Release();
        }
    }
    return hr;
}

HRESULT CNscTree::Expand(VARIANT var, int iDepth)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidl;

    if (var.vt == VT_EMPTY)
        pidl = ILClone(_pidlRoot);
    else
        pidl = VariantToIDList(&var);

    if (pidl)
    {
        hr = _Expand(pidl, iDepth);
        if (FAILED(hr))
            hr = S_FALSE;
        ILFree(pidl);
    }
    return hr;
}

HRESULT CNscTree::UnselectAll()
{
    if (_dwFlags & NSS_MULTISELECT)
        _MarkChildren(TVI_ROOT, FALSE);
        
    return S_OK;
}

LRESULT CNscTree::OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // when in label edit mode, don't try to activate the control or you'll get out of label editing,
    // even when you click on the label edit control
    if (!InLabelEdit())
        InPlaceActivate(OLEIVERB_UIACTIVATE);
    return S_OK;
}

LRESULT CNscTree::OnGetIShellBrowser(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    LRESULT lResult = NULL; // This will be the IShellBrowser *.
    IShellBrowser * psb;
    if (SUCCEEDED(_InternalQueryInterface(IID_PPV_ARG(IShellBrowser, &psb))))
    {
        lResult = (LRESULT) psb;
        psb->Release();
    }
    
    bHandled = TRUE;
    return lResult;
}

LRESULT CNscTree::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    if (!m_bUIActive)
        CComControlBase::InPlaceActivate(OLEIVERB_UIACTIVATE);

    if ((HWND)wParam != _hwndTree)
        ::SendMessage(_hwndTree, uMsg, wParam, lParam);
    bHandled = TRUE;
    return 0;
}

LRESULT CNscTree::OnKillFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    bHandled = TRUE;

    return S_OK;
}

LRESULT CNscTree::OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LPNMHDR pnm = (LPNMHDR)lParam;
    if (pnm)
    {
        switch (pnm->code)
        {
        case TVN_SELCHANGEDA:
        case TVN_SELCHANGED:
            {
                if (CSIDL_FAVORITES == _csidl)
                {
                    IShellFolder *psf = NULL;
                    LPITEMIDLIST pidl = NULL;
                    UINT cItems, cVisits;
                    WCHAR szTitle[MAX_PATH];
                    BOOL fAvailableOffline;

                    szTitle[0] = 0;

                    HRESULT hr = BindToSelectedItemParent(IID_PPV_ARG(IShellFolder, &psf), &pidl);
                    if (SUCCEEDED(hr) && (SUCCEEDED(GetSelectedItemName(szTitle, ARRAYSIZE(szTitle)))))
                    {
                        WCHAR szUrl[INTERNET_MAX_URL_LENGTH], szLastVisited[MAX_PATH]; // szLastVisisted assumed to be MAX_PATH below

                        szUrl[0] = szLastVisited[0] = 0;
                        GetEventInfo(psf, pidl, &cItems, szUrl, ARRAYSIZE(szUrl), &cVisits, szLastVisited, &fAvailableOffline);

                        CComBSTR strName(szTitle);
                        CComBSTR strUrl(szUrl);
                        CComBSTR strDate(szLastVisited);
                
                        _FireFavoritesSelectionChange(cItems, 0, strName, strUrl, cVisits, strDate, fAvailableOffline);
                    }
                    else
                        _FireFavoritesSelectionChange(0, 0, NULL, NULL, 0, NULL, FALSE);

                    ILFree(pidl);
                    ATOMICRELEASE(psf);
                }
                IUnknown_CPContainerInvokeParam(SAFECAST(this, IShellNameSpace *), 
                    DIID_DShellNameSpaceEvents, DISPID_SELECTIONCHANGE, NULL, 0);
            }
            break;

        case NM_DBLCLK:
            IUnknown_CPContainerInvokeParam(SAFECAST(this, IShellNameSpace *), 
                DIID_DShellNameSpaceEvents, DISPID_DOUBLECLICK, NULL, 0);
            break;

        default:
            break;
        }
    }

    LRESULT lResult;
    HRESULT hr = OnWinEvent(_hwndTree, uMsg, wParam, lParam, &lResult);
    
    bHandled = (lResult ? TRUE : FALSE);
    return SUCCEEDED(hr) ? lResult : hr;
}

void CNscTree::_InitHeaderInfo()
{
    if (!_pidlRoot || !_hdpaColumns || DPA_GetPtrCount(_hdpaColumns) == 0)
        return;

    IShellFolder *psf;
    if (SUCCEEDED(IEBindToObject(_pidlRoot, &psf)))
    {
        IShellFolder2 *psf2;
        if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
        {
            int i;
            SHCOLUMNID scid;
            
            for (i=0; SUCCEEDED(psf2->MapColumnToSCID(i, &scid)); i++)
            {
                BOOL bFound = FALSE;
                HEADERINFO *phinfo;

                for (int iCol=0; iCol < DPA_GetPtrCount(_hdpaColumns); iCol++)
                {
                    phinfo = (HEADERINFO *)DPA_GetPtr(_hdpaColumns, iCol);
                    if (phinfo && phinfo->iFldrCol == -1 && IsEqualSCID(*(phinfo->pscid), scid))
                    {
                        bFound = TRUE;
                        break;
                    }
                }

                if (bFound)
                {
                    DETAILSINFO di;

                    di.fmt  = LVCFMT_LEFT;
                    di.cxChar = 20;
                    di.str.uType = (UINT)-1;
                    //di.pidl = NULL;

                    if (SUCCEEDED(psf2->GetDetailsOf(NULL, i, (SHELLDETAILS *)&di.fmt)))
                    {
                        phinfo->fmt = di.fmt;
                        phinfo->iFldrCol = i;
                        phinfo->cxChar = di.cxChar;
                        StrRetToBuf(&di.str, NULL, phinfo->szName, ARRAYSIZE(phinfo->szName));
                    }
                }
            }

            for (i=DPA_GetPtrCount(_hdpaColumns)-1; i >= 0; i--)
            {
                HEADERINFO *phinfo = (HEADERINFO *)DPA_GetPtr(_hdpaColumns, i);

                if (!phinfo || phinfo->iFldrCol == -1)
                {
                    if (phinfo)
                    {
                        LocalFree(phinfo);
                        phinfo = NULL;
                    }

                    DPA_DeletePtr(_hdpaColumns, i);
                }
            }
            psf2->Release();
        }
        psf->Release();
    }
}

HWND CNscTree::Create(HWND hWndParent, RECT& rcPos, LPCTSTR pszWindowName, DWORD dwStyle, DWORD dwExStyle, UINT nID)
{
    CWindowImpl<CNscTree>::Create(hWndParent, rcPos, pszWindowName, dwStyle, dwExStyle, nID);

    LPITEMIDLIST pidl = _pidlRoot, pidlToFree = NULL;

    ASSERT(m_spClientSite);

    SetSite(m_spClientSite); // hook up the site chain

    _dwTVFlags |= TVS_TRACKSELECT | TVS_INFOTIP | TVS_FULLROWSELECT;
    if (!(_mode & MODE_CUSTOM))
    {
        DWORD dwValue;
        DWORD dwSize = sizeof(dwValue);
        BOOL  fDefault = TRUE;

        SHRegGetUSValue(L"Software\\Microsoft\\Internet Explorer\\Main",
                        L"NscSingleExpand", NULL, (LPBYTE)&dwValue, &dwSize, FALSE,
                        (void *) &fDefault, sizeof(fDefault));

        if (dwValue)
            _dwTVFlags |= TVS_SINGLEEXPAND;
    }

    _hwndTree = NULL;
    CreateTree(m_hWnd, _dwTVFlags, &_hwndTree);

    if (NULL == pidl)
    {
        SHGetSpecialFolderLocation(NULL, _csidl, &pidl);
        pidlToFree = pidl;
    }

    if (pidl)
    {
        if (_dwFlags & NSS_HEADER)
        {
            if (!_hdpaColumns || DPA_GetPtrCount(_hdpaColumns) == 0)
            {
                _dwFlags &= ~NSS_HEADER;
            }
            else
            {
                _InitHeaderInfo();
            }
        }
        Initialize(pidl, _grfFlags, _dwFlags);
        ShowWindow(TRUE);
        IUnknown_CPContainerInvokeParam(SAFECAST(this, IShellNameSpace *), DIID_DShellNameSpaceEvents, DISPID_INITIALIZED, NULL, 0);
        ILFree(pidlToFree);
    }
    
    return m_hWnd;
}

HRESULT CNscTree::InPlaceActivate(LONG iVerb, const RECT* prcPosRect /*= NULL*/)
{
    HRESULT hr = CComControl<CNscTree>::InPlaceActivate(iVerb, prcPosRect);
    if (::GetFocus() != _hwndTree)
        ::SetFocus(_hwndTree);
    return hr;
}


STDMETHODIMP CNscTree::GetWindow(HWND* phwnd)
{
    return IOleInPlaceActiveObjectImpl<CNscTree>::GetWindow(phwnd);
}

STDMETHODIMP CNscTree::TranslateAccelerator(MSG *pMsg)
{
    // label editing edit control is taking the keystrokes, TAing them will just duplicate them
    if (InLabelEdit())
        return S_FALSE;

    // hack so that the escape can get out to the document, because TA won't do it
    // WM_KEYDOWN is because some keyup's come through that need to not close the dialog
    if ((pMsg->wParam == VK_ESCAPE) && (pMsg->message == WM_KEYDOWN))
    {
        _FireFavoritesSelectionChange(-1, 0, NULL, NULL, 0, NULL, FALSE);
        return S_FALSE;
    }
    
    //except for tabs and sys keys, let nsctree take all the keystrokes
    if ((pMsg->wParam != VK_TAB) && (pMsg->message != WM_SYSCHAR) && (pMsg->message != WM_SYSKEYDOWN) && (pMsg->message != WM_SYSKEYUP))
    {
        // TreeView will return TRUE if it processes the key, so we return S_OK to indicate
        // the keystroke was used and prevent further processing 
        return ::SendMessage(pMsg->hwnd, TVM_TRANSLATEACCELERATOR, 0, (LPARAM)pMsg) ? S_OK : S_FALSE;
    } 
    else
    {
        CComQIPtr<IOleControlSite, &IID_IOleControlSite>spCtrlSite(m_spClientSite);
        if (spCtrlSite)
            return spCtrlSite->TranslateAccelerator(pMsg,0);       
    }        
    
    return S_FALSE;
}

HRESULT CNscTree::SetObjectRects(LPCRECT prcPos, LPCRECT prcClip)
{
    HRESULT hr = IOleInPlaceObjectWindowlessImpl<CNscTree>::SetObjectRects(prcPos, prcClip);
    LONG lTop = 0;

    if (_hwndHdr)
    {
        RECT rc;

        ::GetWindowRect(_hwndHdr, &rc);
        lTop = RECTHEIGHT(rc);
        ::SetWindowPos(_hwndHdr, NULL, 0, 0, RECTWIDTH(*prcPos), lTop, SWP_NOZORDER | SWP_NOACTIVATE);
    }

    if (_hwndTree)
    {
        ::SetWindowPos(_hwndTree, NULL, 0, lTop, RECTWIDTH(*prcPos), RECTHEIGHT(*prcPos)-lTop, 
                       SWP_NOZORDER | SWP_NOACTIVATE);
    }

    return hr;
}

STDMETHODIMP CNscTree::SetClientSite(IOleClientSite *pClientSite)
{
    SetSite(pClientSite);
    return IOleObjectImpl<CNscTree>::SetClientSite(pClientSite);
}

HRESULT CNscTree::OnDraw(ATL_DRAWINFO& di)
{
    //should only get called before CNscTree is initialized
    return S_OK;
}

LRESULT CNscTree::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL &bHandled)
{
    bHandled = FALSE; //let default handler also do it's work
    _OnWindowCleanup();
    return 0;
}

BOOL IsChannelFolder(LPCWSTR pwzPath, LPWSTR pwzChannelURL);

HRESULT CNscTree::GetEventInfo(IShellFolder *psf, LPCITEMIDLIST pidl,
                                               UINT *pcItems, LPWSTR pszUrl, DWORD cchUrl, 
                                               UINT *pcVisits, LPWSTR pszLastVisited, BOOL *pfAvailableOffline)
{
    HRESULT hr = S_OK;
    TCHAR szPath[MAX_PATH];
    TCHAR szUrl[MAX_URL_STRING];

    szPath[0] = szUrl[0] = 0;
    
    *pcItems = 1;
    
    ULONG ulAttr = SFGAO_FOLDER;    // make sure item is actually a folder
    hr = GetPathForItem(psf, pidl, szPath, &ulAttr);
    if (SUCCEEDED(hr) && (ulAttr & SFGAO_FOLDER)) 
    {
        pszLastVisited[0] = 0;
        
        StrCpyN(pszUrl, szPath, cchUrl);

        WIN32_FIND_DATA fd;
        HANDLE hfind = FindFirstFile(szPath, &fd);
        if (hfind != INVALID_HANDLE_VALUE)
        {
            SHFormatDateTime(&(fd.ftLastWriteTime), NULL, pszLastVisited, MAX_PATH);
            FindClose(hfind);
        }
        
        *pcVisits = -1;
        *pfAvailableOffline = 0;
        
        return S_OK;
    } 
    
    if (FAILED(hr))
    {
        // GetPathForItem fails on channel folders, but the following GetDisplayNameOf 
        // succeeds.
        DisplayNameOf(psf, pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath));
    }

    hr = GetNavTargetName(psf, pidl, szUrl, ARRAYSIZE(szUrl));

    // IsChannelFolder will fixup szUrl if it's a channel
    IsChannelFolder(szPath, szUrl);

    if (szUrl[0])
    {
        SHTCharToUnicode(szUrl, pszUrl, cchUrl);

        //
        // Get the cache info for this item.  Note that we use GetUrlCacheEntryInfoEx instead
        // of GetUrlCacheEntryInfo because it follows any redirects that occured.  This wacky
        // api uses a variable length buffer, so we have to guess the size and retry if the
        // call fails.
        //
        BOOL fInCache = FALSE;
        TCHAR szBuf[512];
        LPINTERNET_CACHE_ENTRY_INFO pCE = (LPINTERNET_CACHE_ENTRY_INFO)szBuf;
        DWORD dwEntrySize = sizeof(szBuf);
    
        fInCache = GetUrlCacheEntryInfoEx(szUrl, pCE, &dwEntrySize, NULL, NULL, NULL, 0);
        if (!fInCache)
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                // We guessed too small for the buffer so allocate the correct size & retry
                pCE = (LPINTERNET_CACHE_ENTRY_INFO)LocalAlloc(LPTR, dwEntrySize);
                if (pCE)
                {
                    fInCache = GetUrlCacheEntryInfoEx(szUrl, pCE, &dwEntrySize, NULL, NULL, NULL, 0);
                }
            }
        }

        *pfAvailableOffline = IsSubscribed(szUrl);

        if (fInCache)
        {
            *pcVisits = pCE->dwHitRate;

            SHFormatDateTime(&(pCE->LastAccessTime), NULL, pszLastVisited, MAX_PATH);        
        } 
        else
        {
            *pcVisits = 0;
            pszLastVisited[0] = 0;
        }

        if ((TCHAR*)pCE != szBuf)
        {
            LocalFree(pCE);
            pCE = NULL;
        }
    }
    else
    {
        *pcVisits = 0;
        SHTCharToUnicode(szPath, pszUrl, cchUrl);
    }
    
    return hr;
}

//    [id(DISPID_FAVSELECTIONCHANGE)] void FavoritesSelectionChange([in] long cItems, [in] long hItem, [in] BSTR strName,
//             [in] BSTR strUrl, [in] long cVisits, [in] BSTR strDate,
//             [in] BOOL fAvailableOffline);
void CNscTree::_FireFavoritesSelectionChange(
    long cItems, long hItem, BSTR strName, BSTR strUrl, 
    long cVisits, BSTR strDate, long fAvailableOffline)
{
    VARIANTARG args[7];

    IUnknown_CPContainerInvokeParam(SAFECAST(this, IShellNameSpace *), 
        DIID_DShellNameSpaceEvents, DISPID_FAVSELECTIONCHANGE, 
        args, ARRAYSIZE(args), 
        VT_I4, cItems,
        VT_I4, hItem,
        VT_BSTR, strName,
        VT_BSTR, strUrl,
        VT_I4, cVisits,
        VT_BSTR, strDate,
        VT_I4, fAvailableOffline);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\nscband.cpp ===
/**************************************************************\
    FILE: NSCBand.cpp

    DESCRIPTION:  implementation of CNSCBand.  the class CNSCBand 
        exists to support name space control bands.  A name 
        space control uses IShellFolder rooted in various 
        namespaces including Favorites, history, Shell Name 
        Space, etc. to depict a hierarchical UI 
        representation of the given name space.  
    
    AUTHOR:  chrisny

\**************************************************************/
#include "priv.h"
#include "sccls.h"
#include "util.h"
#include "resource.h"
#include "dhuihand.h"
#include "nscband.h"
#include <varutil.h>
#include <mluisupp.h>

HRESULT CNSCBand::_Init(LPCITEMIDLIST pidl)
{
    // further initialization happens in ShowDW
    _fInited = FALSE;
    _fVisible = FALSE;
    _fCanFocus = TRUE;
    _haccTree = LoadAccelerators(MLGetHinst(), MAKEINTRESOURCE(ACCEL_FAVBAR));

    // pidl can be real or a CSIDL_ constant
    if (HIWORD(pidl))
        _pidl = ILClone(pidl);
    else
        SHGetSpecialFolderLocation(NULL, LOWORD(pidl), &_pidl);

    return _pidl ? S_OK : E_FAIL;
}

CNSCBand::~CNSCBand()
{
    if (_pidl)
        ILFree(_pidl);
    ATOMICRELEASE(_pns);
    ATOMICRELEASE(_pweh);

    if (_himlNormal)
        ImageList_Destroy(_himlNormal);
    if (_himlHot)  
        ImageList_Destroy(_himlHot);
}

HRESULT CNSCBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CNSCBand, IContextMenu),       // IID_IContextMenu
        QITABENT(CNSCBand, IWinEventHandler),   // IID_IWinEventHandler
        QITABENT(CNSCBand, IBandNavigate),      // IID_IBandNavigate
        QITABENT(CNSCBand, INamespaceProxy),          // IID_INamespaceProxy
        { 0 },
    };
    HRESULT hres = QISearch(this, qit, riid, ppvObj);
    if (FAILED(hres))
        hres = CToolBand::QueryInterface(riid, ppvObj);
    return hres;
}

extern HRESULT GetHistoryPIDL(LPITEMIDLIST *ppidlHistory);


HRESULT CNSCBand::CloseDW(DWORD dw)
{
    if (_fVisible) 
    {
        _UnregisterBand();
    }

    if (_pns)
    {
        IUnknown_SetSite(_pns, NULL); // Break the ref-count cycle.
    }

    return CToolBand::CloseDW(dw);
}

void CNSCBand::_UnregisterBand()
{
    IBrowserService *pswProxy;
    QueryService(SID_SProxyBrowser, IID_PPV_ARG(IBrowserService, &pswProxy));
    ASSERT(pswProxy);
    if (pswProxy)
    {
        IOleCommandTarget *poctProxy;

        if (SUCCEEDED(pswProxy->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &poctProxy))))
        {
            VARIANT var;
            VariantInit(&var);
                
            //  Register ourselves for SBCMDID_SELECTHISTPIDL,SBCMDID_INITFILECTXMENU
            var.vt = VT_UNKNOWN;
            QueryInterface(IID_PPV_ARG(IUnknown, &var.punkVal));
            poctProxy->Exec(&CGID_Explorer, SBCMDID_UNREGISTERNSCBAND,  OLECMDEXECOPT_PROMPTUSER, &var, NULL);
            VariantClear(&var);
            poctProxy->Release();
        }
        pswProxy->Release();
    }
}

HRESULT CNSCBand::_InitializeNsc()
{
    return _pns->Initialize(_pidl, _GetEnumFlags(), NSS_DROPTARGET | NSS_BROWSERSELECT);
}

HRESULT CNSCBand::ShowDW(BOOL fShow)
{
    BOOL fIsHistory = IsEqualCLSID(*_poi->pclsid, CLSID_HistBand);
    if (fShow && _hwnd && !_fVisible)
    {
        IBrowserService *pswProxy;
        QueryService(SID_SProxyBrowser, IID_PPV_ARG(IBrowserService, &pswProxy));
        ASSERT(pswProxy);
        if (!_fInited)
        {
            _InitializeNsc();
        }
        else
        {
            _pns->ShowWindow(TRUE);
        }

        if (pswProxy)
        {
            IOleCommandTarget *poctProxy;
            if (SUCCEEDED(pswProxy->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &poctProxy))))
            {
                VARIANT var;
                VariantInit(&var);
                
                //  Register ourselves for SBCMDID_SELECTHISTPIDL,SBCMDID_INITFILECTXMENU
                var.vt = VT_UNKNOWN;
                QueryInterface(IID_PPV_ARG(IUnknown, &var.punkVal));

                poctProxy->Exec(&CGID_Explorer, SBCMDID_REGISTERNSCBAND, OLECMDEXECOPT_PROMPTUSER, &var, NULL);

                //clear the variant cheaply
                var.vt = VT_EMPTY;
                Release();

                // do any special registration if necessary
                _OnRegisterBand(poctProxy);
                
                poctProxy->Release();
            }
            pswProxy->Release();
        }
       _fInited = TRUE;
       _fVisible = TRUE;
    }
    else if (!fShow && _fVisible)
    {
        _pns->ShowWindow(FALSE);
        _UnregisterBand();
        _fVisible = FALSE;
    }

    return CToolBand::ShowDW(fShow);
}

HRESULT CNSCBand::GetWindow(HWND *phwnd)
{
    INSCTree2 *pns2;
    HRESULT hr = _pns->QueryInterface(IID_PPV_ARG(INSCTree2, &pns2));
    if (SUCCEEDED(hr))
    {
        pns2->CreateTree2(_hwndParent, _GetTVStyle(), _GetTVExStyle(), &_hwnd);
        hr = CToolBand::GetWindow(phwnd);
        pns2->Release();
    }

    return hr;
}

DWORD CNSCBand::_GetTVStyle()
{ 
    DWORD dwFlags = TVS_FULLROWSELECT | TVS_TRACKSELECT | TVS_INFOTIP;
    DWORD dwValue;
    DWORD dwSize = SIZEOF(dwValue);
    BOOL  fDefault = TRUE;

    SHRegGetUSValue(L"Software\\Microsoft\\Internet Explorer\\Main",
                    L"NscSingleExpand", NULL, (LPBYTE)&dwValue, &dwSize, FALSE,
                    (void *) &fDefault, sizeof(fDefault));

    if (dwValue)
        dwFlags |= TVS_SINGLEEXPAND;

    return dwFlags; 
}

HRESULT CNSCBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                DESKBANDINFO* pdbi) 
{
    _dwBandID = dwBandID;
    pdbi->dwModeFlags = DBIMF_FIXEDBMP | DBIMF_VARIABLEHEIGHT;
    
    pdbi->ptMinSize.x = 16;
    pdbi->ptMinSize.y = 0;
    pdbi->ptMaxSize.x = 32000; // random
    pdbi->ptMaxSize.y = 32000; // random
    pdbi->ptActual.y = -1;
    pdbi->ptActual.x = -1;
    pdbi->ptIntegral.y = 1;

    if (_szTitle[0]) 
    {
        StrCpyNW(pdbi->wszTitle, _szTitle, ARRAYSIZE(pdbi->wszTitle));
    } 
    else 
    {
        CLSID clsid;
        UINT  ids;
        GetClassID(&clsid);
        if (IsEqualIID(clsid, CLSID_FavBand))
            ids = IDS_BAND_FAVORITES;
        else if (IsEqualIID(clsid, CLSID_HistBand)) 
            ids = IDS_BAND_HISTORY;
        else if (IsEqualIID(clsid, CLSID_ExplorerBand))
            ids = IDS_BAND_EXPLORER;
        else 
        {
            ASSERT(FALSE);      // BOGUS BAND!!!
            return S_FALSE;
        }
        MLLoadStringW(ids, pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
    }
    return S_OK;
} 

void _InitColors(BOOL fReinit);


// *** IWinEventHandler methods ***

HRESULT CNSCBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    HRESULT hr = E_FAIL;

    if (!_pweh && _pns)
        _pns->QueryInterface(IID_PPV_ARG(IWinEventHandler, &_pweh));

    // We need to tell the bandsite that we have become active if we're getting a 
    // click focus or something
    if (uMsg == WM_NOTIFY && ((LPNMHDR)lParam)->code == NM_SETFOCUS)
    {
        IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
    }


    if (_pweh)
        hr = _pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

    return hr;
}

HRESULT CNSCBand::IsWindowOwner(HWND hwnd)
{
    HRESULT hr = SHIsChildOrSelf(_hwnd, hwnd);
    ASSERT(hwnd != NULL || hr == S_FALSE);
    ASSERT(_hwnd != NULL || hr == S_FALSE);
    return hr;
}

//***   CNSCBand::IPersistStream::* {

HRESULT CNSCBand::GetClassID(CLSID *pClassID)
{
    ASSERT(_poi->pclsid != NULL);
    *pClassID = *(_poi->pclsid);
    return S_OK;
}

HRESULT CNSCBand::Load(IStream *pstm)
{
    return S_OK;
}

HRESULT CNSCBand::Save(IStream *pstm, BOOL fClearDirty)
{
    return S_OK;
}

// }

//***   CNSCBand::IContextMenu::* {

HRESULT CNSCBand::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    // aka (S_OK|i)
    return MAKE_HRESULT(ERROR_SUCCESS, FACILITY_NULL, 0);
}

HRESULT CNSCBand::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    return S_OK;
}

HRESULT CNSCBand::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    if (pguidCmdGroup && IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        for (UINT i=0; i < cCmds; i++)
        {
            rgCmds[i].cmdf = 0;
            switch (rgCmds[i].cmdID)
            {
                case SBCMDID_INITFILECTXMENU:
                    if (_hwnd && _fVisible)
                    {
                        rgCmds->cmdf = 0;
                        if (pcmdtext) 
                            pcmdtext->cmdtextf = 0;

                        if (pcmdtext)
                        {
                            if (SUCCEEDED(_pns->GetSelectedItemName(pcmdtext->rgwz, pcmdtext->cwBuf)))
                            {
                                rgCmds->cmdf = OLECMDF_ENABLED;
                                pcmdtext->cmdtextf = OLECMDTEXTF_NAME;
                                pcmdtext->cwActual = lstrlenW(pcmdtext->rgwz) + 1;
                            }
                        }
                    }
                    break;

                case SBCMDID_FILERENAME:
                case SBCMDID_FILEDELETE:
                case SBCMDID_FILEPROPERTIES:
                {
                    LPITEMIDLIST  pidl;

                    // get selected item can return NULL pidl and S_FALSE
                    if (_pns->GetSelectedItem(&pidl, 0) == S_OK)
                    {
                        DWORD rgfAttrib = SFGAO_CANDELETE | SFGAO_CANRENAME | SFGAO_HASPROPSHEET; // CAN_LINK
                        if (SUCCEEDED(IEGetAttributesOf(pidl, &rgfAttrib)))
                        {
                            DWORD nCmdID;
        
                            static const DWORD tbtab[] = {
                                    SBCMDID_FILEDELETE, SBCMDID_FILEPROPERTIES, SBCMDID_FILERENAME };
                            static const DWORD cttab[] = {
                                    SFGAO_CANDELETE,    SFGAO_HASPROPSHEET,     SFGAO_CANRENAME };

                            nCmdID = SHSearchMapInt((int*)tbtab, (int*)cttab, ARRAYSIZE(tbtab), rgCmds[i].cmdID);

                            if (nCmdID != -1 && (rgfAttrib & nCmdID))
                                rgCmds[i].cmdf = OLECMDF_ENABLED;
                        }
                        ILFree(pidl);
                    }
                    break;
                }
                    
                default:
                    break;
            }
        }

        return S_OK;
    }
    return CToolBand::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

HRESULT CNSCBand::_InvokeCommandOnItem(LPCTSTR pszVerb)
{
    HRESULT hr;
    IContextMenu *pcm;
    
    hr = _QueryContextMenuSelection(&pcm);
    if (SUCCEEDED(hr))
    {
        CMINVOKECOMMANDINFOEX ici = 
        {
            SIZEOF(CMINVOKECOMMANDINFOEX),
            0L,
            _hwnd,
            NULL,
            NULL, NULL,
            SW_NORMAL,
        };
        
        CHAR szVerbAnsi[MAX_PATH];
        SHUnicodeToAnsi(pszVerb, szVerbAnsi, ARRAYSIZE(szVerbAnsi));
        ici.lpVerb = szVerbAnsi;
        ici.lpVerbW = pszVerb;
        ici.fMask |= CMIC_MASK_UNICODE;

        hr = pcm->InvokeCommand((LPCMINVOKECOMMANDINFO)&ici);
        pcm->Release();
    }
    
    return hr;
}

HRESULT CNSCBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL)
    {
        switch (nCmdID)
        {
        case OLECMDID_REFRESH:
            if (_pns)
                _pns->Refresh();
            return S_OK;
        }

    }
    else if (pguidCmdGroup && IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        HRESULT hr = S_OK;
        
        switch (nCmdID)
        {
        case SBCMDID_SELECTHISTPIDL:
            if (IsEqualCLSID(*_poi->pclsid, CLSID_HistBand) && _hwnd && _fVisible)
            {
                // If you're not visible do nothing.  On becoming visible
                // use Exec to proxy to get last pidlSelect that you would
                // have shown, had you been visible
                LPITEMIDLIST pidlSelect = VariantToIDList(pvarargIn);
                if (pidlSelect)
                {
                    ASSERT(_pns);
                    _pns->SetSelectedItem(pidlSelect, TRUE, FALSE, 0);
                    ILFree(pidlSelect);
                }
            }
            break;

        case SBCMDID_INITFILECTXMENU:
            if (_hwnd && _fVisible)
            {
                if (pvarargOut)
                {
                    VariantClearLazy(pvarargOut);

                    hr = _QueryContextMenuSelection((IContextMenu **)&(pvarargOut->punkVal));
                    if (SUCCEEDED(hr))
                    {
                        pvarargOut->vt = VT_UNKNOWN;
                    }
                }
            }
            break;

        case SBCMDID_FILERENAME:
        {
            IShellNameSpace *psfns;
            hr = _pns->QueryInterface(IID_PPV_ARG(IShellNameSpace, &psfns));
            if (SUCCEEDED(hr))
            {
                hr = psfns->InvokeContextMenuCommand(L"rename");
                psfns->Release();
            }
            break;
        }
            
        case SBCMDID_FILEDELETE:
            hr = _InvokeCommandOnItem(TEXT("delete"));
            break;
            
        case SBCMDID_FILEPROPERTIES:
            hr = _InvokeCommandOnItem(TEXT("properties"));
            break;

        default:
            hr = E_FAIL;
            break;
        }
        
        if (SUCCEEDED(hr))
            return hr;
    }

    return CToolBand::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}


HRESULT CNSCBand::_QueryContextMenuSelection(IContextMenu ** ppcm)
{
    *ppcm = NULL;

    LPITEMIDLIST pidlSelected;
    HRESULT hr = _pns->GetSelectedItem(&pidlSelected, 0);
    if (SUCCEEDED(hr))
    {
        LPCITEMIDLIST pidlRelative;
        IShellFolder * psf;
        hr = IEBindToParentFolder(pidlSelected, &psf, &pidlRelative);
        if (SUCCEEDED(hr))
        {
            hr = psf->GetUIObjectOf(NULL, 1, &pidlRelative, IID_PPV_ARG_NULL(IContextMenu, ppcm));
            psf->Release();
        }
        ILFree(pidlSelected);
    }
    
    return hr;
}


HRESULT CNSCBand::Select(LPCITEMIDLIST pidl)
{
    _pns->SetSelectedItem(pidl, TRUE, FALSE, 0);
    return S_OK;
}


// *** IInputObject Methods ***
HRESULT CNSCBand::TranslateAcceleratorIO(LPMSG lpMsg)
{
    HWND hwndFocus = GetFocus();
    if (_pns->InLabelEdit())
        return EditBox_TranslateAcceleratorST(lpMsg);
    else if (lpMsg && lpMsg->hwnd && SendMessage(lpMsg->hwnd, TVM_TRANSLATEACCELERATOR, 0, (LPARAM)lpMsg))
        return S_OK;
    else if (hwndFocus == _hwnd && TranslateAcceleratorWrap(_hwnd, _haccTree, lpMsg))
        return S_OK;

    return S_FALSE;
}


void CNSCBand::_EnsureImageListsLoaded()
{
    if (_himlNormal == NULL)
        _himlNormal = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_HISTORYANDFAVBANDSDEF), 18, 3, RGB(255, 0, 255), IMAGE_BITMAP, LR_CREATEDIBSECTION);

    if (_himlHot == NULL)
        _himlHot = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_HISTORYANDFAVBANDSHOT), 18, 3, RGB(255, 0, 255), IMAGE_BITMAP, LR_CREATEDIBSECTION);
}

HRESULT CNSCBand::_TranslatePidl(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib)
{
    IShellFolder *psf;
    LPCITEMIDLIST pidlLast;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
    if (SUCCEEDED(hr))
    {
        hr = SHGetNavigateTarget(psf, pidlLast, ppidlTarget, pulAttrib);
        psf->Release();
    }

    return hr;
}

// favorites, history and Explorer band should override this (they need not worry about channel band)
BOOL CNSCBand::_ShouldNavigateToPidl(LPCITEMIDLIST pidl, ULONG ulAttrib)
{
    BOOL bReturn = (ulAttrib & SFGAO_FOLDER);
    if (bReturn)
    {
        IShellFolder *psf;
        LPCITEMIDLIST pidlLast;
        HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
        if (SUCCEEDED(hr))
        {
            bReturn = IsExpandableChannelFolder(psf, pidlLast);
            psf->Release();
        }
    }

    return !bReturn;
}

HRESULT CNSCBand::GetNavigateTarget(LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget, ULONG *pulAttrib)
{
    HRESULT hr = _TranslatePidl(pidl, ppidlTarget, pulAttrib);
    if (SUCCEEDED(hr))
    {
        hr = _ShouldNavigateToPidl(pidl, *pulAttrib) ? S_OK : S_FALSE;
        if (hr == S_FALSE)
        {
            ILFree(*ppidlTarget);
            *ppidlTarget = NULL;
        }
    }
            
    return hr;
}

HRESULT CNSCBand::OnSelectionChanged(LPCITEMIDLIST pidl)
{
    return S_OK;
}

HRESULT CNSCBand::Invoke(LPCITEMIDLIST pidl)
{
    HRESULT hr = E_INVALIDARG;

    if (pidl)
    {
        IShellBrowser *psb;
        hr = IUnknown_QueryService(_punkSite, SID_SProxyBrowser, IID_PPV_ARG(IShellBrowser, &psb));
        if (SUCCEEDED(hr))
        {
            hr = _NavigateRightPane(psb, pidl);
            if (FAILED(hr))
            {
                IShellFolder *psf;
                LPCITEMIDLIST pidlChild;
                if (SUCCEEDED(SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlChild)))
                {
                    if (!SHGetAttributes(psf, pidlChild, SFGAO_FOLDER))
                    {
                        hr = SHInvokeDefaultCommand(_hwnd, psf, pidlChild);
                    }
                    psf->Release();
                }
            }
            psb->Release();
        }
    }
    return hr;
}

HRESULT CNSCBand::_NavigateRightPane(IShellBrowser *psb, LPCITEMIDLIST pidl)
{
    HRESULT hr = psb->BrowseObject(pidl, SBSP_SAMEBROWSER);
    if (SUCCEEDED(hr))
        UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_NAVIGATE, UIBL_NAVOTHER);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\occtrl.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: olecontrol.cpp
//
// History:
//         7-31-96  by dli
//------------------------------------------------------------------------

#include "priv.h"

class COleControlHost;

//---------------------------------------------------------------------------
// Event sink
class CEventSink : public IDispatch
//---------------------------------------------------------------------------
{
public:
    CEventSink( BOOL bAutoDelete = FALSE ) ;

    //  Connect/disconnect
    BOOL  Connect( HWND hwndOwner, HWND hwndSite, LPUNKNOWN punkOC ) ;
    BOOL  Disconnect() ;

//  IUnknown methods
    STDMETHOD (QueryInterface)( REFIID riid, void** ppvObj ) ;
    STDMETHOD_(ULONG, AddRef)() ;
    STDMETHOD_(ULONG, Release)() ;

//  IDispatch methods
    STDMETHOD (GetTypeInfoCount)( UINT *pctinfo )
        { return E_NOTIMPL ; }

    STDMETHOD (GetTypeInfo)( UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo )
        { return E_NOTIMPL ; }

    STDMETHOD (GetIDsOfNames)( REFIID riid, LPOLESTR *rgszNames, UINT cNames,
                                LCID lcid, DISPID *rgDispId )
        { return E_NOTIMPL ; }

    STDMETHOD (Invoke)( 
        IN DISPID dispIdMember,
        IN REFIID riid,
        IN LCID lcid,
        IN WORD wFlags,
        IN OUT DISPPARAMS *pDispParams,
        OUT VARIANT *pVarResult,
        OUT EXCEPINFO *pExcepInfo,
        OUT UINT *puArgErr) ;

private:
    static HRESULT _GetDefaultEventIID( LPUNKNOWN punkOC, IID* piid ) ;
    BOOL           _Connect( HWND hwndOwner, HWND hwndSite, LPUNKNOWN punkOC, REFIID iid ) ;
    BOOL           _IsConnected( REFIID iid ) ;

    ULONG       _dwCookie ;   // connection cookie
    IID         _iid ;        // connection interface
    IID         _iidDefault ; // OC's default event dispatch interface
    LPUNKNOWN   _punkOC ;     // OC's unknown
    LONG        _cRef ;       // ref count
    HWND        _hwndSite,    // 
                _hwndOwner ;
    BOOL        _bAutoDelete ;
} ;

class CProxyUIHandler : 
    public IDocHostUIHandler2
{
public:
    
    // *** IUnknown methods *** 
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // *** IDocHostUIHandler methods *** 
    virtual STDMETHODIMP ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
    virtual STDMETHODIMP GetHostInfo(DOCHOSTUIINFO *pInfo);
    virtual STDMETHODIMP ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject, IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc);
    virtual STDMETHODIMP HideUI();
    virtual STDMETHODIMP UpdateUI();
    virtual STDMETHODIMP EnableModeless(BOOL fActivate);
    virtual STDMETHODIMP OnDocWindowActivate(BOOL fActivate);
    virtual STDMETHODIMP OnFrameWindowActivate(BOOL fActivate);
    virtual STDMETHODIMP ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
    virtual STDMETHODIMP TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
    virtual STDMETHODIMP GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw);
    virtual STDMETHODIMP GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
    virtual STDMETHODIMP GetExternal(IDispatch **ppDispatch);
    virtual STDMETHODIMP TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
    virtual STDMETHODIMP FilterDataObject( IDataObject *pDO, IDataObject **ppDORet);

    // *** IDocHostUIHandler2 methods ***
    virtual STDMETHODIMP GetOverrideKeyPath( LPOLESTR *pchKey, DWORD dw);
};

//---------------------------------------------------------------------------
//  Ole control container object
class COleControlHost : 
        public IOleClientSite,
        public IAdviseSink,
        public IOleInPlaceSite,
        public IOleInPlaceFrame,
        public IServiceProvider,
        public IOleCommandTarget,
        public IDispatch            // For ambient properties
{
friend CProxyUIHandler;

protected:
    static LRESULT CALLBACK OCHostWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HRESULT _Draw(HDC hdc);
    HRESULT _PersistInit();
    HRESULT _Init();
    HRESULT _Activate();
    HRESULT _Deactivate();
    HRESULT _DoVerb(long iVerb, LPMSG lpMsg);
    HRESULT _Exit();
    HRESULT _InitOCStruct(LPOCHINITSTRUCT lpocs);
    LRESULT _OnPaint();
    LRESULT _OnSize(HWND hwnd, LPARAM lParam);
    LRESULT _OnCreate(HWND hwnd, LPCREATESTRUCT);
    LRESULT _OnDestroy();
    LRESULT _OnQueryInterface(WPARAM wParam, LPARAM lParam);
    LRESULT _SetOwner(IUnknown * punkOwner);
    LRESULT _ConnectEvents( LPUNKNOWN punkOC, BOOL bConnect ) ;
    LRESULT _SetServiceProvider(IServiceProvider* pSP);
    LRESULT _SendNotify(UINT code, LPNMHDR pnmhdr);
    
    // IUnknown 
    UINT _cRef;
    
    DWORD _dwAspect;
    DWORD _dwMiscStatus;    // OLE misc status 
    DWORD _dwConnection;    // Token for Advisory connections
   
    BOOL _bInPlaceActive;   // Flag indicating if the OC is in place active
        
    HWND _hwnd;
    HWND _hwndParent;
    CLSID _clsidOC;
   
    IUnknown *_punkOC;
    IViewObject *_pIViewObject; 
    IOleObject *_pIOleObject;
    IOleInPlaceObject *_pIOleIPObject;

    IUnknown *_punkOwner;
    CEventSink  _eventSink ;
    CProxyUIHandler     _xuih;
    IDocHostUIHandler  *_pIDocHostUIParent;
    IDocHostUIHandler2 *_pIDocHostUIParent2;

    IDispatch *_pdispSiteDelegate;

public:
    COleControlHost(HWND hwnd);

    static void _RegisterClass();

    // *** IUnknown methods *** 
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);    
    
    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);
    
    // *** IOleClientSite methods *** 
    STDMETHOD (SaveObject)();
    STDMETHOD (GetMoniker)(DWORD, DWORD, LPMONIKER *);
    STDMETHOD (GetContainer)(LPOLECONTAINER *);
    STDMETHOD (ShowObject)();
    STDMETHOD (OnShowWindow)(BOOL);
    STDMETHOD (RequestNewObjectLayout)();
    
    // *** IAdviseSink methods *** 
    STDMETHOD_(void,OnDataChange)(FORMATETC *, STGMEDIUM *);
    STDMETHOD_(void,OnViewChange)(DWORD, LONG);
    STDMETHOD_(void,OnRename)(LPMONIKER);
    STDMETHOD_(void,OnSave)();
    STDMETHOD_(void,OnClose)();
    
    // *** IOleWindow Methods ***
    STDMETHOD (GetWindow) (HWND * phwnd);
    STDMETHOD (ContextSensitiveHelp) (BOOL fEnterMode);
    
    // *** IOleInPlaceSite Methods *** 
    STDMETHOD (CanInPlaceActivate) (void);
    STDMETHOD (OnInPlaceActivate) (void);
    STDMETHOD (OnUIActivate) (void);
    STDMETHOD (GetWindowContext) (IOleInPlaceFrame ** ppFrame, IOleInPlaceUIWindow ** ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
    STDMETHOD (Scroll) (SIZE scrollExtent);
    STDMETHOD (OnUIDeactivate) (BOOL fUndoable);
    STDMETHOD (OnInPlaceDeactivate) (void);
    STDMETHOD (DiscardUndoState) (void);
    STDMETHOD (DeactivateAndUndo) (void);
    STDMETHOD (OnPosRectChange) (LPCRECT lprcPosRect); 

    // IOleInPlaceUIWindow methods.
    STDMETHOD (GetBorder)(LPRECT lprectBorder);
    STDMETHOD (RequestBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
    STDMETHOD (SetBorderSpace)(LPCBORDERWIDTHS lpborderwidths);
    STDMETHOD (SetActiveObject)(IOleInPlaceActiveObject * pActiveObject,
                                LPCOLESTR lpszObjName);

    // IOleInPlaceFrame methods
    STDMETHOD (InsertMenus)(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths);
    STDMETHOD (SetMenu)(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject);
    STDMETHOD (RemoveMenus)(HMENU hmenuShared);
    STDMETHOD (SetStatusText)(LPCOLESTR pszStatusText);
    STDMETHOD (EnableModeless)(BOOL fEnable);
    STDMETHOD (TranslateAccelerator)(LPMSG lpmsg, WORD wID);

    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguid, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguid, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // IDispatch (for ambient properties)
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
    STDMETHODIMP GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
        LCID lcid, DISPID *rgDispId);
    STDMETHODIMP Invoke(DISPID dispIdMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pvarResult,
        EXCEPINFO *pExcepInfo, UINT *puArgErr);
};

HRESULT COleControlHost::GetTypeInfoCount(UINT* pctinfo)
{
    if (_pdispSiteDelegate)
    {
        return _pdispSiteDelegate->GetTypeInfoCount(pctinfo);
    }

    return E_NOTIMPL;
}

HRESULT COleControlHost::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo)
{
    if (_pdispSiteDelegate)
    {
        return _pdispSiteDelegate->GetTypeInfo(iTInfo, lcid, ppTInfo);
    }

    return E_NOTIMPL;
}

HRESULT COleControlHost::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames,
        LCID lcid, DISPID *rgDispId)
{
    if (_pdispSiteDelegate)
    {
        return _pdispSiteDelegate->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispId);
    }

    return E_NOTIMPL;
}

HRESULT COleControlHost::Invoke(DISPID dispIdMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS  *pDispParams, VARIANT  *pvarResult,
        EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
    if (_pdispSiteDelegate)
    {
        return _pdispSiteDelegate->Invoke(dispIdMember, riid, lcid, wFlags, pDispParams, pvarResult, pExcepInfo, puArgErr);
    }

    return DISP_E_MEMBERNOTFOUND;
}

HRESULT COleControlHost::_Draw(HDC hdc)
{
    HRESULT hr = E_FAIL;
        
    if (_hwnd && _punkOC && !_bInPlaceActive)
    {
        RECT rc;
        GetClientRect(_hwnd, &rc);
        hr = OleDraw(_punkOC, _dwAspect, hdc, &rc);
    }
    return(hr);
}

HRESULT COleControlHost::_PersistInit()
{
    IPersistStreamInit * pIPersistStreamInit;

    if (_SendNotify(OCN_PERSISTINIT, NULL) == OCNPERSISTINIT_HANDLED)
        return S_FALSE;
    
    HRESULT hr = _punkOC->QueryInterface(IID_IPersistStreamInit, (void **)&pIPersistStreamInit);
    if (SUCCEEDED(hr))
    {
        hr = pIPersistStreamInit->InitNew();
        pIPersistStreamInit->Release();
    }
    else    
    {
        IPersistStorage * pIPersistStorage;
        hr = _punkOC->QueryInterface(IID_IPersistStorage, (void **)&pIPersistStorage);
        if (SUCCEEDED(hr))
        {
            // Create a zero sized ILockBytes.
            ILockBytes *pILockBytes;
            hr = CreateILockBytesOnHGlobal(NULL, TRUE, &pILockBytes);
            if (SUCCEEDED(hr)) {
                // Use the ILockBytes to create a storage.
                IStorage    *pIStorage;
                hr = StgCreateDocfileOnILockBytes(pILockBytes,
                                                  STGM_CREATE |
                                                  STGM_READWRITE |
                                                  STGM_SHARE_EXCLUSIVE,
                                                  0, &pIStorage);
                if (SUCCEEDED(hr)) {
                    // Call InitNew to initialize the object.
                    hr = pIPersistStorage->InitNew(pIStorage);
                    // Clean up
                    pIStorage->Release();
                } // IStorage
                pILockBytes->Release();
            } // ILockBytes
            pIPersistStorage->Release();
        }   
    }
    return hr;
}

HRESULT COleControlHost::_Init()
{
    HRESULT hr = E_FAIL;

    OCNCOCREATEMSG ocm = {0};
    ocm.clsidOC = _clsidOC;
    ocm.ppunk = &_punkOC;
    if(_SendNotify(OCN_COCREATEINSTANCE, &ocm.nmhdr) != OCNCOCREATE_HANDLED)
    {
        hr = CoCreateInstance(_clsidOC, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, 
                                  IID_IUnknown, (LPVOID *)&_punkOC);
        if (FAILED(hr))
        {
            TraceMsg(TF_OCCONTROL, "_Init: Unable to CoCreateInstance this Class ID -- hr = %lX -- hr = %lX", _clsidOC, hr);
            return hr;
        }
        
    }
    
    ASSERT(_punkOC != NULL);
        
    if (_punkOC == NULL)
        return E_FAIL;
    
    hr = _punkOC->QueryInterface(IID_IOleObject, (void **)&_pIOleObject);    
    if (FAILED(hr))
    {
        TraceMsg(TF_OCCONTROL, "_Init: Unable to QueryInterface IOleObject -- hr = %s", hr);
        return hr;
    }

    hr = _pIOleObject->GetMiscStatus(_dwAspect, &_dwMiscStatus);

    // Set the inplace active flag here
    // If this fails, we will assume that we can setclientsite later

    if (_dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)
    {   
        hr = _pIOleObject->SetClientSite(this);
        _PersistInit();
    }
    else
    {
        _PersistInit();
        hr = _pIOleObject->SetClientSite(this);
    }
    
    if (FAILED(hr))
    {
        TraceMsg(TF_OCCONTROL, "_Init: Unable to set client site -- hr = %lX", hr);
        return hr;
    }
    
    
    if (SUCCEEDED(_punkOC->QueryInterface(IID_IViewObject, (void **)&_pIViewObject)))
    {    
        _pIViewObject->SetAdvise(_dwAspect, 0, this);
    }
    
    //FEATURE: this is not really useful because we do not handle the cases, yet 
    _pIOleObject->Advise(this, &_dwConnection);
    
    _pIOleObject->SetHostNames(TEXTW("OC Host Window"), TEXTW("OC Host Window"));
    
    return S_OK;
}

// 
HRESULT COleControlHost::_Activate()
{
    HRESULT hr = E_FAIL;
    
    RECT rcClient;
    ASSERT(_hwnd);
    
    _SendNotify(OCN_ACTIVATE, NULL);
    
    if (!GetClientRect(_hwnd, &rcClient))
        SetRectEmpty(&rcClient);
    
    hr = _pIOleObject->DoVerb(OLEIVERB_INPLACEACTIVATE, NULL, this, 0, _hwnd, &rcClient);
    
    if (SUCCEEDED(hr))
        _bInPlaceActive = TRUE;
    
    // Calling second DoVerb with OLEIVERB_SHOW because:
    // 1. If the above DoVerb fails, this is a back up activation call
    // 2. If the above DoVerb succeeds, this is also necessary because 
    //    Some embeddings needs to be explicitly told to show themselves.
    
    if (!(_dwMiscStatus & OLEMISC_INVISIBLEATRUNTIME)) 
        hr = _pIOleObject->DoVerb(OLEIVERB_SHOW, NULL, this, 0, _hwnd, &rcClient);      
    
    if (FAILED(hr))
        TraceMsg(TF_OCCONTROL, "_Activate: %d Unable to DoVerb! Error = %lX", _bInPlaceActive, hr);

    return hr;
}

HRESULT COleControlHost::_Deactivate()
{
    _SendNotify(OCN_DEACTIVATE, NULL);
    if (_pIOleIPObject)
    {
        _pIOleIPObject->InPlaceDeactivate();
        // Should be set to NULL by the above function call
        ASSERT(_pIOleIPObject == NULL);
        
        return S_OK;
    }
    
    return S_FALSE;
}

HRESULT COleControlHost::_DoVerb(long iVerb, LPMSG lpMsg)
{
    HRESULT hr = E_FAIL;
    
    RECT rcClient;
    ASSERT(_hwnd && IsWindow(_hwnd));
    
    if (!GetClientRect(_hwnd, &rcClient))
        SetRectEmpty(&rcClient);
    
    hr = _pIOleObject->DoVerb(iVerb, lpMsg, this, 0, _hwnd, &rcClient);
    
    if (SUCCEEDED(hr))
        _bInPlaceActive = TRUE;
    
    if (FAILED(hr))
        TraceMsg(TF_OCCONTROL, "_Activate: %d Unable to DoVerb! Error = %lX", _bInPlaceActive, hr);

    return hr;
}

// Clean up and Release all of interface pointers used in this object
HRESULT COleControlHost::_Exit()
{
    _SendNotify(OCN_EXIT, NULL);
    if (_pIViewObject)
    {
        _pIViewObject->SetAdvise(_dwAspect, 0, NULL);
        _pIViewObject->Release();
        _pIViewObject = NULL;
    }
    
    if (_pIOleObject)
    {
        if (_dwConnection)
        {
            _pIOleObject->Unadvise(_dwConnection);
            _dwConnection = 0;
        }
        
        _pIOleObject->Close(OLECLOSE_NOSAVE);
        _pIOleObject->SetClientSite(NULL);
        _pIOleObject->Release();
        _pIOleObject = NULL;
    }

    if (_punkOC)
    {
        ULONG ulRef;
        ulRef = _punkOC->Release();
        _punkOC = NULL;
        if (ulRef != 0)
            TraceMsg(TF_OCCONTROL, "OCHOST _Exit: After last release ref = %d > 0", ulRef);
    }
    
    ATOMICRELEASE(_pIDocHostUIParent);
    ATOMICRELEASE(_pIDocHostUIParent2);

    if (_punkOwner) {
        _punkOwner->Release();
        _punkOwner = NULL;
    }
        
    if (_pdispSiteDelegate) {
        _pdispSiteDelegate->Release();
        _pdispSiteDelegate = NULL;
    }
        
    return S_OK;
}

COleControlHost::COleControlHost(HWND hwnd)
    : _cRef(1), _dwAspect(DVASPECT_CONTENT), _hwnd(hwnd)
    {
    // These variables should be initialized to zeros automatically
    ASSERT(_dwMiscStatus == 0);
    ASSERT(_dwConnection == 0);
    ASSERT(_bInPlaceActive == FALSE);
    ASSERT(_pIDocHostUIParent  == NULL);
    ASSERT(_pIDocHostUIParent2 == NULL);
    ASSERT(_clsidOC == CLSID_NULL);
    ASSERT(_punkOC == NULL);
    ASSERT(_pIViewObject == NULL);
    ASSERT(_pIOleIPObject == NULL);
    ASSERT(_pdispSiteDelegate == NULL);

    ASSERT(_hwnd);
    
}


#ifdef DEBUG
#define _AddRef(psz) { ++_cRef; TraceMsg(TF_OCCONTROL, "CDocObjectHost(%x)::QI(%s) is AddRefing _cRef=%lX", this, psz, _cRef); }
#else
#define _AddRef(psz)    ++_cRef
#endif

// *** IUnknown Methods ***

HRESULT COleControlHost::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    // ppvObj must not be NULL
    ASSERT(ppvObj != NULL);

    if (ppvObj == NULL)
        return E_INVALIDARG;
    
    *ppvObj = NULL;

    if ((IsEqualIID(riid, IID_IUnknown)) ||
        (IsEqualIID(riid, IID_IOleWindow)) || 
        (IsEqualIID(riid, IID_IOleInPlaceUIWindow)) || 
        (IsEqualIID(riid, IID_IOleInPlaceFrame)))
    {
        *ppvObj = SAFECAST(this, IOleInPlaceFrame *);
        TraceMsg(TF_OCCONTROL, "QI IOleInPlaceFrame succeeded");
    }
    else if (IsEqualIID(riid, IID_IServiceProvider)) 
    {
        *ppvObj = SAFECAST(this, IServiceProvider *);
        TraceMsg(TF_OCCONTROL, "QI IServiceProvider succeeded");
    }
        
    else if (IsEqualIID(riid, IID_IOleClientSite))
    {
        *ppvObj = SAFECAST(this, IOleClientSite *);
        TraceMsg(TF_OCCONTROL, "QI IOleClientSite succeeded");
    }
    else if (IsEqualIID(riid, IID_IAdviseSink))
    {
        *ppvObj = SAFECAST(this, IAdviseSink *);
        TraceMsg(TF_OCCONTROL, "QI IAdviseSink succeeded");
    }
    else if (IsEqualIID(riid, IID_IOleInPlaceSite))
    {
        *ppvObj = SAFECAST(this, IOleInPlaceSite *);
        TraceMsg(TF_OCCONTROL, "QI IOleInPlaceSite succeeded");
    } 
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
    {
        *ppvObj = SAFECAST(this, IOleCommandTarget *);
        TraceMsg(TF_OCCONTROL, "QI IOleCommandTarget succeeded");
    }
    else if (NULL != _pIDocHostUIParent  && 
            IsEqualIID(riid, IID_IDocHostUIHandler))
    {
        // only implement this if the host implements it
        *ppvObj = SAFECAST(&_xuih, IDocHostUIHandler *);
        TraceMsg(TF_OCCONTROL, "QI IDocHostUIHandler succeeded");
    }
    else if (NULL != _pIDocHostUIParent2  && 
            IsEqualIID(riid, IID_IDocHostUIHandler2))
    {
        // only implement this if the host implements it
        *ppvObj = SAFECAST(&_xuih, IDocHostUIHandler2 *);
        TraceMsg(TF_OCCONTROL, "QI IDocHostUIHandler2 succeeded");
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = SAFECAST(this, IDispatch *);
        TraceMsg(TF_OCCONTROL, "QI IDispatch succeeded");
    }
    else
        return E_NOINTERFACE;  // Otherwise, don't delegate to HTMLObj!!
     
    
    _AddRef(TEXT("IOleInPlaceSite"));
    return S_OK;
}


ULONG COleControlHost::AddRef()
{
    _cRef++;
    TraceMsg(TF_OCCONTROL, "COleControlHost(%x)::AddRef called, new _cRef=%lX", this, _cRef);
    return _cRef;
}

ULONG COleControlHost::Release()
{
    _cRef--;
    TraceMsg(TF_OCCONTROL, "COleControlHost(%x)::Release called, new _cRef=%lX", this, _cRef);
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

// ServiceProvider interfaces
HRESULT COleControlHost::QueryService(REFGUID guidService,
                                    REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL;
    
    if (_punkOwner) {
        IServiceProvider *psp;
        
        _punkOwner->QueryInterface(IID_IServiceProvider, (LPVOID*)&psp);
        if (psp) {
            hres = psp->QueryService(guidService, riid, ppvObj);
            psp->Release();
        }
    }
    
    return hres;
}

// ************************ IOleClientSite methods ****************** 

HRESULT COleControlHost::SaveObject()
{
    //FEATURE: default set to E_NOTIMPL may not be correct
    HRESULT hr = E_NOTIMPL;
    
    IStorage * pIs;
    if (SUCCEEDED(_punkOC->QueryInterface(IID_IStorage, (void **)&pIs)))
    {
        IPersistStorage *pIps;
        if (SUCCEEDED(_punkOC->QueryInterface(IID_IPersistStorage, (void **)&pIps)))
        {
            OleSave(pIps, pIs, TRUE);
            pIps->SaveCompleted(NULL);
            pIps->Release();
            hr = S_OK;
        }
        pIs->Release();
    }
    
    return hr;   
}

HRESULT COleControlHost::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER * ppMk)
{
     return E_NOTIMPL;   
}

HRESULT COleControlHost::GetContainer(LPOLECONTAINER * ppContainer)
{
    *ppContainer = NULL;       
    return E_NOINTERFACE;
}

HRESULT COleControlHost::ShowObject()
{
//    RECTL rcl;
//    POINT pt1, pt2;
    
    return S_OK;   
}

HRESULT COleControlHost::OnShowWindow(BOOL fShow)
{
    return S_OK;
}

HRESULT COleControlHost::RequestNewObjectLayout()
{
     return E_NOTIMPL;   
}

// ************************ IAdviseSink methods ********************* 
void COleControlHost::OnDataChange(FORMATETC * pFmt, STGMEDIUM * pStgMed)
{
    // NOTES: This is optional
    return;   
}
    
void COleControlHost::OnViewChange(DWORD dwAspect, LONG lIndex)
{
    // FEATURE: need to let the container know the colors might have changed
    // but don't want to deal with the paletts now

    // Draw only if not inplace active and this is the right aspect.  Inplace
    // active objects have their own window and are responsible for painting
    // themselves.
    
    // WARNING: _bInPlaceActive is not determined, yet. 
    // This funtion is called as a result of calling doverb, however, 
    // _bInPlaceActive will only be determined as DoVerb returns
    // works fine for now, but could be trouble later. 
    if ((_hwnd) && (!_bInPlaceActive) && (dwAspect == _dwAspect))
    {
        HDC hdc = GetDC(_hwnd);

        if (hdc)
        {
            _Draw(hdc);
            ReleaseDC(_hwnd, hdc);
        }
    }
}

void COleControlHost::OnRename(LPMONIKER pMoniker)
{
    return;   
}

void COleControlHost::OnSave()
{
    // NOTES: This is optional
    return;   
}

void COleControlHost::OnClose()
{
    // FEATURE: need to let the container know the colors might have changed
    return;   
}

// ************************ IOleWindow Methods ********************** 
HRESULT COleControlHost::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;
    return S_OK;
}

HRESULT COleControlHost::ContextSensitiveHelp(BOOL fEnterMode)
{
    // NOTES: This is optional
    return E_NOTIMPL;   
}

// *********************** IOleInPlaceSite Methods *****************
HRESULT COleControlHost::CanInPlaceActivate(void)
{
    return S_OK;   
}

HRESULT COleControlHost::OnInPlaceActivate(void)
{
    if (!_pIOleIPObject)
        return (_punkOC->QueryInterface(IID_IOleInPlaceObject, (void **)&_pIOleIPObject));    
    else
        return S_OK;
}


HRESULT COleControlHost::OnUIActivate(void)
{
    LRESULT lres;
    OCNONUIACTIVATEMSG oam = {0};

    oam.punk = _punkOC;

    lres = _SendNotify(OCN_ONUIACTIVATE, &oam.nmhdr);
    return S_OK;
}

HRESULT COleControlHost::GetWindowContext (IOleInPlaceFrame ** ppFrame, IOleInPlaceUIWindow ** ppIIPUIWin, 
                                           LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
    *ppFrame = this;
    _AddRef("GetWindowContext");
        
    // This is set to NULL because the document window is the same as the frame 
    // window
    *ppIIPUIWin = NULL;
    
    ASSERT(_hwnd);
    if (!GetClientRect(_hwnd, lprcPosRect))
        SetRectEmpty(lprcPosRect);
    
    // Set the clip rectangle to be the same as the position rectangle
    
    CopyRect(lprcClipRect, lprcPosRect);
        
    lpFrameInfo->cb = sizeof(OLEINPLACEFRAMEINFO);
    
#ifdef MDI
    lpFrameInfo->fMDIApp = TRUE;
#else
    lpFrameInfo->fMDIApp = FALSE;
#endif
    lpFrameInfo->hwndFrame = _hwnd;
    lpFrameInfo->haccel = 0;
    lpFrameInfo->cAccelEntries = 0;
    return S_OK;
}

HRESULT COleControlHost::Scroll(SIZE scrollExtent)
{
    // Should implement later
    return E_NOTIMPL;   
}

HRESULT COleControlHost::OnUIDeactivate(BOOL fUndoable)
{
    
    return E_NOTIMPL;   
}


HRESULT COleControlHost::OnInPlaceDeactivate(void)
{
    if (_pIOleIPObject)
    {
        _pIOleIPObject->Release();
        _pIOleIPObject = NULL;
    }
    
    return S_OK;
}

HRESULT COleControlHost::DiscardUndoState(void)
{
    // Should implement later
    return E_NOTIMPL;   
}

HRESULT COleControlHost::DeactivateAndUndo(void)
{
    // Should implement later
    return E_NOTIMPL;   
}

HRESULT COleControlHost::OnPosRectChange(LPCRECT lprcPosRect) 
{
    // We do not allow the children to change the size themselves
    OCNONPOSRECTCHANGEMSG opcm = {0};
    opcm.prcPosRect = lprcPosRect;
    _SendNotify(OCN_ONPOSRECTCHANGE, &opcm.nmhdr);
    return S_OK;
}
// ************************ IOleInPlaceUIWindow methods *************

HRESULT COleControlHost::GetBorder(LPRECT lprectBorder)
{
    return E_NOTIMPL;
}

HRESULT COleControlHost::RequestBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    return E_NOTIMPL;
}

HRESULT COleControlHost::SetBorderSpace(LPCBORDERWIDTHS lpborderwidths)
{
    return E_NOTIMPL;
}

HRESULT COleControlHost::SetActiveObject(IOleInPlaceActiveObject * pActiveObject,
                                LPCOLESTR lpszObjName)
{
    return E_NOTIMPL;
}

// *********************** IOleInPlaceFrame Methods *****************
HRESULT COleControlHost::InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    // Should implement later
    return E_NOTIMPL;   
}

HRESULT COleControlHost::SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject)
{
    // Should implement later
    return E_NOTIMPL;   
}

HRESULT COleControlHost::RemoveMenus(HMENU hmenuShared)
{
    // Should implement later
    return E_NOTIMPL;   
}

HRESULT COleControlHost::SetStatusText(LPCOLESTR pszStatusText)
{
    OCNONSETSTATUSTEXTMSG osst = {0};
    osst.pwszStatusText = pszStatusText;
    _SendNotify(OCN_ONSETSTATUSTEXT, &osst.nmhdr);
    return S_OK;
}

HRESULT COleControlHost::EnableModeless(BOOL fEnable)
{
    // Should implement later
    return E_NOTIMPL;   
}

HRESULT COleControlHost::TranslateAccelerator(LPMSG lpmsg, WORD wID)
{
    // Should implement later
    return E_NOTIMPL;   
}

// ************************ IOleCommandTarget Methods *************
HRESULT COleControlHost::QueryStatus(const GUID *pguid, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT *pcmdtext)
{
    return IUnknown_QueryStatus(_punkOwner, pguid, cCmds, rgCmds, pcmdtext);
}

HRESULT COleControlHost::Exec(const GUID *pguid, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    return IUnknown_Exec(_punkOwner, pguid, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}

HRESULT COleControlHost::_InitOCStruct(LPOCHINITSTRUCT lpocs)
{               
    HRESULT hres = E_FAIL;

    if (_punkOC)
        return S_FALSE;
    
    if (lpocs)
    {
        if (lpocs->cbSize != SIZEOF(OCHINITSTRUCT))
            return hres;

        if (lpocs->clsidOC == CLSID_NULL)
            return hres;

        _clsidOC = lpocs->clsidOC;
        _SetOwner(lpocs->punkOwner);
    }
    else 
        return hres;

    hres = _Init();
    if (SUCCEEDED(hres))
        hres = _Activate();    
    
    return hres;
}

LRESULT COleControlHost::_OnPaint()
{
    ASSERT(_hwnd);

    PAINTSTRUCT ps;

    HDC hdc = BeginPaint(_hwnd, &ps);    
    _Draw(hdc);
    EndPaint(_hwnd, &ps);
    return 0;
}

LRESULT COleControlHost::_OnSize(HWND hwnd, LPARAM lParam)
{
    if (_pIOleIPObject)
    {
        RECT rcPos, rcClip ;
        SetRect( &rcPos, 0, 0, LOWORD(lParam), HIWORD(lParam) ) ;
        rcClip = rcPos ;
        _pIOleIPObject->SetObjectRects(&rcPos, &rcClip);
    }
    return 0;
}

LRESULT COleControlHost::_OnCreate(HWND hwnd, LPCREATESTRUCT lpcs)
{   
    TCHAR szClsid[50];
    _hwndParent = GetParent(hwnd);
    SetWindowLongPtr(hwnd, 0, (LONG_PTR)this);
    
    LPOCHINITSTRUCT lpois = (LPOCHINITSTRUCT)lpcs->lpCreateParams;
    HRESULT hres = S_OK;
        
    if (lpois)
        hres = _InitOCStruct(lpois);
    else if (GetWindowText(hwnd, szClsid, ARRAYSIZE(szClsid)))
    {
        OCHINITSTRUCT ois;
        ois.cbSize = SIZEOF(OCHINITSTRUCT);
        if (FAILED(SHCLSIDFromString(szClsid, &ois.clsidOC)))
            ois.clsidOC = CLSID_NULL;
        ois.punkOwner = NULL;
        
        hres = _InitOCStruct(&ois);
    }
    
    if (FAILED(hres))
        return -1;
    return 0;
}

LRESULT COleControlHost::_OnDestroy()
{    
    ASSERT(_hwnd);
    SetWindowLongPtr(_hwnd, 0, 0);
    _ConnectEvents( _punkOC, FALSE ) ;
    _Deactivate();
    _Exit();
    Release();
   
    return 0;
}

LRESULT COleControlHost::_OnQueryInterface(WPARAM wParam, LPARAM lParam)
{
    if (lParam)
    {
        QIMSG * qiMsg = (QIMSG *)lParam;
        return _punkOC->QueryInterface(*qiMsg->qiid, qiMsg->ppvObject);
    }
    return -1;
}

LRESULT COleControlHost::_SetOwner(IUnknown * punkNewOwner)
{
    if (_punkOwner)
        _punkOwner->Release();
    _punkOwner = punkNewOwner;
    if (_punkOwner)
        _punkOwner->AddRef();

    ATOMICRELEASE(_pIDocHostUIParent);
    ATOMICRELEASE(_pIDocHostUIParent2);

    // Query if owner supports IDocHostUIHandler, if so then
    // we turn on our delegating wrapper
    if (punkNewOwner)
    {
        punkNewOwner->QueryInterface(IID_IDocHostUIHandler,  (LPVOID *)&_pIDocHostUIParent);
        punkNewOwner->QueryInterface(IID_IDocHostUIHandler2, (LPVOID *)&_pIDocHostUIParent2);
    }
    return 0;
}

LRESULT COleControlHost::_ConnectEvents( LPUNKNOWN punkOC, BOOL bConnect )
{
    if( bConnect )
    {
        ASSERT( punkOC ) ;
        return _eventSink.Connect( _hwndParent, _hwnd, punkOC ) ;
    }
    return _eventSink.Disconnect() ;
}

LRESULT COleControlHost::_SetServiceProvider(IServiceProvider* pSP)
{
    // Free any existing delegates
    if (_pdispSiteDelegate)
    {
        _pdispSiteDelegate->Release();
    }
    
    // For now, we just delegate IDispatch (Ambient properties) calls
    HRESULT hr = pSP->QueryService(SID_OleControlSite, IID_PPV_ARG(IDispatch, &_pdispSiteDelegate));

    if (FAILED(hr))
    {
        _pdispSiteDelegate = NULL;
    }

    return 0;
}

LRESULT COleControlHost::_SendNotify(UINT code, LPNMHDR pnmhdr)
{
    NMHDR nmhdr;
    ASSERT(_hwnd);

    if (!_hwndParent)
        return 0;
   
    if (!pnmhdr)
        pnmhdr = &nmhdr;
    pnmhdr->hwndFrom = _hwnd;  
    pnmhdr->idFrom = GetDlgCtrlID( _hwnd ) ;
    pnmhdr->code = code;
    
    return SendMessage(_hwndParent, WM_NOTIFY, 0, (LPARAM)pnmhdr);
}



LRESULT CALLBACK COleControlHost::OCHostWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    COleControlHost *pcoch = (COleControlHost *)GetWindowPtr(hwnd, 0);

    if (!pcoch && (uMsg != WM_CREATE))
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);            
    
    switch(uMsg)
    {
    case WM_CREATE:
        pcoch = new COleControlHost(hwnd);
        if (pcoch)
            return pcoch->_OnCreate(hwnd, (LPCREATESTRUCT)lParam);
        return -1;

    case WM_ERASEBKGND:
        if (pcoch->_punkOC && pcoch->_bInPlaceActive)
        {
            //  Now tell windows we don't need no stinkin'
            //  erased background because our view object
            //  is in-place active and he/she will be
            //  taking over from here.
            return TRUE;
        }
        break;
        
    case WM_PAINT:
        return pcoch->_OnPaint();
        
    case WM_SIZE:
        return pcoch->_OnSize(hwnd, lParam);
        
    case WM_DESTROY:
        return pcoch->_OnDestroy();
        
    case OCM_QUERYINTERFACE:
        return  pcoch->_OnQueryInterface(wParam, lParam);
        
    case OCM_INITIALIZE:
        return pcoch->_InitOCStruct((LPOCHINITSTRUCT)lParam);
        
    case OCM_SETOWNER:
        return pcoch->_SetOwner((IUnknown*)lParam);
    
    case OCM_DOVERB:
        return pcoch->_DoVerb((long)wParam, (LPMSG)lParam);

    case OCM_ENABLEEVENTS:
        return pcoch->_ConnectEvents( pcoch->_punkOC, (BOOL)wParam ) ;

    case OCM_SETSERVICEPROVIDER:
        return pcoch->_SetServiceProvider((IServiceProvider*) lParam);
    
    case WM_PALETTECHANGED:
        if (pcoch->_pIOleIPObject) {
            HWND hwnd;
            if (SUCCEEDED(pcoch->_pIOleIPObject->GetWindow(&hwnd))) {
                SendMessage(hwnd, WM_PALETTECHANGED, wParam, lParam);
                }
        }   
        break;

    case WM_SETFOCUS:
        
        //  OC doesn't respond to OLEIVERB_UIACTIVATE ?
        if( pcoch->_dwMiscStatus & OLEMISC_NOUIACTIVATE )
        {
            //  so explicitly assign focus
            HWND hwndObj ;
            if( pcoch->_pIOleIPObject && 
                SUCCEEDED( pcoch->_pIOleIPObject->GetWindow( &hwndObj ) ) )
                SetFocus( hwndObj ) ;
        }
        else
            pcoch->_DoVerb( OLEIVERB_UIACTIVATE, NULL ) ;

        break ;

        
    default:
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);            
    }
    
    return 0;
}

void COleControlHost::_RegisterClass()
{
    WNDCLASS wc = {0};

    wc.style         = CS_GLOBALCLASS;
    wc.lpfnWndProc   = OCHostWndProc;
    //wc.cbClsExtra    = 0;
    wc.cbWndExtra    = SIZEOF(LPVOID);
    wc.hInstance     = HINST_THISDLL;
    //wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor (NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
    //wc.lpszMenuName  = NULL;
    wc.lpszClassName = OCHOST_CLASS;
    SHRegisterClass(&wc);
}


HRESULT CProxyUIHandler::QueryInterface(REFIID riid, LPVOID * ppvObj)
{   
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->QueryInterface(riid, ppvObj); 
};

ULONG CProxyUIHandler::AddRef(void)
{   
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->AddRef(); 
};

ULONG CProxyUIHandler::Release(void)
{   
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->Release(); 
};

HRESULT CProxyUIHandler::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->ShowContextMenu(dwID, ppt, pcmdtReserved, pdispReserved) : E_NOTIMPL;
}

HRESULT CProxyUIHandler::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->GetHostInfo(pInfo) : E_NOTIMPL;
}

HRESULT CProxyUIHandler::ShowUI(DWORD dwID, IOleInPlaceActiveObject *pActiveObject, IOleCommandTarget *pCommandTarget, IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->ShowUI(dwID, pActiveObject, pCommandTarget, pFrame, pDoc): E_NOTIMPL;
}

HRESULT CProxyUIHandler::HideUI()
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->HideUI(): E_NOTIMPL;
}

HRESULT CProxyUIHandler::UpdateUI()
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->UpdateUI(): E_NOTIMPL;
}

HRESULT CProxyUIHandler::EnableModeless(BOOL fActivate)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->EnableModeless(fActivate): E_NOTIMPL;
}

HRESULT CProxyUIHandler::OnDocWindowActivate(BOOL fActivate)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->OnDocWindowActivate(fActivate): E_NOTIMPL;
}

HRESULT CProxyUIHandler::OnFrameWindowActivate(BOOL fActivate)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->OnFrameWindowActivate(fActivate): E_NOTIMPL;
}

HRESULT CProxyUIHandler::ResizeBorder(LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->ResizeBorder(prcBorder, pUIWindow, fRameWindow): E_NOTIMPL;
}

HRESULT CProxyUIHandler::TranslateAccelerator(LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->TranslateAccelerator(lpMsg, pguidCmdGroup, nCmdID): E_NOTIMPL;
}

HRESULT CProxyUIHandler::GetOptionKeyPath(LPOLESTR *pchKey, DWORD dw)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->GetOptionKeyPath(pchKey, dw): E_NOTIMPL;
}

HRESULT CProxyUIHandler::GetDropTarget(IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->GetDropTarget(pDropTarget, ppDropTarget) : E_NOTIMPL;
}

HRESULT CProxyUIHandler::GetExternal(IDispatch **ppDispatch)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->GetExternal(ppDispatch) : E_NOTIMPL;
}

HRESULT CProxyUIHandler::TranslateUrl(DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->TranslateUrl(dwTranslate, pchURLIn, ppchURLOut) : E_NOTIMPL;
}

HRESULT CProxyUIHandler::FilterDataObject( IDataObject *pDO, IDataObject **ppDORet)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent ? poch->_pIDocHostUIParent->FilterDataObject(pDO, ppDORet) : E_NOTIMPL;
}

HRESULT CProxyUIHandler::GetOverrideKeyPath( LPOLESTR *pchKey, DWORD dw)
{
    COleControlHost *poch = IToClass(COleControlHost, _xuih, this);

    return poch->_pIDocHostUIParent2 ? poch->_pIDocHostUIParent2->GetOverrideKeyPath(pchKey, dw) : E_NOTIMPL;    
}

STDAPI_(BOOL) DllRegisterWindowClasses(const SHDRC * pshdrc)
{
    if (pshdrc && pshdrc->cbSize == SIZEOF(SHDRC) && !(pshdrc->dwFlags & ~SHDRCF_ALL))
    {
        if (pshdrc->dwFlags & SHDRCF_OCHOST)
        {
            COleControlHost::_RegisterClass();
            return TRUE;
        }
    }
    return FALSE;
}

//---------------------------------------------------------------------------
//  CEventSink constructor
CEventSink::CEventSink( BOOL bAutoDelete )
    :    _hwndSite(NULL),
         _hwndOwner(NULL),
         _punkOC(NULL),
         _dwCookie(0),
         _cRef(1),
         _bAutoDelete( bAutoDelete )
{
    _iid = _iidDefault = IID_NULL ;
}

//  CEventSink IUnknown impl
STDMETHODIMP CEventSink::QueryInterface( REFIID riid, void** ppvObj )
{
    *ppvObj = NULL ;
    if( IsEqualGUID( riid, IID_IUnknown ) || 
        IsEqualGUID( riid, IID_IDispatch )||
        IsEqualGUID( riid, _iidDefault ) )
    {
        *ppvObj = this ;
        return S_OK ;
    }
    return E_NOINTERFACE ;
}

STDMETHODIMP_(ULONG) CEventSink::AddRef()
{ 
    return InterlockedIncrement( &_cRef ) ;
}

STDMETHODIMP_(ULONG) CEventSink::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement( &_cRef );
    if( 0 == cRef )
    {
        if( _bAutoDelete )
        {
            delete this ;
        }
    }
    return cRef ;
}

//  Connects the sink to the OC's default event dispatch interface.
BOOL CEventSink::Connect( HWND hwndOwner, HWND hwndSite, LPUNKNOWN punkOC )
{
    ASSERT( punkOC ) ;
    IID iidDefault = IID_NULL ;

    if( SUCCEEDED( _GetDefaultEventIID( punkOC, &iidDefault ) ) )
    {
        _iidDefault = iidDefault ;
        return _Connect( hwndOwner, hwndSite, punkOC, iidDefault ) ;
    }
    return FALSE ;
}

//  Establishes advise connection on the specified interface
BOOL CEventSink::_Connect( HWND hwndOwner, HWND hwndSite, LPUNKNOWN punkOC, REFIID iid )
{
    LPCONNECTIONPOINTCONTAINER pcpc;
    ASSERT(punkOC != NULL) ;
    HRESULT hr = CONNECT_E_CANNOTCONNECT ;

    if( _IsConnected( iid ) )
        return TRUE ;

    if( _dwCookie )
        Disconnect() ;

    if( punkOC &&
        SUCCEEDED( punkOC->QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&pcpc )))
    {
        LPCONNECTIONPOINT pcp = NULL;
        DWORD             dwCookie = 0;
        ASSERT(pcpc != NULL);

        if( SUCCEEDED(pcpc->FindConnectionPoint( iid, &pcp )))
        {
            ASSERT(pcp != NULL);
            hr = pcp->Advise( this, &dwCookie ) ;
            
            if( SUCCEEDED( hr ) )
            {
                _iid = iid ;
                _dwCookie  = dwCookie ;
                _hwndOwner = hwndOwner ;
                _hwndSite  = hwndSite ;
                _punkOC    = punkOC ;
                _punkOC->AddRef() ;
            }
            pcp->Release();
        }
        pcpc->Release();
    }

    return SUCCEEDED( hr ) ;
}

//  Retrieves default event dispatch interface from the OC.
HRESULT CEventSink::_GetDefaultEventIID( LPUNKNOWN punkOC, IID* piid )
{
    HRESULT hr ;

    ASSERT( punkOC ) ;
    ASSERT( piid ) ;

    IProvideClassInfo  *pci ;
    IProvideClassInfo2 *pci2 ;
    *piid = IID_NULL ;

    #define IMPLTYPE_MASK \
        (IMPLTYPEFLAG_FDEFAULT|IMPLTYPEFLAG_FSOURCE|IMPLTYPEFLAG_FRESTRICTED)
    #define IMPLTYPE_DEFAULTSOURCE \
        (IMPLTYPEFLAG_FDEFAULT|IMPLTYPEFLAG_FSOURCE)

    //  Retrieve default outbound dispatch IID using OC's IProvideClassInfo2
    if( SUCCEEDED( (hr = punkOC->QueryInterface( IID_IProvideClassInfo2, (void**)&pci2 )) ) )
    {
        hr = pci2->GetGUID( GUIDKIND_DEFAULT_SOURCE_DISP_IID, piid ) ;
        pci2->Release() ;
    }
    else // no IProvideClassInfo2; try IProvideClassInfo:
    if( SUCCEEDED( (hr = punkOC->QueryInterface( IID_IProvideClassInfo, (void**)&pci )) ) )
    {
        ITypeInfo* pClassInfo = NULL;

        if( SUCCEEDED( (hr = pci->GetClassInfo( &pClassInfo )) ) )
        {
            LPTYPEATTR pClassAttr;
            ASSERT( pClassInfo );

            if( SUCCEEDED( (hr = pClassInfo->GetTypeAttr( &pClassAttr )) ) )
            {
                ASSERT( pClassAttr ) ;
                ASSERT( pClassAttr->typekind == TKIND_COCLASS ) ;

                // Enumerate implemented interfaces looking for default source IID.
                HREFTYPE hRefType;
                int      nFlags;

                for( UINT i = 0; i < pClassAttr->cImplTypes; i++ )
                {
                    if( SUCCEEDED( (hr = pClassInfo->GetImplTypeFlags( i, &nFlags )) ) &&
                        ((nFlags & IMPLTYPE_MASK) == IMPLTYPE_DEFAULTSOURCE) )
                    {
                        // Got the interface, now retrieve its IID:
                        ITypeInfo* pEventInfo = NULL ;

                        if( SUCCEEDED( (hr = pClassInfo->GetRefTypeOfImplType( i, &hRefType )) ) &&
                            SUCCEEDED( (hr = pClassInfo->GetRefTypeInfo( hRefType, &pEventInfo )) ) )
                        {
                            LPTYPEATTR pEventAttr;
                            ASSERT( pEventInfo ) ;

                            if( SUCCEEDED( (hr = pEventInfo->GetTypeAttr( &pEventAttr )) ) )
                            {
                                *piid = pEventAttr->guid ; 
                                pEventInfo->ReleaseTypeAttr(pEventAttr);
                            }
                            pEventInfo->Release();
                        }
                        break;
                    }
                }
                pClassInfo->ReleaseTypeAttr(pClassAttr);
            }
            pClassInfo->Release();
        }
        pci->Release() ;
    }

    if( SUCCEEDED( hr ) && IsEqualIID( *piid, IID_NULL ) )
        hr = E_FAIL ;

    return hr ;
}

//  reports whether the sink is connected to the indicated sink
BOOL CEventSink::_IsConnected( REFIID iid )
{
    return _dwCookie != 0L && 
           IsEqualIID( iid, _iid ) ;
}

//  disconnects the sink
BOOL CEventSink::Disconnect()
{
    LPCONNECTIONPOINTCONTAINER pcpc;

    if( _dwCookie != 0 &&
        _punkOC &&
        SUCCEEDED( _punkOC->QueryInterface(IID_IConnectionPointContainer, (LPVOID*)&pcpc)))
    {
        LPCONNECTIONPOINT pcp = NULL;
        ASSERT(pcpc != NULL);

        if (SUCCEEDED(pcpc->FindConnectionPoint(_iid, &pcp)))
        {
            ASSERT(pcp != NULL);
            pcp->Unadvise(_dwCookie);
            pcp->Release();

            _iid        = IID_NULL ;
            _dwCookie   = 0L ;
            _hwndOwner = NULL ;
            _hwndSite  = NULL ;
            _punkOC->Release() ;
            _punkOC     = NULL ;
        }
        pcpc->Release();
        return TRUE ;
    }

    return FALSE ;
}

//  CEventSink IDispatch interface
STDMETHODIMP CEventSink::Invoke( 
    IN DISPID dispIdMember,
    IN REFIID riid,
    IN LCID lcid,
    IN WORD wFlags,
    IN OUT DISPPARAMS *pDispParams,
    OUT VARIANT *pVarResult,
    OUT EXCEPINFO *pExcepInfo,
    OUT UINT *puArgErr)
{
    //  Copy method args to notification block
    NMOCEVENT   event = {0};
    event.hdr.hwndFrom = _hwndSite;  
    event.hdr.idFrom   = GetDlgCtrlID( _hwndSite ) ;
    event.hdr.code     = OCN_OCEVENT ;
    event.dispID       = dispIdMember ;
    event.iid          = riid ;
    event.lcid         = lcid ;
    event.wFlags       = wFlags ;
    event.pDispParams  = pDispParams ;
    event.pVarResult   = pVarResult ;
    event.pExepInfo    = pExcepInfo ;
    event.puArgErr     = puArgErr ;

    //  Notify parent of event
    ::SendMessage( _hwndOwner, WM_NOTIFY, event.hdr.idFrom, (LPARAM)&event ) ;
    
    //  Cleanup args
    if (pVarResult != NULL)
        VariantClear( pVarResult ) ;

    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\preview.h ===
//  CPrintDoc status defines
//  NB: The # defined of status is important; it 0..2 is used as an array index. (greglett)
#define LOADING_OEHEADER        0
#define LOADING_CONTENT         1       
#define LOADING_TABLEOFLINKS    2
#define PAGING_COMPLETE         3
#define READY_TO_PRINT          4

#define MEMBER(strClass, strMember) \
    strClass.prototype.strMember = strClass##_##strMember

#ifndef DEBUG

#define AssertSz(x, str)
#define PrintDocAlert(str)
#define Transition(nNew, str) this._nStatus = nNew

#else   // ndef DEBUG
#define AssertSz(x, str)    \
    if (!(x))               \
        alert(str)

#define PrintDocAlert(str)  \
    alert("[" + this._strDoc + "," + StatusToString(this._nStatus) + "] " + str )

#define Transition(nNew, str)                                               \
    this._nStatus = nNew;                                                   \
    //PrintDocAlert("Transition status in " + str);
    
#endif      // ndef DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\opsprof.cpp ===
//
// COPSProfile implementation
//

#include "priv.h"
#include "sccls.h"
#include "hlframe.h"
#include "mshtmdid.h"
#include "wtypes.h"

#include "shlwapi.h"

#include "resource.h"

#include "iehelpid.h"

#include <mluisupp.h>

// Definitions copied from WININET

#define COOKIES_WARN     0 // warn with a dlg if using cookies
#define COOKIES_ALLOW    1 // allow cookies without any warning
#define COOKIES_DENY     2 // disable cookies completely


#ifndef VARIANT_TRUE
#define VARIANT_TRUE     ((VARIANT_BOOL)-1)           // TRUE for VARIANT_BOOL
#endif

#ifndef VARIANT_FALSE
#define VARIANT_FALSE    ((VARIANT_BOOL)0)            // FALSE for VARIANT_BOOL
#endif

#define EMPTY_STRINGA(s)    ( !s || (s)[0] == '\0'  )
#define EMPTY_STRINGW(s)    ( !s || (s)[0] == L'\0' )

#ifdef  UNICODE
#define EMPTY_STRING(s)     EMPTY_STRINGW(s)
#else
#define EMPTY_STRING(s)     EMPTY_STRINGA(s)
#endif

// Max number of characters in a friendly OPS attribute name.        
const   int     MAX_PROFILE_NAME = 128;


// Constant non-localizable string definitions
const   TCHAR   rgszP3Global[]  = TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Security\\P3Global");
const   TCHAR   rgszP3Sites[]   = TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Security\\P3Sites");

const   TCHAR   rgszInetKey[]   = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings");
const   TCHAR   rgszPathTxt[]   = TEXT("Path");
const   TCHAR   rgszDomainTxt[] = TEXT("Domain");
const   TCHAR   rgszAllowTxt[]  = TEXT("Allow");
const   TCHAR   rgszDenyTxt[]   = TEXT("Deny");
const   TCHAR   rgszExpireTxt[] = TEXT("Expiration");
const   TCHAR   rgszCookieTxt[] = TEXT("AllowCookies");
const   TCHAR   rgszEnabled[]   = TEXT("Enabled");
const   TCHAR   rgszRegKey[]    = TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\P3\\Write");
const   TCHAR   rgszRegTxt[]    = TEXT("Registration");

const   TCHAR   GENDER_UNSPECIFIED[] = TEXT("U");
const   TCHAR   GENDER_FEMALE[] = TEXT("F");
const   TCHAR   GENDER_MALE[] = TEXT("M");
const   WCHAR   GENDER_FEMALE_W[] = L"F";
const   WCHAR   GENDER_MALE_W[] = L"M";

#ifdef _USE_PSTORE_

// {647EC150-DC4A-11d0-A02C-00C0DFA9C763}
EXTERN_C const GUID GUID_PStoreType = { 0x647ec150, 0xdc4a, 0x11d0, { 0xa0, 0x2c, 0x0, 0xc0, 0xdf, 0xa9, 0xc7, 0x63 } };

PST_KEY s_Key = PST_KEY_CURRENT_USER;

#endif  // _USE_PSTORE_


// Static helper functions
static WCHAR*   _GetNameFromAttrIndex ( int index );
static INT      _GetResourceIdFromAttrIndex( int index );
static ULONG    _GetPropTagFromAttrIndex( int index );


// This table maintains the list of the suffixes for the Standard OPS attributes
// The names are intentionally kept here because these should not be localized.
struct _ProfileAttribute
{
     WCHAR * pwzName;
     int     id;         // resource ID for the friendly name of the attribute.
     ULONG   ulPropTag;
};

const _ProfileAttribute rgProfAttr [] =
        {
            { L"Vcard.DisplayName",             IDS_OPS_COMMONNAME,         PR_DISPLAY_NAME             },
            { L"Vcard.FirstName",               IDS_OPS_GIVENNAME,          PR_GIVEN_NAME               },
            { L"Vcard.LastName",                IDS_OPS_LASTNAME,           PR_SURNAME                  },
            { L"Vcard.MiddleName",              IDS_OPS_MIDDLENAME,         PR_MIDDLE_NAME              },
            // 0, 1, 2 for Unspecified, Female, Male
            { L"Vcard.Gender",                  IDS_OPS_GENDER,             PR_GENDER                   },

            { L"Vcard.Cellular",                IDS_OPS_CELLULAR,           PR_CELLULAR_TELEPHONE_NUMBER},
            { L"Vcard.Email",                   IDS_OPS_EMAIL,              PR_EMAIL_ADDRESS            },
            { L"Vcard.HomePage",                IDS_OPS_URL,                PR_PERSONAL_HOME_PAGE       },

            { L"Vcard.Company",                 IDS_OPS_COMPANY,            PR_COMPANY_NAME             },
            { L"Vcard.Department",              IDS_OPS_DEPARTMENT,         PR_DEPARTMENT_NAME          },
            { L"Vcard.Office",                  IDS_OPS_OFFICE,             PR_OFFICE_LOCATION,         },
            { L"Vcard.JobTitle",                IDS_OPS_JOBTITLE,           PR_TITLE                    },
            { L"Vcard.Pager",                   IDS_OPS_PAGER,              PR_PAGER_TELEPHONE_NUMBER   },
            
            { L"Vcard.Home.StreetAddress",      IDS_OPS_HOME_ADDRESS,       PR_HOME_ADDRESS_STREET      },
            { L"Vcard.Home.City",               IDS_OPS_HOME_CITY,          PR_HOME_ADDRESS_CITY        },
            { L"Vcard.Home.ZipCode",            IDS_OPS_HOME_ZIPCODE,       PR_HOME_ADDRESS_POSTAL_CODE },
            { L"Vcard.Home.State",              IDS_OPS_HOME_STATE,         PR_HOME_ADDRESS_STATE_OR_PROVINCE   },
            { L"Vcard.Home.Country",            IDS_OPS_HOME_COUNTRY,       PR_HOME_ADDRESS_COUNTRY     },
            { L"Vcard.Home.Phone",              IDS_OPS_HOME_PHONE,         PR_HOME_TELEPHONE_NUMBER    },
            { L"Vcard.Home.Fax",                IDS_OPS_HOME_FAX,           PR_HOME_FAX_NUMBER          },

            { L"Vcard.Business.StreetAddress",  IDS_OPS_BUSINESS_ADDRESS,   PR_BUSINESS_ADDRESS_STREET  },
            { L"Vcard.Business.City",           IDS_OPS_BUSINESS_CITY,      PR_BUSINESS_ADDRESS_CITY    },
            { L"Vcard.Business.Zipcode",        IDS_OPS_BUSINESS_ZIPCODE,   PR_BUSINESS_ADDRESS_POSTAL_CODE},
            { L"Vcard.Business.State",          IDS_OPS_BUSINESS_STATE,     PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE},
            { L"Vcard.Business.Country",        IDS_OPS_BUSINESS_COUNTRY,   PR_BUSINESS_ADDRESS_COUNTRY },
            
            { L"Vcard.Business.Phone",          IDS_OPS_BUSINESS_PHONE,     PR_BUSINESS_TELEPHONE_NUMBER},
            { L"Vcard.Business.Fax",            IDS_OPS_BUSINESS_FAX,       PR_BUSINESS_FAX_NUMBER      },
            { L"Vcard.Business.URL",            IDS_OPS_BUSINESS_URL,       PR_BUSINESS_HOME_PAGE       },
        };


// A sentinel value returned for unsuccessful searches
const   int     INVALID_ATTRIBUTE_INDEX = 0xFFFFFFFF;


// Compute the number of bytes necessary to hold a bit-vector for the
// Vcard schema where each attribute is represented by one bit.
const   DWORD   dwVcardCount    = ARRAYSIZE(rgProfAttr);
const   DWORD   dwVcardBytes    = (dwVcardCount+7) / 8;


const   DWORD   defExpireDays   = 7;            // Default expiration time in days
const   DWORD   maxExpireDays   = 30;           // Maximum allowed expiration period

// Number of 100-ns intervals per day
const   __int64 intervalsPerDay = (__int64) 10000000 * 3600 * 24;    

// Default and maximum expiration time in units of 100 nanoseconds
// (This is the format used for the FILETIME structure)
const   __int64 defExpiration = defExpireDays * intervalsPerDay;
const   __int64 maxExpiration = maxExpireDays * intervalsPerDay;


// Context-sensitive help IDS
const   DWORD   aHelpIDs[] =
{
    IDC_OPS_INFO_REQUESTED,     IDH_PA_OPS_REQUEST,
    IDC_OPS_URL,                IDH_PA_OPS_REQUEST,
    IDC_SITE_IDENTITY,          IDH_PA_OPS_REQUEST,
    IDC_OPS_LIST,               IDH_PA_OPS_LIST,
    IDC_USAGE_STRING,           IDH_PA_USAGE_STRING,
    IDC_VIEW_CERT,              IDH_PA_VIEW_CERT,
    IDC_EDIT_PROFILE,           IDH_EDIT_PROFILE_BTN,
    IDC_OPS_PRIVACY,            IDH_PA_CONNECTION_SECURITY,
    IDC_SECURITY_ICON,          IDH_PA_CONNECTION_SECURITY,
    IDC_SECURE_CONNECTION,      IDH_PA_CONNECTION_SECURITY,
    IDC_UNSECURE_CONNECTION,    IDH_PA_CONNECTION_SECURITY,
    IDC_KEEP_SETTINGS,          IDH_PA_ALWAYS_SHARE,
    0,                          0
};

WCHAR* _GetNameFromAttrIndex ( int index ) 
{
    // Assert that the index is valid.
    ASSERT(index>=0 && index<ARRAYSIZE(rgProfAttr));
    return rgProfAttr[index].pwzName;
}

INT _GetResourceIdFromAttrIndex( int index )
{
    // Assert that the index is valid.
    ASSERT(index>=0 && index<ARRAYSIZE(rgProfAttr));
    return rgProfAttr[index].id;
}

ULONG _GetPropTagFromAttrIndex( int index )
{
    // Assert that the index is valid.
    ASSERT(index>=0 && index<ARRAYSIZE(rgProfAttr));
    return rgProfAttr[index].ulPropTag;
}

//================================================
//   Implementation of the OPSRequestEntry object
//------------------------------------------------

int CIEFrameAuto::COpsProfile::OPSRequestEntry::destWrapper(void *pEntry, void *pUnused) 
{
    OPSRequestEntry *pReqEntry = (OPSRequestEntry*) pEntry;

    if ( pReqEntry )
    {
        delete pReqEntry;
        pReqEntry = NULL;
    }

    return TRUE; 
}

int CIEFrameAuto::COpsProfile::OPSRequestEntry::grantRequest(void *pEntry, void *pUnused)
{
    OPSRequestEntry *pReqEntry = (OPSRequestEntry*) pEntry;
    pReqEntry->grantRequest();
    return TRUE;
}

void CIEFrameAuto::COpsProfile::OPSRequestEntry::grantRequest() 
{
    m_fQuery    = FALSE;
    m_fAnswer   = TRUE; 
}

void CIEFrameAuto::COpsProfile::OPSRequestEntry::denyRequest() 
{   
    m_fQuery    = FALSE;
    m_fAnswer   = FALSE;
}

void CIEFrameAuto::COpsProfile::OPSRequestEntry::clearValue()
{   
    SysFreeString(m_bstrValue);
    m_bstrValue = NULL;
}

CIEFrameAuto::COpsProfile::OPSRequestEntry::OPSRequestEntry()
{
    m_fQuery        = TRUE;
    m_fAnswer       = FALSE;
    m_bstrValue     = NULL;
    m_bstrName      = NULL;
    m_bstrOldVal    = NULL;
}
   
CIEFrameAuto::COpsProfile::OPSRequestEntry::~OPSRequestEntry()
{
    SysFreeString(m_bstrName);
    SysFreeString(m_bstrValue);
    SysFreeString(m_bstrOldVal);
}

//================================================
//   Implementation of the COpsProfile object
//------------------------------------------------

CIEFrameAuto::COpsProfile::COpsProfile()
:    CAutomationStub( MIN_BROWSER_DISPID, MAX_BROWSER_DISPID, TRUE ) 
{    
#ifdef NEVER
    m_pCert = NULL;
#endif  // NEVER

#ifdef _USE_PSTORE_   
    m_provID = GUID_NULL;
    m_pStore    = NULL;
    m_iStoreRef = 0;
#else
    m_bWABInit = FALSE;
    m_hInstWAB = NULL;
    m_lpAdrBook = NULL;
    m_lpWABObject = NULL;
    m_hrWAB = E_UNEXPECTED;
    m_SBMe.cb = 0;
    m_SBMe.lpb = NULL;
#endif  // _USE_PSTORE_

    m_fEnabled = FALSE;
        
    m_bstrLastURL = NULL;

    m_hdpaRequests = DPA_Create(0);
    m_hdpaChanges = DPA_Create(0);

    m_hP3Global     = NULL;
    m_hP3Sites      = NULL;
				
    //Begin a-thkesa	Initialize . See Windows BUG:589837.
    VariantInit(&m_vUsage);// a-thkesa. 
    m_vUsage.vt = VT_I4;
    m_vUsage.lVal = 8;
    //End a-thkesa
}


CIEFrameAuto::COpsProfile::~COpsProfile() 
{
    clearRequest();

#ifdef NEVER
    if (m_pCert)
        m_pCert->Release();
#endif  // NEVER

    for (unsigned i=m_iStoreRef; i>0; i--)
        _ReleaseStore();

#ifdef _USE_PSTORE_
    if (m_pStore)
        ATOMICRELEASE(m_pStore);
#else
    if (m_SBMe.lpb)
        m_lpWABObject->FreeBuffer(m_SBMe.lpb);

    if (m_lpAdrBook)
        ATOMICRELEASE(m_lpAdrBook);

    if (m_lpWABObject)
        ATOMICRELEASE(m_lpWABObject);

    if (m_hInstWAB)
        FreeLibrary(m_hInstWAB);
#endif  // _USE_PSTORE_

    // Prevent delay-loading of OLEAUT32.DLL if not necessary
    if (m_bstrLastURL)
        SysFreeString(m_bstrLastURL);

    RegCloseKey(m_hP3Global);
    RegCloseKey(m_hP3Sites);

    DPA_DestroyCallback(m_hdpaRequests, OPSRequestEntry::destWrapper, NULL);
    m_hdpaRequests = NULL;

    DPA_DestroyCallback(m_hdpaChanges, OPSRequestEntry::destWrapper, NULL);
    m_hdpaChanges = NULL;
	
}

HRESULT     CIEFrameAuto::COpsProfile::_CreateStore()
{
#ifdef _USE_PSTORE_
    if (m_iStoreRef == 0) 
    {
        HRESULT hr = PStoreCreateInstance(  &m_pStore,  
                                            IsEqualGUID(m_provID, GUID_NULL) ? NULL : &m_provID,
                                            NULL,
                                            0);
        if (SUCCEEDED(hr))
            m_iStoreRef++;

        return hr;
    }
    m_iStoreRef++;

    return S_OK;
#else
    if (!m_bWABInit) 
    {

        ASSERT(NULL == m_hInstWAB);
        ASSERT(NULL == m_lpAdrBook && NULL == m_lpWABObject);

        // Don't try initializing the wab again and again 
        m_bWABInit = TRUE;
        
        {
            // Figure out the location of the wab dll and try opening it.
            TCHAR szWABDllPath[MAX_PATH];
            DWORD dwType = 0;
            ULONG cbData = sizeof(szWABDllPath);
            HKEY hKey = NULL;

            *szWABDllPath = '\0';
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
                RegQueryValueEx( hKey, TEXT(""), NULL, &dwType, (LPBYTE) szWABDllPath, &cbData);

            if(hKey) RegCloseKey(hKey);

            if (lstrlen(szWABDllPath) != 0 )
                m_hInstWAB = LoadLibrary(szWABDllPath);
            else
                m_hInstWAB = NULL;
        }

        HRESULT hr;
        if (m_hInstWAB)
        {
            LPWABOPEN lpfnWABOpen = (LPWABOPEN) GetProcAddress(m_hInstWAB, "WABOpen");
            
            if (lpfnWABOpen)
            {
                hr = lpfnWABOpen(&m_lpAdrBook, &m_lpWABObject, NULL, 0);

                if (NULL == m_lpAdrBook || NULL == m_lpWABObject)
                    hr = E_UNEXPECTED;
            }
            else 
            {
                hr = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);  // Not the right dll anyway!!
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);
        }

        // Good so far, call GetMe.
        if (!hr)
        {
            m_SBMe.cb = 0;
            m_SBMe.lpb = NULL;
            hr = m_lpWABObject->GetMe(m_lpAdrBook, WABOBJECT_ME_NOCREATE | AB_NO_DIALOG, NULL, &m_SBMe, 0);

            if (0 == m_SBMe.cb || NULL == m_SBMe.lpb)
                hr = E_UNEXPECTED;
        }     

        // Remember the return code for later.
        m_hrWAB = hr;
    }
        
    if (!m_hrWAB)
        m_iStoreRef++;

    return m_hrWAB;
#endif
}

HRESULT     CIEFrameAuto::COpsProfile::_ReleaseStore()
{
    if (m_iStoreRef > 0) 
        m_iStoreRef--;

    return S_OK;
}

HRESULT     CIEFrameAuto::COpsProfile::Init() 
{
    DWORD   dwError;
    DWORD   dwAction;

    dwError = RegCreateKeyEx(HKEY_CURRENT_USER, 
                            rgszP3Global, 
                            0, 
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_SET_VALUE,
                            NULL, 
                            &m_hP3Global, 
                            &dwAction);

    dwError = RegCreateKeyEx(HKEY_CURRENT_USER,
                            rgszP3Sites,
                            0, 
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ | KEY_CREATE_SUB_KEY,
                            NULL,
                            &m_hP3Sites,
                            &dwAction);

    m_fEnabled = _IsP3Enabled();

 
    CIEFrameAuto* pauto = IToClass(CIEFrameAuto, _profile, this);
    return CAutomationStub::Init( SAFECAST(this, IHTMLOpsProfile*), IID_IHTMLOpsProfile,
                        CLSID_COpsProfile, pauto );
}

HRESULT     CIEFrameAuto::COpsProfile::addReadRequest(BSTR bstrName, VARIANT reserved, VARIANT_BOOL *pfSuccess)
{
    if ( pfSuccess )
        *pfSuccess = VARIANT_FALSE;

    if (!m_fEnabled)
        return S_FALSE;

    if (bstrName==NULL)
        return E_POINTER;

    BSTR    bstrURL = NULL;
    HRESULT hr = _pAuto->get_LocationURL(&bstrURL);

    if (_DifferentURL())
        clearRequest();

    SysFreeString(m_bstrLastURL);
    m_bstrLastURL = SysAllocString(bstrURL);
    if (NULL == m_bstrLastURL)
    {
        return E_OUTOFMEMORY;
    }

    int index = _GetAttrIndexFromName(bstrName);
    if (index==INVALID_ATTRIBUTE_INDEX)
        return S_FALSE;

    // If the attribute already exists on the list, return from this function
    for (int i=0; i<DPA_GetPtrCount(m_hdpaRequests); i++)
    {
        OPSRequestEntry *pEntry = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaRequests, i);

        if (StrCmpIW(pEntry->m_bstrName,bstrName)==0)
            return S_OK;
    }

    OPSRequestEntry *pNewEntry = new OPSRequestEntry;

    if (pNewEntry==NULL)
        return E_OUTOFMEMORY;

    pNewEntry->m_bstrName = SysAllocString(_GetNameFromAttrIndex(index));
    if (pNewEntry->m_bstrName==NULL) 
    {
        delete pNewEntry;
        return E_OUTOFMEMORY;
    }

    pNewEntry->m_bstrValue  = NULL;

    int eIns = DPA_AppendPtr(m_hdpaRequests, (void*) pNewEntry);
    if (eIns==-1) 
    {
        delete pNewEntry;
        return E_OUTOFMEMORY;
    }

    if ( pfSuccess )
        *pfSuccess = VARIANT_TRUE;
    return S_OK;
}

HRESULT     CIEFrameAuto::COpsProfile::clearRequest() 
{
    m_fEnabled = _IsP3Enabled();

    if (!m_fEnabled)
        return S_FALSE;
   
    DPA_EnumCallback(m_hdpaRequests, OPSRequestEntry::destWrapper, NULL);
    DPA_DeleteAllPtrs(m_hdpaRequests);
    return S_OK;
}

HRESULT     CIEFrameAuto::COpsProfile::doRequest(VARIANT usage, VARIANT fname, 
                                                 VARIANT vaDomain, VARIANT vaPath, VARIANT vaExpire,
                                                 VARIANT reserved)
{
    m_fEnabled = _IsP3Enabled();

    if (!m_fEnabled)
        return S_FALSE;

    int     i, k;
    HRESULT hr;

    BOOL    fShowUI = FALSE;
    BOOL    fPersistent = FALSE;

    BSTR    bstrURL;
    TCHAR   rgchURL[MAX_URL_STRING];
    TCHAR   rgchDomain[INTERNET_MAX_HOST_NAME_LENGTH+1];
    TCHAR   rgchPath[MAX_PATH+1];
    TCHAR   rgchScheme[16];

    AccessSettings      acSettings;

    HDPA    hdpaConfirm = DPA_Create(0);

    if (_DifferentURL())
    {
        clearRequest();
        return S_FALSE;
    }

    hr = _pAuto->get_LocationURL(&bstrURL);
    if (FAILED(hr))
        return S_FALSE;

    _StringFromBSTR(bstrURL, rgchURL, ARRAYSIZE(rgchURL));

    URL_COMPONENTS uc = {0};
    uc.dwStructSize = sizeof(URL_COMPONENTS);
    uc.lpszHostName = rgchDomain;
    uc.dwHostNameLength = ARRAYSIZE(rgchDomain);
    uc.lpszUrlPath = rgchPath;
    uc.dwUrlPathLength = ARRAYSIZE(rgchPath);
    uc.lpszScheme = rgchScheme;
    uc.dwSchemeLength = ARRAYSIZE(rgchScheme);

    InternetCrackUrl(rgchURL, lstrlen(rgchURL), ICU_DECODE, &uc);
    
    _GetSiteSettings(&uc, vaDomain, vaPath, vaExpire, &acSettings);

    hr = _CreateStore();
    if (FAILED(hr))
        return S_FALSE;

    if (DPA_GetPtrCount(m_hdpaRequests)==0)
        return S_OK;

    for (k=0; k<DPA_GetPtrCount(m_hdpaRequests); k++)
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaRequests,k);
        pCurrent->clearValue();
    }

    HWND hwnd = _pAuto->_GetHWND();
    INT_PTR nRet = -1;

    // #59340 - don't need special priviliges for local machine zone anymore.
    if (FALSE && _IsLocalMachine())
    {
        // If page is on the local machine, all requested information will be given
        DPA_EnumCallback(m_hdpaRequests, OPSRequestEntry::grantRequest, NULL);
        nRet = TRUE;
    }
    else
    {
        // Process the request list and mark attributes according to the configuration
        _ApplyPreferences(&uc, m_hdpaRequests);

        // Go through the request list and for each attribute that was not marked as
        // grant/deny according to the preferences, add it to the list
        for (k=0; k<DPA_GetPtrCount(m_hdpaRequests); k++)
        {
            OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaRequests,k);
            
            if (pCurrent->m_fQuery)
                DPA_AppendPtr(hdpaConfirm, pCurrent);
        }

        // Determine whether there are any attributes to query
        fShowUI = DPA_GetPtrCount(hdpaConfirm)>0;

        if (!fShowUI)
        {
            nRet = TRUE;
            goto HandleRequest;
        }

        // If a UI is going to be shown, all attributes that were going to be
        // given or denied silently should also be shown
        for (k=0; k<DPA_GetPtrCount(m_hdpaRequests); k++)
        {
            OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaRequests,k);
            if (!pCurrent->m_fQuery && 
                (pCurrent->m_fAnswer || (!pCurrent->m_fAnswer && pCurrent->m_dwDecision==P3_SITELEVEL)))
            {
                DPA_AppendPtr(hdpaConfirm, pCurrent);
                pCurrent->m_fQuery = TRUE;
            }
        }
		
		
        OPSDlgInfo opsDlgInfo;

        opsDlgInfo.m_hdpa = hdpaConfirm;
        StrCpyN(opsDlgInfo.m_rgchURL, rgchURL, ARRAYSIZE(opsDlgInfo.m_rgchURL));
        opsDlgInfo.m_pOpsProfile = this;
        opsDlgInfo.m_pacSettings = &acSettings;

        opsDlgInfo.m_fRemember = (_GetCookieSettings()==COOKIES_ALLOW);

        if (fname.vt == VT_BSTR && fname.bstrVal && lstrlenW(fname.bstrVal)>0)
            opsDlgInfo.m_bstrFName = SysAllocString(fname.bstrVal);
        else
            opsDlgInfo.m_bstrFName = NULL;
			
        _GetUsageCode(usage, opsDlgInfo.m_rgchUsage, ARRAYSIZE(opsDlgInfo.m_rgchUsage));
        //Beign a-thkesa  to solve Windows BUG:589837. Assigne the usage member for the next use.
        {
          m_vUsage.vt = usage.vt;
          m_vUsage.lVal = usage.lVal;
        }
        // End.
		
          nRet = DialogBoxParam(MLGetHinst(),
                                MAKEINTRESOURCE(IDD_OPS_CONSENT),
                                hwnd,
                                _OPSConsent_DlgProc,
                                (LPARAM) &opsDlgInfo);

          fPersistent = opsDlgInfo.m_fRemember;
    }

HandleRequest:

    if (nRet==-1)
        return E_FAIL;
    
    if (!nRet)
    {
        fPersistent = FALSE;
        goto Cleanup;
    }

    for (i=0; i<DPA_GetPtrCount(m_hdpaRequests); i++) 
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaRequests,i);
 
        if (pCurrent->m_fQuery)
        {
            pCurrent->m_prefs.m_lastRequest = pCurrent->m_fAnswer ? P3_ACCEPT : P3_REJECT;
            _PutUserPreference(pCurrent->m_bstrName, pCurrent->m_prefs);
        }

        if (pCurrent->m_fAnswer)
        {
            hr = _GetFieldValue(pCurrent->m_bstrName, & (pCurrent->m_bstrValue));
            if (FAILED(hr))
                pCurrent->clearValue();
        }
    }

    if (fShowUI && fPersistent &&
        (uc.nScheme==INTERNET_SCHEME_HTTP || uc.nScheme==INTERNET_SCHEME_HTTPS))
    {
        _UpdateSiteSettings(&acSettings, m_hdpaRequests);
    }

Cleanup:
    DPA_Destroy(hdpaConfirm);
    hdpaConfirm = NULL;
    _ReleaseStore();
    return S_OK;
}

HRESULT     CIEFrameAuto::COpsProfile::getAttribute(BSTR bstrAttribName, BSTR *pbstrAttribValue) 
{
    if (!m_fEnabled)
        return S_FALSE;
    
    if (pbstrAttribValue==NULL || bstrAttribName==NULL)
        return E_POINTER;

    *pbstrAttribValue = NULL;
    
    
    //
    // SECURITY: Since shdocvw has no notion of frames, 
    // we now prompt on every attempt to get attributes.
    // See Windows bugs 536637 & 549409 for details.
    //

    VARIANT_BOOL vbSuccess;
    VARIANT vError, vUsage, vName;
    VariantInit(&vError);
    VariantInit(&vUsage);
    VariantInit(&vName);
    vError.vt = VT_ERROR;
    vError.scode = DISP_E_PARAMNOTFOUND;
    
    //a-thkesa to solve Windows BUG:589837. Assign the usage member for the this use.
    //Begin comment a-thkesa   
    //vUsage.vt = VT_I4;
    //vUsage.lVal = 8;
    //End
    vUsage = m_vUsage ;// a-thkesa to solve Windows BUG:589837
    vName.vt = VT_EMPTY;
    clearRequest();
    addReadRequest(bstrAttribName, vError, &vbSuccess);
    if (vbSuccess == VARIANT_FALSE)
        return E_FAIL;
    doReadRequest(vUsage, vName, vError, vError, vError, vError);

    for (int i=0; i<DPA_GetPtrCount(m_hdpaRequests); i++) 
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaRequests,i);

        if (StrCmpIW(bstrAttribName,pCurrent->m_bstrName) == 0) 
        {
            if (pCurrent->m_bstrValue == NULL)
            {
                *pbstrAttribValue = SysAllocString(L"");
            }
            else
            {
                *pbstrAttribValue = SysAllocString(pCurrent->m_bstrValue);
            }
            return (*pbstrAttribValue == NULL) ? E_OUTOFMEMORY : S_OK;
        }
    }

    return S_FALSE;
}

HRESULT     CIEFrameAuto::COpsProfile::setAttribute(BSTR bstrAttribName, BSTR bstrAttribValue, VARIANT vaPrefs,
                                                    VARIANT_BOOL *pfSuccess)
{
    BSTR bstrStdName = NULL;
    HRESULT hr = S_FALSE;

    if (pfSuccess)
        *pfSuccess = VARIANT_FALSE;

    if (!m_fEnabled)
        return S_FALSE;

    if (bstrAttribName==NULL)
        return E_POINTER;

    // If this is a new URL, flush the change queue.
    if (_DifferentURL())
    {
        DPA_EnumCallback(m_hdpaChanges,OPSRequestEntry::destWrapper,NULL);
        DPA_DeleteAllPtrs(m_hdpaChanges);
    }

    // Load the name of the current URL into the last visited URL
    SysFreeString(m_bstrLastURL);
    _pAuto->get_LocationURL(&m_bstrLastURL);

    int index = _GetAttrIndexFromName(bstrAttribName);
    if (index==INVALID_ATTRIBUTE_INDEX)
        return S_FALSE;

    OPSRequestEntry *pNewEntry = new OPSRequestEntry;
    if (pNewEntry == NULL)
        return E_OUTOFMEMORY;
    
    pNewEntry->m_bstrName = SysAllocString(_GetNameFromAttrIndex(index));
    if (pNewEntry->m_bstrName==NULL)
    {
        delete pNewEntry;
        return E_OUTOFMEMORY;
    }

    if (bstrAttribValue != NULL)
        pNewEntry->m_bstrValue = SysAllocString(bstrAttribValue);
    else
        pNewEntry->m_bstrValue = SysAllocString(L"");

    if (pNewEntry->m_bstrValue==NULL)
    {
        delete pNewEntry;
        return E_OUTOFMEMORY;
    }

    for (int i=0; i<DPA_GetPtrCount(m_hdpaChanges); i++) 
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaChanges,i);

        if (StrCmpIW(pCurrent->m_bstrName, bstrAttribName) == 0)
        {
            SysFreeString(pCurrent->m_bstrValue);
            pCurrent->m_bstrValue = SysAllocString(bstrAttribValue);

            if (*pfSuccess)
                *pfSuccess = (pCurrent->m_bstrValue!=NULL) ? VARIANT_TRUE : VARIANT_FALSE;

            delete pNewEntry;

            return S_OK;
        }
    }

    int eIns = DPA_AppendPtr(m_hdpaChanges, pNewEntry);
    if (eIns==-1) 
    {
        delete pNewEntry;
        return E_OUTOFMEMORY;
    }

    if (pfSuccess)
        *pfSuccess = VARIANT_TRUE;

    return S_OK;
}

HRESULT CIEFrameAuto::COpsProfile::commitChanges(VARIANT_BOOL *pfSuccess) 
{
    if (pfSuccess)
        *pfSuccess = VARIANT_FALSE;

    if (!m_fEnabled)
        return S_FALSE;

    HRESULT hr;
    HWND hwnd;
    int i;
    INT_PTR nRet;
    OPSDlgInfo opsDlgInfo;

    BSTR    bstrURL = NULL;
    TCHAR   rgchURL[MAX_URL_STRING];

    _pAuto->get_LocationURL(&bstrURL);
    _StringFromBSTR(bstrURL, rgchURL, ARRAYSIZE(rgchURL));
    SysFreeString(bstrURL);

    // Crack the URL and get the hostname
    TCHAR   rgchHostName[INTERNET_MAX_HOST_NAME_LENGTH] = { TEXT('\0') };
    DWORD   dwcbHostLen = ARRAYSIZE(rgchHostName);
    UrlGetPart(rgchURL, rgchHostName,  &dwcbHostLen, URL_PART_HOSTNAME, 0);

    // Read the hostname for the registration page from the registry 
    TCHAR   rgchRegDomain[INTERNET_MAX_HOST_NAME_LENGTH];
    DWORD   dwcbReg = sizeof(rgchRegDomain);

    HKEY    hWriteKey = NULL;
    DWORD   dwError;

    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, rgszRegKey, 0, KEY_READ, &hWriteKey);

    if (dwError==ERROR_SUCCESS)
    {
        dwError = RegQueryValueEx(hWriteKey, rgszRegTxt, NULL, NULL, (LPBYTE) rgchRegDomain, &dwcbReg);
        RegCloseKey(hWriteKey);
    }

    BOOL  fRegDomain = (dwError==ERROR_SUCCESS && _DomainMatch(rgchHostName, rgchRegDomain));
    BOOL  fCanWrite = _IsLocalMachine() || fRegDomain;

    if (!fCanWrite || _DifferentURL())
        goto Cleanup;

    hr = _CreateStore();
    if (hr)
        goto Cleanup;

    // Look up the old values from the store
    for (i=0; i<DPA_GetPtrCount(m_hdpaChanges); i++)
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaChanges, i);

        // Default case: the attribute will be updated
        pCurrent->m_fAnswer = TRUE;

        hr = _GetFieldValue (pCurrent->m_bstrName, &(pCurrent->m_bstrOldVal));
        if (hr)
        {
            SysFreeString(pCurrent->m_bstrOldVal);
            pCurrent->m_bstrOldVal = NULL;
        }
    }

    // Delete nodes in the list if the new value is the same as the old one
    // NOTE: The loop counter will remain stationary or increment depending on whether
    // the current node in the list is deleted
    for (i=0; i<DPA_GetPtrCount(m_hdpaChanges); )
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaChanges, i);

        if (StrCmpW(pCurrent->m_bstrValue, pCurrent->m_bstrOldVal)==0)
            DPA_DeletePtr(m_hdpaChanges, i);
        else
            i++;
    }

    // If nothing has changed, then we do not need to write data back to the storage
    if (DPA_GetPtrCount(m_hdpaChanges)==0)     
        goto Cleanup;  

    // The registration domain can write profile information silently.
    // For all other cases, a UI will be displayed.
    if (!fRegDomain)
    {

        // Pop up a UI to show the items that are being changes and allow the user to 
        // confirm the changes by selecting check-boxes for each attribute
        opsDlgInfo.m_hdpa = m_hdpaChanges;
        opsDlgInfo.m_pOpsProfile = this;

        hwnd = _pAuto->_GetHWND();
        nRet = DialogBoxParam(MLGetHinst(),
                                MAKEINTRESOURCE(IDD_OPS_UPDATE),
                                hwnd,
                                _OPSUpdate_DlgProc,
                                (LPARAM) &opsDlgInfo
                            );

        // Unrecoverable error: failed to show the dialog box
        if (nRet==-1)
            return S_FALSE;

        // If the user clicked "CANCEL", then no changes will be performed
        if (nRet==0)
            goto Cleanup;
    }

    if ( pfSuccess )
        *pfSuccess = VARIANT_TRUE;

    for (i=0; i<DPA_GetPtrCount(m_hdpaChanges); i++)
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(m_hdpaChanges, i);

        // Registration page should not overwrite existing entries
        if (fRegDomain && ! EMPTY_STRINGW(pCurrent->m_bstrOldVal))
            continue;

        // Update only if the user allowed in the UI
        // For the registration page, this condition will hold for all attributes
        if (pCurrent->m_fAnswer)
        {
            hr = _SetFieldValue(pCurrent->m_bstrName, pCurrent->m_bstrValue);
            if (hr && pfSuccess)
                *pfSuccess = VARIANT_FALSE;
        }
     }

Cleanup:

    // Clear the queue that holds the changes 
    DPA_EnumCallback(m_hdpaChanges,OPSRequestEntry::destWrapper,NULL);
    DPA_DeleteAllPtrs(m_hdpaChanges);

    return S_OK;
}

// *** IOpsProfileSimple members ***
STDMETHODIMP CIEFrameAuto::COpsProfile::ReadProperties(long lNumProperties, const LPCWSTR szProperties[], LPWSTR szReturnValues[])
{
    HRESULT hr=S_OK;

    for (int i=0; i<lNumProperties; i++)
    {
        BSTR bstrValue=NULL;
        LPWSTR pwszRet=NULL;

        if (szProperties[i])
        {
            _GetFieldValue(szProperties[i], &bstrValue);

            if (bstrValue)
            {
                // FEATURE change _GetFieldValue so we don't reallocate twice unnecessarily
                int cch = (1 + lstrlenW(bstrValue));

                pwszRet = (LPWSTR) CoTaskMemAlloc(sizeof(WCHAR) * cch);

                if (pwszRet)
                    StrCpyNW(pwszRet, bstrValue, cch);

                SysFreeString(bstrValue);
            }
            else
            {
                hr = S_FALSE;
            }
        }

        szReturnValues[i] = pwszRet;
    }

    return hr;
}

STDMETHODIMP CIEFrameAuto::COpsProfile::WriteProperties(long lNumProperties, const LPCWSTR szProperties[], const LPCWSTR szValues[])
{
    return E_NOTIMPL;
}


#ifdef _USE_PSTORE_

HRESULT     CIEFrameAuto::COpsProfile::_GetFieldValue(const OLECHAR *pszField, BSTR * pbstrValue) 
{

    GUID            itemType = GUID_NULL;
    GUID            itemSubtype = GUID_NULL;
    BSTR            bstrName = NULL;
    DWORD           cbData;
    BYTE *          pbData = NULL;

    HRESULT         hr;
    BOOL            fOpen = FALSE;

    if (pszField==NULL || pbstrValue==NULL)
        return E_POINTER;

    PST_PROMPTINFO  promptInfo = {0};
    promptInfo.cbSize = sizeof(promptInfo);
    promptInfo.szPrompt = pszField;
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp = _pAuto->_GetHWND();

    hr = _CreateStore();
    if (hr)
        goto Cleanup;

    hr = _GetPStoreTypes(pszField, &itemType, &itemSubtype, &bstrName);
    if (hr)
        goto Cleanup;

    hr =    m_pStore->ReadItem(
                        s_Key,
                        &itemType,
                        &itemSubtype,
                        bstrName,
                        &cbData,
                        &pbData,
                        &promptInfo,
                        0);
    if (FAILED(hr))
    {
        *pbstrValue = SysAllocString(L"");
        hr = S_OK;
        goto Cleanup;
    }

    *pbstrValue = SysAllocString((OLECHAR *) pbData);

Cleanup:
    _ReleaseStore();
    CoTaskMemFree(pbData);
    SysFreeString(bstrName);
    return hr;
}

HRESULT     CIEFrameAuto::COpsProfile::_SetFieldValue(const OLECHAR *pszField, BSTR bstrValue) 
{
    
    HRESULT         hr;
    PST_TYPEINFO    typeInfo;
    PST_PROMPTINFO  promptInfo;
    WCHAR *         szValue = bstrValue ? bstrValue : L"";
    TCHAR           szDisplayName[MAX_PATH];
    WCHAR           wzDisplayName[MAX_PATH];

    if (pszField==NULL)
        return E_POINTER;

    MLLoadString(IDS_PROFILE_ASSISTANT, szDisplayName, ARRAYSIZE(szDisplayName));

    typeInfo.cbSize = sizeof(typeInfo);
    int cch = MultiByteToWideChar(CP_ACP, 0, szDisplayName, -1, 
                                    wzDisplayName, ARRAYSIZE(wzDisplayName));
    ASSERT(cch != 0); 
    typeInfo.szDisplayName = wzDisplayName;

    promptInfo.cbSize = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp = _pAuto->_GetHWND();  
    promptInfo.szPrompt = pszField;

    hr = _CreateStore();
    if (hr)
        goto Cleanup;

    hr = m_pStore->CreateType(s_Key, &GUID_PStoreType, &typeInfo, 0);
    if (hr && (hr != PST_E_TYPE_EXISTS))
        goto Cleanup;

    hr = m_pStore->CreateSubtype(
                            s_Key,
                            &GUID_PStoreType,
                            &GUID_NULL,
                            &typeInfo,
                            NULL,
                            0);
    if (hr && (hr != PST_E_TYPE_EXISTS))
        goto Cleanup;

    hr = m_pStore->WriteItem(
                        s_Key,
                        &GUID_PStoreType,
                        &GUID_NULL,
                        pszField,
                        (lstrlenW(szValue) + 1) * sizeof(WCHAR),
                        (BYTE *) szValue,
                        &promptInfo,
                        PST_CF_NONE,
                        0);

Cleanup:
    _ReleaseStore();
    return hr;
}

#else       // _USE_PSTORE_

HRESULT     CIEFrameAuto::COpsProfile::_GetFieldValue(const OLECHAR *pszField, BSTR * pbstrValue) 
{

    LPMAILUSER lpMailUser = NULL;
    ULONG ulPropTag; 
    ULONG ulObjType = 0;
    WCHAR * pwzValue = NULL;
    BOOL bStoreCreated = FALSE;
    HRESULT hr;

    if (pszField==NULL || pbstrValue==NULL)
        return E_POINTER;
     
    hr = _CreateStore();
    if (hr)
        goto Cleanup;
    else
        bStoreCreated = TRUE;

    INT index;
    index = INVALID_ATTRIBUTE_INDEX;
    if (!_ValidateElemName(pszField, &index))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    // Open the entry in the address book. 

    hr = m_lpAdrBook->OpenEntry(m_SBMe.cb, 
                                (LPENTRYID) m_SBMe.lpb,
                                NULL,
                                0,
                                &ulObjType,
                                (LPUNKNOWN *)&lpMailUser);

    if (hr)
        goto Cleanup;

    if (lpMailUser)
    {
        ulPropTag = _GetPropTagFromAttrIndex(index);
        SPropTagArray SPTA;
        SPTA.cValues = 1;
        SPTA.aulPropTag[0] = ulPropTag;

        if (PROP_TYPE(ulPropTag) ==  PT_TSTRING || ulPropTag == PR_GENDER)
        {
            DWORD cValues = 0;
            LPSPropValue lpSPropValue = NULL;

            hr = lpMailUser->GetProps(&SPTA, 0, &cValues, &lpSPropValue);
            if (!hr)
            {
                ASSERT(1 == cValues);
                ASSERT(NULL != lpSPropValue);

                int cch = 0;
                LPCTSTR pszPropStr = NULL; 
                
                if (ulPropTag == PR_GENDER)
                {
                    switch (lpSPropValue->Value.i) 
                    {
                        case 1:
                            pszPropStr = GENDER_FEMALE;
                            break;
                        case 2:
                            pszPropStr = GENDER_MALE;
                            break;
                        default:
                            pszPropStr = GENDER_UNSPECIFIED;
                            break;
                    }
                }
                else
                {
                    ASSERT(PROP_TYPE(lpSPropValue->ulPropTag) == PT_TSTRING);
                    pszPropStr = lpSPropValue->Value.LPSZ;
                }

                if (pszPropStr)
                {
                    cch = lstrlen(pszPropStr) + 1;
                    pwzValue = new WCHAR [cch];
                    if (NULL == pwzValue)
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        StrCpyN(pwzValue, pszPropStr, cch);
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);    // This will cause us to just return the NULL string.                                                                                                                                                                                                                                    
                }
            }

            m_lpWABObject->FreeBuffer(lpSPropValue);
        }
        else 
        {
            // If this assert fires you are probably adding a new PR_* mapping to the OPS code.
            // You will need to write code to convert the returned value to a string meaningfully.
            // See the example for GENDER above.
            ASSERT(FALSE);  
            hr = E_NOTIMPL ; 
        }
    }
    else 
    {
        hr = E_UNEXPECTED;
    }                

    if (hr)
    {
        *pbstrValue = SysAllocString(L"");
        hr = (NULL != pbstrValue) ? S_OK : E_OUTOFMEMORY;
        goto Cleanup;
    }

    *pbstrValue = SysAllocString((OLECHAR *) pwzValue);

Cleanup:

    if (bStoreCreated)
        _ReleaseStore();

    if (lpMailUser)
        lpMailUser->Release();

    delete [] pwzValue;

    return hr;
}

HRESULT     CIEFrameAuto::COpsProfile::_SetFieldValue(const OLECHAR *pszField, BSTR bstrValue) 
{
    HRESULT         hr;
    LPMAILUSER lpMailUser = NULL;
    ULONG ulPropTag; 
    ULONG ulObjType = 0;
    BOOL bStoreCreated = FALSE;

    if (pszField==NULL)
        return E_POINTER;

     
    hr = _CreateStore();
    if (hr)
        goto Cleanup;
    else
        bStoreCreated = TRUE;

    INT index;
    index = INVALID_ATTRIBUTE_INDEX;
    if (!_ValidateElemName(pszField, &index))
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Open the entry in the address book. 
    hr = m_lpAdrBook->OpenEntry(m_SBMe.cb, 
                                (LPENTRYID) m_SBMe.lpb,
                                NULL,
                                MAPI_MODIFY,
                                &ulObjType,
                                (LPUNKNOWN *)&lpMailUser);

    if (hr)
        goto Cleanup;

    if (lpMailUser)
    {
        ulPropTag = _GetPropTagFromAttrIndex(index);

        if (PROP_TYPE(ulPropTag) ==  PT_TSTRING || ulPropTag == PR_GENDER)
        {
            // First remove the existing entry
            SPropTagArray SPTA;
            SPTA.cValues = 1;
            SPTA.aulPropTag[0] = ulPropTag;

            lpMailUser->DeleteProps(&SPTA, NULL);

            SPropValue prop;
            prop.ulPropTag = ulPropTag;
            CHAR *pszValue = NULL;

            if (ulPropTag == PR_GENDER)
            {
                short int i = 0;    // unspecified.
                if (0 == StrCmpIW(bstrValue, GENDER_FEMALE_W))
                    i = 1;
                else if (0 == StrCmpIW(bstrValue, GENDER_MALE_W))
                    i = 2;

                prop.Value.i = i;
            }
            else 
            {
                prop.Value.LPSZ = bstrValue;   
            }

            if (!hr)
            {
                hr = lpMailUser->SetProps(1, &prop, NULL);
                lpMailUser->SaveChanges(0);
            }
            
            delete [] pszValue;
        }                                                           
        else 
        {
            hr = E_NOTIMPL ; // FIX THIS BEFORE CHECKING IN. 
        }
    }
    else 
    {
        hr = E_UNEXPECTED;
    }                


Cleanup:

    if (bStoreCreated)
        _ReleaseStore();

    if (lpMailUser)
        lpMailUser->Release();

    return hr;
}

#endif      // ! _USE_PSTORE_

HRESULT     CIEFrameAuto::COpsProfile::_GetIDispatchExDelegate(IDispatchEx ** const delegate) 
{
    if( !delegate )
        return E_POINTER;

    *delegate = NULL;    // We do not handle expandos yet
    return DISP_E_MEMBERNOTFOUND;
}

HRESULT     CIEFrameAuto::COpsProfile::_InternalQueryInterface(REFIID riid, void ** const ppvObjOut)
{
    ASSERT( this );
    ASSERT( !IsEqualIID(riid, IID_IUnknown) );

    if (IsEqualIID(riid, IID_IHTMLOpsProfile))
    {
        *ppvObjOut = SAFECAST(this,IHTMLOpsProfile*);
    }
    else if (IsEqualIID(riid, IID_IOpsProfileSimple))
    {
        *ppvObjOut = SAFECAST(this,IOpsProfileSimple*);
    }
    else
    {
        *ppvObjOut = NULL;
        return E_NOINTERFACE;
    }

    AddRef( );
    return S_OK;
}

#ifdef _USE_PSTORE_

HRESULT
CIEFrameAuto::COpsProfile::_GetPStoreTypes(
        BSTR bstrField,
        GUID * pguidType,
        GUID * pguidSub,
        BSTR * pbstrName)
{
    *pguidType = GUID_PStoreType;
    *pguidSub = GUID_NULL;

    *pbstrName = SysAllocString(bstrField);

    return S_OK;
}
#endif  // _USE_PSTORE_

// Functions to display the consent dialog.

BOOL CIEFrameAuto::COpsProfile::_OPSConsent_OnInitDlg(HWND hDlg)
{
    const   int cbMaxStringDisplay  = 24;
    
    LPOPSDLGINFO lpOpsDlgInfo = (LPOPSDLGINFO) GetWindowLongPtr(hDlg, DWLP_USER);
    COpsProfile *pProfile = lpOpsDlgInfo->m_pOpsProfile;

    if (!lpOpsDlgInfo || !lpOpsDlgInfo->m_hdpa)
        return FALSE;

    // Get the hostname
    TCHAR   rgSiteName[MAX_URL_STRING];
    DWORD   dwchOut = ARRAYSIZE(rgSiteName);

    HRESULT hr;
    
    hr = UrlGetPart(lpOpsDlgInfo->m_rgchURL, rgSiteName, &dwchOut, URL_PART_HOSTNAME, 0);
    if (FAILED(hr) || dwchOut == 0 )
        StrCpyN(rgSiteName, lpOpsDlgInfo->m_rgchURL, ARRAYSIZE(rgSiteName));

    // Display site identity information
    HWND        hwndReq = GetDlgItem(hDlg, IDC_SITE_IDENTITY);
    TCHAR       rgRequestInfo[MAX_URL_STRING];
    TCHAR       rgFormat[MAX_URL_STRING];

    BSTR        bstrFName = lpOpsDlgInfo->m_bstrFName;
    TCHAR       rgFName[MAX_URL_STRING];
    
    MLLoadString(IDS_DEFAULT_FNAME, rgFName, ARRAYSIZE(rgFName));

    MLLoadString(IDS_OPS_REQUEST, rgFormat, ARRAYSIZE(rgFormat));
    StringCchPrintf(rgRequestInfo, ARRAYSIZE(rgRequestInfo), rgFormat, rgFName);
    SetWindowText(hwndReq, rgRequestInfo);

    // Display the access settings
    TCHAR rgchAccessPath[MAX_URL_STRING];
    HWND hwndURL = GetDlgItem(hDlg, IDC_OPS_URL);
    _FormatSiteSettings(lpOpsDlgInfo->m_pacSettings, rgchAccessPath, ARRAYSIZE(rgchAccessPath));
    SetWindowText(hwndURL, rgchAccessPath);

    // Display the usage information
    HWND hwndUsage = GetDlgItem(hDlg, IDC_USAGE_STRING);
    SetWindowText(hwndUsage, lpOpsDlgInfo->m_rgchUsage);

    // Detect SSL and inform user in the lower pane
    BOOL fUsingSSL = pProfile->_IsUsingSSL();

    if (fUsingSSL) 
    {
        // If the connection is SSL, the default is to remember the settings
        lpOpsDlgInfo->m_fRemember = TRUE;          

        // Hide the unsecure connection text.
        HWND hwndStatic = GetDlgItem(hDlg, IDC_UNSECURE_CONNECTION);
        ASSERT(hwndStatic != NULL);
        ShowWindow(hwndStatic, SW_HIDE);

        HICON hicon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_LOCK));
        if (hicon != NULL)
        {
             HICON hiconOld = (HICON)SendDlgItemMessage(hDlg, IDC_SECURITY_ICON, STM_SETICON, 
                                                                (WPARAM)hicon, 0);
            if (hiconOld)
            {
                DestroyIcon(hiconOld);
            }
        }
    }
    else
    {
        // Hide the view certificate button and the secure connection text.
        HWND hwndViewCert = GetDlgItem(hDlg, IDC_VIEW_CERT);
        ASSERT(hwndViewCert != NULL);
        ShowWindow(hwndViewCert, SW_HIDE);

        HWND hwndStatic = GetDlgItem(hDlg, IDC_SECURE_CONNECTION);
        ASSERT(hwndStatic != NULL);
        ShowWindow(hwndStatic, SW_HIDE);
    }

    // Hide the Edit Profile button if we are using the PStore.
#ifdef _USE_PSTORE
    HWND hwndEditProf = GetDlgItem(hDlg, IDC_EDIT_PROFILE);
    ASSERT(hwndEditProf != NULL);
    ShowWindow(hwndEditProf, SW_HIDE);
#endif

    Button_SetCheck(GetDlgItem(hDlg, IDC_KEEP_SETTINGS), lpOpsDlgInfo->m_fRemember);    

    HWND hwndLV = GetDlgItem(hDlg, IDC_OPS_LIST);
    ASSERT(hwndLV);

    // Initialize the list view control
    ListView_SetExtendedListViewStyle(hwndLV, LVS_EX_CHECKBOXES);

    // Setup the columns for the list view control. 
    LV_COLUMN lvc = { LVCF_FMT , LVCFMT_LEFT };

    ListView_InsertColumn(hwndLV, 0, &lvc); 
    ListView_InsertColumn(hwndLV, 1, &lvc); 

    // Add elements to the list view. 
    _OPSConsent_ShowRequestedItems(hDlg);

    // show the items.
    ListView_RedrawItems(hwndLV, 0, ListView_GetItemCount(hwndLV));
    UpdateWindow(hwndLV);

    return TRUE;
}

BOOL
CIEFrameAuto::COpsProfile::_OPSConsent_ShowRequestedItems(HWND hDlg)
{
    LPOPSDLGINFO lpOpsDlgInfo = (LPOPSDLGINFO) GetWindowLongPtr(hDlg, DWLP_USER);
    COpsProfile *pProfile = lpOpsDlgInfo->m_pOpsProfile;

    HDPA hdpaList = lpOpsDlgInfo->m_hdpa;
    HWND hwndLV = GetDlgItem(hDlg, IDC_OPS_LIST);
    ASSERT(hwndLV);

    BOOL  fAllBlank = TRUE;

    TCHAR szName[MAX_PROFILE_NAME];

    // Initialize the common parts of the LVI
    LV_ITEM lvi = { 0 };

    for (int i=DPA_GetPtrCount(hdpaList)-1; i>=0; i--)
    {
        OPSRequestEntry * pOpsEntry = (OPSRequestEntry*) DPA_FastGetPtr(hdpaList,i);

        MLLoadString(_GetResourceIdFromAttrName(pOpsEntry->m_bstrName), szName, MAX_PATH);
        
        BSTR    bstrValue = NULL;
        TCHAR   rgchValue[1024];

        pProfile->_GetFieldValue(pOpsEntry->m_bstrName, &bstrValue);
        _StringFromBSTR(bstrValue, rgchValue, ARRAYSIZE(rgchValue));

        fAllBlank = fAllBlank && EMPTY_STRING(rgchValue);

        TCHAR *pchNewLine = StrPBrk(rgchValue, TEXT("\r\n"));
        if (pchNewLine)
            *pchNewLine = '\0';

        if (lstrlen(rgchValue)==0)
        {
            MLLoadString(IDS_OPS_BLANK, rgchValue, ARRAYSIZE(rgchValue));
        }

        SysFreeString(bstrValue);

        lvi.mask        = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
        lvi.iItem       = 0;
        lvi.iSubItem    = 0;
        lvi.pszText     = szName;
        lvi.cchTextMax  = MAX_PROFILE_NAME;
        lvi.stateMask   = LVIS_STATEIMAGEMASK;
        lvi.state       = pOpsEntry->m_fAnswer ? 0x00002000 : 0x00001000;
        lvi.lParam      = (LPARAM)pOpsEntry;

        int iItem = ListView_InsertItem(hwndLV, &lvi);

        lvi.mask        = LVIF_TEXT;
        lvi.iItem       = iItem;
        lvi.iSubItem    = 1;
        lvi.pszText     = rgchValue;
        ListView_SetItem(hwndLV, &lvi);

        // APPCOMPAT: There is a problem with the listview implementation because of which
        // the check box is not displayed even though lvi.state is set correctly.
        //  We have to find the item and set it again.
        ListView_SetItemState(hwndLV, iItem, pOpsEntry->m_fAnswer ? 0x00002000 : 0x00001000, LVIS_STATEIMAGEMASK);
    }

    lpOpsDlgInfo->m_fAllBlank = fAllBlank;

    // Autosize the columns
    ListView_SetColumnWidth(hwndLV, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(hwndLV, 1, LVSCW_AUTOSIZE);

    return TRUE;
}


BOOL CIEFrameAuto::COpsProfile::_OPSDlg_OnClose(HWND hDlg)
{
    LPOPSDLGINFO lpOpsDlgInfo = (LPOPSDLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    HWND hwndLV = GetDlgItem(hDlg, IDC_OPS_LIST);
    int nItems = ListView_GetItemCount(hwndLV);

    LV_ITEM lvi = {0};
    lvi.mask    = LVIF_PARAM ;        

    for (int i = 0; i < nItems ; i++ )
    {
        lvi.iItem = i;
        lvi.lParam = 0;
        
        ListView_GetItem(hwndLV, &lvi);

        ASSERT(lvi.lParam != NULL)
        if (lvi.lParam)
        {
            OPSRequestEntry * pOpsEntry = (OPSRequestEntry *)lvi.lParam;
            
            pOpsEntry->m_fAnswer = ListView_GetCheckState(hwndLV, i);
        }
    }

    lpOpsDlgInfo->m_fRemember = Button_GetCheck(GetDlgItem(hDlg, IDC_KEEP_SETTINGS));    
    
    return TRUE;
}                                    


BOOL CIEFrameAuto::COpsProfile::_OPSConsent_EditProfile(HWND hDlg)
{
#ifdef _USE_PSTORE
    return FALSE;
#else
    HRESULT hr;
    LPOPSDLGINFO lpOpsDlgInfo = (LPOPSDLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!lpOpsDlgInfo || !lpOpsDlgInfo->m_hdpa)
        return FALSE;   
    
    CIEFrameAuto::COpsProfile * pOpsProfile = lpOpsDlgInfo->m_pOpsProfile;
    if (pOpsProfile == NULL || pOpsProfile->m_lpAdrBook == NULL)
    {
        ASSERT(FALSE);
        return FALSE;
    }
        
    if (pOpsProfile->m_SBMe.cb == 0)
        return FALSE;
             
    LPSBinary lpSB = &(pOpsProfile->m_SBMe);

    // Display the WAB dialog for the me entry. 
    hr = pOpsProfile->m_lpAdrBook->Details(  (LPULONG) &hDlg,
                                        NULL,
                                        NULL,
                                        lpSB->cb,
                                        (LPENTRYID)lpSB->lpb,
                                        NULL,
                                        NULL,
                                        NULL,
                                        0);

    return (hr) ? FALSE : TRUE;
#endif
}


BOOL CIEFrameAuto::COpsProfile::_OPSConsent_OnCommand(HWND hDlg, UINT id, UINT nCmd)
{
    LPOPSDLGINFO lpOpsDlgInfo = (LPOPSDLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    switch (id)
    {
        case IDOK:
            if (lpOpsDlgInfo->m_fAllBlank)
            {
                // The user has agreed to share information but all the entries in the 
                // profile are blank. This is probably due to user oversight, since the
                // easier way to achieve the same effect would be to select "DENY"

                TCHAR   rgchHeading[256];
                MLLoadShellLangString(IDS_PROFILE_ASSISTANT, rgchHeading, ARRAYSIZE(rgchHeading));

                TCHAR   rgchConfirm[1024];
                MLLoadShellLangString(IDS_OPS_NO_INFORMATION, rgchConfirm, ARRAYSIZE(rgchConfirm));

                ULONG_PTR uCookie = 0;
                SHActivateContext(&uCookie);
                DWORD msgRet = MessageBox(hDlg, rgchConfirm, rgchHeading, MB_YESNO | MB_DEFBUTTON1 | MB_ICONWARNING);
                if (uCookie)
                {
                    SHDeactivateContext(uCookie);
                }

                if (msgRet==IDYES)
                    goto FallThrough;
            }
        
            if (! Button_GetCheck(GetDlgItem(hDlg, IDC_KEEP_SETTINGS))  &&
                  (_GetCookieSettings()==COOKIES_ALLOW))
            {
                // The user wants to share information for one time only but cookies
                // are enabled, allowing sites to store profile information in a cookie
                DWORD   dwConfirm = 0;
                TCHAR   rgchHeading[256];
                TCHAR   rgchConfirm[1024];
                AccessSettings *pac = lpOpsDlgInfo->m_pacSettings;

                MLLoadShellLangString(IDS_PROFILE_ASSISTANT, rgchHeading, ARRAYSIZE(rgchHeading));
                MLLoadShellLangString(IDS_OPS_CONFIRM, rgchConfirm, ARRAYSIZE(rgchConfirm));

                ULONG_PTR uCookie = 0;
                SHActivateContext(&uCookie);
                dwConfirm = MessageBox(hDlg, rgchConfirm, rgchHeading, MB_ICONINFORMATION | MB_OKCANCEL | MB_DEFBUTTON2);
                if (uCookie)
                {
                    SHDeactivateContext(uCookie);
                }

                if (dwConfirm!=IDOK)
                    break;
            }

            _OPSDlg_OnClose(hDlg);        
            EndDialog(hDlg, TRUE);
            break;

FallThrough:

        case IDC_EDIT_PROFILE:
            {
                HWND hwndLV = GetDlgItem(hDlg, IDC_OPS_LIST);
                ListView_DeleteAllItems(hwndLV);
    
                _OPSConsent_EditProfile(hDlg);
            
                _OPSConsent_ShowRequestedItems(hDlg);
                ListView_RedrawItems(hwndLV, 0, ListView_GetItemCount(hwndLV));
                UpdateWindow(hwndLV);
                break;
            }

        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;

        case IDC_VIEW_CERT:
            _OPSConsent_ViewCertificate(hDlg);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}                    

              
BOOL         
CIEFrameAuto::COpsProfile::_OPSConsent_ViewCertificate(HWND hDlg) 
{
    OPSDlgInfo *pDlgInfo = (OPSDlgInfo*) GetWindowLongPtr(hDlg, DWLP_USER);

    InternetShowSecurityInfoByURL(pDlgInfo->m_rgchURL, hDlg);
    return TRUE;
}

INT_PTR CIEFrameAuto::COpsProfile::_OPSConsent_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)  
    {
        case WM_INITDIALOG:
            ASSERT(NULL != lParam);            
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);  // save the list.

            return _OPSConsent_OnInitDlg(hDlg);

        case WM_COMMAND:
            return _OPSConsent_OnCommand(hDlg, LOWORD(wParam), HIWORD(wParam));

        case WM_HELP:
            SHWinHelpOnDemandWrap((HWND) ((LPHELPINFO) lParam)->hItemHandle, c_szHelpFile,
                    HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aHelpIDs);
            break;

        case WM_CONTEXTMENU:
            SHWinHelpOnDemandWrap((HWND) wParam, c_szHelpFile, HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPTSTR) aHelpIDs);
            break;
            
        case WM_DESTROY:
            break;
    }
    
    return FALSE;
}                                        


// Update dialog functions.
BOOL CIEFrameAuto::COpsProfile::_OPSUpdate_OnInitDlg(HWND hDlg)
{
    LPOPSDLGINFO lpOpsDlgInfo = (LPOPSDLGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!lpOpsDlgInfo || !lpOpsDlgInfo->m_hdpa)
        return FALSE;   

    HDPA hdpaList = lpOpsDlgInfo->m_hdpa;
    HWND hwndLV = GetDlgItem(hDlg, IDC_OPS_LIST);
    ASSERT(hwndLV);

    // Add elements to the list view. 
    ListView_SetExtendedListViewStyle(hwndLV, LVS_EX_CHECKBOXES);

    // Initialize the common parts of the LVI
    TCHAR szName[MAX_PROFILE_NAME];
    LV_ITEM lvi = { 0 };
    lvi.mask        = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
    lvi.iItem       = 0;
    lvi.pszText     = szName;
    lvi.cchTextMax  = MAX_PROFILE_NAME;
    lvi.stateMask   = LVIS_STATEIMAGEMASK;

    LV_FINDINFO lvfi = { 0 };
    lvfi.flags = LVFI_STRING;
    lvfi.psz   = szName;

    for (int i=0; i<DPA_GetPtrCount(hdpaList); i++)
    {
        OPSRequestEntry * pOpsEntry = (OPSRequestEntry*) DPA_FastGetPtr(hdpaList,i);

        MLLoadString(_GetResourceIdFromAttrName(pOpsEntry->m_bstrName), szName, MAX_PATH);

        pOpsEntry->m_fAnswer = TRUE;
        lvi.state       = 0x00002000;
        lvi.lParam      = (LPARAM)pOpsEntry;

        ListView_InsertItem(hwndLV, &lvi);

        // APPCOMPAT: There is a problem with the listview implementation because of which
        // the check box is not displayed even though lvi.state is set correctly.
        //  We have to find the item and set it again.
        ListView_SetItemState(hwndLV, ListView_FindItem(hwndLV, -1, &lvfi), 0x00002000, LVIS_STATEIMAGEMASK);
    }

    // show the items.
    ListView_RedrawItems(hwndLV, 0, ListView_GetItemCount(hwndLV));
    UpdateWindow(hwndLV);

    return TRUE;
}

BOOL CIEFrameAuto::COpsProfile::_OPSUpdate_OnCommand(HWND hDlg, UINT id, UINT nCmd)
{
    switch (id)
    {
        case IDOK:
            _OPSDlg_OnClose(hDlg);
            EndDialog(hDlg, TRUE);
            break;
            
        case IDCANCEL:
            EndDialog(hDlg, FALSE);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}                    
    
INT_PTR CIEFrameAuto::COpsProfile::_OPSUpdate_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)  
    {
        case WM_INITDIALOG:
            ASSERT(NULL != lParam);            
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);  // save the list.

            return _OPSUpdate_OnInitDlg(hDlg);

        case WM_COMMAND:
            return _OPSUpdate_OnCommand(hDlg, LOWORD(wParam), HIWORD(wParam));

        case WM_HELP:
            break;

        case WM_CONTEXTMENU:
            break;
            
        case WM_DESTROY:
            break;
    }
    
    return FALSE;
}                                        

       
BOOL
CIEFrameAuto::COpsProfile ::_ValidateElemName(LPCWSTR szIn, INT *pIndex /* = NULL */)
{
    int index = _GetAttrIndexFromName(szIn);
    if ( INVALID_ATTRIBUTE_INDEX != index )
    {
        if (pIndex) 
            *pIndex = index;

        return TRUE;                    
    }

    return FALSE;
}

INT CIEFrameAuto::COpsProfile::_GetAttrIndexFromName (LPCWSTR pwzName )
{
    INT index = INVALID_ATTRIBUTE_INDEX;

    if ( pwzName != NULL )
    {
        for ( int i = 0 ; i < ARRAYSIZE(rgProfAttr) ; i++ )
        {
            if (0 == StrCmpIW(rgProfAttr[i].pwzName, pwzName ))
            {
                index = i;
                break;
            }
        }
    }
    return index;
}

INT CIEFrameAuto::COpsProfile::_GetResourceIdFromAttrName( WCHAR * pwzName)
{
    return _GetResourceIdFromAttrIndex(_GetAttrIndexFromName(pwzName));
}

BOOL                
CIEFrameAuto::COpsProfile::_IsLocalMachine()
{
    BOOL    fLocal = FALSE;

    BSTR    bstrURL;
    HRESULT hr = _pAuto->get_LocationURL(&bstrURL);
    if (SUCCEEDED(hr))
    {
        DWORD   dwZone;
        hr = GetZoneFromUrl(bstrURL, _pAuto->_psp, &dwZone);
        if (SUCCEEDED(hr))
        {
            fLocal = (dwZone == URLZONE_LOCAL_MACHINE); 
        }

        SysFreeString(bstrURL);
    }

    return fLocal;
}

    
HRESULT
CIEFrameAuto::COpsProfile::_GetUserPreference(BSTR bstrName, P3UserPref *pUsrPref) {

    TCHAR   rgszName[MAX_PROFILE_NAME];
    DWORD   dwType;
    DWORD   dwPrefSize;
    DWORD   dwError;

    _StringFromBSTR(bstrName, rgszName, ARRAYSIZE(rgszName));

    dwPrefSize = sizeof(struct P3UserPref);
    dwError = RegQueryValueEx(m_hP3Global, rgszName, 0, &dwType, 
                             (LPBYTE) pUsrPref, &dwPrefSize);

    if (dwError == ERROR_MORE_DATA) 
    {
        BYTE *pBuffer;
        pBuffer = new BYTE [dwPrefSize];
        if (pBuffer == NULL)
        {
            return E_OUTOFMEMORY;
        }
        dwError = RegQueryValueEx(m_hP3Global, rgszName, 0, &dwType, pBuffer, &dwPrefSize);
        memcpy(pUsrPref, pBuffer, sizeof(struct P3UserPref));
        delete [] pBuffer;
    }

    // If a preference for this attribute is not found, create a default one and 
    // write it back to persistent storage
    if (dwError != ERROR_SUCCESS)
    {
        P3UserPref  defPrefs;
        
        defPrefs.m_access = P3_QUERY;
        defPrefs.m_lastRequest = P3_ACCEPT;

        _PutUserPreference(bstrName, defPrefs);
        *pUsrPref = defPrefs;
    }

    return S_OK;
}


HRESULT 
CIEFrameAuto::COpsProfile::_PutUserPreference(BSTR bstrName, P3UserPref usrPref) {

    TCHAR   rgszName[MAX_PROFILE_NAME];
    DWORD   dwError;

    _StringFromBSTR(bstrName, rgszName, ARRAYSIZE(rgszName));

    dwError = RegSetValueEx(m_hP3Global, rgszName, 0, REG_BINARY,
                            (LPBYTE) &usrPref,
                            sizeof(struct P3UserPref));

    return HRESULT_FROM_WIN32(dwError);
}

BOOL
CIEFrameAuto::COpsProfile::_IsUsingSSL() 
{
    BOOL fSecure = FALSE;

    BSTR    bstrUrl;
    TCHAR   rgchUrl[MAX_URL_STRING+1];

    _pAuto->get_LocationURL(&bstrUrl);
    _StringFromBSTR(bstrUrl, rgchUrl, ARRAYSIZE(rgchUrl));
    SysFreeString(bstrUrl);
    fSecure = GetUrlScheme(rgchUrl)==URL_SCHEME_HTTPS;

    return fSecure;
}

HRESULT     
CIEFrameAuto::COpsProfile::_ApplyPreferences(URL_COMPONENTS *pucURL, HDPA hdpaReqList) 
{
    for (int k=0; k<DPA_GetPtrCount(hdpaReqList); k++)
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(hdpaReqList,k);
        pCurrent->m_fQuery  = TRUE;
        pCurrent->m_fAnswer = FALSE;
        pCurrent->m_dwDecision = P3_NONE;
    }

    _ApplySiteSettings(pucURL, hdpaReqList);
    _ApplyGlobalSettings(hdpaReqList);
    return S_OK;
}

HRESULT     
CIEFrameAuto::COpsProfile::_ApplyGlobalSettings(HDPA hdpaReqList) 
{
    for (int k=0; k<DPA_GetPtrCount(hdpaReqList); k++)
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(hdpaReqList,k);
        P3UserPref       userInfo;
    
        _GetUserPreference(pCurrent->m_bstrName, &userInfo);

        switch (userInfo.m_access)
        {
        case P3_GRANT:      if (pCurrent->m_fQuery)
                            {
                                pCurrent->grantRequest();
                                pCurrent->m_dwDecision = P3_GLOBAL;
                            }
                            break;
        case P3_DENY:       pCurrent->denyRequest();
                            pCurrent->m_dwDecision = P3_GLOBAL;
                            break;
        case P3_REQSSL:     // This resolves to P3_QUERY at the moment
        case P3_QUERY:      if (pCurrent->m_fQuery)
                                pCurrent->m_fAnswer = (userInfo.m_lastRequest == P3_ACCEPT);
                            break;
        default:            ;
        }
    }

    return S_OK;
}

HRESULT
CIEFrameAuto::COpsProfile::_ApplySiteSettings(URL_COMPONENTS *pucURL, HDPA hdpaReqList)
{
    if (pucURL->nScheme!=INTERNET_SCHEME_HTTP && pucURL->nScheme!=INTERNET_SCHEME_HTTPS)
        return S_OK;

    TCHAR *pszSubDomain = pucURL->lpszHostName;

    // For a given hostname such as "www.foo.bar.com", this loop will iterate over all possible
    // domains such as "www.foo.bar.com", ".foo.bar.com" and ".bar.com" but NOT ".com"
    while (pszSubDomain!=NULL && _LegalDomain(pucURL->lpszHostName, pszSubDomain))
    {
        HKEY    hkey    = NULL;
        
        if (ERROR_SUCCESS == RegOpenKeyEx(m_hP3Sites, pszSubDomain, 0, KEY_ENUMERATE_SUB_KEYS, &hkey))
        {
            _ApplyDomainSettings(pucURL, hkey, hdpaReqList);
            RegCloseKey(hkey);
        }
        pszSubDomain = StrChr(pszSubDomain+1, TEXT('.')); // Find the next embedded dot
    }

    return S_OK;
}

HRESULT     
CIEFrameAuto::COpsProfile::_ApplyDomainSettings(URL_COMPONENTS *pucComp, HKEY hkey, HDPA hdpaReqList) 
{
    DWORD   dwError;
    DWORD   dwIndex = 0;
    TCHAR   rgchName[MAX_PATH];

    int     iReqCount = DPA_GetPtrCount(hdpaReqList);
    DWORD  *pdwLastApplied = new DWORD[iReqCount];

    if (pdwLastApplied == NULL)
    {
        return E_OUTOFMEMORY;
    }

    for (int i=0; i<iReqCount; i++)
        pdwLastApplied[i] = 0;

    do
    {
        DWORD dwcbVal = ARRAYSIZE(rgchName);
        
        dwError = RegEnumKeyEx(hkey, dwIndex, rgchName, &dwcbVal, NULL, NULL, NULL, NULL);
        if (dwError==ERROR_SUCCESS)
        {
            HKEY hPathKey;
            AccessSettings ac;

            dwError = RegOpenKeyEx(hkey, rgchName, 0, KEY_QUERY_VALUE, &hPathKey);
            _ReadSettingsFromRegistry(hPathKey, &ac);
            _ApplySettings(&ac, pucComp, hdpaReqList, pdwLastApplied);
            RegCloseKey(hPathKey);
        }
        dwIndex++;
    } 
    while (dwError==ERROR_SUCCESS);

    delete [] pdwLastApplied;
    return S_OK;
}

HRESULT
CIEFrameAuto::COpsProfile::_UpdateSiteSettings(AccessSettings *pSettings, HDPA hdpaReqList)
{
    DWORD       dwError;
    DWORD       dwAction;

    // Clear the allow and deny vectors
    ZeroMemory(pSettings->m_rgbStdAllow, sizeof(pSettings->m_rgbStdAllow));
    ZeroMemory(pSettings->m_rgbStdDeny, sizeof(pSettings->m_rgbStdDeny));

    // Fill out the vectors based on the user responses on the request list    
    for (int i=0; i<DPA_GetPtrCount(hdpaReqList); i++)
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(hdpaReqList,i);
        int iVcardIndex = _GetAttrIndexFromName(pCurrent->m_bstrName);

        // At the moment we do not handle custom attributes
        if (iVcardIndex!=INVALID_ATTRIBUTE_INDEX)
            _WriteBitVector(pCurrent->m_fAnswer ? pSettings->m_rgbStdAllow : pSettings->m_rgbStdDeny, iVcardIndex);
    }

    // Create a key for the given domain or open it if one already exists
    HKEY  hDomainKey;
    dwError = RegCreateKeyEx(m_hP3Sites, pSettings->m_rgchDomain, 
                            0, NULL, REG_OPTION_NON_VOLATILE, KEY_ENUMERATE_SUB_KEYS,
                            NULL, &hDomainKey, &dwAction);

    if (dwError != ERROR_SUCCESS)
        return E_FAIL;

    TCHAR       rgchName[16];
    DWORD       dwIndex = 0;
    
    do
    {
        DWORD dwcbName = ARRAYSIZE(rgchName);
        if (ERROR_SUCCESS == RegEnumKeyEx(hDomainKey, dwIndex, rgchName, &dwcbName, NULL, NULL, NULL, NULL))
        {
            HKEY hPathKey;
            if (ERROR_SUCCESS == RegOpenKeyEx(hDomainKey, rgchName, 0, KEY_QUERY_VALUE, &hPathKey))
            {
                AccessSettings ac;
                _ReadSettingsFromRegistry(hPathKey, &ac);    
                RegCloseKey(hPathKey); // not needed below

                // If there are existing settings for this domain and path, merge the permissions
                if (StrCmp(ac.m_rgchPath, pSettings->m_rgchPath) == 0)
                {
                    // An attribute is allowed if it has been allowed explicitly by the user from
                    // the current UI or it was previously allowed and it has not been denied
                    // in the current UI. Similarly, an attribute is denied if it is denied in the
                    // current UI or it was denied previously and it has not been granted this time.
                    for (int i=0; i<ARRAYSIZE(pSettings->m_rgbStdAllow); i++)
                    {
                        pSettings->m_rgbStdAllow[i] |= ac.m_rgbStdAllow[i] & ~(pSettings->m_rgbStdDeny[i]);
                        pSettings->m_rgbStdDeny[i]  |= ac.m_rgbStdDeny[i]  & ~(pSettings->m_rgbStdAllow[i]);
                    }
                    break;
                }
                dwIndex++;
            }
        }
    }
    while (dwError == ERROR_SUCCESS);

    StringCchPrintf(rgchName, ARRAYSIZE(rgchName), TEXT("%03d"), dwIndex);

    HKEY hPathKey;
    if (ERROR_SUCCESS == RegCreateKeyEx(hDomainKey, rgchName, 0, NULL, 0, KEY_SET_VALUE, NULL, &hPathKey, &dwAction))
    {
        _WriteSettingsToRegistry(hPathKey, pSettings);
        RegCloseKey(hPathKey);
    }

    RegCloseKey(hDomainKey);

    return S_OK;
}

BOOL
CIEFrameAuto::COpsProfile::_ReadBitVector(LPCBYTE ucBitVector, DWORD dwIndex)
{
    DWORD   dwByte = dwIndex/8;
    DWORD   dwMask = 0x80 >> (dwIndex & 0x07);

    return (ucBitVector[dwByte]&dwMask) != 0;
}

VOID
CIEFrameAuto::COpsProfile::_WriteBitVector(LPBYTE ucBitVector, DWORD dwIndex)
{
    DWORD   dwByte = dwIndex/8;
    DWORD   dwMask = 0x80 >> (dwIndex & 0x07);

    ucBitVector[dwByte] |= dwMask;
}


// The path matching is done on a character-level, which is the way cookies are
// implemented in IE4 and in Navigator
// Note that this is different from the RFC-2109
BOOL
CIEFrameAuto::COpsProfile::_PathMatch(TCHAR *pszDocumentPath, TCHAR *pszAccessPath)
{
    return StrStr(pszDocumentPath,pszAccessPath) == pszDocumentPath;
}


// Domain name matching is done on the character level except that a leading
// period is added to the access domain if necessary
// Refer to "cookie.cxx" in MSHTML for details
BOOL
CIEFrameAuto::COpsProfile::_DomainMatch(TCHAR *pszHostName, TCHAR *pszDomain) 
{
    // If domain is the same as hostname, matching is successful
    if (StrCmp(pszHostName, pszDomain) == 0)
        return TRUE;

    // Fail if the domain is not a legal subdomain of the hostname
    // This prevents matching against invaid domains such as ".com" or ".edu"
    if (! _LegalDomain(pszHostName, pszDomain))
        return FALSE;

    // Find the matching part of the domain on the access path
    TCHAR *pszMatchingPart = StrStr(pszHostName, pszDomain);

    // If the domain is not a substring of the hostname, it does not match
    if (pszMatchingPart==NULL)
        return FALSE;

    // Otherwise the domain must be a suffix and it should either contain a period
    // at the beginning or should match following a period
    if (StrCmp(pszMatchingPart, pszDomain) != 0)
        return FALSE;
    if (*pszMatchingPart!='.' && pszMatchingPart[-1]!='.')
        return FALSE;

    return TRUE;
}

BOOL
CIEFrameAuto::COpsProfile::_LegalDomain(TCHAR *pszHostName, TCHAR *pszDomain)
{
    // Fail if either of the strings are invalid
    if (pszHostName==NULL || pszDomain==NULL ||
        EMPTY_STRING(pszHostName) || EMPTY_STRING(pszDomain))
        return FALSE;

    // If domain is the same as hostname, it is always valid
    if (!StrCmpI(pszHostName, pszDomain))
        return TRUE;
    
    int iEmbeddedPeriods = 0;

    // Count the number of embedded periods, defined as the number of dots after
    // the first character of the domain
    for (int i=1; pszDomain[i]!=0; i++)
        if (pszDomain[i]=='.')
            iEmbeddedPeriods++;

    // Require that the domain name has at least one embedded period
    if (iEmbeddedPeriods==0)
        return FALSE;

    // Find the requested domain name in the host name 
    TCHAR   *pszMatchingPart = StrStr(pszHostName, pszDomain);

    // Require that this search succeed
    if (pszMatchingPart==NULL)
        return FALSE;

    // Require furthermore that the domain name be a suffix of the hostname 
    if (StrCmp(pszMatchingPart, pszDomain) != 0)
        return FALSE;

    // If all the above criteria has been satisfied, then the domain is valid
    return TRUE;
}

// Path matching is done at a character-level; this is to be compliant with Netscape
// Navigator and the original cookie specification.
// This has the surprising result that "/foo" matches "/foo/doc" as well as "/foobar/doc"
BOOL
CIEFrameAuto::COpsProfile::_LegalPath(TCHAR *pszActualPath, TCHAR *pszAccessPath)
{
    return StrStr(pszActualPath, pszAccessPath) == pszActualPath;
}


// For the ANSI<-->UNICODE transition 
HRESULT
CIEFrameAuto::COpsProfile::_StringFromBSTR(BSTR bstrSource, TCHAR *pszDest, DWORD cchDestSize) 
{
    StrCpyNW(pszDest, bstrSource, cchDestSize);
    return S_OK;
}

HRESULT     
CIEFrameAuto::COpsProfile::_StringFromVariant(VARIANT *vaSource, TCHAR *pszDest, DWORD cchDestSize)
{
    VARIANT     vaTemp;
    HRESULT     hr;

    VariantInit(&vaTemp);
    hr = VariantChangeType(&vaTemp, vaSource, 0, VT_BSTR);

    if (SUCCEEDED(hr))
        _StringFromBSTR(vaTemp.bstrVal, pszDest, cchDestSize);
    else
        ZeroMemory(pszDest, cchDestSize*sizeof(TCHAR));
    
    VariantClear(&vaTemp);
    return hr;
}

INT
CIEFrameAuto::COpsProfile::_GetCookieSettings()
{

    HKEY    hInetKey = NULL;
    DWORD   dwCookiePref;
    DWORD   dwDataRead = sizeof(dwCookiePref);

    DWORD   dwError = RegOpenKeyEx(HKEY_CURRENT_USER, rgszInetKey, 0, KEY_READ, &hInetKey);
    if (dwError != ERROR_SUCCESS)
        return COOKIES_DENY;

    dwError = RegQueryValueEx(hInetKey, rgszCookieTxt, NULL, NULL, (LPBYTE) &dwCookiePref, &dwDataRead);

    RegCloseKey(hInetKey);

    if (dwError==ERROR_SUCCESS)
        return dwCookiePref;
    else
        return COOKIES_ALLOW;
}

HRESULT
CIEFrameAuto::COpsProfile::_GetUsageCode(VARIANT vaUsage, LPTSTR rgchUsage, int cLen)
{
    LONG lUsage;

    VARIANT varDest;
    VariantInit(&varDest);

    HRESULT hr = VariantChangeType(&varDest, &vaUsage, 0, VT_I4);

    if (SUCCEEDED(hr))
    {
        lUsage = varDest.lVal;
        // If lUsage is not within range just display unknown usage.     
        if (lUsage < 0 || lUsage > (IDS_OPS_USAGEMAX - IDS_OPS_USAGE0))
            lUsage = -1;
    }
    else
        lUsage = -1;

    VariantClear(&varDest);

    MLLoadString(lUsage + IDS_OPS_USAGE0, rgchUsage, cLen);

    return S_OK;
}

BOOL
CIEFrameAuto::COpsProfile::_IsP3Enabled()
{
    DWORD dwEnabled;
    DWORD dwDataOut = sizeof(dwEnabled);
    DWORD dwError = RegQueryValueEx(m_hP3Global, rgszEnabled, NULL, NULL, (LPBYTE) &dwEnabled, &dwDataOut);
    if (dwError != ERROR_SUCCESS)
    {
        dwEnabled = TRUE;
        RegSetValueEx(m_hP3Global, rgszEnabled, 0, REG_DWORD, (LPBYTE)&dwEnabled, sizeof(dwEnabled));
    }
    return dwEnabled;
}

// The script can specify domain, path and expiration date for the settings.
// If these are not provided, the domain defaults to the hostname, the path to the current 
// document and the expiration to a specified number of days in the future
HRESULT 
CIEFrameAuto::COpsProfile::_GetSiteSettings(URL_COMPONENTS *pucComp, 
                                            VARIANT vaDomain, VARIANT vaPath, VARIANT vaExpire,
                                            AccessSettings *pSettings)
{
    SYSTEMTIME  st;
    TCHAR       rgchExpire[32];
    HRESULT     hr;
    BOOL        bRet;    

    // Note: For IE4, the domain name has to be hostname.
    StrCpyN(pSettings->m_rgchDomain, pucComp->lpszHostName, ARRAYSIZE(pSettings->m_rgchDomain));

    hr = _StringFromVariant(&vaPath, pSettings->m_rgchPath, ARRAYSIZE(pSettings->m_rgchPath)); 
    if (FAILED(hr))
        StrCpyN(pSettings->m_rgchPath, pucComp->lpszUrlPath, ARRAYSIZE(pSettings->m_rgchPath));

    // If the path is different from the page, add a "/" if necessary at the end
    DWORD dwPathLen = lstrlen(pSettings->m_rgchPath);
    
    if (StrCmp(pSettings->m_rgchPath, pucComp->lpszUrlPath)     &&
        pSettings->m_rgchPath[dwPathLen-1] != TEXT('/'))
    {
        StrCatBuff(pSettings->m_rgchPath, TEXT("/"), ARRAYSIZE(pSettings->m_rgchPath));
    }


    FILETIME        ftNow;
    LARGE_INTEGER  *pqwNow = (LARGE_INTEGER*) & ftNow;
    LARGE_INTEGER  *pftime = (LARGE_INTEGER*) & pSettings->m_ftExpire;

    GetSystemTimeAsFileTime(&ftNow);

    hr = _StringFromVariant(&vaExpire, rgchExpire, ARRAYSIZE(rgchExpire));
    if (SUCCEEDED(hr))
    {
        bRet = InternetTimeToSystemTime(rgchExpire, &st, 0);
        SystemTimeToFileTime(&st, & pSettings->m_ftExpire);
    }
    if (FAILED(hr) || !bRet)
    {
        QUAD_PART(*pftime) = QUAD_PART(*pqwNow) + defExpiration;
    }

    // Enforce the limit on expiration time
    __int64 qwDelta = (QUAD_PART(*pftime)) - (QUAD_PART(*pqwNow));

    if (qwDelta<0 || qwDelta>maxExpiration)
        QUAD_PART(*pftime) = QUAD_PART(*pqwNow) + maxExpiration;

    // Make sure that the domain and path are valid
    // The criteria is a mix of the cookie semantics as defined by RFC-2109 and Navigator 
    // compliant behaviour as implemented elsewhere in IE4 
    if (!_LegalPath(pucComp->lpszUrlPath, pSettings->m_rgchPath))
        StrCpyN(pSettings->m_rgchPath, pucComp->lpszUrlPath, ARRAYSIZE(pSettings->m_rgchPath));

    if (!_LegalDomain(pucComp->lpszHostName, pSettings->m_rgchDomain))
        StrCpyN(pSettings->m_rgchDomain, pucComp->lpszHostName, ARRAYSIZE(pSettings->m_rgchDomain));

    // Add a period at the beginning of the domain name if it is not equal to 
    // the host name
    if (StrCmpI(pucComp->lpszHostName, pSettings->m_rgchDomain)   &&
        pSettings->m_rgchDomain[0] != '.')
    {
        StrCpyN(1+pSettings->m_rgchDomain, pSettings->m_rgchDomain, ARRAYSIZE(pSettings->m_rgchDomain)-1);
        pSettings->m_rgchDomain[0] = '.';
    }

    pSettings->m_fExactDomain   = ! StrCmpI(pSettings->m_rgchDomain, pucComp->lpszHostName);
    
    if (StrCmp(pSettings->m_rgchPath, pucComp->lpszUrlPath))
    {
        pSettings->m_fExactPath = FALSE;
    }
    else
    {
        pSettings->m_fExactPath = pSettings->m_rgchPath[dwPathLen-1]!=TEXT('/');
    }

    return S_OK;
}

HRESULT
CIEFrameAuto::COpsProfile::_FormatSiteSettings(AccessSettings *pSettings, LPTSTR rgchOut, int cLimit)
{
    TCHAR   rgchFullName[MAX_URL_STRING];
    TCHAR   rgchTemp[MAX_URL_STRING];

    StringCchPrintf(rgchFullName,
             ARRAYSIZE(rgchFullName),
             TEXT("http://%s%s"),
             pSettings->m_rgchDomain,
             pSettings->m_rgchPath);

    FormatUrlForDisplay(rgchFullName, rgchTemp, cLimit, NULL, 0, FALSE, CP_ACP, NULL);

    TCHAR *pchSiteName = StrStr(rgchTemp, TEXT("//"));
 
    if (pchSiteName==NULL)
        pchSiteName = rgchTemp;
    else
        pchSiteName += 2;

    StrCpyN(rgchOut, pchSiteName, cLimit);
    return S_OK;
}


// Attempts to use the given settings to determine the user response to the requests 
// in the given list. If the domain and path for the settings is not applicable to
// for the given URL, returns FALSE.
BOOL
CIEFrameAuto::COpsProfile::_ApplySettings(AccessSettings *pac, URL_COMPONENTS *puc, HDPA hdpaReqList, DWORD *pdwLast)
{
    if (!_DomainMatch(puc->lpszHostName, pac->m_rgchDomain)  ||
        !_PathMatch(puc->lpszUrlPath, pac->m_rgchPath))
        return FALSE;

    DWORD   dwPathLen = lstrlen(pac->m_rgchPath);

    for (int i=0; i<DPA_GetPtrCount(hdpaReqList); i++)
    {
        OPSRequestEntry *pCurrent = (OPSRequestEntry*) DPA_FastGetPtr(hdpaReqList,i);
        int iVcIndex = _GetAttrIndexFromName(pCurrent->m_bstrName);

        if (iVcIndex==INVALID_ATTRIBUTE_INDEX)
            continue;

        if (pdwLast[i]>=dwPathLen)
            continue;
        else
            pdwLast[i] = dwPathLen;

        BOOL    fAllow  = _ReadBitVector(pac->m_rgbStdAllow, iVcIndex);
        BOOL    fDeny   = _ReadBitVector(pac->m_rgbStdDeny, iVcIndex);

        if (fDeny)
        {
            pCurrent->denyRequest();
            pCurrent->m_dwDecision = P3_SITELEVEL;
        }
        else if (fAllow)
        {
            pCurrent->grantRequest();
            pCurrent->m_dwDecision = P3_SITELEVEL;
        }
    }    

    return TRUE;
}

BOOL
CIEFrameAuto::COpsProfile::_ReadSettingsFromRegistry(HKEY hkey, AccessSettings *pac)
{
    DWORD  dwError;
    DWORD  dwcb;

    ZeroMemory(pac, sizeof(struct AccessSettings));

    dwcb = sizeof(pac->m_rgbStdAllow);
    dwError = RegQueryValueEx(hkey, rgszAllowTxt, NULL, NULL, (LPBYTE) pac->m_rgbStdAllow, &dwcb);

    dwcb = sizeof(pac->m_rgbStdDeny);
    dwError = RegQueryValueEx(hkey, rgszDenyTxt, NULL, NULL, (LPBYTE) pac->m_rgbStdDeny, &dwcb);

    dwcb = sizeof(pac->m_rgchPath);
    dwError = RegQueryValueEx(hkey, rgszPathTxt, NULL, NULL, (LPBYTE) pac->m_rgchPath, &dwcb);

    dwcb = sizeof(pac->m_rgchDomain);
    dwError = RegQueryValueEx(hkey, rgszDomainTxt, NULL, NULL, (LPBYTE) pac->m_rgchDomain, &dwcb);

    return (dwError==ERROR_SUCCESS);
}

BOOL
CIEFrameAuto::COpsProfile::_WriteSettingsToRegistry(HKEY hkey, AccessSettings *pac)
{
    RegSetValueEx(hkey, rgszAllowTxt, 0, REG_BINARY, pac->m_rgbStdAllow, sizeof(pac->m_rgbStdAllow));
    RegSetValueEx(hkey, rgszDenyTxt, 0, REG_BINARY, pac->m_rgbStdDeny, sizeof(pac->m_rgbStdDeny));

    RegSetValueEx(hkey, rgszPathTxt, 0, REG_SZ, (LPBYTE) pac->m_rgchPath, sizeof(pac->m_rgchPath));
    RegSetValueEx(hkey, rgszDomainTxt, 0, REG_SZ, (LPBYTE) pac->m_rgchDomain, sizeof(pac->m_rgchDomain));

    return TRUE;
}


// This function revokes all site permission given previously by deleting
// the registry entries for all the domains under the "P3Sites" key
// It is not a good idea to invoke recursive delete on the P3Sites key because
// the running instance of the navigator will end up with an invalid handle
HRESULT
CIEFrameAuto::COpsProfile::_ClearAllSettings(HWND hwnd)
{
    DWORD   dwAction;
    DWORD   dwError;
    HKEY    hP3Sites;

    dwError = RegCreateKeyEx(HKEY_CURRENT_USER,  rgszP3Sites, 0, NULL, REG_OPTION_NON_VOLATILE,
                            KEY_READ | DELETE, NULL, &hP3Sites, &dwAction);

    DWORD dwIndex = 0;
    DWORD dwcbVal;
    TCHAR rgchName[MAX_PATH];
    HDPA  hdpaKeys = DPA_Create(0);

    do
    {
        dwcbVal = ARRAYSIZE(rgchName);
        dwError = RegEnumKeyEx(hP3Sites, dwIndex, rgchName, &dwcbVal, NULL, NULL, NULL, NULL);
        if (dwError==ERROR_SUCCESS)
        {
            int cchSiteName = MAX_PATH;
            LPTSTR  pszSiteName = new TCHAR[cchSiteName];
            if (pszSiteName)
            {
                StrCpyN(pszSiteName, rgchName, cchSiteName);
                DPA_AppendPtr(hdpaKeys, pszSiteName);
            }
        }
        dwIndex++;
    }
    while (dwError==ERROR_SUCCESS);

    for (int i=0; i<DPA_GetPtrCount(hdpaKeys); i++)
    {
        LPTSTR  pszSiteName = (LPTSTR) DPA_FastGetPtr(hdpaKeys, i);
        SHDeleteKey(hP3Sites, pszSiteName);
        delete pszSiteName;
    }

    DPA_Destroy(hdpaKeys);
    hdpaKeys = NULL;

    return S_OK;
}

BOOL
CIEFrameAuto::COpsProfile::_DifferentURL()
{
    BSTR    bstrCurrentURL  = NULL;
    HRESULT hr = _pAuto->get_LocationURL(&bstrCurrentURL);
    BOOL    fDifferent = (m_bstrLastURL!=NULL) && StrCmpW(bstrCurrentURL, m_bstrLastURL);

    SysFreeString(bstrCurrentURL);
    return fDifferent;
}

STDAPI ResetProfileSharing(HWND hwin)
{
    return CIEFrameAuto::COpsProfile::_ClearAllSettings(hwin);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\packager.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       packager.hxx
//
//  Contents:   Save as Office9 'Thicket' format implementation classes.
//
//----------------------------------------------------------------------------

#ifndef _PACKAGER_HXX_
#define _PACKAGER_HXX_

#define MAX_SAVING_STATUS_TEXT                128
#define MAX_BUFFER_LEN                        512
#define REGPATH_MSIE_MAIN                     TEXT("Software\\Microsoft\\Internet Explorer\\Main")
#define REGVALUE_DOWNLOAD_IMAGES              "Display Inline Images"
#define URL_ABOUT_BLANK                       TEXT("about:blank")

class CWebArchive;

class CThicketProgress
{
public:
    CThicketProgress( HWND hDlg );
    ~CThicketProgress(void);

    void SetPercent( ULONG ulPct );
    void SetSaving( LPCTSTR szFile, LPCTSTR szDst );
    void SetSaveText(LPCTSTR szText);

protected:
    HWND    m_hDlg;
    HWND    m_hwndProg;
    TCHAR*  m_pszSavingFmt;
    int     m_cchSavingFmt;
    TCHAR*  m_pszPctFmt;
    ULONG   m_ulPct;
};

/*
 *  CDocumentPackager - master packager class.
 */

// Packaging styles. 
// NOTE: These need to match the order in the format filter string.
enum {
    PACKAGE_THICKET = 1,
    PACKAGE_MHTML,
    PACKAGE_HTML,
    PACKAGE_TEXT
};

class CDocumentPackager
{
public:
    CDocumentPackager(UINT iPackageStyle) {  m_iPackageStyle = iPackageStyle;
                                             m_ptp = NULL; }
    ~CDocumentPackager(void) {}

    HRESULT PackageDocument(IHTMLDocument2 *pDoc, LPCTSTR lpstrDoc,
                            BOOL *pfCancel, CThicketProgress *ptprog,
                            ULONG progLow, ULONG progHigh,
                            UINT cpDst,
                            CWebArchive *pwa = NULL );

    CWebArchive *GetFrameDocArchive( CWebArchive *pwaSrc );

protected:
    friend class CFramesPackager;

    UINT    m_iPackageStyle;

    HRESULT _PackageDocument(IHTMLDocument2 *pDoc, LPCTSTR lpstrDoc,
                             BOOL *pfCancel, CThicketProgress *ptprog,
                             ULONG progLow, ULONG progHigh,
                             UINT cpDst,
                             CWebArchive *pwa,
                             CDocumentPackager *pdpFrames,
                             BOOL fFrameDoc);

    HRESULT _GetDesignDoc( IHTMLDocument2 *pDocSrc, IHTMLDocument2 **ppDocDesign, 
                           BOOL *pfCancel, CThicketProgress *ptp, UINT cp );
private:
    CThicketProgress                 *m_ptp;
};


#endif // _PACKAGER_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\shdocvw\packager.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994
//
//  File:       persist.cxx
//
//  Contents:   Implmentation of Office9 Thicket Save API
//
//----------------------------------------------------------------------------


#include "priv.h"
#include <mshtml.h>
#include <winineti.h>
#include <mlang.h>
// fake out mimeole.h's dll linkage directives for our delay load stuff in dllload.c
#define _MIMEOLE_
#define DEFINE_STRCONST
#include <mimeole.h>
#include "resource.h"
#include "packager.h"
#include "reload.h"

#include <mluisupp.h>


#define DEFINE_STRING_CONSTANTS
#pragma warning( disable : 4207 ) 
#include "htmlstr.h"
#pragma warning( default : 4207 )

const GUID CLSID_IMimeInternational =
{0xfd853cd9, 0x7f86, 0x11d0, {0x82, 0x52, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4}};

const GUID IID_IMimeInternational =
{0xc5588349, 0x7f86, 0x11d0, {0x82, 0x52, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4}};

const GUID IID_IMimeBody =
{0xc558834c, 0x7f86, 0x11d0, {0x82, 0x52, 0x0, 0xc0, 0x4f, 0xd8, 0x5a, 0xb4}};

// Trident legacy defines...

#define RRETURN(hr) return hr;
#define ReleaseInterface(punk) { if (punk) punk->Release(); punk = NULL; }

// Local prototypes

void RemoveBookMark(WCHAR *pwzURL, WCHAR **ppwzBookMark);
void RestoreBookMark(WCHAR *pwzBookMark);

HRESULT HrSetMember(LPUNKNOWN pUnk, BSTR bstrMember, BSTR bstrValue);
HRESULT HrGetCollectionItem(IHTMLElementCollection *pCollect, ULONG uIndex, REFIID riid, LPVOID *ppvObj);
ULONG UlGetCollectionCount(IHTMLElementCollection *pCollect);
HRESULT HrBSTRToLPSZ(BSTR bstr, LPSTR *lplpsz);
HRESULT HrGetCombinedURL( IHTMLElementCollection *pCollBase,
                          LONG cBase,
                          LONG lElemPos,
                          BSTR bstrRelURL,
                          BSTR bstrDocURL,
                          BSTR *pbstrBaseURL);

class CHashEntry {
public:
    CHashEntry(void) : m_bstrKey(NULL), m_bstrValue(NULL), m_pheNext(NULL) {};
    ~CHashEntry(void)
    {
        if (m_bstrKey)
            SysFreeString(m_bstrKey);
        if (m_bstrValue)
            SysFreeString(m_bstrValue);
    }

    BOOL SetKey(BSTR bstrKey)
    {
        ASSERT(m_bstrKey==NULL);
        m_bstrKey = SysAllocString(bstrKey);
        return m_bstrKey != NULL;
    }

    BOOL SetValue(BSTR bstrValue)
    {
        ASSERT(m_bstrValue==NULL || !StrCmpIW(m_bstrValue, c_bstr_BLANK) ||
               !StrCmpIW(m_bstrValue, bstrValue));
        m_bstrValue = SysAllocString(bstrValue);
        return m_bstrValue != NULL;
    }

    BSTR       m_bstrKey;
    BSTR       m_bstrValue;
    CHashEntry  *m_pheNext;        
};


class CWebArchive
{
public:

    CWebArchive(CThicketProgress* ptp=NULL);
    ~CWebArchive(void);

    virtual HRESULT Init( LPCTSTR lpstrDoc, DWORD dwHashSize );

    virtual HRESULT AddURL( BSTR bstrURL, CHashEntry **pphe ) = 0;
    virtual HRESULT AddFrameOrStyleEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrFrameDoc ) = 0;
    virtual HRESULT Find(BSTR bstrF, CHashEntry **pphe);

    virtual HRESULT Commit(void);
    virtual HRESULT Revert(void);

    virtual HRESULT ArchiveDocumentText(IHTMLDocument2 *pDoc, UINT cpDoc, BOOL fFrameDoc) = 0;
    virtual HRESULT ArchiveCSSText( BSTR bstrCSSUrl, LPCSTR lpszSSText, LPCTSTR lpszStyleDoc ) = 0;

protected:

    LPTSTR m_lpstrDoc;          // Desintation file for thicket document  
    LPTSTR m_lpstrSafeDoc;      // Temp name of original file, which we delete on Commit()

    CThicketProgress*   m_ptp;

    enum ThURLType {
        thurlMisc,
        thurlHttp,
        thurlFile
    };

    ThURLType _GetURLType( BSTR bstrURL );

    HRESULT _BackupOldFile(void);

    // hash table stuff stolen from MIMEEDIT
    HRESULT _Insert(BSTR bstrI, BSTR bstrThicket, CHashEntry **pphe);
    inline DWORD Hash(LPWSTR psz);

    DWORD       m_cBins;
    CHashEntry  *m_rgBins;
};


class CThicketArchive : public CWebArchive
{
public:

    CThicketArchive(CThicketProgress* ptp=NULL);
    ~CThicketArchive(void);

    virtual HRESULT Init( LPCTSTR lpstrDoc, DWORD dwHashSize );

    virtual HRESULT AddURL( BSTR bstrURL, CHashEntry **pphe );
    virtual HRESULT AddFrameOrStyleEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrFrameDoc );

    virtual HRESULT Commit(void);
    virtual HRESULT Revert(void);

    virtual HRESULT ArchiveDocumentText(IHTMLDocument2 *pDoc, UINT cpDoc, BOOL fFrameDoc);
    virtual HRESULT ArchiveCSSText( BSTR bstrCSSUrl, LPCSTR lpszSSText, LPCTSTR lpszStyleDoc );

protected:

    LPTSTR m_lpstrFilesDir;     // directory for document's supporting files.
    LPTSTR m_lpstrFilesDirName; // suffix of m_lpstrFilesDir
    LPTSTR m_lpstrSafeDir;      // Temp name of original files directory, which we delete on Commit()
    BOOL   m_fFilesDir;         // TRUE if m_lpstrFilesDir has been created.


    HRESULT _ApplyMarkOfTheWeb( IHTMLDocument2 *pDoc, LPSTREAM pstm, BOOL fUnicode );

    HRESULT _AddHttpEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrDstFile, LPTSTR lpstrSrcFile=NULL );
    HRESULT _AddFileEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrDstFile, LPTSTR lpstrSrcFile=NULL );
    HRESULT _AddMiscEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrDstFile, int cchDstFile );

    HRESULT _PersistHttpURL( BSTR bstrURL, CHashEntry **pphe );
    HRESULT _PersistFileURL( BSTR bstrURL, CHashEntry **pphe );
    HRESULT _PersistMiscURL( BSTR bstrURL, CHashEntry **pphe );

    HRESULT _BackupOldDirectory(void);
    HRESULT _RemoveOldDirectoryAndChildren( LPCWSTR pszDir );

    HRESULT _Insert(BSTR bstrI, LPTSTR lpszFile, int cchFile, CHashEntry **pphe);
};

class CMHTMLArchive : public CWebArchive
{
public:

    CMHTMLArchive(CThicketProgress* ptp=NULL);
    ~CMHTMLArchive(void);

    virtual HRESULT Init( LPCTSTR lpstrDoc, DWORD dwHashSize );

    virtual HRESULT AddURL( BSTR bstrURL, CHashEntry **pphe );
    virtual HRESULT AddFrameOrStyleEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrFrameDoc );

    virtual HRESULT ArchiveDocumentText(IHTMLDocument2 *pDoc, UINT cpDoc, BOOL fFrameDoc);
    virtual HRESULT ArchiveCSSText( BSTR bstrCSSUrl, LPCSTR lpszSSText, LPCTSTR lpszStyleDoc );

    virtual HRESULT SetCharset(UINT uiCharset, CSETAPPLYTYPE csat, IMimeBody *pBody);

protected:

    HBODY m_hBodyAlt;
    IMimeMessage *m_pimm;
};

/*
 * The following classes implement extended Save As MTHML functionality.
 * Access to the extended functionality is controlled by new MECD_ flags
 * defined in mimeole.h. Clients of the C API in this module should notice
 * mimimal change in its behavior. ( limited to the additional inclusion
 * table and table cell background images ).
 *
 * The root idea is that of a collection packager, which takes a subset
 * of the document.all collection, filters the elements of that subcollection,
 * and marshall's the element data into the MIMEOle document This is patterned
 * after the existing PackageImageData routine, and relies heavily on
 * HrAddImageToMessage, which is much more general than its name implies.
 *
 *
 * Stylesheets introduce some repetition, as the stylesheet OM is similar,
 * but not similar enough, to support common base classes specialized via
 * templates.
 *
 * The process of adding new packagers is pretty straight-forward.
 * [1]  (a) if the packaged attribute is a complete URL, derive from CCollectionPackager
 *      (b) if the attribute is a relative URL, derive from CRelativeURLPackager
 * [2] Implement InitFromCollection. Have it call _InitSubCollection() with the tag name.
 *     See CImagePackager::InitFromCollection() as a simple example.
 * [3] Implement _GetTargetAttribute() to return the attribute you want to package.
 *     You may want to add the string constants for [2] and [3] to htmlstr.h
 * [4] Define an MECD_ control flag, if the thing you're packaging is new.
 * [5] Add a local var of your packager type to CDocumentPackager::PackageDocument.
 * [6] Follow the pattern of the other packagers in CDocumentPackager::PackageDocument
 *
 * For elements with multiple persisted attributes, it's dealer's choice as to how
 * to approach it. Write seperate, simpler packagers for each attribute or write
 * one packager that deals with all of the target element's attributes.
 */



/*
 *  CCollectionPackager - abstract base class for HTML element packagers.
 *      Implements subsampling from the all collection, iteration over the
 *  collection, and basic packaging functionality.
 *
 *      Derived classes must implement InitFromCollection and _GetTargetAttribute.
 *  InitFromCollection - derived class should store the desired subset of the
 *      input collection into the m_pColl data member. _InitSubCollection is
 *      a useful method for this purpose.
 *  _GetTargetAttribute - derived class should return a BSTR naming the attribute
 *      of the element to be packaged.
 *
 */
class CCollectionPackager
{
public:
    virtual ~CCollectionPackager(void);
    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL) = 0;
    virtual HRESULT PackageData(CWebArchive *pwa, BOOL *pfCancel = NULL,
                                CThicketProgress *ptp = NULL, ULONG progLow = 0, ULONG progHigh = 100)
    { 
        return _PackageData( pwa, m_pColl, pfCancel, ptp, progLow, progHigh );
    }

protected:

    CCollectionPackager(void) : m_pColl(NULL), m_fAddCntLoc(FALSE) {};

    HRESULT _InitSubCollection(IHTMLElementCollection *pAll,
                              BSTR bstrTagName,
                              IHTMLElementCollection **ppSub,
                              ULONG *pcElems = NULL);

    virtual BSTR _GetTargetAttribute(void) = 0;

    virtual HRESULT _GetElementURL(IHTMLElement *pElem, BSTR *pbstrURL);
    virtual HRESULT _PackageData(CWebArchive *pwa,
                                 IHTMLElementCollection *pColl,
                                 BOOL *pfCancel = NULL,
                                 CThicketProgress *ptp = NULL, ULONG progLow = 0, ULONG progHigh = 100);
    virtual HRESULT _PackageElement(CWebArchive *pwa,
                                    IHTMLElement *pElem);

    IHTMLElementCollection *m_pColl; 
    BOOL                    m_fAddCntLoc;
};

/*
 * CImagePackager - packages the src's of IMG tags.
 */
class CImagePackager : public CCollectionPackager
{
public:
    CImagePackager(void) {};
    virtual ~CImagePackager(void) {};
 
    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL);
protected:

    virtual BSTR _GetTargetAttribute(void);

};

/*
 * CInputImgPackager - packages INPUT type="image"
 */

class CInputImgPackager : public CImagePackager
{
public:
    CInputImgPackager() {}
    virtual ~CInputImgPackager() {}

    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL);
    
};

/*
 * CBGSoundsPackager - packages background sounds
 */

class CBGSoundsPackager : public CCollectionPackager
{
    public:
        CBGSoundsPackager() {};
        virtual ~CBGSoundsPackager() {};

        virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                           ULONG *pcElems = NULL);
protected:

    virtual BSTR _GetTargetAttribute(void);

};
     
/*
 * CAnchorAdjustor - modifies anchor hrefs.
 *
 * Makes them absolute if they point out of the collection.
 */

class CAnchorAdjustor : public CCollectionPackager
{
public:
    CAnchorAdjustor(void) {};
    virtual ~CAnchorAdjustor(void) {};
 
    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL);
protected:

    virtual BSTR _GetTargetAttribute(void);
    virtual HRESULT _PackageElement(CWebArchive *pwa,
                                    IHTMLElement *pElem);
};

/*
 * CAreaAdjustor - modifies AREA hrefs.
 *
 * Makes them absolute if they point out of the collection. Same filter
 * as the anchor adjustor, but different tag.
 */

class CAreaAdjustor : public CAnchorAdjustor
{
public:
    CAreaAdjustor(void) {};
    virtual ~CAreaAdjustor(void) {};
 
    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL);
};

/*
 * CBaseNeutralizer - resets any and all <BASE> tags to the d.
 *
 * No actual packaging goes on here, but we do remap the 
 * <BASE> href.
 */

class CBaseNeutralizer : public CCollectionPackager
{
public:
    CBaseNeutralizer(void) : m_bstrLocal(NULL), m_pTree(NULL) {};
    virtual ~CBaseNeutralizer(void);

    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL )
        { return InitFromCollection( pColl, pcElems, NULL ); };
    HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL,
                                       IHTMLDocument2 *pDoc = NULL);
    virtual HRESULT PackageData(CWebArchive *pwa, BOOL *pfCancel = NULL,
                                CThicketProgress *ptp = NULL, ULONG progLow = 0, ULONG progHigh = 100);

protected:

    virtual BSTR _GetTargetAttribute(void);
    virtual HRESULT _PackageElement(CWebArchive *pwa,
                                    IHTMLElement *pElem);

    BSTR m_bstrLocal;
    IMarkupServices *m_pTree;
};

/*
 *  CRelativeURLPackager - abstract base class for packagers
 *      whose element's source attribute returns a relative URL.
 *  This class implements triutils.pp's GetBackgroundImageUrl's
 *  process of attempting to combine the (relative) element URL
 *  with the nearest <BASE> URL. If no <BASE> is availaible, it
 *  uses the document URL.
 *
 *  This class is an abstract base because it does not implement
 *  _GetTargetAttribute. It's implementation of InitFromCollection
 *  isn't very useful and will probably be overridden by derived
 *  classes.
 */

class CRelativeURLPackager : public CCollectionPackager
{
public:
    CRelativeURLPackager(void) : m_pCollBase(NULL), m_cBase(0), m_bstrDocURL(NULL) {};
    virtual ~CRelativeURLPackager(void);
 
    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL)
    {
        return Init( pColl, pcElems, NULL );
    }

    virtual HRESULT Init(IHTMLElementCollection *pColl,
                         ULONG *pcElems,
                         IHTMLDocument2 *pDoc);

protected:

    virtual HRESULT _GetElementURL(IHTMLElement *pElem, BSTR *pbstrURL);

    IHTMLElementCollection  *m_pCollBase; // collection of BASE tags used to complete URLs
    ULONG                   m_cBase;
    BSTR                    m_bstrDocURL;
};

/*
 * CBackgroundPackager - packages the background of BODY, TABLE, TD, and TH.
 *
 * These three tags have a common target attribute.
 */

class CBackgroundPackager : public CRelativeURLPackager
{
public:
    CBackgroundPackager(void) {};
    ~CBackgroundPackager(void) {};
 
    virtual HRESULT PackageData(CWebArchive *pwa, BOOL *pfCancel,
                                CThicketProgress *ptp = NULL, ULONG progLow = 0, ULONG progHigh = 100);
protected:

    virtual BSTR _GetTargetAttribute(void);
};

/*
 * CDynSrcPackager - packages the dynsrc of IMG and INPUT.
 *
 * These two tags have a common target attribute.
 */

class CDynSrcPackager : public CRelativeURLPackager
{
public:
    CDynSrcPackager(void) {};
    ~CDynSrcPackager(void) {};
 
    virtual HRESULT PackageData(CWebArchive *pwa, BOOL *pfCancel,
                                CThicketProgress *ptp = NULL, ULONG progLow = 0, ULONG progHigh = 100);
protected:

    virtual BSTR _GetTargetAttribute(void);
};


/*
 * CScriptPackager - packages the dynsrc of IMG and INPUT.
 *
 * These two tags have a common target attribute.
 */

class CScriptPackager : public CRelativeURLPackager
{
public:
    CScriptPackager(void) : m_pCollScripts(NULL) {};
    ~CScriptPackager(void) { if (m_pCollScripts) m_pCollScripts->Release(); };
 
    virtual HRESULT PackageData(CWebArchive *pwa, BOOL *pfCancel = NULL,
                                CThicketProgress *ptp = NULL, ULONG progLow = 0, ULONG progHigh = 100)
    { 
        return _PackageData( pwa, m_pCollScripts, pfCancel, ptp, progLow, progHigh );
    }

    virtual HRESULT Init(IHTMLElementCollection *pColl,
                         ULONG *pcElems = NULL,
                         IHTMLDocument2 *pDoc = NULL);
protected:

    virtual BSTR _GetTargetAttribute(void);

    IHTMLElementCollection *m_pCollScripts;

};


/*
 * CFramesPackager - packages the <FRAME> and <IFRAME> sub-documents.
 *
 *  This process is recursive, so all nested frames will be packaged.
 */

class CFramesPackager : public CRelativeURLPackager
{
public:
    CFramesPackager(void) :
        m_pCollFrames(NULL),
        m_pframes2(NULL),
        m_cFrames(0),
        m_iFrameCur(0),
        m_pfCancel(0),
        m_ptp(NULL),
        m_uLow(0),
        m_uHigh(0),
        m_uRangeDoc(0) {};

        virtual ~CFramesPackager(void)
            { 
                if (m_pCollFrames) m_pCollFrames->Release();
                if (m_pframes2) m_pframes2->Release();
            };
 
    virtual HRESULT InitFromCollection(IHTMLElementCollection *pColl,
                                       ULONG *pcElems = NULL)
    {
        return CRelativeURLPackager::Init( pColl, pcElems, NULL );
    }

    virtual HRESULT Init(IHTMLElementCollection *pColl,
                         ULONG *pcElems,
                         IHTMLDocument2 *pDoc,
                         IHTMLDocument2 *pDocDesign,
                         CDocumentPackager *pdp);

    virtual HRESULT PackageData(CWebArchive *pwa, BOOL *pfCancel,
                                CThicketProgress *ptp = NULL, ULONG progLow = 0, ULONG progHigh = 100);

protected:

    virtual BSTR _GetTargetAttribute(void);
    virtual HRESULT _PackageElement(CWebArchive *pwa,
                                    IHTMLElement *pElem);

    IHTMLElementCollection *m_pCollFrames;
    IHTMLFramesCollection2 *m_pframes2;
    ULONG   m_cFrames;
    ULONG   m_iFrameCur;
    BOOL    *m_pfCancel;
    CThicketProgress*    m_ptp;
    ULONG   m_uLow;
    ULONG   m_uHigh;
    ULONG   m_uRangeDoc;
    CDocumentPackager *m_pdp;
};

/*
 * CSSPackager - packages imported stylesheets.
 *
 *  Stylesheets have a different OM than document elements, so
 *  we have a packager that looks similar, but works differently
 *  than the other element packagers.
 *
 *  We derive from CRelativeURLPackager for the convenience of 
 *  its Init method and <BASE> collection functionality, which
 *  we also need because the hrefs in style sheets can be relative.
 *
 *  Since we aren't actually packaging elments, the _GetTargetAttribute()
 *  implementation is a formality to satisfy the abstract base class.
 */

class CSSPackager : public CRelativeURLPackager
{
public:
    CSSPackager(void) : m_pDoc(NULL) {};
    ~CSSPackager(void) {};

    HRESULT Init( IHTMLElementCollection *pColl,
                         ULONG *pcElems = NULL,
                         IHTMLDocument2 *pDoc = NULL);

    HRESULT PackageStyleSheets(IHTMLDocument2 *pDoc2, CWebArchive *pwa);

protected:

    BSTR _GetTargetAttribute(void) { ASSERT(FALSE); return NULL; };

    HRESULT _PackageSSCollection(IHTMLStyleSheetsCollection *pssc,
                                         CWebArchive *pwa);
    HRESULT _PackageSS(IHTMLStyleSheet *pss, CWebArchive *pwa);

    IHTMLDocument2 *m_pDoc;
};


// possible hash-table sizes, chosen from primes not close to powers of 2
static const DWORD s_rgPrimes[] = { 29, 53, 97, 193, 389, 769, 1543, 3079, 6151, 12289, 24593 };

/*
*  class implementation
*/

/*
*  CWebArchive ##################################################
*/

CWebArchive::CWebArchive(CThicketProgress *ptp)
{
    m_lpstrDoc = NULL;
    m_lpstrSafeDoc = NULL;
    
    m_cBins = 0;
    m_rgBins = NULL;

    m_ptp = ptp;
}


CWebArchive::~CWebArchive(void)
{
    CHashEntry *phe, *pheTemp;
    
    if (m_lpstrDoc != NULL)
    {
        LocalFree( m_lpstrDoc );
        m_lpstrDoc = NULL;
    }

    if (m_lpstrSafeDoc != NULL)
    {
        LocalFree( m_lpstrSafeDoc );
        m_lpstrSafeDoc = NULL;
    }
        
    // m_ptp is on loan to us, don't delete it
    
    for (DWORD dw = 0; dw < m_cBins; dw++)
    {
        if (m_rgBins[dw].m_pheNext)
        {
            phe = m_rgBins[dw].m_pheNext;
            while (phe)
            {
                pheTemp = phe;
                phe = phe->m_pheNext;
                delete pheTemp;
            }
        }
    }
    delete[] m_rgBins;
}


HRESULT
CWebArchive::Init( LPCTSTR lpstrDoc, DWORD dwHashSize )
{
    HRESULT hr = S_OK;
    int     i = 0;
    
    m_lpstrDoc = StrDup(lpstrDoc);

    // check for replacement of old file
    if (PathFileExists(m_lpstrDoc))
        hr = _BackupOldFile();
    if (FAILED(hr))
        goto error; 
    
    // Initialize the hash table.
    for (i = 0; i < (ARRAYSIZE(s_rgPrimes) - 1) && s_rgPrimes[i] < dwHashSize; i++);
    ASSERT(s_rgPrimes[i] >= dwHashSize || i == (ARRAYSIZE(s_rgPrimes)-1));
    m_cBins = s_rgPrimes[i];
    
    m_rgBins = new CHashEntry[m_cBins];
    if (m_rgBins==NULL)
        hr = E_OUTOFMEMORY;
    
error:
    
    RRETURN(hr);
}


HRESULT
CWebArchive::Commit()
{
    // clean up old version of file
    if (m_lpstrSafeDoc)
        DeleteFile(m_lpstrSafeDoc);

    return S_OK;
}

HRESULT
CWebArchive::Revert()
{
    if (m_lpstrSafeDoc)
    {
        // we used to use MoveFileEx with MOVEFILE_REPLACE_EXISTING, but MoveFileEx
        // doesn't work on Win9x... so we have to DeleteFile/MoveFile instead...

        DeleteFile(m_lpstrDoc);
        BOOL fMoved = MoveFile(m_lpstrSafeDoc, m_lpstrDoc);

        if (!fMoved)
        {
            ASSERT(FALSE);
            // We shouldn't get into this situtation because we've pre-checked that
            // the original file is not read-only.
            DeleteFile(m_lpstrSafeDoc);
        }
    }

   return S_OK;
}

CWebArchive::ThURLType
CWebArchive::_GetURLType( BSTR bstrURL )
{
//    _tcsncmpi(bstrURL, 4, _T("http",4)
    if ( bstrURL[0] == TEXT('h') &&
         bstrURL[1] == TEXT('t') &&
         bstrURL[2] == TEXT('t') &&
         bstrURL[3] == TEXT('p') )
        return thurlHttp;
    else if ( bstrURL[0] == TEXT('f') &&
              bstrURL[1] == TEXT('i') &&
              bstrURL[2] == TEXT('l') &&
              bstrURL[3] == TEXT('e') )
        return thurlFile;
    else
        return thurlMisc;
}



HRESULT
CWebArchive::_Insert(BSTR bstrI, BSTR bstrThicket, CHashEntry **pphe )
{
    HRESULT hr = S_OK;

    CHashEntry *phe = &m_rgBins[Hash(bstrI)];
    
    ASSERT(pphe != NULL);

    *pphe = NULL;

 
    if (phe->m_bstrKey)
    {        
        CHashEntry *pheNew = new CHashEntry;
        
        if (pheNew==NULL)
            return E_OUTOFMEMORY;

        if (pheNew->SetKey(bstrI) && pheNew->SetValue(bstrThicket))
            *pphe = pheNew;
        else
        {
            delete pheNew;
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pheNew->m_pheNext = phe->m_pheNext;
        phe->m_pheNext = pheNew;
        phe = pheNew;
    } 
    else if (phe->SetKey(bstrI) && phe->SetValue(bstrThicket))
        *pphe = phe;
    else
        hr = E_OUTOFMEMORY;
        
Cleanup:

    return hr;
}

HRESULT
CWebArchive::Find(BSTR bstrF, CHashEntry **pphe)
{
    CHashEntry *phe = &m_rgBins[Hash(bstrF)];

    if (!pphe)
        return E_POINTER;

    *pphe = NULL;

    if (phe->m_bstrKey)
    {
        do
        {
            if (!StrCmpW(phe->m_bstrKey, bstrF))
            {
                ASSERT(phe->m_bstrValue!=NULL);
                *pphe = phe;
                return NOERROR;
            }
            phe = phe->m_pheNext;
        }
        while (phe);
    }
    return E_INVALIDARG;
}


DWORD
CWebArchive::Hash(BSTR bstr)
{
    DWORD h = 0;
    WCHAR *pwch = bstr;
    
    while (*pwch)
        h = ((h << 4) + *pwch++ + (h >> 28));
    return (h % m_cBins);
}

HRESULT
CWebArchive::_BackupOldFile()
{
    HRESULT hr = S_OK;
    TCHAR   chT;
    LPTSTR  lpstrT;
    TCHAR   szT[MAX_PATH];
    DWORD   dwAttrib = GetFileAttributes(m_lpstrDoc);

    if (dwAttrib & FILE_ATTRIBUTE_READONLY)
        return E_ACCESSDENIED;

    lpstrT = PathFindFileName(m_lpstrDoc);
    ASSERT(lpstrT);

    lpstrT--; // back up to the slash
    chT = *lpstrT;
    *lpstrT = 0;
    if (GetTempFileName( m_lpstrDoc, &lpstrT[1], 0,szT ))
    {
        *lpstrT = chT;
        if (CopyFile(m_lpstrDoc, szT, FALSE))
        {
            int cchSafeDoc = lstrlen(szT) + 1;
            m_lpstrSafeDoc = (LPTSTR)LocalAlloc( LMEM_FIXED, sizeof(TCHAR) * cchSafeDoc);
            if (m_lpstrSafeDoc)
                StringCchCopy(m_lpstrSafeDoc, cchSafeDoc, szT);
            else
            {
                hr = E_OUTOFMEMORY;
                DeleteFile(szT);
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto error;
        }
    }
    else
    {

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto error;
    }

error:
    *lpstrT = chT;
    RRETURN(hr);
}

/*
*  CThicketArchive ##################################################
*/

CThicketArchive::CThicketArchive(CThicketProgress *ptp) : CWebArchive(ptp)
{
    m_lpstrFilesDir = NULL;
    m_lpstrFilesDirName = NULL;
    m_lpstrSafeDir = NULL;
    m_fFilesDir = FALSE;   // TRUE when m_lpstrFilesDir has been created
}


CThicketArchive::~CThicketArchive(void)
{    
    if (m_lpstrFilesDir != NULL)
    {
        LocalFree( m_lpstrFilesDir );
        m_lpstrFilesDir = NULL;
    }

    if (m_lpstrSafeDir != NULL)
    {
        LocalFree( m_lpstrSafeDir );
        m_lpstrSafeDir = NULL;
    }
    
    // m_lpstrFilesDirName points into m_lpstrFilesDir
}


HRESULT
CThicketArchive::Init( LPCTSTR lpstrDoc, DWORD dwHashSize )
{
    HRESULT hr = CWebArchive::Init( lpstrDoc, dwHashSize );
    int     i = 0;
    TCHAR   chT;
    LPTSTR  lpstrT;
    TCHAR   szFmt[MAX_PATH];
    int     cch;
    
    if (FAILED(hr))
        goto error;  
    
    // Build the path to the directory for stored files, like 'Document1 files'.
    lpstrT = PathFindExtension(m_lpstrDoc);
    chT = *lpstrT;
    *lpstrT = 0;
    MLLoadString(IDS_THICKETDIRFMT, szFmt, ARRAYSIZE(szFmt));
    cch = lstrlen(m_lpstrDoc) + lstrlen(szFmt) + 1;
    m_lpstrFilesDir = (LPTSTR)LocalAlloc( LMEM_FIXED, sizeof(TCHAR) * cch );
    if (m_lpstrFilesDir==NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    StringCchCopy( m_lpstrFilesDir, cch, m_lpstrDoc);
    StringCchCat( m_lpstrFilesDir, cch, szFmt);

    *lpstrT = chT;  

    // make m_lpstrFilesDirName point to the last component of m_lpstrFilesDir
    for ( i = lstrlen(m_lpstrFilesDir) - 1; i > 0 && m_lpstrFilesDirName == NULL; i-- )
    {
        if ( m_lpstrFilesDir[i-1] == FILENAME_SEPARATOR )
            m_lpstrFilesDirName = &m_lpstrFilesDir[i];
    }

    // check to see if the files dir already exists. If it does, rename the original.
    if (PathFileExists(m_lpstrFilesDir))
        hr = _BackupOldDirectory();
    if (FAILED(hr))
        goto error;
    
error:
    
    RRETURN(hr);
}


HRESULT
CThicketArchive::AddURL( BSTR bstrURL, CHashEntry **pphe )
{
    HRESULT hr;
    
    hr = THR(Find(bstrURL, pphe));
    
    if (FAILED(hr))
    {
        // first, lets put our document dir in place, if it isn't already
        if (!m_fFilesDir)
            m_fFilesDir = (SHCreateDirectory(NULL, m_lpstrFilesDir) == ERROR_SUCCESS);
        
        if (m_fFilesDir)
        {
            switch (_GetURLType(bstrURL))
            {
            case thurlMisc:
                hr = _PersistMiscURL(bstrURL, pphe);
                break;

            case thurlHttp:
                hr = _PersistHttpURL(bstrURL, pphe);
                break;

            case thurlFile:
                hr = _PersistFileURL(bstrURL, pphe);
                break;
            }
        }
        else
            hr = E_FAIL;
    }
    
    RRETURN(hr);
}

HRESULT
CThicketArchive::AddFrameOrStyleEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrFrameDoc )
{
    HRESULT hr;
    
    hr = THR(Find(bstrURL, pphe)); // there's always a slim chance we're reusing a frame.
    
    if (FAILED(hr))
    {
        // first, lets put our document dir in place, if it isn't already
        if (!m_fFilesDir)
            m_fFilesDir = (SHCreateDirectory(NULL, m_lpstrFilesDir) == ERROR_SUCCESS);
        
        if (m_fFilesDir)
        {
            switch (_GetURLType(bstrURL))
            {
            case thurlMisc:
                //hr = _AddMiscEntry(bstrURL, pphe, lpstrFrameDoc);
                // It would be nice if we could just _AddMiscEntry, but if set a frame src
                // to one of the temp files that this produces, we get a 'Do you want to open'
                // prompt, so instead, we'll just keep this funky protocol URL.
                hr = CWebArchive::_Insert( bstrURL, bstrURL, pphe );
                lpstrFrameDoc[0] = 0; // shouldn't be used, anyway
                hr = S_FALSE;         // I told him we all-reddy got one! <snicker>
                break;

            case thurlHttp:
                hr = _AddHttpEntry(bstrURL, pphe, lpstrFrameDoc);
                break;

            case thurlFile:
                hr = _AddFileEntry(bstrURL, pphe, lpstrFrameDoc);
                break;
            }

            if (m_ptp)
                m_ptp->SetSaving( PathFindFileName(lpstrFrameDoc), m_lpstrFilesDir );

        }
        else
        {
            hr = (GetLastError() == ERROR_DISK_FULL) ? (HRESULT_FROM_WIN32(ERROR_DISK_FULL))
                                                     : (E_FAIL);
        }
    }
    else
    {
        LPTSTR lpszThicket;
        lpszThicket = (*pphe)->m_bstrValue;
        PathCombine( lpstrFrameDoc, m_lpstrFilesDir, lpszThicket );
        hr = S_FALSE;
    }
    
    return hr; // no RRETURN - may return S_FALSE
}

HRESULT
CThicketArchive::Commit()
{
    CWebArchive::Commit();

    // clean up obsolete files dir.
    if (m_lpstrSafeDir)
    {
        _RemoveOldDirectoryAndChildren(m_lpstrSafeDir);
    }

    return S_OK;
}

HRESULT
CThicketArchive::Revert()
{
    // clean up file dir

    _RemoveOldDirectoryAndChildren(m_lpstrFilesDir);

    // restore old files dir.
    if (m_lpstrSafeDir)
        MoveFile(m_lpstrSafeDir,m_lpstrFilesDir);
    
    return CWebArchive::Revert();;
}

HRESULT CThicketArchive::ArchiveDocumentText(IHTMLDocument2 *pDoc, UINT cpDoc, BOOL fFrameDoc)
{
    HRESULT             hr = S_OK;
    IPersistStreamInit* ppsi = NULL;
    IStream*            pstm = NULL;

    hr = SHCreateStreamOnFile(m_lpstrDoc, STGM_WRITE | STGM_CREATE, &pstm);
    if (SUCCEEDED(hr))
    {
        hr = pDoc->QueryInterface(IID_IPersistStreamInit, (void**)&ppsi);
        if (SUCCEEDED(hr))
        {          
            hr = _ApplyMarkOfTheWeb( pDoc, pstm, cpDoc == CP_UNICODE );

            if ( SUCCEEDED(hr) )
                hr = ppsi->Save(pstm, FALSE);
        }
    }
   
    ReleaseInterface(ppsi);
    ReleaseInterface(pstm);
    
    RRETURN(hr);
}

HRESULT CThicketArchive::ArchiveCSSText( BSTR bstrCSSUrl, LPCSTR lpszSSText, LPCTSTR lpszStyleDoc )
{
    HRESULT hr = S_OK;
    HANDLE  hfile;

    hfile = CreateFile( lpszStyleDoc, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                        CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hfile!=INVALID_HANDLE_VALUE) 
    {
        ULONG   cbWrite, cbWritten;

        cbWrite = lstrlenA(lpszSSText);
        if (!WriteFile( hfile, lpszSSText, cbWrite, &cbWritten, NULL ))
             hr = HRESULT_FROM_WIN32(GetLastError());

        CloseHandle(hfile);
    }
    else
        hr = HRESULT_FROM_WIN32(hr);

    return hr;
}

EXTERN_C HRESULT GetMarkOfTheWeb( LPCSTR, LPCSTR, DWORD, LPSTR *);

HRESULT CThicketArchive::_ApplyMarkOfTheWeb( IHTMLDocument2 *pDoc, LPSTREAM pstm, BOOL fUnicode )
{
    HRESULT hr;
    IInternetSecurityManager *pism = NULL;
    DWORD   dwZone;
    BSTR    bstrURL = NULL;

    hr = pDoc->get_URL( &bstrURL );
    if (FAILED(hr))
        return hr;

    // We only want to mark the document if it isn't already coming from the local
    // file system. If  ( minus the mark ) the file is in the local machine zone,
    // then it was made here, saved with a mark, or created outside our control.
    // If it was saved with a mark, then we want to leave that in place, rather
    // than mark it with the local copy's file: URL.

    hr = CoInternetCreateSecurityManager( NULL, &pism, 0 );
    if (SUCCEEDED(hr) && 
        SUCCEEDED(pism->MapUrlToZone( bstrURL, &dwZone, MUTZ_NOSAVEDFILECHECK)) &&
        dwZone != URLZONE_LOCAL_MACHINE )
    {
        LPSTR   pszMark;
        DWORD   cchURL = WideCharToMultiByte(CP_ACP, 0, bstrURL, -1, NULL, 0, NULL, NULL);
        LPSTR   pszURL = new CHAR[cchURL];

        if (pszURL)
        {
            if (WideCharToMultiByte(CP_ACP, 0, bstrURL, -1, pszURL, cchURL, NULL, NULL))
            {
                int   cch = lstrlen(m_lpstrDoc) + 1;
                LPSTR psz = new char[cch];

                if (psz)
                {
                    SHUnicodeToAnsi(m_lpstrDoc, psz, cch);
                    
                    hr = GetMarkOfTheWeb( pszURL, psz, 0, &pszMark);

                    delete [] psz;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }


                IMarkupServices              *pims = NULL;
                IMarkupPointer               *pimp = NULL;
                IMarkupContainer             *pimc = NULL;
                IHTMLElement                 *pihe = NULL;
                IHTMLElement                 *piheBody = NULL;
                IDispatch                    *pidDocument = NULL;
                IHTMLCommentElement          *pihce = NULL;
                LPWSTR                        pwszMark = NULL;
                BSTR                          bstrMark = NULL;

                hr = pDoc->QueryInterface(IID_IMarkupServices, (void **)&pims);

                if (SUCCEEDED(hr)) {
                    hr = pims->CreateElement(TAGID_COMMENT, NULL, &pihe);

                    if (SUCCEEDED(hr)) {
                        hr = pihe->QueryInterface(IID_IHTMLCommentElement, (void **)&pihce);
                    }

                    if (SUCCEEDED(hr)) {
                        int cbWrite = 0;
                        int cchMark = MultiByteToWideChar(CP_ACP, 0, pszMark, -1, NULL, 0);

                        // cchMark includes the null terminator.
                    
                        pwszMark = new WCHAR[cchMark];
                        if ( pwszMark != NULL )
                        {
                            MultiByteToWideChar( CP_ACP, 0, pszMark, -1, pwszMark, cchMark);
                            cbWrite = (cchMark - 1) * sizeof(WCHAR);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }

                        if (SUCCEEDED(hr))
                        {
                            // force <!-- ... --> style comment
                            hr = pihce->put_atomic(1);
                        }

                    }

                    if (SUCCEEDED(hr)) {
                        bstrMark = SysAllocString(pwszMark);
                        if (NULL != bstrMark)
                        {
                            hr = pihce->put_text(bstrMark);
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;
                        }
                        
                    }

                    if (SUCCEEDED(hr)) {
                        hr = pims->CreateMarkupPointer(&pimp);
                    }

                    if (SUCCEEDED(hr)) {
                        hr = pDoc->get_body(&piheBody);
                    }

                    if (SUCCEEDED(hr)) {
                        hr = piheBody->get_document(&pidDocument);
                    }

                    if (SUCCEEDED(hr)) {
                        hr = pidDocument->QueryInterface(IID_IMarkupContainer, (void **)&pimc);
                    }

                    if (SUCCEEDED(hr)) {
                        // Move to beginning of doc and insert it
                        hr = pimp->MoveToContainer(pimc, TRUE);

                        if (SUCCEEDED(hr)) {
                            hr = pims->InsertElement(pihe, pimp, pimp);
                        }
                    }
                }

                SAFERELEASE(pims);
                SAFERELEASE(pimc);
                SAFERELEASE(pihe);
                SAFERELEASE(pimp);
                SAFERELEASE(piheBody);
                SAFERELEASE(pidDocument);
                SAFERELEASE(pihce);

                if (bstrMark)
                {
                    SysFreeString(bstrMark);
                }

                if (pwszMark)
                {
                    delete[] pwszMark;
                }
            }
            else
                 hr = HRESULT_FROM_WIN32(GetLastError());

            delete[] pszURL;
        }
        else
            hr = E_OUTOFMEMORY;
    }



    ReleaseInterface(pism);
    if (bstrURL)
        SysFreeString(bstrURL);

    return hr;
}

HRESULT
CThicketArchive::_AddHttpEntry( BSTR bstrURL, CHashEntry **pphe, LPTSTR lpstrDstFile, LPTSTR lpstrSrcFile )
{
    HRESULT hr;
    TCHAR   szCacheFile[MAX_PATH];
    LPTSTR  lpszDst;
    LPTSTR  lpszFile;
    int     cchFile;
    LPTSTR  lpszURL;

    lpszURL = bstrURL;

    hr = URLDownloadToCacheFile(NULL, lpszURL, szCacheFile,
                                ARRAYSIZE(szCacheFile), BINDF_FWD_BACK,
                                NULL);
    if (FAILED(hr))
        goto Cleanup;

    if (lpstrSrcFile)
        StringCchCopy(lpstrSrcFile, MAX_PATH, szCacheFile);

    PathUndecorate( szCacheFile );

    lpszFile = PathFindFileName( szCacheFile );
    ASSERT(lpszFile != NULL);

    cchFile = ARRAYSIZE(szCacheFile) - (int)(lpszFile-szCacheFile);

    hr = _Insert( bstrURL, lpszFile, cchFile, pphe ); 

    lpszDst = PathCombine( lpstrDstFile, m_lpstrFilesDir, lpszFile );
    ASSERT( lpszDst );

Cleanup:

    RRETURN(hr);
}


HRESULT
CThicketArchive::_AddFi