 flag
    //
    DWORD dwValue = g_dwIsolatedFlag;
    MDRecord.dwMDIdentifier = MD_APP_ISOLATED;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_WAM;
    MDRecord.dwMDDataType = DWORD_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = sizeof(DWORD);
    MDRecord.pbMDData = (PBYTE)&dwValue;

    hr = g_pIMSAdminBase->SetData(
							metaHandle,
							g_wcsFullPath,
							&MDRecord
							);    

    if (FAILED(hr))
    {
        DebugLogMsg(eError, L"The isolated flag could not be set. IMSAdminBase::SetData() failed. hr = 0x%x", hr);       
        throw bad_hresult(hr);
    }

    DebugLogMsg(eInfo, L"The isolated flag was set.");  
}


static void SetExtensionPhysicalPath(METADATA_HANDLE metaHandle)
/*++
Routine Description:
	Set Extension Physical Path (MD_VR_PATH) property.

Arguments:
	metaHandle - handle to metadata

--*/
{     
    //
    // set physical path
    //

    METADATA_RECORD MDRecord; 

    MDRecord.dwMDIdentifier = MD_VR_PATH;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_FILE;
    MDRecord.dwMDDataType = STRING_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = numeric_cast<DWORD>(sizeof(WCHAR) * (g_MsmqWebDir.length() +1));
    MDRecord.pbMDData = (UCHAR*)(g_MsmqWebDir.c_str());

    HRESULT hr = g_pIMSAdminBase->SetData(
									metaHandle,
									g_wcsFullPath,
									&MDRecord
									);    
    if (FAILED(hr))
    {        
        DebugLogMsg(eError, L"The physical path to the IIS extension could not be set. IMSAdminBase::SetData() failed. hr = 0x%x", hr);
        throw bad_hresult(hr);
    }    

    DebugLogMsg(eInfo, L"The physical path to the IIS extension was set.");
}


static void SetExtentionKeyType(METADATA_HANDLE metaHandle)
{
	LPCWSTR KeyType = L"IIsWebVirtualDir";
    METADATA_RECORD MDRecord; 

    MDRecord.dwMDIdentifier = MD_KEY_TYPE;
	MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_SERVER;
    MDRecord.dwMDDataType = STRING_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = numeric_cast<DWORD>(sizeof(WCHAR) * (wcslen(KeyType) + 1));
    MDRecord.pbMDData = (UCHAR*)(KeyType);

    HRESULT hr = g_pIMSAdminBase->SetData(
									metaHandle,
									g_wcsFullPath,
									&MDRecord
									);    
    if (FAILED(hr))
    {        
        DebugLogMsg(eError, L"The extention KeyType could not be set. IMSAdminBase::SetData() failed. hr = 0x%x", hr);
        throw bad_hresult(hr);
    }    

    DebugLogMsg(eInfo, L"The extention KeyType was set to %s.", KeyType);
}


static void SetExtensionAccessFlag(METADATA_HANDLE metaHandle)
/*++
Routine Description:
	Set Extension Access Flag (MD_ACCESS_PERM).

Arguments:
	metaHandle - handle to metadata

--*/
{     
    //
    // set access flag
    //

    METADATA_RECORD MDRecord; 

    DWORD dwValue = MD_ACCESS_SCRIPT | MD_ACCESS_EXECUTE;
    MDRecord.dwMDIdentifier = MD_ACCESS_PERM;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_FILE;
    MDRecord.dwMDDataType = DWORD_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = sizeof(DWORD);
    MDRecord.pbMDData = (PBYTE)&dwValue;

    HRESULT hr = g_pIMSAdminBase->SetData(
									metaHandle,
									g_wcsFullPath,
									&MDRecord
									);    
    if (FAILED(hr))
    {        
        DebugLogMsg(eError, L"The access flag for the IIS extension could not be set. IMSAdminBase::SetData() failed. hr = 0x%x", hr);
        throw bad_hresult(hr);
    }    
    DebugLogMsg(eInfo, L"The access flag for the IIS extension was set.");
}


static void SetExtensionDontLog(METADATA_HANDLE metaHandle)
/*++
Routine Description:
	Set Extension Dont log Flag (MD_DONT_LOG).

Arguments:
	metaHandle - handle to metadata

--*/
{     
    //
    // set don't log flag
    //

    METADATA_RECORD MDRecord; 

    DWORD dwValue = TRUE;
    MDRecord.dwMDIdentifier = MD_DONT_LOG;
    MDRecord.dwMDAttributes = METADATA_INHERIT;
    MDRecord.dwMDUserType = IIS_MD_UT_FILE;
    MDRecord.dwMDDataType = DWORD_METADATA;
    MDRecord.dwMDDataTag = 0;
    MDRecord.dwMDDataLen = sizeof(DWORD);
    MDRecord.pbMDData = (PBYTE)&dwValue;

    HRESULT hr = g_pIMSAdminBase->SetData(
									metaHandle,
									g_wcsFullPath,
									&MDRecord
									);    
    if (FAILED(hr))
    {        
        DebugLogMsg(eError, L"The MD_DONT_LOG flag for the IIS extension could not be set. IMSAdminBase::SetData() failed. hr = 0x%x", hr);
        throw bad_hresult(hr);
    }    
    DebugLogMsg(eInfo, L"The MD_DONT_LOG flag for the IIS extension was set.");
}


static void SetExtensionProperties()
/*++
Routine Description:
	Set data for MSMQ IIS Extension

Arguments:
	None

Returned Value:
	HRESULT

--*/
{  
	DebugLogMsg(eAction, L"Setting properties for the Message Queuing IIS extension");

    CAutoCloseMetaHandle metaHandle;

	OpenRootKey(&metaHandle);

	SetExtentionKeyType(metaHandle);


	SetExtensionPhysicalPath(metaHandle);

	SetExtensionAccessFlag(metaHandle);

	SetExtensionDontLog(metaHandle);
}

//+--------------------------------------------------------------
//
// Function: CleanupAll
//
// Synopsis: In case of failure cleanup everything: delete application
//              delete extension etc.
//
//+--------------------------------------------------------------
static void CleanupAll()
{
	DebugLogMsg(eAction, L"Cleaning up the Message Queuing IIS extension");
    //
    // unload application
    //
    UnloadApplication();

    HRESULT hr = g_pIWamAdmin->AppDelete(g_wcsFullPath, TRUE);
    if (FAILED(hr))
    {      
        DebugLogMsg(eError, L"IWamAdmin::AppDelete failed. hr = 0x%x", hr);
		throw bad_hresult(hr);
    }
    
    CAutoCloseMetaHandle metaHandle;
    hr = g_pIMSAdminBase->OpenKey(
								METADATA_MASTER_ROOT_HANDLE,
								PARENT_PATH,
								METADATA_PERMISSION_WRITE,
								5000,
								&metaHandle
								);    
 
    if (FAILED(hr))
    {    
        if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
        {
            //
            // extension does not exist
            //
            return;
        }
       
        DebugLogMsg(eError, L"IMSAdminBase::OpenKey failed. hr = 0x%x", hr);
		throw bad_hresult(hr);
    }    

    //
    // delete key
    //
    hr = g_pIMSAdminBase->DeleteKey(
                            metaHandle,
                            MSMQ_IISEXT_NAME
                            );
    if (FAILED(hr))
    {      
        DebugLogMsg(eError, L"IMSAdminBase::DeleteKey failed. hr = 0x%x", hr);
        throw bad_hresult(hr);
    }    

    //
    // Commit the changes
    //
    CommitChanges();    
   
    DebugLogMsg(eInfo, L"The IIS extension was deleted.");
}


static void CleanupAllNoThrow()
{
	try
	{
		CleanupAll();
	}
	catch(const bad_hresult&)
	{
	}
}


static void CreateMsmqWebDirectory()
/*++

Routine Description:
	Create msmq web directory

--*/
{
	DebugLogMsg(eAction, L"Creating the msmq web directory");
	
	//
	// Compose msmq web directory string
	//
	g_MsmqWebDir = GetDefaultWebSitePhysicalPath() + DIR_MSMQ;

    //
    // create msmq web directory if needed. 
    // Even if extension exists maybe directory was removed.
    // So it is the place to create it (bug 6014)...
    //
    if (!StpCreateWebDirectory(g_MsmqWebDir.c_str(), GetAnonymousUserName().c_str()))
    {
        DebugLogMsg(eError, L"The Message Queuing Web directory could not be created.");
		HRESULT hr = HRESULT_FROM_WIN32(ERROR_CREATE_FAILED);
        MqDisplayError(NULL, IDS_CREATE_IISEXTEN_ERROR, hr, g_wcsFullPath);
		throw bad_hresult(hr);
    }    

    DebugLogMsg(eInfo, L"The Message Queuing Web directory '%ls' was created.", g_MsmqWebDir.c_str());
}


static bool SetInetpubWebDirRegistry()
{
    DWORD InetpubWebDir = 1;
    if (!MqWriteRegistryValue(
			MSMQ_INETPUB_WEB_DIR_REGNAME,
			sizeof(DWORD),
			REG_DWORD,
			(PVOID) &InetpubWebDir
			))
    {
        ASSERT(("failed to write InetpubWebDir value in registry", 0));
        return false;
    }

    return true;
}


static bool MsmqWebDirectoryNeedUpdate()
{
    DWORD MsmqInetpubWebDir = 0;
    MqReadRegistryValue( 
			MSMQ_INETPUB_WEB_DIR_REGNAME,
			sizeof(MsmqInetpubWebDir),
			(PVOID) &MsmqInetpubWebDir 
			);

	//
	// If the MSMQ_INETPUB_WEB_DIR_REGNAME is not set 
	// we need to update msmq web directory location
	//
	return (MsmqInetpubWebDir == 0);
}


//+--------------------------------------------------------------
//
// Function: CreateIISExtension
//
// Synopsis: Create MSMQ IIS Extension
//
//+--------------------------------------------------------------

static 
void
CreateIISExtension()
{
	DebugLogMsg(eAction, L"Creating A new Message Queuing IIS extension");
	
    //
    // start default web server if needed
    //
    StartDefaultWebServer();
   
	CreateMsmqWebDirectory();

    //
    // check if iis extension with MSMQ name already exists
    //
    if (IsExtensionExist())
    {
		try
		{
			CleanupAll();
		}
		catch(const bad_hresult& e)
		{
			if(IsExtensionExist())
			{
				MqDisplayError(
					NULL, 
					IDS_EXTEN_EXISTS_ERROR, 
					e.error(), 
					MSMQ_IISEXT_NAME, 
					g_wcsFullPath
					);
				throw;
			}
        }
    }   

	//
	// create application
	//
	CreateApplication();

	//
	// set extension properties
	//
	SetExtensionProperties();
	
	SetApplicationProperties();

	//
	// set application mapping
	//
	CMultiString multi = GetApplicationMapping();

	AddMSMQToMapping(multi);

	//
	// Configure the security permissions.
	//
	PermitISExtention();

	//
	// commit changes
	//
	CommitChanges();

	//
	// Set InetpubWebDir registry
	// This indicates that msmq web directory is in the new location.
	//
	SetInetpubWebDirRegistry();
}


static bool RemoveIISDirectory()
{
	DebugLogMsg(eAction, L"Removing the Message Queuing Web directory");

    CAutoCloseMetaHandle metaHandle;
    OpenRootKeyForRead(&metaHandle);

	//
	// Compose msmq web directory string
	//
	g_MsmqWebDir = GetDefaultWebSitePhysicalPath() + DIR_MSMQ;

	if(!RemoveDirectory(g_MsmqWebDir.c_str()))
	{
		DWORD gle = GetLastError();
		DebugLogMsg(eError, L"The Message Queuing Web directory %s could not be removed. Error: %d", g_MsmqWebDir.c_str(), gle);
		return false;
	}
	return true;
}

//+--------------------------------------------------------------
//
// Function: UnInstallIISExtension
//
// Synopsis: Remove MSMQ IIS Extension
//
//+--------------------------------------------------------------
BOOL UnInstallIISExtension()
{
    TickProgressBar(IDS_PROGRESS_REMOVE_HTTP);	

    //
    // Init COM and pointers
    //
    CIISPtr IISPtr;
	try
	{
		Init();
	}
	catch(const bad_hresult&)
	{
        //
        // I don't think we need popup here: maybe Init failed
        // since IIS was removed too. Just return FALSE.        
        //MqDisplayError(NULL, IDS_INIT_FOREXTEN_ERROR, hr);        
        return FALSE;
    }
    
    //
    // remove application and extention compltely
    //
	try
	{
		CleanupAll();
		RemoveIISDirectory();
	}
    catch(const bad_hresult& hr)
    {
        MqDisplayError(NULL, IDS_DELETE_EXT_ERROR, hr.error(), MSMQ_IISEXT_NAME, g_wcsFullPath);
        return FALSE;
    }
	return TRUE;
}

//+--------------------------------------------------------------
//
// Function: InstallIISExtensionInternal
//
// Synopsis: Main loop to create IIS Extension
//
//+--------------------------------------------------------------
static BOOL InstallIISExtensionInternal()
{
    CIISPtr IISPtr;
	try
	{
		Init();
	}
    catch(const bad_hresult& err)
    {        
        MqDisplayError(NULL, IDS_INIT_FOREXTEN_ERROR, err.error());                         
        DebugLogMsg(eError, L"Message Queuing will not be able to receive HTTP messages.");
        return FALSE;
    }

	try
	{
	    CreateIISExtension();
	}
    catch(const bad_hresult& e)
    {
        CleanupAllNoThrow();
        MqDisplayError(NULL, IDS_CREATE_IISEXTEN_ERROR, e.error(), g_wcsFullPath);
        DebugLogMsg(eError, L"Message Queuing will not be able to receive HTTP messages.");
        return FALSE;
    }   
    return TRUE;
}


static BOOL UpgradeHttpInstallation()
/*++

Routine Description:
	This function is called on upgrade,
	The function check if we need to update msmq web directory.
	If HTTP Subcomponent is installed, 
	and if current msmq web directory is in the old location (system32\msmq\web)
	we will create a new msmq web directory in inetpub\wwwroot\msmq. 

Arguments:
    None

Return Value:
    None

--*/
{
	//
	// This function is called on upgrade when http subcomponent is installed
	//
	ASSERT(g_fUpgrade);
	ASSERT(GetSubcomponentInitialState(HTTP_SUPPORT_SUBCOMP) == SubcompOn);

	if(!MsmqWebDirectoryNeedUpdate())
	{
        DebugLogMsg(eInfo, L"The Message Queuing Web directory is under Inetpub. There is no need to update its location.");        
		return TRUE;
	}

	//
	// every upgrade of operation system change the security descriptor of directories under system32
	// If current msmq web directory is in the old location under system32, 
	// than we need to move it to a new location under inetpub dir.
	// Otherwise every upgrade will overrun this directory security.
	//

    //
    // Run IIS service
    //
    //
    // ISSUE: This code should be dropped.
    // There is no need to start the service. On the first CoCreateInstance of a
    // metabase component, scm will start the service. (see bug 714868)
    //
	if(!RunService(IISADMIN_SERVICE_NAME))
	{
        DebugLogMsg(eError, L"The IIS service did not start. Setup will not upgrade the MSMQ HTTP Support subcomponent.");
        return TRUE;
	}

	//
	// Wait for IIS service to start
	//
    if(!WaitForServiceToStart(IISADMIN_SERVICE_NAME))
	{
        DebugLogMsg(eError, L"The IIS service did not start. Setup will not upgrade the MSMQ HTTP Support subcomponent.");
        return TRUE;
	}

	if(!InstallIISExtensionInternal())
	{
	    DebugLogMsg(eError, L"The MSMQ HTTP Support subcomponent could not be installed.");
		return FALSE;
	}

    DebugLogMsg(eInfo, L"The MSMQ HTTP Support subcomponent was upgraded. The new Message Queuing Web directory is %ls.", g_MsmqWebDir.c_str()); 
	return TRUE;
}


//+--------------------------------------------------------------
//
// Function: InstallIISExtension
//
// Synopsis: Main loop to create IIS Extension
//
//+--------------------------------------------------------------
BOOL InstallIISExtension()
{
	DebugLogMsg(eHeader, L"Installation of the MSMQ HTTP Support Subcomponent");
	if(g_fUpgradeHttp)
	{
		return UpgradeHttpInstallation();
	}

	return InstallIISExtensionInternal();
}


//
// Isapi Restriction list related functions.
//
static
void
SetRestrictionList(
	CMultiString& multi,
	METADATA_HANDLE hmd
    )
/*++
Routine Description:
    Write the restriction list back to the metabase.

Arguments:
	multi - A multistring to set to the metabase.
	hmd - An open handel to the metabase.

--*/
{
    METADATA_RECORD mdr;
	mdr.dwMDIdentifier = MD_WEB_SVC_EXT_RESTRICTION_LIST;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdr.dwMDUserType = IIS_MD_UT_FILE;
	mdr.dwMDDataType = MULTISZ_METADATA;
	mdr.dwMDDataLen = numeric_cast<DWORD>(multi.Size() * sizeof(WCHAR));
	mdr.pbMDData = (BYTE*)(multi.Data());

    HRESULT hr = g_pIMSAdminBase->SetData(
                    hmd,
                    L"",
                    &mdr
                    );
    if FAILED(hr)
    {
        throw bad_hresult(hr);
    }
}



static
void
FixIsapiRestrictonList(
	CMultiString& multi
	)
/*++
Routine Description:
    First if mqise.dll is in the list we remove it.
	Then add the string to allow mqise.dll.

Arguments:
    CMultiString - The restriction list.
--*/
{
	//
	// First remove all apearences of MQISE.DLL
	//
	multi.RemoveAllContiningSubstrings(g_szSystemDir + L"\\" + MQISE_DLL);

	//
	// Construct the allow string:
	//
	std::wstring str = L"1," + g_szSystemDir + L"\\" + MQISE_DLL;
	multi.Add(str);
	DebugLogMsg(eInfo, L"%s was added to the restriction list.", str.c_str());

}

static
CMultiString
GetRestrictionList(
	const METADATA_HANDLE hmd
    )
/*++
Routine Description:
	Get the actual restriction list.

Arguments:
	hmd - open handle to metadata.

Returned Value:
	The isapi restriction list.
--*/
{
	METADATA_RECORD mdr;
	mdr.dwMDIdentifier = MD_WEB_SVC_EXT_RESTRICTION_LIST;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdr.dwMDUserType = IIS_MD_UT_FILE;
	mdr.dwMDDataType = MULTISZ_METADATA;
	mdr.dwMDDataLen = 0;
	mdr.pbMDData = NULL;
	
    DWORD size = 0;

    HRESULT hr = g_pIMSAdminBase->GetData(
									hmd,
									L"",
									&mdr,  
									&size //pointer to a DWORD that receives the size. 
									);
	
	if(hr != HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
	{
		throw bad_hresult(hr);
	}


	mdr.dwMDDataLen = size; 
	AP<BYTE> buff = new BYTE[size];
	mdr.pbMDData = buff;
    DWORD s;
    hr = g_pIMSAdminBase->GetData(
                        hmd,
                        L"",
                        &mdr, 
                        &s 
                        );
	if(FAILED(hr))
	{
		throw bad_hresult(hr);
	}
	CMultiString multi((LPCWSTR)(buff.get()), size / sizeof(WCHAR));
	return multi;
}

void PermitISExtention()
/*++
Routine Description:
    This routine is for adding mqise.dll to the list of allowed Dlls in IIS Metabase.
    The relevant key is WebSvcExtRestrictionList in /lm/w3svc/. This is a multy string which 
    is a group of concatinated strings (each eanding with \0) ending with \0\0.
    for example: string1\0string2\0\0.
	To be allowed we need to add an entry of the format:
	1,"dll full path" (where 1 is 'allow').
    What we do here is add this string to the list.

    If the key is not found (can happen on client or setup after upgrade, just do nothing).
    In case of failure give an error that the user must add mqise.dll manualy.

--*/
{
	DebugLogMsg(eAction, L"Allowing the Message Queuing IIS extension");
    CAutoCloseMetaHandle hmd;
	HRESULT hr = g_pIMSAdminBase->OpenKey(
			METADATA_MASTER_ROOT_HANDLE,
			L"/lm/w3svc",
			METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
			1000,
			&hmd
            );

	if(FAILED(hr))
	{
        if(hr == ERROR_INVALID_PARAMETER || hr == ERROR_PATH_NOT_FOUND)
        {
            //
            // This is fine, just go on with setup.
            //
            DebugLogMsg(eWarning ,L"The WebSvcExtRestrictionList key does not exist.");
            return;
        }
        MqDisplayError(NULL, IDS_CREATE_IISEXTEN_ERROR, hr);
	    return ;
	}

    try
	{
        CMultiString multi = GetRestrictionList(hmd);

        FixIsapiRestrictonList(multi);

        SetRestrictionList(multi, hmd);
    }
    catch(const bad_hresult& e)
    {
		if(e.error() == MD_ERROR_DATA_NOT_FOUND)
		{
			//
			// This error is legitimate, MD_ISAPI_RESTRICTION_LIST doesn't exist.
			// This is the case when installing MSMQ on client build.
			//
			DebugLogMsg(eWarning, L"The restriction list property (MD_ISAPI_RESTRICTION_LIST) was not found.");
			return;
		}

        MqDisplayError(NULL, IDS_ISAPI_RESTRICTION_LIST_ERROR, e.error());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\list.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    list.h

Abstract:

    List and List::Iterator.
    An intrusive double linked list and iterator template

Author:

    Erez Haba (erezh) 13-Aug-95

Revision History:

--*/

/*++

  DESCRIPTION:
    List is defined as a circular doubble linked list. With actions
    to insert and remove entries.

       List
      +-----+   +-----+ +-----+ +-----+ +-----+ +-----+
      |     |<--|     | |     | |     | |     | |     |
      | head|   | data| | data| | data| | data| | data|
      |     |-->|     | |     | |     | |     | |     |
      +-----+   +-----+ +-----+ +-----+ +-----+ +-----+

                      Linked list diagram

    An iteration is defined for the list using the member type named
    Iterator. To declater an interator variable, use full qualified
    name. e.g., List<T>::Iterator. An iterator variable is analogous
    to type T pointer. Dereference '*' and arrow '->' operators are
    overloaded for this type so you can (allmost) freely use it as a
    T pointer.

      Example:

        for(List<T>::Iterator p = list.begin(); p != list.end(); ++p)
        {
            p->doSomeThing();
        }
--*/

#ifndef _LIST_H
#define _LIST_H

//---------------------------------------------------------
//
//  class List
//
//---------------------------------------------------------
template<class T, int Offset = FIELD_OFFSET(T, m_link)>
class List {

public:

    class Iterator;

public:
    List(void);
   ~List(void);

    void insert(T* pItem);
    void remove(T* pItem);

    int isempty(void) const;

    T* peekhead(void) const;
    T* peektail(void) const;

    T* gethead(void);
    T* gettail(void);

    Iterator begin() const;
    Iterator end() const;

    static LIST_ENTRY* Item2Entry(T*);
    static T* Entry2Item(LIST_ENTRY*);

private:
    LIST_ENTRY m_head;

public:

    //
    // class List<T, Offset>::Iterator
    //
    class Iterator {
    private:
        LIST_ENTRY* m_current;

    public:
        //
        //  Iterator implementation is here due to bug
        //  in VC++ 4.0 compiler. If implementation is not
        //  here, liker looks for some constructor not needed
        //
        explicit Iterator(LIST_ENTRY* pEntry) :
            m_current(pEntry)
        {
        }

        Iterator& operator++()
        {
            m_current = m_current->Flink;
            return *this;
        }

        Iterator& operator--()
        {
            m_current = m_current->Blink;
            return *this;
        }

        T& operator*() const
        {
            return (*List<T, Offset>::Entry2Item(m_current));
        }

        T* operator->() const
        {
            return (&**this);
        }

        BOOL operator==(const Iterator& i)
        {
            return (m_current == i.m_current);
        }

        BOOL operator!=(const Iterator& i)
        {
            return (!(*this == i));
        }
    };
    //
    // end class Iterator decleration
    //
};


//---------------------------------------------------------
//
//  IMPLEMENTATION
//
//---------------------------------------------------------
template<class T, int Offset>
inline List<T, Offset>::List(void)
{
    InitializeListHead(&m_head);
}

template<class T, int Offset>
inline List<T, Offset>::~List(void)
{
    ASSERT(isempty());
}

template<class T, int Offset>
inline LIST_ENTRY* List<T, Offset>::Item2Entry(T* t)
{
    return ((LIST_ENTRY*)(PVOID)((PCHAR)t + Offset));
}

template<class T, int Offset>
inline T* List<T, Offset>::Entry2Item(LIST_ENTRY* l)
{
    return ((T*)(PVOID)((PCHAR)l - Offset));
}

template<class T, int Offset>
inline void List<T, Offset>::insert(T* item)
{
    LIST_ENTRY* pEntry = Item2Entry(item);
    InsertTailList(&m_head, pEntry);
}

template<class T, int Offset>
inline void List<T, Offset>::remove(T* item)
{
    LIST_ENTRY* pEntry = Item2Entry(item);
    RemoveEntryList(pEntry);
}

template<class T, int Offset>
inline int List<T, Offset>::isempty(void) const
{
    return IsListEmpty(&m_head);
}

template<class T, int Offset>
inline T* List<T, Offset>::peekhead() const
{
    return (isempty() ? 0 : Entry2Item(m_head.Flink));
}

template<class T, int Offset>
inline T* List<T, Offset>::peektail() const
{
    return (isempty() ? 0 : Entry2Item(m_head.Blink));
}

template<class T, int Offset>
inline T* List<T, Offset>::gethead()
{
    if(isempty())
    {
        return 0;
    }

    //
    // return RemoveHeadList(...) will NOT work here!!! (macro)
    //
    LIST_ENTRY* p = RemoveHeadList(&m_head);
    return Entry2Item(p);
}

template<class T, int Offset>
inline T* List<T, Offset>::gettail()
{
    if(isempty())
    {
        return 0;
    }

    //
    // return RemoveTailList(...) will NOT work here!!! (macro)
    //
    LIST_ENTRY* p = RemoveTailList(&m_head);
    return Entry2Item(p);
}

template<class T, int Offset>
inline typename List<T, Offset>::Iterator List<T, Offset>::begin() const
{
    return Iterator(m_head.Flink);
}

template<class T, int Offset>
inline typename List<T, Offset>::Iterator List<T, Offset>::end() const
{
    return Iterator(const_cast<LIST_ENTRY*>(&m_head));
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\list_mac.h ===
//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\machnutl.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    machnutl.cpp

Abstract:

    Utility/helper code for creating the machine objects.

Author:


Revision History:

    Doron Juster  (DoronJ)

--*/

#include "msmqocm.h"
#include <mqsec.h>

#include "machnutl.tmh"


BOOL
PrepareUserSID()
{
    //
    // Save SID of user in registry. The msmq service will read the sid
    // and use it when building the DACL of the msmqConfiguration object.
    //

    DebugLogMsg(eAction, L"Preparing a user SID (by calling MQSec_GetProcessUserSid) and saving it in the registery");

    AP<BYTE> pUserSid;
    DWORD    dwSidLen = 0;

    HRESULT hResult = MQSec_GetProcessUserSid(
							(PSID*)&pUserSid,
							&dwSidLen
							);
    ASSERT(SUCCEEDED(hResult));

    if (SUCCEEDED(hResult))
    {
        BOOL  fLocalUser = FALSE ;
        hResult = MQSec_GetUserType(pUserSid, &fLocalUser, NULL);
        ASSERT(SUCCEEDED(hResult)) ;

        if (SUCCEEDED(hResult))
        {
            BOOL fRegistry;
            if (fLocalUser)
            {
                DWORD dwLocal = 1 ;
                DWORD dwSize = sizeof(dwLocal) ;

                fRegistry = MqWriteRegistryValue(
                                            MSMQ_SETUP_USER_LOCAL_REGNAME,
                                            dwSize,
                                            REG_DWORD,
                                            &dwLocal ) ;
            }
            else
            {
                //
                // Only domain user get full control on the object, not
                // local user. Local user is not known in active directory.
                //
                fRegistry = MqWriteRegistryValue(
                                             MSMQ_SETUP_USER_SID_REGNAME,
                                             dwSidLen,
                                             REG_BINARY,
                                             pUserSid ) ;
            }
            ASSERT(fRegistry) ;
        }
    }
    return true;
}

//+----------------------------------------------------------------------
//
//  BOOL  PrepareRegistryForClient()
//
//  Prepare registry for client msmq service that will later create the
//  msmqConfiguration object in the active directory.
//
//+----------------------------------------------------------------------

BOOL  PrepareRegistryForClient()
{
    //
    // msmqConfiguration object will be created by the msmq service
    // after it boot.
    //
    DebugLogMsg(eAction, L"Setting a signal in the registry for the Message Queuing service to create the MSMQ-Configuration object"); 
    TickProgressBar();

    DWORD dwCreate = 1 ;
    BOOL fRegistry = MqWriteRegistryValue(
                        MSMQ_CREATE_CONFIG_OBJ_REGNAME,
                        sizeof(DWORD),
                        REG_DWORD,
                        &dwCreate
                        );
    
    UNREFERENCED_PARAMETER(fRegistry);

    ASSERT(fRegistry);

    return PrepareUserSID();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\msmqocm.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    msmqocm.cpp

Abstract:

    Entry point for OCM.

Author:

    Shai Kariv  (ShaiK)  10-Dec-97

--*/

#include "msmqocm.h"
#include "_mqres.h"

#include "msmqocm.tmh"

//
// Various globals
//
BOOL    g_fServerSetup = TRUE;           
BOOL    g_fMSMQAlreadyInstalled; 
BOOL    g_fDependentClient = FALSE ;
BOOL    g_fMSMQServiceInstalled = FALSE ;
BOOL    g_fDriversInstalled = FALSE ;
BOOL    g_fCoreSetupSuccess = FALSE;
BOOL    g_fDsLess = FALSE;
BOOL    g_fInstallMSMQOffline = FALSE;
BOOL    g_fWorkGroup = FALSE;
BOOL    g_fSkipServerPageOnClusterUpgrade = FALSE;
BOOL    g_fWeakSecurityOn = FALSE;
BOOL    g_fFirstMQDSInstallation = FALSE;

//
// we need this flag because of IIS installation bug.
// we have to postpone msmq iis installation to the end of setup
//
BOOL    g_fNeedToCreateIISExtension = FALSE;

//
// Setup mode (install, remove, etc...)
//
BOOL  g_fBatchInstall     = FALSE ;
BOOL  g_fCancelled        = FALSE ;
BOOL  g_fUpgrade          = FALSE ;
BOOL  g_fUpgradeHttp      = FALSE ;
DWORD g_dwDsUpgradeType   = 0;
BOOL  g_fWelcome          = FALSE ;
BOOL  g_fOnlyRegisterMode = FALSE ;
BOOL  g_fWrongConfiguration = FALSE;

//
// ID of error messages title
//
UINT  g_uTitleID     = IDS_SETUP_ERROR ;

//
// Machine info
//
WCHAR g_wcsMachineName[MAX_COMPUTERNAME_LENGTH + 1] = {_T("")};
std::wstring g_MachineNameDns;
DWORD g_dwMachineType = SERVICE_NONE ;  // "old" property for msmq type
DWORD g_dwMachineTypeDs = 0;            // boolean: ds server
DWORD g_dwMachineTypeFrs = 0;           // boolean: routing server
DWORD g_dwMachineTypeDepSrv = 0;        // boolean: dependent client supporting server

SC_HANDLE g_hServiceCtrlMgr;

SPerComponentData g_ComponentMsmq;

extern VOID APIENTRY ShutDownDebugWindow(VOID);

//
// DLL handles
// Get the handle to the resource only DLL first, i.e. mqutil.dll
//
HINSTANCE g_hResourceMod = MQGetResourceHandle();
HINSTANCE g_hMqutil = NULL;

SSubcomponentData g_SubcomponentMsmq[] =
{
//=====================================================================
//  szSubcomponentId        ||InitialState  ||IsSelected    ||fIsInstalled  ||dwOperation             PFNINSTALL||            PFNREMOVE
//=====================================================================
    {MSMQ_CORE_SUBCOMP,     FALSE,          FALSE,          FALSE,          DONOTHING,              InstallMsmqCore,        RemoveMSMQCore},
    {LOCAL_STORAGE_SUBCOMP, FALSE,          FALSE,          FALSE,          DONOTHING,              InstallLocalStorage,    UnInstallLocalStorage},
    {TRIGGERS_SUBCOMP,      FALSE,          FALSE,          FALSE,          DONOTHING,              InstallMSMQTriggers,    UnInstallMSMQTriggers},
    {HTTP_SUPPORT_SUBCOMP,  FALSE,          FALSE,          FALSE,          DONOTHING,              InstallIISExtension,    UnInstallIISExtension},
    {AD_INTEGRATED_SUBCOMP, FALSE,          FALSE,          FALSE,          DONOTHING,              InstallADIntegrated,    UnInstallADIntegrated},
    {ROUTING_SUBCOMP,       FALSE,          FALSE,          FALSE,          DONOTHING,              InstallRouting,         UnInstallRouting},    
    {MQDSSERVICE_SUBCOMP,   FALSE,          FALSE,          FALSE,          DONOTHING,              InstallMQDSService,     UnInstallMQDSService}
};

//
// number of all subcomponents
//
DWORD g_dwAllSubcomponentNumber = sizeof(g_SubcomponentMsmq)/sizeof(SSubcomponentData);

//
// first server only subcomponent: eRoutingSupport
//
DWORD g_dwClientSubcomponentNumber = eRoutingSupport; 
DWORD g_dwSubcomponentNumber;

        
//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//--------------------------------------------------------------------------
BOOL 
WINAPI 
DllMain(
    IN const HANDLE /*DllHandle*/,
    IN const DWORD  Reason,
    IN const LPVOID /*Reserved*/
    )
{
    switch( Reason )    
    {
        case DLL_PROCESS_ATTACH:
        {
            break; 
        }

        default:
        {
            break;
        }
    }

    return TRUE;

} //DllMain


//+-------------------------------------------------------------------------
//
//  Function:   MsmqOcm
//
//  Synopsis:   Called by the ocmgr when things happen
//
//  Arguments:  ComponentId    -- the MSMQ Component name
//              SubcomponentId -- the .inf section being operated on
//              Function       -- the operation
//              Param1         -- operation paramater
//              Param2         -- operation paramater
//
//  Returns:    Win32 error code (usually), depends on Function
//
//--------------------------------------------------------------------------
DWORD  //POCSETUPPROC
MsmqOcm(
    IN const TCHAR * ComponentId,
    IN const TCHAR * SubcomponentId,
    IN const UINT    Function,
    IN const UINT_PTR  Param1,
    IN OUT PVOID   Param2 )
{ 
	if(g_fOnlyRegisterMode)
	{
		//
		// MSMQ instllation during fresh install of os is not supported.
		//
		return NO_ERROR;
	}


    switch(Function)
    {
      case OC_PREINITIALIZE:
      {    
          return OCFLAG_UNICODE;  
      }

      case OC_INIT_COMPONENT:
      {        
          return InitMSMQComponent(ComponentId, Param2);
      }

      case OC_QUERY_STATE:
      {                
          return MqOcmQueryState(Param1, SubcomponentId);
      }

      case OC_SET_LANGUAGE:
      {
          //
          // We don't care what language is used
          //        
          return 1;
      }

      case OC_REQUEST_PAGES:
      {          
          return MqOcmRequestPages(
              g_ComponentMsmq.ComponentId,
              (WizardPagesType) Param1,
              (PSETUP_REQUEST_PAGES) Param2 
			  );                
      }

      case OC_QUERY_CHANGE_SEL_STATE:
      {                          
          if (g_fCancelled)
          {
              //
              // Setup was cancelled. Don't allow changes.
              //
              return 0;
          }

          return MqOcmQueryChangeSelState(
						SubcomponentId, 
						Param1, 
						(DWORD_PTR)Param2
						);                           
      }

      case OC_QUERY_SKIP_PAGE:
      {
          //
          // for subcomponent setup: we need to show pages if Advanced
          // Option was selected. Otherwise we have sufficient information
          // to run setup without UI. In order
          // - to skip pages return non-0; 
          // - do not skip pages return 0;
          //
          
		  if (g_fWelcome && WizPagesEarly != Param1)
		  {
			  return 1;
		  }
		  return 0;
      }

      case OC_CALC_DISK_SPACE:
      {
          //
          // Param1 = 0 if for removing component or non-0 if for adding component
          // Param2 = HDSKSPC to operate on
          // 
		  try
		  {
				MqOcmCalcDiskSpace((Param1 != 0), SubcomponentId, (HDSKSPC)Param2);
				return 0;
		  }
		  catch(const bad_win32_error& e)
		  {
				return e.error();
		  }

      }

      case OC_QUEUE_FILE_OPS:
      {                 
          if (0 == SubcomponentId)
          {
              //
              // False notification from OCM, just ignore (we will be called again)
              //
              return NO_ERROR;
          }
                   
          if (_tcsicmp(SubcomponentId, g_SubcomponentMsmq[eMSMQCore].szSubcomponentId) != 0)
          {
              //
              // there is no file operation if it is not CORE subcomponent
              // 
              return NO_ERROR;
          }

          //
          // We can reach this point once, for MSMQ Core subcomponent only.
          // So, it is the time to perform operations that must be done only once
          // when UI is already closed (it does not matter what is subcomponent
          // here, so do all for MSMQ Core)
          //
          MqInit();

          //          
          // It is already defined what we have to do, so it is the time
          // to set operation flags for each subcomponent if we did not
          // set operation before, in our wizard page. It can happen if
          // we are in unattended mode. 
          // We need to call this function only once (we set operation for
          // all components)
          // 
          SetOperationForSubcomponents();

          //
          // Note: this case is always called before removing or installing,
          // so we are using it to initialize some stuff.
          // Don't call it for no-op.
          //
          if ( (g_SubcomponentMsmq[eMSMQCore].dwOperation != DONOTHING) ||
              //
              // or upgrading the OS and msmq is installed
              //
              (0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE) && g_fMSMQAlreadyInstalled))
          {              
              //
              // Param2 = HSPFILEQ to operate on
              //                            
              //
              // file operation only if MSMQ Core subcomponent
              // was selected/ unselected
              //
              return MqOcmQueueFiles(SubcomponentId, Param2);              
          }
          DebugLogMsg(eInfo, L"Setup is operating in DO NOTHING mode and skipping file operations.");
		  return NO_ERROR;          
      }

      case OC_QUERY_STEP_COUNT:
      {    
          //
          // BUGBUG: we need to define number of steps for each 
          // subcomponent separately. Maybe it is possible to save it
          // in msmqocm.inf.
          //      
          const x_nInstallationSteps = 20;          

          if (g_fCancelled)
		  {
			  return NO_ERROR;
		  }
          DWORD dwSetupOperation = GetSetupOperationBySubcomponentName(SubcomponentId);
          return (DONOTHING == dwSetupOperation ? 0 : x_nInstallationSteps);
      }

      case OC_ABOUT_TO_COMMIT_QUEUE :
      {                  
			MqOcmRemoveInstallation(SubcomponentId); // Ignore errors
			return NO_ERROR;
      }

      case OC_COMPLETE_INSTALLATION:
      {  
          
          //
          // Install MSMQ. Don't report errors to OCM.
          //                            
          MqOcmInstall(SubcomponentId) ;            
          return NO_ERROR;
      } 

      case OC_QUERY_IMAGE:
      {
          //
          // we do it in .inf files. Please keep resource ID numbers (118-130)!
          // if you have to change them do not forget to change them in 
          // all .inf files!
          //
          return NO_ERROR;
      }

      case OC_CLEANUP:
      {                     
		  //
		  // If needed Write to registry what type of MSMQ was just installed (server, client, etc.)
		  //
		  DebugLogMsg(eHeader, L"Cleanup Phase");
   		  WriteRegInstalledComponentsIfNeeded();
		  
          
          //
          // the wizard is closed at this moment. We need to call
          // MessageBox with NULL first parameter
          //
          g_hPropSheet = NULL;
             
                          
          //
          //  Terminate MQUTIL working threads
          //
          ShutDownDebugWindow();

          return NO_ERROR;
      }

      default:
      {
		return NO_ERROR;
      }
    }
} //MsmqOcm


//+-------------------------------------------------------------------------
//
//  Function:   WelcomeEntryProc
//
//  Synopsis:   Entry point for installing MSMQ from Welcome UI.
//              Wraps MsmqOcm().
//
//--------------------------------------------------------------------------
DWORD 
WelcomeEntryProc(
    IN const TCHAR * ComponentId,
    IN const TCHAR * SubcomponentId,
    IN const UINT    Function,
    IN const UINT_PTR    Param1,
    IN OUT PVOID   Param2 )
{
    g_fWelcome = TRUE;

    return MsmqOcm(ComponentId, SubcomponentId, Function, Param1, Param2);

} // WelcomeEntryProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\msmqocm.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    msmqocm.h

Abstract:

    Master header file for NT5 OCM setup.

Author:

    Doron Juster  (DoronJ)  26-Jul-97

Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/


#ifndef _MSMQOCM_H
#define _MSMQOCM_H

#include "stdh.h"
#include "comreg.h"
#include "ocmnames.h"
#include "service.h"
#include "setupdef.h"

#include <activeds.h>
#include <shlwapi.h>
#include <autorel.h>    //auto release pointer definition
#include <autorel2.h>
#include "ad.h"
#include <mqcast.h>
#include <autoreln.h>

//++-------------------------------------------------------
//
// Globals declaration
//
//-------------------------------------------------------++
extern WCHAR      g_wcsMachineName[MAX_COMPUTERNAME_LENGTH + 1];
extern std::wstring g_MachineNameDns;
extern HINSTANCE  g_hResourceMod;

extern BOOL       g_fMSMQAlreadyInstalled;
extern SC_HANDLE  g_hServiceCtrlMgr;
extern BOOL       g_fMSMQServiceInstalled;
extern BOOL       g_fDriversInstalled;
extern BOOL       g_fNeedToCreateIISExtension;
extern HWND       g_hPropSheet ;

extern DWORD      g_dwMachineType ;
extern DWORD      g_dwMachineTypeDs;
extern DWORD      g_dwMachineTypeFrs;
extern DWORD      g_dwMachineTypeDepSrv;

extern BOOL       g_fDependentClient ;
extern BOOL       g_fServerSetup ;
extern BOOL       g_fDsLess;
extern BOOL       g_fInstallMSMQOffline;

extern BOOL       g_fCancelled ;
extern BOOL       g_fUpgrade ;
extern BOOL       g_fUpgradeHttp ;
extern DWORD      g_dwDsUpgradeType;
extern BOOL       g_fBatchInstall ;
extern BOOL       g_fWelcome;
extern BOOL       g_fOnlyRegisterMode ;
extern BOOL       g_fWrongConfiguration;

extern std::wstring g_szMsmqDir;
extern std::wstring g_szMsmq1SetupDir;
extern std::wstring g_szMsmq1SdkDebugDir;
extern std::wstring g_szMsmqMappingDir;

extern UINT       g_uTitleID  ;
extern std::wstring g_ServerName;
extern std::wstring g_szSystemDir;

extern BOOL       g_fDomainController;
extern DWORD      g_dwOS;
extern BOOL       g_fCoreSetupSuccess;

extern BOOL       g_fWorkGroup;
extern BOOL       g_fSkipServerPageOnClusterUpgrade;
extern BOOL       g_fFirstMQDSInstallation;
extern BOOL       g_fWeakSecurityOn;


extern PNETBUF<WCHAR> g_wcsMachineDomain;


//++-----------------------------------------------------------
//
// Structs and classes
//
//-----------------------------------------------------------++

//
// Component info sent by OC Manager (per component data)
//
struct SPerComponentData
{
    std::wstring       ComponentId;
    HINF               hMyInf;
    DWORDLONG          Flags;
    LANGID             LanguageId;
	std::wstring       SourcePath;
    std::wstring       UnattendFile;
    OCMANAGER_ROUTINES HelperRoutines;
    DWORD              dwProductType;
};
extern SPerComponentData g_ComponentMsmq;

typedef BOOL (WINAPI*  Install_HANDLER)();
typedef BOOL (WINAPI*  Remove_HANDLER)();

struct SSubcomponentData
{
    TCHAR       szSubcomponentId[MAX_PATH];
    
    //TRUE if it was installed when we start THIS setup, otherwise FALSE
    BOOL        fInitialState;  
    //TRUE if user select it to install, FALSE to remove
    BOOL        fIsSelected;    
    //TRUE if it was installed successfully during THIS setup
    //FALSE if it was removed
    BOOL        fIsInstalled;
    DWORD       dwOperation;
    
    //
    // function to install and remove subcomponent
    //
    Install_HANDLER  pfnInstall;
    Remove_HANDLER   pfnRemove;
};
extern SSubcomponentData g_SubcomponentMsmq[];
extern DWORD g_dwSubcomponentNumber;
extern DWORD g_dwAllSubcomponentNumber;
extern DWORD g_dwClientSubcomponentNumber;

//
// The order is important! It must suit to the subcomponent order
// in g_SubcomponentMsmq[]
// NB! eRoutingSupport must be FIRST server subcomponents since according 
// to that number g_dwClientSubcomponentNumber is calculated
//
typedef enum {
    eMSMQCore = 0,
    eLocalStorage,
    eTriggersService,
    eHTTPSupport,
    eADIntegrated,
    eRoutingSupport,
    eMQDSService    
} SubcomponentIndex;

//
// Define the msgbox style.
// eYesNoMsgBox - YES,NO
// eOkCancelMsgBox - OK,Cancel
//
typedef enum {
		eYesNoMsgBox = 0,
		eOkCancelMsgBox
} MsgBoxStyle;


//
// String handling class
//
class CResString
{
public:
    CResString() { m_Buf[0] = 0; }

    CResString( UINT strIDS )
    {
        m_Buf[0] = 0;
        LoadString(
            g_hResourceMod,
            strIDS,
            m_Buf,
            sizeof m_Buf / sizeof TCHAR );
    }

    BOOL Load( UINT strIDS )
    {
        m_Buf[0] = 0;
        LoadString(
            g_hResourceMod,
            strIDS,
            m_Buf,
            sizeof(m_Buf) / sizeof(TCHAR)
            );
        return ( 0 != m_Buf[0] );
    }

    TCHAR * const Get() { return m_Buf; }

private:
    TCHAR m_Buf[MAX_STRING_CHARS];
};


class CMultiString;


//++------------------------------------------------------------
//
//  Functions prototype
//
//------------------------------------------------------------++

//
// OCM request handlers
//
DWORD
InitMSMQComponent(
    IN     const LPCTSTR ComponentId,
    IN OUT       PVOID   Param2
    ) ;

BOOL
MqOcmRemoveInstallation(IN     const TCHAR  * SubcomponentId);

DWORD
MqOcmRequestPages(
    const std::wstring&              ComponentId,
    IN     const WizardPagesType     WhichOnes,
    IN OUT       SETUP_REQUEST_PAGES *SetupPages
    ) ;

void
MqOcmCalcDiskSpace(
    const bool bInstall,
    LPCWSTR SubcomponentId,
    HDSKSPC& hDiskSpaceList
	);

DWORD
MqOcmQueueFiles(
    IN     const TCHAR  * SubcomponentId,
    IN OUT       HSPFILEQ hFileList
    );

DWORD
MqOcmQueryState(
    IN const UINT_PTR uWhichState,
    IN const TCHAR    *SubcomponentId
    );

DWORD MqOcmQueryChangeSelState (
    IN const TCHAR      *SubcomponentId,    
    IN const UINT_PTR    iSelection,
    IN const DWORD_PTR   dwActualSelection
    );

//
// Registry routines
//
void
MqOcmReadRegConfig();

BOOL
StoreServerPathInRegistry(
	const std::wstring& ServerName
	);

BOOL
MqSetupInstallRegistry();

BOOL
MqSetupRemoveRegistry();

BOOL
MqWriteRegistryValue(
    IN const TCHAR  * szEntryName,
    IN const DWORD   dwNumBytes,
    IN const DWORD   dwValueType,
    IN const PVOID   pValueData,
    IN const BOOL OPTIONAL bSetupRegSection = FALSE
    );

BOOL
MqWriteRegistryStringValue(
	std::wstring EntryName,
    std::wstring ValueData,
    IN const BOOL OPTIONAL bSetupRegSection = FALSE 
	);


BOOL
MqReadRegistryValue(
    IN     const TCHAR  * szEntryName,
    IN OUT       DWORD   dwNumBytes,
    IN OUT       PVOID   pValueData,
    IN const BOOL OPTIONAL bSetupRegSection = FALSE
    );

std::wstring
MqReadRegistryStringValue(
    const std::wstring& EntryName,
    IN const BOOL OPTIONAL bSetupRegSection  = FALSE 
    );


DWORD
RegDeleteKeyWithSubkeys(
    IN const HKEY    hRootKey,
    IN const LPCTSTR szKeyName);

BOOL
RegisterWelcome();

BOOL
RegisterMigrationForWelcome();

BOOL
UnregisterWelcome();

BOOL 
RemoveRegistryKeyFromSetup (
    IN const LPCTSTR szRegistryEntry);

BOOL
SetWorkgroupRegistry();

//
// Installation routines
//
DWORD
MqOcmInstall(IN const TCHAR * SubcomponentId);

BOOL
InstallMachine();

void
RegisterActiveX(
    const bool bRegister
    );

void
RegisterSnapin(
    const bool fRegister
    );
void
RegisterDll(
    bool fRegister,
    bool f32BitOnWin64,
	LPCTSTR szDllName
    );

void
OcpRegisterTraceProviders(
	LPCTSTR szFileName
    );


void
OcpUnregisterTraceProviders(
    void
    );

void
UnregisterMailoaIfExists(
    void
    );

bool
UpgradeMsmqClusterResource(
    VOID
    );

bool 
TriggersInstalled(
    bool * pfMsmq3TriggersInstalled
    );

BOOL
InstallMSMQTriggers (
	void
	);

BOOL
UnInstallMSMQTriggers (
	void
	);

BOOL
InstallMsmqCore(
    void
    );

BOOL 
RemoveMSMQCore(
    void
    );

BOOL
InstallLocalStorage(
    void
    );

BOOL
UnInstallLocalStorage(
    void
    );

BOOL
InstallRouting(
    void
    );


bool RegisterMachineType();

bool AddSettingObject(PROPID propId);


bool
SetServerPropertyInAD(
   PROPID propId,
   bool Value
   );


BOOL
UnInstallRouting(
    void
    );

BOOL
InstallADIntegrated(
    void
    );

BOOL
UnInstallADIntegrated(
    void
    );

//
// IIS Extension routines
//
BOOL
InstallIISExtension();

BOOL 
UnInstallIISExtension();

//
// Operating System routines
//
BOOL
InitializeOSVersion();

BOOL
IsNTE();

//
// Service handling routines
//

BOOL
CheckServicePrivilege();

BOOL
InstallService(
    LPCWSTR szDisplayName,
    LPCWSTR szServicePath,
    LPCWSTR szDependencies,
    LPCWSTR szServiceName,
    LPCWSTR szDescription,
    LPCWSTR szServiceAccount
    );

BOOL
RunService(
	IN LPCWSTR szServiceName
	);


BOOL
WaitForServiceToStart(
	LPCWSTR pServiceName
	);

BOOL RemoveService(LPCWSTR ServiceName);

BOOL
OcpDeleteService(
    LPCWSTR szServiceName
    );

BOOL
StopService(
    IN const TCHAR * szServiceName
    );

BOOL
InstallDeviceDrivers();

BOOL
InstallMSMQService();

BOOL
DisableMsmqService();

BOOL
UpgradeServiceDependencies();

BOOL
InstallMQDSService();

BOOL
UnInstallMQDSService();

BOOL
GetServiceState(
    IN  const TCHAR *szServiceName,
    OUT       DWORD *pdwServiceState
    );

BOOL 
InstallPGMDeviceDriver();

bool WriteDsEnvRegistry(DWORD dwDsEnv);

bool DsEnvSetDefaults();

BOOL LoadDSLibrary();

BOOL
CreateMSMQServiceObject(
    IN UINT uLongLive = MSMQ_DEFAULT_LONG_LIVE
    ) ;


BOOL
CreateMSMQConfigurationsObjectInDS(
    OUT BOOL *pfObjectCreated,
    IN  BOOL  fMsmq1Server,
	OUT GUID* pguidMsmq1ServerSite,
	OUT LPWSTR* ppwzMachineName
    );

BOOL
CreateMSMQConfigurationsObject(
    OUT GUID *pguidMachine,
    OUT BOOL *pfObjectCreated,
    IN  BOOL  fMsmq1Server
    );

BOOL
UpdateMSMQConfigurationsObject(
    IN LPCWSTR pMachineName,
    IN const GUID& guidMachine,
    IN const GUID& guidSite,
    IN BOOL fMsmq1Server
    );

BOOL
GetMSMQServiceGUID(
    OUT GUID *pguidMSMQService
    );

BOOL
GetSiteGUID();

BOOL
LookupMSMQConfigurationsObject(
    IN OUT BOOL *pbFound,
       OUT GUID *pguidMachine,
       OUT GUID *pguidSite,
       OUT BOOL *pfMsmq1Server,
       OUT LPWSTR * ppMachineName
       );

void
FRemoveMQXPIfExists();

//
// Error handling routines
//
int
_cdecl
MqDisplayError(
    IN const HWND  hdlg,
    IN const UINT  uErrorID,
    IN const DWORD dwErrorCode,
    ...);

int
_cdecl
MqDisplayErrorWithRetry(
    IN const UINT  uErrorID,
    IN const DWORD dwErrorCode,
    ...);

int 
_cdecl 
MqDisplayErrorWithRetryIgnore(
    IN const UINT  uErrorID, 
    IN const DWORD dwErrorCode,
    ...);

BOOL
_cdecl
MqAskContinue(
    IN const UINT uProblemID,
    IN const UINT uTitleID,
    IN const BOOL bDefaultContinue,
	IN const MsgBoxStyle eMsgBoxStyle,
    ...);

int 
_cdecl 
MqDisplayWarning(
    IN const HWND  hdlg, 
    IN const UINT  uErrorID, 
    IN const DWORD dwErrorCode, 
    ...);

void
LogMessage(
    IN const TCHAR * szMessage
    );

typedef enum 
{
	eInfo = 0,
	eAction,
	eWarning,
	eError,
	eHeader,
	eUI,
	eUser
}TraceLevel;


void
DebugLogMsg(
	TraceLevel tl,
    IN LPCTSTR psz,
	...
    );

//
// Property pages routines
//
inline
int
SkipWizardPage(
    IN const HWND hdlg
    )
{
    SetWindowLongPtr(hdlg, DWLP_MSGRESULT, -1);
    return 1; //Must return 1 for the page to be skipped
}

INT_PTR
CALLBACK
MsmqTypeDlgProcWks(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    );

INT_PTR
CALLBACK
MsmqTypeDlgProcSrv(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    );

INT_PTR
CALLBACK
MsmqServerNameDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    );

INT_PTR
CALLBACK
WelcomeDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    );

INT_PTR
CALLBACK
FinalDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    );

INT_PTR
CALLBACK
AddWeakSecurityDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    );

INT_PTR
CALLBACK
RemoveWeakSecurityDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    );


INT_PTR
CALLBACK
DummyPageDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );


INT_PTR
CALLBACK
SupportingServerNameDlgProc(
    HWND hdlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    );


//
// Utilities and misc
//
BOOL
StpCreateDirectory(
    const std::wstring& PathName
    );

BOOL
StpCreateWebDirectory(
    IN const TCHAR* lpPathName,
	IN const WCHAR* IISAnonymousUserName
    );

BOOL
IsDirectory(
    IN const TCHAR * szFilename
    );

HRESULT
StpLoadDll(
    IN  const LPCTSTR   szDllName,
    OUT       HINSTANCE *pDllHandle
    );

BOOL 
SetRegistryValue (
    IN const HKEY    hKey, 
    IN const TCHAR   *pszEntryName,
    IN const DWORD   dwNumBytes,
    IN const DWORD   dwValueType,
    IN const PVOID   pValueData
    );

BOOL
MqOcmInstallPerfCounters();

BOOL
MqOcmRemovePerfCounters();

HRESULT 
CreateMappingFile();

// Five minute timeout for process termination
#define PROCESS_DEFAULT_TIMEOUT  ((DWORD)INFINITE)

DWORD
RunProcess(
	const std::wstring& FullPath,
	const std::wstring& CommandParams
    );  


std::wstring
ReadINIKey(
    LPCWSTR szKey
    );

inline
void
TickProgressBar(
    IN const UINT uProgressTextID = 0
    )
{
    if (uProgressTextID != 0)
    {
        CResString szProgressText(uProgressTextID);
        g_ComponentMsmq.HelperRoutines.SetProgressText(
            g_ComponentMsmq.HelperRoutines.OcManagerContext,
            szProgressText.Get()
            );
    }
    else
    {
        g_ComponentMsmq.HelperRoutines.TickGauge(g_ComponentMsmq.HelperRoutines.OcManagerContext) ;
    }
};

void 
DeleteFilesFromDirectoryAndRd( 
	const std::wstring& Directory
	);

void
GetGroupPath(
    IN const LPCTSTR szGroupName,
    OUT      LPTSTR  szPath
    );

VOID
DeleteStartMenuGroup(
    IN LPCTSTR szGroupName
    );

BOOL
StoreMachineSecurity(
    IN const GUID &guidMachine
    );

bool
StoreDefaultMachineSecurity();

BOOL
Msmq1InstalledOnCluster();

void WriteRegInstalledComponentsIfNeeded();

bool
IsWorkgroup();

bool
MqInit();


//
// Function to handle subcomponents
//

BOOL 
UnregisterSubcomponentForWelcome (
    DWORD SubcomponentIndex
    );

DWORD
GetSubcomponentWelcomeState (
    IN const TCHAR    *SubcomponentId
    );

BOOL
FinishToRemoveSubcomponent (
    DWORD SubcomponentIndex
    );

BOOL
FinishToInstallSubcomponent (
    DWORD SubcomponentIndex
    );

DWORD 
GetSubcomponentInitialState(
    IN const TCHAR    *SubcomponentId
    );

DWORD 
GetSubcomponentFinalState (
    IN const TCHAR    *SubcomponentId
    );

void
SetOperationForSubcomponents ();

DWORD 
GetSetupOperationBySubcomponentName (
    IN const TCHAR    *SubcomponentId
    );

void
VerifySubcomponentDependency();


void 
PostSelectionOperations(
    HWND hdlg
    );

void 
OcpRemoveWhiteSpaces(
    std::wstring& str
    );


bool IsADEnvironment();


RPC_STATUS PingAServer();


BOOL SkipOnClusterUpgrade();

BOOL
PrepareUserSID();

BOOL 
OcpRestartService(
	LPCWSTR strServiceName
	);

void SetWeakSecurity(bool fWeak);

bool 
OcmLocalAwareStringsEqual(
	LPCWSTR str1, 
	LPCWSTR str2
	);

bool 
OcmLocalUnAwareStringsEqual(
	LPCWSTR str1, 
	LPCWSTR str2
	);

std::wstring
OcmGetSystemWindowsDirectoryInternal();

void
SetDirectories();

std::wstring 
GetKeyName(
	const std::wstring& EntryName
	);

std::wstring
GetValueName(
	const std::wstring& EntryName
	);


CMultiString
GetMultistringFromRegistry(
	HKEY hKey,
    LPCWSTR lpValueName
    );

void 
LogRegValue(
    std::wstring  EntryName,
    const DWORD   dwValueType,
    const PVOID   pValueData,
    const BOOL bSetupRegSection
    );


class CMultiString
{
public:
	CMultiString(){}

	CMultiString(LPCWSTR c, size_t size):m_multi(c, size - 1){}
	
	void Add(const std::wstring& str)
	{
		m_multi += str;
		m_multi.append(1, L'\0');
	}

	LPCWSTR Data()
	{
		return m_multi.c_str();
	}

	size_t Size()
	{
		return (m_multi.length() + 1);
	}

	size_t FindSubstringPos(const std::wstring& str)
	{
		//
		// Construct the string str0
		//
		std::wstring CopyString = str;
		CopyString.append(1, L'\0');

		size_t pos = m_multi.find(CopyString, 0);

		//
		// This is the first string in the multistring.
		//
		if(pos == 0)
		{
			return pos;
		}

		//
		// Construct 0str0
		//
		CopyString.insert(0, L'\0');

		pos = m_multi.find(CopyString, 0);
		if(pos  == std::wstring::npos)
		{
			return pos;
		}

		//
		// Add 1 to pos to make up for the '0' added to str.
		//
		return(pos + 1);
	}


	bool IsSubstring(const std::wstring& str)
	{
		size_t pos = FindSubstringPos(str);
		if(pos == std::wstring::npos)
		{
			return false;
		}
		return true;
	}


	bool RemoveSubstring(const std::wstring& str)
	{
		size_t pos = FindSubstringPos(str);
		if(pos == std::wstring::npos)
		{
			return false;
		}
		m_multi.erase(pos, str.length() + 1);
		return true;
	}

	
	size_t CaseInsensitiveFind(std::wstring str)
	{
		std::wstring UperMulti(m_multi.c_str(), m_multi.size());
		CharUpperBuff(const_cast<WCHAR*>(UperMulti.c_str()), (DWORD)(UperMulti.length()));
		CharUpperBuff(const_cast<WCHAR*>(str.c_str()), (DWORD)(str.length()));
		return UperMulti.find(str, 0);
	}


	bool RemoveContiningSubstring(const std::wstring& str)
	/*++
		Removes the first multistring element that str is a subltring of.
	--*/
	{
		size_t pos = CaseInsensitiveFind(str);
		if(pos == std::wstring::npos)
		{
			return false;
		}

		//
		// Find begining of the element.
		//

		for(size_t start = pos; start > 0; --start)
		{
			if(m_multi[start] == 0)
			{
				start++;
				break;
			}
		}

		//
		// Find end of element.
		//

		for(size_t end = pos; m_multi[end] != 0; ++end)
		{
		}

		//
		// Remove the element.
		//
		m_multi.erase(start, end - start + 1);
		return true;
	}
	

	void RemoveAllContiningSubstrings(const std::wstring& str)
	{
		while(RemoveContiningSubstring(str))
		{
		}
	}

		
	void RemoveAllApearences(const std::wstring& str)
	{
		while(RemoveSubstring(str))
		{
		}
	}

	WCHAR& operator[](int pos)
	{
		return m_multi[pos];
	}

private:
	std::wstring m_multi;
};


#endif  //#ifndef _MSMQOCM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\ocminit.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocminit.cpp

Abstract:

    Code for initialization of OCM setup.

Author:

    Doron Juster  (DoronJ)   7-Oct-97  

Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include "Cm.h"
#include "cancel.h"

#include "ocminit.tmh"

extern MQUTIL_EXPORT CCancelRpc g_CancelRpc;

static
void
SetDirectoryIDInternal(
	DWORD Id,     
	const std::wstring& Directory 
	)
{
	if(!SetupSetDirectoryId(
			g_ComponentMsmq.hMyInf,  // handle to the INF file
			Id,        // optional, DIRID to assign to Directory
			Directory.c_str() // optional, directory to map to identifier
			))
    {
        DWORD gle = GetLastError();
		DebugLogMsg(eError, L"Setting the folder ID for %s failed. SetupSetDirectoryId returned %d.", Directory.c_str(), gle);
        throw bad_win32_error(gle);
    }
    DebugLogMsg(eInfo, L"The folder ID for %s was set.", Directory.c_str());
}


//+-------------------------------------------------------------------------
//
//  Function:   SetDirectories
//
//  Synopsis:   Generate MSMQ specific directory names and set directory IDs.
//				These IDs correspond to IDs in inf file, and this is how the
//				link is made between names in inf file and actual directories.
//
//--------------------------------------------------------------------------
void
SetDirectories()
{    
    DebugLogMsg(eAction, L"Setting the Message Queuing folders");

    //
    // Set root dir for MSMQ
    //
	g_szMsmqDir = g_szSystemDir + DIR_MSMQ;
	DebugLogMsg(eInfo, L"The Message Queuing folder was set to %s.", g_szMsmqDir.c_str());

	//
	// Setting folder ID for the Message Queuing folder.
	//
    SetDirectoryIDInternal(
		idMsmqDir, 
		g_szMsmqDir
		);

    //
    // Set the exchange connector dir of MSMQ1 / MSMQ2-beta2
    // Do we need it for Whistler?
    //
    SetDirectoryIDInternal( 
		idExchnConDir, 
		g_szMsmqDir + OCM_DIR_MSMQ_SETUP_EXCHN
		);

    //
    // Set the storage dir
    //
    SetDirectoryIDInternal( 
		idStorageDir, 
		g_szMsmqDir + DIR_MSMQ_STORAGE
		);

    //
    // Set the mapping dir
    //
    g_szMsmqMappingDir = g_szMsmqDir + DIR_MSMQ_MAPPING;                                        
    SetDirectoryIDInternal( 
		idMappingDir, 
		g_szMsmqMappingDir
		);

    //
    // Set directories for MSMQ1 files
	//
    // Setting the folder ID for the MSMQ 1.0 setup folder:
	//
	g_szMsmq1SetupDir = g_szMsmqDir + OCM_DIR_SETUP;
    SetDirectoryIDInternal( 
		idMsmq1SetupDir,
		g_szMsmq1SetupDir
		);

	//
	// Setting the folder ID for the MSMQ 1.0 SDK debug folder:
	//
	g_szMsmq1SdkDebugDir = g_szMsmqDir + OCM_DIR_SDK_DEBUG;
    SetDirectoryIDInternal( 
		idMsmq1SDK_DebugDir,
		g_szMsmq1SdkDebugDir
		);

    DebugLogMsg(eInfo, L"The Message Queuing folder IDs were set.");
} // SetDirectories


//+-------------------------------------------------------------------------
//
//  Function:   CheckMsmqK2OnCluster
//
//  Synopsis:   Checks if we're upgrading MSMQ 1.0 K2 on cluster to NT 5.0.
//              This is special because of bug 2656 (registry corrupt).
//              Result is stored in g_fMSMQAlreadyInstalled.
//
//  Returns:    BOOL dependes on success.  
//
//--------------------------------------------------------------------------
static
BOOL
CheckMsmqK2OnCluster()
{    
    DebugLogMsg(eAction, L"Checking for installed components in an MSMQ 1.0 K2 cluster installation");

    //
    // Read type of MSMQ from MachineCache\MQS
    //
    DWORD dwType = SERVICE_NONE;
    if (!MqReadRegistryValue(
             MSMQ_MQS_REGNAME,
             sizeof(DWORD),
             (PVOID) &dwType
             ))
    {
        //
        // MSMQ installed but failed to read its type
        //
        MqDisplayError(NULL, IDS_MSMQ1TYPEUNKNOWN_ERROR, 0);
        return FALSE;
    }

    g_dwMachineType = dwType;
    g_fMSMQAlreadyInstalled = TRUE;
    g_fUpgrade = (0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE));
    g_fServerSetup = FALSE;
    g_uTitleID = IDS_STR_CLI_ERROR_TITLE;
    g_fDependentClient = FALSE;

    switch (dwType)
    {
        case SERVICE_PEC:
        case SERVICE_PSC:
        case SERVICE_BSC:
            g_dwDsUpgradeType = dwType;
            g_dwMachineTypeDs = 1;
            g_dwMachineTypeFrs = 1;
            //
            // Fall through
            //
        case SERVICE_SRV:
            g_fServerSetup = TRUE;
            g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
            g_dwMachineTypeDs = 0;
            g_dwMachineTypeFrs = 1;
            break;

        case SERVICE_RCS:
            g_fServerSetup = TRUE;
            g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
            g_dwMachineTypeDs = 0;
            g_dwMachineTypeFrs = 0;
            break;

        case SERVICE_NONE:
            g_dwMachineTypeDs = 0;
            g_dwMachineTypeFrs = 0;
            break;

        default:
            MqDisplayError(NULL, IDS_MSMQ1TYPEUNKNOWN_ERROR, 0);
            return FALSE;
            break;
    }

	DebugLogMsg(eInfo, L"TypeFrs = %d, TypeDs = %d", g_dwMachineTypeFrs, g_dwMachineTypeDs);
    return TRUE;

} //CheckMsmqK2OnCluster

//
// Macros used to convert MAX_PATH into the string '260' 
//
#define FROM_NUM(n) L#n
#define TO_STR(n) FROM_NUM(n)


//+-------------------------------------------------------------------------
//
//  Function:   CheckWin9xUpgrade
//
//  Synopsis:   Checks if we're upgrading Win9x with MSMQ 1.0 to NT 5.0.
//              Upgrading Win9x is special because registry settings
//              can not be read during GUI mode. Therefore we use a special
//              migration DLL during the Win95 part of NT 5.0 upgrade.
//
//              Result is stored in g_fMSMQAlreadyInstalled.
//
//  Returns:    BOOL dependes on success.  
//
//--------------------------------------------------------------------------
static
BOOL
CheckWin9xUpgrade()
{    
    DebugLogMsg(eAction, L"Checking for a Windows 9x installation");

    //
    // If this is not OS upgrade from Win95, we got nothing to do here
    //

    if (!(g_ComponentMsmq.Flags & SETUPOP_WIN95UPGRADE))
    {
        return TRUE;
    }

    //
    // Generate the info file name (under %WinDir%).
    // The file was created by MSMQ migration DLL during the
    // Win95 part of NT 5.0 upgrade.
    //
	std::wstring szMsmqInfoFile = OcmGetSystemWindowsDirectoryInternal() + L"\\" + MQMIG95_INFO_FILENAME;

    //
    // MQMIG95_INFO_FILENAME (msmqinfo.txt) is actually a .ini file. However we do not read it using 
    // GetPrivateProfileString because it is not trustable in GUI-mode setup 
    // (YoelA - 15-Mar-99)
    //
    FILE *stream = _tfopen(szMsmqInfoFile.c_str(), TEXT("r"));
    if (0 == stream)
    {
        //
        // Info file not found. That means MSMQ 1.0 is not installed
        // on this machine. Log it.
        // 
        MqDisplayError(NULL, IDS_MSMQINFO_NOT_FOUND_ERROR, 0);
        return TRUE;
    }

    //
    // First line should be [msmq]. Check it.
    //
    WCHAR szToken[MAX_PATH + 1];
    //
    // "[%[^]]s" - Read the string between '[' and ']' (start with '[', read anything that is not ']')
    //

    int iScanResult = fwscanf(stream, L"[%" TO_STR(MAX_PATH) L"[^]]s", szToken);
    if ((iScanResult == 0 || iScanResult == EOF || iScanResult == WEOF) ||
        (_tcscmp(szToken, MQMIG95_MSMQ_SECTION) != 0))
    {
        //
        // File is currupted. Either a pre-mature EOF, or first line is not [msmq[
        //
        MqDisplayError(NULL, IDS_MSMQINFO_HEADER_ERROR, 0);
        return TRUE;

    }

    //
    // The first line is in format "directory = xxxx". We first prepate a format string,
    // And then read according to that format.
    // The format string will look like "] directory = %[^\r\n]s" - start with ']' (last 
    // character in header), then whitespaces (newlines, etc), then 'directory =', and
    // from then take everything till the end of line (not \r or \n).
    //
    LPCWSTR szInFormat = L"] " MQMIG95_MSMQ_DIR L" = %" TO_STR(MAX_PATH) L"[^\r\n]s";
	
	WCHAR MsmqDirBuffer[MAX_PATH + 1];
	iScanResult = fwscanf(stream, szInFormat, MsmqDirBuffer);
	g_szMsmqDir = MsmqDirBuffer;
    
	if (iScanResult == 0 || iScanResult == EOF || iScanResult == WEOF)
    {
        //
        // We did not find the "directory =" section. file is corrupted
        //
        MqDisplayError(NULL, IDS_MSMQINFO_DIRECTORY_KEY_ERROR, 0);
        return TRUE;
    }

    //
    // The second line is in format "type = xxx" (after white spaces)
    //
	WCHAR szType[MAX_PATH + 1];
    szInFormat = L" " MQMIG95_MSMQ_TYPE L" = %" TO_STR(MAX_PATH) L"[^\r\n]s";
    iScanResult =fwscanf(stream, szInFormat, szType);
    if (iScanResult == 0 || iScanResult == EOF || iScanResult == WEOF)
    {
        //
        // We did not find the "type =" section. file is corrupted
        //
        MqDisplayError(NULL, IDS_MSMQINFO_TYPE_KEY_ERROR, 0);
        return TRUE;
    }

    fclose( stream );
    //
    // At this point we know that MSMQ 1.0 is installed on the machine,
    // and we got its root directory and type.
    //
    g_fMSMQAlreadyInstalled = TRUE;
    g_fUpgrade = TRUE;
    g_fServerSetup = FALSE;
    g_uTitleID = IDS_STR_CLI_ERROR_TITLE;
    g_dwMachineType = SERVICE_NONE;
    g_dwMachineTypeDs = 0;
    g_dwMachineTypeFrs = 0;
    g_fDependentClient = OcmLocalUnAwareStringsEqual(szType, MQMIG95_MSMQ_TYPE_DEP);
    MqDisplayError(NULL, IDS_WIN95_UPGRADE_MSG, 0);

    return TRUE;

} // CheckWin9xUpgrade


//+-------------------------------------------------------------------------
//
//  Function:   CheckMsmqAcmeInstalled
//
//  Synopsis:   Checks if MSMQ 1.0 (ACME) is installed on this computer.
//              Result is stored in g_fMSMQAlreadyInstalled.
//
//  Returns:    BOOL dependes on success.  
//
//--------------------------------------------------------------------------
static
BOOL
CheckMsmqAcmeInstalled()
{    
    DebugLogMsg(eAction, L"Checking for installed components of MSMQ 1.0 ACME");

    //
    // Open ACME registry key
    //
    HKEY hKey ;
    LONG rc = RegOpenKeyEx( 
                  HKEY_LOCAL_MACHINE,
                  ACME_KEY,
                  0L,
                  KEY_ALL_ACCESS,
                  &hKey 
                  );
    if (rc != ERROR_SUCCESS)
    {        
        DebugLogMsg(eInfo, L"The ACME registry key could not be opened. MSMQ 1.0 ACME was not found.");
        return TRUE;
    }

    //
    // Enumerate the values for the first MSMQ entry.
    //
    DWORD dwIndex = 0 ;
    TCHAR szValueName[MAX_STRING_CHARS] ;
    TCHAR szValueData[MAX_STRING_CHARS] ;
    DWORD dwType ;
    TCHAR *pFile, *p;
    BOOL  bFound = FALSE;
    do
    {
        DWORD dwNameLen = MAX_STRING_CHARS;
        DWORD dwDataLen = sizeof(szValueData) ;

        rc =  RegEnumValue( 
                  hKey,
                  dwIndex,
                  szValueName,
                  &dwNameLen,
                  NULL,
                  &dwType,
                  (BYTE*) szValueData,
                  &dwDataLen 
                  );
        if (rc == ERROR_SUCCESS)
        {
            ASSERT(dwType == REG_SZ) ; // Must be a string
            pFile = _tcsrchr(szValueData, TEXT('\\')) ;
            if (!pFile)
            {
                //
                // Bogus entry. Must have a backslash. Ignore it.
                //
                continue ;
            }

            p = CharNext(pFile);
            if (OcmLocalUnAwareStringsEqual(p, ACME_STF_NAME))
            {
                //
                // Found. Cut the STF file name from the full path name.
                //
                *pFile = TEXT('\0') ;
                bFound = TRUE;                
                DebugLogMsg(eInfo, L"MSMQ 1.0 ACME was found.");

                //
                // Delete the MSMQ entry
                //
                RegDeleteValue(hKey, szValueName); 
            }
            else
            {
                pFile = CharNext(pFile) ;
            }

        }
        dwIndex++ ;

    } while (rc == ERROR_SUCCESS) ;
    RegCloseKey(hKey) ;

    if (!bFound)
    {
        //
        // MSMQ entry was not found.
        //        
        DebugLogMsg(eInfo, L"MSMQ 1.0 ACME was not found.");
        return TRUE;
    }

    //
    // Remove the "setup" subdirectory from the path name.
    //
    pFile = _tcsrchr(szValueData, TEXT('\\')) ;
    p = CharNext(pFile);
    *pFile = TEXT('\0') ;
    if (!OcmLocalUnAwareStringsEqual(p, ACME_SETUP_DIR_NAME))
    {
        //
        // That's a problem. It should have been "setup".
        // Consider ACME installation to be corrupted (not completed successfully).
        //        
        DebugLogMsg(eWarning, L"MSMQ 1.0 ACME is corrupted.");
        return TRUE;
    }

    g_szMsmqDir = szValueData;
	DebugLogMsg(eInfo, L"The Message Queuing folder was set to %s.", g_szMsmqDir.c_str());

    //
    // Check MSMQ type (client, server etc.)
    //
    DWORD dwMsmqType;
    BOOL bResult = MqReadRegistryValue(
                       MSMQ_ACME_TYPE_REG,
                       sizeof(DWORD),
                       (PVOID) &dwMsmqType
                       );
    if (!bResult)
    {
        //
        // MSMQ 1.0 (ACME) is installed but MSMQ type is unknown. 
        //
        MqDisplayError(NULL, IDS_MSMQ1TYPEUNKNOWN_ERROR, 0);
        return FALSE;
    }

    g_fMSMQAlreadyInstalled = TRUE;
    g_fUpgrade = (0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE));
    g_fServerSetup = FALSE;
    g_uTitleID = IDS_STR_CLI_ERROR_TITLE;
    g_dwMachineType = SERVICE_NONE;
    g_dwMachineTypeDs = 0;
    g_dwMachineTypeFrs = 0;
    g_fDependentClient = FALSE;
    switch (dwMsmqType)
    {
        case MSMQ_ACME_TYPE_DEP:
        {
            g_fDependentClient = TRUE;
            break;
        }
        case MSMQ_ACME_TYPE_IND:
        {
            break;
        }
        case MSMQ_ACME_TYPE_RAS:
        {
            g_fServerSetup = TRUE;
            g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
            g_dwMachineType = SERVICE_RCS;
            break;
        }
        case MSMQ_ACME_TYPE_SRV:
        {
            g_fServerSetup = TRUE;
            g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
            DWORD dwServerType = SERVICE_NONE;
            bFound = MqReadRegistryValue(
                         MSMQ_MQS_REGNAME,
                         sizeof(DWORD),
                         (PVOID) &dwServerType
                         );
            switch (dwServerType)
            {
                case SERVICE_PEC:
                case SERVICE_PSC:
                case SERVICE_BSC:
                {
                    g_dwMachineType = SERVICE_DSSRV;
                    g_dwDsUpgradeType = dwServerType;
                    g_dwMachineTypeDs = 1;
                    g_dwMachineTypeFrs = 1;
                    break;
                }    
                case SERVICE_SRV:
                {
                    g_dwMachineType = SERVICE_SRV;
                    g_dwMachineTypeDs = 0;
                    g_dwMachineTypeFrs = 1;
                    break;
                }
                default:
                {
                    //
                    // Unknown MSMQ 1.0 server type. 
                    //
                    MqDisplayError(NULL, IDS_MSMQ1SERVERUNKNOWN_ERROR, 0);
                    return FALSE;
                    break ;
                }
            }
            break;
        }
        default:
        {
            //
            // Unknown MSMQ 1.0 type
            //
            MqDisplayError(NULL, IDS_MSMQ1TYPEUNKNOWN_ERROR, 0);
            return FALSE;
            break;
        }
    }

    return TRUE;

} // CheckMsmqAcmeInstalled

static
bool
ReadMSMQ2Beta3OrLaterDirectoryFromRegistry()
{
	g_szMsmqDir = MqReadRegistryStringValue(MSMQ_ROOT_PATH);
	if(g_szMsmqDir.empty())
	{
		g_szMsmqDir = MqReadRegistryStringValue(
							REG_DIRECTORY, 
							/* bSetupRegSection = */TRUE
							);
		if(g_szMsmqDir.empty())
		{
			MqDisplayError(NULL, IDS_MSMQROOTNOTFOUND_ERROR, 0); 
			return false;
		}
	}

	DebugLogMsg(eInfo, L"The Message Queuing folder was set to %s.", g_szMsmqDir.c_str());
	return true;
}


static
bool
ReadMSMQ2Beta2OrMSMQ1K2DirectoryFromRegistry()
{
	g_szMsmqDir = MqReadRegistryStringValue(OCM_REG_MSMQ_DIRECTORY);
	if(g_szMsmqDir.empty())
	{
		MqDisplayError(NULL, IDS_MSMQROOTNOTFOUND_ERROR, 0); 
		return false;
	}

	DebugLogMsg(eInfo, L"The Message Queuing folder was set to %s.", g_szMsmqDir.c_str());
	return true;
}


static
bool 
ReadDsValueFromRegistery()
{
	if (!MqReadRegistryValue(
             MSMQ_MQS_DSSERVER_REGNAME,
             sizeof(DWORD),
             (PVOID)&g_dwMachineTypeDs
             ))                  
    {
    	DebugLogMsg(eWarning, L"The " MSMQ_MQS_DSSERVER_REGNAME L" registry value could not be read.");
    	return false;
    }
	return true;
}


static
bool
ReadRsValueFromRegistery()
{
    if(!MqReadRegistryValue(
	         MSMQ_MQS_ROUTING_REGNAME,
	         sizeof(DWORD),
	         (PVOID)&g_dwMachineTypeFrs
	         ))
    {
    	DebugLogMsg(eWarning, L"The " MSMQ_MQS_ROUTING_REGNAME L" registry value could not be read.");
       	return false;
    }
    return true;
}


static BOOL CheckInstalledCompnentsFormMsmsq2Beta3AndLater(DWORD dwOriginalInstalled)
{
    //
    // MSMQ 2.0 Beta 3 or later is installed.
    // Read MSMQ type and directory from registry
    //
    // Note: to improve performance (shorten init time) we can do these
    // reads when we actually need the values (i.e. later, not at init time).
    //

    DebugLogMsg(eInfo, L"Message Queuing 2.0 Beta3 or later is installed. InstalledComponents = 0x%x", dwOriginalInstalled);

   	if(!ReadMSMQ2Beta3OrLaterDirectoryFromRegistry())
	{
		return false;
	}

    if(!ReadDsValueFromRegistery() || !ReadRsValueFromRegistery())
    {
        //
        // This could be okay if dependent client is installed
        //
        
        if (OCM_MSMQ_DEP_CLIENT_INSTALLED != (dwOriginalInstalled & OCM_MSMQ_INSTALLED_TOP_MASK))
        {
            MqDisplayError(NULL, IDS_MSMQTYPEUNKNOWN_ERROR, 0);
            return FALSE;
        }
        ASSERT(g_dwMachineTypeFrs == 0);
        ASSERT(g_dwMachineTypeDs == 0);
    }

    g_fUpgrade = (0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE));        
    g_fMSMQAlreadyInstalled = TRUE;
    g_fServerSetup = FALSE;
    g_uTitleID = IDS_STR_CLI_ERROR_TITLE ;
    g_dwMachineType = SERVICE_NONE;
    g_fDependentClient = FALSE;
    switch (dwOriginalInstalled & OCM_MSMQ_INSTALLED_TOP_MASK)
    {
        case OCM_MSMQ_DEP_CLIENT_INSTALLED:
        	DebugLogMsg(eInfo, L"A dependent client is installed.");
            g_fDependentClient = TRUE;
            break;

        case OCM_MSMQ_IND_CLIENT_INSTALLED:
        	DebugLogMsg(eInfo, L"An independent client is installed.");
            break;
        
        case OCM_MSMQ_SERVER_INSTALLED:
	        DebugLogMsg(eInfo, L"A Message Queuing server is installed. TypeFrs = %d, TypeDs = %d", g_dwMachineTypeFrs, g_dwMachineTypeDs);
            g_fServerSetup = TRUE;
            g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
            switch (dwOriginalInstalled & OCM_MSMQ_SERVER_TYPE_MASK)
            {
                case OCM_MSMQ_SERVER_TYPE_PEC:
                case OCM_MSMQ_SERVER_TYPE_PSC:
                case OCM_MSMQ_SERVER_TYPE_BSC:
			        DebugLogMsg(eInfo, L"A Message Queuing server is installed. MachineType = SERVICE_DSSRV");
                    g_dwMachineType = SERVICE_DSSRV;
                    break;

                case OCM_MSMQ_SERVER_TYPE_SUPPORT:
			        DebugLogMsg(eInfo, L"A Message Queuing server is installed. MachineType = SERVICE_SRV");
                    g_dwMachineType = SERVICE_SRV;
                    break ;

                default:
                    //
					// For SERVICE_NONE The obvious condition is (!Ds && !Frs)
					// But there might be cases that MachineTypeDs = true 
					// although OriginalInstalled shows we are SERVICE_NONE.
					// The 2 cases are:
					// 1) After dcpromo we became a DS server (no one is updating OriginalInstall registry on dcpromo).
					// 2) Previous installation might marked SERVICE_NONE when DS was installed without FRS.
					//
					if (!g_dwMachineTypeFrs)
					{
				        DebugLogMsg(eInfo, L"A Message Queuing server is installed. MachineType = SERVICE_NONE");
						g_dwMachineType = SERVICE_NONE;
						break;
					}

                    MqDisplayError(NULL, IDS_MSMQSERVERUNKNOWN_ERROR, 0);
					return FALSE;
                    break ;
            }
            break;
        
        case OCM_MSMQ_RAS_SERVER_INSTALLED:
        	DebugLogMsg(eInfo, L"A Message Queuing RAS Server is installed.");
            g_fServerSetup = TRUE;
            g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
            g_dwMachineType = SERVICE_RCS;
            break;

        default:
            MqDisplayError(NULL, IDS_MSMQTYPEUNKNOWN_ERROR, 0);
            return FALSE;
            break;
    }
    return TRUE;
}


static BOOL CheckInstalledCompnentsFormMsmsq2Beta2OrMsmq1K2(DWORD dwOriginalInstalled)
{
    //
    // MSMQ 2.0 beta2 or MSMQ 1.0 k2 is installed.
    // Read MSMQ type and directory from registry
    //

   	DebugLogMsg(eInfo, L"Message Queuing 2.0 Beta2 or MSMQ 1.0 K2 is installed. InstalledComponents = 0x%x", dwOriginalInstalled);

	if(!ReadMSMQ2Beta2OrMSMQ1K2DirectoryFromRegistry())
	{
		return false;
	}

    g_fMSMQAlreadyInstalled = TRUE;
    g_fUpgrade = (0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE));
    g_fServerSetup = FALSE;
    g_uTitleID = IDS_STR_CLI_ERROR_TITLE ;
    g_dwMachineType = SERVICE_NONE;
    g_dwMachineTypeDs = 0;
    g_dwMachineTypeFrs = 0;
    g_fDependentClient = FALSE;
    switch (dwOriginalInstalled & OCM_MSMQ_INSTALLED_TOP_MASK)
    {
        case OCM_MSMQ_DEP_CLIENT_INSTALLED:
            g_fDependentClient = TRUE;
            break;

        case OCM_MSMQ_IND_CLIENT_INSTALLED:
            break;

        case OCM_MSMQ_SERVER_INSTALLED:
            g_fServerSetup = TRUE;
            g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
            switch (dwOriginalInstalled & OCM_MSMQ_SERVER_TYPE_MASK)
            {
                case OCM_MSMQ_SERVER_TYPE_PEC:
                    g_dwDsUpgradeType = SERVICE_PEC;
                    g_dwMachineType   = SERVICE_DSSRV;
                    g_dwMachineTypeDs = 1;
                    g_dwMachineTypeFrs = 1;
                    break;

                case OCM_MSMQ_SERVER_TYPE_PSC:
                    g_dwDsUpgradeType = SERVICE_PSC;
                    g_dwMachineType   = SERVICE_DSSRV;
                    g_dwMachineTypeDs = 1;
                    g_dwMachineTypeFrs = 1;
                    break;

                case OCM_MSMQ_SERVER_TYPE_BSC:
                    g_dwDsUpgradeType = SERVICE_BSC;
                    g_dwMachineType = SERVICE_DSSRV;
                    g_dwMachineTypeDs = 1;
                    g_dwMachineTypeFrs = 1;
                    break;

                case OCM_MSMQ_SERVER_TYPE_SUPPORT:
                    g_dwMachineType = SERVICE_SRV;
                    g_dwMachineTypeFrs = 1;
                    break ;

                default:
                    MqDisplayError(NULL, IDS_MSMQSERVERUNKNOWN_ERROR, 0);
                    return FALSE;
                    break ;
            }
            break;
        
        case OCM_MSMQ_RAS_SERVER_INSTALLED:
            g_fServerSetup = TRUE;
            g_uTitleID = IDS_STR_SRV_ERROR_TITLE;
            g_dwMachineType = SERVICE_RCS;
            break;

        default:
            MqDisplayError(NULL, IDS_MSMQTYPEUNKNOWN_ERROR, 0);
            return FALSE;
            break;
    }
	TCHAR szMsmqVersion[MAX_STRING_CHARS] = {0};
    if (MqReadRegistryValue(
    		OCM_REG_MSMQ_PRODUCT_VERSION,
            sizeof(szMsmqVersion),
            (PVOID) szMsmqVersion
            ))
    {
        //
        // Upgrading MSMQ 2.0 beta 2, don't upgrade DS
        //
        g_dwDsUpgradeType = 0;
    }
	return TRUE;
}


static 
bool 
IsMSMQK2ClusterUpgrade()
{
    //
    // Check in registry if there is MSMQ installation on cluster
    //
    if (!Msmq1InstalledOnCluster())
    {        
        DebugLogMsg(eInfo, L"MSMQ 1.0 is not installed in the cluster.");
        return false;
    }

    //
    // Read the persistent storage directory from registry.
    // MSMQ directory will be one level above it.
    // This is a good enough workaround since storage directory is
    // always on a cluster shared disk.
    //
	WCHAR buffer[MAX_PATH + 1] = L""; 
    if (!MqReadRegistryValue(
             MSMQ_STORE_PERSISTENT_PATH_REGNAME,
             sizeof(buffer)/sizeof(buffer[0]),
             (PVOID)buffer
             ))
    {        
        DebugLogMsg(eInfo, L"The persistent storage path could not be read from the registry. MSMQ 1.0 was not found.");
        return false;
    }

    TCHAR * pChar = _tcsrchr(buffer, TEXT('\\'));
    if (pChar)
    {
        *pChar = TEXT('\0');
    }
	g_szMsmqDir = buffer;
	DebugLogMsg(eInfo, L"The Message Queuing folder was set to %s.", g_szMsmqDir.c_str());
	return true;
}

	
//+-------------------------------------------------------------------------
//
//  Function:   CheckInstalledComponents
//
//  Synopsis:   Checks if MSMQ is already installed on this computer
//
//  Returns:    BOOL dependes on success. The result is stored in 
//              g_fMSMQAlreadyInstalled.
//
//--------------------------------------------------------------------------
static
BOOL
CheckInstalledComponents()
{
    g_fMSMQAlreadyInstalled = FALSE;
    g_fUpgrade = FALSE;
    DWORD dwOriginalInstalled = 0;
    
    DebugLogMsg(eAction, L"Checking for installed components");

    if (IsMSMQK2ClusterUpgrade())
    {
	    //
    	// Special case: workaround for bug 2656, registry corrupt for msmq1 k2 on cluster
    	// We check this first because the registry was set during gui mode, so it 
    	// could apear that msmq3 is installed.
    	//
    	return CheckMsmqK2OnCluster();
    }
 
    if (MqReadRegistryValue( 
            REG_INSTALLED_COMPONENTS,
            sizeof(DWORD),
            (PVOID) &dwOriginalInstalled,
            /* bSetupRegSection = */TRUE
            ))
    {
		return CheckInstalledCompnentsFormMsmsq2Beta3AndLater(dwOriginalInstalled);
    } // MSMQ beta 3 or later


#ifndef _DEBUG
    //
    // If we're not in OS setup, don't check older versions (beta2, msmq1, etc).
    // This is a *little* less robust (we expect the user to upgrade msmq only thru OS
    // upgrade), but decrease init time (ShaiK, 25-Oct-98)
    //
    // In we are running as a post-upgrade-on-cluster wizard, do check for old versions.
    //
    if (!g_fWelcome || !Msmq1InstalledOnCluster())
    {
        if (0 != (g_ComponentMsmq.Flags & SETUPOP_STANDALONE))
        {            
            DebugLogMsg(eInfo, L"Message Queuing 2.0 Beta3 or later is NOT installed. The checking for other versions will be skipped.");            
            DebugLogMsg(eInfo, L"Message Queuing is considered NOT installed on this computer.");
            return TRUE;
        }
    }
#endif //_DEBUG

    if (MqReadRegistryValue( 
            OCM_REG_MSMQ_SETUP_INSTALLED,
            sizeof(DWORD),
            (PVOID) &dwOriginalInstalled
            ))
    {
		return CheckInstalledCompnentsFormMsmsq2Beta2OrMsmq1K2(dwOriginalInstalled);
    } // MSMQ 2.0 or MSMQ 1.0 k2


    //
    // Check if MSMQ 1.0 (ACME) is installed
    //
    BOOL bRetCode = CheckMsmqAcmeInstalled();
    if (g_fMSMQAlreadyInstalled)
        return bRetCode;
    
    //
    // Special case: check if this is MSMQ 1.0 on Win9x upgrade
    //
    bRetCode = CheckWin9xUpgrade();
    if (g_fMSMQAlreadyInstalled)
        return bRetCode;

    return TRUE;
} // CheckInstalledComponents

static void LogSetupData(PSETUP_INIT_COMPONENT pInitComponent)
{
    DebugLogMsg(eInfo, 
    	L"Dump of OCM flags: ProductType = 0x%x, SourcePath = %s, OperationFlags = 0x%x",
    	pInitComponent->SetupData.ProductType, 
    	pInitComponent->SetupData.SourcePath,
    	pInitComponent->SetupData.OperationFlags
    	);

    DWORDLONG OperationFlags = pInitComponent->SetupData.OperationFlags;
   	if(OperationFlags & SETUPOP_WIN95UPGRADE)
	{
		DebugLogMsg(eInfo, L"This is an upgrade from Windows 9x.");
	}

	if(OperationFlags & SETUPOP_NTUPGRADE)
	{
		DebugLogMsg(eInfo, L"This is an upgrade from Windows NT.");
	}

	if(OperationFlags & SETUPOP_BATCH)
	{
		DebugLogMsg(eInfo, L"This is an unattended setup.");
	}

	if(OperationFlags & SETUPOP_STANDALONE)
	{
		DebugLogMsg(eInfo, L"This is a stand-alone setup.");
	}
}

static bool s_fInitCancelThread = false;

//+-------------------------------------------------------------------------
//
//  Function:   MqOcmInitComponent
//
//  Synopsis:   Called by MsmqOcm() on OC_INIT_COMPONENT
//				this is the main initialization routine 
//				for the MSMQ component. It is called only 
//				once by OCM.
//
//  Arguments:  ComponentId    -- name of the MSMQ component
//              Param2         -- pointer to setup info struct
//
//  Returns:    Win32 error code
//
//--------------------------------------------------------------------------
DWORD 
InitMSMQComponent( 
    IN     const LPCTSTR ComponentId,
    IN OUT       PVOID   Param2 )
{ 
    DebugLogMsg(eHeader, L"Initialization");
	DebugLogMsg(eInfo, L"ComponentId = %d", ComponentId);

    //
    // Store per component info
    //
    PSETUP_INIT_COMPONENT pInitComponent = (PSETUP_INIT_COMPONENT)Param2;
    g_ComponentMsmq.hMyInf = pInitComponent->ComponentInfHandle;
    g_ComponentMsmq.dwProductType = pInitComponent->SetupData.ProductType;
    g_ComponentMsmq.HelperRoutines = pInitComponent->HelperRoutines;
    g_ComponentMsmq.Flags = pInitComponent->SetupData.OperationFlags;
    g_ComponentMsmq.SourcePath = pInitComponent->SetupData.SourcePath;
    g_ComponentMsmq.ComponentId = ComponentId;

	LogSetupData(pInitComponent);

    
    if (!s_fInitCancelThread)
    {
		try
		{
			g_CancelRpc.Init();
			s_fInitCancelThread = true;
		}
		catch(const exception&)
		{
			g_fCancelled = TRUE;       
			DebugLogMsg(eError, L"Setup failed to initialize. Setup will not continue.");
			return NO_ERROR;
		}
    }

    if (INVALID_HANDLE_VALUE == g_ComponentMsmq.hMyInf)
    {
       g_fCancelled = TRUE;       
       DebugLogMsg(eError, L"The value of the handle for Msmqocm.inf is invalid. Setup will not continue.");
       return NO_ERROR;
    }

    if (0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE))
    {
        //
        // OS setup - don't show UI
        //        
        DebugLogMsg(eInfo, L"This is an OS setup.");
        g_fBatchInstall = TRUE;
    }

    //
    // Check if wer'e in unattended mode.
    //
    if (g_ComponentMsmq.Flags & SETUPOP_BATCH)
    {
        g_fBatchInstall = TRUE;
        g_ComponentMsmq.UnattendFile = pInitComponent->SetupData.UnattendFile;
        DebugLogMsg(eInfo, L"Setup is running in unattended mode. The answer file is %s.", g_ComponentMsmq.UnattendFile.c_str());
    }

    //
    // Append layout inf file to our inf file
    //
    SetupOpenAppendInfFile( 0, g_ComponentMsmq.hMyInf, 0 );

    //
    // Check if MSMQ is already installed on this machine.
    // Result is stored in g_fMSMQAlreadyInstalled.
    //
    if (!CheckInstalledComponents())
    {        
        DebugLogMsg(eError, L"An error occurred while checking for installed components. Setup will not continue.");
        g_fCancelled = TRUE;
        return NO_ERROR;
    }

    if (g_fWelcome && Msmq1InstalledOnCluster() && g_dwMachineTypeDs != 0)
    {
        //
        // Running as a post-cluster-upgrade wizard.
        // MSMQ DS server should downgrade to routing server.
        //
        g_dwMachineTypeDs = 0;
        g_dwMachineTypeFrs = 1;
        g_dwMachineType = SERVICE_SRV;
    }

    //
    // On fresh install on non domain controller,
    // default is installing independent client.
    //
    if (!g_fMSMQAlreadyInstalled && !g_dwMachineTypeDs)
    {
        g_fServerSetup = FALSE;
        g_fDependentClient = FALSE;
        g_dwMachineTypeFrs = 0;
    }

    if (!InitializeOSVersion())
    {        
        DebugLogMsg(eError, L"An error occurred while retrieving the operating system information. Setup will not continue.");
        g_fCancelled = TRUE;
        return NO_ERROR;
    }

    //
    // init number of subcomponent that is depending on platform
    //
    if (MSMQ_OS_NTS == g_dwOS || MSMQ_OS_NTE == g_dwOS)
    {
        g_dwSubcomponentNumber = g_dwAllSubcomponentNumber;
    }
    else
    {
        g_dwSubcomponentNumber = g_dwClientSubcomponentNumber;
    }
   
    DebugLogMsg(eInfo, L"The number of subcomponents is %d.", g_dwSubcomponentNumber);    

    //
    // User must have admin access rights to run this setup
    //
    if (!CheckServicePrivilege())
    {
        g_fCancelled = TRUE;
        MqDisplayError(NULL, IDS_SERVICEPRIVILEGE_ERROR, 0);        
        return NO_ERROR;
    }  

    if ((0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE)) && !g_fMSMQAlreadyInstalled)
    {
        //
        // GUI mode + MSMQ is not installed
        //       
        g_fOnlyRegisterMode = TRUE;        
        DebugLogMsg(eInfo, L"Setup is running in GUI mode, and Message Queuing is not installed.");
		DebugLogMsg(eWarning, L"Installing Message Queuing during a fresh install of the OS is not supported.");
    }

    g_fWorkGroup = IsWorkgroup();
    
    DebugLogMsg(eInfo, L"Initialization was completed successfully.");
    
    return NO_ERROR ;

} //MqOcmInitComponent


static
void
SetSystemDirectoryInternal()
{
	DebugLogMsg(eAction, L"Getting the system directory and storing it for later use");
	//
	// Get system path, add backslash.
	//
	WCHAR buffer [MAX_PATH + 1];
    GetSystemDirectory( 
        buffer,
        (MAX_PATH / sizeof(buffer[0]))
        );
	g_szSystemDir = buffer;
	DebugLogMsg(eInfo, L"The system directory is %s.", g_szSystemDir.c_str());
}

void
SetComputerNameInternal()
{
	DebugLogMsg(eAction, L"Geting the computer name and storing it for later use");
	//
	// Get net bios name.
	//
    DWORD dwNumChars = TABLE_SIZE(g_wcsMachineName);
    if(!GetComputerName(g_wcsMachineName, &dwNumChars))
	{
		DWORD gle = GetLastError();
		DebugLogMsg(eError, L"GetComputerName failed. Last error: %d", gle);
		throw bad_win32_error(gle);
	}
	DebugLogMsg(eInfo, L"The computer's NetBIOS name is %s." ,g_wcsMachineName);
	
	//
	// Get the DNS name.
	// Call first to get required length.
	//
	dwNumChars = 0;
	if(!GetComputerNameEx(
				ComputerNamePhysicalDnsFullyQualified, 
				NULL, 
				&dwNumChars
				))
	{
		DWORD gle = GetLastError();
		if(gle != ERROR_MORE_DATA)
		{
			DebugLogMsg(eWarning, L"GetComputerNameEx failed. Last error: %d", gle);
			DebugLogMsg(eWarning, L"g_MachineNameDns is set to empty."); 
			g_MachineNameDns = L"";
			return;
		}
	}

	AP<WCHAR> buffer = new WCHAR[dwNumChars + 1];
    if(!GetComputerNameEx(
				ComputerNamePhysicalDnsFullyQualified, 
				buffer.get(),
				&dwNumChars
				))
	{
		DWORD gle = GetLastError();
		DebugLogMsg(eWarning, L"GetComputerNameEx failed. Last error: %d", gle);
		DebugLogMsg(eWarning, L"g_MachineNameDns is set to empty."); 
		g_MachineNameDns = L"";
		return;
	}
	g_MachineNameDns = buffer.get();
	DebugLogMsg(eInfo, L"The computer's DNS name is %s." ,g_MachineNameDns.c_str());
}

bool
MqInit()
/*++

Routine Description:

    Handles "lazy initialization" (init as late as possible to shorten OCM startup time)

Arguments:

    None

Return Value:

    None

--*/
{
    static bool fBeenHere = false;
    if (fBeenHere)
    {
        return true;
    }
    fBeenHere = true;
    
    DebugLogMsg(eAction, L"Starting late initialization");

	try
	{
		SetSystemDirectoryInternal();

		SetComputerNameInternal();
    

        //
		// Create and set MSMQ directories
		//
		SetDirectories();
    
		//
		// Initialize to use Ev.lib later. We might need it to use registry function 
		// in setup code too.
		//
		CmInitialize(HKEY_LOCAL_MACHINE, L"", KEY_ALL_ACCESS);
    
	    DebugLogMsg(eInfo, L"Late initialization was completed successfully.");
		return true;
	}
	catch(const exception&)
	{
		return false;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\ocminst.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocminst.cpp

Abstract:

    Code to install Falcon

Author:

    Doron Juster  (DoronJ)  02-Aug-97

Revision History:

    Shai Kariv    (ShaiK)   14-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include "ocmres.h"
#include "privque.h"
#include <lmcons.h>
#include <lmshare.h>
#include <lmaccess.h>
#include <rt.h>
#include <Ev.h>
#include <mqnames.h>
#include "autoreln.h"
#include <lm.h>
#include <lmapibuf.h>
#include <Dsgetdc.h>
#include "mqdsname.h"
#include "dsutils.h"
#include "autohandle.h"
#include <strsafe.h>
#include "ocminst.tmh"

using namespace std;
BOOL
GetServiceState(
    IN  const TCHAR *szServiceName,
    OUT       DWORD *dwServiceState ) ;

BOOL
GenerateSubkeyValue(
    IN     const BOOL    fWriteToRegistry,
    const std::wstring& EntryName,
    IN OUT       HKEY*  phRegKey,
    IN const BOOL OPTIONAL bSetupRegSection = FALSE
    );


//+-------------------------------------------------------------------------
//
//  Function: Msmq1InstalledOnCluster
//
//  Synopsis: Checks if MSMQ 1.0 was installed on a cluster
//
//--------------------------------------------------------------------------
BOOL
Msmq1InstalledOnCluster()
{
	static s_fBeenHere = false;
	static s_fMsmq1InstalledOnCluster = false;

	if(s_fBeenHere)
	{
		return s_fMsmq1InstalledOnCluster;
	}
	s_fBeenHere = true;
	
    DebugLogMsg(eAction, L"Checking whether MSMQ 1.0 is installed in the cluster");

    CRegHandle  hRegKey;
    LONG rc = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  FALCON_REG_KEY,
                  0,
                  KEY_READ,
                  &hRegKey
                  );
    
    if (ERROR_SUCCESS != rc)
    {        
        DebugLogMsg(eInfo, L"The Falcon registry key could not be opened for reading. MSMQ 1.0 is assumed not to be installed in the cluster.");
        return FALSE;
    }

    TCHAR szClusterName[MAX_PATH];
    DWORD dwNumBytes = sizeof(szClusterName);
    rc = RegQueryValueEx(
             hRegKey,
             FALCON_CLUSTER_NAME_REGNAME,
             0,
             NULL,
             (PBYTE)(PVOID)szClusterName,
             &dwNumBytes
             );
    if (ERROR_SUCCESS != rc)
    {
        DebugLogMsg(eInfo, L"The " FALCON_CLUSTER_NAME_REGNAME L" registry value could not be queried. MSMQ 1.0 is assumed not to be installed in the cluster.");
        return FALSE;
    }
    DebugLogMsg(eInfo, L"MSMQ 1.0 is installed in the cluster."); 
    s_fMsmq1InstalledOnCluster = true;
    return TRUE;
} // Msmq1InstalledOnCluster


static
void
RemoveMsmqServiceEnvironment()
/*++
Routine Description:

    Delete the environment registry value from msmq service SCM database
    (registry). Needed for upgrade on cluster. 

--*/
{    
    DebugLogMsg(eAction, L"Deleting the Message Queuing service environment");

    LPCWSTR x_SERVICES_KEY = L"System\\CurrentControlSet\\Services";

    CAutoCloseRegHandle hServicesKey;
    if (ERROR_SUCCESS != RegOpenKeyEx(
                             HKEY_LOCAL_MACHINE,
                             x_SERVICES_KEY,
                             0,
                             KEY_READ,
                             &hServicesKey
                             ))
    {        
        DebugLogMsg(eError, L"The Services registry key could not be opened.");
        return;
    }

    CAutoCloseRegHandle hMsmqServiceKey;
    if (ERROR_SUCCESS != RegOpenKeyEx(
                             hServicesKey,
                             QM_DEFAULT_SERVICE_NAME,
                             0,
                             KEY_READ | KEY_WRITE,
                             &hMsmqServiceKey
                             ))
    {        
        DebugLogMsg(eError, L"The MSMQ registry key in the SCM database could not be opened.");
        return;
    }

    if (ERROR_SUCCESS != RegDeleteValue(hMsmqServiceKey, L"Environment"))
    {        
        DebugLogMsg(eError, L"The Environment registry value of MSMQ registry key could not be deleted from the SCM database.");
        return;
    }
    
    DebugLogMsg(eInfo, L"The Environment registry value of MSMQ registry key was deleted.");

} //RemoveMsmqServiceEnvironment


static
void
SetQmQuota()
/*++

Routine Description:

	checks if this is an upgrade from NT4 or WIN2k, if so, sets the MSMQ_MACHINE_QUOTA_REGNAME 
Arguments:

    None

Return Value:

    None

--*/
{
	//
	// Set the MSMQ_MACHINE_QUOTA_REGNAME registry key to 8GB, unless this is
	// an upgrade from .Net or XP, then leave the registry key as 0xffffffff
	//
	DWORD defaultValue = DEFAULT_QM_QUOTA;
	
	TCHAR szPreviousBuild[MAX_STRING_CHARS] = {0};
    DWORD dwNumBytes = sizeof(szPreviousBuild[0]) * (sizeof(szPreviousBuild) - 1);

	//
	// the Current Build registry key will be used to know from what build are we upgrading
	// since the MSMQ_CURRENT_BUILD_REGNAME reg key was not updated yet, it holds the Previous Build
	//
    if (MqReadRegistryValue(MSMQ_CURRENT_BUILD_REGNAME, dwNumBytes, szPreviousBuild,FALSE) && szPreviousBuild[2] != '0')
    {
		//
		//this is an upgrade not from W2k or NT4
		//
		DebugLogMsg(eInfo, L"The computer quota is not changed during upgrade.");
		return;
	}
	else
	{
		DebugLogMsg(eAction, L"Setting the computer quota");
		//
		// the szPreviousBuild is in the form of "5.0.something" for W2K or "4.0.something" for NT4.
		// this is an upgrade from NT4 or WIN2k, so the Quota key should be 8GB and is 0xffffffff. 
		// we can change it since the user could not acceed 2GB anyway.
		// if no CurrentBuild registry key was found, assuming upgrade from NT4 
		//
			
		//
		// Write the quota properties to the registry keys, we will copy this value to the Active
		// Directory on Qm startup in UpgradeMsmqSetupInAds()
		//
		MqWriteRegistryValue( MSMQ_MACHINE_QUOTA_REGNAME, sizeof(DWORD), REG_DWORD,&defaultValue);
	}
	
}


//+-------------------------------------------------------------------------
//
//  Function: UpgradeMsmq
//
//  Synopsis: Performs upgrade installation on top of MSMQ 1.0
//
//  Returns:  BOOL depending on success.
//
//--------------------------------------------------------------------------
static
BOOL
UpgradeMsmq()
{    
    DebugLogMsg(eAction, L"Upgrading Message Queuing");
    TickProgressBar(IDS_PROGRESS_UPGRADE);

    //
    // Delete msmq1 obsolete directories.
    // These calls would fail if files were left in the directories.
    //
    RemoveDirectory(g_szMsmq1SdkDebugDir.c_str());
    RemoveDirectory(g_szMsmq1SetupDir.c_str());

    if (g_fServerSetup)
    {
		std::wstring InstallDirectory = g_szMsmqDir + OCM_DIR_INSTALL;
        DeleteFilesFromDirectoryAndRd(InstallDirectory);

        //
        // Remove MSMQ 1.0 installaion share
        //
        HINSTANCE hNetAPI32DLL;
        HRESULT hResult = StpLoadDll(TEXT("NETAPI32.DLL"), &hNetAPI32DLL);
        if (!FAILED(hResult))
        {
            //
            // Obtain a pointer to the function for deleting a share
            //
            typedef NET_API_STATUS
                (NET_API_FUNCTION *FUNCNETSHAREDEL)(LPWSTR, LPWSTR, DWORD);
            FUNCNETSHAREDEL pfNetShareDel =
                (FUNCNETSHAREDEL)GetProcAddress(hNetAPI32DLL, "NetShareDel");
            if (pfNetShareDel != NULL)
            {
                NET_API_STATUS dwResult = pfNetShareDel(NULL, MSMQ1_INSTALL_SHARE_NAME, 0);
                UNREFERENCED_PARAMETER(dwResult);
            }

            FreeLibrary(hNetAPI32DLL);
        }
    }
    
    DebugLogMsg(eAction, L"Getting the Message Queuing Start menu program group");

    wstring Group = MqReadRegistryStringValue(
        OCM_REG_MSMQ_SHORTCUT_DIR
        );
	if(Group.empty())
	{
		Group = MSMQ_ACME_SHORTCUT_GROUP;
	}
    
    DebugLogMsg(eInfo, L"The Message Queuing Start menu program group %s.", Group.c_str());
    DeleteStartMenuGroup(Group.c_str());


    //
    // Reform MSMQ service dependencies
    //
    if (!g_fDependentClient && (0 == (g_ComponentMsmq.Flags & SETUPOP_WIN95UPGRADE)))
    {        
        DebugLogMsg(eAction, L"Upgrading a non-dependent client from non-Windows 9x, reforming service dependencies");
        UpgradeServiceDependencies();
    }

    switch (g_dwDsUpgradeType)
    {
        case SERVICE_PEC:
        case SERVICE_PSC:
        {
            if (!Msmq1InstalledOnCluster())
            {
                DisableMsmqService();
                RegisterMigrationForWelcome();
            }
            break;
        }

        case SERVICE_BSC:
            break;

        default:
            break;
    }

    if ((g_ComponentMsmq.Flags & SETUPOP_WIN95UPGRADE) && !g_fDependentClient)
    {
        //
        // Upgrading Win95 to NT 5.0 - register the MSMQ service
        //        
        DebugLogMsg(eAction, L"Upgrading a non-dependent client from Windows 9x, installing the service and driver");

        if (!InstallMSMQService())
            return FALSE;
        g_fMSMQServiceInstalled = TRUE ;

        if (!InstallDeviceDrivers())
            return FALSE;        
    }
    
    if (Msmq1InstalledOnCluster() && !g_fDependentClient)
    {
        //
        // Upgrade on cluster - the msmq service and driver have to be deleted
        // here because their environment is set to be cluster aware.
        // The msmq-post-cluster-upgrade-wizard will create them with
        // normal environment, in the context of the node.
        //        
        DebugLogMsg(eInfo, L"MSMQ 1.0 was installed in the cluster. Delete the service/driver and register for CYS.");

        OcpDeleteService(MSMQ_SERVICE_NAME);
        RemoveService(MSMQ_DRIVER_NAME);
        RegisterWelcome();

        if (g_dwDsUpgradeType == SERVICE_PEC  ||
            g_dwDsUpgradeType == SERVICE_PSC  ||
            g_dwDsUpgradeType == SERVICE_BSC)
        {            
            DebugLogMsg(eInfo, L"An MSMQ 1.0 controller server upgrade was detected in the cluster. The computer will be downgraded to a routing server.");
            DebugLogMsg(eAction, L"Downgrading to a routing server");

            g_dwMachineTypeDs = 0;
            g_dwMachineTypeFrs = 1;
            
        }
    }    
    
    //
    // Update type of MSMQ in registry
    //
    MqWriteRegistryValue( MSMQ_MQS_DSSERVER_REGNAME, sizeof(DWORD),
                          REG_DWORD, &g_dwMachineTypeDs);

    MqWriteRegistryValue( MSMQ_MQS_ROUTING_REGNAME, sizeof(DWORD),
                          REG_DWORD, &g_dwMachineTypeFrs);

    if (g_fDependentClient)
    {
        //
        // Dependent client cannot serve as supporting server, even when installed on NTS
        //
        g_dwMachineTypeDepSrv = 0;
    }
	
	bool fNoDepRegKey=false;
	DWORD dwDepSrv;
	if(!MqReadRegistryValue(MSMQ_MQS_DEPCLINTS_REGNAME,sizeof(dwDepSrv),(PVOID) &dwDepSrv,FALSE) &&
		!g_fDependentClient)
	{
		//
		//no registry key found, this is an upgrade from NT4, so set a registry key
		//for the MachineTypeDepSrv, and set it to 1, since in NT4 it's always ok to be a DepSrv
		//
		fNoDepRegKey=true;
		g_dwMachineTypeDepSrv = 1;
	}
	
	//
	// 1) Dependent client cannot serve as supporting server.
	// 2) if there was a registry key, leave it as it was, if there was no
	// registry key, we are upgrading from NT4 therefor we set the registry key to 1.
	//
	if (g_fDependentClient || fNoDepRegKey)
	{
		MqWriteRegistryValue( MSMQ_MQS_DEPCLINTS_REGNAME, sizeof(DWORD),
                          REG_DWORD, &g_dwMachineTypeDepSrv);
	}


    if (!g_fDependentClient)
    {
        //
        // install PGM driver
        //
        if (!InstallPGMDeviceDriver())
            return FALSE;        
    }
 
	//
	//set the MSMQ_MACHINE_QUOTA_REGNAME key.
	//
	if(!g_fDependentClient)
	{
		SetQmQuota();   
	}

    DebugLogMsg(eInfo, L"The upgrade is completed.");
    return TRUE;
} // UpgradeMsmq


static 
std::wstring 
GetForestName(
	std::wstring Domain
    )
/*++
Routine Description:
	Find the forest root for the specified domain.
	the function allocated the forest root string, the caller is responsible to free this string
	throw bad_hresult excption in case of failure.

Arguments:
	pwcsDomain - domain name, can be NULL

Returned Value:
	Forest Root string.

--*/
{
    //
    // Bind to the RootDSE to obtain information about ForestRootName
    //
	std::wstringstream RootDSE; 
	if(Domain.empty())
	{
		RootDSE <<x_LdapProvider <<x_RootDSE;
	}
	else
	{
		RootDSE <<x_LdapProvider <<Domain <<L"/" <<x_RootDSE;
	}

    R<IADs> pADs;
	HRESULT hr = ADsOpenObject(
					RootDSE.str().c_str(),
					NULL,
					NULL,
					ADS_SECURE_AUTHENTICATION, 
					IID_IADs,
					(void**)&pADs
					);

    if (FAILED(hr))
    {
        DebugLogMsg(eError, L"ADsOpenObject() failed to bind %ls. hr = 0x%x", RootDSE.str().c_str(), hr); 
        throw bad_hresult(hr);
    }

    //
    // Setting value to BSTR Root domain
    //
    BS bstrRootDomainNamingContext( L"rootDomainNamingContext");

    //
    // Reading the root domain name property
    //
    CAutoVariant    varRootDomainNamingContext;

    hr = pADs->Get(bstrRootDomainNamingContext, &varRootDomainNamingContext);
    if (FAILED(hr))
    {
        DebugLogMsg(eError, L"rootDomainNamingContext could not be obtained. hr = 0x%x", hr); 
        throw bad_hresult(hr);
    }

    ASSERT(((VARIANT &)varRootDomainNamingContext).vt == VT_BSTR);

    //
    //  calculate length, allocate and copy the string
    //
	std::wstring RootName = ((VARIANT &)varRootDomainNamingContext).bstrVal;
    if (RootName.empty())
    {
        DebugLogMsg(eError, L"varRootDomainNamingContext is empty.");
        throw bad_hresult(MQ_ERROR);
    }
	return RootName;
}


static 
std::wstring
FindComputerDomain()
/*++
Routine Description:
	Find computer domain.
	the function allocated the computer domain string, the caller is responsible to free this string
	throw excption in case of failure

Arguments:
	None

Returned Value:
	computer domain
--*/
{
	//
	// Get AD server
	//
	PNETBUF<DOMAIN_CONTROLLER_INFO> pDcInfo;
	DWORD dw = DsGetDcName(
					NULL, 
					NULL, 
					NULL, 
					NULL, 
					DS_DIRECTORY_SERVICE_REQUIRED, 
					&pDcInfo
					);

	if(dw != NO_ERROR) 
	{
        DebugLogMsg(eError, L"DsGetDcName failed. Last error: 0x%x", dw); 
		throw bad_win32_error(dw);
	}

	ASSERT(pDcInfo->DomainName != NULL);
	std::wstring ComputerDomain = pDcInfo->DomainName;
	return ComputerDomain;
} // FindComputerDomain


static 
bool 
UserMachineCrossForest()
/*++

Routine Description:
    Check if this is user-machine cross forest scenario.

Arguments:
    None

Return Value:
    true for user-machine cross forest

--*/
{
    ASSERT(!g_fWorkGroup);
	ASSERT(!g_fDsLess);
	ASSERT(!g_fUpgrade);

	try
	{
		std::wstring UserForest = GetForestName(L"");
		ASSERT(!UserForest.empty());
		DebugLogMsg(eInfo, L"The user's forest is %s.", UserForest.c_str());

		std::wstring ComputerDomainName = FindComputerDomain();
		DebugLogMsg(eInfo, L"The computer's domain name is %s.", ComputerDomainName.c_str());
		
		std::wstring MachineForest = GetForestName(ComputerDomainName);
		ASSERT(!MachineForest.empty());
		DebugLogMsg(eInfo, L"The computer's forest is %s.", MachineForest.c_str());


		if(OcmLocalAwareStringsEqual(MachineForest.c_str(),UserForest.c_str()))
		{
			//
			//	The user and the machine are in the same forest
			//
			DebugLogMsg(eInfo, L"The user and the computer are in the same forest.");
			return false;
		}

		//
		// The User and the Machine are in different forests
		//
        DebugLogMsg(
        	eError,
			L"The logged-on user and the local computer are in different forests. The user's forest is %ls. The computer's forest is %ls.", 
			UserForest.c_str(), 
			MachineForest.c_str()
			);

	    MqDisplayError(NULL, IDS_CROSS_FOREST_ERROR, 0, UserForest.c_str(), MachineForest.c_str());
		return true;
	}
	catch(const exception&)
	{
		//
		// In case of failure we assume that the user and machine are in the same forest
		//
		return false;
	}

} // UserMachineCrossForest


bool
InstallOnDomain(
    OUT BOOL  *pfObjectCreatedOrExist
    )
/*++

Routine Description:

    Handles DS operations when machine is joined to domain

Arguments:

    None

Return Value:

    true iff successful

--*/
{
	DebugLogMsg(eAction, L"Performing directory service operations on a computer belonging to a domain");
	if(UserMachineCrossForest())
	{
        DebugLogMsg(eError, L"InstallOnDomain failed. The logged-on user and the local computer are in different forests.");
		return false;
	}
    
	
	*pfObjectCreatedOrExist = TRUE;

    //
    // First do installation of MSMQ DS Server
    //
    if (g_fServerSetup && g_dwMachineTypeDs)
    {        
        DebugLogMsg(eAction, L"Installing a Message Queuing directory service server");

        TickProgressBar();
        if (!CreateMSMQServiceObject())    // in the DS
            return false;
    }

    //
    // Determine whether the MSMQ Configurations object exists in the DS.
    // If it exists, get its Machine and Site GUIDs.
    //
    TickProgressBar();
    GUID guidMachine, guidSite;
    BOOL fMsmq1Server = FALSE;
    LPWSTR pwzMachineName = NULL;
    BOOL bUpdate = FALSE;
    if (!LookupMSMQConfigurationsObject(&bUpdate, &guidMachine, &guidSite, &fMsmq1Server, &pwzMachineName))
    {
        DebugLogMsg(eError, L"LookupMSMQConfigurationsObject() failed.");
        return false;
    }
    if (g_fInstallMSMQOffline)
    {
        return true;
    }

    BOOL fObjectCreatedOrExist = TRUE;

    if (bUpdate)
    {
        //
        // MSMQ Configurations object exists in the DS.
        // We need to update it.
        //        
        DebugLogMsg(eAction, L"Updating the MSMQ-Configuration object");
        if (!UpdateMSMQConfigurationsObject(pwzMachineName, guidMachine, guidSite, fMsmq1Server))
		{
			DebugLogMsg(eError, L"UpdateMSMQConfigurationsObject() failed. The computer name is %ls.", pwzMachineName); 
            return false;
		}
    }
    else
    {
        //
        // MSMQ Configurations object doesn't exist in the DS.
        // We need to create one.
        //        
        DebugLogMsg(eAction, L"Creating an MSMQ-Configuration object");
        if (!CreateMSMQConfigurationsObject( 
					&guidMachine,
					&fObjectCreatedOrExist,
					fMsmq1Server 
					))
        {
	        DebugLogMsg(eError, L"CreateMSMQConfigurationsObject() failed.");
            return false;
        }
    }

    *pfObjectCreatedOrExist = fObjectCreatedOrExist;
    if (fObjectCreatedOrExist)
    {
        //
        // Create local security cache for this machine
        //
        if (!StoreMachineSecurity(guidMachine))
		{
	        DebugLogMsg(eError, L"StoreMachineSecurity() failed.");
            return false;
		}
    }

	DebugLogMsg(eAction, L"The directory service operations have completed successfully.");
    return true;

} //InstallOnDomain


static bool SetAlwaysWithoutDSRegistry()
{
	DebugLogMsg(eWarning, L"The AlwaysWithoutDS registry value is being set.");
    DWORD dwAlwaysWorkgroup = 1;
    if (!MqWriteRegistryValue(
			MSMQ_ALWAYS_WORKGROUP_REGNAME,
			sizeof(DWORD),
			REG_DWORD,
			(PVOID) &dwAlwaysWorkgroup
			))
    {
        ASSERT(("failed to write Always Workgroup value in registry", 0));
		return false;
    }
    return true;
}


bool
InstallOnWorkgroup(
    VOID
    )
/*++

Routine Description:

    Handles installation when the computer belongs to a workgroup
    or offline.

Arguments:

    None

Return Value:

    true iff successful
--*/
{
    ASSERT(("we must be on workgroup or ds-less here", g_fWorkGroup || g_fDsLess || g_fInstallMSMQOffline));
	DebugLogMsg(eAction, L"Installing Message Queuing on a computer operating in workgroup mode"); 

    if (!MqWriteRegistryValue(
        MSMQ_MQS_REGNAME,
        sizeof(DWORD),
        REG_DWORD,
        &g_dwMachineType
        ))
    {
        ASSERT(("failed to write MQS value to registry", 0));
    }

    if (!MqWriteRegistryValue(
             MSMQ_MQS_DSSERVER_REGNAME,
             sizeof(DWORD),
             REG_DWORD,
             (PVOID)&g_dwMachineTypeDs
             )                        ||
        !MqWriteRegistryValue(
             MSMQ_MQS_ROUTING_REGNAME,
             sizeof(DWORD),
             REG_DWORD,
             (PVOID)&g_dwMachineTypeFrs
             )                        ||
        !MqWriteRegistryValue(
             MSMQ_MQS_DEPCLINTS_REGNAME,
             sizeof(DWORD),
             REG_DWORD,
             (PVOID)&g_dwMachineTypeDepSrv
             ))
    {
        ASSERT(("failed to write MSMQ type bits to registry", 0));
    }

	//
	// Generate a guid for the QM and write it to the registry.
	//
    GUID guidQM = GUID_NULL;
    for (;;)
    {
        RPC_STATUS rc = UuidCreate(&guidQM);
        if (rc == RPC_S_OK)
        {
            break;
        }
        
        if (IDRETRY != MqDisplayErrorWithRetry(IDS_CREATE_UUID_ERR, rc))
        {
            return false;
        }
    }
    if (!MqWriteRegistryValue(
        MSMQ_QMID_REGNAME,
        sizeof(GUID),
        REG_BINARY,
        (PVOID)&guidQM
        ))
    {
        ASSERT(("failed to write QMID value to registry", 0));
    }

    SetWorkgroupRegistry();
   
    if (g_fDsLess)
    {
		SetAlwaysWithoutDSRegistry();
    }

	DebugLogMsg(eInfo, L"The installation of Message Queuing on a computer operating in workgroup mode succeeded."); 
    return true;
} //InstallOnWorkgroup


static void pWaitForCreateOfConfigObject()
{
    CAutoCloseRegHandle hKey = NULL ;
    CAutoCloseHandle hEvent = CreateEvent(
                                   NULL,
                                   FALSE,
                                   FALSE,
                                   NULL 
                                   );
    if (!hEvent)
    {
        throw bad_win32_error(GetLastError());
    }

    HKEY hKeyTmp = NULL ;
    BOOL fTmp = GenerateSubkeyValue(
                             FALSE,
                             MSMQ_CONFIG_OBJ_RESULT_KEYNAME,
                             &hKeyTmp
                             );
    if (!fTmp || !hKeyTmp)
    {
        throw bad_win32_error(GetLastError());
    }

    hKey = hKeyTmp ;

    for(;;)
    {
        ResetEvent(hEvent) ;
        LONG rc = RegNotifyChangeKeyValue(
                       hKey,
                       FALSE,   // bWatchSubtree
                       REG_NOTIFY_CHANGE_LAST_SET,
                       hEvent,
                       TRUE
                       ); 
        if (rc != ERROR_SUCCESS)
        {
            throw bad_win32_error(GetLastError());
        }
        
        DebugLogMsg(eInfo ,L"Setup is waiting for a signal from the queue manager.");
        DWORD wait = WaitForSingleObject( hEvent, 300000 ) ;
        UNREFERENCED_PARAMETER(wait);
        //
        // Read the hresult left by the msmq service in registry.
        //
        HRESULT hrSetup = MQ_ERROR ;
        MqReadRegistryValue(
            MSMQ_CONFIG_OBJ_RESULT_REGNAME,
            sizeof(DWORD),
            &hrSetup
            );
        if(SUCCEEDED(hrSetup))
        {
            return;
        }

        if(hrSetup != MQ_ERROR_WAIT_OBJECT_SETUP)
        {
            ASSERT (wait == WAIT_OBJECT_0);
            throw bad_hresult(hrSetup);
        }
        //
        // See bug 4474.
        // It probably takes the msmq service lot of time to
        // create the object. See of the service is still
        // running. If yes, then keep waiting.
        //
        DWORD dwServiceState = FALSE ;
        BOOL fGet = GetServiceState(
                        MSMQ_SERVICE_NAME,
                        &dwServiceState
                        ) ;
        if (!fGet || (dwServiceState == SERVICE_STOPPED))
        {
            throw bad_win32_error(GetLastError());
        }
    }
}
//+----------------------------------------------------------------------
//
//  BOOL  WaitForCreateOfConfigObject()
//
//  Wait until msmq service create the msmqConfiguration object after
//  it boot.
//
//+----------------------------------------------------------------------
static
HRESULT
WaitForCreateOfConfigObject(
	BOOL  *pfRetry
	)
{
    *pfRetry = FALSE ;

    //
    // Wait until the msmq service create the msmq configuration
    // object in active directory. We're waiting on registry.
    // When msmq terminate its setup phase, it updates the
    // registry with hresult.
    //
    try
    {
        pWaitForCreateOfConfigObject();
        return MQ_OK;

    }
    catch(bad_win32_error&)
	{
        *pfRetry = (MqDisplayErrorWithRetry(
                    IDS_MSMQ_FAIL_SETUP_NO_SERVICE,
                    (DWORD)MQ_ERROR_WAIT_OBJECT_SETUP,
                    MSMQ_SERVICE_NAME
                    ) == IDRETRY);
        return MQ_ERROR_WAIT_OBJECT_SETUP;
    }
    catch(bad_hresult& e)
	{
        ASSERT(e.error() != MQ_ERROR_WAIT_OBJECT_SETUP);
        *pfRetry = (MqDisplayErrorWithRetry(
                    IDS_MSMQ_FAIL_SETUP_NO_OBJECT,
                    e.error()
                    ) == IDRETRY);

        return e.error();
    }
}

//+------------------------------------
//
//  BOOL  _RunTheMsmqService()
//
//+------------------------------------

BOOL  _RunTheMsmqService( IN BOOL  fObjectCreatedOrExist )
{    
    BOOL fRetrySetup = FALSE ;

    do
    {
        HRESULT hrSetup = MQ_ERROR_WAIT_OBJECT_SETUP ;

        if (!fObjectCreatedOrExist)
        {
            //
            // Reset error value in registry. If msmq service won't
            // set it, then we don't want a success code to be there
            // from previous setups.
            //
            MqWriteRegistryValue( MSMQ_CONFIG_OBJ_RESULT_REGNAME,
                                  sizeof(DWORD),
                                  REG_DWORD,
                                 &hrSetup ) ;
        }

        if (!RunService(MSMQ_SERVICE_NAME))
        {
            return FALSE;
        }
        else if (!fObjectCreatedOrExist)
        {
            hrSetup = WaitForCreateOfConfigObject( &fRetrySetup ) ;

            if (FAILED(hrSetup) && !fRetrySetup)
            {
                return FALSE ;
            }
        }
    }
    while (fRetrySetup) ;
    return WaitForServiceToStart(MSMQ_SERVICE_NAME);
}


static void ResetCertRegisterFlag()
/*++

Routine Description:
    Reset CERTIFICATE_REGISTERD_REGNAME for the user that is running setup.
	This function is called when MQRegisterCertificate failed.
	CERTIFICATE_REGISTERD_REGNAME might be set if we previously uninstall msmq.
	reset CERTIFICATE_REGISTERD_REGNAME ensure that we try again on next logon.

Arguments:
	None

Return Value:
	None
--*/
{
	CAutoCloseRegHandle hMqUserReg;

    DWORD dwDisposition;
    LONG lRes = RegCreateKeyEx( 
						FALCON_USER_REG_POS,
						FALCON_USER_REG_MSMQ_KEY,
						0,
						TEXT(""),
						REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						&hMqUserReg,
						&dwDisposition 
						);

    ASSERT(lRes == ERROR_SUCCESS);

    if (hMqUserReg != NULL)
    {
		DWORD Value = 0;
		DWORD dwType = REG_DWORD;
		DWORD dwSize = sizeof(Value);

		lRes = RegSetValueEx( 
					hMqUserReg,
					CERTIFICATE_REGISTERD_REGNAME,
					0,
					dwType,
					(LPBYTE) &Value,
					dwSize 
					);

		ASSERT(lRes == ERROR_SUCCESS);
	}
}


VOID
RegisterCertificate(
    VOID
    )
/*++

Routine Description:

    Register msmq internal certificate.
    Ignore errors.

Arguments:

    None

Return Value:

    None.

--*/
{
	DebugLogMsg(eAction, L"Registering the MSMQ internal certificate");
    CAutoFreeLibrary hMqrt;
    if (FAILED(StpLoadDll(MQRT_DLL, &hMqrt)))
    {
        return;
    }

    typedef HRESULT (APIENTRY *MQRegisterCertificate_ROUTINE) (DWORD, PVOID, DWORD);


    MQRegisterCertificate_ROUTINE pfMQRegisterCertificate =
        (MQRegisterCertificate_ROUTINE)
                          GetProcAddress(hMqrt, "MQRegisterCertificate") ;

    ASSERT(("GetProcAddress failed for MQRT!MQRegisterCertificate",
            pfMQRegisterCertificate != NULL));

    if (pfMQRegisterCertificate)
    {
        //
        // This function will fail if setup run form local user account.
        // That's ok, by design!
        // Ignore MQ_ERROR_SERVICE_NOT_AVAILABLE - we may get it if service is not up yet - on 
        // next logon we will retry.
        //
        HRESULT hr = pfMQRegisterCertificate(MQCERT_REGISTER_ALWAYS, NULL, 0);
        //
        // add more logging
        //
        if (FAILED(hr))
        {
			//
			// Need to reset the user flag that indicate that the certificate was registered on logon
			// This might be leftover from previous msmq installation.
			// uninstall don't clear this user flag. 
			// so when we failed here to create new certificate, 
			// next logon should try and create it.
			// removing this flag ensure that we will retry to create the certificate.
			//
			ResetCertRegisterFlag();
			
            if (hr == MQ_ERROR_SERVICE_NOT_AVAILABLE)
            {                
                DebugLogMsg(eError, L"MQRegisterCertificate() failed with the error MQ_ERROR_SERVICE_NOT_AVAILABLE. The queue manager will try to register the certificate when you log on again.");
            }
			else if(hr == HRESULT_FROM_WIN32(ERROR_DS_ADMIN_LIMIT_EXCEEDED))
			{
				MqDisplayError(NULL, IDS_MSMQ_CERTIFICATE_OVERFLOW, hr);
			}
			else
			{
	            DebugLogMsg(eError, L"MQRegisterCertificate() failed. hr = 0x%x", hr);
			}
        }

        ASSERT(("MQRegisterCertificate failed",
               (SUCCEEDED(hr) || 
			   (hr == MQ_ERROR_ILLEGAL_USER) || 
			   (hr == MQ_ERROR_SERVICE_NOT_AVAILABLE) || 
			   (hr == MQ_ERROR_NO_DS) ||
			   (hr == HRESULT_FROM_WIN32(ERROR_DS_ADMIN_LIMIT_EXCEEDED) )) ));
    }

} //RegisterCertificate


VOID
RegisterCertificateOnLogon(
    VOID
    )
/*++

Routine Description:

    Register mqrt.dll to launch on logon and register
    internal certificate. This way every logon user will
    have internal certificate registered automatically.

    Ignore errors.

Arguments:

    None

Return Value:

    None.

--*/
{
	DebugLogMsg(eAction, L"Registering mqrt.dll to launch on logon and register the internal certificate.");
    DWORD dwDisposition = 0;
    CAutoCloseRegHandle hMqRunReg = NULL;

    LONG lRes = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT("software\\microsoft\\windows\\currentVersion\\Run"),
                    0,
                    TEXT(""),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hMqRunReg,
                    &dwDisposition
                    );
    ASSERT(lRes == ERROR_SUCCESS) ;
    if (lRes == ERROR_SUCCESS)
    {
        DWORD dwType = REG_SZ ;
        DWORD dwSize = sizeof(DEFAULT_RUN_INT_CERT) ;

        lRes = RegSetValueEx(
                   hMqRunReg,
                   RUN_INT_CERT_REGNAME,
                   0,
                   dwType,
                   (LPBYTE) DEFAULT_RUN_INT_CERT,
                   dwSize
                   ) ;
        ASSERT(lRes == ERROR_SUCCESS) ;
    }
} //RegisterCertificateOnLogon


VOID
VerifyMsmqAdsObjects(
    VOID
    )
/*++

Routine Description:

    Check for MSMQ objects in Active Directory.
    If not found, popup a warning about replication delays.
    
    Ignore other errors.

Arguments:

    None

Return Value:

    None.

--*/
{
    PROPID      propId = PROPID_QM_OS;
    PROPVARIANT propVar;

    propVar.vt = VT_NULL;

    //
    // try DNS format
    //
    HRESULT hr;
    hr = ADGetObjectProperties(
				eMACHINE,
				NULL,	// pwcsDomainController
				false,	// fServerName
				g_MachineNameDns.c_str(),
				1,
				&propId,
				&propVar
				);

    if (SUCCEEDED(hr))
    {
        return;
    }

    //
    // try NET BEUI format
    //
    hr = ADGetObjectProperties(
				eMACHINE,
				NULL,	// pwcsDomainController
				false,	// fServerName
				g_wcsMachineName,
				1,
				&propId,
				&propVar
				);

    if (SUCCEEDED(hr))
    {
        return;
    }

    if (hr != MQDS_OBJECT_NOT_FOUND)
    {
        //
        // Ignore other errors (e.g. security permission, ds went offline, qm went down)
        //
        return;
    }

	MqDisplayWarning(NULL, IDS_REPLICATION_DELAYS_WARNING, 0);

} // VerifyMsmqAdsObjects


static bool	ResetWorkgroupRegistry()
{
    DWORD dwWorkgroup = 0;
    if (MqReadRegistryValue( 
			MSMQ_WORKGROUP_REGNAME,
			sizeof(dwWorkgroup),
			(PVOID) &dwWorkgroup 
			))
    {
        if (dwWorkgroup != 0)
        {
            dwWorkgroup = 0;
            if (!MqWriteRegistryValue( 
					MSMQ_WORKGROUP_REGNAME,
					sizeof(DWORD),
					REG_DWORD,
					(PVOID) &dwWorkgroup 
					))
            {
				DebugLogMsg(eError, L"The attempt to reset the Workgroup registry value failed.");
				ASSERT(("failed to turn off Workgroup value", 0));
				return false;
            }
        }
    }
	return true;
}


static
bool
InstallMSMQOffline()
{
    //
    // This function handles the instalation of ADIntegrated when in an offline scenario.
    // This is similar to installing ADIntegrated on workroup, with the diference of also
    // preparing a user sid so when the user uninstalls, he will have permissions to remove 
    // the object from AD.
    //
    ASSERT(g_fDsLess == FALSE);               
    DebugLogMsg(eAction, L"Installing Message Queuing in offline mode");
    if (!InstallOnWorkgroup())
    {
        DebugLogMsg(eError, L"Message Queuing could not be installed in workgroup mode.");
        return false;
    }

    if(!PrepareUserSID())
    {
        DebugLogMsg(eError, L"Preparing the user SID failed.");
        return false;
    }
    
    return true;
}


static
BOOL
InstallIndependentClient()
{
    DebugLogMsg(eAction, L"Installing an independent client");
    TickProgressBar(IDS_PROGRESS_INSTALL);

    //
    // Register service and driver
    //
    if (!InstallMachine())
    {
        return FALSE;
    }

    BOOL fObjectCreatedOrExist = TRUE;

    //
    // Cache the OS type in registry.
    // Workgroup and independent client need it, so they later
    // create the msmqConfiguration object in DS.
    //
    BOOL fRegistry = MqWriteRegistryValue( 
							MSMQ_OS_TYPE_REGNAME,
							sizeof(DWORD),
							REG_DWORD,
							&g_dwOS 
							);
    UNREFERENCED_PARAMETER(fRegistry);
    ASSERT(fRegistry) ;

    if (g_fWorkGroup || g_fDsLess)
    {            
        DebugLogMsg(eInfo, L"Installing Message Queuing in workgroup mode");
        if (!InstallOnWorkgroup())
            return FALSE;
    }
    else
    {
        if (!g_fInstallMSMQOffline)
        {
            if (!InstallOnDomain(&fObjectCreatedOrExist))
                return FALSE;
        }

        if (g_fInstallMSMQOffline)
        {
            fObjectCreatedOrExist = TRUE; //return to initial state 
            //
            // We continue as if we are in workgroup. msmq will try to "join domain"
            // each time the service restarts.
            //
            if(!InstallMSMQOffline())
            {
                return FALSE;
            }
        }
    }

    BOOL fRunService = _RunTheMsmqService(fObjectCreatedOrExist);
    if (!fRunService)
    {
        return FALSE ;
    }

    if (!g_fWorkGroup && !g_fDsLess)
    {
        VerifyMsmqAdsObjects();
    }
    return TRUE;
}


static
BOOL
InstallDependentClient()
{
    ASSERT(INSTALL == g_SubcomponentMsmq[eMSMQCore].dwOperation); // Internal error, we should not be here
    DebugLogMsg(eAction, L"Installing a dependent client");

    //
    // Dependent client installation.
    // Create a guid and store it as QMID. Necessary for licensing.
    //
    GUID guidQM = GUID_NULL;
    for (;;)
    {
        RPC_STATUS rc = UuidCreate(&guidQM);
        if (rc == RPC_S_OK)
        {
            break;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_CREATE_UUID_ERR, rc))
        {
            return FALSE;
        }
    }
    BOOL fSuccess = MqWriteRegistryValue(
                   MSMQ_QMID_REGNAME,
                   sizeof(GUID),
                   REG_BINARY,
                   (PVOID) &guidQM
                   );
    ASSERT(fSuccess);

    //
    // Store the remote QM machine in registry
    //
    fSuccess = MqWriteRegistryStringValue(
                   RPC_REMOTE_QM_REGNAME,
                   g_ServerName
                   );

    ASSERT(fSuccess);
    
    TickProgressBar(IDS_PROGRESS_CONFIG);

    UnregisterWelcome();

    return TRUE;
}


bool
CompleteUpgradeOnCluster(
    VOID
    )
/*++

Routine Description:

    Handle upgrade on cluster from NT 4 / Win2K beta3

Arguments:

    None

Return Value:

    true - The operation was successful.

    false - The operation failed.

--*/
{
	DebugLogMsg(eAction, L"Completing upgrade of a Windows NT 4.0 cluster (part of the work was done during the OS upgrade)");
    //
    // Convert old msmq cluster resources
    //
    if (!UpgradeMsmqClusterResource())
    {
        return false;
    }


    //
    // Prepare for clean installation of msmq on the node:
    //
    // * reset globals
    // * create msmq directory
    // * create msmq mapping directory    
    // * reset registry values
    // * clean old msmq service environment
    //

    g_fMSMQAlreadyInstalled = FALSE;
    g_fUpgrade = FALSE;

    SetDirectories();
    if (!StpCreateDirectory(g_szMsmqDir))
    {
        return FALSE;
    }
    
   HRESULT hr = CreateMappingFile();
    if (FAILED(hr))
    {
        return FALSE;
    }    
    
    HKEY hKey = NULL;
    if (GenerateSubkeyValue(TRUE, GetKeyName(MSMQ_QMID_REGNAME), &hKey))
    {
        ASSERT(("should be valid handle to registry key here!",  hKey != NULL));

        RegDeleteValue(hKey, (GetValueName(MSMQ_QMID_REGNAME)).c_str());
        RegCloseKey(hKey);
    }


    TCHAR szCurrentServer[MAX_REG_DSSERVER_LEN] = _T("");
    if (MqReadRegistryValue(MSMQ_DS_CURRENT_SERVER_REGNAME, sizeof(szCurrentServer), szCurrentServer))
    {
        if (_tcslen(szCurrentServer) < 1)
        {
            //
            // Current MQIS server is blank. Take the first server from the server list.
            //
            TCHAR szServer[MAX_REG_DSSERVER_LEN] = _T("");
            MqReadRegistryValue(MSMQ_DS_SERVER_REGNAME, sizeof(szServer), szServer);

            ASSERT(("must have server list in registry", _tcslen(szServer) > 0));

            TCHAR szBuffer[MAX_REG_DSSERVER_LEN] = _T("");
            HRESULT hr = StringCchCopy(szBuffer, MAX_REG_DSSERVER_LEN, szServer);
			DBG_USED(hr);
			ASSERT(SUCCEEDED(hr));
            
			TCHAR * psz = _tcschr(szBuffer, _T(','));
            if (psz != NULL)
            {
                (*psz) = _T('\0');
            }
            hr = StringCchCopy(szCurrentServer, MAX_REG_DSSERVER_LEN, szBuffer);
			ASSERT(SUCCEEDED(hr));

        }

        ASSERT(("must have two leading bits", _tcslen(szCurrentServer) > 2));
        g_ServerName = &szCurrentServer[2];
    }

    RemoveMsmqServiceEnvironment();

    TickProgressBar(IDS_PROGRESS_INSTALL);
    return true;

} //CompleteUpgradeOnCluster


//+-------------------------------------------------------------------------
//
//  Function: MqOcmInstall
//
//  Synopsis: Called by MsmqOcm() after files copied
//
//--------------------------------------------------------------------------
DWORD
MqOcmInstall(IN const TCHAR * SubcomponentId)
{    
    if (SubcomponentId == NULL)
    {
        return NO_ERROR;
    }    

    if (g_fCancelled)
    {
        return NO_ERROR;
    }

    //
    // we need to install specific subcomponent
    //
    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        if (_tcsicmp(SubcomponentId, g_SubcomponentMsmq[i].szSubcomponentId) != 0)
        {
            continue;
        }                
        
        if (g_SubcomponentMsmq[i].dwOperation != INSTALL)
        {
            //
            // this component was not selected to install
            //
            return NO_ERROR;
        }
        
        if ( (g_SubcomponentMsmq[i]).pfnInstall == NULL)
        {            
            ASSERT(("There is no specific installation function", 0));
            return NO_ERROR ;
        }

        //
        //  we need to install this subcomponent
        //
        if ( (!g_SubcomponentMsmq[eMSMQCore].fIsInstalled) && (i != eMSMQCore) )
        {  
            //
            // MSMQ Core is not installed and this subcomponent
            // is NOT MSMQ Core!
            // It is wrong situation: MSMQ Core must be installed
            // FIRST since all subcomponents depends on it.
            //       
            // It can happen if
            // MSMQ Core installation failed and then
            // setup for the next component was called. 
            //           
            return (DWORD)MQ_ERROR;                
        }

        if (i == eHTTPSupport)
        {
            //
            // we have to install HTTP support later since this
            // subcomponent depends on IIS service that will be 
            // installed in OC_CLEANUP phase. So we need to postpone
            // our HTTP support installation
            //
			// .NET RC2
			//
			// Windows bug 666911.
            // msmq+http installation cannot register iis extension if
            // smtp is also installed.
            // By iis recommendation, move registration code from oc_cleanup
            // to oc_copmlete, and test if iisadmin is running, instead
            // of testing for w3svc.

		    if (// HTTP Support subcomponent was selected
                g_SubcomponentMsmq[eHTTPSupport].dwOperation == INSTALL &&    
                // only if MSMQ Core is installed successfully
                g_SubcomponentMsmq[eMSMQCore].fIsInstalled)
			{
			    //
			    // Try to configure msmq iis extension
			    //                   
			    BOOL f = InstallIISExtension(); 
				             
			    if (!f)
			    {
					 //
					 // warning to the log file that MSMQ will not support http
					 // messages was printed in ConfigureIISExtension().
					 // Anyway we don't fail the setup because of this failure
					 // 
		
					 //
					 // In case of upgrade we nead to unregister http suport
					 //
					 FinishToRemoveSubcomponent(eHTTPSupport);                
		       }
	           else             
	           {              
	                 FinishToInstallSubcomponent(eHTTPSupport);   
					 if (g_fWelcome)
					 {
					     UnregisterSubcomponentForWelcome(eHTTPSupport);
					 }
			   }
			}                

			 return NO_ERROR;
        }
            
        DebugLogMsg(eHeader, L"Installation of the %s Subcomponent", SubcomponentId);                 

        BOOL fRes = g_SubcomponentMsmq[i].pfnInstall();           
        if (fRes)
        {                
            FinishToInstallSubcomponent(i);
            if (g_fWelcome)
            {
                UnregisterSubcomponentForWelcome (i);
            }
        }
        else
        {              
            DebugLogMsg(eWarning, L"The %s subcomponent could not be installed.", SubcomponentId);                     
        }       
        return NO_ERROR;    
    }

    ASSERT (("Subcomponent for installation is not found", 0));
    return NO_ERROR ;
}
 

static
void
WriteFreshOrUpgradeRegistery()
{
	//
	// These registry values are should be set on both fresh install
	// and upgrade, and before service is started.
	//
    DWORD dwStatus = MSMQ_SETUP_FRESH_INSTALL;
    if (g_fMSMQAlreadyInstalled)
    {
        dwStatus = MSMQ_SETUP_UPGRADE_FROM_NT;
    }
    if (0 != (g_ComponentMsmq.Flags & SETUPOP_WIN95UPGRADE))
    {
        dwStatus = MSMQ_SETUP_UPGRADE_FROM_WIN9X;
    }
    MqWriteRegistryValue(MSMQ_SETUP_STATUS_REGNAME, sizeof(DWORD), REG_DWORD, &dwStatus);

	MqWriteRegistryStringValue(
		MSMQ_ROOT_PATH,
		g_szMsmqDir
		);
}


static
BOOL
CreateEventLogRegistry() 
{
    //
    // Create eventlog registry for MSMQ and MSMQTriggers services
    //
	std::wstring MessageFile = g_szSystemDir + L"\\" + MQUTIL_DLL_NAME;
    try
    {        
        EvSetup(MSMQ_SERVICE_NAME, MessageFile.c_str());
        EvSetup(TRIG_SERVICE_NAME, MessageFile.c_str());
        return TRUE;
    }
    catch(const exception&)
	{
        //
        // ISSUE-2001/03/01-erez   Using GetLastError in catch
        // This should be replaced with a specifc exception by Cm and pass the
        // last error. e.g., use bad_win32_error class.
        //
        MqDisplayError(NULL, IDS_EVENTLOG_REGISTRY_ERROR, GetLastError(), MSMQ_SERVICE_NAME, MessageFile.c_str());
        return FALSE;
	}
}


static
void
RevertInstallation()
{
    //
    // This method is called if somthing went wrong and we want to revert the 
    // changed we made before failing setup.
    //
    if (g_fMSMQServiceInstalled || 
        g_fDriversInstalled )
    {
       //
       // remove msmq and mqds service and driver (if already installed).
       //
       RemoveService(MSMQ_SERVICE_NAME);
       
       RemoveService(MSMQ_DRIVER_NAME);
    }    
    MqOcmRemovePerfCounters();
    g_fCoreSetupSuccess = FALSE;
}


void OcpReserveTcpIpPort1801(void)
/*++
Routine Description:
    MSMQ service is listening on TCP port 1801. Since it is not below 1204 range, 
    it can be used if the TCP winsock application is using port random selection.  
    In this case, MSMQ service wouldn't be able to start since it cannot be bounded to
    port 1801.

	This routine will add "1801-1801" to the following registry value so that it will 
    excluded from the random selection list.  However, application can still use the port 
    if they specify explicitly.  We only append "1801-1801" if it doesn't exist.

         HKLM\System\CurrentControlSet\Services\TCPIP\Parameters\ReservedPorts (REG_MULTI_SZ)

Arguments:
	None

Returned Value:
	None

--*/
{
	DebugLogMsg( eAction, L"Reserving TCP/IP port 1801 for Message Queuing");
	
    CRegHandle	hTCPIPKey;
    long	    lError=0;
    
	//
	// Reserve TCP port 1801 so that it can't be used when other program open TCP socket 
    // specifying random port selection
	//
	lError   = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
							TCPIP_REG_PARAM, 
							NULL,
							KEY_ALL_ACCESS,
							&hTCPIPKey);

    if(lError != ERROR_SUCCESS)
    {
        DebugLogMsg(eWarning, L"The %s registry key could not be opened. Return code: 0x%x", TCPIP_REG_PARAM, lError);
        return;
    }

	CMultiString multi;
	try
	{
		multi = GetMultistringFromRegistry(
						hTCPIPKey,
						TCPIP_RESERVED_PORT_REGNAME
						);
	}
	catch(const bad_hresult&)
	{
		return;
	}

	if(multi.IsSubstring(MSMQ_RESERVED_TCPPORT_RANGE))
	{
	    DebugLogMsg(eInfo, L"Port 1801 is already listed in the ReservedPorts registry value."); 
	    return;
	}

	multi.Add(MSMQ_RESERVED_TCPPORT_RANGE);
    
	
  	//
	// Set the registry value
	//
  	if(!SetRegistryValue(
  			hTCPIPKey, 
		 	TCPIP_RESERVED_PORT_REGNAME,
			(DWORD)(multi.Size() * sizeof(WCHAR)),
            REG_MULTI_SZ,
            (PVOID)multi.Data()
            ))
  	{
    	DebugLogMsg(eWarning, L"The TCP/IP port "MSMQ_RESERVED_TCPPORT_RANGE L" could not be reserved for the Message Queuing service.");
    	return;
  	}
  	DebugLogMsg(eInfo, L"The TCP/IP port "MSMQ_RESERVED_TCPPORT_RANGE L" is reserved for the Message Queuing service.");
}


void WriteRegInstalledComponentsIfNeeded()
{
	//
	// Check if we need to update InstalledComponents registry
	// The registry will be updated whenever core or one of the server components
	// is updated.
	//

	if (!g_SubcomponentMsmq[eMSMQCore].fIsInstalled)
	{
		//
		// MSMQ Core is not installed
		//
		return;
	}

	if (g_SubcomponentMsmq[eMSMQCore].dwOperation == DONOTHING &&    
		g_SubcomponentMsmq[eRoutingSupport].dwOperation == DONOTHING &&    
		g_SubcomponentMsmq[eMQDSService].dwOperation == DONOTHING)    
	{
		//
		// No change in Core or server components (routing, MQDS)
		//
		return;
	}

    //
    // Write to registry what type of MSMQ was just installed (server, client, etc.)
    //
    DWORD dwType = g_fDependentClient ? OCM_MSMQ_DEP_CLIENT_INSTALLED : OCM_MSMQ_IND_CLIENT_INSTALLED;
    if (g_fServerSetup)
    {
	    DebugLogMsg(eInfo, L"A Message Queuing server is being installed. MachineType = %d, TypeDs = %d, TypeFrs = %d", g_dwMachineType, g_dwMachineTypeDs, g_dwMachineTypeFrs);
        dwType = OCM_MSMQ_SERVER_INSTALLED;
        switch (g_dwMachineType)
        {
            case SERVICE_DSSRV:
                dwType |= OCM_MSMQ_SERVER_TYPE_BSC;
                break;

            case SERVICE_PEC:  // PEC and PSC downgrade to FRS on cluster upgrade
            case SERVICE_PSC:
            case SERVICE_SRV:
                dwType |= OCM_MSMQ_SERVER_TYPE_SUPPORT;
                break;

            case SERVICE_RCS:
                dwType = OCM_MSMQ_RAS_SERVER_INSTALLED;
                break;

            case SERVICE_NONE:
                //
                // This can be valid only when installing DS server which is not FRS
                // on non DC machine
                //
                ASSERT(!g_dwMachineTypeDs && !g_dwMachineTypeFrs);
                break;

            default:
                ASSERT(0); // Internal error. Unknown server type.
                break;
        }
    }
  
    DebugLogMsg(eInfo, L"The InstalledComponents registry value is set to 0x%x.", dwType);

    BOOL bSuccess = MqWriteRegistryValue(
                        REG_INSTALLED_COMPONENTS,
                        sizeof(DWORD),
                        REG_DWORD,
                        (PVOID) &dwType,
                        /* bSetupRegSection = */TRUE
                        );
    DBG_USED(bSuccess);
    ASSERT(bSuccess);
}


static void WriteBuildInfo()
{
	//
	// Get old 'CurrentBuild' regkey from the registry and save it in 'PreviousBuild'.
	//
	std::wstring PreviosBuild = MqReadRegistryStringValue(MSMQ_CURRENT_BUILD_REGNAME);
	if(!PreviosBuild.empty())
	{
		MqWriteRegistryStringValue(
			MSMQ_PREVIOUS_BUILD_REGNAME, 
			PreviosBuild
			);
	}
    
	//
	// Construct CurrenbBuild string and srtore it in registry.
	//
	std::wstringstream CurrentBuild;
	CurrentBuild <<rmj <<L"." <<rmm <<L"." <<rup;
    BOOL bSuccess = MqWriteRegistryStringValue(
		                   MSMQ_CURRENT_BUILD_REGNAME,
		                   CurrentBuild.str()
		                   );
    DBG_USED(bSuccess);
    ASSERT(bSuccess);        
    DebugLogMsg(eInfo, L"The current build is %ls, and the previous build is %ls.", CurrentBuild.str().c_str(), PreviosBuild.c_str());
}


static
bool
HandleWorkgroupRegistery()
{
    if (g_fWorkGroup || g_fDsLess)
    {
        if (!SetWorkgroupRegistry())
        {
            return false;
        }
		return true;
    }
	//
	// Cleaning up the Workgroup reg key!
    // We're on machine that joined the domain.
    // If the "workgroup" flag in registry is on, turn it off.
    // It could have been turned on by previous unsuccessfull
    // setup, or left in registry when removing previous
    // installation of msmq.
    //
	if(!ResetWorkgroupRegistry())
	{
        return false;
	}
	return true;
}



BOOL
InstallMsmqCore()
{
    //
    // Install msmq core subcomponent.
    // This is where we do most of the work on fresh install or upgrade.
    //

    static BOOL fAlreadyInstalled = FALSE;
    if (fAlreadyInstalled)
    {
        //
        // We're called more than once
        //
        return NO_ERROR;
    }
    fAlreadyInstalled = TRUE; 

    DebugLogMsg(eAction, L"Starting InstallMsmqCore(), the main installation routine for MSMQ");

    OcpRegisterTraceProviders(TRACE_MOF_FILENAME);
    
    if (g_hPropSheet)
    {
        //
        // Disable back/next buttons while we're installing.
        //
        PropSheet_SetWizButtons(g_hPropSheet, 0);
    }

    if (g_fWelcome && Msmq1InstalledOnCluster())
    {
        if (!CompleteUpgradeOnCluster())
        {     
            return FALSE;
        }
    }

    if(!CreateEventLogRegistry())
    {
        return FALSE;
    }

    //
    // From this point on we perform install or upgrade operations.
    // The MSMQ files are already on disk.
    //

    WriteFreshOrUpgradeRegistery();

    MqOcmInstallPerfCounters();
    
	//
	// Set DsEnvironment registry defaults if needed
	//
	if(!DsEnvSetDefaults())
	{
		return false;
	}
	
	if (g_fUpgrade)
    {
        if(!UpgradeMsmq())
        {
            RevertInstallation();
            return FALSE;
        }
    }
    else
    {
		//
		// we have to handle Workgroup registry before ADInit since
		// this function uses the flag.
		//
		if(!HandleWorkgroupRegistery())
		{
			return false;
		}

        if (!LoadDSLibrary())
        {
            return false;
        }
        
        if(g_fDependentClient)
        {
            if(!InstallDependentClient())
            {
                RevertInstallation();
                return false;
            }
        }
        else
        {
            if(!InstallIndependentClient())
            {
                RevertInstallation();
                return false;
            }
        }
    }          	

    g_fCoreSetupSuccess = TRUE;

    //
    // The code below is common to fresh install and upgrade.
    //                        
    DebugLogMsg(eAction, L"Starting operations which are common to a fresh installation and an upgrade");

    RegisterCertificateOnLogon();

    //
    // Write to registry build info. This registry value also marks a successful
    // installation and mqrt.dll checks for it in order to enable its loading.
    //
	WriteBuildInfo();
									
	OcpReserveTcpIpPort1801();

    //
    // Now that mqrt.dll enables its loading we can call code that loads it.
    //

    RegisterActiveX(TRUE);

    RegisterSnapin(TRUE);

    if (!g_fUpgrade && !g_fWorkGroup && !g_fDsLess && !g_fInstallMSMQOffline)
    {
        RegisterCertificate();
    }

    return TRUE;

} //InstallMsmqCore

//+-------------------------------------------------------------------------
//
//  Empty installation function: everything was done in Install/Remove
//  MSMQ Core
//
//--------------------------------------------------------------------------  

BOOL
InstallLocalStorage()
{   
    //
    // do nothing
    //
    return TRUE;
}

BOOL
UnInstallLocalStorage()
{
    //
    // do nothing
    //
    return TRUE;
}


bool
SetServerPropertyInAD(
   PROPID propId,
   bool Value
   )
/*++
Routine Description:
	Update both server property bit and service type property in AD
	for both configuration and settings objects.

Arguments:
	propId - the propid server functionality.
	Value - the propid value.

Returned Value:
	true if success, false otherwise

--*/
{
	DebugLogMsg(eAction, L"Updating the server property bit and service type property in Active Directory for both the MSMQ-Configuration and MSMQ-Settings objects");
	ASSERT((propId == PROPID_QM_SERVICE_ROUTING) || (propId == PROPID_QM_SERVICE_DSSERVER));
	
	GUID QmGuid;
    if(!MqReadRegistryValue(MSMQ_QMID_REGNAME, sizeof(GUID), &QmGuid))
    {
        DebugLogMsg(eError, L"The attempt to obtain QMID from the registry failed.");
		return false;
	}

	//
	// Update propId value in AD 
	// this update the property value 
	// in both configuration and setting objects 
	//
    PROPID aProp[2];
    MQPROPVARIANT aVar[TABLE_SIZE(aProp)];

	aProp[0] = PROPID_QM_OLDSERVICE;
	aVar[0].vt = VT_UI4;
	aVar[0].ulVal = g_dwMachineType;

	aProp[1] = propId;
	aVar[1].vt = VT_UI1;
	aVar[1].bVal = Value;

	HRESULT hr = ADSetObjectPropertiesGuid(
					eMACHINE,
					NULL,  // pwcsDomainController
					false, // fServerName
					&QmGuid,
					TABLE_SIZE(aProp),
					aProp,
					aVar
					);

	if (FAILED(hr))
    {
        DebugLogMsg(eError, L"ADSetObjectPropertiesGuid() failed. PROPID = %d, hr = 0x%x", propId, hr); 
		return false;
	}

	return true;
}


static void DisplayAddError(PROPID propId)
/*++

Routine Description:
	Display the correct error for ADD Server subcomponent (routing or MQDS) failure.

Arguments:
	propId - the propid server functionality.

Returned Value:
	None.

--*/
{
	if(propId == PROPID_QM_SERVICE_ROUTING)
	{
        MqDisplayError(NULL, IDS_ADD_ROUTING_STATE_ERROR, 0);
		return;
	}

	if(propId == PROPID_QM_SERVICE_DSSERVER)
	{
        MqDisplayError(NULL, IDS_CHANGEMQDS_STATE_ERROR, 0);
		return;
	}

	ASSERT(("Unexpected PROPID", 0));
}


static bool InstallMsmqSetting(PROPID propId)
/*++
Routine Description:
	Install msmq setting object. it will also update msmq existing object.

Arguments:
	None

Returned Value:
	true if success, false otherwise

--*/
{
	DebugLogMsg(eAction, L"Installing the MSMQ-Settings object in Active Directory");
	//
	// Not first installation
	// Not installing ADIntegrated
	// Not workgroup
	// Must be TypeFrs (routing) or TypeDs (MQDS) 
	//
    ASSERT(g_SubcomponentMsmq[eMSMQCore].dwOperation != INSTALL);
	ASSERT(g_SubcomponentMsmq[eADIntegrated].dwOperation != INSTALL);
	ASSERT(!g_fWorkGroup);
    ASSERT(g_dwMachineTypeFrs || g_dwMachineTypeDs);

	if(ADGetEnterprise() != eAD)
	{
		//
		// Changing server functionality is not supported in MQIS env.
		//
		DisplayAddError(propId);
        DebugLogMsg(eError, L"Adding server functionality is only supported in an Active Directory environment.");
        return false;
	}

	static bool fNeedToCreateSettingObject = true;
	if((GetSubcomponentInitialState(ROUTING_SUBCOMP) == SubcompOn) ||
	   (GetSubcomponentInitialState(MQDSSERVICE_SUBCOMP) == SubcompOn))
	{
		//
		// Routing or MQDS subcomponent already installed, don't need to create the setting object
		//
		fNeedToCreateSettingObject = false;
	}
    
	if(fNeedToCreateSettingObject)
	{
		//
		// Invoke Create on the existing MSMQConfiguration object. 
		// will create \ recreate MSMQSetting objects.
		//
		BOOL fObjectCreated = FALSE;
		if (!CreateMSMQConfigurationsObjectInDS(
				&fObjectCreated, 
				FALSE,  // fMsmq1Server
				NULL,	// pguidMsmq1ServerSite
				NULL	// ppwzMachineName
				))
		{
			DebugLogMsg(eError, L"The MSMQ-Settings object could not be created.");
			return false;
		}

		fNeedToCreateSettingObject = false;
	}

	//
	// We set first the local registry for adding routing case.
	// If we fail to set the property in AD and for that will not update the registry
	// It will cause Messages to be lost, 
	// if the setting object indicate that we are routing server clients will send messages to us 
	// but we will not be aware that we are routing server.
	// the case mention above can happened if CreateMSMQConfigurationsObjectInDS was called 
	// and created MSMQSetting object but than we went offline and was not able to set 
	// the configuration object properties.
	// For that reason we first update the local registry so messages will not be lost.
	//
	if(!RegisterMachineType())
	{
        DebugLogMsg(eError, L"The computer type information could not be updated in the registry.");
        return false;
	}

	//
	// Set the new functionality property in both configuration and setting object
	//
	if(!SetServerPropertyInAD(propId, true))
    {
		return false;
	}

    DebugLogMsg(eInfo, L"The MSMQ-Settings object was created.");
	return true;
}


bool AddSettingObject(PROPID propId)
/*++

Routine Description:
	Install msmq setting object for Server subcomponent (routing or MQDS).

Arguments:
	propId - the propid server functionality.

Returned Value:
	true for success, false for failure.

--*/
{
    if (!LoadDSLibrary())
    {
        DebugLogMsg(eError, L"The DS dynamic-link library could not be loaded.");
        return false;
    }

	if(!InstallMsmqSetting(propId))
	{
        DebugLogMsg(eError, L"Installation of the MSMQ-Settings object failed.");
        return false;
	}

	return true;
}


BOOL
InstallRouting()
{  
    if((g_SubcomponentMsmq[eMSMQCore].dwOperation == INSTALL) ||
	   (g_SubcomponentMsmq[eADIntegrated].dwOperation == INSTALL))
	{
		//
		// do nothing
		//
		DebugLogMsg(eInfo, L"The Message Queuing Core and/or Active Directory Integration subcomponents are selected for installation.");
		DebugLogMsg(eInfo, L"An MSMQ-Settings object was created as part of their installation.");
		DebugLogMsg(eInfo, L"There is nothing else to do here.");
		return TRUE;
	}

	//
	// msmq configuration object already exist
	// Add setting object and set PROPID_QM_SERVICE_ROUTING property.
	//
	if(!AddSettingObject(PROPID_QM_SERVICE_ROUTING))
	{
		DebugLogMsg(eError, L"An MSMQ-Settings object could not be added for the Message Queuing Routing server.");
		return FALSE;
	}

	if(!OcpRestartService(MSMQ_SERVICE_NAME))
	{
		MqDisplayWarning (NULL, IDS_RESTART, 0);
	}


	return TRUE;
}


BOOL
UnInstallRouting()
{
    if(g_SubcomponentMsmq[eMSMQCore].dwOperation == REMOVE)
	{
		//
		// Uninstall - do nothing
		//
		return TRUE;
	}

	ASSERT(("Remove Routing is allowed only on workgroup", g_fWorkGroup));

	//
	// Update machine type registry info
	//
	if(!RegisterMachineType())
	{
        DebugLogMsg(eError, L"The computer type information could not be updated in the registry.");
        return FALSE;
	}

	return TRUE;
}


static bool	InstallADIntegratedOnDomain()
/*++
Routine Description:
	Handle AD integration installation on domain (similar to the code that is done in installmsmqcore on fresh install).

Arguments:
	None

Returned Value:
	true if success, false otherwise

--*/
{
	DebugLogMsg(eAction, L"Installing Active Directory Integration in a domain");
	//
	// Not first installation
	//
    ASSERT(g_SubcomponentMsmq[eMSMQCore].dwOperation != INSTALL);

    //
    // If the "workgroup" flag in registry is on, turn it off.
	// Since this is not first installation, workgroup registry is supposed to be set.
    // in NT4 environment we must reset workgroup registry.
	// otherwise mqdscli library will return MQ_ERROR_UNSUPPORTED_OPERATION.
	// in AD environment we can workaround this limitation by calling ADInit 
	// with fIgnoreWorkGroup = true.
    //
	if(!ResetWorkgroupRegistry())
        return false;

    if (!LoadDSLibrary())
    {
		SetWorkgroupRegistry();
        DebugLogMsg(eError, L"The DS library could not be loaded.");
        return false;
    }

	//
	// In order to support NT4 ad integration we must call InstallOnDomain
	// in case of NT4 environment setup is creating the msmq configuration object
	// in case of AD environment for independent client, setup is preparing some data but the qm upon startup
	// will create the object
	//
    BOOL fObjectCreatedOrExist = FALSE;
	BOOL fSuccess = InstallOnDomain(&fObjectCreatedOrExist);

    if(g_fInstallMSMQOffline)
    {
        //
        // g_fInstallMSMQOffline could be set to TRUE during InstallOnDomain().
        //
        return InstallMSMQOffline();
    }

    if(!fSuccess)
	{
		SetWorkgroupRegistry();
        DebugLogMsg(eError, L"The installation of Active Directory Integration failed.");
        return false;
	}

	if(fObjectCreatedOrExist)
	{
		//
		// msmq configuration object was created or updated.
		//
        DebugLogMsg(eInfo, L"The MSMQ-Configuration object was created or updated in the %ls domain.", g_wcsMachineDomain.get()); 
		return true;
	}

	//
	// msmq configuration object was not created 
	// this is the case for independent client in AD env.
	// set workgroup registry to trigger qm join domain code, it will create msmq configuration object.
	//
	DebugLogMsg(eWarning, L"InstallOnDomain() succeeded. No MSMQ-Configuration object was created. The Message Queuing service must be restarted to create an MSMQ-Configuration object."); 
	SetWorkgroupRegistry();
	return true;
}


static
bool 
DeleteAlwaysWithoutDSRegistry()
/*++
Routine Description:
	Remove AlwaysWithoutDS registry.

Arguments:
	None

Returned Value:
	true if success, false otherwise

--*/
{
	std::wstringstream SubKey;
    SubKey <<FALCON_REG_KEY <<L"\\" <<MSMQ_SETUP_KEY;
	DebugLogMsg(eAction, L"Deleting the %s%s registry value", SubKey.str().c_str(), ALWAYS_WITHOUT_DS_NAME); 

    CAutoCloseRegHandle hRegKey;
    LONG error = RegOpenKeyEx(
                            FALCON_REG_POS, 
                            SubKey.str().c_str(), 
                            0, 
                            KEY_ALL_ACCESS, 
                            &hRegKey
							);
    if (ERROR_SUCCESS != error)
    {
        MqDisplayError(NULL, IDS_REGISTRYOPEN_ERROR, error, HKLM_DESC, SubKey.str().c_str());
        DebugLogMsg(			 
        	eError,
			L"The %s registry key could not be opened. Return code: 0x%x",
            FALCON_REG_KEY, 
			error
			);  
        return false;
    }
 
    error = RegDeleteValue(
					hRegKey, 
					ALWAYS_WITHOUT_DS_NAME
					);

    if((error != ERROR_SUCCESS) &&
    	(error != ERROR_FILE_NOT_FOUND)) 
    {
    	DebugLogMsg(
			eError,
			L"The %s registry value could not be deleted. Return code: 0x%x",
	        ALWAYS_WITHOUT_DS_NAME, 
			error
			);
    	return false;
    }

   return true;
}


BOOL
InstallADIntegrated()
{
	DebugLogMsg(eInfo, L"An MSMQ-Configuration object will be created (if it was not created while installing the Core subcomponent).");
    if (g_SubcomponentMsmq[eMSMQCore].dwOperation == INSTALL)
    {
        //
        // it is the first installation of MSMQ
		// In this case during the installation of MSMQCore the msmq configuration object was created
        //
		DebugLogMsg(eInfo, L"An MSMQ-Configuration object was already created while installing the Core subcomponent.");
        return TRUE;
    }
    
    //
    // MSMQ Core already installed
    // To install AD Integrated:
    //      Remove "AlwaysWithoutDs" registry    
	//		handle msmq installation in domain
    //      Ask user to reboot the computer
	//		restart msmq service is enough for join domain, 
	//		reboot will also create user certificate if needed.
    // 
	if(!DeleteAlwaysWithoutDSRegistry())
	{
		return FALSE;
	}

    if(g_fInstallMSMQOffline)
    {
        return InstallMSMQOffline();
    }

	if(!InstallADIntegratedOnDomain())
	{
		//
		// In case of failure roll back to ds less. 
		//
		SetAlwaysWithoutDSRegistry();
		return FALSE;
	}

	//
	// We need to restart the service so the qm will be aware of the changes made,
	//
	if(!OcpRestartService(MSMQ_SERVICE_NAME))
	{
		MqDisplayWarning (NULL, IDS_RESTART, 0);
	}

	//
	// We need a user certificate (this is instead of reboot).
	//
	RegisterCertificate();
    
    return TRUE;
}


BOOL
UnInstallADIntegrated()
{
    if(g_SubcomponentMsmq[eMSMQCore].dwOperation == REMOVE)
	{
		//
		// Uninstall - do nothing
		//
		return TRUE;
	}

	//
	// removing AD integrated is not supported for MSMQ servers (DS servers or routing servers)
	//
	ASSERT(!g_fServerSetup || (!g_dwMachineTypeDs && !g_dwMachineTypeFrs));
    ASSERT(g_SubcomponentMsmq[eMSMQCore].dwOperation == DONOTHING);

	SetWorkgroupRegistry();
	SetAlwaysWithoutDSRegistry();
	DebugLogMsg(eInfo, L"Message Queuing has switched from domain mode to workgroup mode."); 

	if(!OcpRestartService(MSMQ_SERVICE_NAME))
	{
	    MqDisplayWarning (NULL, IDS_REMOVE_AD_INTEGRATED_WARN, 0);
	}
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\machine.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    machine.cpp

Abstract:

    Handles machine based operations.

Author:


Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include "privque.h"
#include "autoreln.h"
#include <lm.h>
#include <lmapibuf.h>
#include "Dsgetdc.h"
#include <Strsafe.h>

#include "machine.tmh"

class CSiteEntry {
public:
    GUID  m_guid;
    TCHAR m_szName[MAX_PATH];
    LIST_ENTRY m_link;
};

static List<CSiteEntry> s_listSites;
static GUID  s_guidUserSite = GUID_NULL;
static TCHAR s_szUserSite[MAX_PATH];

BOOL  PrepareRegistryForClient() ;

//+--------------------------------------------------------------
//
// Function: GetMsmq1ServerSiteGuid
//
// Synopsis: Queries MSMQ1 DS Server for its Site GUID
//
//+--------------------------------------------------------------
static
BOOL
GetMsmq1ServerSiteGuid(
    OUT GUID *pguidMsmq1ServerSite
    )
{
    //
    // We must have g_wcsServerName filled by the user
    //
    ASSERT(!g_ServerName.empty());
    //
    // Prepare the Site ID property
    //
    PROPID propID = PROPID_QM_SITE_ID;
    PROPVARIANT propVariant;
    propVariant.vt = VT_NULL;

    //
    // Issue the query
    //
    TickProgressBar();

    HRESULT hResult;
    do
    {
        hResult = ADGetObjectProperties(
                    eMACHINE,
                    NULL,	// pwcsDomainController
					false,	// fServerName
                    g_ServerName.c_str(),
                    1,
                    &propID,
                    &propVariant
                    );
        if(SUCCEEDED(hResult))
            break;

    }while( MqDisplayErrorWithRetry(
                        IDS_MSMQ1SERVER_SITE_GUID_ERROR,
                        hResult
                        ) == IDRETRY);

    if (FAILED(hResult))
    {
        return FALSE;
    }

    //
    // Store the results
    //
    ASSERT(pguidMsmq1ServerSite);
    *pguidMsmq1ServerSite = *propVariant.puuid;

    return(TRUE);

} // GetMsmq1ServerSiteGuid


//+--------------------------------------------------------------
//
// Function: GetGuidCn
//
// Synopsis: Queries MSMQ1 DS Server for its IPCN Guid
//
//+--------------------------------------------------------------
static
BOOL
GetGuidCn(
    OUT GUID* pGuidCn
    )
{
    ASSERT(pGuidCn != NULL);

    //
    // We must have g_wcsServerName filled by the user
    //
    ASSERT(!g_ServerName.empty());

    //
    // Prepare properties for query
    //
    PROPID aProp[] = {PROPID_QM_ADDRESS, PROPID_QM_CNS};

    MQPROPVARIANT aVar[TABLE_SIZE(aProp)];

	for(DWORD i = 0; i < TABLE_SIZE(aProp); ++i)
	{
		aVar[i].vt = VT_NULL;
	}

	//
    // Issue the query
    //
    TickProgressBar();
    HRESULT hResult;
    do
    {
        hResult = ADGetObjectProperties(
                    eMACHINE,
                    NULL,	// pwcsDomainController
					false,	// fServerName
                    g_ServerName.c_str(),
		            TABLE_SIZE(aProp),
                    aProp,
                    aVar
                    );
        if(SUCCEEDED(hResult))
            break;

    }while (MqDisplayErrorWithRetry(
                        IDS_MSMQ1SERVER_CN_GUID_ERROR,
                        hResult
                        ) == IDRETRY);

    if (FAILED(hResult))
    {
        return FALSE;
    }

	AP<BYTE> pCleanBlob = aVar[0].blob.pBlobData;
	AP<GUID> pCleanCNS = aVar[1].cauuid.pElems;

	//
	// PROPID_QM_ADDRESS
	//
    ASSERT((aVar[0].vt == VT_BLOB) &&
	       (aVar[0].blob.cbSize > 0) &&
		   (aVar[0].blob.pBlobData != NULL));

	//
	// PROPID_QM_CNS
	//
	ASSERT((aVar[1].vt == (VT_CLSID|VT_VECTOR)) &&
	       (aVar[1].cauuid.cElems > 0) &&
		   (aVar[1].cauuid.pElems != NULL));

	//
	// Process the results - look for ip cns
	//
	BYTE* pAddress = aVar[0].blob.pBlobData;
	BOOL fFoundIPCn = FALSE;
	for(DWORD i = 0; i < aVar[1].cauuid.cElems; ++i)
	{
        TA_ADDRESS* pBuffer = reinterpret_cast<TA_ADDRESS *>(pAddress);

		ASSERT((pAddress + TA_ADDRESS_SIZE + pBuffer->AddressLength) <= 
			   (aVar[0].blob.pBlobData + aVar[0].blob.cbSize)); 

        if(pBuffer->AddressType == IP_ADDRESS_TYPE)
		{
			//
			// Found IP_ADDRESS_TYPE cn
			//
			*pGuidCn = aVar[1].cauuid.pElems[i];
			fFoundIPCn = TRUE;
			break;
		}

		//
		// Advance pointer to the next address
		//
		pAddress += TA_ADDRESS_SIZE + pBuffer->AddressLength;

	}

    return(fFoundIPCn);

} // GetGuidCn


static
bool
QueryMsmqServerVersion(
    BOOL * pfMsmq1Server
    )
{
    *pfMsmq1Server = FALSE;

    if (g_dwMachineTypeDs)
    {
        return true;
    }

    //
    // We must have g_wcsServerName filled by the user
    //
    ASSERT(!g_ServerName.empty());
    //
    // Try to access the MSMQ server / Active Directory.
    //

    PROPID propId = PROPID_QM_MACHINE_TYPE;
    PROPVARIANT propVar;
    propVar.vt = VT_NULL;

    HRESULT hr = ADGetObjectProperties(
						eMACHINE,
						NULL,	// pwcsDomainController
						false,	// fServerName
						g_ServerName.c_str(),
						1,
						&propId,
						&propVar
						);

    if (FAILED(hr))
    {
        MqDisplayError(NULL, IDS_ACCESS_MSMQ_SERVER_ERR, hr, g_ServerName.c_str());
        return false;
    }


    //
    // Succeeded in accessing MSMQ server / Active Directory.
    // Now try using an MSMQ 2.0 RPC interface to server.
    //

    propId = PROPID_QM_SIGN_PKS;
    propVar.vt = VT_NULL;

    hr = ADGetObjectProperties(
				eMACHINE,
				NULL,	// pwcsDomainController
				false,	// fServerName
				g_ServerName.c_str(),
				1,
				&propId,
				&propVar
				);

    if (MQ_ERROR_NO_DS == hr)
    {
        //
        // MSMQ 1.0 server does not recognize MSMQ 2.0 RPC interface
        //
        *pfMsmq1Server = TRUE;
        return true;
    }

    if (FAILED(hr))
    {
        MqDisplayError(NULL, IDS_ACCESS_MSMQ_SERVER_ERR, hr, g_ServerName.c_str());
        return false;
    }

    return true;

} //QueryMsmqServerVersion


static 
std::wstring
FindDCofComputerDomain(
	LPCWSTR pwcsComputerName
	)
/*++
Routine Description:
	Find computer domain

Arguments:
	pwcsComputerName - computer name

Returned Value:
	DC of computer domain,Empty if not found

    NOTE - we are not using the domain name of the computer,
           because binding to it failed

--*/
{

	//
	// Get AD server
	//
	PNETBUF<DOMAIN_CONTROLLER_INFO> pDcInfo;
	DWORD dw = DsGetDcName(
					pwcsComputerName, 
					NULL, 
					NULL, 
					NULL, 
					DS_DIRECTORY_SERVICE_REQUIRED, 
					&pDcInfo
					);

	if(dw != NO_ERROR) 
	{
		return L"";
	}

	ASSERT(pDcInfo->DomainName != NULL);
	std::wstring ComputerDomain = pDcInfo->DomainControllerName;
	ComputerDomain.erase(0, 2);
	return ComputerDomain;
}



//+--------------------------------------------------------------
//
// Function: LookupMSMQConfigurationsObject
//
// Synopsis: Tries to find MSMQ Configurations object in the DS
//
//+--------------------------------------------------------------
BOOL
LookupMSMQConfigurationsObject(
    IN OUT BOOL *pbFound,
       OUT GUID *pguidMachine,
       OUT GUID *pguidSite,
       OUT BOOL *pfMsmq1Server,
       OUT LPWSTR * ppMachineName
       )
{ 
	DebugLogMsg(eAction, L"Looking up the MSMQ-Configuration object in the DS");
    if (!g_ServerName.empty())
    {
        //
        // user specified a server, check if it is an MSMQ1 server
        //
        if (!QueryMsmqServerVersion(pfMsmq1Server))
        {
	        DebugLogMsg(eError, L"The query to determine MsmqServerVersion failed.");
            return FALSE;
        }
    }
    else
    {
        //
        // user didn't specify a server name so we have no specific server
        //
        *pfMsmq1Server = FALSE;
    }

    if (g_dwMachineTypeFrs && *pfMsmq1Server)
    {
        //
        // Installing FRS vs MSMQ 1.0 server is not supported
        //
        MqDisplayError(NULL, IDS_FRS_IN_MSMQ1_ENTERPRISE_ERROR, 0);
        return FALSE;
    }

    //
    // Prepare properties for query
    //
    const x_nMaxProps = 10;
    PROPID propIDs[x_nMaxProps];
    PROPVARIANT propVariants[x_nMaxProps];
    DWORD ix =0;
    DWORD ixService = 0,
          ixMachine = 0,
          ixSite = 0;
    DWORD ixDs = 0,
          ixFrs = 0,
          ixDepSrv = 0;

    propIDs[ix] = PROPID_QM_MACHINE_ID;
    propVariants[ix].vt = VT_NULL;
    ixMachine = ix;
    ++ix;

    propIDs[ix] = PROPID_QM_SITE_ID;
    propVariants[ix].vt = VT_NULL;
    ixSite = ix;
    ++ix;

    if (g_dwMachineTypeDs)
    {
        propIDs[ix] = PROPID_QM_SERVICE_DSSERVER;
        propVariants[ix].vt = VT_NULL;
        ixDs = ix;
        ++ix;

        propIDs[ix] = PROPID_QM_SERVICE_ROUTING;
        propVariants[ix].vt = VT_NULL;
        ixFrs = ix;
        ++ix;

        propIDs[ix] = PROPID_QM_SERVICE_DEPCLIENTS;
        propVariants[ix].vt = VT_NULL;
        ixDepSrv = ix;
        ++ix;
    }
    else
    {
        propIDs[ix] = PROPID_QM_SERVICE;
        propVariants[ix].vt = VT_NULL;
        ixService = ix;
        ++ix;
    }


    //
    //  Find out the computer domain and use it as parameter when quering AD.
    //  This will guarnety the AD will not access GC and will look for the
    //  object only in the computer domain
    //
	std::wstring DcOfComputerDomainName;
    if ( (!*pfMsmq1Server) && (!g_MachineNameDns.empty()) )
    {
        DcOfComputerDomainName = FindDCofComputerDomain(g_MachineNameDns.c_str());
    }

    LPCWSTR pwcsDcOfComputerDomainName = NULL;
	if(!DcOfComputerDomainName.empty())
	{
		pwcsDcOfComputerDomainName = DcOfComputerDomainName.c_str();
	}


    for (;;)
    {
        LPWSTR pwzMachineName = const_cast<WCHAR*>(g_MachineNameDns.c_str());
        if (*pfMsmq1Server || g_MachineNameDns.empty())
        {
            pwzMachineName = g_wcsMachineName;
        }

        HRESULT hResult = ADGetObjectProperties(
								eMACHINE,
								pwcsDcOfComputerDomainName, 
								true,	// fServerName
								pwzMachineName, // DNS name (if server is MSMQ 2.0)
								ix,
								propIDs,
								propVariants
								);
		if (FAILED(hResult))
		{
			DebugLogMsg(eWarning, L"ADGetObjectProperties failed. MachineName = %s, hr = 0x%x", pwzMachineName ,hResult);
		}
        if (FAILED(hResult) && pwzMachineName != g_wcsMachineName)
        {
            //
            // Try NETBIOS
            //
            pwzMachineName = g_wcsMachineName;

            hResult = ADGetObjectProperties(
							eMACHINE,
							pwcsDcOfComputerDomainName, 
							true,	// fServerName
							pwzMachineName,
							ix,
							propIDs,
							propVariants
							);
			if(FAILED(hResult))
			{
				DebugLogMsg(eWarning, L"ADGetObjectProperties failed. MachineName = %s, hr = 0x%x", pwzMachineName ,hResult);
			}
        }

        //
        // Assume the object is not found
        //
        *pbFound = FALSE;

        if (FAILED(hResult))
        {
            if (MQDS_OBJECT_NOT_FOUND == hResult)
			{
				DebugLogMsg(eWarning, L"The DS is available, but the MSMQ-Configuration object was not found.");
                return TRUE;   // *pbFound == FALSE here
			}

            if (MQ_ERROR_NO_DS == hResult)
            { 
				DebugLogMsg(eWarning, L"The DS is not available.");
                //                
                // Maybe it is possible to continue with ds-less mode
                //
                if (g_dwMachineTypeFrs == 0 && // it is ind. client
                    !g_dwMachineTypeDs      && // it is not DC
                    !*pfMsmq1Server)           // not MSMQ1 (NT4) server
                {
					//
					// In unattended mode, continue in DS less mode.
                    //
					if(g_fBatchInstall)
					{
                        g_fInstallMSMQOffline = TRUE;
				        DebugLogMsg(eWarning, L"Unattended setup will continue in offline mode.");
                        return TRUE;
					}

                    // ask Retry Ignore Abort
                    // if retry - continue to try to access AD
                    // if Ignore - return TRUE and continue in ds-less mode
                    // if Abort - return FALSE and cancel the setup
                    //
                    int iButton = MqDisplayErrorWithRetryIgnore(
                                        IDS_ACCESS_AD_ERROR,
                                        hResult
                                        );

                    if (iButton == IDRETRY)
                    {
                        //
                        // try again
                        //
                        continue;
                    } 
                    else if (iButton == IDIGNORE)
                    {
                        //
                        // continue in ds-less mode
                        //
                        g_fInstallMSMQOffline = TRUE;
				        DebugLogMsg(eWarning, L"The user chose to continue in offline mode.");
                        return TRUE;
                    }
                    else
                    {
						DebugLogMsg(eWarning, L"The user chose to abort setup.");
                        return FALSE;
                    }
                }
            }

            if (IDRETRY != MqDisplayErrorWithRetry(
                               IDS_MACHINEGETPROPS_ERROR,
                               hResult
                               ))
            {
                return FALSE;
            }
            //
            // On next try we don't specify the DC name ( it may be old
            // information). To reduce risk we don't try at this point to
            // find another DC name
            //
            pwcsDcOfComputerDomainName = NULL;
            continue;  // Error accured, retry
        }

        if (//
            // When DS server is local, compare the 3 "new" bits
            //
            (g_dwMachineTypeDs &&
                (g_dwMachineTypeDs == propVariants[ixDs].bVal &&
                 g_dwMachineTypeFrs == propVariants[ixFrs].bVal &&
                 g_dwMachineTypeDepSrv == propVariants[ixDepSrv].bVal))    ||

            //
            // When DS server is remote, compare the "old" propid
            //
            (!g_dwMachineTypeDs &&
                g_dwMachineType == propVariants[ixService].ulVal)
            )
        {
            *pbFound = TRUE;
            *pguidMachine = *propVariants[ixMachine].puuid;
            *pguidSite    = *propVariants[ixSite].puuid;
            *ppMachineName = pwzMachineName;
			DebugLogMsg(eInfo, L"The MSMQ-Configuration object was found.");
            return TRUE;
        }

		//
		// MSMQ type mismatch (between what user selected and what's in the DS).
		// Delete the object. It will be re-created by the caller
		//
		for (;;)
		{
			hResult = ADDeleteObjectGuid(
							eMACHINE,
							NULL,       // pwcsDomainController
							false,	    // fServerName
							propVariants[ixMachine].puuid
							);
			if (SUCCEEDED(hResult))
				return TRUE;  // *pbFound == FALSE here

			UINT uErrorId = IDS_TYPE_MISMATCH_MACHINE_DELETE_ERROR;
			if (MQDS_E_MSMQ_CONTAINER_NOT_EMPTY == hResult)
			{
				//
				// The MSMQ Configuration object container is not empty.
				//
				uErrorId = IDS_TYPE_MISMATCH_MACHINE_DELETE_NOTEMPTY_ERROR;
			}
			if (IDRETRY == MqDisplayErrorWithRetry(uErrorId, hResult))
				continue;

			return FALSE; // Fail to delete
		}
    }

    // this line is never reached

} //LookupMSMQConfigurationsObject


//+--------------------------------------------------------------
//
// Function: GetMSMQServiceGUID
//
// Synopsis: Reads GUID of MSMQ Service object from the DS
//
//+--------------------------------------------------------------
BOOL
GetMSMQServiceGUID(
    OUT GUID *pguidMSMQService
    )
{
    //
    // Lookup the GUID of the object
    //
    TickProgressBar();
    PROPVARIANT propVariant;
    propVariant.vt = VT_NULL;
    PROPID columnsetPropertyIDs[] = {PROPID_E_ID};
    HRESULT hResult;
    do
    {
        hResult = ADGetObjectProperties(
                    eENTERPRISE,
                    NULL,	// pwcsDomainController
					false,	// fServerName
                    L"msmq",
                    1,
                    columnsetPropertyIDs,
                    &propVariant
                    );
        if(SUCCEEDED(hResult))
            break;

    }while( MqDisplayErrorWithRetry(
                        IDS_MSMQSERVICEGETID_ERROR,
                        hResult
                        ) == IDRETRY);
    
    //
    // Check if there was an error
    //
    if (FAILED(hResult))
    {
        MqDisplayError(NULL, IDS_MSMQSERVICEGETID_ERROR, hResult);
        return FALSE;
    }

    //
    // Store the GUID (if results were found)
    //
    if (propVariant.vt == VT_CLSID) 
    {
        *pguidMSMQService = *(propVariant.puuid);
        delete propVariant.puuid;
    }
    else
    {
        ASSERT(0);
        *pguidMSMQService = GUID_NULL;
    }

    return TRUE;

} //GetMSMQServiceGUID


//+-------------------------------------------------------------------------
//
//  Function:   SitesDlgProc
//
//  Synopsis:   Dialog procedure for selection of MSMQ site
//
//  Returns:    int depending on msg
//
//+-------------------------------------------------------------------------
INT_PTR
CALLBACK
SitesDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam )
{
    int iSuccess = 0;
    TCHAR szSite[MAX_PATH];

    switch( msg )
    {
        case WM_INITDIALOG:
        {
            g_hPropSheet = GetParent(hdlg);

            //
            // Insert the server site to the list box
            //
            SendDlgItemMessage(hdlg, IDC_List, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)s_szUserSite);

            //
            // Insert all the rest of the sites to the list box
            //
            for (List<CSiteEntry>::Iterator p = s_listSites.begin(); p != s_listSites.end(); ++p)
            {
                if (p->m_guid == s_guidUserSite)
                {
                    //
                    // This is the server site, it's already in the list box
                    //
                    continue;
                }

                SendDlgItemMessage(hdlg, IDC_List, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)p->m_szName);
            }

            //
            // Set the first one to be selected
            //
            SendDlgItemMessage(hdlg, IDC_List, LB_SETCURSEL, 0, 0);

            iSuccess = 1;
            break;
        }

        case WM_COMMAND:
        {
            if ( BN_CLICKED == HIWORD(wParam) )
            {
                //
                // Get the selected string from list box
                //
                UINT_PTR ix = SendDlgItemMessage(hdlg, IDC_List, LB_GETCURSEL, 0, 0);
                SendDlgItemMessage(hdlg, IDC_List, LB_GETTEXT, ix, (LPARAM)(LPCTSTR)szSite);

                //
                // Iterate the list to find the selected site's guid
                //
                CSiteEntry *pSiteEntry;
                while((pSiteEntry = s_listSites.gethead()) != 0)
                {
                    if (_tcscmp(pSiteEntry->m_szName, szSite) == 0)
                    {
                        //
                        // This is the selected site. Store its guid.
                        //
                        s_guidUserSite = pSiteEntry->m_guid;
                    }

                    delete pSiteEntry;
                }

                //
                // Kill the dialog page
                //
                EndDialog(hdlg, 0);
            }
            break;
        }

        case WM_NOTIFY:
        {
            switch(((NMHDR *)lParam)->code)
            {
              case PSN_SETACTIVE:
              {
              }

              //
              // fall through
              //
              case PSN_KILLACTIVE:
              case PSN_QUERYCANCEL:

                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    iSuccess = 1;
                    break;

            }
            break;
        }
    }

    return iSuccess;

} // SitesDlgProc


//+--------------------------------------------------------------
//
// Function: CleanList
//
// Synopsis:
//
//+--------------------------------------------------------------
static
void
CleanList()
{
    CSiteEntry *pSiteEntry;
    while((pSiteEntry = s_listSites.gethead()) != 0)
    {
        delete pSiteEntry;
    }
} // CleanList


//+--------------------------------------------------------------
//
// Function: AskUserForSites
//
// Synopsis:
//
//+--------------------------------------------------------------
BOOL
AskUserForSites()
{
	DebugLogMsg(eAction , L"Asking the user for sites");
	std::wstring UnattenSite;
    if (g_fBatchInstall)
    {
        //
        // Unattended. Read site name from INI file.
        //
        try
        {
			UnattenSite = ReadINIKey(L"Site");
			if(UnattenSite.empty())
			{
				return FALSE;
			}
		}
        catch(exception)
        {
            return FALSE;
        }
    }

    PROPID columnsetPropertyIDs[] = {PROPID_S_SITEID, PROPID_S_PATHNAME/*, PROPID_S_FOREIGN*/};
    UINT nCol = sizeof(columnsetPropertyIDs)/sizeof(columnsetPropertyIDs[0]);
    MQCOLUMNSET columnsetSite;
    columnsetSite.cCol = sizeof(columnsetPropertyIDs)/sizeof(columnsetPropertyIDs[0]);
    columnsetSite.aCol = columnsetPropertyIDs;

    //
    // Begin the query
    //
    CADQueryHandle hQuery;
    HRESULT hResult;
    do
    {
        hResult = ADQueryAllSites(
                        NULL,       // pwcsDomainController
						false,	    // fServerName
                        &columnsetSite,
                        &hQuery
                        );
        if(SUCCEEDED(hResult))
            break;

    }while( MqDisplayErrorWithRetry(
                        IDS_SITESLOOKUP_ERROR,
                        hResult
                        ) == IDRETRY);

    if (FAILED(hResult))
        return FALSE;
    //
    // Get all sites
    //
    UINT nSites = 0;
    PROPVARIANT propVars[50];
    DWORD dwProps = sizeof(propVars)/sizeof(propVars[0]);
    for (;;)
    {
        do
        {
            hResult = ADQueryResults(
                        hQuery,
                        &dwProps,
                        propVars
                        );
            if(SUCCEEDED(hResult))
                break;

            }while( MqDisplayErrorWithRetry(
                                IDS_SITESLOOKUP_ERROR,
                                hResult
                                ) == IDRETRY);

       if (FAILED(hResult))
            break;

        if (0 == dwProps)
            break;

        PROPVARIANT *pvar = propVars;
        for ( int i = (dwProps / nCol) ; i > 0 ; i--, pvar+=nCol )
        {
            /*if ((pvar+2)->bVal)
            {
                //
                // Don't count foreign sites
                //
                continue;
            } */

            LPTSTR pszCurrentSite = (pvar+1)->pwszVal;

            if (g_fBatchInstall)
            {
                if (OcmLocalAwareStringsEqual(UnattenSite.c_str(), pszCurrentSite))
                {
                    s_guidUserSite = *(pvar->puuid);
                    return TRUE;
                }
            }
            else
            {
                //
                // Push site guid and name to list
                //
                CSiteEntry *pentrySite = new CSiteEntry;
                ASSERT(pentrySite);
                pentrySite->m_guid = *(pvar->puuid);
				HRESULT hr = StringCchCopy(pentrySite->m_szName, MAX_PATH, pszCurrentSite);
				if(FAILED(hr))
				{
					DebugLogMsg(eError, L"StringCchCopy failed. hr= 0x%x",hr); 
					return FALSE;
				}

                s_listSites.insert(pentrySite);

                //
                // Store the server site name
                //
                if (pentrySite->m_guid == s_guidUserSite)
				{
					hr = StringCchCopy(s_szUserSite, MAX_PATH, pentrySite->m_szName);
					if(FAILED(hr))
					{
						DebugLogMsg(eError, L"StringCchCopy failed. hr= 0x%x",hr); 
						return FALSE;
					}
				}
                nSites++;
            }
        }
    }

    if (FAILED(hResult))
    {
        CleanList();
        return FALSE;
    }

    hResult = ADEndQuery(hQuery.detach());
    ASSERT(0 == hResult);

    //
    // No point showing the page if less than 2 sites found
    //
    if (2 > nSites)
    {
        CleanList();
        return TRUE;
    }

    if (g_fBatchInstall)
    {
        MqDisplayError(NULL, IDS_UNATTEND_SITE_NOT_FOUND_ERROR, 0, UnattenSite.c_str());
        return FALSE;
    }

    //
    // Show the page, wait until user selects a site
    //
    DialogBox(
        g_hResourceMod ,
        MAKEINTRESOURCE(IDD_Sites),
        g_hPropSheet,
        SitesDlgProc
        );

    CleanList();
    return TRUE;

} // AskUserForSites


//+--------------------------------------------------------------
//
// Function: GetSites
//
// Synopsis: Reads GUIDs of Site objects from the DS
//
//+--------------------------------------------------------------
BOOL
GetSites(
    OUT CACLSID *pcauuid)
{
	if(s_guidUserSite != GUID_NULL)
	{
		pcauuid->cElems = 1;
		pcauuid->pElems = &s_guidUserSite;
		return TRUE;
	}

	HRESULT hResult;
    DWORD dwNumSites = 0;
    GUID *pguidSites;

    TickProgressBar();
    for (;;)
    {
        hResult = ADGetComputerSites(
            g_MachineNameDns.c_str(),  // DNS name
            &dwNumSites,
            &pguidSites
            );
        if (FAILED(hResult))
        {
            //
            // Try NETBIOS name
            //
            hResult = ADGetComputerSites(
                               g_wcsMachineName,  // NETBIOS name
                               &dwNumSites,
                               &pguidSites
                               );
        }

        if (MQDS_INFORMATION_SITE_NOT_RESOLVED == hResult && g_dwMachineTypeFrs && !g_dwMachineTypeDs)
        {
            //
            // Failed to resolve site on FRS. Let user select a site.
            //
            ASSERT(dwNumSites); // must be at least 1
            ASSERT(pguidSites); // must point to a valid site guid
            s_guidUserSite = *pguidSites;

            if (!AskUserForSites())
            {
                return FALSE;
            }

            pcauuid->cElems = 1;
            pcauuid->pElems = &s_guidUserSite;
            return TRUE;
        }

        if FAILED(hResult)
        {
            if (IDRETRY == MqDisplayErrorWithRetry(IDS_SITEGETID_ERROR, hResult))
            {
                continue;
            }
        }
        break;
    }

    if (FAILED(hResult))
    {
        return FALSE;
    }

    ASSERT(dwNumSites); // Must be > 0
    pcauuid->cElems = dwNumSites;
    pcauuid->pElems = pguidSites;

    return TRUE;

} //GetSites


//+--------------------------------------------------------------
//
// Function: RegisterMachineType
//
// Synopsis: Writes machine type info to registry
//
//+--------------------------------------------------------------
bool RegisterMachineType()
{
	if( !MqWriteRegistryValue( MSMQ_MQS_REGNAME, sizeof(DWORD),
							   REG_DWORD, &g_dwMachineType)                   ||

		!MqWriteRegistryValue( MSMQ_MQS_DSSERVER_REGNAME, sizeof(DWORD),
							   REG_DWORD, &g_dwMachineTypeDs)                 ||

		!MqWriteRegistryValue( MSMQ_MQS_ROUTING_REGNAME, sizeof(DWORD),
							   REG_DWORD, &g_dwMachineTypeFrs)                ||

		!MqWriteRegistryValue( MSMQ_MQS_DEPCLINTS_REGNAME, sizeof(DWORD),
							   REG_DWORD, &g_dwMachineTypeDepSrv))
	{
		return false;
	}
	return true;
} // RegisterMachineType


//+--------------------------------------------------------------
//
// Function: RegisterMachine
//
// Synopsis: Writes machine info to registry
//
//+--------------------------------------------------------------
static
BOOL
RegisterMachine(
    IN const GUID    &guidMachine,
    IN const GUID    &guidSite
    )
{
    //
    // Get the MSMQ Service GUID from the DS
    //
    GUID    guidMSMQService;
    if (!GetMSMQServiceGUID(&guidMSMQService))
    {
        //
        // Failed to read from the DS
        //
        return FALSE;
    }

    if (GUID_NULL == guidMSMQService)
    {
        //
        // Guid of MSMQ Service not found by the DS query
        //
        MqDisplayError( NULL, IDS_MSMQSERVICEGETID_ERROR, 0);
        return FALSE;
    }

    //
    // Write the stuff in the registry
    //
    TickProgressBar();
    if (!MqWriteRegistryValue( MSMQ_ENTERPRISEID_REGNAME, sizeof(GUID),
                               REG_BINARY, &guidMSMQService)                  ||

        !MqWriteRegistryValue( MSMQ_SITEID_REGNAME, sizeof(GUID),
                               REG_BINARY, (PVOID)&guidSite)                  ||

        !RegisterMachineType()												  ||

        !MqWriteRegistryValue( MSMQ_QMID_REGNAME, sizeof(GUID),
                               REG_BINARY, (PVOID)&guidMachine))
    {
        return FALSE;
    }

    return TRUE;

} //RegisterMachine


//+--------------------------------------------------------------
//
// Function: StoreMachinePublicKeys
//
// Synopsis:
//
//  The fFreshSetup parameter is passed as fRegenerate parameter to
//  MQsec_StorePubKeysInDS. On fresh setup, we want to regenerate the
//  crytpo keys and not using any leftovers from previous installations
//  of msmq on this machine.
//
//+--------------------------------------------------------------

static
HRESULT
StoreMachinePublicKeys( IN const BOOL fFreshSetup )
{
    if (g_fWorkGroup)
        return ERROR_SUCCESS;

    TickProgressBar();

    //
    // Store the public keys of the machine in the directory server
    //	
    DebugLogMsg(eAction, L"Storing the computer's public keys by calling MQsec_StorePubKeysInDS()");
    HRESULT hResult;

    do{
		//
		// the fFromSetup parameter is true to prevent from tring to write old key before re generate which cause empty key 
		// to be written and send to other machines.
		//
      
		hResult = MQSec_StorePubKeysInDS(
                    fFreshSetup,  
                    NULL,
                    MQDS_MACHINE,
					true
                    );
        if (hResult != MQ_ERROR_DS_ERROR)
            break;
        }
    while (MqDisplayErrorWithRetry(
                IDS_POSSIBLECOMPROMISE_ERROR,
                hResult
                ) == IDRETRY);

     

    if (FAILED(hResult) && (hResult != MQ_ERROR_DS_ERROR))
    {
        MqDisplayError(NULL, IDS_PUBLICKEYSSTORE_WARNING, hResult);
    }

	DebugLogMsg(eInfo, L"MQsec_StorePubKeysInDS succeeded.");

    return hResult;

} //StoreMachinePublicKeys


//+--------------------------------------------------------------
//
// Function: StoreQueueManagerInfo
//
// Synopsis: Writes registry stuff and creates machine queues
//
//+--------------------------------------------------------------

static
BOOL
StoreQueueManagerInfo(
    IN const BOOL     fFreshSetup,
    IN const GUID    &guidMachine,
    IN const GUID    &guidSite
    )
{
    //
    // Set the registry keys for this machine
    //	
    DebugLogMsg(eAction, L"Setting the registry keys for this computer");
    if (!RegisterMachine(guidMachine, guidSite))
    {
        return FALSE;
    }

    //
    // Store the public keys of this machine in the directory server
    //	
    DebugLogMsg(eAction, L"Storing the public keys for this computer in the directory service");
    HRESULT hResult = StoreMachinePublicKeys( fFreshSetup ) ;

    return (hResult == MQ_ERROR_DS_ERROR) ? FALSE : TRUE;

} //StoreQueueManagerInfo


static
bool
DsGetQmInfo(
    BOOL fMsmq1Server,
    LPCWSTR pMachineName,
    GUID * pguidMachine,
    GUID * pguidSite
    )
/*++

Routine Description:

    Get from ADS properties of this QM.
    This routine is called after the properties were set.


Arguments:

    fMsmq1Server - in, indicates if NT4 enterprise
    pguidMachine - out, guid of this QM
    pguidSite - out, guid of best site for this QM

Return Value:

    bool depending on success

--*/
{
    ASSERT(("at least one out param should be valid", pguidMachine != NULL || pguidSite != NULL));

    const UINT x_nMaxProps = 16;
    PROPID propIDs[x_nMaxProps];
    PROPVARIANT propVariants[x_nMaxProps];
    DWORD iProperty = 0;

    if (pguidMachine)
    {
        propIDs[iProperty] = PROPID_QM_MACHINE_ID;
        propVariants[iProperty].vt = VT_CLSID;
        propVariants[iProperty].puuid = pguidMachine;
        iProperty++;
    }

    if (pguidSite)
    {
        propIDs[iProperty] = PROPID_QM_SITE_ID;
        propVariants[iProperty].vt = VT_CLSID;
        propVariants[iProperty].puuid = pguidSite;
        iProperty++;
    }

    ASSERT(("we should request at least one property!", iProperty > 0));

    UINT uCounter = fMsmq1Server ? 2 : 0;
    HRESULT hr = MQ_OK;
    for (;;)
    {
        TickProgressBar();
        hr = ADGetObjectProperties(
                eMACHINE,
                NULL,	// pwcsDomainController
				false,	// fServerName
                pMachineName,
                iProperty,
                propIDs,
                propVariants
                );
        if (!FAILED(hr))
            break;

        uCounter++;
        if (1 == uCounter)
        {
            //
            // First time fail. Sleep for a while and retry.
            //
            TickProgressBar();
            Sleep(20000);
            continue;
        }

        if (2 == uCounter)
        {
            //
            // Second time fail. Sleep a little longer and retry.
            //
            TickProgressBar();
            Sleep(40000);
            continue;
        }

        //
        // Third time fail. Let the user decide.
        //
        UINT uErr = fMsmq1Server ? IDS_MACHINEGETPROPS_MSMQ1_ERROR :IDS_MACHINEGETPROPS_ERROR;
        if (IDRETRY == MqDisplayErrorWithRetry(uErr, hr))
        {
            uCounter = 0;
            continue;
        }

        break;
    }

    if (FAILED(hr))
    {
        return false;
    }

    return true;

} //DsGetQmInfo


//+--------------------------------------------------------------
//
// Function: CreateMSMQConfigurationsObjectInDS
//
// Synopsis: Creates MSMQ Configurations object (under computer object)
//           in the DS.
//
//+--------------------------------------------------------------
BOOL
CreateMSMQConfigurationsObjectInDS(
    OUT BOOL *pfObjectCreated,
    IN  BOOL  fMsmq1Server,
	OUT GUID* pguidMsmq1ServerSite,
	OUT LPWSTR* ppwzMachineName
    )
{   
	DebugLogMsg(eAction, L"Creating the MSMQ-Configuration object in the directory service");
    ASSERT(g_fServerSetup || g_fDependentClient || fMsmq1Server);

    *pfObjectCreated = TRUE;

    //
    // Prepare the properties
    //
    const UINT x_nMaxProps = 16;
    PROPID propIDs[x_nMaxProps];
    PROPVARIANT propVariants[x_nMaxProps];
    DWORD iProperty =0;

    propIDs[iProperty] = PROPID_QM_OLDSERVICE;
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = g_dwMachineType;
    iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_DSSERVER;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal = (UCHAR)(g_dwMachineTypeDs ? 1 : 0);
    iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_ROUTING;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal = (UCHAR)(g_dwMachineTypeFrs ? 1 : 0);
    iProperty++;

    propIDs[iProperty] = PROPID_QM_SERVICE_DEPCLIENTS;
    propVariants[iProperty].vt = VT_UI1;
    propVariants[iProperty].bVal = (UCHAR)(g_dwMachineTypeDepSrv ? 1 : 0);
    iProperty++;

    propIDs[iProperty] = PROPID_QM_MACHINE_TYPE;
    propVariants[iProperty].vt = VT_LPWSTR;
    propVariants[iProperty].pwszVal = L"";
    iProperty++;

    propIDs[iProperty] = PROPID_QM_OS;
    propVariants[iProperty].vt = VT_UI4;
    propVariants[iProperty].ulVal = g_dwOS;
    iProperty++;

    TickProgressBar();
    GUID guidMsmq1ServerSite;
    if (!fMsmq1Server)
    {
        //
        // NT 5.0 enterprise. Get sites IDs for this machine from the DS.
        //
        propIDs[iProperty] = PROPID_QM_SITE_IDS;
        propVariants[iProperty].vt = VT_CLSID|VT_VECTOR;
        CACLSID cauuid;
        if (!GetSites(&cauuid))
            return FALSE;
        propVariants[iProperty].cauuid.pElems = cauuid.pElems;
        propVariants[iProperty].cauuid.cElems = cauuid.cElems;
    }
    else
    {
        //
        // NT 4.0 enterprise. Use the site GUID of the MSMQ1 DS Server
        //
        // We must have g_ServerName filled by the user
        //
        ASSERT(!g_ServerName.empty());
        propIDs[iProperty] = PROPID_QM_SITE_ID;
        propVariants[iProperty].vt = VT_CLSID;
        if (!GetMsmq1ServerSiteGuid(&guidMsmq1ServerSite))
        {
            //
            // Failed to query the MSMQ1 DS Server
            //
            return FALSE;
        }
        propVariants[iProperty].puuid = &guidMsmq1ServerSite;

		//
		// Store the Msmq1ServerSite guid on the out parameter
		//
		if (pguidMsmq1ServerSite != NULL)
		{
			*pguidMsmq1ServerSite = guidMsmq1ServerSite;
		}
    }
    iProperty++;

    //
    // Some extra properties are needed if the DS Server is MSMQ1 DS Server
    //
    GUID guidMachine = GUID_NULL;
    GUID guidCns = MQ_SETUP_CN;
    BYTE Address[TA_ADDRESS_SIZE + IP_ADDRESS_LEN];
    if (fMsmq1Server)
    {
        ASSERT(*pfObjectCreated) ;

        propIDs[iProperty] = PROPID_QM_PATHNAME;
        propVariants[iProperty].vt = VT_LPWSTR;
        propVariants[iProperty].pwszVal = g_wcsMachineName;
        iProperty++;

        propIDs[iProperty] = PROPID_QM_MACHINE_ID;
        propVariants[iProperty].vt = VT_CLSID;
        for (;;)
        {
            RPC_STATUS rc = UuidCreate(&guidMachine);
            if (rc == RPC_S_OK)
            {
                break;
            }

            if (IDRETRY != MqDisplayErrorWithRetry(IDS_CREATE_UUID_ERR, rc))
            {
                return FALSE;
            }
        }
        propVariants[iProperty].puuid = &guidMachine;
        iProperty++;

        if (!GetGuidCn(&guidCns))
        {
            //
            // Failed to query the MSMQ1 DS Server IPCN
            //
	        DebugLogMsg(eError, L"Querying the MQIS server for IPCN failed.");
            return FALSE;
        }

		ASSERT(guidCns != MQ_SETUP_CN);

        propIDs[iProperty] = PROPID_QM_CNS;
        propVariants[iProperty].vt = VT_CLSID|VT_VECTOR;
        propVariants[iProperty].cauuid.cElems = 1;
        propVariants[iProperty].cauuid.pElems = &guidCns;
        iProperty++;

        TA_ADDRESS * pBuffer = reinterpret_cast<TA_ADDRESS *>(Address);
        pBuffer->AddressType = IP_ADDRESS_TYPE;
        pBuffer->AddressLength = IP_ADDRESS_LEN;
        ZeroMemory(pBuffer->Address, IP_ADDRESS_LEN);

        propIDs[iProperty] = PROPID_QM_ADDRESS;
        propVariants[iProperty].vt = VT_BLOB;
        propVariants[iProperty].blob.cbSize = sizeof(Address);
        propVariants[iProperty].blob.pBlobData = reinterpret_cast<BYTE*>(pBuffer);
        iProperty++;
     }

    //
    // Create the MSMQ Configurations object in the DS
    //
    UINT uCounter = 0;
    HRESULT hResult;
    LPWSTR pwzMachineName = 0;

    for (;;)
    {
        TickProgressBar();

        pwzMachineName = const_cast<WCHAR*>(g_MachineNameDns.c_str());
        if (fMsmq1Server || g_MachineNameDns.empty())
        {
            pwzMachineName = g_wcsMachineName;
        }

        hResult = ADCreateObject(
						eMACHINE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
						pwzMachineName,   // DNS name (if server is MSMQ 2.0)
						NULL,
						iProperty,
						propIDs,
						propVariants,
						NULL
						);

        if (FAILED(hResult) && pwzMachineName != g_wcsMachineName)
        {
            //
            // Try NETBIOS name
            //
            pwzMachineName = g_wcsMachineName;

            hResult = ADCreateObject(
							eMACHINE,
							NULL,       // pwcsDomainController
							false,	    // fServerName
							pwzMachineName, // NETBIOS this time
							NULL,
							iProperty,
							propIDs,
							propVariants,
							NULL
							);
        }

		if(ppwzMachineName != NULL)
		{
			*ppwzMachineName = pwzMachineName;
		}

        uCounter++;
        if (MQDS_OBJECT_NOT_FOUND == hResult && 1 == uCounter)
        {
            //
            // First try - no computer object in the DS.
            // This is okay on win9x fresh install
            // In these scenarios we have to create computer object in the DS first.
            //
            continue;
        }

        if (FAILED(hResult))
        {
            UINT uErr = fMsmq1Server ? IDS_MACHINECREATE_MSMQ1_ERROR :IDS_MACHINECREATE_ERROR;
            if (!fMsmq1Server)
            {
                if (MQDS_OBJECT_NOT_FOUND == hResult)
                    uErr = IDS_MACHINECREATE_OBJECTNOTFOUND_ERROR;
                if (MQ_ERROR_ACCESS_DENIED == hResult)
                    uErr = g_fServerSetup ? IDS_MACHINECREATE_SERVER_ACCESSDENIED_ERROR : IDS_MACHINECREATE_CLIENT_ACCESSDENIED_ERROR;
                //
                // BUGBUG: the following error code doesn't seem to be declared anywhere
                //         (see bug 3311). ShaiK, 8-Sep-98.
                //
                const HRESULT x_uInvalidDirectoryPathnameErr = 0xc8000500;
                if (x_uInvalidDirectoryPathnameErr == hResult)
                    uErr = IDS_MACHINECREATE_INVALID_DIR_ERROR;
            }
            if (IDRETRY == MqDisplayErrorWithRetry(uErr, hResult))
                continue;
        }
        break;
    }

    if (FAILED(hResult))
    {
        return FALSE;
    }

	return TRUE;
}

//+--------------------------------------------------------------
//
// Function: CreateMSMQConfigurationsObject
//
// Synopsis: Creates MSMQ Configurations object (under computer object)
//           in the DS.
//
//+--------------------------------------------------------------
BOOL
CreateMSMQConfigurationsObject(
    OUT GUID *pguidMachine,
    OUT BOOL *pfObjectCreated,
    IN  BOOL  fMsmq1Server
    )
{
	DebugLogMsg(eAction, L"Createing the MSMQ-Configuration object");
    if (!g_fServerSetup && !g_fDependentClient && !fMsmq1Server)
    {
        //
        // For MSMQ client setup, that run against Windows Active Directory
        // we're not creating the msmqConfiguration object
        // from setup. Rather, we're caching some values in registry
        // and the msmq service, after first boot, will create the object.
        // This eliminates the need to grant extra permissions in the actvie
        // directory to the user that run setup.
        //
        DebugLogMsg(eInfo, L"This is a client setup. The MSMQ-Configuration object will be created by the Message Queuing service.");
        *pfObjectCreated = FALSE;

        BOOL fPrepare =  PrepareRegistryForClient();
        return fPrepare;
    }

	LPWSTR pwzMachineName = NULL;
    GUID guidMsmq1ServerSite;
	if(!CreateMSMQConfigurationsObjectInDS(
			pfObjectCreated, 
			fMsmq1Server, 
			&guidMsmq1ServerSite, 
			&pwzMachineName
			))
	{
		return FALSE;
	}

    //
    // Get the best site and guid of this QM
    //
    GUID guidMachine = GUID_NULL;
    GUID guidSite = GUID_NULL;
    if (!DsGetQmInfo(fMsmq1Server, pwzMachineName, &guidMachine, &guidSite))
    {
        return FALSE;
    }


    //
    // Store QM stuff in registry
    //
    if (fMsmq1Server)
    {
        if (!StoreQueueManagerInfo(
                 TRUE,  /*fFreshSetup*/
                 guidMachine,
                 guidMsmq1ServerSite
                 ))
        {
            return FALSE;
        }
    }
    else
    {
        if (!StoreQueueManagerInfo(
                 TRUE,  /*fFreshSetup*/
                 guidMachine,
                 guidSite
                 ))
        {
            return FALSE;
        }
    }

    //
    // Store the machine guid on the out parameter
    //
    if (pguidMachine != NULL)
    {
        *pguidMachine = guidMachine;
    }

    return TRUE;

} //CreateMSMQConfigurationsObject

//+--------------------------------------------------------------
//
// Function: UpdateMSMQConfigurationsObject
//
// Synopsis: Updates existing MSMQ Configurations object in the DS
//
//+--------------------------------------------------------------
BOOL
UpdateMSMQConfigurationsObject(
    IN LPCWSTR pMachineName,
    IN const GUID& guidMachine,
    IN const GUID& guidSite,
    IN BOOL fMsmq1Server
    )
{   
    if (!g_dwMachineTypeDs && !g_dwMachineTypeFrs)
    {
        //
        // Independent client. QM does the update from DS.
        //
        
        DebugLogMsg(eAction, L"Updating the MSMQ-Configuration object for an independent client");

        return StoreQueueManagerInfo(
                   FALSE,  /*fFreshSetup*/
                   guidMachine,
                   guidSite
                   );
    }

	DebugLogMsg(eAction, L"Updating the MSMQ-Configuration object for a Message Queuing server");
    //
    // Prepare the properties
    //
    const UINT x_nMaxProps = 16;
    PROPID propIDs[x_nMaxProps];
    PROPVARIANT propVariants[x_nMaxProps];
    DWORD ixProperty = 0;

    propIDs[ixProperty] = PROPID_QM_MACHINE_TYPE;
    propVariants[ixProperty].vt = VT_LPWSTR;
    propVariants[ixProperty].pwszVal = L"";
    ixProperty++;

    propIDs[ixProperty] = PROPID_QM_OS;
    propVariants[ixProperty].vt = VT_UI4;
    propVariants[ixProperty].ulVal = g_dwOS;
    ixProperty++;

    GUID guidCns = MQ_SETUP_CN;
    BYTE Address[TA_ADDRESS_SIZE + IP_ADDRESS_LEN];
    if (fMsmq1Server)
    {
        if (!GetGuidCn(&guidCns))
        {
            //
            // Failed to query the MSMQ1 DS Server IPCN
            //
	        DebugLogMsg(eError, L"Querying the MQIS server for IPCN failed.");
            return FALSE;
        }

		ASSERT(guidCns != MQ_SETUP_CN);

        propIDs[ixProperty] = PROPID_QM_CNS;
        propVariants[ixProperty].vt = VT_CLSID|VT_VECTOR;
        propVariants[ixProperty].cauuid.cElems = 1;
        propVariants[ixProperty].cauuid.pElems = &guidCns;
        ixProperty++;

        TA_ADDRESS * pBuffer = reinterpret_cast<TA_ADDRESS *>(Address);
        pBuffer->AddressType = IP_ADDRESS_TYPE;
        pBuffer->AddressLength = IP_ADDRESS_LEN;
        ZeroMemory(pBuffer->Address, IP_ADDRESS_LEN);

        propIDs[ixProperty] = PROPID_QM_ADDRESS;
        propVariants[ixProperty].vt = VT_BLOB;
        propVariants[ixProperty].blob.cbSize = sizeof(Address);
        propVariants[ixProperty].blob.pBlobData = reinterpret_cast<BYTE*>(pBuffer);
        ixProperty++;
    }
    else
    {
        //
        // NT 5.0 enterprise.
        // Get up to date list of sites this computer belongs to.
        //
        propIDs[ixProperty] = PROPID_QM_SITE_IDS;
        propVariants[ixProperty].vt = VT_CLSID|VT_VECTOR;
        CACLSID cauuid;
        if (!GetSites(&cauuid))
            return FALSE;
        propVariants[ixProperty].cauuid.pElems = cauuid.pElems;
        propVariants[ixProperty].cauuid.cElems = cauuid.cElems;
        ixProperty++;
    }


    //
    // Update the object properties in the DS
    // Note: Due to replication delay it's possible to fail here.
    // Resolution: sleep for a while and retry, if fail ask user to cancel/retry.
    //
    // BUGBUG: This should not be done for any failure but only
    // failures that can be caused by replication delay.
    //
    HRESULT hResult;
    UINT uCounter = fMsmq1Server ? 2 : 0;
    for (;;)
    {
        TickProgressBar();
        hResult = ADSetObjectPropertiesGuid(
						eMACHINE,
						NULL,		// pwcsDomainController
						false,		// fServerName
						&guidMachine,
						ixProperty,
						propIDs,
						propVariants
						);
        if (!FAILED(hResult))
            break;

        uCounter++;
        if (1 == uCounter)
        {
            //
            // First time fail. Sleep for a while and retry.
            //
            TickProgressBar();
            Sleep(20000);
            continue;
        }

        if (2 == uCounter)
        {
            //
            // Second time fail. Sleep a little longer and retry.
            //
            TickProgressBar();
            Sleep(40000);
            continue;
        }

        //
        // Third time fail. Let the user decide.
        //
        UINT uErr = fMsmq1Server ? IDS_MACHINESETPROPERTIES_MSMQ1_ERROR :IDS_MACHINESETPROPERTIES_ERROR;
        if (IDRETRY == MqDisplayErrorWithRetry(uErr, hResult))
        {
            uCounter = 0;
            continue;
        }

        break;
    }

    if (FAILED(hResult))
    {
        return FALSE;
    }

    //
    // For MSMQ servers on NT5 we also need to recreate all
    // MSMQSetting objects, to recover any inconsistency in ADS.
    // This is invoked by calling Create on the existing
    // MSMQConfiguration object.  (ShaiK, 24-Dec-1998)
    //
    if (g_dwMachineTypeFrs || g_dwMachineTypeDs)
    {
        ASSERT(("msmq servers should not install in NT4 enterprise", !fMsmq1Server));

        BOOL fObjectCreated ;
        if (!CreateMSMQConfigurationsObject(NULL, &fObjectCreated, FALSE /*fMsmq1Server*/))
        {
            return FALSE;
        }

        ASSERT(fObjectCreated) ;
        return TRUE;
    }


    //
    // Store QM stuff in registry
    //
    if (fMsmq1Server)
    {
        if(!StoreQueueManagerInfo(
                FALSE,  /*fFreshSetup*/
                guidMachine,
                guidSite
                ))
        {
            return FALSE;
        }
    }
    else
    {
        //
        // Get from ADS the up to date "best" site for this computer.
        //
        GUID guidBestSite = GUID_NULL;
        if (!DsGetQmInfo(false, pMachineName, NULL, &guidBestSite))
        {
            return FALSE;
        }
        if(!StoreQueueManagerInfo(
                FALSE,  /*fFreshSetup*/
                guidMachine,
                guidBestSite
                ))
        {
            return FALSE;
        }
    }

    return TRUE;

} //UpdateMSMQConfigurationsObject

//+--------------------------------------------------------------
//
// Function: InstallMachine
//
// Synopsis: Machine installation (driver, storage, etc...)
//
//+--------------------------------------------------------------
BOOL
InstallMachine()
{
    TickProgressBar();
    if (!InstallMSMQService())
    {
        return FALSE ;
    }
    g_fMSMQServiceInstalled = TRUE ;

    //
    // Install the device driver
    //
    if (!InstallDeviceDrivers())
    {
        return FALSE ;
    }    
    
    return TRUE ;

}  //InstallMachine


bool
StoreSecurityDescriptorInRegistry(
    IN PSECURITY_DESCRIPTOR pSd,
    IN DWORD dwSize
    )
/*++

Routine Description:

    Writes the machine security descriptor in Falcon registry

Arguments:

    pSd - pointer to security descriptor
    dwSize - size of the security descriptor

Return Value:

    true iff successful

--*/
{
    BOOL f = MqWriteRegistryValue(
                MSMQ_DS_SECURITY_CACHE_REGNAME,
                dwSize,
                REG_BINARY,
                pSd
                );

    return (f == TRUE);

} //StoreSecurityDescriptorInRegistry


//+--------------------------------------------------------------
//
// Function: StoreMachineSecurity
//
// Synopsis: Caches security info in registry
//
//+--------------------------------------------------------------
BOOL
StoreMachineSecurity(
    IN const GUID &guidMachine
    )
{
    SECURITY_INFORMATION RequestedInformation =
        OWNER_SECURITY_INFORMATION |
        GROUP_SECURITY_INFORMATION |
        DACL_SECURITY_INFORMATION;

    PROPVARIANT varSD;
    varSD.vt = VT_NULL;
    HRESULT hr = ADGetObjectSecurityGuid(
                            eMACHINE,
                            NULL,       // pwcsDomainController
							false,	    // fServerName
                            &guidMachine,
                            RequestedInformation,
                            PROPID_QM_SECURITY,
                            &varSD
							);
    if (SUCCEEDED(hr))
    {
        ASSERT(varSD.vt == VT_BLOB);
        StoreSecurityDescriptorInRegistry(varSD.blob.pBlobData, varSD.blob.cbSize);
        delete varSD.blob.pBlobData;
    }
    else
    {
        MqDisplayError(
            NULL,
            IDS_CACHE_SECURITY_ERROR,
            hr
            );
    }

    return SUCCEEDED(hr);

} // StoreMachineSecurity
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\ocmmail.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmmail.cpp

Abstract:

    Handles Exchange connector.

Author:


Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "ocmmail.tmh"

using namespace std;

//structure of ini file line
typedef struct MQXPMapiSvcLine_Tag
{
	LPTSTR lpszSection;
	LPTSTR lpszKey;
	LPTSTR lpszValue;
} MQXPMapiSvcLine, *LPMQXPMapiSvcLine;

//ini file lines to maintain in mapisvc.inf
MQXPMapiSvcLine g_MQXPMapiSvcLines[] =
{
	{TEXT("Services"),			    TEXT("MSMQ"),						TEXT("Microsoft Message Queue")},
	{TEXT("MSMQ"),				    TEXT("Providers"),				    TEXT("MSMQ_Transport")},
	{TEXT("MSMQ"),				    TEXT("Sections"),					TEXT("MSMQ_Shared_Section")},
	{TEXT("MSMQ"),				    TEXT("PR_SERVICE_DLL_NAME"),		TEXT("mqxp.dll")},
	{TEXT("MSMQ"),				    TEXT("PR_SERVICE_SUPPORT_FILES"),	TEXT("mqxp.dll")},
	{TEXT("MSMQ"),				    TEXT("PR_SERVICE_DELETE_FILES"),	TEXT("mqxp.dll")},
	{TEXT("MSMQ"),				    TEXT("PR_SERVICE_ENTRY_NAME"),	    TEXT("ServiceEntry")},
	{TEXT("MSMQ"),				    TEXT("PR_RESOURCE_FLAGS"),		    TEXT("SERVICE_SINGLE_COPY")},
	{TEXT("MSMQ_Shared_Section"),	TEXT("UID"),						TEXT("80d245f07092cf11a9060020afb8fb50")},
	{TEXT("MSMQ_Transport"),		TEXT("PR_PROVIDER_DLL_NAME"),		TEXT("mqxp.dll")},
	{TEXT("MSMQ_Transport"),		TEXT("PR_RESOURCE_TYPE"),			TEXT("MAPI_TRANSPORT_PROVIDER")},
	{TEXT("MSMQ_Transport"),		TEXT("PR_RESOURCE_FLAGS"),		    TEXT("STATUS_PRIMARY_IDENTITY")},
	{TEXT("MSMQ_Transport"),		TEXT("PR_PROVIDER_DISPLAY"),		TEXT("Microsoft Message Queue Transport")}
};


//+-------------------------------------------------------------------------
//
//  Function: FRemoveMQXPIfExists
//
//  Synopsis: Remove mapi transport (w/o file copy) if it exists  
//
//--------------------------------------------------------------------------
void 
FRemoveMQXPIfExists()
{
	ULONG ulTmp, ulLines;
	LPMQXPMapiSvcLine lpLine;
		
	//
	// Construct mapisvc.inf path
	//
	wstring MapiSvcFile = g_szSystemDir + L"\\mapisvc.inf";

	//
	// Remove each line from mapisvc file
	//
	lpLine = g_MQXPMapiSvcLines;
	ulLines = sizeof(g_MQXPMapiSvcLines)/sizeof(MQXPMapiSvcLine);
	for (ulTmp = 0; ulTmp < ulLines; ulTmp++)
	{
		WritePrivateProfileString(
			lpLine->lpszSection, 
			lpLine->lpszKey, 
			NULL, 
			MapiSvcFile.c_str()
			);
		lpLine++;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\ocmnames.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmnames.h

Abstract:

    To define names which appear in the inf files.

Author:

    Doron Juster  (DoronJ)   6-Oct-97 

Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/


//
// Names for performance counters entries.
//
#define   OCM_PERF_ADDREG    TEXT("PerfCountInstall")
#define   OCM_PERF_DELREG    TEXT("PerfCountUnInstall")

#define   UPG_DEL_SYSTEM_SECTION    TEXT("MsmqUpgradeDelSystemFiles")
#define   UPG_DEL_PROGRAM_SECTION   TEXT("MsmqUpgradeDelProgramFiles")

//
// These directory ids are referred to in the .inf file,
// under section [DestinationDirs]
//
#define  idSystemDir          97000
#define  idMsmqDir            97001
#define  idSystemDriverDir    97005
#define  idExchnConDir        97010
#define  idStorageDir         97019
#define  idWinHelpDir         97020
#define  idWebDir             97021
#define  idMappingDir         97022

#define  idMsmq1SetupDir      97050
#define  idMsmq1SDK_DebugDir  97055
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\ocmperf.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmperf.cpp

Abstract:

    Handle installation and removal of performance counters

Author:

    Doron Juster  (DoronJ)   6-Oct-97  

Revision History:

	Shai Kariv    (ShaiK)   15-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "ocmperf.tmh"

//+-------------------------------------------------------------------------
//
//  Function: UnloadCounters 
//
//  Synopsis: Uninstalls performance counters  
//
//--------------------------------------------------------------------------
void 
UnloadCounters()
{
	//
	// Unload the performance counters
	//
	std::wstringstream RegisterCommandParams;
	RegisterCommandParams <<g_szSystemDir <<L"\\unlodctr.exe";

    RunProcess(RegisterCommandParams.str(), L"unlodctr.exe MSMQ");
    RunProcess(RegisterCommandParams.str(), L"unlodctr.exe MQ1SYNC");

} //UnloadCounters


//+-------------------------------------------------------------------------
//
//  Function: LoadCounters 
//
//  Synopsis: Installs performance counters  
//
//--------------------------------------------------------------------------
void 
LoadCounters()
{

    //
    // Load the performance counters
    //
	std::wstring ApplicationFullPath = g_szSystemDir + L"\\lodctr.exe";
	DWORD dwExitCode = RunProcess(ApplicationFullPath, L"lodctr mqperf.ini");
    //
    // Check if the performance counters were loaded successfully
    //
    if (dwExitCode != 0)
    {
    	MqDisplayError(NULL, IDS_COUNTERSLOAD_ERROR, dwExitCode);
    }
} 


//+-------------------------------------------------------------------------
//
//  Function: HandlePerfCounters 
//
//  Synopsis:   
//
//--------------------------------------------------------------------------
static 
BOOL  
HandlePerfCounters(
	TCHAR *pOp, 
	BOOL *pNoOp = NULL)
{
    if (g_fDependentClient)
    {        
        DebugLogMsg(eInfo, L"This Message Queuing computer is a dependent client. There is no need to install performance counters.");

        if (pNoOp)
        {
            *pNoOp = TRUE ;
        }
        return TRUE ;
    }

    
    UnloadCounters() ;  
    
    DebugLogMsg(eAction, L"Setting registry values for the performance counters");

    if (!SetupInstallFromInfSection( 
		NULL,
        g_ComponentMsmq.hMyInf,
        pOp,
        SPINST_REGISTRY,
        NULL,
        NULL,
        0,
        NULL,
        NULL,
        NULL,
        NULL ))
	{        
        DebugLogMsg(eError, L"The registry values for the performance counters could not be set.");
		return FALSE;
	}
    
    DebugLogMsg(eInfo, L"The registry values for the performance counters were set successfully.");
    return TRUE ;

} //HandlePerfCounters


//+-------------------------------------------------------------------------
//
//  Function: MqOcmInstallPerfCounters 
//
//  Synopsis:   
//
//--------------------------------------------------------------------------
BOOL  
MqOcmInstallPerfCounters()
{    
    DebugLogMsg(eAction, L"Installing performance counters");

    BOOL fNoOp = FALSE ;

    if (!HandlePerfCounters(OCM_PERF_ADDREG, &fNoOp))
    {
        return FALSE ;
    }
    if (fNoOp)
    {
        return TRUE ;
    }

    LoadCounters() ;
    
    DebugLogMsg(eInfo, L"The performance counters were installed successfully.");
    return TRUE ;

} //MqOcmInstallPerfCounters


//+-------------------------------------------------------------------------
//
//  Function: MqOcmRemovePerfCounters 
//
//  Synopsis:   
//
//--------------------------------------------------------------------------
BOOL  
MqOcmRemovePerfCounters()
{
    return HandlePerfCounters(OCM_PERF_DELREG) ;

} //MqOcmRemovePerfCounters
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\ocmmode.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmmode.cpp

Abstract:

    Code to handle setup mode.

Author:

    Doron Juster  (DoronJ)  31-Jul-97

Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "ocmmode.tmh"

BOOL g_fMQDSServiceWasActualSelected = FALSE;
BOOL g_fRoutingSupportWasActualSelected = FALSE;
BOOL g_fHTTPSupportWasActualSelected = FALSE;
BOOL g_fTriggersServiceWasActualSelected = FALSE;


 
//+-------------------------------------------------------------------------
//
//  Function: MqOcmQueryState 
//
//  Synopsis: Returns to OCM the component state (on/off)
//
//--------------------------------------------------------------------------
DWORD
MqOcmQueryState(
    IN const UINT_PTR uWhichState,
    IN const TCHAR    *SubcomponentId
    )
{
    if (g_fCancelled)
        return SubcompUseOcManagerDefault;

    if (SubcomponentId == NULL)
    {        
        return SubcompUseOcManagerDefault;     
    }

    if (OCSELSTATETYPE_FINAL == uWhichState)
    {
        //
        // We are called after COMPLETE_INSTALLATION.
        // Should report our final state to OCM.              
        //
        // we need to return the status of the specific subcomponent
        // after its installation
        //
        return GetSubcomponentFinalState (SubcomponentId);      
    }               


    //
    // We are here only in Add/Remove mode or unattended setup
    //
    DWORD dwInitialState = GetSubcomponentInitialState(SubcomponentId); 

    //
    // uWhichState is OCSELSTATETYPE_ORIGINAL or OCSELSTATETYPE_CURRENT
    // 

    if (OCSELSTATETYPE_ORIGINAL == uWhichState)
    {
        //
        // it is right for both attended and unattended setup
        // It is impossible to return SubcompUseOcManagerDefault since
        // for msmq_HTTPSupport OCM Subcomponents registry can be wrong
        // (we install HTTPSupport at the end after final subcomponent
        // state returning to OCM). So it is better to use our setup registry
        //
        return dwInitialState;
    }

    //
    // uWhichState is OCSELSTATETYPE_CURRENT
    //
    if (g_fBatchInstall)
    {    
        //
        // in such case OCM takes flags ON/OFF from unattended file
        //
        return SubcompUseOcManagerDefault;
    }
    
    //
    // according to the dwInitialState state of that subcomponent
    // will be shown in UI
    //
    return dwInitialState;     

} // MqOcmQueryState

//+-------------------------------------------------------------------------
//
//  Function: DefineDefaultSelection
//
//  Synopsis: Define default subcomponent state
//
//--------------------------------------------------------------------------
DWORD DefineDefaultSelection (
    IN const DWORD_PTR  dwActualSelection,
    IN OUT BOOL        *pbWasActualSelected
    )
{
    if (OCQ_ACTUAL_SELECTION & dwActualSelection)
    {
        //
        // actual selection: accept this change
        //
        *pbWasActualSelected = TRUE;
        return 1;
    }

    //
    // parent was selected: default is do not install subcomponent
    //       
    if (!(*pbWasActualSelected))
    {    
        return 0;            
    }
        
    //
    // we can be here if subcomponent was actually selected but 
    // OCM calls us for such event twice: when the component is actually
    // selected and then when it changes state of the parent.
    // So, in this case accept changes, but reset the flag.
    // We need to reset the flag for the scenario: select some 
    // subcomponents, return to the parent, unselect the parent and then
    // select parent again. In such case we have to put default again.
    //
    *pbWasActualSelected = FALSE;
    return 1;
}


static bool IsDependentClientServer()
{
	DWORD dwDepSrv; 
	if(!MqReadRegistryValue(MSMQ_MQS_DEPCLINTS_REGNAME, sizeof(dwDepSrv), (PVOID) &dwDepSrv, FALSE))
	{
		return false;
	}

	return (dwDepSrv != 0); 
}


//+-------------------------------------------------------------------------
//
//  Function: IsInstallationAccepted
//
//  Synopsis: Verify if it is allowed to install the subcomponent
//
//--------------------------------------------------------------------------
DWORD IsInstallationAccepted(
    IN const UINT       SubcomponentIndex, 
    IN const DWORD_PTR  dwActualSelection)
{
    if (g_fDependentClient &&
        SubcomponentIndex != eMSMQCore)
    {
        //
        // do not accept any selection if dependent client is
        // already installed
        //
        if ((OCQ_ACTUAL_SELECTION & dwActualSelection) || g_fBatchInstall)
        {
            MqDisplayError(NULL, IDS_ADD_SUBCOMP_ON_DEPCL_ERROR, 0);                
        }                
        return 0;
    }
            
    DWORD dwRet;    

    switch (SubcomponentIndex)
    {
    case eMSMQCore: 
    case eLocalStorage:
    case eADIntegrated:
        //
        // always accept this selection
        //
        dwRet = 1;
        break;        

    case eTriggersService:
		//
		// Triggers service is to be off by default.
		//
        return DefineDefaultSelection(
				dwActualSelection, 
				&g_fTriggersServiceWasActualSelected
				);

    case eHTTPSupport:
    {
      
        dwRet = DefineDefaultSelection(
            dwActualSelection, 
            &g_fHTTPSupportWasActualSelected
            );
        if(dwRet ==  0)
        {
            break;
        }

        //
        // always accept HTTP support selection on server
        //

        static fShowOnce = false;
        if(fShowOnce)
        {
            break;
        }
        fShowOnce = true;

        if (MqAskContinue(IDS_ADD_HTTP_WORNING_MSG, IDS_ADD_HTTP_WORNING_TITEL, TRUE,eOkCancelMsgBox))

        {                   
            dwRet =  1;                   
        }
        else
        {                    
            dwRet =  0;
        }

        break;
    }
    case eRoutingSupport:
        if(g_fWorkGroup)
        {
            dwRet = 0;
            if (OCQ_ACTUAL_SELECTION & dwActualSelection)
            {
                MqDisplayError(NULL, IDS_ROUTING_ON_WORKGROUP_ERROR, 0);
            }
        }
        else
        {
            dwRet = DefineDefaultSelection (dwActualSelection, 
                                        &g_fRoutingSupportWasActualSelected);                      
        }
        break;
        
    case eMQDSService  :
        if (g_fWorkGroup)
        {
            dwRet = 0;
            if (OCQ_ACTUAL_SELECTION & dwActualSelection)
            {
                MqDisplayError(NULL, IDS_MQDS_ON_WORKGROUP_ERROR, 0);
            }
        }
        else
        {
            dwRet = DefineDefaultSelection (dwActualSelection, 
                                        &g_fMQDSServiceWasActualSelected);                        
        }
        break;

    default :
        ASSERT(0);
        dwRet = 0;
        break;
    }
             
    return dwRet;            
}


static BOOL IsItOKToRemoveMSMQ()
{
	UINT StringId = IDS_UNINSTALL_AREYOUSURE_MSG;
	if(g_fDependentClient)
	{
		StringId = IDS_DEP_UNINSTALL_AREYOUSURE_MSG;
	}
	else if(IsDependentClientServer())
	{
		StringId = IDS_MSMQ_DEP_CLINT_SERVER_UNINSTALL_WARNING;
	}
                                   
	return MqAskContinue(StringId, IDS_UNINSTALL_AREYOUSURE_TITLE, TRUE, eYesNoMsgBox);
}


//+-------------------------------------------------------------------------
//
//  Function: IsRemovingAccepted
//
//  Synopsis: Verify if it is allowed to remove the subcomponent
//
//--------------------------------------------------------------------------
DWORD IsRemovingAccepted( 
    IN const UINT       SubcomponentIndex, 
    IN const DWORD_PTR  dwActualSelection
	)
{
    if (g_SubcomponentMsmq[SubcomponentIndex].fInitialState == FALSE)
    {
        //            
        // it was not installed, so do nothing, accept all
        //
        return 1;
    }
          
    switch (SubcomponentIndex)
    {
    case eMSMQCore:
        if (OCQ_ACTUAL_SELECTION & dwActualSelection)
		{
			if(IsItOKToRemoveMSMQ())
			{
				return 1;
			}
			return 0;
		}
    case eMQDSService:
    case eTriggersService: 
    case eHTTPSupport:
        return 1;        

    case eRoutingSupport:
        if ((OCQ_ACTUAL_SELECTION & dwActualSelection) && !g_fWorkGroup)
        {            
            MqDisplayError(NULL, IDS_REMOVE_ROUTING_STATE_ERROR, 0);        
            return 0;
        }
        else
        {                
            //
            // accept this selection since probably parent was
            // unselected: all MSMQ will be uninstalled
            //
            return 1;
        }     

    case eLocalStorage:
        if (OCQ_ACTUAL_SELECTION & dwActualSelection)
        {
            MqDisplayError(NULL, IDS_CHANGE_LOCAL_STORAGE_STATE, 0); 
            return 0;
        }
        else
        {
            //
            // accept this selection since probably parent was
            // unselected: all MSMQ will be uninstalled
            //
            return 1;
        }   

    case eADIntegrated:
        if (OCQ_ACTUAL_SELECTION & dwActualSelection)
        {            
			if(g_fServerSetup && (g_dwMachineTypeDs || g_dwMachineTypeFrs))
			{
				//
				// Removing AD integrated for MSMQ servers (DS or routing server)
				// is not supported
				//
				DebugLogMsg(
					eError,
					L"Removing the Active Directory Integration subcomponent from a DS or routing server is not supported. TypeDS = %d, TypeFrs = %d", 
					g_dwMachineTypeDs, 
					g_dwMachineTypeFrs
					); 
				MqDisplayError(NULL, IDS_REMOVE_AD_INTEGRATED, 0); 
				return 0;
			}
			return 1;
        }
        else
        {
            //
            // accept this selection since probably parent was
            // unselected: all MSMQ will be uninstalled
            //
            return 1;
        }  

    default:

        ASSERT(0);
        break;
    }  //end switch
        
    return 0;       
}


static
void
LogSelectionType(
	const TCHAR      *SubcomponentId,    
    const DWORD_PTR   dwActualSelection
    )
{
	std::wstring SelectionType = L"None";
	if(dwActualSelection & OCQ_ACTUAL_SELECTION)
	{
		SelectionType = L"Actual ";
	}
	else if(dwActualSelection & OCQ_DEPENDENT_SELECTION)
	{
		SelectionType = L"Dependent";
	}		
	
	DebugLogMsg(eInfo, L"The %s subcomponent is selected for installation. Selection Type: %s", SubcomponentId, SelectionType.c_str());
}

//+-------------------------------------------------------------------------
//
//  Function: MqOcmQueryChangeSelState
//
//  Synopsis: Set selection state for each component
//
//--------------------------------------------------------------------------
DWORD MqOcmQueryChangeSelState (
    IN const TCHAR      *SubcomponentId,    
    IN const UINT_PTR    iSelection,
    IN const DWORD_PTR   dwActualSelection)
{
	static bool fBeenHere = false;
	if (!fBeenHere)
	{
		DebugLogMsg(eHeader, L"Component Selection Phase");
		fBeenHere = true;
	}
	
    DWORD dwRetCode = 1;    //by default accept state changes        

    //
    // Do not change in this code dwOperation value in this code!
    // It will be done later (in function SetOperationForSubcomponents)
    // for all subcomponents when all selection will be defined by user    
    // Here we have to save the initial state of dwOperation to handle
    // correctly subcomponent selection (Routing or Local Storage)
    //

    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        if (_tcsicmp(SubcomponentId, g_SubcomponentMsmq[i].szSubcomponentId) != 0)
        {
            continue;
        }                
        
        //
        // we found this subcomponent
        //        

        if (iSelection) //subcomponent is selected
        {                                   
            //
            // we need to install subcomponent
            //  
            dwRetCode = IsInstallationAccepted(i, dwActualSelection);                        
              
            if (dwRetCode)
            {
            	LogSelectionType(SubcomponentId, dwActualSelection);
            }            

            return dwRetCode;
        }
        
        //
        // User tries to unselect this subcomponent
        //        
        dwRetCode = IsRemovingAccepted(i, dwActualSelection);       
   
        if (dwRetCode)
        {
            DebugLogMsg(eInfo, L"The %s check box is cleared. The subcomponent will be removed.", SubcomponentId);
        }
        
        return dwRetCode;
        
    }   //end for

    //
    // we are here if parent (msmq) was selected/ deselected
    // Do not enable some of the components, if they are being selected because their parent 
    // is being selected.
    // 
    // checking loginc:
    //    iSelection      -> This tells us that it is being turned on.					
    //    dwActualSelection & OCQ_DEPENDENT_SELECTION -> Tell us that it is selected from its parent
    //     !(dwActualSelection& OCQ_ACTUAL_SELECTION ) -> Tell us that it is not selected itself 
    if ( ( (BOOL) iSelection ) &&					
         ( ( (UINT) (ULONG_PTR) dwActualSelection ) & OCQ_DEPENDENT_SELECTION ) &&
         !( ( (UINT) (ULONG_PTR) dwActualSelection ) & OCQ_ACTUAL_SELECTION ) 
       )
    {
        //
        // Deny request to change state
        //
        return 0;
    }

    //
    // remove all msmq
    //    
    if (g_SubcomponentMsmq[eMSMQCore].fInitialState == FALSE)
    {
        //
        // it was not installed
        //
        return 1;
    }

    if (!(OCQ_ACTUAL_SELECTION & dwActualSelection))
    {            
        dwRetCode = 1;
    }
    else if (IsItOKToRemoveMSMQ())
    {         
        dwRetCode = 1;
    }
    else
    {         
        dwRetCode = 0;
    }      
        
    return dwRetCode;
} // MqOcmQueryChangeSelState
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\ocmsrv.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmsrv.cpp

Abstract:

    Code for ocm setup of server.

Author:

    Doron Juster  (DoronJ)  26-Jul-97

Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "ocmsrv.tmh"

//+--------------------------------------------------------------
//
// Function: CreateMSMQServiceObject
//
// Synopsis: Creates MSMQ Service object in the DS (if not exists)
//
//+--------------------------------------------------------------
BOOL
CreateMSMQServiceObject(
	UINT uLongLive /* = MSMQ_DEFAULT_LONG_LIVE */
	)
{
	//
	// Lookup the object in the DS
	//
	GUID guidMSMQService;
	if (!GetMSMQServiceGUID(&guidMSMQService))
	    return FALSE; // Failed to lookup


    if (GUID_NULL == guidMSMQService)
	{
		//
		// MSMQ Service object does not exist. Create a new one.
		//
		PROPID      propIDs[] = {PROPID_E_LONG_LIVE};
		const DWORD nProps = sizeof(propIDs) / sizeof(propIDs[0]);
		PROPVARIANT propVariants[nProps] ;
		DWORD       iProperty = 0 ;

		propVariants[iProperty].vt = VT_UI4;
		propVariants[iProperty].ulVal = uLongLive ;
		iProperty++ ;

		ASSERT( iProperty == nProps);
		HRESULT hResult;
        do
        {
            hResult = ADCreateObject(
                        eENTERPRISE,
						NULL,       // pwcsDomainController
						false,	    // fServerName
                        NULL,
                        NULL,
                        nProps,
                        propIDs,
                        propVariants,
                        NULL
                        );
            if(SUCCEEDED(hResult))
                break;

        }while (MqDisplayErrorWithRetry(
                            IDS_OBJECTCREATE_ERROR,
                            hResult
                            ) == IDRETRY);

		if (FAILED(hResult))
		{
			return FALSE;
		}
	}

    return TRUE;

} //CreateMSMQServiceObject
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\ocmremov.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmremov.cpp

Abstract:

    Code to remove a Falcon installation

Author:

    Doron Juster  (DoronJ)  02-Aug-97   

Revision History:

    Shai Kariv    (ShaiK)   22-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"

#include "ocmremov.tmh"

struct
{
    TCHAR * szRegistryKey;
    TCHAR cStoragePrefix;
    TCHAR szDirectory[MAX_PATH];
}
s_descStorageTypes[] = {
    {MSMQ_STORE_RELIABLE_PATH_REGNAME, 'R'},
    {MSMQ_STORE_PERSISTENT_PATH_REGNAME, 'P'},
    {MSMQ_STORE_JOURNAL_PATH_REGNAME, 'J'},
    {MSMQ_STORE_LOG_PATH_REGNAME, 'L'},
};

const UINT s_uNumTypes = sizeof(s_descStorageTypes) / sizeof(s_descStorageTypes[0]);


//+-------------------------------------------------------------------------
//
//  Function: GetGroupPath
//
//  Synopsis: Gets the start menu Programs item path
//
//--------------------------------------------------------------------------
static
std::wstring 
GetGroupPath(
    LPCWSTR szGroupName
    )
{    
    DebugLogMsg(eAction, L"Getting the path for Programs in the Start menu");

    LPITEMIDLIST   pidlPrograms;
    HRESULT hr = SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, &pidlPrograms);
	if FAILED(hr)
	{
		DebugLogMsg(eError, L"SHGetSpecialFolderLocation() failed. hr = 0x%x", hr);
		return L"";
	}

	WCHAR buffer[MAX_PATH + 1] = L"";
    if(!SHGetPathFromIDList(pidlPrograms, buffer))
	{
		DebugLogMsg(eError, L"SHGetPathFromIDList() failed for %s", buffer);
		return L"";
	}
    
    DebugLogMsg(eInfo, L"The group path is %s.", buffer);
	std::wstring Path = buffer;

    if (szGroupName != NULL)
    {
        if(Path[Path.length() - 1] != L'\\')
        {
           Path += L"\\";
        }
        Path += szGroupName;
    }
    
    DebugLogMsg(eInfo, L"The full path is %s.", Path.c_str());
	return Path;

} // GetGroupPath


//+-------------------------------------------------------------------------
//
//  Function: DeleteStartMenuGroup
//
//  Synopsis: Removes MSMQ 1.0 shortcuts from start menu
//
//--------------------------------------------------------------------------
VOID
DeleteStartMenuGroup(
    IN LPCTSTR szGroupName
    )
{    
    DebugLogMsg(eInfo, L"The Start menu group %s will be deleted.", szGroupName);

	std::wstring Path = GetGroupPath(szGroupName);
	if(Path.empty())
	{
		return;
	}

    DeleteFilesFromDirectoryAndRd(Path);

    SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, Path.c_str(), 0);

} // DeleteStartMenuGroup


//+-------------------------------------------------------------------------
//
//  Function: DeleteMSMQConfigurationsObject 
//
//  Synopsis: Deletes MSMQ Configurations object from the DS
//
//--------------------------------------------------------------------------
static 
BOOL 
DeleteMSMQConfigurationsObject()
{
    DWORD dwWorkgroup = 0;
    if (MqReadRegistryValue(
            MSMQ_WORKGROUP_REGNAME,
            sizeof(dwWorkgroup),
            (PVOID) &dwWorkgroup
            ))
    {
        if (1 == dwWorkgroup)
            return TRUE;
    }

    BOOL bDeleted = FALSE;

    //
    // Load and initialize the DS library
    //
    if (!LoadDSLibrary())
        return (!g_fMSMQAlreadyInstalled); // It's OK if not installed

    //
    // Obtain the GUID of this QM from the DS
    //
    TickProgressBar();
    PROPID propID = PROPID_QM_MACHINE_ID;
    PROPVARIANT propVariant;
    propVariant.vt = VT_NULL;
    HRESULT hResult;
    do
    {
        hResult = ADGetObjectProperties(
                    eMACHINE,
                    NULL,	// pwcsDomainController
					false,	// fServerName
                    g_wcsMachineName,
                    1, 
                    &propID, 
                    &propVariant
                    );
        if(SUCCEEDED(hResult))
            break;

    }while( MqDisplayErrorWithRetry(
                        IDS_MACHINEREMOTEGETID_ERROR,
                        hResult
                        ) == IDRETRY);

    if (SUCCEEDED(hResult))
    { 
        //
        // Delete the MSMQ Configuration object from the DS
        //
        TickProgressBar();
        for (;;)
        {
            hResult = ADDeleteObjectGuid(
							eMACHINE,
							NULL,       // pwcsDomainController
							false,	    // fServerName
							propVariant.puuid
							);

            if (FAILED(hResult))
            {
                UINT uErrorId = g_fServerSetup ? IDS_SERVER_MACHINEDELETE_ERROR : IDS_MACHINEDELETE_ERROR;
                if (MQDS_E_MSMQ_CONTAINER_NOT_EMPTY == hResult)
                {
                    //
                    // The MSMQ Configuration object container is not empty.
                    //
                    uErrorId = g_fServerSetup ? IDS_SERVER_MACHINEDELETE_NOTEMPTY_ERROR : IDS_MACHINEDELETE_NOTEMPTY_ERROR;
                }
                if (IDRETRY == MqDisplayErrorWithRetry(uErrorId, hResult))
                    continue;
            }
            break;
        }

        
        if (SUCCEEDED(hResult))
        {
            bDeleted = TRUE;
        }
    }

    return bDeleted;

} //DeleteMSMQConfigurationsObject


//+-------------------------------------------------------------------------
//
//  Function: DeleteFilesFromDirectoryAndRd 
//
//  Synopsis: Deletes all the files from the specified directory. Remove the directory
//            if it is empty and not in use (RemoveDirectory function called at the end)
//
//--------------------------------------------------------------------------
void 
DeleteFilesFromDirectoryAndRd( 
	const std::wstring& Directory
    )
{    
    DebugLogMsg(eAction, L"Removing files in the folder %s", Directory.c_str());

    WIN32_FIND_DATA FoundFileData;
	std::wstring CurrentPath = Directory + L"\\*";
    HANDLE hFindFile = FindFirstFile(
							CurrentPath.c_str(), 
							&FoundFileData
							);

    if (hFindFile == INVALID_HANDLE_VALUE)
    {
        RemoveDirectory(Directory.c_str());
        return;
    }

    do
    {
        if (FoundFileData.cFileName[0] == '.')
            continue;
        //
        // Make the file read /write
        //
        if (FoundFileData.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
        {
            SetFileAttributes( 
                FoundFileData.cFileName,
                FILE_ATTRIBUTE_NORMAL
                );
        }
		std::wstring CurrentFile = Directory + L"\\" + FoundFileData.cFileName;
 
        //
        //directory:
        //
        if (FoundFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {                                                  
            DeleteFilesFromDirectoryAndRd(CurrentFile);
        }
        //
        //file:
        //
        else
        {
           if(!DeleteFile(CurrentFile.c_str()))
           {
                DebugLogMsg(eWarning, L"DeleteFile() failed for %s.", CurrentFile.c_str());
           }

        }
    }
    while (FindNextFile(hFindFile, &FoundFileData));

    FindClose(hFindFile);
    RemoveDirectory(Directory.c_str());
} 


//+-------------------------------------------------------------------------
//
//  Function: MqSetupDeleteStorageFiles 
//
//  Synopsis:  
//
//--------------------------------------------------------------------------
static 
BOOL 
MqSetupDeleteStorageFiles(VOID)
{
//    TCHAR szFirstFileTemplate[MAX_PATH] = {_T("")};

    //
    // Initialize path of storage folders (read from registry).
    //
    for (UINT uType = 0; uType < s_uNumTypes ; uType++ )
    {
        s_descStorageTypes[uType].szDirectory[0] = TEXT('\0') ;
        //
        // Otain the directory associated with the storage type
        // Note: Errors are ignored - we simply proceed to the next directory
        //
        MqReadRegistryValue( 
            s_descStorageTypes[uType].szRegistryKey,
            sizeof(s_descStorageTypes[0].szDirectory),
            s_descStorageTypes[uType].szDirectory);
    }

    //
    // Remove all the storage files associated with each registry value
    //

    for ( uType = 0 ; uType < s_uNumTypes ; uType++ )
    {
        //
        // Obtain the directory associated with the storage type
        //
        if (s_descStorageTypes[uType].szDirectory[0] == TEXT('\0'))
        {
            continue;
        }

        //
        // Delete all the files in the directory 
        //
        DeleteFilesFromDirectoryAndRd(
            s_descStorageTypes[uType ].szDirectory
            );                           
    }

    return TRUE;

} //MqSetupDeleteStorageFiles


//+-------------------------------------------------------------------------
//
//  Function: RemoveInstallationInternal 
//
//  Synopsis: (Note: We ignore errors)  
//
//--------------------------------------------------------------------------
static 
BOOL  
RemoveInstallationInternal()
{

    //
    // Remove the performance counters.
    //
    BOOL fSuccess =  MqOcmRemovePerfCounters() ;
    ASSERT(fSuccess) ;

    //
    // Unregister the ActiveX object.
    //
    RegisterActiveX(FALSE) ;


    //
    // Unregister the mqsnapin DLL
    //
    RegisterSnapin(/* fRegister = */FALSE);

    //
    // Unregister Tracing WMI
    //
    OcpUnregisterTraceProviders();

    //
    // Remove MSMQ replication service (if exists)
    //
    TickProgressBar();
	RemoveService(MQ1SYNC_SERVICE_NAME);

    //
    // Remove msmq and mqds services and driver
    //
    TickProgressBar();
    
    RemoveService(MSMQ_SERVICE_NAME);
    
    RemoveService(MSMQ_DRIVER_NAME);
    
    //
    // Remove files (storage and others)
    //
    TickProgressBar();
    MqSetupDeleteStorageFiles();

    TickProgressBar();
    if (g_fServerSetup && g_dwMachineTypeDs)
    {
        //
        // Remove MSMQ DS server
        //
        fSuccess = DeleteMSMQConfigurationsObject();
    }
    else if (!g_fDependentClient)
    {
        //
        // Remove MSMQ independent client
        //
        fSuccess = DeleteMSMQConfigurationsObject() ;
    }
    else
    {
        //
        // Dependent client. Nothing to do.
        //
    }  

    return TRUE ;

} //RemoveInstallationInternal



//+-------------------------------------------------------------------------
//
//  Function: MqOcmRemoveInstallation 
//
//  Note:     We ignore errors
//
//--------------------------------------------------------------------------
BOOL  
MqOcmRemoveInstallation(IN     const TCHAR  * SubcomponentId)
{    
    if (SubcomponentId == NULL)
    {
        return NO_ERROR;
    }    

    if (g_fCancelled)
    {
        return NO_ERROR;
    }

    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        if (_tcsicmp(SubcomponentId, g_SubcomponentMsmq[i].szSubcomponentId) != 0)
        {
            continue;
        }                  

        //
        // verify if we need to remove this subcomponent
        //
        if (g_SubcomponentMsmq[i].dwOperation != REMOVE)
        {
            //
            // do nothing: this component was not selected for removing
            //
            return NO_ERROR;
        }
        
        //
        // We found this subcomponent in the array
        //
        if (g_SubcomponentMsmq[i].pfnRemove == NULL)
        {           
            ASSERT(("There is no specific removing function", 0));
            return NO_ERROR ; 
        }

        //
        // only in this case we have to remove it
        //               
        
        //
        // BUGBUG: we have to check that MSMQ Core must be removed 
        // the last!
        //      
        DebugLogMsg(eHeader, L"Removing the %s Subcomponent", SubcomponentId);        

        BOOL fRes = g_SubcomponentMsmq[i].pfnRemove();
        
        //
        // remove registry in any case
        //
        FinishToRemoveSubcomponent (i); 
        if (fRes)
        {
            //
            // subcomponent was removed successfully
            //                                     
        }
        else
        {
            //
            // if removing failed we have to remove registry anyway
            // since we can't leave half-removed component as
            // "installed" (if there is registry entry we assume that
            // subcomponent is installed)
            //
            DebugLogMsg(eWarning, L"The %s subcomponent could not be removed.", SubcomponentId);
        }              
        return NO_ERROR;
    }    
        

    ASSERT (("Subcomponent for removing is not found", 0));
    return NO_ERROR; //BUGBUG: what to return
}

BOOL RemoveMSMQCore()
{
    static BOOL fAlreadyRemoved = FALSE ;

    if (fAlreadyRemoved)
    {
        //
        // We're called more than once.
        //
        return NO_ERROR ;
    }
    fAlreadyRemoved = TRUE ;
    
    DebugLogMsg(eInfo, L"Starting RemoveMsmqCore(), the main uninstallation routine for MSMQ");
    TickProgressBar(IDS_PROGRESS_REMOVE);		

    BOOL fRes =  RemoveInstallationInternal();

    //
    // Cleanup registry. Registry is needed when deleting storage files
    // so do it only after files were deleted.
    //
    RegDeleteKey(FALCON_REG_POS, MSMQ_REG_SETUP_KEY);
    RegDeleteKeyWithSubkeys(FALCON_REG_POS, FALCON_REG_KEY);
    RegDeleteKey(FALCON_REG_POS, FALCON_REG_MSMQ_KEY) ;

    LPCTSTR x_RUN_KEY = _T("software\\microsoft\\windows\\currentVersion\\Run\\");
    CAutoCloseRegHandle hKey;
    if (ERROR_SUCCESS == RegOpenKeyEx(FALCON_REG_POS, x_RUN_KEY, 0, KEY_ALL_ACCESS, &hKey))
    {
        RegDeleteValue(hKey, RUN_INT_CERT_REGNAME);
    }    

    UnregisterWelcome();

    DeleteFilesFromDirectoryAndRd(g_szMsmqDir);

    return fRes ;

} //RemoveMSMQCore()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\ocmreg.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmreg.cpp

Abstract:

    Registry related code for ocm setup.

Author:

    Doron Juster  (DoronJ)  26-Jul-97

Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include <autohandle.h>
#include "ocmreg.tmh"

//+-------------------------------------------------------------------------
//
//  Function:  GenerateSubkeyValue
//
//  Synopsis:  Creates a subkey in registry
//
//+-------------------------------------------------------------------------

BOOL
GenerateSubkeyValue(
    IN     const BOOL    fWriteToRegistry,
    const std::wstring& EntryName,
    IN OUT       HKEY*   phRegKey,
    IN const BOOL OPTIONAL bSetupRegSection = FALSE
    )
{
    //
    // Store the full subkey path and value name
    //

	std::wstringstream KeyName;

    if (bSetupRegSection)
    {
        KeyName <<MSMQ_REG_SETUP_KEY <<L"\\" <<EntryName;
    }
	else
	{
		KeyName <<FALCON_REG_KEY <<L"\\" <<EntryName;
	}

    //
    // Create the subkey, if necessary
    //
    DWORD dwDisposition;
    HRESULT hResult = RegCreateKeyEx(
        FALCON_REG_POS,
        KeyName.str().c_str(),
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        phRegKey,
        &dwDisposition
		);

    if (hResult != ERROR_SUCCESS && fWriteToRegistry)
    {
        MqDisplayError(NULL, IDS_REGISTRYOPEN_ERROR, hResult, FALCON_REG_POS_DESC, KeyName.str());
        return FALSE;
    }

    return TRUE;
} // GenerateSubkeyValue


std::wstring 
GetKeyName(
	const std::wstring& EntryName
	)
{
	size_t pos = EntryName.find_last_of(L"\\");
	if (pos == std::wstring::npos)
	{
		return L"";
	}
	return EntryName.substr(0, pos);
}


std::wstring
GetValueName(
	const std::wstring& EntryName
	)
{
	size_t pos = EntryName.find_last_of(L"\\");
	if (pos == std::wstring::npos)
	{
		return EntryName;
	}

	size_t StartIndex = pos + 1;
	size_t NumberOfCharacters = (UINT)EntryName.length() - StartIndex;
	return EntryName.substr(StartIndex, NumberOfCharacters);
}


//+-------------------------------------------------------------------------
//
//  Function:  MqWriteRegistryValue
//
//  Synopsis:  Sets a MSMQ value in registry (under MSMQ key)
//
//+-------------------------------------------------------------------------
BOOL
MqWriteRegistryValue(
    IN const TCHAR  * szEntryName,
    IN const DWORD   dwNumBytes,
    IN const DWORD   dwValueType,
    IN const PVOID   pValueData,
    IN const BOOL OPTIONAL bSetupRegSection /* = FALSE */
    )
{
	std::wstring KeyName  = GetKeyName(szEntryName);
    CRegHandle hRegKey;
    if (!GenerateSubkeyValue(
			TRUE, 
			KeyName.c_str(), 
			&hRegKey, 
			bSetupRegSection
			))
	{
		return FALSE;
	}

    //
    // Set the requested registry value
    //
	std::wstring ValueName  = GetValueName(szEntryName);
    HRESULT hResult = RegSetValueEx( 
		hRegKey, 
		ValueName.c_str(), 
		0, 
		dwValueType,
		(BYTE *)pValueData, 
		dwNumBytes
		);

    RegFlushKey(hRegKey);

    if (hResult != ERROR_SUCCESS)
    {
          MqDisplayError( NULL, IDS_REGISTRYSET_ERROR, hResult, szEntryName);
          return FALSE;
    }
   	LogRegValue(
		szEntryName,
		dwValueType,
		pValueData,
		bSetupRegSection
		);

    return (hResult == ERROR_SUCCESS);

} //MqWriteRegistryValue


BOOL
MqWriteRegistryStringValue(
	std::wstring EntryName,
    std::wstring ValueData,
    IN const BOOL OPTIONAL bSetupRegSection  /*= FALSE */
	)
{
	size_t NumBytes = (ValueData.length() + 1) * sizeof(WCHAR);
    return MqWriteRegistryValue(
				EntryName.c_str(), 
				(DWORD)NumBytes, 
				REG_SZ, 
				(VOID*)ValueData.c_str(),
				bSetupRegSection
				);
}


//+-------------------------------------------------------------------------
//
//  Function:  MqReadRegistryValue
//
//  Synopsis:  Gets a MSMQ value from registry (under MSMQ key)
//
//+-------------------------------------------------------------------------
BOOL
MqReadRegistryValue(
    IN     const TCHAR  * szEntryName,
    IN OUT       DWORD   dwNumBytes,
    IN OUT       PVOID   pValueData,
    IN const BOOL OPTIONAL bSetupRegSection /* = FALSE */
    )
{
	std::wstring KeyName = GetKeyName(szEntryName);
	std::wstring ValueName  = GetValueName(szEntryName);

    CRegHandle hRegKey;

    if (!GenerateSubkeyValue(
			FALSE, 
			KeyName.c_str(), 
			&hRegKey, 
			bSetupRegSection
			))
	{
        return FALSE;
	}

    //
    // Get the requested registry value
    //
    HRESULT hResult = RegQueryValueEx(
							hRegKey, 
							ValueName.c_str(), 
							0, 
							NULL,
                            (BYTE*)pValueData, 
							&dwNumBytes
							);

    return (hResult == ERROR_SUCCESS);

} //MqReadRegistryValue


std::wstring
MqReadRegistryStringValue(
    const std::wstring& EntryName,
    IN const BOOL OPTIONAL bSetupRegSection /* = FALSE */
    )
{
	WCHAR buffer[MAX_PATH + 1] = L"";
	BOOL b = MqReadRegistryValue(
				EntryName.c_str(),
				sizeof(buffer),
				(VOID*)buffer,
				bSetupRegSection /* = FALSE */
				);
    if(!b)
	{
		return L"";
	}
	return buffer;
}

//+-------------------------------------------------------------------------
//
//  Function:  RegDeleteKeyWithSubkeys
//
//  Synopsis:
//
//+-------------------------------------------------------------------------
DWORD
RegDeleteKeyWithSubkeys(
    IN const HKEY    hRootKey,
    IN const LPCTSTR szKeyName)
{
    //
    // Open the key to delete
    //
    HKEY hRegKey;
    DWORD rc = RegOpenKeyEx(
					hRootKey, 
					szKeyName, 
					0,
					KEY_ENUMERATE_SUB_KEYS | KEY_WRITE, 
					&hRegKey
					);

	if (rc != ERROR_SUCCESS)
	{
        DebugLogMsg(eWarning, L"The registry key %s could not be deleted. Error = %d", szKeyName, rc);            

		return rc;
	}

    //
    // Recursively delete all subkeys of the key
    //
    TCHAR szSubkeyName[512] = {_T("")};
    DWORD dwNumChars;
    do
    {
        //
        // Check if the key has any subkeys
        //
        dwNumChars = 512;
        rc = RegEnumKeyEx(hRegKey, 0, szSubkeyName, &dwNumChars,
                               NULL, NULL, NULL, NULL);

        //
        // Delete the subkey
        //
        if (rc == ERROR_SUCCESS)
        {
            rc = RegDeleteKeyWithSubkeys(hRegKey, szSubkeyName);
        }

    } while (rc == ERROR_SUCCESS);

    //
    // Close the key
    //
    RegCloseKey(hRegKey);

    //
    // If there are no more subkeys, delete the key itself
    //
    if (rc == ERROR_NO_MORE_ITEMS)
    {
        rc = RegDeleteKey(hRootKey, szKeyName);
    }

    return rc;

} //RegDeleteKeyWithSubkeys


//+--------------------------------------------------------------
//
// Function: StoreServerPathInRegistry
//
// Synopsis: Writes server name in registry
//
//+--------------------------------------------------------------
BOOL
StoreServerPathInRegistry(
	const std::wstring& ServerName
    )
{
    DebugLogMsg(eAction, L"Storing the Message Queuing DS server name %ls in the registry", ServerName.c_str()); 
    
	std::wstring ServerPath = L"11" + ServerName;
    if (!MqWriteRegistryStringValue( MSMQ_DS_SERVER_REGNAME, ServerPath))
    {
        return FALSE;
    }

    if (!MqWriteRegistryStringValue(MSMQ_DS_CURRENT_SERVER_REGNAME, ServerPath))
    {
        return FALSE;
    }

	if(!WriteDsEnvRegistry(MSMQ_DS_ENVIRONMENT_MQIS))
    {
        return FALSE;
    }

    return TRUE;
} //StoreServerPathInRegistry


//+-------------------------------------------------------------------------
//
//  Function:   RegisterWelcome
//
//  Synopsis:   Registers this setup for Configure Your Server page.
//              We use CYS in 2 scenarios:
//              1. When MSMQ is selected in GUI mode.
//              2. When MSMQ is upgraded on Cluster.
//
//--------------------------------------------------------------------------
BOOL
RegisterWelcome()
{
    //
    // Create the ToDoList\MSMQ key
    //
    DWORD dwDisposition;
    HKEY hKey;
    HRESULT hResult = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        WELCOME_TODOLIST_MSMQ_KEY,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &dwDisposition
        );
    if (hResult != ERROR_SUCCESS)
    {
        MqDisplayError( NULL, IDS_REGISTRYOPEN_ERROR, hResult,
                        HKLM_DESC, WELCOME_TODOLIST_MSMQ_KEY);
        return FALSE;
    }

    //
    // Set the MSMQ values
    //
    CResString strWelcomeTitleData(IDS_WELCOME_TITLE_DATA);
    if (Msmq1InstalledOnCluster() && !g_fDependentClient)
    {
        strWelcomeTitleData.Load(IDS_WELCOME_TITLE_CLUSTER_UPGRADE);
    }
    hResult = RegSetValueEx(
        hKey,
        WELCOME_TITLE_NAME,
        0,
        REG_SZ,
        (PBYTE)strWelcomeTitleData.Get(),
        sizeof(TCHAR) * (lstrlen(strWelcomeTitleData.Get()) + 1)
        );

    if (hResult != ERROR_SUCCESS)
    {
          MqDisplayError(
              NULL,
              IDS_REGISTRYSET_ERROR,
              hResult,
              WELCOME_TITLE_NAME
              );
          RegCloseKey(hKey);
          return FALSE;
    }

    LPTSTR szConfigCommand = TEXT("sysocmgr.exe");
    hResult = RegSetValueEx(
        hKey,
        WELCOME_CONFIG_COMMAND_NAME,
        0,
        REG_SZ,
        (PBYTE)szConfigCommand,
        sizeof(TCHAR) * (lstrlen(szConfigCommand) + 1)
        );
    if (hResult != ERROR_SUCCESS)
    {
          MqDisplayError(
              NULL,
              IDS_REGISTRYSET_ERROR,
              hResult,
              WELCOME_CONFIG_COMMAND_NAME
              );
          RegCloseKey(hKey);
          return FALSE;
    }

    TCHAR szConfigArgs[MAX_STRING_CHARS];
    lstrcpy(szConfigArgs, TEXT("/i:mqsysoc.inf /x"));
    hResult = RegSetValueEx(
        hKey,
        WELCOME_CONFIG_ARGS_NAME,
        0,
        REG_SZ,
        (PBYTE)szConfigArgs,
        sizeof(TCHAR) * (lstrlen(szConfigArgs) + 1)
        );
    if (hResult != ERROR_SUCCESS)
    {
          MqDisplayError(
              NULL,
              IDS_REGISTRYSET_ERROR,
              hResult,
              WELCOME_CONFIG_ARGS_NAME
              );
          RegCloseKey(hKey);
          return FALSE;
    }

    RegCloseKey(hKey);

    //
    // Flag in MSMQ registry that MSMQ files are already on disk.
    // This is true both wheh msmq is selected in GUI mode and when
    // upgrading on Cluster.
    //
    DWORD dwCopied = 1;
    MqWriteRegistryValue(MSMQ_FILES_COPIED_REGNAME, sizeof(DWORD), REG_DWORD, &dwCopied, TRUE);

    return TRUE;

} // RegisterWelcome


//+-------------------------------------------------------------------------
//
//  Function:   UnregisterWelcome
//
//  Synopsis:   Unregisters this setup from Welcome UI
//
//--------------------------------------------------------------------------
BOOL
UnregisterWelcome()
{
    return (ERROR_SUCCESS == RegDeleteKey(
                                 HKEY_LOCAL_MACHINE,
                                 WELCOME_TODOLIST_MSMQ_KEY
                                 ));

} // UnregisterWelcome


//+-------------------------------------------------------------------------
//
//  Function:   RegisterMigrationForWelcome
//
//  Synopsis:   Registers the migration utility for Welcome UI
//
//--------------------------------------------------------------------------
BOOL
RegisterMigrationForWelcome()
{
    //
    // Create the ToDoList\MSMQ key
    //
    DWORD dwDisposition;
    HKEY hKey;
    HRESULT hResult = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        WELCOME_TODOLIST_MSMQ_KEY,
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &dwDisposition
        );
    if (hResult != ERROR_SUCCESS)
    {
        MqDisplayError( NULL, IDS_REGISTRYOPEN_ERROR, hResult,
                        HKLM_DESC, WELCOME_TODOLIST_MSMQ_KEY);
        return FALSE;
    }

    //
    // Set the MSMQ values
    //
    CResString strWelcomeTitleData(IDS_MIGRATION_WELCOME_TITLE_DATA);
    hResult = RegSetValueEx(
        hKey,
        WELCOME_TITLE_NAME,
        0,
        REG_SZ,
        (PBYTE)strWelcomeTitleData.Get(),
        sizeof(TCHAR) * (lstrlen(strWelcomeTitleData.Get()) + 1)
        );

    if (hResult != ERROR_SUCCESS)
    {
          MqDisplayError(
              NULL,
              IDS_REGISTRYSET_ERROR,
              hResult,
              WELCOME_TITLE_NAME
              );
          RegCloseKey(hKey);
          return FALSE;
    }

    TCHAR szConfigCommand[MAX_STRING_CHARS];
    lstrcpy(szConfigCommand, g_szSystemDir.c_str());
    lstrcat(szConfigCommand, TEXT("\\"));
    lstrcat(szConfigCommand, MQMIG_EXE);
    hResult = RegSetValueEx(
        hKey,
        WELCOME_CONFIG_COMMAND_NAME,
        0,
        REG_SZ,
        (PBYTE)szConfigCommand,
        sizeof(TCHAR) * (lstrlen(szConfigCommand) + 1)
        );
    if (hResult != ERROR_SUCCESS)
    {
          MqDisplayError(
              NULL,
              IDS_REGISTRYSET_ERROR,
              hResult,
              WELCOME_CONFIG_COMMAND_NAME
              );
          RegCloseKey(hKey);
          return FALSE;
    }

    RegCloseKey(hKey);

    return TRUE;

} // RegisterMigrationForWelcome

//+-------------------------------------------------------------------------
//
//  Function:   SetRegistryValue
//
//  Synopsis:   Set Registry Value
//
//--------------------------------------------------------------------------
BOOL SetRegistryValue (IN const HKEY    hKey, 
                       IN const TCHAR   *pszEntryName,
                       IN const DWORD   dwNumBytes,
                       IN const DWORD   dwValueType,
                       IN const PVOID   pValueData)
{
    HRESULT hResult = RegSetValueEx(
                            hKey,
                            pszEntryName,
                            0,
                            dwValueType,
                            (BYTE *)pValueData,
                            dwNumBytes
                            );
    if (hResult != ERROR_SUCCESS)
    {
          MqDisplayError(
              NULL,
              IDS_REGISTRYSET_ERROR,
              hResult,
              pszEntryName
              );          
          return FALSE;
    }

    
    RegFlushKey(hKey);        

    return TRUE;
} //SetRegistryValue



BOOL RemoveRegistryKeyFromSetup (IN const LPCTSTR szRegistryEntry)
{
    CAutoCloseRegHandle hSetupRegKey;
    if (ERROR_SUCCESS != RegOpenKeyEx(
                            FALCON_REG_POS, 
                            MSMQ_REG_SETUP_KEY, 
                            0, 
                            KEY_ALL_ACCESS, 
                            &hSetupRegKey))
    {    
        DebugLogMsg(eWarning, L"The %s registry key could not be opened.", MSMQ_REG_SETUP_KEY);    
        return FALSE;
    }

    if (ERROR_SUCCESS != RegDeleteValue(
                            hSetupRegKey, 
                            szRegistryEntry))
    { 
        
		DebugLogMsg(eWarning, L"The %s registry value could not be deleted.", szRegistryEntry);
        return FALSE;
    }

    return TRUE;

} //RemoveRegistryKeyFromSetup

BOOL
SetWorkgroupRegistry()
{
	DebugLogMsg(eAction, L"Setting the Workgroup registry value to 1");
    DWORD dwWorkgroup = 1;
    if (!MqWriteRegistryValue(
        MSMQ_WORKGROUP_REGNAME,
        sizeof(DWORD),
        REG_DWORD,
        (PVOID) &dwWorkgroup
        ))
    {
        ASSERT(("failed to write Workgroup value in registry", 0));
        return false;
    }

    return true;
}


CMultiString
GetMultistringFromRegistry(
	HKEY hKey,
    LPCWSTR lpValueName
    )
{
	DWORD dwType = REG_MULTI_SZ;
    DWORD SizeInBytes;
    
	//
	// Call first to determin the required buffer size.
	//
	HRESULT hr = RegQueryValueEx(
					hKey,
					lpValueName,
					NULL,
					&dwType,
					NULL,
					&SizeInBytes
					);
	if(hr == ERROR_FILE_NOT_FOUND)
	{
		//
		// Return an empty Multistring.
		//
		CMultiString multi;
		return multi;
	}


    if(hr != ERROR_SUCCESS)
    {
        DebugLogMsg(eError, L"RegQueryValueEx() for the value %s failed. Return code: 0x%x", lpValueName, hr); 
        throw bad_hresult(hr);
    }

    AP<BYTE> buff = new BYTE[SizeInBytes];

	//
	// Now call to get the value.
	//

	hr = RegQueryValueEx(
			hKey,
			lpValueName,
			NULL,
			&dwType,
			(PBYTE)buff,
			&SizeInBytes
			);
    if(hr != ERROR_SUCCESS)
    {
        DebugLogMsg(eError, L"RegQueryValueEx() for the value %s failed. Return code: 0x%x", lpValueName, hr); 
        throw bad_hresult(hr);
    }

	CMultiString multi((LPCWSTR)(buff.get()), SizeInBytes / sizeof(WCHAR));;
	return multi;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\ocmutil.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ocmutil.cpp

Abstract:

    utility code for ocm setup.

Author:

    Doron Juster  (DoronJ)  26-Jul-97

Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <lmjoin.h>
#include <clusapi.h>
#include <mqmaps.h>
#include <autohandle.h>
#include <wbemidl.h>
#include <strsafe.h>
#include <setupdef.h>

using namespace std;

#include "ocmutil.tmh"



std::wstring g_szSystemDir;  // system32 directory
std::wstring g_szMsmqDir;    // Root directory for MSMQ
std::wstring g_szMsmq1SetupDir;
std::wstring g_szMsmq1SdkDebugDir;
std::wstring g_szMsmqMappingDir;

PNETBUF<WCHAR> g_wcsMachineDomain;


//+-------------------------------------------------------------------------
//
//  Function:   StpLoadDll
//
//  Synopsis:   Handle library load.
//
//--------------------------------------------------------------------------
HRESULT
StpLoadDll(
    IN  const LPCTSTR   szDllName,
    OUT       HINSTANCE *pDllHandle)
{
	DebugLogMsg(eAction, L"Loading the DLL %s", szDllName); 
    HINSTANCE hDLL = LoadLibrary(szDllName);
    *pDllHandle = hDLL;
    if (hDLL == NULL)
    {
        MqDisplayError(NULL, IDS_DLLLOAD_ERROR, GetLastError(), szDllName);
        return MQ_ERROR;
    }
    else
    {
        return MQ_OK;
    }
} //StpLoadDll


static bool GetUserSid(LPCWSTR UserName, PSID* ppSid)
/*++
Routine Description:
	Get sid corresponding to user name.

Arguments:
	UserName - user name	
	ppSid - pointer to PSID

Returned Value:
	true if success, false otherwise	

--*/
{
	DebugLogMsg(eAction, L"Getting the SID for %s", UserName);
	*ppSid = NULL;

    DWORD dwDomainSize = 0;
    DWORD dwSidSize = 0;
    SID_NAME_USE su;

	//
	// Get buffer size.
	//
    BOOL fSuccess = LookupAccountName(
						NULL,
						UserName,
						NULL,
						&dwSidSize,
						NULL,
						&dwDomainSize,
						&su
						);

    if (fSuccess || (GetLastError() != ERROR_INSUFFICIENT_BUFFER))
    {
		DWORD gle = GetLastError();
        DebugLogMsg(eError, L"LookupAccountName() failed to get the SID for the user %ls. Last error: 0x%x", UserName, gle);
        return false;
    }

	//
	// Get sid and domain information.
	//
    AP<BYTE> pSid = new BYTE[dwSidSize];
    AP<WCHAR> szRefDomain = new WCHAR[dwDomainSize];

    fSuccess = LookupAccountName(
					NULL,
					UserName,
					pSid,
					&dwSidSize,
					szRefDomain,
					&dwDomainSize,
					&su
					);

    if (!fSuccess)
    {
		DWORD gle = GetLastError();
		DebugLogMsg(eError, L"LookupAccountName() failed to get the SID for the user %ls. Last error: 0x%x", UserName, gle);
        return false;
    }

    ASSERT(su == SidTypeUser);

	*ppSid = pSid.detach();

	return true;
}


//+-------------------------------------------------------------------------
//
//  Function:   SetDirectorySecurity
//
//  Synopsis:   Configure security on the folder such that any file will have
//              full control for the local admin group and no access for others.
//
//--------------------------------------------------------------------------
void
SetDirectorySecurity(
	LPCTSTR pFolder,
	bool fWebDirPermission,
	LPCWSTR IISAnonymousUserName
    )
{
	DebugLogMsg(eAction, L"Setting security for the folder %s.", pFolder);
	AP<BYTE> pIISAnonymousUserSid;
	if(fWebDirPermission)
	{
		//
		// Ignore errors, only write tracing to msmqinst
		//
		if((IISAnonymousUserName == NULL) || !GetUserSid(IISAnonymousUserName, reinterpret_cast<PSID*>(&pIISAnonymousUserSid)))
		{
			DebugLogMsg(
				eWarning,
				L"The SID for the user %ls could not be obtained. The Internet guest account permissions will not be set on the Web directory %ls. As a result, HTTPS messages will not be accepted by this computer until the IUSR_MACHINE permissions are added to the Web directory.",
				IISAnonymousUserName,
				pFolder
				);
		}
	}

    //
    // Get the SID of the local administrators group.
    //
	PSID pAdminSid = MQSec_GetAdminSid();

    //
    // Create a DACL so that the local administrators group will have full
    // control for the directory and full control for files that will be
    // created in the directory. Anybody else will not have any access to the
    // directory and files that will be created in the directory.
    //
    DWORD dwDaclSize = sizeof(ACL) +
					  (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
					  GetLengthSid(pAdminSid);

	if(pIISAnonymousUserSid != NULL)
	{
		dwDaclSize += (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
					  GetLengthSid(pIISAnonymousUserSid);

	}

	P<ACL> pDacl = (PACL)(char*) new BYTE[dwDaclSize];

    //
    // Create the security descriptor and set it as the security
    // descriptor of the directory.
    //
    SECURITY_DESCRIPTOR SD;

	if(!InitializeSecurityDescriptor(&SD, SECURITY_DESCRIPTOR_REVISION))
	{
	        DebugLogMsg(
	        	eError,
				L"The security descriptor for the folder %ls could not be set. InitializeSecurityDescriptor() failed. Last error: = 0x%x",
				pFolder,
				GetLastError()
				);
			return;
	}
	if(!InitializeAcl(pDacl, dwDaclSize, ACL_REVISION))
	{
	        DebugLogMsg(
	        	eError,
				L"The security descriptor for the folder %ls could not be set. InitializeAcl() failed. Last error: = 0x%x",
				pFolder,
				GetLastError()
				);
			return;
	}

	//
	// We give different permisssions for IIS directories and other directories.
	//
	if(pIISAnonymousUserSid != NULL)
	{
		//
		// if pIISAnonymousUserSid we will Add AllowAce with FILE_GENERIC_WRITE permissions for administrator.
		//
		if(!AddAccessAllowedAceEx(pDacl, ACL_REVISION, OBJECT_INHERIT_ACE, FILE_GENERIC_WRITE | FILE_GENERIC_READ, pAdminSid))
		{
	        DebugLogMsg(
	        	eError,
				L"The security descriptor for the folder %ls could not be set. AddAccessAllowedAceEx() failed. Last error: = 0x%x",
				pFolder,
				GetLastError()
				);
			return;
		}

		//
		// if pIISAnonymousUserSid we will Add AllowAce with FILE_GENERIC_WRITE permissions for IUSR_MACHINE
		//
		if(!AddAccessAllowedAceEx(pDacl, ACL_REVISION, OBJECT_INHERIT_ACE, FILE_GENERIC_WRITE, pIISAnonymousUserSid))
		{
	        DebugLogMsg(
	        	eError,
				L"The security descriptor for the folder %ls could not be set. AddAccessAllowedAceEx() failed. Last error: = 0x%x",
				pFolder,
				GetLastError()
				);
			return;
		}
	}
	else
	{
	    if(!AddAccessAllowedAceEx(pDacl, ACL_REVISION, OBJECT_INHERIT_ACE, FILE_ALL_ACCESS, pAdminSid))
		{
	        DebugLogMsg(
	        	eError,
				L"The security descriptor for the folder %ls could not be set. AddAccessAllowedAceEx() failed. Last error: = 0x%x",
				pFolder,
				GetLastError()
				);
			return;
		}
	}
    if(!SetSecurityDescriptorDacl(&SD, TRUE, pDacl, FALSE))
	{
	        DebugLogMsg(
	        	eError,
				L"The security descriptor for the folder %ls could not be set. SetSecurityDescriptorDacl() failed. Last error: = 0x%x",
				pFolder,
				GetLastError()
				);
			return;
	}
    if(!SetFileSecurity(pFolder, DACL_SECURITY_INFORMATION, &SD))
	{
	    DebugLogMsg(
	    	eError,
			L"The security descriptor for the folder %ls could not be set. SetFileSecurity() failed. Last error: = 0x%x",
			pFolder,
			GetLastError()
			);
		return;

	}

    DebugLogMsg(eInfo, L"The security descriptor for the folder %ls was set.", pFolder);

} //SetDirectorySecurity


//+-------------------------------------------------------------------------
//
//  Function:   StpCreateDirectoryInternal
//
//  Synopsis:   Handle directory creation.
//
//--------------------------------------------------------------------------
static
BOOL
StpCreateDirectoryInternal(
    IN const TCHAR * lpPathName,
	IN bool fWebDirPermission,
	IN const WCHAR* IISAnonymousUserName
    )
{
    if (!CreateDirectory(lpPathName, 0))
    {
        DWORD dwError = GetLastError();
        if (dwError != ERROR_ALREADY_EXISTS)
        {
            DebugLogMsg(eError, L"The %ls folder could not be created. Last error: 0x%x", lpPathName, dwError);
            MqDisplayError(NULL, IDS_COULD_NOT_CREATE_DIRECTORY, dwError, lpPathName);
            return FALSE;
        }
    }

    SetDirectorySecurity(lpPathName, fWebDirPermission, IISAnonymousUserName);

    return TRUE;

} //StpCreateDirectoryInternal


//+-------------------------------------------------------------------------
//
//  Function:   StpCreateDirectory
//
//  Synopsis:   Handle directory creation.
//
//--------------------------------------------------------------------------
BOOL
StpCreateDirectory(
	const std::wstring& PathName
    )
{
	return StpCreateDirectoryInternal(
				PathName.c_str(),
				false,	// fWebDirPermission
				NULL	// IISAnonymousUserName
				);
} //StpCreateDirectory


//+-------------------------------------------------------------------------
//
//  Function:   StpCreateWebDirectory
//
//  Synopsis:   Handle web directory creation.
//
//--------------------------------------------------------------------------
BOOL
StpCreateWebDirectory(
    IN const TCHAR* lpPathName,
	IN const WCHAR* IISAnonymousUserName
    )
{
	return StpCreateDirectoryInternal(
				lpPathName,
				true,	// fWebDirPermission
				IISAnonymousUserName
				);
} //StpCreateWebDirectory


//+-------------------------------------------------------------------------
//
//  Function:   IsDirectory
//
//  Synopsis:
//
//--------------------------------------------------------------------------
BOOL
IsDirectory(
    IN const TCHAR * szFilename
    )
{
    DWORD attr = GetFileAttributes(szFilename);

    if ( INVALID_FILE_ATTRIBUTES == attr )
    {
		DWORD gle = GetLastError();
		DebugLogMsg(eError,L"The call to GetFileAttributes() for %s failed. Last error: 0x%d", szFilename, gle);
        return FALSE;
    }

    return ( 0 != ( attr & FILE_ATTRIBUTE_DIRECTORY ) );

} //IsDirectory


//+-------------------------------------------------------------------------
//
//  Function:   MqOcmCalcDiskSpace
//
//  Synopsis:   Calculates disk space for installing/removing MSMQ component
//
//--------------------------------------------------------------------------
void
MqOcmCalcDiskSpace(
    const bool bInstall,
    LPCWSTR SubcomponentId,
    HDSKSPC& hDiskSpaceList
	)
{
	static bool fBeenHere = false;
	if(!fBeenHere)
	{
		fBeenHere = true;
	}
#ifdef _WIN64
	//
	// In 64bit there is no dependent client, and therfore no local storage.
	//
	SubcomponentIndex si = eMSMQCore;
#else
	SubcomponentIndex si = eLocalStorage;
#endif


	if(_tcsicmp(SubcomponentId, g_SubcomponentMsmq[si].szSubcomponentId) != 0)
	{
		return;
	}

	if(g_SubcomponentMsmq[si].fInitialState)
	{
		return;
	}


    LONGLONG x_llDiskSpace = 7*1024*1024;

    if (g_fCancelled)
        return ;

    if (bInstall)
    {
		if(!SetupAddToDiskSpaceList(
			hDiskSpaceList,      // handle to the disk-space list
			L"msmq_dummy",  // specifies the path and filename
			x_llDiskSpace,      // specifies the uncompressed filesize
			FILEOP_COPY,         // specifies the type of file operation
			0,        // must be zero
			0          // must be zero
			))
		{
			DWORD gle = GetLastError();
			DebugLogMsg(eError, L"SetupAddToDiskSpaceList() failed. Last error: 0x%x", gle);
			throw bad_win32_error(gle);
		}
		return;
    }
    //
    // Remove the files space
    //
	if(!SetupRemoveFromDiskSpaceList(
		hDiskSpaceList,      // handle to the disk-space list
		L"msmq_dummy",  // specifies the path and filename
		FILEOP_COPY,          // specifies the type of file operation
		0,        // must be zero
		0          // must be zero
		))
	{
		DWORD gle = GetLastError();
		DebugLogMsg(eError, L"SetupRemoveFromDiskSpaceList() failed. Last error: 0x%x", gle);
		throw bad_win32_error(gle);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   MqOcmQueueFiles
//
//  Synopsis:   Performs files queueing operations
//
//--------------------------------------------------------------------------
DWORD
MqOcmQueueFiles(
   IN     const TCHAR  * /*SubcomponentId*/,
   IN OUT       HSPFILEQ hFileList
   )
{
    DWORD dwRetCode = NO_ERROR;
    BOOL  bSuccess = TRUE;

    if (g_fCancelled)
    {
        return NO_ERROR;
    }

    if (g_fWelcome)
    {
        if (Msmq1InstalledOnCluster())
        {
            //
            // Running as a cluster upgrade wizard, files are already on disk.
            //
            return NO_ERROR;
        }

        //
        // MSMQ files may have already been copied to disk
        // (when msmq is selected in GUI mode, or upgraded).
        //
        DWORD dwCopied = 0;
        MqReadRegistryValue(MSMQ_FILES_COPIED_REGNAME, sizeof(DWORD), &dwCopied, TRUE);

        if (dwCopied != 0)
        {
            return NO_ERROR;
        }
    }

    //
    // we perform file operation only for MSMQCore subcomponent
    //
    if (REMOVE == g_SubcomponentMsmq[eMSMQCore].dwOperation)
    {
        //
        // do nothing: we do not remove binaries from the computer
        //
        return NO_ERROR;
    }

    //
    // we perform file operation only for MSMQCore subcomponent
    //
    if (INSTALL == g_SubcomponentMsmq[eMSMQCore].dwOperation)
    {
        //
        // Check if this upgrade on cluster
        //
        BOOL fUpgradeOnCluster = g_fUpgrade && Msmq1InstalledOnCluster();

        if (!fUpgradeOnCluster)
        {
            if (!StpCreateDirectory(g_szMsmqDir))
            {
                return GetLastError();
            }

	        if (g_fUpgrade)
			{
				//
				// create mapping dir and file on upgrade
				// On fresh install the QM create the directory and file
				//
				HRESULT hr = CreateMappingFile();
				if (FAILED(hr))
				{
					return hr;
				}
			}
        }

        //
        // On upgrade, delete old MSMQ files.
        // First delete files from system directory.
        //
        if (g_fUpgrade)
        {

#ifndef _WIN64
            //
            // Before deleting MSMQ Mail files below (Msmq2Mail, Msmq2ExchConnFile), unregister them
            //
            FRemoveMQXPIfExists();
            DebugLogMsg(eInfo, L"MSMQ MAPI Transport was removed during upgrade.");
            UnregisterMailoaIfExists();
            DebugLogMsg(eInfo, L"The MSMQ Mail COM DLL was unregistered during upgrade.");

#endif //!_WIN64

            bSuccess = SetupInstallFilesFromInfSection(
                g_ComponentMsmq.hMyInf,
                0,
                hFileList,
                UPG_DEL_SYSTEM_SECTION,
                NULL,
                SP_COPY_IN_USE_NEEDS_REBOOT
                );
            if (!bSuccess)
                MqDisplayError(
                NULL,
                IDS_SetupInstallFilesFromInfSection_ERROR,
                GetLastError(),
                UPG_DEL_SYSTEM_SECTION,
                TEXT("")
                );

            //
            // Secondly, delete files from MSMQ directory (forget it if we're on cluster,
            // 'cause we don't touch the shared disk)
            //
            if (!fUpgradeOnCluster)
            {
                bSuccess = SetupInstallFilesFromInfSection(
                    g_ComponentMsmq.hMyInf,
                    0,
                    hFileList,
                    UPG_DEL_PROGRAM_SECTION,
                    NULL,
                    SP_COPY_IN_USE_NEEDS_REBOOT
                    );
                if (!bSuccess)
                    MqDisplayError(
                    NULL,
                    IDS_SetupInstallFilesFromInfSection_ERROR,
                    GetLastError(),
                    UPG_DEL_PROGRAM_SECTION,
                    TEXT("")
                    );
            }
        }
    }

    dwRetCode = bSuccess ? NO_ERROR : GetLastError();

    return dwRetCode;

} // MqOcmQueueFiles


//+-------------------------------------------------------------------------
//
//  Function:   RegisterSnapin
//
//  Synopsis:   Registers or unregisters the mqsnapin DLL
//
//--------------------------------------------------------------------------
void
RegisterSnapin(
    bool fRegister
    )
{
	if(fRegister)
	{
    	DebugLogMsg(eAction, L"Registering the Message Queuing snap-in");
	}
	else
	{
    	DebugLogMsg(eAction, L"Unregistering the Message Queuing snap-in");
	}
		

    for (;;)
    {
        try
        {
            RegisterDll(
                fRegister,
                false,
                SNAPIN_DLL
                );
            
            if(fRegister)
			{
    			DebugLogMsg(eInfo, L"The Message Queuing snap-in was registered successfully.");
			}
			else
			{
		    	DebugLogMsg(eInfo, L"The Message Queuing snap-in was unregistered successfully.");
			}
            break;
        }
        catch(bad_win32_error e)
        {
        if (MqDisplayErrorWithRetry(
                IDS_SNAPINREGISTER_ERROR,
                e.error()
                ) != IDRETRY)
            {
                break;
            }

        }
    }
} // RegisterSnapin


//+-------------------------------------------------------------------------
//
//  Function:   UnregisterMailoaIfExists
//
//  Synopsis:   Unregisters the mqmailoa DLL if exists
//
//--------------------------------------------------------------------------
void
UnregisterMailoaIfExists(
    void
    )
{
    RegisterDll(
        FALSE,
        FALSE,
        MQMAILOA_DLL
        );
}


bool
IsWorkgroup()
/*++

Routine Description:

    Checks if this machines is joined to workgroup / domain

Arguments:

    None

Return Value:

    true iff we're in workgroup, false otherwise (domain)

--*/
{
	DebugLogMsg(eAction, L"Checking whether the computer belongs to a workgroup or to a domain");
    static bool fBeenHere = false;
    static bool fWorkgroup = true;
    if (fBeenHere)
        return fWorkgroup;
    fBeenHere = true;

    NETSETUP_JOIN_STATUS status;
    NET_API_STATUS rc = NetGetJoinInformation(
                            NULL,
                            &g_wcsMachineDomain,
                            &status
                            );
    ASSERT(("NetGetJoinInformation() failed, not enough memory",NERR_Success == rc));

    if (NERR_Success != rc)
    {
    	DebugLogMsg(eInfo, L"The computer does not belong to a domain.");
        return fWorkgroup; // Defaulted to true
    }

    if (NetSetupDomainName == status)
    {
    	DebugLogMsg(eInfo, L"The computer belongs to the %s domain.", g_wcsMachineDomain);
        fWorkgroup = false;

        DWORD dwNumBytes = (lstrlen(g_wcsMachineDomain) + 1) * sizeof(TCHAR);
        BOOL fSuccess = MqWriteRegistryValue(
                                MSMQ_MACHINE_DOMAIN_REGNAME,
                                dwNumBytes,
                                REG_SZ,
                               (PVOID) g_wcsMachineDomain.get()
							   );
        UNREFERENCED_PARAMETER(fSuccess);
        ASSERT(fSuccess);
    }
    else
    {
        ASSERT(("unexpected machine join status", status <= NetSetupWorkgroupName));
    }

    return fWorkgroup;
}//IsWorkgroup


VOID
APIENTRY
SysprepDeleteQmId(
    VOID
    )
/*++

Routine Description:

    This routine is called from sysprep tool before
    starting duplication of the disk. It is called
    regardless of msmq being installed or not.

    The only thing we need to do is delete the QM
    guid from registry (if it exists there).

    Note: do not raise UI in this routine.

Arguments:

    None.

Return Value:

    None. (sysprep ignores our return code)

--*/
{
    CAutoCloseRegHandle hParamKey;
    if (ERROR_SUCCESS != RegOpenKeyEx(FALCON_REG_POS, FALCON_REG_KEY, 0, KEY_ALL_ACCESS, &hParamKey))
    {
        return;
    }

    DWORD dwSysprep = 1;
    if (ERROR_SUCCESS != RegSetValueEx(
                             hParamKey,
                             MSMQ_SYSPREP_REGNAME,
                             0,
                             REG_DWORD,
                             reinterpret_cast<PBYTE>(&dwSysprep),
                             sizeof(DWORD)
                             ))
    {
        return;
    }

	std::wstringstream MachineCacheKey;
	MachineCacheKey<<FALCON_REG_KEY <<L"\\" <<L"MachineCache";

    CAutoCloseRegHandle hMachineCacheKey;
    if (ERROR_SUCCESS != RegOpenKeyEx(FALCON_REG_POS, MachineCacheKey.str().c_str(), 0, KEY_ALL_ACCESS, &hMachineCacheKey))
    {
        return;
    }

    if (ERROR_SUCCESS != RegDeleteValue(hMachineCacheKey, _T("QMId")))
    {
        return;
    }

} //SysprepDeleteQmId


static
HRESULT
CreateSampleFile(
	LPCWSTR fileName,
	LPCSTR sample,
	DWORD sampleSize
	)
{
	std::wstringstream MappingFile;
	MappingFile<<g_szMsmqMappingDir <<L"\\" <<fileName;

    //
    // Create the redirection file
    //
    CHandle hMapFile = CreateFile(
                          MappingFile.str().c_str(),
                          GENERIC_WRITE,
                          FILE_SHARE_READ,
                          NULL,
                          CREATE_ALWAYS,    //overwrite the file if it already exists
                          FILE_ATTRIBUTE_NORMAL,
                          NULL
                          );

	if(hMapFile == INVALID_HANDLE_VALUE)
	{
        DWORD gle = GetLastError();
        MqDisplayError(NULL, IDS_CREATE_MAPPING_FILE_ERROR, gle, MappingFile.str().c_str());
		return HRESULT_FROM_WIN32(gle);
	}

    SetFilePointer(hMapFile, 0, NULL, FILE_END);

    DWORD dwNumBytes = sampleSize;
    BOOL fSucc = WriteFile(hMapFile, sample, sampleSize, &dwNumBytes, NULL);
	if (!fSucc)
	{
		DWORD gle = GetLastError();
        MqDisplayError(NULL, IDS_CREATE_MAPPING_FILE_ERROR, gle, MappingFile.str().c_str());
		return HRESULT_FROM_WIN32(gle);
	}

	return MQ_OK;
}

HRESULT
CreateMappingFile()
/*++

Routine Description:

    This routine creates mapping directory and sample mapping file.
    It called when files are copied or from CompleteUpgradeOnCluster routine.

    It fixes bug 6116 and upgrade on cluster problem: it is impossible to copy
    this file since mapping directory does not yet exists. Now we create
    directory and create the file from resource, so we don't need copy operation.

Arguments:

    None.

Return Value:

    HRESULT

--*/
{
	DebugLogMsg(eAction, L"Creating a mapping folder and a sample mapping file"); 
    if (!StpCreateDirectory(g_szMsmqMappingDir))
    {
        return GetLastError();
    }

	HRESULT hr = CreateSampleFile(MAPPING_FILE, xMappingSample, STRLEN(xMappingSample));
	if (FAILED(hr))
		return hr;
	
	hr = CreateSampleFile(STREAM_RECEIPT_FILE, xStreamReceiptSample, STRLEN(xStreamReceiptSample));
	if (FAILED(hr))
		return hr;
	
	hr = CreateSampleFile(OUTBOUNT_MAPPING_FILE, xOutboundMappingSample, STRLEN(xOutboundMappingSample));

    return hr;
}


static
std::wstring
GetSystemPathInternal(bool f32BitOnWin64)
{
	const DWORD BufferLength = MAX_PATH + 100;
    TCHAR szPrefixDir[BufferLength];
    szPrefixDir[0] = TEXT('\0');

    if (f32BitOnWin64)
    {
		//
		// for 32 bit on win64 set szPrefixDir to syswow64 dir
		//
		HRESULT hr = SHGetFolderPath(
						NULL,
						CSIDL_SYSTEMX86,
						NULL,
						0,
						szPrefixDir
						);
		if FAILED(hr)
		{
			DebugLogMsg(eError, L"SHGetFolderPath() failed. hr = 0x%x", hr);
			throw bad_win32_error(HRESULT_CODE(hr));
		}
	    return szPrefixDir;
    }
	return g_szSystemDir;
}

//+-------------------------------------------------------------------------
//
//  Function:   RegisterDll
//
//  Synopsis:   Registers or unregisters given DLL
//
//--------------------------------------------------------------------------
void
RegisterDll(
    bool fRegister,
    bool f32BitOnWin64,
	LPCTSTR szDllName
    )
{
    //
    // Always unregister first
    //
	std::wstringstream FullPath;
	FullPath <<GetSystemPathInternal(f32BitOnWin64) <<L"\\" <<REGSVR32;

	std::wstringstream UnregisterCommandParams;
	UnregisterCommandParams <<SERVER_UNINSTALL_COMMAND <<GetSystemPathInternal(f32BitOnWin64) <<L"\\" <<szDllName;
	
	RunProcess(FullPath.str(), UnregisterCommandParams.str());

    //
    // Register the dll on install
    //
    if (!fRegister)
        return;

	std::wstringstream RegisterCommandParams;
	RegisterCommandParams <<SERVER_INSTALL_COMMAND <<GetSystemPathInternal(f32BitOnWin64) <<L"\\" <<szDllName;

    DWORD dwExitCode = 	RunProcess(FullPath.str(), RegisterCommandParams.str());
    if(dwExitCode == 0)
    {
        DebugLogMsg(eInfo, L"The DLL %s was registered successfully.", szDllName);
        return;
    }
	DebugLogMsg(eError, L"The DLL %s could not be registered.", szDllName);
}

static
HRESULT 
OcpWBEMInit(
    BOOL *pfInitialized,
    IWbemServices **ppServices,
    IWbemLocator **ppLocator
    )
{
    HRESULT hr = S_OK;
    WCHAR   wszNamespace[MAX_PATH+1];

    *pfInitialized = FALSE;

    hr = StringCchCopy(
            wszNamespace, 
            TABLE_SIZE(wszNamespace), 
            TRACE_NAMESPACE_ROOT
            );
	

    hr = CoInitialize(0);
    
    *pfInitialized = TRUE;

    hr = CoInitializeSecurity(
            NULL, 
            -1, 
            NULL, 
            NULL, 
            RPC_C_AUTHN_LEVEL_CONNECT, 
            RPC_C_IMP_LEVEL_IMPERSONATE, 
            NULL, 
            EOAC_NONE, 
            0
            );
	
    if(RPC_E_TOO_LATE == hr)
    {
        //
        //Has been called before
        //
        hr = S_OK;
    }

    if(FAILED(hr))
    {
        DebugLogMsg(eError, L"CoInitializeSecurity failed with hr = 0x%x", hr);
        return hr;
    }
		
    hr = CoCreateInstance(
            CLSID_WbemLocator,
            NULL, 
            CLSCTX_INPROC_SERVER ,
            IID_IWbemLocator,
            (void **)ppLocator
            );

    if(FAILED(hr))	
    {
        DebugLogMsg(eError, L"CoCreateInstance failed with hr = 0x%x", hr);
        return hr;
    }
	
    hr = (*ppLocator)->ConnectServer(
            wszNamespace,   // pNamespace is to initialized with "root\default"
            NULL,           //using current account
            NULL,           //using current password
            0L,             // locale
            0L,             // securityFlags
            NULL,           // authority (NTLM domain)
            NULL,           // context
            ppServices
            );

    if(FAILED(hr))
    {
        DebugLogMsg(eError, L"WMI ConnectServer to %s failed with hr = 0x%x", wszNamespace, hr);
        return hr;
    }

    //	    
    // Switch security level to IMPERSONATE. 
    //
    hr = CoSetProxyBlanket(
            *ppServices,    // proxy
            RPC_C_AUTHN_WINNT,          // authentication service
            RPC_C_AUTHZ_NONE,           // authorization service
            NULL,                       // server principle name
            RPC_C_AUTHN_LEVEL_CALL,     // authentication level
            RPC_C_IMP_LEVEL_IMPERSONATE,// impersonation level
            NULL,                       // identity of the client
            EOAC_NONE                   // capability flags
            );       
	

    return hr;
}

static
void 
OcpWBEMUninit(
    BOOL *pfInitialized,
    IWbemServices **ppServices,
    IWbemLocator **ppLocator)
{
    if(NULL != *ppServices)
    {
        (*ppServices)->Release();
        *ppServices = NULL;
    }
	
    if(NULL != *ppLocator)
    {
        (*ppLocator)->Release(); 
        *ppLocator = NULL;
    }

    if(*pfInitialized)
    {
        CoUninitialize();
        *pfInitialized = FALSE;
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   RegisterTraceProviders
//
//  Synopsis:   Registers/Unregister MSMQ WMI Trace Providers
//
//--------------------------------------------------------------------------
void
OcpRegisterTraceProviders(
    LPCTSTR szFileName
    )
{

    DebugLogMsg(eAction, L"Registering the MSMQ Trace WMI Provider %s", szFileName);

    //
    // Always unregister first
    //
    std::wstringstream FullPath;
    FullPath <<GetSystemPathInternal(false) <<MOFCOMP;


    std::wstringstream RegisterCommandParams;
    RegisterCommandParams <<TRACE_REGISTER_COMMAND <<GetSystemPathInternal(false) <<L"\\" <<szFileName;

    DWORD dwExitCode = 	RunProcess(FullPath.str(), RegisterCommandParams.str());
    if(dwExitCode == 0)
    {
        DebugLogMsg(eInfo, L"The MSMQ WMI Trace Provider: %s was registered successfully.", szFileName);
        return;
    }
 
    DebugLogMsg(eError, L"Failed to register MSMQ Trace WMI Provider %s, dwExitCode = 0x%x.", szFileName, dwExitCode);
    return;
 
} // OcpRegisterTraceProviders


void OcpUnregisterTraceProviders()
{	
    
    BOOL fInitialized = FALSE;
    IWbemServices *pServices = NULL;
    IWbemLocator  *pLocator  = NULL;

    DebugLogMsg(eAction, L"UnRegistering the MSMQ Trace WMI Provider");

    HRESULT hr = OcpWBEMInit(&fInitialized, &pServices, &pLocator);

    if(FAILED(hr))
    {
        DebugLogMsg(eError, L"OcpWBEMInit failed with hr = 0x%x", hr);
        return;
    }

    pServices->DeleteClass(MSMQ_GENERAL, 0, 0, NULL);
    pServices->DeleteClass(MSMQ_AC, 0, 0, NULL);
    pServices->DeleteClass(MSMQ_NETWORKING, 0, 0, NULL);
    pServices->DeleteClass(MSMQ_SRMP, 0, 0, NULL);
    pServices->DeleteClass(MSMQ_RPC, 0, 0, NULL);
    pServices->DeleteClass(MSMQ_DS, 0, 0, NULL);
    pServices->DeleteClass(MSMQ_ROUTING, 0, 0, NULL);
    pServices->DeleteClass(MSMQ_XACT, 0, 0, NULL);
    pServices->DeleteClass(MSMQ_XACT_SEND, 0, 0, NULL);
    pServices->DeleteClass(MSMQ_XACT_RCV, 0, 0, NULL);
    pServices->DeleteClass(MSMQ_XACT_LOG, 0, 0, NULL);
    pServices->DeleteClass(MSMQ_LOG, 0, 0, NULL);
    pServices->DeleteClass(MSMQ_PROFILING, 0, 0, NULL);
    pServices->DeleteClass(MSMQ_SECURITY, 0, 0, NULL);

    OcpWBEMUninit(&fInitialized,&pServices, &pLocator);

} // OcpUnRegisterTraceProviders


void OcpRemoveWhiteSpaces(std::wstring& str)
{
	size_t pos = str.find_first_of(L" ");
	while (pos != std::wstring::npos)
	{
		str.erase(pos);
		pos = str.find_first_of(L" ");
	}
}


void SetWeakSecurity(bool fWeak)
{
/*++
	Two regKeys are set. When MQDS service is started, it checks these keyes and sets
	the "mSMQNameStyle" key, under the MSMQ Enterprize Object. This key is the Weakened Security key.
--*/

	if(fWeak)
	{
		DebugLogMsg(eAction, L"Setting weakened security to True");
	}
	else
	{
		DebugLogMsg(eAction, L"Setting weakened security to False");
	}
	
	DWORD dwSet = 1;
	if(fWeak)
	{
		MqWriteRegistryValue(
			MSMQ_ALLOW_NT4_USERS_REGNAME,
			sizeof(DWORD),
			REG_DWORD,
			&dwSet
			);
		return;
	}

	MqWriteRegistryValue(
		MSMQ_DISABLE_WEAKEN_SECURITY_REGNAME,
		sizeof(DWORD),
		REG_DWORD,
		&dwSet
		);
}

//
// Locale aware and unaware strings compare.
//
static
bool
OcmCompareString(
	LCID Locale,       // locale identifier
	DWORD dwCmpFlags,  // comparison-style options
	LPCWSTR lpString1, // first string
	LPCWSTR lpString2 // second string
	)
{
	int retval = CompareString(
					Locale,       // locale identifier
					dwCmpFlags,	  // comparison-style options
					lpString1,	  // first string
					-1,		      // size of first string, -1 for null terminated
					lpString2,    // second string
					-1            // size of second string, -1 for null terminated
					);

	if(retval == 0)
	{
		//
		// CompareString can fail only with ERROR_INVALID_FLAGS or ERROR_INVALID_PARAMETER
		// an assamption is made that the caller passed valid arguments.

		ASSERT(("CompareString failed!", 0));
	}
	return(retval == CSTR_EQUAL);
}


bool
OcmLocalAwareStringsEqual(
	LPCWSTR str1,
	LPCWSTR str2
	)
{
	return OcmCompareString(
					LOCALE_SYSTEM_DEFAULT,
					NORM_IGNORECASE,		
					str1,
					str2
					);
}


bool
OcmLocalUnAwareStringsEqual(
	LPCWSTR str1,
	LPCWSTR str2
	)
{
	return OcmCompareString(
					LOCALE_INVARIANT,
					NORM_IGNORECASE,			
					str1,
					str2
					);
}

std::wstring
OcmGetSystemWindowsDirectoryInternal()
{
	//
	// Get windows directory, add backslash.
	//
	WCHAR buffer [MAX_PATH + 1];
	GetSystemWindowsDirectory(
		buffer,
		TABLE_SIZE(buffer)
		);
	return buffer;
}

static 
wstring 
GetValueAccordingToType(
	const DWORD   dwValueType,
    const PVOID   pValueData
    )
{
	switch(dwValueType)
	{
		case REG_DWORD:
		{
			wstringstream out;
			DWORD val = *((DWORD*)pValueData);
			out << val;
			return out.str();
		}

		case REG_SZ:
			return (WCHAR*)pValueData;
		
		default:
			return L"???";
	}
}
	

void 
LogRegValue(
    std::wstring  EntryName,
    const DWORD   dwValueType,
    const PVOID   pValueData,
    const BOOL bSetupRegSection
    )
{
	std::wstring Output = L"Setting the registry value: ";
    if (bSetupRegSection)
    {
        Output = Output + MSMQ_REG_SETUP_KEY + L"\\" + EntryName;
    }
	else
	{
		Output = Output + FALCON_REG_KEY + L"\\" + EntryName;
	}

	Output += L" = ";

	Output += GetValueAccordingToType(
				dwValueType,
    			pValueData
    			);

   	DebugLogMsg(eAction, Output.c_str());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\ostype.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ostype.cpp

Abstract:

    Code to detect type of Operating System.

Author:


Revision History:

	Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include <lmcons.h>
#include <lmerr.h>
#include <lmserver.h>

#include "ostype.tmh"

DWORD g_dwOS = MSMQ_OS_NONE;


//+-------------------------------------------------------------------------
//
//  Function:  IsNTE
//
//  Synopsis:  Tells if the OS is NT Enterprise Server
//
//+-------------------------------------------------------------------------
BOOL
IsNTE()
{
    HKEY  hKey ;
	static BOOL  fIsNTE = FALSE;
	static BOOL  fBeenHereAlready = FALSE;

	if (fBeenHereAlready)
		return fIsNTE;

	fBeenHereAlready = TRUE;

    LONG lResult = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
        0L,
        KEY_READ,
        &hKey);

    if (ERROR_SUCCESS == lResult)
    {
        BYTE  ch ;
        DWORD dwSize = sizeof(BYTE) ;
        DWORD dwType = REG_MULTI_SZ ;
        lResult = RegQueryValueEx(
			hKey,
            TEXT("ProductSuite"),
            NULL,
            &dwType,
            (BYTE*)&ch,
            &dwSize) ;

        if (ERROR_MORE_DATA == lResult)
		{
			TCHAR *pBuf = new TCHAR[ dwSize + 2 ] ;
            lResult = RegQueryValueEx(
				hKey,
                TEXT("ProductSuite"),
                NULL,
                &dwType,
                (BYTE*) &pBuf[0],
                &dwSize) ;

            if (ERROR_SUCCESS == lResult)
			{
                //
                // Look for the string "Enterprise".
                // The REG_MULTI_SZ set of strings terminate with two
                // nulls. This condition is checked in the "while".
                //
                TCHAR *pVal = pBuf ;
                while(*pVal)
                {
                    if (OcmLocalUnAwareStringsEqual(L"Enterprise", pVal))
                    {
                        fIsNTE = TRUE;
                        break;
                    }
                    pVal = pVal + lstrlen(pVal) + 1 ;
                }
				delete [] pBuf;
            }
		}					
	}
	
    RegCloseKey(hKey);

	return fIsNTE;

} //IsNTE


//+-------------------------------------------------------------------------
//
//  Function:  InitializeOSVersion
//
//  Synopsis:  Gets OS information
//
//+-------------------------------------------------------------------------
BOOL
InitializeOSVersion()
{
    OSVERSIONINFO infoOS;
    infoOS.dwOSVersionInfoSize = sizeof(infoOS);
    GetVersionEx(&infoOS);

    ASSERT(("OS must be Windows NT",
            infoOS.dwPlatformId == VER_PLATFORM_WIN32_NT  && infoOS.dwMajorVersion >= 5));

    DebugLogMsg(eAction, L"Initializing the OS version");
    DebugLogMsg(eInfo, L"ProductType = 0x%x", g_ComponentMsmq.dwProductType);

    switch (g_ComponentMsmq.dwProductType)
    {
        case PRODUCT_WORKSTATION:
            g_dwOS = MSMQ_OS_NTW;
            break;

        case PRODUCT_SERVER_SECONDARY:
        case PRODUCT_SERVER_PRIMARY:
            //
            // For fresh install g_dwMachineTypeDs should be set according to
            // subcomponent selection and not according to product type
            //
            //
            // Fall through
            //
        case PRODUCT_SERVER_STANDALONE:
            g_dwOS = MSMQ_OS_NTS;
            break;

        default:
            ASSERT(0);
            return FALSE;
            break;
    }

	//
	// In case of NT Server, check if it's an Enterprise Server
	//
	if (MSMQ_OS_NTS == g_dwOS)
	{
		g_dwOS = IsNTE() ? MSMQ_OS_NTE : MSMQ_OS_NTS;
	}

    return TRUE ;

} //InitializeOSVersion
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\qm2qm_c_.c ===
#pragma warning(push, 3)
#include <qm2qm_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\post_selection.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    post_selection.cpp

Abstract:

  This file holds the actions that should be performed after the user has finished selecting subcomponents,
  and before any other property sheets are shown. The main operation to perform at this stage is to get info
  from the unattended answer file.

Author:

    Uri Ben Zeev (uribz)  39-Aug-2001

Revision History:


--*/

#include "msmqocm.h"

// This error code is returned in the RPC code of dscommk2.mak
#define  RPC_ERROR_SERVER_NOT_MQIS  0xc05a5a5a

HRESULT  APIENTRY  GetNt4RelaxationStatus(ULONG *pulRelax);


static
void
ReadNt4ServerNameFromAnswerFile()
{
    ASSERT(
        g_SubcomponentMsmq[eADIntegrated].dwOperation == INSTALL &&
        !g_fWorkGroup &&
        !g_fUpgrade &&
        !g_fSkipServerPageOnClusterUpgrade
        );
    //                  
    // Read server name from INI file, if fails try finding AD server.
    //
    g_ServerName = ReadINIKey(L"ControllerServer");
   
    if(g_ServerName.empty())
    {
		DebugLogMsg(eWarning, L"A name of an MSMQ 1.0 controller server was not found in the answer file.");

        //
        // Detect DS environment - find if environment is AD.
        // If FindServerIsAdsInternal succeeds We found AD and can return.
        //
        if (IsADEnvironment())
        {
			return;
		}

		//
		// Supporting server name not provided in answer file and failed to find AD.
		// Continuing in ofline mode.
		//
        DebugLogMsg(eWarning, L"FindServerIsAdsInternal() failed. Setup will continue in offline mode.");
		if(g_fServerSetup)
		{
			//
			// rs,ds installation in ofline mode is not supported.
			//
			MqDisplayError(NULL, IDS_SERVER_INSTALLATION_NOT_SUPPORTED, 0);
			throw exception();
		}

		g_fInstallMSMQOffline = true;  
        return;
    }

    DebugLogMsg(eInfo, L"A name of an MSMQ 1.0 controller server was provided in the answer file.");

	if(g_fServerSetup)
	{
		//
		// rs,ds installation in nt4 domain is not supported.
		//
		MqDisplayError(NULL, IDS_SERVER_INSTALLATION_NOT_SUPPORTED, 0);
		throw exception();
	}


    //
    // Ping MSMQ server.
    //
    RPC_STATUS rc = PingAServer();
    if (RPC_S_OK != rc)
    {
        //
        // Log the failure. 
        //
        UINT iErr = IDS_SERVER_NOT_AVAILABLE ;
        if (RPC_ERROR_SERVER_NOT_MQIS == rc)
        {
            iErr = IDS_REMOTEQM_NOT_SERVER ;
        }
        MqDisplayError(NULL, iErr, 0);
        throw exception();  
    }
    
    DebugLogMsg(eInfo, L"An MSMQ 1.0 controller server was successfully pinged.");
    StoreServerPathInRegistry(g_ServerName);
}


static
void
ReadSupportingServerNameFromAnswerFile()
{
    ASSERT(
        g_fDependentClient && 
        g_SubcomponentMsmq[eMSMQCore].dwOperation == INSTALL &&
        !g_fWorkGroup &&
        !g_fUpgrade &&
        !g_fSkipServerPageOnClusterUpgrade
        );

    g_ServerName = ReadINIKey(L"SupportingServer");

	if(g_ServerName.empty())
	{
		MqDisplayError(NULL, IDS_UNATTEN_NO_SUPPORTING_SERVER, 0);
		throw exception();
	}
    
    //
    // Unattended. Ping MSMQ server.
    //
    RPC_STATUS rc = PingAServer();
    if (RPC_S_OK != rc)
    {
        //
        // Log the failure. Continue only for dep client.
        //
        MqAskContinue(IDS_STR_REMOTEQM_NA, g_uTitleID, TRUE,eYesNoMsgBox);
        return;
    }
    DebugLogMsg(eInfo, L"A supporting server was successfully pinged.");
}


static
void
ReadSecurityModelFromAnswerFile()
{
	//
	// Unattended. Read security model from INI file.
	// Default is strong.
	//
	std::wstring Security = ReadINIKey(L"SupportLocalAccountsOrNT4");
	if (OcmLocalUnAwareStringsEqual(Security.c_str(), L"TRUE"))
	{
		SetWeakSecurity(true);
		return;
	}
	if (OcmLocalUnAwareStringsEqual(Security.c_str(), L"FALSE"))
	{
		SetWeakSecurity(false);
	}
}


static
void
SetWeakSecurityGlobals()
{
	if((g_SubcomponentMsmq[eMQDSService].dwOperation != INSTALL) ||
	   !g_dwMachineTypeDs||
	   (g_fWelcome && Msmq1InstalledOnCluster()))
	{
		return;
	}
	//
	// Check if the relaxation flag was already set. If so,
	// do not display this page.
	//
	ULONG ulRelax = MQ_E_RELAXATION_DEFAULT;
	HRESULT hr = GetNt4RelaxationStatus(&ulRelax);
	if(FAILED(hr))
	{
		DebugLogMsg(eWarning, L"GetNt4RelaxationStatus() failed. hr = 0x%x", hr);
		return;
	}

	if(ulRelax == MQ_E_RELAXATION_DEFAULT)
	{
		//
		// Relaxation bit not set. Display this
		// page. This page should be displayed only on first
		// setup of a MSMQ on domain controller,
		// enterptise-wide.
		//
		DebugLogMsg(eInfo, L"This is the first MQDS server in the enterprize.");
		g_fFirstMQDSInstallation = true;
		return;
	}

	if(ulRelax == MQ_E_RELAXATION_ON)
	{
		//
		// We are in an enterprise with weakened security.
		//
		DebugLogMsg(eInfo, L"MSMQ was found to be running with weakened security.");
		g_fWeakSecurityOn = true;
		return;
	}
	
	DebugLogMsg(eInfo, L"MSMQ was found to be running without weakened security.");
	ASSERT(ulRelax == MQ_E_RELAXATION_OFF);
}


static
void
UnattendedOperations()
{
	ASSERT(g_fBatchInstall);
	ASSERT(!g_fCancelled);
	ASSERT(!g_fUpgrade);


    if(g_SubcomponentMsmq[eADIntegrated].dwOperation == INSTALL &&
       !g_fWorkGroup &&
       !g_fSkipServerPageOnClusterUpgrade
       )
    {
        ReadNt4ServerNameFromAnswerFile();
    }

    if(g_fDependentClient && 
       g_SubcomponentMsmq[eMSMQCore].dwOperation == INSTALL &&
       !g_fWorkGroup &&
       !g_fSkipServerPageOnClusterUpgrade
       )
    {
        ReadSupportingServerNameFromAnswerFile();
    }

	ReadSecurityModelFromAnswerFile();
}


void PostSelectionOperations(HWND hdlg)
/*++
    Preform operations after user select/ unselect all needed subcomponent.
--*/
{
	DebugLogMsg(eHeader, L"Post-Selection Operations and Dialog Pages");
    SetOperationForSubcomponents();
    if (g_fCancelled == TRUE)
    {
        return;
    }

    g_hPropSheet = GetParent(hdlg);
    g_fSkipServerPageOnClusterUpgrade = SkipOnClusterUpgrade();
    if (!MqInit())
    {
        g_fCancelled = TRUE;
        return;
    }

	if(g_fUpgrade)
	{
		return;
	}

	SetWeakSecurityGlobals();

    if(!g_fBatchInstall)
    {
        return;
    }
    
    try
    {    
        UnattendedOperations();
    }
    catch(const exception& )
    {
        g_fCancelled = TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\pgminst.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    pgminst.cpp

Abstract:

    Code to handle instalation of pgm driver.

Author:

  Uri Ben-zeev (uirbz)


Revision History:

    Uri Ben-zeev (uirbz)   31-Oct-01   

--*/

#include "msmqocm.h"

#include <netcfgn.h>
#include <comdef.h>
#include <devguid.h>


_COM_SMARTPTR_TYPEDEF(INetCfg, __uuidof(INetCfg));

_COM_SMARTPTR_TYPEDEF(INetCfgLock, __uuidof(INetCfgLock));

class AutoINetCfgLock
{
private:
	bool m_locked;
	INetCfgLockPtr m_ptr;

public:
	AutoINetCfgLock(INetCfgLockPtr ptr)
	{
		m_locked = false; 
		m_ptr = ptr;
	} 
	HRESULT GetLock(PWSTR& szLockedBy);

	~AutoINetCfgLock()
	{
		if(m_locked) 
			m_ptr->ReleaseWriteLock();
	}
};


HRESULT AutoINetCfgLock::GetLock(PWSTR& szLockedBy)
{
	//
	// Attempt to lock the INetCfg for read/write
	//

	static const ULONG x_Timeout = 1500;
	static const WCHAR x_szAppName[] = L"Message Queuing setup";

	HRESULT hr = m_ptr->AcquireWriteLock(
							x_Timeout,
							x_szAppName,
							&szLockedBy
							);
	if(SUCCEEDED(hr))
	{
		m_locked = true;
	}
	return hr;
}


void InstallNetComponent(
			INetCfg* pnc,
			PCWSTR szComponentId,
			const GUID* pguidClass
			)
{
    OBO_TOKEN OboToken;
	_COM_SMARTPTR_TYPEDEF(INetCfgClassSetup, __uuidof(INetCfgClassSetup));
	_COM_SMARTPTR_TYPEDEF(INetCfgComponent, __uuidof(INetCfgComponent));

    INetCfgClassSetupPtr pncClassSetup;
    INetCfgComponentPtr pncc;

    // OBO_TOKEN specifies the entity on whose behalf this
    // component is being installed

    // set it to OBO_USER so that szComponentId will be installed
    // On-Behalf-Of "user"
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    HRESULT hr = pnc->QueryNetCfgClass (
				pguidClass, 
				IID_INetCfgClassSetup,
                (void**)&pncClassSetup
				);

	if (FAILED(hr))
	{
		DebugLogMsg(eError, L"INetCfg::QueryNetCfgClass() failed. hr = 0x%x", hr);
		throw bad_hresult(hr);
	}
    hr = pncClassSetup->Install(
			szComponentId,
			&OboToken,
			NSF_POSTSYSINSTALL,
			0,       // <upgrade-from-build-num>
			NULL,    // answerfile name
			NULL,    // answerfile section name
			&pncc
			);

	if (FAILED(hr))
	{
		DebugLogMsg(eError, L"INetCfgClassSetup::Install() failed. hr = 0x%x", hr);
		throw bad_hresult(hr);
	}
}


BOOL 
InstallPGMDeviceDriver()
{   
    DebugLogMsg(eAction, L"Installing the RMCast device driver");

	try
	{
		INetCfgPtr pNetCfg(CLSID_CNetCfg);

		AutoINetCfgLock NetCfgLock(pNetCfg);

		HRESULT hr;

		for(;;)
		{
			PWSTR szLockedBy;
			hr = NetCfgLock.GetLock(szLockedBy);
			if (S_FALSE != hr)
			{
				break;
			}

			//
			// S_FALSE == hr 
			//
			if(MqDisplayErrorWithRetry(
					IDS_INETCNF_LOCK_ERROR,
					0 ,
					szLockedBy					
					) ==IDRETRY)
			{
				continue;
			}
			break;
		}
		if(FAILED(hr))
		{
			DebugLogMsg(eError, L"INetCfgLock::AcquireWriteLock() failed. hr = 0x%x", hr);
			throw bad_hresult(hr);
		}

		hr = pNetCfg->Initialize(NULL);

		InstallNetComponent(
			pNetCfg, 
			PGM_COMPONENT_ID,
			&GUID_DEVCLASS_NETTRANS
			);

		hr = pNetCfg->Apply();
	}
	catch(const bad_hresult& e)
	{
		MqDisplayError(NULL, IDS_PGM_ERROR, e.error());
		return false;

	}
	catch(const _com_error& e)
	{
		MqDisplayError(NULL, IDS_PGM_ERROR, e.Error());
		return false;
	}

	DebugLogMsg(eInfo, L"The RMCast device driver was installed successfully.");
	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\process.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    process.cpp

Abstract:

    Handle creation of processes.

Author:


Revision History:

	Shai Kariv    (ShaiK)   15-Dec-97   Modified for NT 5.0 OCM Setup

--*/
#include "msmqocm.h"
#include <string>
#include <autohandle.h>
#include "process.tmh"


//+-------------------------------------------------------------------------
//
//  Function:  RunProcess
//
//  Synopsis:  Creates and starts a process
//
//+-------------------------------------------------------------------------
DWORD
RunProcess(
	const std::wstring& FullPath,
	const std::wstring& CommandParams
    )  
{
	//
	// Comand line string is used for error messages. 
    //
	std::wstring CommandLine = FullPath + L" " + CommandParams;   

    // Initialize the process and startup structures
    //
    PROCESS_INFORMATION infoProcess;
    STARTUPINFO	infoStartup;
    memset(&infoStartup, 0, sizeof(STARTUPINFO)) ;
    infoStartup.cb = sizeof(STARTUPINFO) ;
    infoStartup.dwFlags = STARTF_USESHOWWINDOW ;
    infoStartup.wShowWindow = SW_MINIMIZE ;

    //
    // Create the process
    //
    if (!CreateProcess( 
			FullPath.c_str(),
            const_cast<WCHAR*>(CommandParams.c_str()), 
            NULL,
            NULL,
            FALSE,
            DETACHED_PROCESS,
            NULL,
            NULL,
            &infoStartup,
            &infoProcess 
			))
	{
		DWORD gle = GetLastError(); 
        MqDisplayError(NULL, IDS_PROCESSCREATE_ERROR, gle, CommandLine.c_str());
        throw bad_win32_error(gle);
    }

	//
	// Close thread, it is never used.
	// Wrap process thread with auto class.
	//
    CloseHandle(infoProcess.hThread);
	CAutoCloseHandle hProcess(infoProcess.hProcess);

    //
    // Wait for the process to terminate within the timeout period
    // (this will never happen as the process is created with INFINITE timeout.
	//
	DWORD RetVal = WaitForSingleObject(
						hProcess, 
						PROCESS_DEFAULT_TIMEOUT
						);
	if(RetVal != WAIT_OBJECT_0)
	{
		MqDisplayError(
			NULL, 
			IDS_PROCESSCOMPLETE_ERROR,
			0,
            PROCESS_DEFAULT_TIMEOUT/60000, 
			CommandLine.c_str()
			);
        throw bad_win32_error(RetVal);
    }

	//
	// Obtain the termination status of the process
	//
	DWORD ExitCode;
	if (!GetExitCodeProcess(infoProcess.hProcess, &ExitCode))
	{
		DWORD gle = GetLastError();
        MqDisplayError(NULL, IDS_PROCESSEXITCODE_ERROR, gle, CommandLine.c_str());
		throw bad_win32_error(gle); 
	}
    return ExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\service.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    service.h

Abstract:

    Service related definitions

Author:

	Shai Kariv    (ShaiK)   22-May-98   

--*/


#ifndef _SERVICE_H
#define _SERVICE_H

//
// Service related strings
//
#define MSMQ_DRIVER_NAME        TEXT("MQAC")
#define MSMQ_DRIVER_PATH        TEXT("drivers\\mqac.sys")
#define MSMQ_SERVICE_NAME       TEXT("MSMQ")
#define MQ1SYNC_SERVICE_NAME    TEXT("MQ1SYNC")
#define MSMQ_SERVICE_PATH       TEXT("mqsvc.exe")
#define MQ1SYNC_SERVICE_PATH    TEXT("mq1sync.exe")
#define RPC_SERVICE_NAME        TEXT("RPCSS")
#define DTC_SERVICE_NAME        TEXT("MSDTC")
#define LMS_SERVICE_NAME        TEXT("NtLmSsp")
#define SAM_SERVICE_NAME        TEXT("SamSs")
#define IISADMIN_SERVICE_NAME   TEXT("IISADMIN")
#define MQDS_SERVICE_NAME       TEXT("MQDS")
#define MQDS_SERVICE_PATH       TEXT("mqdssvc.exe")
#define TRIG_SERVICE_NAME       TEXT("MSMQTriggers")
#define TRIG_SERVICE_PATH       TEXT("mqtgsvc.exe")

#define PGM_DRIVER_NAME         TEXT("RMCAST")
#define PGM_COMPONENT_ID        TEXT("MS_RMCAST")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\service.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    service.cpp

Abstract:

    Code to handle the MSMQ service.

Author:


Revision History:

    Shai Kariv    (ShaiK)   14-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include <tlhelp32.h>
#include "autohandle.h"
#include <shrutil.h>

#include "service.tmh"


//+--------------------------------------------------------------
//
// Function: CheckServicePrivilege
//
// Synopsis: Check if user has privileges to access Service Manager
//
//+--------------------------------------------------------------
BOOL
CheckServicePrivilege()
{
    if (!g_hServiceCtrlMgr) //not yet initialized
    {
        //
        // Check if the user has full access to the service control manager
        //
        g_hServiceCtrlMgr = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (!g_hServiceCtrlMgr)
        {
            return FALSE;
        }
    }

    return TRUE;

} //CheckServicePrivilege



BOOL OcpDeleteService(LPCWSTR ServiceName)
{
	DebugLogMsg(eAction, L"Deleting the %s service", ServiceName); 
    CServiceHandle hService(OpenService(
                                g_hServiceCtrlMgr, 
                                ServiceName,
                                SERVICE_ALL_ACCESS
                                ));

    if (hService == NULL)
    {
        DWORD gle = GetLastError();
        if (gle == ERROR_SERVICE_DOES_NOT_EXIST)
        {
			DebugLogMsg(eInfo, L"The %s service does not exist.", ServiceName);
            return TRUE;
        }
        MqDisplayError(NULL, IDS_SERVICEOPEN_ERROR, gle, ServiceName);
        return FALSE;
    }

    //
    // Mark the service for deletion in SCM database.
    //
    if (!DeleteService(hService))
    {
        DWORD gle = GetLastError();
        if (gle == ERROR_SERVICE_MARKED_FOR_DELETE)
		{
			DebugLogMsg(eInfo, L"The %s service is already marked for deletion.", ServiceName);
			return TRUE;
		}
        MqDisplayError(NULL, IDS_SERVICEDELETE_ERROR, gle, ServiceName);
        return FALSE;

    }
	DebugLogMsg(eInfo, L"The %s service is marked for deletion.", ServiceName); 
    return TRUE;
}


//+--------------------------------------------------------------
//
// Function: FormMSMQDependencies
//
// Synopsis: Tells on which other services the MSMQ relies
//
//+--------------------------------------------------------------
static
void 
FormMSMQDependencies(CMultiString& Dependencies)
{
    //
    // The service depends on the MSMQ device driver
    //
	Dependencies.Add(MSMQ_DRIVER_NAME);

    //
    // The service depends on the PGM device driver
    //
    Dependencies.Add(PGM_DRIVER_NAME);

    //
    // The service depends on the NT Lanman Security support provider
    //
    Dependencies.Add(LMS_SERVICE_NAME);

    //
    // On servers, the service depends on the Security Accounts Manager
    // (in order to wait for DS to start)
    //
    if (g_dwOS != MSMQ_OS_NTW)
    {
        Dependencies.Add(SAM_SERVICE_NAME);
    }

    //
    // The service always depends on RPC
    //
    Dependencies.Add(RPC_SERVICE_NAME);
} //FormMSMQDependencies


static
BOOL
SetServiceDescription(
    SC_HANDLE hService,
    LPCWSTR pDescription
    )
{
    SERVICE_DESCRIPTION ServiceDescription;
    ServiceDescription.lpDescription = const_cast<LPWSTR>(pDescription);

    return ChangeServiceConfig2(
               hService,
               SERVICE_CONFIG_DESCRIPTION,
               &ServiceDescription
               );
} //SetServiceDescription

//+--------------------------------------------------------------
//
// Function: InstallService
//
// Synopsis: Installs service
//
//+--------------------------------------------------------------
BOOL
InstallService(
        LPCWSTR szDisplayName,
        LPCWSTR szServicePath,
        LPCWSTR szDependencies,
        LPCWSTR szServiceName,
        LPCWSTR szDescription,
        LPCWSTR szServiceAccount
        )
{
    //
    // Form the full path to the service
    //
	std::wstring FullServicePath = g_szSystemDir + L"\\" + szServicePath;

    //
    // Determine the service type
    //
#define SERVICE_TYPE    SERVICE_WIN32_OWN_PROCESS

    //
    // Create the service   
    //        
    DWORD dwStartType = IsLocalSystemCluster() ? SERVICE_DEMAND_START : SERVICE_AUTO_START;
 
	DebugLogMsg(eAction, L"Creating the %s service." ,szDisplayName); 
    SC_HANDLE hService = CreateService(
        g_hServiceCtrlMgr,
        szServiceName,
        szDisplayName,
        SERVICE_ALL_ACCESS,
        SERVICE_TYPE,
        dwStartType,
        SERVICE_ERROR_NORMAL,
        FullServicePath.c_str(),
        NULL,
        NULL,
        szDependencies,
        szServiceAccount,
        NULL
        );

    if (hService == NULL)
    {
        if (ERROR_SERVICE_EXISTS != GetLastError())
        {
            MqDisplayError(
                NULL,
                IDS_SERVICECREATE_ERROR,
                GetLastError(),
                szServiceName
                );
            return FALSE;
        }

        //
        // Service already exists.
        // This should be ok. But just to be on the safe side,
        // reconfigure the service (ignore errors here).
        //
        hService = OpenService(g_hServiceCtrlMgr, szServiceName, SERVICE_ALL_ACCESS);
        if (hService == NULL)
        {
            return TRUE;
        }

		DebugLogMsg(eInfo, L"%s already exsists. The service configuration will be changed." ,szDisplayName);
        ChangeServiceConfig(
            hService,
            SERVICE_TYPE,
            dwStartType,
            SERVICE_ERROR_NORMAL,
            FullServicePath.c_str(),
            NULL,
            NULL,
            szDependencies,
            NULL,
            NULL,
            szDisplayName
            );
    }

    if (hService)
    {       
        SetServiceDescription(hService, szDescription);
        CloseServiceHandle(hService);
    }

    return TRUE;

} //InstallService


//+--------------------------------------------------------------
//
// Function: InstallMSMQService
//
// Synopsis: Installs the MSMQ service
//
//+--------------------------------------------------------------
BOOL
InstallMSMQService()
{    
    DebugLogMsg(eAction, L"Installing the Message Queuing service");

    //
    // Form the dependencies of the service
    //
	CMultiString Dependencies;
    FormMSMQDependencies(Dependencies);

    //
    // Form the description of the service
    //
    CResString strDesc(IDS_MSMQ_SERVICE_DESCRIPTION);
	CResString strDisplayName(IDS_MSMQ_SERVICE_DESPLAY_NAME);
    
    BOOL fRes = InstallService(
                    strDisplayName.Get(),
                    MSMQ_SERVICE_PATH,
                    Dependencies.Data(),
                    MSMQ_SERVICE_NAME,
                    strDesc.Get(),
                    NULL
                    );

    return fRes; 

} //InstallMSMQService


//+--------------------------------------------------------------
//
// Function: WaitForServiceToStart
//
// Synopsis: Wait for a service in a start pending state to start (SERVICE_RUNNING).
//
//+--------------------------------------------------------------
BOOL
WaitForServiceToStart(
	LPCWSTR pServiceName
	)
{
	DebugLogMsg(eAction, L"Waiting for the %s service to start", pServiceName);
    CServiceHandle hService(OpenService(
                            g_hServiceCtrlMgr,
                            pServiceName, 
                            SERVICE_QUERY_STATUS
                            ));
    if (hService == NULL)
    {
        MqDisplayError(NULL, IDS_SERVICEOPEN_ERROR, GetLastError(), pServiceName);
        return FALSE;
    }

    SERVICE_STATUS statusService;
    UINT TotalTime = 0;
	for (;;)
	{
		
		if (!QueryServiceStatus(hService, &statusService))
		{
			MqDisplayError( NULL, IDS_SERVICEGETSTATUS_ERROR, GetLastError(), pServiceName);
			return FALSE;
		}

        if (statusService.dwCurrentState == SERVICE_RUNNING)
        {
            DebugLogMsg(eInfo, L"The %s service is running.", pServiceName); 
			return TRUE;
		}

        if (statusService.dwCurrentState != SERVICE_START_PENDING)
        {
            DebugLogMsg(eError, L"The %s service did not start.", pServiceName); 
            MqDisplayError( NULL, IDS_MSMQ_FAIL_SETUP_NO_SERVICE, 0, pServiceName);
			return FALSE;
        }
        
        Sleep(WAIT_INTERVAL);
        TotalTime += WAIT_INTERVAL;
		
        if (TotalTime > (MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES * 60000))
		{
			if (MqDisplayErrorWithRetry(
					IDS_WAIT_FOR_START_TIMEOUT_EXPIRED, 
					0,
					MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES
					) !=IDRETRY)
			{
				return FALSE;
			}
            TotalTime = 0;			
		}
	}
}


//+--------------------------------------------------------------
//
// Function: RunService
//
// Synopsis: Start a service and then wait for it to be running.
//
//+--------------------------------------------------------------
BOOL
RunService(LPCWSTR szServiceName)
{
	DebugLogMsg(eAction, L"Running the %s service", szServiceName );
    TickProgressBar();
    
    CServiceHandle hService(OpenService(
                                g_hServiceCtrlMgr,
                                szServiceName, 
                                SERVICE_START
                                ));
    if (hService == NULL)
    {
        MqDisplayError(NULL, IDS_SERVICEOPEN_ERROR, GetLastError(), szServiceName);
        return FALSE;
    }
   
    if(!StartService(hService, 0, NULL))
    {
        DWORD gle = GetLastError();
        if(gle == ERROR_SERVICE_ALREADY_RUNNING)
        {
            return TRUE;
        }
        MqDisplayError(NULL, IDS_SERVICESTART_ERROR, gle, szServiceName);
        return FALSE;
    }
    
    DebugLogMsg(eInfo, L"The %s service is in the start pending state.", szServiceName); 
    return TRUE;
}


//+--------------------------------------------------------------
//
// Function: GetServiceState
//
// Synopsis: Determines if a service is running
//
//+--------------------------------------------------------------

BOOL
GetServiceState(
    LPCWSTR szServiceName,
    DWORD*  pdwServiceStatus
    )
{
    //
    // Open a handle to the service
    //
    SERVICE_STATUS statusService;
    CServiceHandle hService(OpenService(
								g_hServiceCtrlMgr,
								szServiceName,
								SERVICE_QUERY_STATUS
								));

    if (hService == NULL)
    {
        DWORD dwError = GetLastError();

        if (ERROR_SERVICE_DOES_NOT_EXIST == dwError)
		{
			*pdwServiceStatus = SERVICE_STOPPED;
            return TRUE;
		}

        MqDisplayError(NULL, IDS_SERVICEOPEN_ERROR, dwError, szServiceName);
        return FALSE;
    }

    //
    // Obtain the service status
    //
    if (!QueryServiceStatus(hService, &statusService))
    {
        MqDisplayError(NULL, IDS_SERVICEGETSTATUS_ERROR, GetLastError(), szServiceName);
        return FALSE;
    }

    //
    // Determine if the service is not stopped
    //
    *pdwServiceStatus = statusService.dwCurrentState;

    return TRUE;

} // GetServiceState


BOOL 
RemoveService(
	LPCWSTR ServiceName
	)
{
	BOOL retval = TRUE;
    if (!OcpDeleteService(ServiceName))
	{
		retval = FALSE;
	}
	if(!StopService(ServiceName))
	{
		retval = FALSE;
	}
	return retval;
}


//+--------------------------------------------------------------
//
// Function: DisableMsmqService
//
// Synopsis:
//
//+--------------------------------------------------------------
BOOL
DisableMsmqService()
{    
    DebugLogMsg(eAction, L"Disabling the Message Queuing service");

    //
    // Open a handle to the service
    //
    SC_HANDLE hService = OpenService(
                             g_hServiceCtrlMgr,
                             MSMQ_SERVICE_NAME,
                             SERVICE_ALL_ACCESS
                             );

    if (!hService)
    {
        MqDisplayError(NULL, IDS_SERVICE_NOT_EXIST_ON_UPGRADE_ERROR,
                       GetLastError(), MSMQ_SERVICE_NAME);
        return FALSE;
    }

    //
    // Set the start mode to be disabled
    //
    if (!ChangeServiceConfig(
             hService,
             SERVICE_NO_CHANGE ,
             SERVICE_DISABLED,
             SERVICE_NO_CHANGE,
             NULL,
             NULL,
             NULL,
             NULL,
             NULL,
             NULL,
             NULL
             ))
    {
        MqDisplayError(NULL, IDS_SERVICE_CHANGE_CONFIG_ERROR,
                       GetLastError(), MSMQ_SERVICE_NAME);
        CloseHandle(hService);
        return FALSE;
    }

    CloseHandle(hService);
    return TRUE;

} // DisableMsmqService


//+--------------------------------------------------------------
//
// Function: UpgradeServiceDependencies
//
// Synopsis: Reform MSMQ service dependencies on upgrade to NT5
//
//+--------------------------------------------------------------
BOOL
UpgradeServiceDependencies()
{
    //
    // Open a handle to the service
    //
    SC_HANDLE hService = OpenService(
        g_hServiceCtrlMgr,
        MSMQ_SERVICE_NAME,
        SERVICE_ALL_ACCESS
        );

    if (!hService)
    {
        MqDisplayError(NULL, IDS_SERVICE_NOT_EXIST_ON_UPGRADE_ERROR,
            GetLastError(), MSMQ_SERVICE_NAME);
        return FALSE;
    }

    //
    // Set the new dependencies
    //
	CMultiString Dependencies;
    FormMSMQDependencies(Dependencies);
	CResString strDisplayName(IDS_MSMQ_SERVICE_DESPLAY_NAME);

    if (!ChangeServiceConfig(
             hService,
             SERVICE_NO_CHANGE,
             SERVICE_NO_CHANGE,
             SERVICE_NO_CHANGE,
             NULL,
             NULL,
             NULL,
             Dependencies.Data(),
             NULL,
             NULL,
             strDisplayName.Get()
             ))
    {
        MqDisplayError(NULL, IDS_SERVICE_CHANGE_CONFIG_ERROR,
                       GetLastError(), MSMQ_SERVICE_NAME);
        CloseServiceHandle(hService);
        return FALSE;
    }

    CResString strDesc(IDS_MSMQ_SERVICE_DESCRIPTION);
    SetServiceDescription(hService, strDesc.Get());

    CloseServiceHandle(hService);
    return TRUE;

} // UpgradeServiceDependencies

//+-------------------------------------------------------------------------
//
//  Function: InstallMQDSService
//
//  Synopsis: Install MQDS Service
//
//  Returns:  BOOL depending on success.
//
//--------------------------------------------------------------------------
BOOL
MQDSServiceSetup()
{    
    DebugLogMsg(eAction, L"Installing the Message Queuing Downlevel Client Support service");

    //
    // Form the dependencies of the service
    //
	CMultiString Dependencies;
	Dependencies.Add(MSMQ_SERVICE_NAME);

    //
    // Form the description of the service
    //
    CResString strDesc(IDS_MQDS_SERVICE_DESCRIPTION);        

	CResString strDisplayName(IDS_MSMQ_MQDS_DESPLAY_NAME);
    BOOL fRes = InstallService(
                    strDisplayName.Get(),
                    MQDS_SERVICE_PATH,
                    Dependencies.Data(),
                    MQDS_SERVICE_NAME,
                    strDesc.Get(),
                    NULL
                    );

    return fRes;   
}


static bool RemoveDsServerFunctionalitySettings()
/*++

Routine Description:
	This routine is called when you performing uninstall to Ds server functionality.
	it remove Ds Server functionality settings from the AD (msmq configuration and msmq settings)
	and from local registry.

Arguments:
	None.

Returned Value:
	true for success, false for failure.

--*/
{
	if(g_fWorkGroup)
	{
		return RegisterMachineType();
	}
    
	if (!LoadDSLibrary())
    {
        DebugLogMsg(eError, L"The DS library could not be loaded.");
        return false;
    }

	if(ADGetEnterprise() == eMqis)
	{
		//
		// Changing server functionality is not supported in MQIS env.
		//
        MqDisplayError(NULL, IDS_CHANGEMQDS_STATE_ERROR, 0);
        DebugLogMsg(eError, L"Removing the DS server functionality is only supported in an AD environment.");
        return false;
	}

	ASSERT(ADGetEnterprise() == eAD);

	//
	// reset the removed functionality property in both configuration and setting object
	//
	if(!SetServerPropertyInAD(PROPID_QM_SERVICE_DSSERVER, false))
	{
		return false;
	}

	//
	// Update machine type registry info
	//
	if(!RegisterMachineType())
	{
        DebugLogMsg(eError, L"The computer type information could not be updated in the registry.");
        return false;
	}

	return true;
}


static void RevertMQDSSettings()
/*++

Routine Description:
	Revert MQDS settings in case of failure.

Arguments:
	None.

Returned Value:
	None.

--*/
{
	//
	// Update the global to the failure state
	//
	g_dwMachineTypeDs = 0;
	g_dwMachineType = g_dwMachineTypeFrs ? SERVICE_SRV : SERVICE_NONE;

	//
	// Update AD and registry
	//
	RemoveDsServerFunctionalitySettings();
}

//+-------------------------------------------------------------------------
//
//  Function: InstallMQDSService
//
//  Synopsis: MQDS Service Setup: install it and if needed to run it
//
//  Returns:  BOOL depending on success.
//
//--------------------------------------------------------------------------
BOOL
InstallMQDSService()
{  
    //
    // we install this service only on servers!
    //
    ASSERT(("MQDS Service must be installed on the server", 
        MSMQ_OS_NTS == g_dwOS || MSMQ_OS_NTE == g_dwOS));
    
    //
    // do not install MQDS on dependent client
    //
    ASSERT(("Unable to install MQDS Service on Dependent Client", 
        !g_fDependentClient));
       
    //
    // In fresh install user select this subcomponent using UI or 
    // unattended file. For upgrade we install this service ONLY on
    // the former DS servers.
    //
    ASSERT(("Upgrade mode: MQDS Service must be installed on the former DS servers", 
        !g_fUpgrade || (g_fUpgrade && g_dwMachineTypeDs)));            


    TickProgressBar(IDS_PROGRESS_INSTALL_MQDS);

    if((g_SubcomponentMsmq[eMSMQCore].dwOperation != INSTALL) &&
	   (g_SubcomponentMsmq[eADIntegrated].dwOperation != INSTALL))
	{
		//
		// msmq configuration object already exist
		// Add setting object and set PROPID_QM_SERVICE_DSSERVER property.
		//
		if(!AddSettingObject(PROPID_QM_SERVICE_DSSERVER))
		{
			DebugLogMsg(eError, L"A MSMQ-Settings object could not be added.");
			return FALSE;
		}
	}
    
    if (!MQDSServiceSetup())
    {        
        DebugLogMsg(eError, L"The MQDS service could not be installed.");
		RevertMQDSSettings();
        return FALSE;
    }

    if ( g_fUpgrade                || // do not start services 
                                      // if upgrade mode        
        IsLocalSystemCluster()        // do not start service on
                                      // cluster machine (MSMQ is not
                                      // started)
        )
    {
        return TRUE;
    }
        
    if (!RunService(MQDS_SERVICE_NAME))
    {        
        DebugLogMsg(eError, L"The MQDS service could not be started.");
        //
        // to clean up because of failure
        //
        OcpDeleteService(MQDS_SERVICE_NAME); 
		RevertMQDSSettings();

        return FALSE;
    }

	if(!MQSec_IsDC())
	{
		//
		// When the server is not DC, MQDS will fail to start.
		// MQDS service will start successfully only on DC.
		// In this case don't call WaitForServiceToStart
		// We know that the service will fail to start which
		// is legitimate in this case.
		//

		//
		// Revert MQDS settings to reflects the fact 
		// that we are currently not DS server.
		// When this server will be DCPROMO 
		// MQDS startup will update the local and AD setting 
		// and the server will become DS server
		//
		RevertMQDSSettings();

		//
		// MQDS subcomponent is installed
		// When this server will be DCPROMO it will become DS server
		//
		DebugLogMsg(eWarning, L"The MQDS service will not start because this server is not a domain controller.");
		DebugLogMsg(eInfo, L"The Downlevel Client Support subcomponent is installed. When this server is promoted to a domain controller, it will become an MQDS server.");
		return TRUE;
	}

	if(!WaitForServiceToStart(MQDS_SERVICE_NAME))
	{
        OcpDeleteService(MQDS_SERVICE_NAME); 
		RevertMQDSSettings();
		return FALSE;
	}

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function: UnInstallMQDSService
//
//  Synopsis: MQDS Service Uninstall: stop and remove MQDS service
//
//  Returns:  BOOL depending on success.
//
//--------------------------------------------------------------------------
BOOL
UnInstallMQDSService()
{
    TickProgressBar(IDS_PROGRESS_REMOVE_MQDS);
	if(!RemoveService(MQDS_SERVICE_NAME))
	{
		return FALSE;
	}

    if(g_SubcomponentMsmq[eMSMQCore].dwOperation == REMOVE)
	{
		//
		// Uninstall - do nothing
		//
		return TRUE;
	}

	if(!RemoveDsServerFunctionalitySettings())
    {
        DebugLogMsg(eError, L"The DS server property could not be reset in Active Directory.");
		return FALSE;
	}

	return TRUE;
}

static
BOOL
StartDependentSrvices(LPCWSTR szServiceName)
{
	DebugLogMsg(eAction, L"Starting dependent services for the %s service", szServiceName);
    //
    // If service is not running, we're finished
    //
    DWORD dwServiceState = FALSE;
    if (!GetServiceState(szServiceName, &dwServiceState))
	{
		DebugLogMsg(eInfo, L"The %s service does not exist.", szServiceName);
        return FALSE;

	}

    if (dwServiceState == SERVICE_STOPPED)
	{
		DebugLogMsg(eInfo, L"The %s service is not running.", szServiceName);
        return FALSE;
	}

    //
    // Open a handle to the service
    //
    CServiceHandle hService(OpenService(
                                g_hServiceCtrlMgr,
                                szServiceName, 
                                SERVICE_ENUMERATE_DEPENDENTS
                                ));

    if (hService == NULL)
    {
        DWORD le = GetLastError();

        MqDisplayError(
            NULL,
            IDS_SERVICEOPEN_ERROR,
            le,
            szServiceName
            );
        return FALSE;
    }

    //
    // First we call EnumDependentServices just to get BytesNeeded.
    //
    DWORD BytesNeeded;
    DWORD NumberOfEntries;
    BOOL fSucc = EnumDependentServices(
                    hService,
                    SERVICE_INACTIVE,
                    NULL,
                    0,
                    &BytesNeeded,
                    &NumberOfEntries
                    );

    DWORD le = GetLastError();
	if (BytesNeeded == 0)
    {
        return TRUE;
    }
    
    ASSERT(!fSucc);
    if( le != ERROR_MORE_DATA)
    {
        MqDisplayError(
            NULL,
            IDS_ENUM_SERVICE_DEPENDENCIES,
            le,
            szServiceName
            );
        
        return FALSE;
    }

    AP<BYTE> pBuffer = new BYTE[BytesNeeded];

    ENUM_SERVICE_STATUS * pDependentServices = reinterpret_cast<ENUM_SERVICE_STATUS*>(pBuffer.get());
    fSucc = EnumDependentServices(
                hService,
                SERVICE_INACTIVE,
                pDependentServices,
                BytesNeeded,
                &BytesNeeded,
                &NumberOfEntries
                );

    if(!fSucc)
    {
        MqDisplayError(
            NULL,
            IDS_ENUM_SERVICE_DEPENDENCIES,
            GetLastError(),
            szServiceName
            );
       
        return FALSE;
    }

    for (DWORD ix = 0; ix < NumberOfEntries; ++ix)
    {
        if(!RunService(pDependentServices[ix].lpServiceName))
        {
            return FALSE;
        }
    }
    
    return TRUE;
}


BOOL 
OcpRestartService(
	LPCWSTR strServiceName
	)
{
	DebugLogMsg(eAction, L"Restarting the %s service", strServiceName);
	if(!StopService(strServiceName))
	{
		return FALSE;
	}
	if(!RunService(strServiceName))
	{
		return FALSE;
	}
	if(!WaitForServiceToStart(strServiceName))
	{
		return FALSE;
	}
	return StartDependentSrvices(strServiceName);
}


//
// Functionnality to stop a service.
//
class open_service_error : public bad_win32_error 
{
public:
	explicit open_service_error(DWORD e) : bad_win32_error(e) {}
};


class query_service_error : public bad_win32_error 
{
public:
	explicit query_service_error(DWORD e) : bad_win32_error(e) {}
};


class enum_dependent_service_error : public bad_win32_error 
{
public:
	explicit enum_dependent_service_error(DWORD e) : bad_win32_error(e) {}
};
 

class stop_service_error : public bad_win32_error 
{
public:
	explicit stop_service_error(DWORD e) : bad_win32_error(e) {}
};


class open_process_error : public bad_win32_error 
{
public:
	explicit open_process_error(DWORD e) : bad_win32_error(e) {}
};


class service_stuck_error : public exception 
{
private:

	SERVICE_STATUS_PROCESS m_status;
public:
	
	explicit service_stuck_error(SERVICE_STATUS_PROCESS status) : m_status(status){}

    SERVICE_STATUS_PROCESS status()const  {return m_status;}
};


static SC_HANDLE OpenServiceForStop(LPCWSTR ServiceName)
{
	SC_HANDLE schService = OpenService( 
							g_hServiceCtrlMgr,       
							ServiceName,       
							SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_STOP
							);            
	if(schService == NULL)
	{
		DWORD gle = GetLastError();
		DebugLogMsg(eWarning, L"OpenService() for %s failed. Last error: %d", ServiceName, gle);
		throw open_service_error(gle);
	}

	return schService; 
}


static SERVICE_STATUS_PROCESS GetServiceStatus(SC_HANDLE handle)
{
	SERVICE_STATUS_PROCESS status;
	DWORD dwBytesNeeded = 0;
    if (!QueryServiceStatusEx(
					handle,
					SC_STATUS_PROCESS_INFO,
					reinterpret_cast<LPBYTE>(&status),
					sizeof(status),
					&dwBytesNeeded
					))
    {
		DWORD gle = GetLastError();
		DebugLogMsg(eError, L"QueryServiceStatus() failed. Last error: %d", gle);
        throw query_service_error(GetLastError());
    }
	return status;
}


static void StopDependentServices(SC_HANDLE handle)
{
    //
    // First we call EnumDependentServices just to get BytesNeeded.
    //
    DWORD BytesNeeded;
    DWORD NumberOfEntries;
    BOOL fSucc = EnumDependentServices(
                    handle,
                    SERVICE_ACTIVE,
                    NULL,
                    0,
                    &BytesNeeded,
                    &NumberOfEntries
                    );

	if (BytesNeeded == 0)
    {
        return; 
    }
    
    ASSERT(!fSucc);

    DWORD gle = GetLastError();
    if( gle != ERROR_MORE_DATA)
    {
		DebugLogMsg(eError, L"EnumDependentServices() failed. Last error: %d", gle);
		throw enum_dependent_service_error(gle);        
    }

    AP<BYTE> pBuffer = new BYTE[BytesNeeded];

    ENUM_SERVICE_STATUS * pDependentServices = reinterpret_cast<ENUM_SERVICE_STATUS*>(pBuffer.get());
    fSucc = EnumDependentServices(
                handle,
                SERVICE_ACTIVE,
                pDependentServices,
                BytesNeeded,
                &BytesNeeded,
                &NumberOfEntries
                );

    if(!fSucc)
    {
		gle = GetLastError();
		DebugLogMsg(eError, L"EnumDependentServices() failed. Last error: %d", gle);
		throw enum_dependent_service_error(gle);       
    }

    for (DWORD ix = 0; ix < NumberOfEntries; ++ix)
    {
		StopService(pDependentServices[ix].lpServiceName);
    }
}


static void StopServiceInternal(SC_HANDLE handle)
{
	SERVICE_STATUS statusService;
	if (!ControlService(
            handle,
            SERVICE_CONTROL_STOP,
            &statusService
            ))
	{
		DWORD gle = GetLastError();
		DebugLogMsg(eError, L"ControlService() failed. Last error: %d", gle);
		throw stop_service_error(GetLastError());
	}
}


static UINT GetWaitTime()
{
	if(!g_fBatchInstall)
	{
		return MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES;
	}
	//
	// In Unattended we want to wait more as there is no ui
	// to let the user decide.
	//

	return 10 * MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES;
}

static DWORD WaitForServiceToStop(SC_HANDLE handle)
{
	SERVICE_STATUS_PROCESS status = GetServiceStatus(handle);
	for(DWORD i = 0;; ++i)
	{
		for(DWORD wait = 0; wait < (GetWaitTime() * 60000); wait += WAIT_INTERVAL)
		{
			
			//
			// If we wait for service to stop, wait until it is really stopped
			//
			if (status.dwCurrentState == SERVICE_STOPPED)
			{
				return (i * GetWaitTime() * 60 + wait/1000);
			}
			status = GetServiceStatus(handle);
  			Sleep(WAIT_INTERVAL);
		
		}
		if(MqDisplayErrorWithRetry(
				IDS_WAIT_FOR_STOP_TIMEOUT_EXPIRED,
				0,
				GetWaitTime()
				) != IDRETRY)
		{
			throw service_stuck_error(status);
		}
	}
}


static
void
WaitForProcessToTerminate(
	DWORD ProcessId
	)
{
	//
	// Get hanlde to the service process
	//
	CHandle hProcess( OpenProcess(SYNCHRONIZE, FALSE, ProcessId) );
	
	if (hProcess == NULL)
	{
		DWORD gle = GetLastError();
		
		//
		// The service is stopped. Either we got a 0
		// process ID in ServiceStatusProcess, or the ID
		// that we got was of a process that already stopped
		//
		if (gle == ERROR_INVALID_PARAMETER)
		{
			return;
		}

		throw open_process_error(gle);  
	}

	DebugLogMsg(eAction, L"Waiting for the process %d to terminate", ProcessId);
	for (DWORD i = 1;;++i)
	{
		DWORD dwRes = WaitForSingleObject(hProcess, GetWaitTime() * 60000);

		if (dwRes == WAIT_OBJECT_0)
		{
			return; 
		}

		if (dwRes == WAIT_FAILED )
		{
			//
			// When this happens the service is already stopped. There is a good chance the process will also 
			// terminate so there is no reason for an error message.
			//
			DebugLogMsg(eInfo, L"WaitForSingleObject() failed for the process %d. Last error: %d.", ProcessId, GetLastError());
			return;
		}

		ASSERT(dwRes == WAIT_TIMEOUT);

		if (IDRETRY !=
			MqDisplayErrorWithRetry(
				IDS_WAIT_FOR_STOP_TIMEOUT_EXPIRED,
				0,
				GetWaitTime()
				))
		{
			DebugLogMsg(eInfo, L"Waiting for the process %d was cancelled by the user after waiting for %d minutes.", ProcessId, i*GetWaitTime());  
			throw exception();
		}
	}
}


BOOL StopService(
    LPCWSTR ServiceName
    )
{
	DebugLogMsg(eAction, L"Stopping the %s service.", ServiceName); 
	try
	{
		SC_HANDLE handle = OpenServiceForStop(ServiceName);
		SERVICE_STATUS_PROCESS ServiceStatus = GetServiceStatus(handle);
		DWORD state = ServiceStatus.dwCurrentState;
		//
		// Fall throug is used in the switch block.
		//
		switch(state)
		{
			case SERVICE_START_PENDING:
				DebugLogMsg(eInfo, L"The %s service is in the start pending state. Setup is waiting for it to start.", ServiceName); 
				if(!(WaitForServiceToStart(ServiceName)))
				{
					SERVICE_STATUS_PROCESS status = GetServiceStatus(handle);
					throw service_stuck_error(status); 
				}
			//
			// Fall Through.
			//
			case SERVICE_RUNNING:
				//
				// At this point the service is running.
				//
				DebugLogMsg(eInfo, L"The %s service is running. Setup is sending it a signal to stop.", ServiceName); 
				StopDependentServices(handle);
				StopServiceInternal(handle);

			//
			// Fall Through.
			//
			case SERVICE_STOP_PENDING:
			{
				DebugLogMsg(eInfo, L"The %s service is in the stop pending state. Setup is waiting for it to stop.", ServiceName); 
				DWORD t = WaitForServiceToStop(handle);
				DebugLogMsg(eInfo, L"The %s service stopped after %d seconds.", ServiceName, t);
			}
			//
			// Fall Through.
			//
			case SERVICE_STOPPED:
				DebugLogMsg(eInfo, L"The %s service is stopped.", ServiceName); 

				//
				// The MSMQ Service has some cleenup to do after it allready signaled stopped to SCM,
				// there fore it is neaded to wait for the process to terminate.
				//
				if(wcscmp(ServiceName, MSMQ_SERVICE_NAME) == 0)
				{
					WaitForProcessToTerminate(ServiceStatus.dwProcessId);
				}
				return TRUE;

			default:
				ASSERT(0);
				return FALSE;
		}
	}
	catch(const open_service_error& e)
	{
		if(e.error() == ERROR_SERVICE_DOES_NOT_EXIST)
		{
			DebugLogMsg(eInfo, L"The %s service does not exist.", ServiceName);
			return TRUE;
		}
		MqDisplayError( NULL, IDS_SERVICEOPEN_ERROR, e.error(), ServiceName);
	}
	catch(const query_service_error& e) 
	{
		MqDisplayError(NULL, IDS_SERVICEGETSTATUS_ERROR, e.error(), ServiceName);
	}
	catch(const enum_dependent_service_error& e)
	{
        MqDisplayError(NULL, IDS_ENUM_SERVICE_DEPENDENCIES, e.error(), ServiceName);
	}
	catch(const stop_service_error& e)
	{
		MqDisplayError( NULL, IDS_SERVICESTOP_ERROR, e.error(), ServiceName);
	}
	catch(const open_process_error& e)
	{
		MqDisplayError(NULL, IDS_PROCESS_OPEN_ERROR, e.error(), MSMQ_SERVICE_NAME);    
	}
	catch(service_stuck_error e)
	{
		DebugLogMsg(
			eError, 
			L"The %s service is not responding."
			L"QueryServiceStatus() returned the following information:" 
			L"dwServiceType = %d, "
			L"dwControlsAccepted = %d, "
			L"dwWin32ExitCode = %d, "
			L"dwServiceSpecificExitCode = %d, "
			L"dwServiceTypedwCheckPoint = %d, "
			L"dwCurrentState = %d, "
			L"dwProcessId = %d, "
			L"dwServiceFlags = %d",
			ServiceName,
			e.status().dwControlsAccepted,
			e.status().dwWin32ExitCode,
			e.status().dwServiceSpecificExitCode,
			e.status().dwCheckPoint,
			e.status().dwWaitHint,
		    e.status().dwProcessId,
		    e.status().dwServiceFlags
			);
	}
	catch(const exception&)
	{
	}
	MqDisplayError(NULL, IDS_SERVICESTOP_FINAL_ERROR, (DWORD)MQ_ERROR, ServiceName);
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\stdh.cpp ===
//
// stdh.cpp
//

#include "msmqocm.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\stdh.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    stdh.h

Abstract:

    Standard header file for NT5 OCM setup.

Author:

	Shai Kariv    (ShaiK)   05-Jan-98

Revision History:


--*/

#ifndef _STDH_H
#define _STDH_H

#include <_stdh.h>
#include <mqwin64a.h>
#include <setupapi.h>
#include <ocmanage.h>
#include <shlobj.h>

#include <_mqini.h>
#include <mqsymbls.h>
#include <mqprops.h>
#include <mqtypes.h>
#include <dsproto.h>
#include <mqsec.h>
#include <_secutil.h>
#include "_mqdef.h"
#include <_mqreg.h>
#include <uniansi.h>
#include "version.h"
#include <exception>    //exception class definition
#include <mqexception.h>


#include "ocmres.h"  
#include "list_mac.h"
#include "list.h"

#endif //_STDH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\servname.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    servname.cpp

Abstract:

    Handle input of server name and check if server available
    and is of the proper type.

Author:

    Doron Juster  (DoronJ)  15-Sep-97

Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/

#include "msmqocm.h"
#include "qm2qm.h"
#include "dscomm.h"
#include "_mqrpc.h"

#include "servname.tmh"

static WCHAR *s_FN=L"msmqocm/servname";


extern "C" void __RPC_FAR * __RPC_USER midl_user_allocate(size_t cBytes)
{
    return new char[cBytes];
}

extern "C" void  __RPC_USER midl_user_free (void __RPC_FAR * pBuffer)
{
    delete[] pBuffer;
}

static RPC_STATUS s_ServerStatus = RPC_S_OK ;
static HWND       s_hwndWait = 0;
static BOOL       s_fWaitCancelPressed = FALSE;
static BOOL       s_fRpcCancelled = FALSE ;
std::wstring      g_ServerName;

// Two minutes, in milliseconds.
static const DWORD sx_dwTimeToWaitForServer = 120000;

// Display the progress bar half a second after starting rpc.
static const DWORD sx_dwTimeUntilWaitDisplayed = 500;

// This error code is returned in the RPC code of dscommk2.mak
#define  RPC_ERROR_SERVER_NOT_MQIS  0xc05a5a5a


//+-------------------------------------------
//
// RPC_STATUS  _PingServerOnProtocol()
//
//+-------------------------------------------

RPC_STATUS _PingServerOnProtocol()
{
    ASSERT(!g_ServerName.empty());
    //
    // Create RPC binding handle.
    // Use the dynamic port for querying the server.
    //
    _TUCHAR  *pszStringBinding = NULL;
    _TUCHAR  *pProtocol  = (_TUCHAR*) TEXT("ncacn_ip_tcp") ;
    RPC_STATUS status = RpcStringBindingCompose(
            NULL,  // pszUuid,
            pProtocol,
            (_TUCHAR*)(g_ServerName.c_str()),
            NULL, // lpwzRpcPort,
            NULL, // pszOptions,
            &pszStringBinding
            );
    if (status != RPC_S_OK)
    {
        return status ;
    }

    handle_t hBind ;
    status = RpcBindingFromStringBinding(
        pszStringBinding,
        &hBind
        );

    //
    // We don't need the string anymore.
    //
    RPC_STATUS rc = RpcStringFree(&pszStringBinding) ;
    ASSERT(rc == RPC_S_OK);

    if (status != RPC_S_OK)
    {
        //
        // this protocol is not supported.
        //
        return status ;
    }

    status = RpcMgmtSetCancelTimeout(0);
    ASSERT(status == RPC_S_OK);

    if (!s_fRpcCancelled)
    {
        RpcTryExcept
        {
            DWORD dwPort = 0 ;

            if (g_fDependentClient)
            {
                //
                // Dependent client can be served by an FRS, which is not MQDSSRV
                // server. So call its QM, not its MQDSSRV.
                //
                dwPort = R_RemoteQMGetQMQMServerPort(hBind, TRUE /*IP*/);
            }
            else
            {
                dwPort = S_DSGetServerPort(hBind, TRUE /*IP*/) ;
            }

            ASSERT(dwPort != 0) ;
            status =  RPC_S_OK ;
        }
		RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            status = RpcExceptionCode();
            PRODUCE_RPC_ERROR_TRACING;
        }
		RpcEndExcept
    }

    if (!s_fRpcCancelled  &&
        (!g_fDependentClient && (status == RPC_S_SERVER_UNAVAILABLE)))
    {
        status = RpcMgmtSetCancelTimeout(0);
        ASSERT(status == RPC_S_OK);

        RpcTryExcept
        {
            //
            // We didn't find an MQIS server. See if the machine name is
            // a routing server and display an appropriate error.
            //
            DWORD dwPort = R_RemoteQMGetQMQMServerPort(hBind, TRUE /*IP*/) ;
            UNREFERENCED_PARAMETER(dwPort);
            status =  RPC_ERROR_SERVER_NOT_MQIS ;
        }
		RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            status = RpcExceptionCode();
            PRODUCE_RPC_ERROR_TRACING;
        }
		RpcEndExcept
    }

    rc = RpcBindingFree(&hBind);
    ASSERT(rc == RPC_S_OK);

    return status ;

} // _PingServerOnProtocol()

//+--------------------------------------------------------------
//
// Function: PingAServer
//
// Synopsis:
//
//+--------------------------------------------------------------

RPC_STATUS PingAServer()
{
    RPC_STATUS status = _PingServerOnProtocol();

    return status;
}

//+--------------------------------------------------------------
//
// Function: PingServerThread
//
// Synopsis: Thread to ping the server, to see if it is available
//
//+--------------------------------------------------------------

DWORD WINAPI PingServerThread(LPVOID)
{
    s_ServerStatus = PingAServer();
    return 0 ;

} // PingServerThread

//+--------------------------------------------------------------
//
// Function: MsmqWaitDlgProc
//
// Synopsis: Dialog procedure for the Wait dialog
//
//+--------------------------------------------------------------
INT_PTR
CALLBACK
MsmqWaitDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM lParam
    )
{
    switch( msg )
    {
    case WM_COMMAND:
        {
            switch(LOWORD(wParam))
            {
            case IDCANCEL:
                {
                    s_fWaitCancelPressed = TRUE;
                    return FALSE;
                }
            }
        }
        break;

    case WM_INITDIALOG:
        {
            SendDlgItemMessage(
                hdlg,
                IDC_PROGRESS,
                PBM_SETRANGE,
                0,
                MAKELPARAM(0, sx_dwTimeToWaitForServer/50)
                );
        }
        break;

    default:
        return DefWindowProc(hdlg, msg, wParam, lParam);
        break;
    }
    return (FALSE);

} // MsmqWaitDlgProc


//+--------------------------------------------------------------
//
// Function: DisplayWaitWindow
//
// Synopsis:
//
//+--------------------------------------------------------------
static
void
DisplayWaitWindow(
    HWND hwndParent,
    DWORD dwTimePassed
    )
{
    ASSERT(!g_fBatchInstall);
    static int iLowLimit;
    static int iHighLimit;

    if (0 == s_hwndWait)
    {
        s_hwndWait = CreateDialog(
            g_hResourceMod ,
            MAKEINTRESOURCE(IDD_WAIT),
            hwndParent,
            MsmqWaitDlgProc
            );
        ASSERT(s_hwndWait);

        if (s_hwndWait)
        {
            ShowWindow(s_hwndWait, TRUE);
        }

        s_fWaitCancelPressed = FALSE;

        //
        // Store the range limits of the progress bar
        //
        PBRANGE pbRange;
        SendDlgItemMessage(
            s_hwndWait,
            IDC_PROGRESS,
            PBM_GETRANGE,
            0,
            (LPARAM)(PPBRANGE)&pbRange
            );
        iLowLimit = pbRange.iLow;
        iHighLimit = pbRange.iHigh;
    }
    else
    {
        int iPos = (dwTimePassed / 50);
        while (iPos >= iHighLimit)
            iPos %= (iHighLimit - iLowLimit);
        SendDlgItemMessage(
            s_hwndWait,
            IDC_PROGRESS,
            PBM_SETPOS,
            iPos,
            0
            );
    }
}


//+--------------------------------------------------------------
//
// Function: DestroyWaitWindow
//
// Synopsis: Kills the Wait dialog
//
//+--------------------------------------------------------------
static
void
DestroyWaitWindow()
{
    if(s_hwndWait)
    {
        DestroyWindow(s_hwndWait);
        s_hwndWait = 0;
    }
} // DestroyWaitWindow


//+--------------------------------------------------------------
//
// Function: CheckServer
//
// Synopsis: Checks if server is valid
//
// Returns:  1 if succeeded, -1 if failed (so as to prevent the
//           wizard from continuing to next page)
//
//+--------------------------------------------------------------
static
bool
CheckServer(
    IN const HWND   hdlg
    )
{
    static BOOL    fRpcMgmt = TRUE ;
    static DWORD   s_dwStartTime ;
    static BOOL    s_fCheckServer = FALSE ;
    static HANDLE  s_hThread = NULL ;

    ASSERT(!g_fBatchInstall);

    if (fRpcMgmt)
    {
        RPC_STATUS status = RpcMgmtSetCancelTimeout(0);
        UNREFERENCED_PARAMETER(status);
        ASSERT(status == RPC_S_OK);
        fRpcMgmt = FALSE ;
    }

    if (s_fCheckServer)
    {

        BOOL fAskRetry = FALSE ;
        DWORD dwTimePassed = (GetTickCount() - s_dwStartTime);

        if ((!s_fWaitCancelPressed) && dwTimePassed < sx_dwTimeToWaitForServer)
        {
            if (dwTimePassed > sx_dwTimeUntilWaitDisplayed)
            {
                DisplayWaitWindow(hdlg, dwTimePassed);
            }

            DWORD dwWait = WaitForSingleObject(s_hThread, 0) ;
            ASSERT(dwWait != WAIT_FAILED) ;

            if (dwWait == WAIT_OBJECT_0)
            {
                CloseHandle(s_hThread) ;
                s_hThread = NULL ;
                DestroyWaitWindow();
                s_fCheckServer = FALSE ;

                if (s_ServerStatus == RPC_S_OK)
                {
                    //
                    // Server exist. go on.
                    //
                }
                else
                {
                    fAskRetry = TRUE ;
                }
            }
            else
            {
                //
                // thread not terminated yet.
                //
                MSG msg ;
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    TranslateMessage(&msg) ;
                    DispatchMessage(&msg) ;
                }
                Sleep(50) ;
                PropSheet_PressButton(GetParent(hdlg),
                    PSBTN_NEXT) ;
                SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );
                return false;
            }
        }
        else
        {
            DisplayWaitWindow(hdlg, sx_dwTimeToWaitForServer) ;
            s_fWaitCancelPressed = FALSE;
            //
            // thread run too much time. Kill it.
            //
            ASSERT(s_hThread);
            __try
            {
                s_fRpcCancelled = TRUE;
                RPC_STATUS status = RpcCancelThread(s_hThread);
				ASSERT(status == RPC_S_OK);
				DBG_USED(status);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
            }
            fAskRetry = TRUE ;
            s_fCheckServer = FALSE ;

            //
            // wait until thread terminate.
            //
            DWORD dwWait = WaitForSingleObject(s_hThread, INFINITE);
            UNREFERENCED_PARAMETER(dwWait);
            DestroyWaitWindow();
            ASSERT(dwWait == WAIT_OBJECT_0);

            CloseHandle(s_hThread);
            s_hThread = NULL;
        }

        BOOL fRetry = FALSE;

        if (fAskRetry && g_fDependentClient)
        {
            //
            // Here "NO" means go on and use server although
            // it's not reachable.
            //
            if (!MqAskContinue(IDS_STR_REMOTEQM_NA, g_uTitleID, TRUE,eYesNoMsgBox))
            {
                fRetry = TRUE ;
            }
        }
        else if (fAskRetry)
        {
            UINT iErr = IDS_SERVER_NOT_AVAILABLE ;
            if (s_ServerStatus ==  RPC_ERROR_SERVER_NOT_MQIS)
            {
                iErr = IDS_REMOTEQM_NOT_SERVER ;
            }
            UINT i = MqDisplayError(hdlg, iErr, 0) ;
            UNREFERENCED_PARAMETER(i);
            fRetry = TRUE ;
        }

        if (fRetry)
        {
            //
            // Try another server. Present one is not available.
            //
            PropSheet_SetWizButtons(
				GetParent(hdlg),
                (PSWIZB_BACK | PSWIZB_NEXT)
				);

            g_ServerName = L"";
            SetDlgItemText(
                hdlg,
                IDC_EDIT_ServerName,
                g_ServerName.c_str()
                );
            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );
            return false;
        }
    }
    else // s_fCheckServer
    {
        if (g_ServerName.empty())
        {
            //
            // Server name must be supplied.
            //
            DebugLogMsg(eError, L"The user did not enter a server name.");
            UINT i = MqDisplayError(hdlg, IDS_STR_MUST_GIVE_SERVER, 0);
            UNREFERENCED_PARAMETER(i);
            SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );
            return false;
        }
        else
        {
        	DebugLogMsg(eInfo, L"The server name entered is %s. Setup is checking its validity.", g_ServerName.c_str());
            s_fRpcCancelled = FALSE ;

            //
            // Check if server available.
            // Disable the back/next buttons.
            //
            DWORD dwID ;
            s_hThread = CreateThread( NULL,
                0,
                (LPTHREAD_START_ROUTINE) PingServerThread,
                (LPVOID) NULL,
                0,
                &dwID ) ;
            ASSERT(s_hThread) ;
            if (s_hThread)
            {
                s_dwStartTime = GetTickCount() ;
                s_fCheckServer = TRUE ;
                s_fWaitCancelPressed = FALSE;
                PropSheet_PressButton(GetParent(hdlg), PSBTN_NEXT) ;
                PropSheet_SetWizButtons(GetParent(hdlg), 0) ;
                SetWindowLongPtr( hdlg, DWLP_MSGRESULT, -1 );
                return false;
            }
        }
    }

    SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
    DebugLogMsg(eInfo, L"The server name povided is valid.");
    return true;
} //CheckServer


bool IsADEnvironment()
{
    DWORD dwDsEnv = ADRawDetection();

    if (dwDsEnv != MSMQ_DS_ENVIRONMENT_PURE_AD)
    {
        DebugLogMsg(eWarning, L"No Active Directory server was found.");
        return false;
    }
    DebugLogMsg(eInfo, L"An Active Directory server was found.");

    if(!WriteDsEnvRegistry(MSMQ_DS_ENVIRONMENT_PURE_AD))
    {
		g_fCancelled = true;
    }
    return true;
}


BOOL
SkipOnClusterUpgrade(
    VOID
    )
/*++

Routine Description:

    Check if the server name page should be skipped in the
    case of upgrading msmq on cluster.

    When upgrading PEC/PSC/BSC on cluster, MQIS is migarted
    to a remote Windows domain controller.
    The upgraded PEC/PSC/BSC is downgraded to a routing server during
    upgrade. Then after logon to Win2K the post-cluster-upgrade wizard
    runs and should find this remote domain controller which serves as
    msmq ds server (either find it automatically or ask user).

Arguments:

    None

Return Value:

    true - Skip the server name page and logic (i.e. we run as a 
           post-cluster-upgrade wizard for client or routing server).

    false - Do not skip the server name page.

--*/
{
    if (!g_fWelcome         || 
        !Msmq1InstalledOnCluster())
    {
        //
        // Not running as post-cluster-upgrade wizard.
        //
        return false;
    }

    DWORD dwMqs = SERVICE_NONE;
    MqReadRegistryValue(MSMQ_MQS_REGNAME, sizeof(DWORD), &dwMqs);

    if (dwMqs == SERVICE_PEC ||
        dwMqs == SERVICE_PSC ||
        dwMqs == SERVICE_BSC)
    {
        //
        // Upgrade of PEC/PSC/BSC
        //
        return false;
    }

    return true;

} //SkipOnClusterUpgrade

static
std::wstring
GetDlgItemTextInternal(
    HWND hDlg,
    int nIDDlgItem
	)
{
	WCHAR buffer[MAX_STRING_CHARS] = L"";
	int n = GetDlgItemText(
			  hDlg, 
			  nIDDlgItem, 
			  buffer,
			  TABLE_SIZE(buffer)
			  );
	if(n == 0)
	{
		DWORD gle = GetLastError();
		if(gle == 0)
		{
			DebugLogMsg(eWarning, L"Gettting the text from the dialog box failed. No text was entered.");
			return buffer;
		}
		DebugLogMsg(eError, L"Getting the text from the dialog box failed. Last error: %d", gle);

	}
	if(n == TABLE_SIZE(buffer) - 1)
	{
		DebugLogMsg(eError, L"The text entered is too long. Setup is exiting.");
	}
	return buffer;
}


//+--------------------------------------------------------------
//
// Function: MsmqServerNameDlgProc
//
// Synopsis:
//
//+--------------------------------------------------------------
INT_PTR
CALLBACK
MsmqServerNameDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM /*wParam*/,
    IN LPARAM lParam )
{
    switch(msg)
    {
        case WM_INITDIALOG:
        {
            return 1;
        }

        case WM_COMMAND:
        {
            return 0;
        }

        case WM_NOTIFY:
        {
            switch(((NMHDR *)lParam)->code)
            {
                case PSN_SETACTIVE:
                {                          

                    if (g_fCancelled           ||
                        g_fUpgrade             ||
                        g_SubcomponentMsmq[eADIntegrated].dwOperation != INSTALL ||
                        g_fWorkGroup           ||
                        g_fSkipServerPageOnClusterUpgrade ||
                        g_fBatchInstall
                        )
                    {
                        return SkipWizardPage(hdlg);
                    }

                    
                    //
                    // Attended Setup
                    //
                    if (IsADEnvironment())
	                {
		                return SkipWizardPage(hdlg);
			        }
					
					if(g_fServerSetup)
					{
						//
						// rs,ds installation in nt4 environment is not supported.
						//
						MqDisplayError(hdlg, IDS_SERVER_INSTALLATION_NOT_SUPPORTED, 0);
						g_fCancelled = TRUE;
						return SkipWizardPage(hdlg);
					}
              
                    PropSheet_SetWizButtons(GetParent(hdlg), PSWIZB_NEXT);
                    DebugLogMsg(eUI, L"The Directory Services dialog page is displayed."); 
                }
                
                //
                // fall through
                //
                case PSN_KILLACTIVE:
                case PSN_WIZFINISH:
                case PSN_QUERYCANCEL:
                case PSN_WIZBACK:
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    return 1;

                case PSN_WIZNEXT:
                {
                    ASSERT(!g_fBatchInstall);
                    
                    g_ServerName = GetDlgItemTextInternal(
									hdlg, 
									IDC_EDIT_ServerName
									);
                      
                    OcpRemoveWhiteSpaces(g_ServerName);

                    if(g_ServerName.empty())
                    {
                        //
                        // We did not detect AD and the user chose not to supply a PEC name, 
                        // therefore we continue in Offline Setup.
                        //

                        DebugLogMsg(eInfo, L"The user did not enter a Message Queuing server name. Setup will continue in offline mode.");
                        SetWindowLongPtr(hdlg, DWLP_MSGRESULT, 0);
                        g_fInstallMSMQOffline = TRUE;
                        return 1; 
						
                    }

                    if(CheckServer(hdlg))
                    {
                        //
                        // DS DLL needs the server name in registry
                        //
                        StoreServerPathInRegistry(g_ServerName);
                    }
                    return 1;
                }
                break;
            }
            break;
        }
        default:
        {
            return 0;
        }
    }
    return 0;
} // MsmqServerNameDlgProc


/// Dependant Client

//+--------------------------------------------------------------
//
// Function: SupportingServerNameDlgProc
//
// Synopsis:
//
//+--------------------------------------------------------------
INT_PTR
CALLBACK
SupportingServerNameDlgProc(
    HWND   hdlg,
    UINT   msg,
    WPARAM /*wParam*/,
    LPARAM lParam 
    )
{
    switch(msg)
    {
        case WM_INITDIALOG:
        {
            return 1;
        }

        case WM_COMMAND:
        {
            return 0;
        }

        case WM_NOTIFY:
        {

            switch(((NMHDR *)lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    if(!g_fDependentClient ||
                       g_fUpgrade	||
                       g_fCancelled ||
                       g_SubcomponentMsmq[eMSMQCore].dwOperation != INSTALL ||
                       g_fWorkGroup ||
                       g_fSkipServerPageOnClusterUpgrade ||
                       g_fBatchInstall
                       )
                    {
                        return SkipWizardPage(hdlg);
                    }
  
                    PropSheet_SetWizButtons(GetParent(hdlg), PSWIZB_NEXT);
                    DebugLogMsg(eUI, L"The Supporting Server Name dialog page is displayed.");
                }
                //
                // fall through
                //

                case PSN_QUERYCANCEL:
                case PSN_KILLACTIVE:
                case PSN_WIZFINISH:
                case PSN_WIZBACK:
                {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    return 1;
                }

                case PSN_WIZNEXT:
                {                                        
                    ASSERT(!g_fBatchInstall);
                    g_ServerName = GetDlgItemTextInternal(
										hdlg, 
										IDC_EDIT_SupportingServerName
                                        );

                    OcpRemoveWhiteSpaces(g_ServerName);

                    CheckServer(hdlg);
                    return 1;
                }
           }
        }
    }
    return 0;
} // MsmqServerNameDlgProc


//
// Stub functions for the DS client side RPC interface
// These functions are never called as Setup does not initiate a DS
// call that will trigger these callbacks.
//


/* [callback] */
HRESULT
S_DSQMSetMachinePropertiesSignProc( 
    /* [size_is][in] */ BYTE* /*abChallenge*/,
    /* [in] */ DWORD /*dwCallengeSize*/,
    /* [in] */ DWORD /*dwContext*/,
    /* [length_is][size_is][out][in] */ BYTE* /*abSignature*/,
    /* [out][in] */ DWORD* /*pdwSignatureSize*/,
    /* [in] */ DWORD /*dwSignatureMaxSize*/
    )
{
    ASSERT(0);
    return MQ_ERROR_ILLEGAL_OPERATION;
}


/* [callback] */
HRESULT
S_DSQMGetObjectSecurityChallengeResponceProc( 
    /* [size_is][in] */ BYTE* /*abChallenge*/,
    /* [in] */ DWORD /*dwCallengeSize*/,
    /* [in] */ DWORD /*dwContext*/,
    /* [length_is][size_is][out][in] */ BYTE* /*abCallengeResponce*/,
    /* [out][in] */ DWORD* /*pdwCallengeResponceSize*/,
    /* [in] */ DWORD /*dwCallengeResponceMaxSize*/
    )
{
    ASSERT(0);
    return MQ_ERROR_ILLEGAL_OPERATION;
}


/* [callback] */
HRESULT
S_InitSecCtx( 
    /* [in] */ DWORD /*dwContext*/,
    /* [size_is][in] */ UCHAR* /*pServerbuff*/,
    /* [in] */ DWORD /*dwServerBuffSize*/,
    /* [in] */ DWORD /*dwClientBuffMaxSize*/,
    /* [length_is][size_is][out] */ UCHAR* /*pClientBuff*/,
    /* [out] */ DWORD* /*pdwClientBuffSize*/
    )
{
    ASSERT(0);
    return MQ_ERROR_ILLEGAL_OPERATION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\setupdef.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    setupdef.h

Abstract:

    Various definitions.

Author:


--*/

#ifndef __SETUPDEF_H
#define __SETUPDEF_H

#define SERVICE_DSSRV  SERVICE_BSC

//
// Setup modes
//
#define INSTALL     (1)
#define DONOTHING   (2)  // Re-install or Re-remove
#define REMOVE      (3)

//
//
// Definitions for directories
//
#define  OCM_DIR_DRIVERS             TEXT("\\drivers")          // Under system32
#define  OCM_DIR_MSMQ_SETUP_EXCHN    TEXT("\\setup\\exchconn")  // Under MSMQ root
#define  OCM_DIR_WIN_HELP            TEXT("\\help")             // Under winnt
#define LQS_SUBDIRECTORY_NAME TEXT("LQS") //BugBug: should be global,and used by setup and qm\lqs.cpp

//
// Definition for iis extension
//
#define PARENT_PATH             TEXT("/LM/W3Svc/1/Root/")
#define ROOT                    TEXT("/")
#define MSMQ_IISEXT_NAME        TEXT("MSMQ")
#define DEFAULT_WEB_SERVER_PATH TEXT("/LM/W3Svc/1")

//
// Definitions for MSMQ 1.0
//
#define  OCM_DIR_SDK                 TEXT("\\sdk")
#define  OCM_DIR_SDK_DEBUG           TEXT("\\sdk\\debug")
#define  OCM_DIR_SETUP               TEXT("\\setup")
#define  OCM_DIR_INSTALL             TEXT("\\install")
#define  MSMQ_ACME_SHORTCUT_GROUP    TEXT("Microsoft Message Queue")
#define  MSMQ1_INSTALL_SHARE_NAME    TEXT("msmqinst")

//
// Maximum string size
//
#define MAX_STRING_CHARS 1024

//
// Locale aware strings compare
//
#define  OcmStringsEqual(str1, str2)   (0 == CompareStringsNoCase(str1, str2))

#define LOG_FILENAME            TEXT("msmqinst.log")
#define TRACE_MOF_FILENAME    TEXT("msmqtrc.mof")

//
// DLL names
//
#define MQUTIL_DLL   TEXT("MQUTIL.DLL")
#define ACTIVEX_DLL  TEXT("MQOA.DLL")
#define MQRT_DLL     TEXT("MQRT.DLL")
#define SNAPIN_DLL   TEXT("MQSNAP.DLL")
#define MQMAILOA_DLL TEXT("MQMAILOA.DLL")
#define MQMIG_EXE    TEXT("MQMIG.EXE")
#define MQISE_DLL    TEXT("MQISE.DLL")

#define MQTRIG_DLL	 TEXT("MQTRIG.DLL")
#define MQTRXACT_DLL TEXT("mqgentr.dll")
#define MQTGCLUS_DLL TEXT("mqtgclus.dll")

//
// Definitions for MSMQ Win95 migration DLL
//

//
// Note: MQMIG95_INFO_FILENAME used to be a .ini file. Its extension 
// changed to .txt to work around a problem in GUI mode setup (.ini files "disappear")
// - Bug #4221, YoelA, 15-Mar-99
//
#define  MQMIG95_INFO_FILENAME     TEXT("msmqinfo.txt")
#define  MQMIG95_MSMQ_SECTION      TEXT("msmq")
#define  MQMIG95_MSMQ_DIR          TEXT("directory")
#define  MQMIG95_MSMQ_TYPE         TEXT("type")
#define  MQMIG95_MSMQ_TYPE_IND     TEXT("IND")
#define  MQMIG95_MSMQ_TYPE_DEP     TEXT("DEP")

//
// Useful macros
//
#define REGSVR32 L"regsvr32.exe"
#define MOFCOMP  L"\\wbem\\mofcomp.exe"
#define SERVER_INSTALL_COMMAND   TEXT("regsvr32.exe -s ")
#define SERVER_UNINSTALL_COMMAND TEXT("regsvr32.exe -s -u ")
#define TRACE_REGISTER_COMMAND   TEXT("mofcomp ")
#define TRACE_NAMESPACE_ROOT     TEXT("root\\wmi")



//
// Service stop / start intervals
//
#define MAXIMUM_WAIT_FOR_SERVICE_IN_MINUTES 2
#define WAIT_INTERVAL 100


//
// MSMQ Trace class names
//
#define MSMQ_GENERAL        L"MSMQ_GENERAL"
#define MSMQ_AC             L"MSMQ_AC"
#define MSMQ_NETWORKING     L"MSMQ_NETWORKING"
#define MSMQ_SRMP           L"MSMQ_SRMP"
#define MSMQ_RPC            L"MSMQ_RPC"
#define MSMQ_DS             L"MSMQ_DS"
#define MSMQ_ROUTING        L"MSMQ_ROUTING"
#define MSMQ_XACT           L"MSMQ_XACT"
#define MSMQ_XACT_SEND      L"MSMQ_XACT_SEND"
#define MSMQ_XACT_RCV       L"MSMQ_XACT_RCV"
#define MSMQ_XACT_LOG       L"MSMQ_XACT_LOG"
#define MSMQ_LOG            L"MSMQ_LOG"
#define MSMQ_PROFILING      L"MSMQ_PROFILING"
#define MSMQ_SECURITY       L"MSMQ_SECURITY"


#endif // __SETUPDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\subcomp.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    subcomp.cpp

Abstract:

    Code to handle subcomponents of MSMQ setup.

Author:

    Tatiana Shubin  (TatianaS)  21-Sep-00

Revision History:
	

--*/

#include "msmqocm.h"

#include "subcomp.tmh"

#define WELCOME_PREFIX  L"Welcome_"

using namespace std;
//+-------------------------------------------------------------------------
//
//  Function: GetSubcomponentStateFromRegistry
//
//  Synopsis: Returns SubcompOn if subcomponent is defined in registry
//              when this setup is started
//
//--------------------------------------------------------------------------

DWORD GetSubcomponentStateFromRegistry( IN const TCHAR   *SubcomponentId,
                                        IN const TCHAR   *szRegName)
{           
    ASSERT(SubcomponentId);

    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        if (_tcsicmp(SubcomponentId, g_SubcomponentMsmq[i].szSubcomponentId) != 0)
        {
            continue;
        }
        
        //
        // we found subcomponent in array
        //
        DWORD dwState = 0;    

        if (MqReadRegistryValue(
                szRegName,                
                sizeof(DWORD),
                (PVOID) &dwState,
                /* bSetupRegSection = */TRUE
                ))
        {
            //
            // registry key is found, it means that this subcomponent
            // was installed early
            //
            g_SubcomponentMsmq[i].fInitialState = TRUE;
            return SubcompOn;
        }
        else
        {
            //
            // registry key is not found
            //
            g_SubcomponentMsmq[i].fInitialState = FALSE;
            return SubcompOff;
        }    
    }
    return SubcompOff;
}

//+-------------------------------------------------------------------------
//
//  Function: GetSubcomponentWelcomeState
//
//  Synopsis: Returns SubcompOn if subcomponent was selected in GUI mode
//
//--------------------------------------------------------------------------

DWORD GetSubcomponentWelcomeState (IN const TCHAR    *SubcomponentId)
{
    if (SubcomponentId == NULL)
    {
        //
        // do nothing
        //
        return SubcompOff;
    } 

    TCHAR szRegName[256];
    _stprintf(szRegName, L"%s%s", WELCOME_PREFIX, SubcomponentId);        

    DWORD dwWelcomeState = GetSubcomponentStateFromRegistry(SubcomponentId, szRegName);
    return dwWelcomeState;
}

	
//+-------------------------------------------------------------------------
//
//  Function: GetSubcomponentInitialState
//
//  Synopsis: Returns SubcompOn if subcomponent is already installed
//              when this setup is started
//
//--------------------------------------------------------------------------
DWORD GetSubcomponentInitialState(IN const TCHAR    *SubcomponentId)
{
    if (SubcomponentId == NULL)
    {
        //
        // do nothing
        //
        return SubcompOff;
    }

    DWORD dwInitialState = GetSubcomponentStateFromRegistry(SubcomponentId, SubcomponentId);
    return dwInitialState;
}

//+-------------------------------------------------------------------------
//
//  Function: GetSubcomponentFinalState
//
//  Synopsis: Returns SubcompOn if subcomponent is successfully installed
//              during this setup
//
//--------------------------------------------------------------------------

DWORD GetSubcomponentFinalState (IN const TCHAR    *SubcomponentId)
{
    if (SubcomponentId == NULL)
    {
        //
        // do nothing
        //
        return SubcompOff;
    }    

    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        if (_tcsicmp(SubcomponentId, g_SubcomponentMsmq[i].szSubcomponentId) != 0)
        {
            continue;
        }
        
        //
        // we found subcomponent in array
        //
        if (g_SubcomponentMsmq[i].fIsInstalled)
        {
            //
            // it means that this subcomponent was installed 
            // successfully
            //               
            return SubcompOn;
        }
        else
        {
			//
			// http support is installed only later
			// since it will set the setup\ocmmanger\msmq_httpsupport entry
			// after we finish according to what we tell it now we
			// let the ocmanager think that the selection succeeded.
			// this is wrong if iis setup fails, but then we keep track of
			// the real status and you would need to run setup again anyway.
			if( i == eHTTPSupport &&
					g_SubcomponentMsmq[i].fIsSelected == TRUE )
				return SubcompUseOcManagerDefault;
            //
            // this subcomponent was not installed
            //           
            return SubcompOff;
        }    
    }

    return SubcompOff;
}

//+-------------------------------------------------------------------------
//
//  Function: GetSetupOperationForSubcomponent
//
//  Synopsis: Return setup operation for the specific subcomponent
//
//--------------------------------------------------------------------------
DWORD GetSetupOperationForSubcomponent (DWORD SubcomponentIndex)
{
    if ( (g_SubcomponentMsmq[SubcomponentIndex].fInitialState == TRUE) &&
         (g_SubcomponentMsmq[SubcomponentIndex].fIsSelected == FALSE) )
    {
        return REMOVE;
    }

    if ( (g_SubcomponentMsmq[SubcomponentIndex].fInitialState == FALSE) &&
         (g_SubcomponentMsmq[SubcomponentIndex].fIsSelected == TRUE) )
    {
        return INSTALL;
    }

    return DONOTHING;
}


//+-------------------------------------------------------------------------
//
//  Function: SetOperationForSubcomponent
//
//  Synopsis: All flags for specific subcomponent are set here.
//
//--------------------------------------------------------------------------
void SetOperationForSubcomponent (DWORD SubcomponentIndex)
{    
    DWORD dwErr;
    BOOL fInitialState = g_ComponentMsmq.HelperRoutines.QuerySelectionState(
                                g_ComponentMsmq.HelperRoutines.OcManagerContext,
                                g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId,
                                OCSELSTATETYPE_ORIGINAL
                                ) ;
    if (fInitialState)
    {
        g_SubcomponentMsmq[SubcomponentIndex].fInitialState = TRUE;

        DebugLogMsg(
        	eInfo, 
			L"The %s subcomponent was selected initially.",
            g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId
			);
    }
    else
    {
        dwErr = GetLastError();
        if (dwErr == NO_ERROR)
        {
            g_SubcomponentMsmq[SubcomponentIndex].fInitialState = FALSE;
                      
            DebugLogMsg(
            	eInfo, 
				L"The %s subcomponent was NOT selected initially.",
                g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId
				);
        }
        else
        {                    
            ASSERT(("initial status for subcomponent is unknown", dwErr));
            g_SubcomponentMsmq[SubcomponentIndex].fInitialState = FALSE;
            
            DebugLogMsg(
            	eInfo, 
				L"The initial status of the %s subcomponent is unknown. Error code: %x.",
                g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId, dwErr
				);
        }    
    }   // fInitialState

    BOOL fCurrentState;     
    fCurrentState =  g_ComponentMsmq.HelperRoutines.QuerySelectionState(
                                g_ComponentMsmq.HelperRoutines.OcManagerContext,
                                g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId,
                                OCSELSTATETYPE_CURRENT
                                ) ;    

    if (fCurrentState)
    {
        g_SubcomponentMsmq[SubcomponentIndex].fIsSelected = TRUE;
            
        DebugLogMsg(
        	eInfo, 
			L"The %s subcomponent is currently selected.",
            g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId
			);
    }
    else 
    {
        dwErr = GetLastError();
        if (dwErr == NO_ERROR)
        {
            g_SubcomponentMsmq[SubcomponentIndex].fIsSelected = FALSE;
			DebugLogMsg(
				eInfo, 
				L"The %s subcomponent is NOT selected.",
                g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId
				);
        }
        else
        {          
            //         
            // set IsSelected flag to the same state as InitialState flag: so
            // we are sure that we do NOTHING with this subcomponent
            //
            ASSERT(("current status for subcomponent is unknown", dwErr));
            g_SubcomponentMsmq[SubcomponentIndex].fIsSelected = 
                g_SubcomponentMsmq[SubcomponentIndex].fInitialState;

            DebugLogMsg(
            	eInfo, 
				L"The current status of the %s subcomponent is unknown. Error code: %x.",
                g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId, 
				dwErr
				);
        }   
    }
    
	DWORD dwOperation = GetSetupOperationForSubcomponent(SubcomponentIndex);
	
    wstring Mode;
    if (dwOperation == INSTALL)
    {
        Mode = L"INSTALL";
    }
    else if (dwOperation == REMOVE)
    {
        Mode = L"REMOVE";
    }
    else
    {
        Mode = L"DO NOTHING";
    }
    
    DebugLogMsg(
    	eInfo, 
		L"The current mode for the %s subcomponent is %s.",
        g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId, 
		Mode.c_str()
		);


    g_SubcomponentMsmq[SubcomponentIndex].dwOperation = dwOperation;
    if (dwOperation == DONOTHING)
    {
        //
        // it means that status was not changed and the final state will 
        // be equal to the initial state
        //
        g_SubcomponentMsmq[SubcomponentIndex].fIsInstalled = 
            g_SubcomponentMsmq[SubcomponentIndex].fInitialState;
    }
    else
    {
        //
        // if we need to install/ remove this subcomponent
        // this flag will be updated by removing/installation
        // function that is defined for this component.
        // Now set to FALSE: will be set correct value after the install/remove
        //
        g_SubcomponentMsmq[SubcomponentIndex].fIsInstalled = FALSE;
    }
}        


//+-------------------------------------------------------------------------
//
//  Function: UnregisterSubcomponentForWelcome
//
//  Synopsis: Unregister subcomponent in "Welcome" mode if it was installed
//              successfully
//
//--------------------------------------------------------------------------
BOOL UnregisterSubcomponentForWelcome (DWORD SubcomponentIndex)
{
    TCHAR RegKey[256];
    _stprintf(RegKey, L"%s%s", WELCOME_PREFIX, 
        g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId);

    if (!RemoveRegistryKeyFromSetup (RegKey))
    {
        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function: FinishToRemoveSubcomponent
//
//  Synopsis: Clean subcomponent registry if removing was successfully
//
//--------------------------------------------------------------------------
BOOL FinishToRemoveSubcomponent (DWORD SubcomponentIndex)
{    
    if (!RemoveRegistryKeyFromSetup (g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId))
    {
        return FALSE;
    }

    g_SubcomponentMsmq[SubcomponentIndex].fIsInstalled = FALSE;

    DebugLogMsg(
    	eInfo, 
		L"The %s subcomponent was removed successfully.",
        g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId
		);

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function: FinishToInstallSubcomponent
//
//  Synopsis: Set subcomponent registry if installation was successfully
//
//--------------------------------------------------------------------------
BOOL FinishToInstallSubcomponent (DWORD SubcomponentIndex)
{
    DWORD dwValue = 1;
    MqWriteRegistryValue(
                g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId,
                sizeof(DWORD),
                REG_DWORD,
                &dwValue,
                TRUE //bSetupRegSection 
                );

    g_SubcomponentMsmq[SubcomponentIndex].fIsInstalled = TRUE;
    
    DebugLogMsg(
    	eInfo, 
		L"The %s subcomponent was installed successfully.",
        g_SubcomponentMsmq[SubcomponentIndex].szSubcomponentId
		);

	return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function: LogSelectedComponents
//
//  Synopsis: Only in debug version log selected components to the file
//
//--------------------------------------------------------------------------
void
LogSelectedComponents()
{   
    DebugLogMsg(eInfo, L"The final selections are:");
	std::wstring Mode;
    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        if (g_SubcomponentMsmq[i].dwOperation == INSTALL)
        {
            Mode = L"INSTALL";
        }
        else if (g_SubcomponentMsmq[i].dwOperation == REMOVE)
        {
            Mode = L"REMOVE";
        }
        else
        {
            Mode = L"DO NOTHING";
        }     

		DebugLogMsg(
			eInfo,
			L"The current mode for the %s subcomponent is %s.",
            g_SubcomponentMsmq[i].szSubcomponentId, 
			Mode.c_str()
			);
    }
}

//+-------------------------------------------------------------------------
//
//  Function: SetSubcomponentForUpgrade
//
//  Synopsis: This function called in Upgrade mode to define which 
//              subcomponent has to be installed
//
//--------------------------------------------------------------------------
void
SetSubcomponentForUpgrade()
{
    //
    // MSMQ Core must be installed always
    //
    g_SubcomponentMsmq[eMSMQCore].fInitialState = FALSE;
    g_SubcomponentMsmq[eMSMQCore].fIsSelected = TRUE;
    g_SubcomponentMsmq[eMSMQCore].dwOperation = INSTALL;

    if (g_fDependentClient)
    {
        LogSelectedComponents();
        return;
    }
   
    //
    // Install independent client/ server
    //
    g_SubcomponentMsmq[eLocalStorage].fInitialState = FALSE;
    g_SubcomponentMsmq[eLocalStorage].fIsSelected = TRUE;
    g_SubcomponentMsmq[eLocalStorage].dwOperation = INSTALL;

    //
    // Install triggers
    //
    if (TriggersInstalled(NULL))
    {
        g_SubcomponentMsmq[eTriggersService].fInitialState = FALSE; 
        g_SubcomponentMsmq[eTriggersService].fIsSelected = TRUE;
        g_SubcomponentMsmq[eTriggersService].dwOperation = INSTALL;
    }

    DebugLogMsg(
    	eInfo, 
        L"The Triggers subcomponent installation status parameters are: InitialState = %d, IsSelected = %d, Operation = %d",
        g_SubcomponentMsmq[eTriggersService].fInitialState,
        g_SubcomponentMsmq[eTriggersService].fIsSelected,
        g_SubcomponentMsmq[eTriggersService].dwOperation
        );

    DWORD dwAlwaysWorkgroup;
    if (!MqReadRegistryValue( MSMQ_ALWAYS_WORKGROUP_REGNAME,
                             sizeof(dwAlwaysWorkgroup),
                            (PVOID) &dwAlwaysWorkgroup ))    
    {
        //
        // install AD Integrated
        //
        g_SubcomponentMsmq[eADIntegrated].fInitialState = FALSE;
        g_SubcomponentMsmq[eADIntegrated].fIsSelected = TRUE;
        g_SubcomponentMsmq[eADIntegrated].dwOperation = INSTALL;
    }

    if (g_fWorkGroup)
    {
        //
        // if it is setup on workgroup install only ind. client
        //
        LogSelectedComponents();
        return;
    }

    if (g_dwMachineTypeDs)
    {
        //
        // install MQDS service on the former DS Servers
        //
        g_SubcomponentMsmq[eMQDSService].fInitialState = FALSE;
        g_SubcomponentMsmq[eMQDSService].fIsSelected = TRUE;
        g_SubcomponentMsmq[eMQDSService].dwOperation = INSTALL;
    }

	if(GetSubcomponentInitialState(HTTP_SUPPORT_SUBCOMP) == SubcompOn)
    {
        //
        // install HTTP support on servers
        //
        g_SubcomponentMsmq[eHTTPSupport].fInitialState = FALSE;
        g_SubcomponentMsmq[eHTTPSupport].fIsSelected = TRUE;
        g_SubcomponentMsmq[eHTTPSupport].dwOperation = INSTALL;
		if(GetSubcomponentInitialState(HTTP_SUPPORT_SUBCOMP) == SubcompOn)
		{
			g_fUpgradeHttp = true;
		}
    }    

    if(g_dwMachineTypeFrs)
    {
        //
        // install routing support on former routing servers
        //
        g_SubcomponentMsmq[eRoutingSupport].fInitialState = FALSE;
        g_SubcomponentMsmq[eRoutingSupport].fIsSelected = TRUE;
        g_SubcomponentMsmq[eRoutingSupport].dwOperation = INSTALL;
    }
   
    LogSelectedComponents();
}


//+-------------------------------------------------------------------------
//
//  Function: UpdateSetupDefinitions()
//
//  Synopsis: Update global flags not in fresh install
//
//--------------------------------------------------------------------------
void 
UpdateSetupDefinitions()
{
    ASSERT(g_SubcomponentMsmq[eMSMQCore].dwOperation == DONOTHING);

	if(g_fUpgrade || g_fDependentClient)
	{
		//
		// Upgrade or Dependent client Do nothing
		//
		return;
	}

	//
    // Code that handle possible changes to the global flags due to 
	// add/remove routing support or Downlevel client support
    //
	g_fServerSetup = FALSE;
	g_dwMachineType = SERVICE_NONE;
	if (g_SubcomponentMsmq[eMQDSService].dwOperation == INSTALL) 
	{
		//
		// MQDS Service will be installed
		//
		g_dwMachineTypeDs = 1;
	}

	if (g_SubcomponentMsmq[eMQDSService].dwOperation == REMOVE) 
	{
		//
		// MQDS Service will be removed
		//
		g_dwMachineTypeDs = 0;
	}

	if (g_SubcomponentMsmq[eRoutingSupport].dwOperation == INSTALL)
	{      
		//
		// routing server will be installed
		//
		ASSERT(("routing on workgroup not supported", !g_fWorkGroup));
		g_dwMachineTypeFrs = 1;     
	}

	if (g_SubcomponentMsmq[eRoutingSupport].dwOperation == REMOVE)
	{      
		//
		// routing server will be removed
		//
		ASSERT(("Remove routing is supported only on workgroup", g_fWorkGroup));
		g_dwMachineTypeFrs = 0;     
	}

	//
	// Determinating the new g_fServerSetup, g_dwMachineType after the possible changes
	// 
	if(g_dwMachineTypeFrs || g_dwMachineTypeDs)
	{
		g_fServerSetup = TRUE;
		g_dwMachineType = g_dwMachineTypeDs ? SERVICE_DSSRV : SERVICE_SRV;
	}
}


//+-------------------------------------------------------------------------
//
//  Function: SetSetupDefinitions()
//
//  Synopsis: Set global flags those define machine type and AD integration
//              This code was in wizpage.cpp, function TypeButtonToMachineType
//              in the previous setup
//
//--------------------------------------------------------------------------
void 
SetSetupDefinitions()
{
    //
    // Note: this code is called on unattneded scenarios too!
    //
    if (g_SubcomponentMsmq[eMSMQCore].dwOperation == REMOVE)
    {
        //
        // do nothing: MSMQ will be removed, all these globals flags were
        // defined in ocminit.cpp.
        // In old scenario (without subcomponents)
        // we skip all pages and did not call function
        // TypeButtonToMachineType
        //
        return;
    }

    if (g_SubcomponentMsmq[eMSMQCore].dwOperation == DONOTHING)
    {
        //
        // MSMQ Core is already installed, 
        // all these globals flags were defined in ocminit.cpp.
        // Handle updates due to possible add/remove routing support or Downlevel client support
        //
		UpdateSetupDefinitions();

        return;
    }

    ASSERT (g_SubcomponentMsmq[eMSMQCore].dwOperation == INSTALL);   
    
    //
    // It is first MSMQ installation
    //
    if (g_SubcomponentMsmq[eLocalStorage].dwOperation == DONOTHING)
    {
        //
        // it is the first installation since MSMQCore will be installed
        // and Local Storage was not selected: it means user like to 
        // install Dependent Client
        //        

        ASSERT(("dep client on domain controller not supported", !g_dwMachineTypeDs));
        ASSERT(("dep client on workgroup not supported", !g_fWorkGroup));
#ifdef _WIN64
        {
        ASSERT(("dep client on 64bit computer not supported", 0));
        }
#endif
        g_dwMachineType = SERVICE_NONE ;
        g_dwMachineTypeFrs = 0;
        g_fServerSetup = FALSE ;
        g_uTitleID = IDS_STR_CLI_ERROR_TITLE;
        g_fDependentClient = TRUE ;       
        return;
    }

    //
    // Ind. Client/ server will be installed
    //
    g_fDependentClient = FALSE ;
    g_fServerSetup = TRUE ;
    g_uTitleID = IDS_STR_SRV_ERROR_TITLE;    
    //
    //  For fresh install, g_dwMachineTypeDs is set only if the user had selected
    //  MQDS service componant and not according to product type
    //
    if ( g_dwMachineTypeDs == 0)   // don't override upgrade selections
    {
        if (g_SubcomponentMsmq[eMQDSService].dwOperation == INSTALL) 
        {
            g_dwMachineTypeDs = 1;
        }
    }
   
    if (g_SubcomponentMsmq[eRoutingSupport].dwOperation == INSTALL)
    {      
        //
        // routing server will be installed
        //
        ASSERT(("routing on workgroup not supported", !g_fWorkGroup ));
        g_dwMachineType = g_dwMachineTypeDs ? SERVICE_DSSRV : SERVICE_SRV;
        g_dwMachineTypeFrs = 1;     
    }
    else // at least eLocalStorage was selected (otherwise Dep. Client case)
    {
        //
        // independent client or DSServer will be installed
        //
        ASSERT (g_SubcomponentMsmq[eLocalStorage].dwOperation == INSTALL);   
    
        g_dwMachineType = g_dwMachineTypeDs ? SERVICE_DSSRV : SERVICE_NONE;
        g_dwMachineTypeFrs = 0;     
        g_fServerSetup = g_dwMachineTypeDs ? TRUE : FALSE ;
        g_uTitleID = g_dwMachineTypeDs ? IDS_STR_SRV_ERROR_TITLE : IDS_STR_CLI_ERROR_TITLE;      
    }  
            
    //
    // AD Integration
    //    
    if (g_SubcomponentMsmq[eADIntegrated].dwOperation == DONOTHING)
    {        
        g_fDsLess = TRUE;     
		DebugLogMsg(eInfo, L"The status of Active Directory Integration is 'Do Nothing'. Setup is setting g_fDsLess to TRUE.");
    }

}

//+-------------------------------------------------------------------------
//
//  Function: ValidateSelection
//
//  Synopsis: Validate if selection was correct. Unfortunately, we can leave
//              selection window with incorrect values (scenario: remove all
//              and then add what we want)
//              NB: this function called for both attended 
//              and unattended modes
//
//--------------------------------------------------------------------------
void ValidateSelection()
{            
    #ifdef _WIN64
    {    
        if (g_SubcomponentMsmq[eMSMQCore].dwOperation == INSTALL)
        {            
            //
            // It is impossible to install Dep. Client on 64 bit machine.
            // So, MSMQCore means here to install Ind. Client.
            // Just set operation to INSTALL for LocalStorage subcomponent 
            // to keep all internal setup logic.
            //
            g_SubcomponentMsmq[eLocalStorage].dwOperation = INSTALL;            
            g_SubcomponentMsmq[eLocalStorage].fIsSelected = TRUE;            
        }
    }
    #endif   
    

    CResString strParam;    
    //
    // Workgroup problem
    //    
    if (g_fWorkGroup)
    {        
        if (g_SubcomponentMsmq[eLocalStorage].dwOperation == DONOTHING &&
            g_SubcomponentMsmq[eMSMQCore].dwOperation == INSTALL)
        {
            //
            //  it is impossible to install Dep. Client on Workgroup
            //    
            strParam.Load(IDS_DEP_ON_WORKGROUP_WARN);            
            MqDisplayError(NULL, IDS_WRONG_CONFIG_ERROR, 0,
                strParam.Get());           
            g_fCancelled = TRUE;
            return;            
        }
      
        if (g_SubcomponentMsmq[eRoutingSupport].dwOperation == INSTALL)
        {
            //
            //  it is impossible to install Routing on Workgroup
            //
            strParam.Load(IDS_ROUTING_ON_WORKGROUP_ERROR);            
            MqDisplayError(NULL, IDS_WRONG_CONFIG_ERROR, 0,
                strParam.Get());
            g_fCancelled = TRUE;
            return;                 
        }

        if(g_SubcomponentMsmq[eMQDSService].dwOperation == INSTALL)
        {
            //
            //  it is impossible to install MQDS Service on Workgroup
            //
            strParam.Load(IDS_MQDS_ON_WORKGROUP_ERROR);            
            MqDisplayError(NULL, IDS_WRONG_CONFIG_ERROR, 0,
                strParam.Get());
            g_fCancelled = TRUE;
            return;
        }                
    }

    if (g_SubcomponentMsmq[eMSMQCore].dwOperation != DONOTHING)
    {
        //
        // MSMQ Core will be installed/ removed: 
        // all selection are acceptable
        // 
        return;
    }

    if (g_SubcomponentMsmq[eMSMQCore].fInitialState == FALSE)
    {
        //
        // MSMQ Core was not installed and will not be installed
        // (since we are here if operation DONOTHING)
        //
        return;
    }

    //
    // We are here if MSMQ Core is already installed and will not be removed
    //

    //
    // "MSMQ already installed" problem
    //


    //
    // verify that state for local storage is not changed    
    //
    if (g_SubcomponentMsmq[eLocalStorage].dwOperation != DONOTHING)
    {
        strParam.Load(IDS_CHANGE_LOCAL_STORAGE_STATE);            
        MqDisplayError(NULL, IDS_WRONG_CONFIG_ERROR, 0,
            strParam.Get());
        g_fCancelled = TRUE;
        return;             
    }      
    
    //
    // verify that AD integrated will not be removed 
	// for MSMQ servers (DS or routing server)
    //
    if ((g_SubcomponentMsmq[eADIntegrated].dwOperation == REMOVE) &&
		(g_fServerSetup && (g_dwMachineTypeDs || g_dwMachineTypeFrs)))
    {
		DebugLogMsg(
			eError,
			L"The selection is not valid. Removing Active Directory Integration from a DS or routing server is not supported. TypeDS = %d, TypeFrs = %d", 
			g_dwMachineTypeDs, 
			g_dwMachineTypeFrs
			); 

        strParam.Load(IDS_REMOVE_AD_INTEGRATED);            
        MqDisplayError(NULL, IDS_WRONG_CONFIG_ERROR, 0,
            strParam.Get());
        g_fCancelled = TRUE;
        return;
    }  
	
    //
    // Remove routing is allowed only on workgroup
    //
    if ((g_SubcomponentMsmq[eRoutingSupport].dwOperation == REMOVE)	&& !g_fWorkGroup)
    {
        strParam.Load(IDS_REMOVE_ROUTING_STATE_ERROR);            
        MqDisplayError(NULL, IDS_WRONG_CONFIG_ERROR, 0,
            strParam.Get());
        g_fCancelled = TRUE;
        return;      
    }


    return;
}


//+-------------------------------------------------------------------------
//
//  Function: SetOperationForSubcomponents
//
//  Synopsis: Called when all subcomponents are already selected. Set 
//              operation for each subcomponent
//
//--------------------------------------------------------------------------
void
SetOperationForSubcomponents()
{
    //
    // do it only once at the start. We arrive here in the cleanup phase
    // too, but we have to save initial selection in order to install
    // HTTP support (at clean up phase) if it was selected.    
    //    
    static BOOL s_fBeenHere = FALSE;

    if (s_fBeenHere)
        return;
    DebugLogMsg(eAction, L"Setting Install, Do Nothing, or Remove for each subcomonent");

    s_fBeenHere = TRUE;

    if (g_fUpgrade || (g_fWelcome && Msmq1InstalledOnCluster()))
    {
        SetSubcomponentForUpgrade();
        return;
    }    
    
    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        SetOperationForSubcomponent (i);
    }        
 
    ValidateSelection();
    if (g_fCancelled)
    {
        if (g_fWelcome)
        {
            UnregisterWelcome();
            g_fWrongConfiguration = TRUE;
            for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
            {
                UnregisterSubcomponentForWelcome (i);
            }  
        }        
        DebugLogMsg(eError, L"An incorrect configuration was selected. Setup will not continue.");    
        return;
    }

    SetSetupDefinitions();    
    
    LogSelectedComponents();    
    
    return;
}

//+-------------------------------------------------------------------------
//
//  Function: GetSetupOperationBySubcomponentName
//
//  Synopsis: Return setup operation for the specific subcomponent
//
//--------------------------------------------------------------------------
DWORD GetSetupOperationBySubcomponentName (IN const TCHAR    *SubcomponentId)
{
    if (SubcomponentId == NULL)
    {
        //
        // do nothing
        //
        return DONOTHING;
    }

    for (DWORD i=0; i<g_dwSubcomponentNumber; i++)
    {
        if (_tcsicmp(SubcomponentId, g_SubcomponentMsmq[i].szSubcomponentId) != 0)
        {
            continue;
        }

        return (g_SubcomponentMsmq[i].dwOperation);        
    }
    
    ASSERT(("The subcomponent is not found", 0));
    return DONOTHING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\triggers.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    triggers.cpp

Abstract:

    Handles MSMQ Triggers Setup.

Author:

    Nela Karpel    (NelaK)   20-Aug-2000

Revision History:


--*/

#include "msmqocm.h"
#include <comdef.h>
#include <autorel2.h>
#include "service.h"
#include <mqtg.h> 
#include "comadmin.tlh"
#include "mqnames.h"
#include "ev.h"
#include "dsutils.h"
#include "compl.h"
#include "autohandle.h"

#include "triggers.tmh"


//+-------------------------------------------------------------------------
//
//  Function:   RegisterTriggersDlls
//
//  Synopsis:   Registers or unregisters the mqtrig DLL
//
//--------------------------------------------------------------------------


void
RegisterTriggersDlls(
	const bool fRegister
	)
{
	//
	// Register Triggers Objects DLL
	//
	if ( fRegister )
	{		
        DebugLogMsg(eAction, L"Registering the Triggers COM objects DLL");
	}
	else
	{		
        DebugLogMsg(eAction, L"Unregistering the Triggers COM objects DLL");
	}
    LPWSTR szDllName = MQTRIG_DLL;
    try
    {
        RegisterDll(
            fRegister,
            false,
            MQTRIG_DLL
            );

	        //
	        // Register Cluster Resource DLL only on 
	        // Advanced Server (ADS). Do not unregister.
	        //

	    if ( g_dwOS == MSMQ_OS_NTE && fRegister )
	    {		
            DebugLogMsg(eAction, L"Registering the Triggers cluster resource DLL");
            szDllName = MQTGCLUS_DLL;
            RegisterDll(
                fRegister,
                FALSE,
                MQTGCLUS_DLL
                );
	    }
    }
    catch(bad_win32_error e)
    {
        MqDisplayError(
            NULL, 
            IDS_TRIGREGISTER_ERROR,
            e.error(),
            szDllName
            );
    	throw exception();
    }

}

//+-------------------------------------------------------------------------
//
//  Function:   CreateTriggersKey
//
//  Synopsis:   Creates Triggers subkey
//
//--------------------------------------------------------------------------
void
CreateTriggersKey (
    IN     const TCHAR  * szEntryName,
    IN OUT       HKEY*    phRegKey
	)
{
	DWORD dwDisposition;
    LONG lResult = RegCreateKeyEx(
						REGKEY_TRIGGER_POS,
						szEntryName,
						0,
						NULL,
						REG_OPTION_NON_VOLATILE,
						KEY_ALL_ACCESS,
						NULL,
						phRegKey,
						&dwDisposition
						);

    if (lResult != ERROR_SUCCESS)
	{
		MqDisplayError(NULL, IDS_REGISTRYOPEN_ERROR, lResult, FALCON_REG_POS_DESC, szEntryName);		
		throw exception();
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   SetRegValue
//
//  Synopsis:   Sets registry value under Triggers subkey
//
//--------------------------------------------------------------------------
void
SetTriggersRegValue (
	IN HKEY hKey,
    IN const TCHAR* szValueName,
    IN DWORD dwValueData
	)
{
    LONG lResult = RegSetValueEx( 
						hKey,
						szValueName,
						0,
						REG_DWORD,
						(BYTE *)&dwValueData,
						sizeof(DWORD)
						);

    RegFlushKey(hKey);

	if (lResult != ERROR_SUCCESS)
	{
		MqDisplayError(NULL, IDS_REGISTRYSET_ERROR, lResult, szValueName);
		throw exception();
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateTriggersRegSection
//
//  Synopsis:   Creates registry section with triggers parameters
//
//--------------------------------------------------------------------------
void
CreateTriggersRegSection (
	void
	)
{
	//
	// Write Configuration parametes to registry
	//
	CRegHandle hMainKey;
	CreateTriggersKey( REGKEY_TRIGGER_PARAMETERS, &hMainKey );

	SetTriggersRegValue( hMainKey, CONFIG_PARM_NAME_INITIAL_THREADS, CONFIG_PARM_DFLT_INITIAL_THREADS );
	SetTriggersRegValue( hMainKey, CONFIG_PARM_NAME_MAX_THREADS, CONFIG_PARM_DFLT_MAX_THREADS );
	SetTriggersRegValue( hMainKey, CONFIG_PARM_NAME_INIT_TIMEOUT, CONFIG_PARM_DFLT_INIT_TIMEOUT );
	SetTriggersRegValue( hMainKey, CONFIG_PARM_NAME_DEFAULTMSGBODYSIZE, CONFIG_PARM_DFLT_DEFAULTMSGBODYSIZE );
	
	//
	// Create key for triggers\rules data
	//
	std::wstringstream TriggersRegPath;
	TriggersRegPath << REGKEY_TRIGGER_PARAMETERS << L"\\" << REG_SUBKEY_TRIGGERS;
	CRegHandle hTriggersKey;
	CreateTriggersKey(TriggersRegPath.str().c_str(), &hTriggersKey);

	std::wstringstream RulesRegPath;
	RulesRegPath << REGKEY_TRIGGER_PARAMETERS << L"\\" << REG_SUBKEY_RULES;
	CRegHandle hRulesKey;
	CreateTriggersKey(RulesRegPath.str().c_str(), &hRulesKey);
}


//+-------------------------------------------------------------------------
//
//  Function:   InstallTriggersService
//
//  Synopsis:   Creates MSMQ Triggers service
//
//--------------------------------------------------------------------------
void
InstallTriggersService(
	void
	)
{    
    DebugLogMsg(eAction, L"Installing the Triggers service");

    //
    // Form the dependencies of the service
    //
	CMultiString Dependencies;
	Dependencies.Add(MSMQ_SERVICE_NAME);

    //
    // Form the description of the service
    //
    CResString strDesc(IDS_TRIG_SERVICE_DESCRIPTION);        

	CResString strDisplayName(IDS_MSMQ_TRIGGERS_DESPLAY_NAME);
	BOOL fRes;

	if (g_fUpgrade)
	{
		//
		// You need to be an admin in order to install COM+ applications, but COM+
		// installation cannot be done in upgrade, therefore installation of triggers service 
		// in upgrade is as local system.
		//	
	    fRes = InstallService(
                    strDisplayName.Get(),
                    TRIG_SERVICE_PATH,
                    Dependencies.Data(),
                    TRIG_SERVICE_NAME,
                    strDesc.Get(),
                    NULL
                    );

		//
		// Set the registry key indicating that the triggers service should change its own permissions
		//
		CRegHandle hKey;
		CreateTriggersKey( REGKEY_TRIGGER_PARAMETERS, &hKey);
		
		SetTriggersRegValue( hKey, CONFIG_PARM_NAME_CHANGE_TO_NETWORK_SERVICE, CONFIG_PARM_CHANGE_TO_NETWORK_SERVICE );
	}
	else
	{
		//
		// Fresh install - triggers service will be installed as network service.
		//
		fRes = InstallService(
                    strDisplayName.Get(),
                    TRIG_SERVICE_PATH,
                    Dependencies.Data(),
                    TRIG_SERVICE_NAME,
                    strDesc.Get(),
                    L"NT AUTHORITY\\NetworkService"
                    );
	}

    if ( !fRes )
	{
		throw exception();   
	}
}


//+-------------------------------------------------------------------------
//
//  Function: MQTrigServiceSetup
//
//  Synopsis: MSMQ Triggers Service Setup: install it and if needed to run it
//
//  Returns:  BOOL depending on success.
//
//--------------------------------------------------------------------------
void
MSMQTriggersServiceSetup()
{
    //
    // do not install triggers on dependent client
    //
    ASSERT(("Unable to install Message Queuing Triggers Service on Dependent Client", 
        !g_fDependentClient));

    InstallTriggersService();

    if (g_fUpgrade)
	{
        return;
    }
        
    if (!RunService(TRIG_SERVICE_NAME))
    {
		throw exception();
    }

    if (!WaitForServiceToStart(TRIG_SERVICE_NAME))
    {
		throw exception();
    }


}


//+-------------------------------------------------------------------------
//
//  Function:   DeleteTriggersRegSection
//
//  Synopsis:   Deletes registry section with triggers parameters
//
//--------------------------------------------------------------------------
VOID
DeleteTriggersRegSection (
	void
	)
{
	RegDeleteKeyWithSubkeys(HKEY_LOCAL_MACHINE, REGKEY_TRIGGER_PARAMETERS);
}


//+-------------------------------------------------------------------------
//
//  Function:   TriggersInstalled
//
//  Synopsis:   Check installation of triggers, either Resource Kit triggers 
//              or MSMQ 3.0 triggers.
//
//--------------------------------------------------------------------------
bool 
TriggersInstalled(
    bool * pfMsmq3TriggersInstalled
    )
{
    DebugLogMsg(eAction, L"Opening the Triggers service to query its configuration");
    CServiceHandle hService(OpenService(g_hServiceCtrlMgr, TRIG_SERVICE_NAME, SERVICE_QUERY_CONFIG));
    if (hService == NULL)
    {
        DWORD rc = GetLastError();
        DebugLogMsg(eWarning, L"The Triggers service could not be opened (last error: %d). Setup will assume that it does not exist.", rc);
        ASSERT(rc == ERROR_SERVICE_DOES_NOT_EXIST);
        return false;
    }

    DebugLogMsg(eAction, L"Querying the configuration of the Triggers service");
    BYTE ConfigData[4096];
    QUERY_SERVICE_CONFIG * pConfigData = reinterpret_cast<QUERY_SERVICE_CONFIG*>(ConfigData);
    DWORD BytesNeeded;
    BOOL rc = QueryServiceConfig(hService, pConfigData, sizeof(ConfigData), &BytesNeeded);
    DebugLogMsg(eInfo, L"QueryServiceConfig() returned %d.", rc);
    ASSERT(("Query triggers service configuration must succeed at this point", rc));

    if (wcsstr(pConfigData->lpBinaryPathName, TRIG_SERVICE_PATH) != NULL)
    {
        DebugLogMsg(eInfo, L"The Triggers service binary file is the MSMQ 3.0 Triggers binary.");
        if (pfMsmq3TriggersInstalled != NULL)
        {
            (*pfMsmq3TriggersInstalled) = true;
        }
        return true;
    }

    DebugLogMsg(eInfo, L"The Triggers service binary file is not the MSMQ 3.0 Triggers binary.");
    if (pfMsmq3TriggersInstalled != NULL)
    {
        (*pfMsmq3TriggersInstalled) = false;
    }
    return true;
}


//+-------------------------------------------------------------------------
//
//  Function:   UpgradeResourceKitTriggersRegistry
//
//  Synopsis:   Upgrade Resource Kit triggers database in registry
//
//--------------------------------------------------------------------------
static
void
UpgradeResourceKitTriggersRegistry(
    void
    )
{
	std::wstringstream TriggersListKey;
    TriggersListKey <<REGKEY_TRIGGER_PARAMETERS <<L"\\" <<REG_SUBKEY_TRIGGERS;
    DebugLogMsg(eAction, L"Opening the %s registry key for enumeration", TriggersListKey.str().c_str());

    LONG rc;
    CAutoCloseRegHandle hKey;
    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TriggersListKey.str().c_str(), 0, KEY_ENUMERATE_SUB_KEYS, &hKey);
    if (rc != ERROR_SUCCESS)
    {
        MqDisplayError(NULL, IDS_REGISTRYOPEN_ERROR, rc, FALCON_REG_POS_DESC, TriggersListKey);
        throw exception();
    }

    DebugLogMsg(eAction, L"Enumerating the Triggers definition registry keys");
    for (DWORD ix = 0; ; ++ix)
    {
        WCHAR SubkeyName[255];
        DWORD SubkeyNameLength = TABLE_SIZE(SubkeyName);
        rc = RegEnumKeyEx(hKey, ix, SubkeyName, &SubkeyNameLength, NULL, NULL, NULL, NULL);
        if (rc != ERROR_SUCCESS && rc != ERROR_MORE_DATA)
        {
            DebugLogMsg(eWarning, L"The subkeys could not be enumerated (error: %d). Setup will assume that there are no more subkeys to enumerate.", rc);
            return;
        }

        std::wstring TriggerDefinitionKey = TriggersListKey.str() + SubkeyName;
        DebugLogMsg(eAction, L"Opening the %s registry key to set a value", TriggerDefinitionKey.c_str());
        CAutoCloseRegHandle hKey1;
        rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TriggerDefinitionKey.c_str(), 0, KEY_SET_VALUE, &hKey1);
        if (rc != ERROR_SUCCESS)
        {
            MqDisplayError(NULL, IDS_REGISTRYSET_ERROR, rc, TriggerDefinitionKey.c_str());
            throw exception();
        }

        DebugLogMsg(eAction, L"Setting the MsgProcessingType registry value to 0");
        DWORD Zero = 0;
        rc = RegSetValueEx(hKey1, REGISTRY_TRIGGER_MSG_PROCESSING_TYPE, 0, REG_DWORD, reinterpret_cast<BYTE*>(&Zero), sizeof(DWORD));
        DebugLogMsg(eInfo, L"RegSetValueEx() for %s returned %d.", REGISTRY_TRIGGER_MSG_PROCESSING_TYPE, rc );
        ASSERT(("Setting registry value must succeed here", rc == ERROR_SUCCESS));
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   RemoveResourceKitTriggersProgramFiles
//
//  Synopsis:   Remove the program files of Resource Kit triggers
//
//--------------------------------------------------------------------------
static
void
RemoveResourceKitTriggersProgramFiles(
    void
    )
{
    DebugLogMsg(eAction, L"Querying the registry for the path to the Program Files folder");
    CAutoCloseRegHandle hKey;
    LONG rc;
    rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion", 0, KEY_QUERY_VALUE, &hKey);
    if (rc != ERROR_SUCCESS)
    {
        DebugLogMsg(eWarning, L"The path to the Program Files could not be obtained (error: %d). Setup will proceed with the upgrade anyway.", rc);
        return;
    }

    WCHAR buffer[MAX_PATH];
    DWORD cbBuffer = sizeof(buffer);
    rc = RegQueryValueEx(hKey, L"ProgramFilesDir", NULL, NULL, reinterpret_cast<BYTE*>(buffer), &cbBuffer);
    if (rc != ERROR_SUCCESS)
    {
        DebugLogMsg(eWarning, L"Querying the ProgramFilesDir registry value failed (error: %d), Setup will proceed with the upgrade anyway.", rc);
        return;
    }

	std::wstringstream Path;
	Path <<buffer << L"\\MSMQ Triggers";
    DeleteFilesFromDirectoryAndRd(Path.str());
}


//+-------------------------------------------------------------------------
//
//  Function:   RemoveResourceKitTriggersFromAddRemovePrograms
//
//  Synopsis:   Unregister Resource Kit triggers from ARP control panel applet
//
//--------------------------------------------------------------------------
static
void
RemoveResourceKitTriggersFromAddRemovePrograms(
    void
    )
{
    DebugLogMsg(eAction, L"Removing Resource Kit Triggers from the Add/Remove Programs Control Panel applet");

    LONG rc;
    rc = RegDeleteKey(
             HKEY_LOCAL_MACHINE, 
             L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Management\\ARPCache\\MSMQ Triggers"
             );
    if (rc != ERROR_SUCCESS)
    {
		DebugLogMsg(eWarning, L"The ARPCache\\MSMQ Triggers registry key could not be deleted (error: %d). Setup will proceed anyway.", rc);
    }

    rc = RegDeleteKey(
             HKEY_LOCAL_MACHINE, 
             L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\MSMQ Triggers"
             );
    if (rc != ERROR_SUCCESS)
    {
        DebugLogMsg(eWarning, L"The Uninstall\\MSMQ Triggers registry key could not be deleted (error: %d). Setup will proceed anyway.", rc);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   UpgradeResourceKitTriggers
//
//  Synopsis:   Upgrade Resource Kit triggers:
//              Unregister reskit triggers DLLs,
//              Upgrade reskit triggers database in registry,
//              Remove reskit triggers service,
//              Remove reskit triggers program file,
//              Remove reskit triggers from Add/Remove Programs.
//              MSMQ 3.0 triggers DLLs and service are registered afterwards by caller.
//
//--------------------------------------------------------------------------
static
void 
UpgradeResourceKitTriggers( 
    void
    )
{
    DebugLogMsg(eAction, L"Stopping the Resource Kit Triggers service");
    if (!StopService(TRIG_SERVICE_NAME))
    {
        DebugLogMsg(eError, L"The attempt to stop the Resource Kit Triggers service failed.");
        throw exception();
    }

    DebugLogMsg(eInfo, L"The Resource Kit Triggers service is stopped. Setup will unregister the Resource Kit Triggers DLLs.");
    try
    {
        RegisterDll(FALSE, FALSE, L"TRIGOBJS.DLL");
        DebugLogMsg(eInfo, L" The Resource Kit Triggers COM objects were unregistered successfully.");
        RegisterDll(FALSE, FALSE, L"TRIGSNAP.DLL");
        DebugLogMsg(eInfo, L"The Resource Kit Triggers snap-in was unregistered successfully.");
    }
    catch(bad_win32_error e)
    {
        DebugLogMsg(eWarning, L"The Resource Kit Triggers DLLs could not be unregistered. Setup will proceed with the upgrade anyway.");
    }

    DebugLogMsg(eAction, L"Upgrading the Resource Kit Triggers database in the registry");
    UpgradeResourceKitTriggersRegistry();

    RemoveResourceKitTriggersProgramFiles();

    RemoveResourceKitTriggersFromAddRemovePrograms();
}


//+-------------------------------------------------------------------------
//
//  Function:   InstallMSMQTriggers
//
//  Synopsis:   Main installation routine
//
//--------------------------------------------------------------------------
BOOL
InstallMSMQTriggers (
	void
	)
{
    TickProgressBar(IDS_PROGRESS_INSTALL_TRIGGERS);

	//
	// Initialize COM for use of COM+ APIs.
	// Done in this context to match the place of com errors catching.
	//
	try
	{
        if (g_fUpgrade)
        { 
            bool fMsmq3TriggersInstalled;
            bool rc = TriggersInstalled(&fMsmq3TriggersInstalled);
	        DBG_USED(rc);
		    ASSERT(("OS upgrade, triggers must be installed at this point", rc));

            if (fMsmq3TriggersInstalled)
            {
                DebugLogMsg(eInfo, L"The MSMQ 3.0 Triggers service is installed. Setup will only re-register the DLLs.");
                RegisterTriggersDlls(TRUE);
                return TRUE;
            }
          
            //
            // Handle unregisteration and upgrade of Resource Kit triggres and fall thru
            //
            UpgradeResourceKitTriggers();
        }

        CreateTriggersRegSection();
	
		RegisterTriggersDlls(TRUE);

		if (!g_fUpgrade)
		{
			DebugLogMsg(eAction, L"Checking if COM+ registration is needed");
			HRESULT hr = RegisterComponentInComPlusIfNeeded(FALSE);
			if (FAILED(hr))
			{
				DebugLogMsg(eError, L"The attempt to register Triggers in COM+ failed.");
				MqDisplayError(NULL, IDS_COMPLUS_REGISTER_ERROR, hr);
				throw exception();
			}
		}

		MSMQTriggersServiceSetup();
		return TRUE;
	}
	catch(const _com_error&)
	{	
	}

	//
	// Fall through.
	//
	catch(const exception&)
	{
	}

	RemoveService(TRIG_SERVICE_NAME);
	RegisterTriggersDlls(FALSE);
	DeleteTriggersRegSection();
	UnregisterComponentInComPlus();
	CoUninitialize();
	return FALSE;
}


//+-------------------------------------------------------------------------
//
//  Function:   UnInstallMSMQTriggers
//
//  Synopsis:   Main installation routine
//
//--------------------------------------------------------------------------
BOOL
UnInstallMSMQTriggers (
	void
	)
{
    TickProgressBar(IDS_PROGRESS_REMOVE_TRIGGERS);

	if (!RemoveService(TRIG_SERVICE_NAME))
    {
        return FALSE;
    }

	CoInitialize(NULL);

	RegisterTriggersDlls(FALSE);

	DeleteTriggersRegSection();

	HRESULT hr = UnregisterComponentInComPlus();
	if (FAILED(hr))
	{
		MqDisplayError(NULL, IDS_COMPLUS_UNREGISTER_ERROR, hr);
	}

	CoUninitialize(); 

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\upgclus.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    upgclus.h

Abstract:

    Header for upgrade of MSMQ cluster resource from NT 4 and Win2000 Beta3

Author:

    Shai Kariv  (shaik)  26-May-1999

Revision History:


--*/

#ifndef _MSMQOCM_UPGCLUS_H_
#define _MSMQOCM_UPGCLUS_H_


#include <clusapi.h>
#include <resapi.h>
#include <autorel3.h>


typedef HCLUSTER   (WINAPI *OpenCluster_ROUTINE)               (LPCWSTR);
typedef BOOL       (WINAPI *CloseCluster_ROUTINE)              (HCLUSTER);
typedef HCLUSENUM  (WINAPI *ClusterOpenEnum_ROUTINE)           (HCLUSTER, DWORD);
typedef DWORD      (WINAPI *ClusterEnum_ROUTINE)               (HCLUSENUM, DWORD, LPDWORD, LPWSTR, LPDWORD);
typedef DWORD      (WINAPI *ClusterCloseEnum_ROUTINE)          (HCLUSENUM);
typedef BOOL       (WINAPI *CloseClusterResource_ROUTINE)      (HRESOURCE);
typedef BOOL       (WINAPI *CloseClusterGroup_ROUTINE)         (HGROUP);
typedef HRESOURCE  (WINAPI *OpenClusterResource_ROUTINE)       (HCLUSTER, LPCWSTR);
typedef DWORD      (WINAPI *ClusterGroupEnum_ROUTINE)          (HGROUPENUM, DWORD, LPDWORD, LPWSTR, LPDWORD);
typedef HGROUPENUM (WINAPI *ClusterGroupOpenEnum_ROUTINE)      (HGROUP, DWORD);
typedef DWORD      (WINAPI *ClusterGroupCloseEnum_ROUTINE)     (HGROUPENUM);     
typedef HGROUP     (WINAPI *OpenClusterGroup_ROUTINE)          (HCLUSTER, LPCWSTR);
typedef DWORD      (WINAPI *CreateClusterResourceType_ROUTINE) (HCLUSTER, LPCWSTR, LPCWSTR, LPCWSTR, DWORD, DWORD);
typedef HRESOURCE  (WINAPI *CreateClusterResource_ROUTINE)     (HGROUP, LPCWSTR, LPCWSTR, DWORD);
typedef DWORD      (WINAPI *OnlineClusterResource_ROUTINE)     (HRESOURCE);
typedef DWORD      (WINAPI *DeleteClusterResource_ROUTINE)     (HRESOURCE);
typedef DWORD      (WINAPI *OfflineClusterResource_ROUTINE)    (HRESOURCE);
typedef DWORD      (WINAPI *DeleteClusterResourceType_ROUTINE) (HCLUSTER, LPCWSTR);
typedef HRESENUM   (WINAPI *ClusterResourceOpenEnum_ROUTINE)   (HRESOURCE, DWORD);
typedef DWORD      (WINAPI *ClusterResourceEnum_ROUTINE)       (HRESENUM, DWORD, LPDWORD, LPWSTR, LPDWORD);
typedef DWORD      (WINAPI *ClusterResourceCloseEnum_ROUTINE)  (HRESENUM);
typedef DWORD      (WINAPI *AddClusterResourceDependency_ROUTINE)    (HRESOURCE, HRESOURCE);
typedef DWORD      (WINAPI *RemoveClusterResourceDependency_ROUTINE) (HRESOURCE, HRESOURCE);
typedef DWORD      (WINAPI *ClusterResourceControl_ROUTINE)    (HRESOURCE, HNODE, DWORD, LPVOID, DWORD, 
                                                                LPVOID, DWORD, LPDWORD);


OpenCluster_ROUTINE               pfOpenCluster               = NULL;
CloseCluster_ROUTINE              pfCloseCluster              = NULL;
ClusterOpenEnum_ROUTINE           pfClusterOpenEnum           = NULL;
ClusterEnum_ROUTINE               pfClusterEnum               = NULL;
ClusterCloseEnum_ROUTINE          pfClusterCloseEnum          = NULL;
CloseClusterResource_ROUTINE      pfCloseClusterResource      = NULL;
CloseClusterGroup_ROUTINE         pfCloseClusterGroup         = NULL;
ClusterResourceControl_ROUTINE    pfClusterResourceControl    = NULL;
OpenClusterResource_ROUTINE       pfOpenClusterResource       = NULL;
ClusterGroupEnum_ROUTINE          pfClusterGroupEnum          = NULL;
ClusterGroupOpenEnum_ROUTINE      pfClusterGroupOpenEnum      = NULL;
ClusterGroupCloseEnum_ROUTINE     pfClusterGroupCloseEnum     = NULL;
OpenClusterGroup_ROUTINE          pfOpenClusterGroup          = NULL;
CreateClusterResourceType_ROUTINE pfCreateClusterResourceType = NULL;
CreateClusterResource_ROUTINE     pfCreateClusterResource     = NULL;
OnlineClusterResource_ROUTINE     pfOnlineClusterResource     = NULL;
DeleteClusterResource_ROUTINE     pfDeleteClusterResource     = NULL;
OfflineClusterResource_ROUTINE    pfOfflineClusterResource    = NULL;
DeleteClusterResourceType_ROUTINE pfDeleteClusterResourceType = NULL;
ClusterResourceOpenEnum_ROUTINE   pfClusterResourceOpenEnum   = NULL;
ClusterResourceEnum_ROUTINE       pfClusterResourceEnum       = NULL;
ClusterResourceCloseEnum_ROUTINE  pfClusterResourceCloseEnum  = NULL;
AddClusterResourceDependency_ROUTINE    pfAddClusterResourceDependency    = NULL;
RemoveClusterResourceDependency_ROUTINE pfRemoveClusterResourceDependency = NULL;


HCLUSTER
WINAPI
OpenCluster(
    IN LPCWSTR lpszClusterName
    )
{
    ASSERT(("pointer to OpenCluster not initialized!", pfOpenCluster != NULL));
    return pfOpenCluster(lpszClusterName);

} //OpenCluster


BOOL
WINAPI
CloseCluster(
    IN HCLUSTER hCluster
    )
{
    ASSERT(("pointer to CloseCluster not initialized!", pfCloseCluster != NULL));
    return pfCloseCluster(hCluster);

} //CloseCluster


HCLUSENUM
WINAPI
ClusterOpenEnum(
    IN HCLUSTER hCluster,
    IN DWORD dwType
    )
{
    ASSERT(("pointer to ClusterOpenEnum not initialized!", pfClusterOpenEnum != NULL));
    return pfClusterOpenEnum(hCluster, dwType);

} //ClusterOpenEnum


DWORD
WINAPI
ClusterEnum(
    IN HCLUSENUM hEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )
{
    ASSERT(("pointer to ClusterEnum not initialized!", pfClusterEnum != NULL));
    return pfClusterEnum(hEnum, dwIndex, lpdwType, lpszName, lpcchName);

} //ClusterEnum


DWORD
WINAPI
ClusterCloseEnum(
    IN HCLUSENUM hEnum
    )
{
    ASSERT(("pointer to ClusterCloseEnum not initialized!", pfClusterCloseEnum != NULL));
    return pfClusterCloseEnum(hEnum);

} //ClusterCloseEnum


BOOL
WINAPI
CloseClusterResource(
    IN HRESOURCE hResource
    )
{
    ASSERT(("pointer to CloseClusterResource not initialized!", pfCloseClusterResource != NULL));
    return pfCloseClusterResource(hResource);

} //CloseClusterResource


BOOL
WINAPI
CloseClusterGroup(
    IN HGROUP hGroup
    )
{
    ASSERT(("pointer to CloseClusterGroup not initialized!", pfCloseClusterGroup != NULL));
    return pfCloseClusterGroup(hGroup);

} //CloseClusterGroup


DWORD
WINAPI
ClusterResourceControl(
    IN HRESOURCE hResource,
    IN OPTIONAL HNODE hHostNode,
    IN DWORD dwControlCode,
    IN LPVOID lpInBuffer,
    IN DWORD cbInBufferSize,
    OUT LPVOID lpOutBuffer,
    IN DWORD cbOutBufferSize,
    OUT LPDWORD lpcbBytesReturned
    )
{
    ASSERT(("pointer to ClusterResourceControl not initialized!", pfClusterResourceControl != NULL));
    return pfClusterResourceControl(hResource, hHostNode, dwControlCode, lpInBuffer, cbInBufferSize,
                                    lpOutBuffer, cbOutBufferSize, lpcbBytesReturned);
} //ClusterResourceControl


HRESOURCE
WINAPI
OpenClusterResource(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceName
    )
{
    ASSERT(("pointer to OpenClusterResource not initialized!", pfOpenClusterResource != NULL));
    return pfOpenClusterResource(hCluster, lpszResourceName);

} //OpenClusterResource


DWORD
WINAPI
ClusterGroupEnum(
    IN HGROUPENUM hGroupEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszResourceName,
    IN OUT LPDWORD lpcchName
    )
{
    ASSERT(("pointer to ClusterGroupEnum not initialized!", pfClusterGroupEnum != NULL));
    return pfClusterGroupEnum(hGroupEnum, dwIndex, lpdwType, lpszResourceName, lpcchName);

} //ClusterGroupEnum


HGROUPENUM
WINAPI
ClusterGroupOpenEnum(
    IN HGROUP hGroup,
    IN DWORD dwType
    )
{
    ASSERT(("pointer to ClusterGroupOpenEnum not initialized!", pfClusterGroupOpenEnum != NULL));
    return pfClusterGroupOpenEnum(hGroup, dwType);

} //ClusterGroupOpenEnum


DWORD
WINAPI
ClusterGroupCloseEnum(
    IN HGROUPENUM hGroupEnum
    )
{
    ASSERT(("pointer to ClusterGroupCloseEnum not initialized!", pfClusterGroupCloseEnum != NULL));
    return pfClusterGroupCloseEnum(hGroupEnum);

} //ClusterGroupCloseEnum


HGROUP
WINAPI
OpenClusterGroup(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszGroupName
    )
{
    ASSERT(("pointer to OpenClusterGroup not initialized!", pfOpenClusterGroup != NULL));
    return pfOpenClusterGroup(hCluster, lpszGroupName);

} //OpenClusterGroup


DWORD
WINAPI
CreateClusterResourceType(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName,
    IN LPCWSTR lpszDisplayName,
    IN LPCWSTR lpszResourceTypeDll,
    IN DWORD dwLooksAlivePollInterval,
    IN DWORD dwIsAlivePollInterval
    )
{
    ASSERT(("pointer to CreateClusterResourceType not initialized!", pfCreateClusterResourceType != NULL));
    return pfCreateClusterResourceType(hCluster, lpszResourceTypeName, lpszDisplayName, lpszResourceTypeDll,
                                       dwLooksAlivePollInterval, dwIsAlivePollInterval);
} //CreateClusterResourceType


HRESOURCE
WINAPI
CreateClusterResource(
    IN HGROUP hGroup,
    IN LPCWSTR lpszResourceName,
    IN LPCWSTR lpszResourceType,
    IN DWORD dwFlags
    )
{
    ASSERT(("pointer to CreateClusterResource not initialized!", pfCreateClusterResource != NULL));
    return pfCreateClusterResource(hGroup, lpszResourceName, lpszResourceType, dwFlags);

} //CreateClusterResource


DWORD
WINAPI
OnlineClusterResource(
    IN HRESOURCE hResource
    )
{
    ASSERT(("pointer to OnlineClusterResource not initialized!", pfOnlineClusterResource != NULL));
    return pfOnlineClusterResource(hResource);

} //OnlineClusterResource


DWORD
WINAPI
DeleteClusterResource(
    IN HRESOURCE hResource
    )
{
    ASSERT(("pointer to DeleteClusterResource not initialized!", pfDeleteClusterResource != NULL));
    return pfDeleteClusterResource(hResource);

} //DeleteClusterResource


DWORD
WINAPI
OfflineClusterResource(
    IN HRESOURCE hResource
    )
{
    ASSERT(("pointer to OfflineClusterResource not initialized!", pfOfflineClusterResource != NULL));
    return pfOfflineClusterResource(hResource);

} //OfflineClusterResource


DWORD
WINAPI
DeleteClusterResourceType(
    IN HCLUSTER hCluster,
    IN LPCWSTR lpszResourceTypeName
    )
{
    ASSERT(("pointer to DeleteClusterResourceType not initialized!", pfDeleteClusterResourceType != NULL));
    return pfDeleteClusterResourceType(hCluster, lpszResourceTypeName);

} //DeleteClusterResourceType


HRESENUM
WINAPI
ClusterResourceOpenEnum(
    IN HRESOURCE hResource,
    IN DWORD dwType
    )
{
    ASSERT(("pointer to ClusterResourceOpenEnum not initialized!", pfClusterResourceOpenEnum != NULL));
    return pfClusterResourceOpenEnum(hResource, dwType);

} //ClusterResourceOpenEnum

DWORD
WINAPI
ClusterResourceEnum(
    IN HRESENUM hResEnum,
    IN DWORD dwIndex,
    OUT LPDWORD lpdwType,
    OUT LPWSTR lpszName,
    IN OUT LPDWORD lpcchName
    )
{
    ASSERT(("pointer to ClusterResourceEnum not initialized!", pfClusterResourceEnum != NULL));
    return pfClusterResourceEnum(hResEnum, dwIndex, lpdwType, lpszName, lpcchName);

} //ClusterResourceEnum

DWORD
WINAPI
ClusterResourceCloseEnum(
    IN HRESENUM hResEnum
    )
{
    ASSERT(("pointer to ClusterResourceCloseEnum not initialized!", pfClusterResourceCloseEnum != NULL));
    return pfClusterResourceCloseEnum(hResEnum);

} //ClusterResourceCloseEnum


DWORD
WINAPI
AddClusterResourceDependency(
    IN HRESOURCE hResource,
    IN HRESOURCE hDependsOn
    )
{
    ASSERT(("pointer to AddClusterResourceDependency not initialized!", pfAddClusterResourceDependency != NULL));
    return pfAddClusterResourceDependency(hResource, hDependsOn);

} //AddClusterResourceDependency

DWORD
WINAPI
RemoveClusterResourceDependency(
    IN HRESOURCE hResource,
    IN HRESOURCE hDependsOn
    )
{
    ASSERT(("pointer to RemoveClusterResourceDependency not initialized!", pfRemoveClusterResourceDependency != NULL));
    return pfRemoveClusterResourceDependency(hResource, hDependsOn);

} //RemoveClusterResourceDependency


//
// From comerror.cpp
//
int 
vsDisplayMessage(
    IN const HWND    hdlg,
    IN const UINT    uButtons,
    IN const UINT    uTitleID,
    IN const UINT    uErrorID,
    IN const DWORD   dwErrorCode,
    IN const va_list argList
    );

#endif //_MSMQOCM_UPGCLUS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\upgclus.cpp ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    upgclus.cpp

Abstract:

    Handle upgrade of MSMQ cluster resource from NT 4 and Win2000 Beta3

Author:

    Shai Kariv  (shaik)  26-May-1999

Revision History:


--*/

#include "msmqocm.h"
#include "ocmres.h"
#include "upgclus.h"
#include "strsafe.h"
#include "upgclus.tmh"

using namespace std;

class CClusterUpgradeException
{
};

bool g_fStrongCryptoKeyCreated = false;

#pragma warning(disable: 4702) //C4702: unreachable code

static
VOID
DisplayMessage(
    UINT  title, 
    UINT  msg,
    ...
    )
/*++

Routine Description:

    Display information message to user while upgrading msmq cluster resources.

Arguments:

    title - ID of title string for the message.

    msg - ID of body string for the message.

Return Value:

    None.

--*/
{
    va_list args;
    va_start(args, msg);

    vsDisplayMessage(NULL,  MB_OK | MB_TASKMODAL, title, msg, 0, args);

    va_end(args);

} //DisplayMessage


VOID
LoadClusapiDll(
    HINSTANCE * phClusapiDll
    )
/*++

Routine Description:

    Load clusapi.dll and get addresses of common cluster APIs

Arguments:

    phClusapiDll - points to clusapi.dll handle, on output.

Return Value:

    None.

--*/
{
    if (FAILED(StpLoadDll(L"clusapi.dll", phClusapiDll)))
    {
        throw CClusterUpgradeException();
    }

    pfOpenCluster      = (OpenCluster_ROUTINE)GetProcAddress(*phClusapiDll, "OpenCluster");
    ASSERT(pfOpenCluster != NULL);

    pfCloseCluster     = (CloseCluster_ROUTINE)GetProcAddress(*phClusapiDll, "CloseCluster");
    ASSERT(pfCloseCluster != NULL);

    pfClusterOpenEnum  = (ClusterOpenEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterOpenEnum");
    ASSERT(pfClusterOpenEnum != NULL);

    pfClusterEnum      = (ClusterEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterEnum");
    ASSERT(pfClusterEnum != NULL);

    pfClusterCloseEnum = (ClusterCloseEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterCloseEnum");
    ASSERT(pfClusterCloseEnum != NULL);

    pfCloseClusterResource = (CloseClusterResource_ROUTINE)GetProcAddress(*phClusapiDll, "CloseClusterResource");
    ASSERT(pfCloseClusterResource != NULL);

    pfCloseClusterGroup = (CloseClusterGroup_ROUTINE)GetProcAddress(*phClusapiDll, "CloseClusterGroup");
    ASSERT(pfCloseClusterGroup != NULL);

    pfClusterResourceControl = (ClusterResourceControl_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterResourceControl");
    ASSERT(pfClusterResourceControl != NULL);

    pfOpenClusterResource = (OpenClusterResource_ROUTINE)GetProcAddress(*phClusapiDll, "OpenClusterResource");
    ASSERT(pfOpenClusterResource != NULL);

    pfClusterGroupEnum = (ClusterGroupEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterGroupEnum");
    ASSERT(pfClusterGroupEnum != NULL);

    pfClusterGroupOpenEnum = (ClusterGroupOpenEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterGroupOpenEnum");
    ASSERT(pfClusterGroupOpenEnum != NULL);

    pfClusterGroupCloseEnum = (ClusterGroupCloseEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterGroupCloseEnum");
    ASSERT(pfClusterGroupCloseEnum != NULL);

    pfOpenClusterGroup = (OpenClusterGroup_ROUTINE)GetProcAddress(*phClusapiDll, "OpenClusterGroup");
    ASSERT(pfOpenClusterGroup != NULL);

    pfCreateClusterResourceType = (CreateClusterResourceType_ROUTINE)GetProcAddress(*phClusapiDll, "CreateClusterResourceType");
    ASSERT(pfCreateClusterResourceType != NULL);

    pfCreateClusterResource = (CreateClusterResource_ROUTINE)GetProcAddress(*phClusapiDll, "CreateClusterResource");
    ASSERT(pfCreateClusterResource != NULL);

    pfOnlineClusterResource = (OnlineClusterResource_ROUTINE)GetProcAddress(*phClusapiDll, "OnlineClusterResource");
    ASSERT(pfOnlineClusterResource != NULL);

    pfDeleteClusterResource = (DeleteClusterResource_ROUTINE)GetProcAddress(*phClusapiDll, "DeleteClusterResource");
    ASSERT(pfDeleteClusterResource != NULL);

    pfOfflineClusterResource = (OfflineClusterResource_ROUTINE)GetProcAddress(*phClusapiDll, "OfflineClusterResource");
    ASSERT(pfOfflineClusterResource != NULL);

    pfDeleteClusterResourceType = (DeleteClusterResourceType_ROUTINE)GetProcAddress(*phClusapiDll, "DeleteClusterResourceType");
    ASSERT(pfDeleteClusterResourceType != NULL);

    pfClusterResourceOpenEnum = (ClusterResourceOpenEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterResourceOpenEnum");
    ASSERT(pfClusterResourceOpenEnum != NULL);

    pfClusterResourceEnum = (ClusterResourceEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterResourceEnum");
    ASSERT(pfClusterResourceEnum != NULL);

    pfAddClusterResourceDependency = (AddClusterResourceDependency_ROUTINE)GetProcAddress(*phClusapiDll, "AddClusterResourceDependency");
    ASSERT(pfAddClusterResourceDependency != NULL);

    pfRemoveClusterResourceDependency = (RemoveClusterResourceDependency_ROUTINE)GetProcAddress(*phClusapiDll, "RemoveClusterResourceDependency");
    ASSERT(pfRemoveClusterResourceDependency != NULL);

    pfClusterResourceCloseEnum = (ClusterResourceCloseEnum_ROUTINE)GetProcAddress(*phClusapiDll, "ClusterResourceCloseEnum");
    ASSERT(pfClusterResourceCloseEnum != NULL);
} //LoadClusapiDll


HCLUSTER
OpenClusterWithRetry(
    VOID
    )
/*++

Routine Description:

    Wrapper for OpenCluster.
    Retry until success or user aborts.

Arguments:

    None.

Return Value:

    HCLUSTER as returned by OpenCluster.

--*/
{
    for (;;)
    {
        HCLUSTER hCluster = OpenCluster(NULL);
        if (hCluster != NULL)
        {
            return hCluster;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_OpenCluster_ERR, GetLastError()))
        {
            throw CClusterUpgradeException();
        }
    }

    return NULL; // never reached

} //OpenClusterWithRetry


HGROUP
OpenClusterGroupWithRetry(
    HCLUSTER hCluster,
    LPCWSTR  pwzGroupName
    )
/*++

Routine Description:

    Wrapper for OpenClusterGroupWithRetry.
    Retry until success or user aborts.

Arguments:

    hCluster - Handle to cluster.

    pwzGroupName - The name of the group to open.

Return Value:

    HGROUP as returned by OpenClusterGroup.

--*/
{
    for (;;)
    {
        HGROUP hGroup = OpenClusterGroup(hCluster, pwzGroupName);
        if (hGroup != NULL)
        {
            return hGroup;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_OpenClusterGroup_ERR, GetLastError(), pwzGroupName))
        {
            throw CClusterUpgradeException();
        }
    }

    return NULL; // never reached

} //OpenClusterGroupWithRetry


HRESOURCE
OpenClusterResourceWithRetry(
    HCLUSTER hCluster,
    LPCWSTR  pwzResourceName
    )
/*++

Routine Description:

    Wrapper for OpenClusterResource.
    Retry until success or user aborts.

Arguments:

    hCluster - Handle to cluster.

    pwzResourceName - Name of resource to open.

Return Value:

    HRESOURCE as returned by OpenClusterResource.

--*/
{
	DebugLogMsg(eAction, L"Opening the %ls cluster resource", pwzResourceName);
    for (;;)
    {
        HRESOURCE hResource = OpenClusterResource(hCluster, pwzResourceName);
        if (hResource != NULL)
        {
            return hResource;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_OpenClusterResource_ERR, GetLastError(), pwzResourceName))
        {
            throw CClusterUpgradeException();
        }
    }

    return NULL; // never reached

} //OpenClusterResourceWithRetry


HCLUSENUM
ClusterOpenEnumWithRetry(
    HCLUSTER hCluster,
    DWORD    dwType
    )
/*++

Routine Description:

    Wrapper for ClusterOpenEnum.
    Retry until success or user aborts.

Arguments:

    hCluster - Handle to cluster.

    dwType   - Type of objects to be enumerated.

Return Value:

    HCLUSENUM as returned by ClusterOpenEnum.

--*/
{
    for (;;)
    {
        HCLUSENUM hClusEnum = ClusterOpenEnum(hCluster, dwType);
        if (hClusEnum != NULL)
        {
            return hClusEnum;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_Enumerate_ERR, GetLastError()))
        {
            throw CClusterUpgradeException();
        }
    }

    return NULL; // never reached

} //ClusterOpenEnumWithRetry


HGROUPENUM
ClusterGroupOpenEnumWithRetry(
    LPCWSTR pwzGroupName,
    HGROUP  hGroup,
    DWORD   dwType
    )
/*++

Routine Description:

    Wrapper for ClusterGroupOpenEnum..
    Retry until success or user aborts.

Arguments:

    pwzGroupName - Name of group to open enumerator for.

    hGroup - Handle to group to open enumerator for.

    dwType - Type of objects to enumerate.

Return Value:

    HGROUPENUM as returned by ClusterGroupOpenEnum.

--*/
{
    for (;;)
    {
        HGROUPENUM hGroupEnum = ClusterGroupOpenEnum(hGroup, dwType);
        if (hGroupEnum != NULL)
        {
            return hGroupEnum;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_EnumerateGroup_ERR, GetLastError(), pwzGroupName))
        {
            throw CClusterUpgradeException();
        }
    }

    return NULL; // never reached

} //ClusterGroupOpenEnumWithRetry


HRESENUM
ClusterResourceOpenEnumWithRetry(
    LPCWSTR   pwzResourceName,
    HRESOURCE hResource,
    DWORD     dwType
    )
/*++

Routine Description:

    Wrapper for ClusterResourceOpenEnum..
    Retry until success or user aborts.

Arguments:

    pwzResourceName - Name of resource to open enumerator for.

    hResource - Handle to resource to open enumerator for.

    dwType - Type of objects to enumerate.

Return Value:

    HRESENUM as returned by ClusterResourceOpenEnum.

--*/
{
    for (;;)
    {
        HRESENUM hResEnum = ClusterResourceOpenEnum(hResource, dwType);
        if (hResEnum != NULL)
        {
            return hResEnum;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_EnumerateResource_ERR, GetLastError(), pwzResourceName))
        {
            throw CClusterUpgradeException();
        }
    }

    return NULL; // never reached

} //ClusterResourceOpenEnumWithRetry


DWORD
ClusterEnumWithRetry(
    HCLUSENUM hClusEnum,
    DWORD     dwIndex,
    LPDWORD   lpdwType,
    AP<WCHAR> &pwzName,
    LPDWORD   lpcbName
    )
/*++

Routine Description:

    Wrapper for ClusterEnum.
    Retry until success or user aborts.
    Also handle reallocation on ERROR_MORE_DATA.

Arguments:

    hClusEnum - Enumeration handle.

    dwIndex - Index of the object to return.

    lpdwType - On output, points to type of object returned.

    pwzName - On output, points to pointer to name of returned object.

    lpcbName - Points to size of buffer.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_NO_MORE_ITEMS - There are no more resources to be returned.

--*/
{
    DWORD cbName = *lpcbName;

    for (;;)
    {
        *lpcbName = cbName;
        DWORD status = ClusterEnum(hClusEnum, dwIndex, lpdwType, pwzName.get(), lpcbName);
        if (status == ERROR_SUCCESS || status == ERROR_NO_MORE_ITEMS)
        {
            return status;
        }

        if (status == ERROR_MORE_DATA)
        {
            pwzName.free();
            cbName = (*lpcbName) + 1;
            pwzName = new WCHAR[cbName];
            if (pwzName.get() == NULL)
            {
                MqDisplayError(NULL, IDS_UpgradeCluster_NoMemory_ERR, 0);
                throw CClusterUpgradeException();
            }
            continue;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_Enumerate_ERR, status))
        {
            throw CClusterUpgradeException();
        }
    }

    return ERROR_SUCCESS; // never reached

} //ClusterEnumWithRetry


DWORD
ClusterGroupEnumWithRetry(
    LPCWSTR    pwzGroupName,
    HGROUPENUM hGroupEnum,
    DWORD      dwIndex,
    LPDWORD    lpdwType,
    AP<WCHAR> &pwzResourceName,
    LPDWORD    lpcbName
    )
/*++

Routine Description:

    Wrapper for ClusterGroupEnum.
    Retry until success or user aborts.
    Also handle reallocation on ERROR_MORE_DATA.

Arguments:

    pwzGroupName - Name of group to enumerate thru.

    hGroupEnum - Group enumeration handle.

    dwIndex - Index of the resource to return.

    lpdwType - On output, points to type of object returned.

    pwzResourceName - On output, points to pointer to name of returned resource.

    lpcbName - Points to size of buffer.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_NO_MORE_ITEMS - There are no more resources to be returned.

--*/
{
    DWORD cbName = *lpcbName;

    for (;;)
    {
        *lpcbName = cbName;
        DWORD status = ClusterGroupEnum(hGroupEnum, dwIndex, lpdwType, pwzResourceName.get(), lpcbName);
        if (status == ERROR_SUCCESS || status == ERROR_NO_MORE_ITEMS)
        {
            return status;
        }

        if (status == ERROR_MORE_DATA)
        {
            pwzResourceName.free();
            cbName = (*lpcbName) + 1;
            pwzResourceName = new WCHAR[cbName];
            if (pwzResourceName.get() == NULL)
            {
                MqDisplayError(NULL, IDS_UpgradeCluster_NoMemory_ERR, 0);
                throw CClusterUpgradeException();
            }
            continue;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_EnumerateGroup_ERR, status, pwzGroupName))
        {
            throw CClusterUpgradeException();
        }
    }

    return ERROR_SUCCESS; // never reached

} //ClusterGroupEnumWithRetry


DWORD
ClusterResourceEnumWithRetry(
    LPCWSTR  pwzResource,
    HRESENUM hResEnum,
    DWORD    dwIndex,
    LPDWORD  lpdwType,
    AP<WCHAR> &pwzName,
    LPDWORD  lpcbName
    )
/*++

Routine Description:

    Wrapper for ClusterResourceEnum.
    Retry until success or user aborts.
    Also handle reallocation on ERROR_MORE_DATA.

Arguments:

    pwzResource - Points to name of resource to enumerate on.

    hResEnum - Enumeration handle.

    dwIndex - Index of the object to return.

    lpdwType - On output, points to type of object returned.

    pwzName - On output, points to pointer to name of returned object.

    lpcbName - Points to size of buffer.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_NO_MORE_ITEMS - There are no more resources to be returned.

--*/
{
    DWORD cbName = *lpcbName;

    for (;;)
    {
        *lpcbName = cbName;
        DWORD status = ClusterResourceEnum(hResEnum, dwIndex, lpdwType, pwzName.get(), lpcbName);
        if (status == ERROR_SUCCESS || status == ERROR_NO_MORE_ITEMS)
        {
            return status;
        }

        if (status == ERROR_MORE_DATA)
        {
            pwzName.free(); 
            cbName = (*lpcbName) + 1;
            pwzName = new WCHAR[cbName];
            if (pwzName.get() == NULL)
            {
                MqDisplayError(NULL, IDS_UpgradeCluster_NoMemory_ERR, 0);
                throw CClusterUpgradeException();
            }
            continue;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_EnumerateResource_ERR, status, pwzResource))
        {
            throw CClusterUpgradeException();
        }
    }

    return ERROR_SUCCESS; // never reached

} //ClusterResourceEnumWithRetry


VOID
RemoveRegistryCheckpointWithRetry(
    HRESOURCE hResource,
    LPCWSTR   pwzResourceName,
    LPWSTR    pwzCheckpoint
    )
/*++

Routine Description:

    Delete registry checkpoint for a resource.
    Retry until success or user aborts.

Arguments:

    hResource - Handle of the resource to operate on.

    pwzResourceName - Points to name of the resource to operate on.

    pwzCheckpoint - Points to name of registry checkpoint.

Return Value:

    None.

--*/
{ 
    for (;;)
    {
        DWORD cbReturnedSize = 0;
        DWORD status = ClusterResourceControl(
            hResource, 
            NULL, 
            CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT,
            pwzCheckpoint,
            numeric_cast<DWORD> ((wcslen(pwzCheckpoint) + 1) * sizeof(WCHAR)),
            NULL,
            0,
            &cbReturnedSize
            );
        if (status == ERROR_SUCCESS || status == ERROR_FILE_NOT_FOUND)
        {
            return;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_DelRegistryCp_ERR, status, pwzResourceName))
        {
            throw CClusterUpgradeException();
        }
    }
} //RemoveRegistryCheckpointWithRetry


VOID
BringOnlineNewResourceWithRetry(
    HRESOURCE hResource,
    LPCWSTR   pwzResourceName
    )
/*++

Routine Description:

    Issue an online request for the new msmq resource.
    Retry until success or user aborts.

Arguments:

    hResource - Handle of msmq resource to bring online.

    pwzResourceName - Points to name of msmq resource to bring online.

Return Value:

    None.

--*/
{
    for (;;)
    {
        DWORD status = OnlineClusterResource(hResource);
        if (status == ERROR_SUCCESS || status == ERROR_IO_PENDING)
        {
            return;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_OnlineResource_ERR, status, pwzResourceName))
        {
            throw CClusterUpgradeException();
        }
    }
} //BringOnlineNewResourceWithRetry


VOID
DeleteOldResourceWithRetry(
    HRESOURCE hResource
    )
/*++

Routine Description:

    Delete the old msmq resource.
    Retry until success or user aborts.

Arguments:

    hResource - Handle of old msmq resource to delete.

Return Value:

    None.

--*/
{
	DebugLogMsg(eAction, L"Deleting the old MSMQ resource");
    //
    // Resource should be offline now, but try anyway.
    //
    OfflineClusterResource(hResource);

    for (;;)
    {
        DWORD status = DeleteClusterResource(hResource);
        if (status == ERROR_SUCCESS)
        {
            return;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_ClusterUpgradeDeleteResource_ERR, status))
        {
            throw CClusterUpgradeException();
        }
    }
} //DeleteOldResourceWithRetry


VOID
DeleteOldResourceTypeWithRetry(
    VOID
    )
/*++

Routine Description:

    Delete the old msmq resource type (Microsoft Message Queue Server).
    Retry until success or user aborts.

Arguments:

    None.

Return Value:

    None.

--*/
{
	DebugLogMsg(eAction, L"Deleting the old MSMQ resource type");
    CAutoCluster hCluster(OpenClusterWithRetry());

    CResString strOldType(IDS_ClusterResourceOldTypeName);
    for (;;)
    {
        DWORD status = DeleteClusterResourceType(hCluster, L"Microsoft Message Queue Server");
        if (status == ERROR_SUCCESS)
        {
            return;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_DeleteResourceType_ERR, status, strOldType.Get()))
        {
            throw CClusterUpgradeException();
        }
    }
} //DeleteOldResourceTypeWithRetry


VOID
AddClusterResourceDependencyWithRetry(
    HRESOURCE hResource,
    LPCWSTR   pwzResource,
    HRESOURCE hDependsOn,
    LPCWSTR   pwzDependsOn
    )
/*++

Routine Description:

    Wrapper for AddClusterResourceDependency.
    Retry until success or user aborts.

Arguments:

    hResource - Handle to the dependent resource.

    pwzResource - Name of the dependent resource.

    hDependsOn - Handle to the resource that the resource identified by hResource should depend on.

    pwzDependsOn - Name of the resource that the resource identified by hResource should depend on.

Return Value:

    None.

--*/
{
    for (;;)
    {
        DWORD status = AddClusterResourceDependency(hResource, hDependsOn);
        if (status == ERROR_SUCCESS || status == ERROR_DEPENDENCY_ALREADY_EXISTS)
        {
            return;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_AddClusterResourceDependency_ERR, status, pwzResource,
                                               pwzDependsOn))
        {
            throw CClusterUpgradeException();
        }
    }
} //AddClusterResourceDependencyWithRetry


VOID
RemoveClusterResourceDependencyWithRetry(
    HRESOURCE hResource,
    LPCWSTR   pwzResource,
    HRESOURCE hDependsOn,
    LPCWSTR   pwzDependsOn
    )
/*++

Routine Description:

    Wrapper for RemoveClusterResourceDependency.
    Retry until success or user aborts.

Arguments:

    hResource - Handle to the dependent resource.

    pwzResourc - Name of the dependent resource.

    hDependsOn - Handle to the resource that the resource identified by hResource currently depends on.

    pwzDependsOn - Name of the resource that the resource identified by hResource currently depends on.

Return Value:

    None.

--*/
{
    for (;;)
    {
        DWORD status = RemoveClusterResourceDependency(hResource, hDependsOn);
        if (status == ERROR_SUCCESS || status == ERROR_DEPENDENCY_NOT_FOUND)
        {
            return;
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_RemoveClusterResourceDependency_ERR, status,
                                               pwzResource, pwzDependsOn))
        {
            throw CClusterUpgradeException();
        }
    }
} //RemoveClusterResourceDependency







static
bool
GenerateStrongCryptoKey(
    VOID
    )
/*++

Routine Description:

    Handle bug 430413: Must generate 128 bit crypto key for the old
    MSMQ resource to properly report its type.

Arguments:

    None

Return Value:

    true - Strong crypto key for msmq was successfully generated.

    false - Strong crypto key for msmq was not generated, either b/c
            the system is not 128 bit or some other failure accured.

--*/
{
	if (g_fStrongCryptoKeyCreated)
	{
		return true;
	}
	
	DebugLogMsg(eAction, L"Generating a strong crypto key.");
    HCRYPTPROV hProv = NULL;
    if (!CryptAcquireContext( 
            &hProv,
            MSMQ_CRYPTO128_DEFAULT_CONTAINER,
            MS_ENHANCED_PROV,
            PROV_RSA_FULL,
            CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET
            ))
    {
        //
        // Failed to generate new key container.
        // Maybe it already exists. Try to open it.
        //
        if (!CryptAcquireContext( 
                &hProv,
                MSMQ_CRYPTO128_DEFAULT_CONTAINER,
                MS_ENHANCED_PROV,
                PROV_RSA_FULL,
                CRYPT_MACHINE_KEYSET
                ))
        {
            //
            // Failed to open key container.
            // Probably system is not 128 bit.
            //
            DebugLogMsg(eError, L"Failed to open key container " MSMQ_CRYPTO128_DEFAULT_CONTAINER L".  Probably system is not 128 bit");
            return false;
        }
    }

    HCRYPTKEY hKeyxKey = NULL;
    if (CryptGenKey(hProv, AT_KEYEXCHANGE, CRYPT_EXPORTABLE, &hKeyxKey))
    {
        CryptDestroyKey(hKeyxKey);
    }
    else
    {
        ASSERT(("CryptGenKey failed for AT_KEYEXCHANGE!", 0));
    }
    
    HCRYPTKEY hSignKey = NULL;
    if (CryptGenKey(hProv, AT_SIGNATURE, CRYPT_EXPORTABLE, &hSignKey))
    {
        CryptDestroyKey(hSignKey);
    }
    else
    {
        ASSERT(("CryptGenKey failed for AT_SIGNATURE!", 0));
    }
    
    CryptReleaseContext(hProv, 0);
    return true;

} // GenerateStrongCryptoKey


HRESOURCE
OpenResourceOfSpecifiedType(
    LPCWSTR pwzResource,
    LPCWSTR pwzType 
    )
/*++

Routine Description:

    Check if the specified resource is of the specified type.

Arguments:

    pwzResource - The name of the resource to check.

    pwzType - The type to check.

Return Value:

    HRESOURCE of the specified resource.

    NULL - The resource is not of the specified type.

--*/
{
    CAutoCluster hCluster(OpenClusterWithRetry());

    CClusterResource hResource(OpenClusterResourceWithRetry(hCluster, pwzResource));

    ASSERT(("assuming length of type name < 255", wcslen(pwzType) < 255));
    WCHAR wzTypeName[255] = L"";

    for (;;)
    {
        DWORD cbReturnedSize = 0;
        DWORD status = ClusterResourceControl(
            hResource, 
            NULL, 
            CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
            NULL,
            0,
            wzTypeName,
            sizeof(wzTypeName),
            &cbReturnedSize
            );

        if (status == ERROR_SUCCESS)
        {
            if (OcmLocalAwareStringsEqual(wzTypeName, pwzType))
            {
                return hResource.detach();
            }

            return NULL;
        }

        if (status == ERROR_MORE_DATA)
        {
            return NULL;
        }

        if (OcmLocalUnAwareStringsEqual(L"Microsoft Message Queue Server", pwzType))
        {
            //
            // Bug 430413: Fail to query old msmq resource for its type, 
            // if system is 128 bit. 
            // Fix: Generate 128 bit key and ask user to reboot.
            //
            DebugLogMsg(eError, L"Failed to get resource type for %ls. status = 0x%x", pwzResource , status);
            if (GenerateStrongCryptoKey())
            {
            	g_fStrongCryptoKeyCreated = true;
            	return NULL;
            }
        }

        if (IDRETRY != MqDisplayErrorWithRetry(IDS_QUERY_RESOURCE_TYPE_ERR, status, pwzResource))
        {
            throw CClusterUpgradeException();
        }
    }

    return NULL; // never reached

} //OpenResourceOfSpecifiedType


HRESOURCE
OpenOldMsmqResourceInGroup(
    HCLUSTER hCluster,
    LPCWSTR  pwzGroupName,
    HGROUP * phGroup,
    wstring& OldResourceName
    )
/*++

Routine Description:

    Enumerate the resources in the group to locate
    the old msmq resource.

Arguments:

    hCluster - handle to this cluster.

    pwzGroupName - Name of the group to iterate thru.

    phGroup  - on output, points to the group handle of the group to search thru.

    OldResourceName - on output, holds the name of old msmq resource.

Return Value:

    HRESOURCE of the old msmq resource.

    NULL - The old msmq resource was not found in the group.

--*/
{
    CClusterGroup hGroup(OpenClusterGroupWithRetry(hCluster, pwzGroupName));

    CGroupEnum hEnum(ClusterGroupOpenEnumWithRetry(pwzGroupName, hGroup, CLUSTER_GROUP_ENUM_CONTAINS));

    AP<WCHAR> pwzResourceName = new WCHAR[255];
    if (pwzResourceName.get() == NULL)
    {
        MqDisplayError(NULL, IDS_UpgradeCluster_NoMemory_ERR, 0);
        throw CClusterUpgradeException();
    }

    DWORD cbResourceName = 255 * sizeof(WCHAR);
    DWORD dwIndex = 0;
    DWORD dwType = CLUSTER_GROUP_ENUM_CONTAINS;
    DWORD status = ERROR_SUCCESS;

    while (status != ERROR_NO_MORE_ITEMS)
    {
        DWORD cbTmp = cbResourceName;
        status = ClusterGroupEnumWithRetry(pwzGroupName, hEnum, dwIndex++, &dwType, pwzResourceName, 
                                           &cbTmp);
        if (cbTmp > cbResourceName)
        {
            cbResourceName = cbTmp;
        }

        ASSERT(status == ERROR_SUCCESS || status == ERROR_NO_MORE_ITEMS);

        if (status == ERROR_SUCCESS)
        {
            HRESOURCE hResource = OpenResourceOfSpecifiedType(pwzResourceName.get(), L"Microsoft Message Queue Server");
            if (hResource != NULL)
            {
                *phGroup = hGroup.detach();
				OldResourceName = pwzResourceName.get();
                return hResource;
            }
        }
    }

    if(g_fStrongCryptoKeyCreated)
    {
		MqDisplayError(NULL, IDS_STRONG_CRYPTO_ERROR, 0);
        throw CClusterUpgradeException();
    }

    return NULL;

} //OpenOldMsmqResourceInGroup


HRESOURCE
OpenOldMsmqResourceInCluster(
    HGROUP * phGroup,
    wstring& OldResourceName
    )
/*++

Routine Description:

    Enumerate the groups in the cluster to locate
    the old msmq resource and its cluster group.

Arguments:

    phGroup - on output, points to handle of the group of old msmq resource.

    OldResourceName - on output, holds the name of old msmq resource.

Return Value:

    HRESOURCE of old msmq resource.

    NULL - The old msmq resource was not found.

--*/
{
	DebugLogMsg(eAction, L"Opening the old MSMQ resource.");
    CAutoCluster hCluster(OpenClusterWithRetry());

    CClusterEnum hEnum(ClusterOpenEnumWithRetry(hCluster, CLUSTER_ENUM_GROUP));

    TickProgressBar(IDS_SearchOldResource_PROGRESS);

    DWORD dwIndex = 0;
    AP<WCHAR> pwzGroupName = new WCHAR[255];
    if (pwzGroupName.get() == NULL)
    {
        MqDisplayError(NULL, IDS_UpgradeCluster_NoMemory_ERR, 0);
        throw CClusterUpgradeException();
    }

    DWORD cbGroupName = 255 * sizeof(WCHAR);
    DWORD dwType = CLUSTER_ENUM_GROUP;
    DWORD status = ERROR_SUCCESS;

    while (status != ERROR_NO_MORE_ITEMS)
    {
        DWORD cbTmp = cbGroupName;
        status = ClusterEnumWithRetry(hEnum, dwIndex++, &dwType, pwzGroupName, &cbTmp);
        if (cbTmp > cbGroupName)
        {
            cbGroupName = cbTmp;
        }

        ASSERT(status == ERROR_SUCCESS || status == ERROR_NO_MORE_ITEMS);

        if (status == ERROR_SUCCESS)
        {
            HRESOURCE hRes = OpenOldMsmqResourceInGroup(hCluster, pwzGroupName.get(), phGroup, OldResourceName);
            if (hRes != NULL)
            {
                return hRes;
            }
        }
    }

    return NULL;

} //OpenOldMsmqResourceInCluster


HRESOURCE
CreateClusterResourceWithRetry(
    LPCWSTR pwzOldResource,
    HGROUP  hGroup,
    wstring& NewResourceName
    )
/*++

Routine Description:

    Create a new msmq cluster resource.
    The name of the new resource is based on the
    name of the old one.

Arguments:

    pwzOldResource - Name of old msmq resource.

    hGroup - Handle to group in which to create the resource.

    pwzNewResource - On output, name of new msmq resource.

Return Value:

    HRESOURCE of the created resource, as returned by CreateClusterResource..

--*/
{
    NewResourceName = pwzOldResource;

    for (;;)
    {
        CResString strSuffix(IDS_ClusterUpgrade_ResourceNameSuffix);
        NewResourceName += strSuffix.Get();

        HRESOURCE hResource = CreateClusterResource(hGroup, NewResourceName.c_str(), L"MSMQ", 0);
        if (hResource != NULL)
        {
            DisplayMessage(IDS_ClusterUpgradeMsgTitle, IDS_NewResourceCreateOk, NewResourceName.c_str());
            return hResource;
        }

        if (ERROR_DUPLICATE_SERVICE_NAME == GetLastError())
        {
            //
            // This newly generated name is already occupied by some other resource.
            // If this other resource is of the new msmq type, than just open a handle
            // to it. This scenario could be as a result of 2 nodes running concurrently
            // this wizard, or re-run of this wizard after crash.
            //
            hResource = OpenResourceOfSpecifiedType(NewResourceName.c_str(), L"MSMQ");
            if (hResource != NULL)
            {
                return hResource;
            }

            continue;
        }

        CResString strType(IDS_ClusterTypeName);
        if (IDRETRY != MqDisplayErrorWithRetry(IDS_CreateResource_ERR, GetLastError(), NewResourceName.c_str(),
                                               strType.Get()))
        {
            throw CClusterUpgradeException();
        }
    }
} //CreateClusterResourceWithRetry


VOID
WINAPI
CloneRegistryStringValue(
    HKEY    hKey,
    LPCWSTR pwzValueName
    )
/*++

Routine Description:

    Copy registry string value from main msmq registry to registry of
    new msmq resource.

Arguments:

    hKey - Handle to registry key to copy on.

    pwzValueName - Points to registry value name to copy.

Return Value:

    None.

--*/
{
    WCHAR wzValueData[255] = L"";
    if (!MqReadRegistryValue(pwzValueName, sizeof(wzValueData), wzValueData))
    {
        return;
    }

    DWORD status = RegSetValueEx(
                       hKey, 
                       pwzValueName, 
                       0, 
                       REG_SZ, 
                       reinterpret_cast<BYTE*>(wzValueData),  
                       numeric_cast<DWORD> ((wcslen(wzValueData) + 1) * sizeof(WCHAR))
                       );
    if (status != ERROR_SUCCESS)
    {
        MqDisplayError(NULL, IDS_REGISTRYSET_ERROR, status, pwzValueName);
        throw CClusterUpgradeException();
    }
} //CloneRegistryStringValue


VOID
WINAPI
CloneRegistryDwordValue(
    HKEY    hKey,
    LPCWSTR pwzValueName
    )
/*++

Routine Description:

    Copy registry DWORD value from main msmq registry to registry of
    new msmq resource.

Arguments:

    hKey - Handle to registry key to copy on.

    pwzValueName - Points to registry value name to copy.

Return Value:

    None.

--*/
{
    DWORD dwValue = 0;
    if (!MqReadRegistryValue(pwzValueName, sizeof(DWORD), &dwValue))
    {
        return;
    }

    DWORD status = RegSetValueEx(
                       hKey, 
                       pwzValueName, 
                       0, 
                       REG_DWORD, 
                       reinterpret_cast<BYTE*>(&dwValue), 
                       sizeof(DWORD)
                       );
    if (status != ERROR_SUCCESS)
    {
        MqDisplayError(NULL, IDS_REGISTRYSET_ERROR, status, pwzValueName);
        throw CClusterUpgradeException();
    }
} //CloneRegistryDwordValue


VOID
CloneRegistryValues(
    LPCWSTR pwzNewResource
    )
/*++

Routine Description:

    Copy registry values from main msmq registry to registry of
    new msmq resource.

Arguments:

    pwzNewResource - Points to name of new msmq resource.

Return Value:

    None.

--*/
{
    //
    // Compose the registry key for clustered qm.
    // This code should be identical to the code in mqclus.dll .
    //
    LPCWSTR x_SERVICE_PREFIX = L"MSMQ$";
    WCHAR wzServiceName[200] = L""; 
    HRESULT hr = StringCchCopy(wzServiceName, TABLE_SIZE(wzServiceName), x_SERVICE_PREFIX);
	ASSERT(SUCCEEDED(hr));

    hr = StringCchCat(wzServiceName, TABLE_SIZE(wzServiceName), pwzNewResource);
	ASSERT(SUCCEEDED(hr));

    WCHAR wzFalconRegSection[200 + 100];
    hr = StringCchPrintf(
			wzFalconRegSection, 
			TABLE_SIZE(wzFalconRegSection), 
			L"%s%s%s\\", 
			FALCON_CLUSTERED_QMS_REG_KEY, 
			wzServiceName, 
			FALCON_REG_KEY_PARAM
			);
	ASSERT(SUCCEEDED(hr));

    CAutoCloseRegHandle hKey;  
    LONG status = RegOpenKeyEx(
                      FALCON_REG_POS, 
                      wzFalconRegSection, 
                      0, 
                      KEY_ALL_ACCESS,
                      &hKey
                      );
    if (status != ERROR_SUCCESS)
    {
        MqDisplayError(NULL, IDS_REGISTRYOPEN_ERROR, status, FALCON_REG_POS_DESC, wzFalconRegSection);
        throw CClusterUpgradeException();
    }

    typedef VOID (WINAPI *HandlerRoutine) (HKEY, LPCWSTR); 

    struct RegEntry 
    {
        LPCWSTR        pwzValueName;
        HandlerRoutine handler;
    };

    RegEntry RegMap[] = {
    // Value Name                         |   Handler Routine
    //------------------------------------|------------------------------------|
    {MSMQ_SETUP_STATUS_REGNAME,              CloneRegistryDwordValue},
    {MSMQ_ROOT_PATH,                         CloneRegistryStringValue}, 
    {MSMQ_STORE_RELIABLE_PATH_REGNAME,       CloneRegistryStringValue},
    {MSMQ_STORE_PERSISTENT_PATH_REGNAME,     CloneRegistryStringValue},
    {MSMQ_STORE_JOURNAL_PATH_REGNAME,        CloneRegistryStringValue},
    {MSMQ_STORE_LOG_PATH_REGNAME,            CloneRegistryStringValue},
    {FALCON_XACTFILE_PATH_REGNAME,           CloneRegistryStringValue},
    {MSMQ_TRANSACTION_MODE_REGNAME,          CloneRegistryStringValue},
    {MSMQ_SEQ_ID_REGNAME,                    CloneRegistryDwordValue},
    {MSMQ_MESSAGE_ID_LOW_32_REGNAME,         CloneRegistryDwordValue},
    {MSMQ_MESSAGE_ID_HIGH_32_REGNAME,        CloneRegistryDwordValue},
    {FALCON_LOGDATA_CREATED_REGNAME,         CloneRegistryDwordValue}
    };

    for (DWORD ix = 0; ix < sizeof(RegMap)/sizeof(RegMap[0]); ++ix)
    {
        RegMap[ix].handler(hKey, RegMap[ix].pwzValueName);
    }
} //CloneRegistryValues


VOID
MoveDependencies(
    HRESOURCE hNewResource,
    LPCWSTR   pwzNewResource,
    HRESOURCE hOldResource,
    LPCWSTR   pwzOldResource
    )
/*++

Routine Description:

    Move dependencies from the old msmq resource to the new one.

Arguments:

    hNewResource - Handle of new msmq resource.

    pwzNewResource - Name of new msmq resource.

    hOldResource - Handle of old msmq resource.

    pwzOldResource - Name of old msmq resource.

Return Value:

    None.

--*/
{
    CAutoCluster hCluster(OpenClusterWithRetry());

    TickProgressBar(IDS_ConfigureNewResource_PROGRESS);

    //
    // Copy dependencies of old resource
    //

    DWORD dwEnum = CLUSTER_RESOURCE_ENUM_DEPENDS;
    CResourceEnum hEnumDepend(ClusterResourceOpenEnumWithRetry(pwzOldResource, hOldResource, dwEnum));

    DWORD dwIndex = 0;
    AP<WCHAR> pwzDepend = new WCHAR[255];
    if (pwzDepend.get() == NULL)
    {
        MqDisplayError(NULL, IDS_UpgradeCluster_NoMemory_ERR, 0);
        throw CClusterUpgradeException();
    }

    DWORD cbDepend = 255 * sizeof(WCHAR);
    DWORD status = ERROR_SUCCESS;

    while (status != ERROR_NO_MORE_ITEMS)
    {
        DWORD cbTmp = cbDepend;
        status = ClusterResourceEnumWithRetry(pwzOldResource, hEnumDepend, dwIndex++, &dwEnum, pwzDepend, 
                                              &cbTmp);
        if (cbTmp > cbDepend)
        {
            cbDepend = cbTmp;
        }

        if (status == ERROR_SUCCESS)
        {
            CClusterResource hResourceDepend(OpenClusterResourceWithRetry(hCluster, pwzDepend.get()));
            AddClusterResourceDependencyWithRetry(hNewResource, pwzNewResource, hResourceDepend, pwzDepend.get());
        }
    }

    //
    // Move dependencies that old resource provides to the new resource
    //

    dwEnum = CLUSTER_RESOURCE_ENUM_PROVIDES;
    CResourceEnum hEnumProvide(ClusterResourceOpenEnumWithRetry(pwzOldResource, hOldResource, dwEnum));

    dwIndex = 0;
    AP<WCHAR> pwzProvide = new WCHAR[255];
    if (pwzProvide.get() == NULL)
    {
        MqDisplayError(NULL, IDS_UpgradeCluster_NoMemory_ERR, 0);
        throw CClusterUpgradeException();
    }

    DWORD cbProvide = 255 * sizeof(WCHAR);
    status = ERROR_SUCCESS;

    while (status != ERROR_NO_MORE_ITEMS)
    {
        DWORD cbTmp = cbProvide;
        status = ClusterResourceEnumWithRetry(pwzOldResource, hEnumProvide, dwIndex++, &dwEnum, pwzProvide, 
                                              &cbTmp);
        if (cbTmp > cbProvide)
        {
            cbProvide = cbTmp;
        }

        if (status == ERROR_SUCCESS)
        {
            CClusterResource hResourceProvide(OpenClusterResourceWithRetry(hCluster, pwzProvide.get()));
            AddClusterResourceDependencyWithRetry(hResourceProvide, pwzProvide.get(), hNewResource, pwzNewResource);
            RemoveClusterResourceDependencyWithRetry(hResourceProvide, pwzProvide.get(), hOldResource, pwzOldResource);
        }
    }
} //MoveDependencies


VOID
CreateNewMsmqResource(
    HRESOURCE hOldResource,
    LPCWSTR   pwzOldResource,
    HGROUP    hGroup
    )
/*++

Routine Description:

    Handle creation of new msmq cluster resource, based on the name
    of the old one.

Arguments:

    hOldResource - Handle of old msmq resource.

    pwzOldResource - Points to name of the old msmq resource.

    hGroup - Handle of group of old msmq resource.

Return Value:

    HRESOURCE of the new msmq cluster resource.

--*/
{
	DebugLogMsg(eAction, L"Creating the new MSMQ resource");
    TickProgressBar(IDS_CreateNewResource_PROGRESS);

    wstring NewResource;
    CClusterResource hNewResource(CreateClusterResourceWithRetry(pwzOldResource, hGroup, NewResource));
    
    MoveDependencies(hNewResource, NewResource.c_str(), hOldResource, pwzOldResource);

    CloneRegistryValues(NewResource.c_str());
    
    BringOnlineNewResourceWithRetry(hNewResource, NewResource.c_str());

    DisplayMessage(IDS_ClusterUpgradeMsgTitle, IDS_NewResourceOnlineOk, NewResource.c_str());

} //CreateNewMsmqResource


bool
UpgradeMsmqClusterResource(
    VOID
    )
/*++

Routine Description:

    Handle upgrade of MSMQ cluster resource from NT 4 and Wind2000 Beta3

Arguments:

    None

Return Value:

    true - operation was successful.

    false - operation failed.

--*/
{
    ASSERT(Msmq1InstalledOnCluster());
    TickProgressBar(IDS_UpgradeMsmqClusterResource_PROGRESS);

    try
    {
        CAutoFreeLibrary hClusapiDll;
        LoadClusapiDll(&hClusapiDll);

        wstring OldResource; 
        CClusterGroup hGroup;
        CClusterResource hOldResource(OpenOldMsmqResourceInCluster(&hGroup, OldResource));
        if (hOldResource == NULL)
        {
            //
            // Old resource was not found. We are done.
            //
            return true;
        }
        
        TickProgressBar(IDS_ClusterUpgradeFixRegistry_PROGRESS);

        DebugLogMsg(eAction, L"Removing registry checkpoints");
        RemoveRegistryCheckpointWithRetry(hOldResource, OldResource.c_str(), L"Software\\Microsoft\\MSMQ");
        RemoveRegistryCheckpointWithRetry(hOldResource, OldResource.c_str(), L"Software\\Microsoft\\MSMQ\\Parameters");
		RemoveRegistryCheckpointWithRetry(hOldResource, OldResource.c_str(), L"Software\\Microsoft\\MSMQ\\Setup");
        RemoveRegistryCheckpointWithRetry(hOldResource, OldResource.c_str(), L"Software\\Microsoft\\Cryptography\\MachineKeys\\MSMQ");

        CreateNewMsmqResource(hOldResource, OldResource.c_str(), hGroup);

        DeleteOldResourceWithRetry(hOldResource);

        DeleteOldResourceTypeWithRetry();
    }
    catch(const CClusterUpgradeException&)
    {
        MqDisplayError(NULL, IDS_UpgradeClusterFail_ERR, 0);
        return false;
    }

    return true;

} //UpgradeMsmqClusterResource

#pragma warning(default: 4702) //C4702: unreachable code
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\msmqocm\wizpage.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wizpage.cpp

Abstract:

    Handle wizard pages for ocm setup.

Author:

    Doron Juster  (DoronJ)  26-Jul-97

Revision History:

    Shai Kariv    (ShaiK)   10-Dec-97   Modified for NT 5.0 OCM Setup

--*/


#include "msmqocm.h"
#include <strsafe.h>

#include "wizpage.tmh"

HWND  g_hPropSheet = NULL ;

HFONT g_hTitleFont = 0;

//+--------------------------------------------------------------
//
// Function: CreatePage
//
// Synopsis: Creates property page
//
//+--------------------------------------------------------------
static
HPROPSHEETPAGE
CreatePage(
    IN const int     nID,
    IN const DLGPROC pDlgProc,
    IN const TCHAR  * szTitle,
    IN const TCHAR  * szSubTitle,
    IN BOOL          fFirstOrLast
    )
{
    PROPSHEETPAGE Page;
    memset(&Page, 0, sizeof(Page)) ;

    Page.dwSize = sizeof(PROPSHEETPAGE);
    Page.dwFlags = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    if (fFirstOrLast)
    {
        Page.dwFlags |= PSP_HIDEHEADER;
    }
    Page.hInstance = (HINSTANCE)g_hResourceMod;
    Page.pszTemplate = MAKEINTRESOURCE(nID);
    Page.pfnDlgProc = pDlgProc;
    Page.pszHeaderTitle = _tcsdup(szTitle);
    Page.pszHeaderSubTitle = _tcsdup(szSubTitle);

    HPROPSHEETPAGE PageHandle = CreatePropertySheetPage(&Page);

    return(PageHandle);

} //CreatePage

//+--------------------------------------------------------------
//
// Function: SetTitleFont
//
// Synopsis: Set font for the title in the welcome/ finish page
//
//+--------------------------------------------------------------
static void SetTitleFont(IN HWND hdlg)
{
    HWND hTitle = GetDlgItem(hdlg, IDC_TITLE);
         
    if (g_hTitleFont == 0)
    {
        NONCLIENTMETRICS ncm = {0};
        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

        //
        // Create the title font
        //
        CResString strFontName( IDS_TITLE_FONTNAME );        
        CResString strFontSize( IDS_TITLE_FONTSIZE );        
        
        INT iFontSize = _wtoi( strFontSize.Get() );

        LOGFONT TitleLogFont = ncm.lfMessageFont;
        TitleLogFont.lfWeight = FW_BOLD;
        HRESULT hr =StringCchCopy(TitleLogFont.lfFaceName, TABLE_SIZE(TitleLogFont.lfFaceName), strFontName.Get());
		DBG_USED(hr);
		ASSERT(SUCCEEDED(hr));

        HDC hdc = GetDC(NULL); //gets the screen DC        
        TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * iFontSize / 72;
        g_hTitleFont = CreateFontIndirect(&TitleLogFont);
        ReleaseDC(NULL, hdc);
    }

    BOOL fRedraw = TRUE;
    SendMessage( 
          hTitle,               //(HWND) hWnd, handle to destination window 
          WM_SETFONT,           // message to send
          (WPARAM) &g_hTitleFont,   //(WPARAM) wParam, handle to font
          (LPARAM) &fRedraw     //(LPARAM) lParam, redraw option
        );
            
} //SetTitleFont

//+-------------------------------------------------------------------------
//
//  Function:   MqOcmRequestPages
//
//  Synopsis:   Handles the OC_REQUEST_PAGES interface routine.
//
//  Arguments:  [ComponentId] - supplies id for component. This routine
//                              assumes that this string does NOT need to
//                              be copied and will persist!
//              [WhichOnes]   - supplies type of pages fo be supplied.
//              [SetupPages]  - receives page handles.
//
//  Returns:    Count of pages returned, or -1 if error, in which case
//              SetLastError() will have been called to set extended error
//              information.
//
//  History:    8-Jan-97 dlee     Created
//
//--------------------------------------------------------------------------
DWORD
MqOcmRequestPages(
	const std::wstring& /*ComponentId*/,
    IN     const WizardPagesType     WhichOnes,
    IN OUT       SETUP_REQUEST_PAGES *SetupPages )
{
    HPROPSHEETPAGE pPage = NULL ;
    DWORD          iPageIndex = 0 ;
    DWORD          dwNumofPages = 0 ;

#define  ADD_PAGE(dlgId, dlgProc, szTitle, szSubTitle, fFirstOrLast)                        \
            pPage = CreatePage(dlgId, dlgProc, szTitle, szSubTitle,fFirstOrLast) ; \
            if (!pPage) goto OnError ;                                                      \
            SetupPages->Pages[iPageIndex] = pPage;                                          \
            iPageIndex++ ;

    if (g_fCancelled)
        return 0;

    if ((0 == (g_ComponentMsmq.Flags & SETUPOP_STANDALONE)) && !g_fUpgrade)
    {
        //
        // NT5 fresh install. Don't show dialog pages.
        //
        return 0;
    }

    if ( WizPagesWelcome == WhichOnes && g_fWelcome)
    {
        if (SetupPages->MaxPages < 1)
            return 1;

        CResString strTitle(IDS_WELCOME_PAGE_TITLE);
        CResString strSubTitle(IDS_WELCOME_PAGE_SUBTITLE);
        ADD_PAGE(IDD_Welcome, WelcomeDlgProc, strTitle.Get(), strSubTitle.Get(), TRUE);
        return 1;
    }

    if ( WizPagesFinal == WhichOnes && g_fWelcome)
    {
        if (SetupPages->MaxPages < 1)
            return 1;

        CResString strTitle(IDS_FINAL_PAGE_TITLE);
        CResString strSubTitle(IDS_FINAL_PAGE_SUBTITLE);
        ADD_PAGE(IDD_Final, FinalDlgProc, strTitle.Get(), strSubTitle.Get(), TRUE);
        return 1;
    }

    if ( WizPagesEarly == WhichOnes )
    {
        const UINT x_uMaxServerPages = 5;

        if (SetupPages->MaxPages < x_uMaxServerPages)
        {
            return x_uMaxServerPages ;
        }
        
        ADD_PAGE(IDD_ServerName, DummyPageDlgProc, NULL, NULL, FALSE);

        CResString strTitle(IDS_ServerName_PAGE_TITLE);
        CResString strSubTitle(IDS_ServerName_PAGE_SUBTITLE);
        ADD_PAGE(IDD_ServerName, MsmqServerNameDlgProc, strTitle.Get(), strSubTitle.Get(), FALSE);

        strTitle.Load(IDS_ServerName_PAGE_TITLE);
        strSubTitle.Load(IDS_ServerName_PAGE_SUBTITLE);
        ADD_PAGE(IDD_SupportingServerName, SupportingServerNameDlgProc, strTitle.Get(), strSubTitle.Get(), FALSE);

		strTitle.Load(IDS_Security_PAGE_TITLE);
		strSubTitle.Load(IDS_Security_PAGE_SUBTITLE);
		ADD_PAGE(IDD_AddWeakenedSecurity, AddWeakSecurityDlgProc, strTitle.Get(), strSubTitle.Get(), FALSE);

		strTitle.Load(IDS_Security_PAGE_TITLE);
		strSubTitle.Load(IDS_Security_PAGE_SUBTITLE);
		ADD_PAGE(IDD_RemoveWeakenedSecurity, RemoveWeakSecurityDlgProc, strTitle.Get(), strSubTitle.Get(), FALSE);

        dwNumofPages = iPageIndex ;
    }

    return  dwNumofPages ;

OnError:
    ASSERT(0) ;
    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return((DWORD)(-1));

#undef  ADD_PAGE
} //MqOcmRequestPages


INT_PTR
CALLBACK
DummyPageDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT  msg,
    IN /*const*/ WPARAM wParam,
    IN /*const*/ LPARAM  lParam
    )
{
    //
    // Post selection.
    //
    
    UNREFERENCED_PARAMETER(wParam);
    
    switch(msg)
    {
        case WM_INITDIALOG:        
        {
           PostSelectionOperations(hdlg);
           return 1;
        }
        case WM_NOTIFY:
        {
            switch(((NMHDR *)lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    return SkipWizardPage(hdlg);
                }

                //
                // fall through
                //
                case PSN_KILLACTIVE:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                case PSN_QUERYCANCEL:
                case PSN_WIZNEXT:
                {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    return 1;
                }
                default:
                {
                    return 0;
                }
            }
        }
        default:
        {
            return 0;
        }
    }


}

//+-------------------------------------------------------------------------
//
//  Function:   WelcomeDlgProc
//
//  Synopsis:   Dialog procedure for the welcome page
//
//  Returns:    int depending on msg
//
//+-------------------------------------------------------------------------
INT_PTR
CALLBACK
WelcomeDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM /*wParam*/,
    IN LPARAM lParam
    )
{    
    int iSuccess = 0;
    switch( msg )
    {
        case WM_INITDIALOG:        
            SetTitleFont(hdlg);            
            break;        

        case WM_NOTIFY:
        {
            switch(((NMHDR *)lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    if (g_fCancelled || !g_fWelcome)
                    {
                        iSuccess = SkipWizardPage(hdlg);
                        break;
                    }
                    PropSheet_SetWizButtons(GetParent(hdlg), 0);
                    PropSheet_SetWizButtons(GetParent(hdlg), PSWIZB_NEXT);
                    DebugLogMsg(eUI, L"The Welcome page of the Message Queuing Installation Wizard is displayed.");
                }

                //
                // fall through
                //
                case PSN_KILLACTIVE:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                case PSN_QUERYCANCEL:
                case PSN_WIZNEXT:
                {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    iSuccess = 1;
                    break;
                }
            }
            break;
        }
    }

    return iSuccess;

} // WelcomeDlgProc



//+-------------------------------------------------------------------------
//
//  Function:   FinalDlgProc
//
//  Synopsis:   Dialog procedure for the final page
//
//  Returns:    int depending on msg
//
//+-------------------------------------------------------------------------
INT_PTR
CALLBACK
FinalDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM /*wParam*/,
    IN LPARAM lParam
    )
{
    int iSuccess = 0;
    switch( msg )
    {
        case WM_INITDIALOG:        
            SetTitleFont(hdlg);            
            break;  

        case WM_NOTIFY:
        {
            switch(((NMHDR *)lParam)->code)
            {
                case PSN_SETACTIVE:
                {
                    if (!g_fWelcome)
                    {
                        iSuccess = SkipWizardPage(hdlg);
                        break;
                    }

                    CResString strStatus(IDS_SUCCESS_INSTALL);                    
                    if (g_fWrongConfiguration)
                    {
                        strStatus.Load(IDS_WELCOME_WRONG_CONFIG_ERROR);                       
                    }
                    else if (!g_fCoreSetupSuccess)
                    {
                        //
                        // g_fCoreSetupSuccess is set only in MSMQ Core.
                        // But we have this page only in upgrade mode, in CYS
                        // wizard where MSMQ Core is selected to be installed
                        // always. It means that we have correct value for
                        // this flag.
                        //
                        strStatus.Load(IDS_STR_GENERAL_INSTALL_FAIL);                        
                    }                    
                    SetDlgItemText(hdlg, IDC_SuccessStatus, strStatus.Get());

                    PropSheet_SetWizButtons(GetParent(hdlg), 0) ;
                    PropSheet_SetWizButtons(GetParent(hdlg), PSWIZB_FINISH) ;
                    DebugLogMsg(eUI, L"The Final page of the Message Queuing Installation Wizard is displayed.");
                }

                //
                // fall through
                //
                case PSN_KILLACTIVE:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                case PSN_QUERYCANCEL:
                case PSN_WIZNEXT:
                {
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    iSuccess = 1;
                    break;
                }
            }
            break;
        }
    }

    return iSuccess;

} // FinalDlgProc



//+-------------------------------------------------------------------------
//
//  Function:   AddWeakSecurityDlgProc
//
//  Synopsis:   Dialog procedure for selection of MSMQ security model on DC.
//				This dialog is shown only once when installing Downlevel 
//				Client Support on a DC for the first time in an enterprize.
//
//  Returns:    int depending on msg
//
//+-------------------------------------------------------------------------
INT_PTR
CALLBACK
AddWeakSecurityDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM /*wParam,*/,
    IN /*const*/ LPARAM lParam
	)
{
    switch( msg )
    {
        case WM_INITDIALOG:
        {
			return 1;
        }

        case WM_COMMAND:
        {
			return 1;
        }

        case WM_NOTIFY:
        {
            switch(((NMHDR *)lParam)->code)
            {
              case PSN_SETACTIVE:
              {   
                  //
                  // show this page only when MQDS subcomponent
                  // is selected for installation
                  //
                  if (g_fCancelled           ||
					  g_fBatchInstall		 ||
					  !g_fFirstMQDSInstallation
                      )
                  {
                      return SkipWizardPage(hdlg);
				  }                  

				  ASSERT(!g_fUpgrade);
				  
                  CResString strPageDescription(IDS_ADD_WEAKENED_SECURITY_PAGE_DESCRIPTION);

                  SetDlgItemText(
                        hdlg,
                        IDC_ADD_WEAKENED_SECURITY_PAGE_DESCRIPTION,
                        strPageDescription.Get()
						);

                  CheckRadioButton(
                      hdlg,
                      IDC_RADIO_STRONG,
                      IDC_RADIO_WEAK,
                      IDC_RADIO_STRONG
                      );
                  //
                  // Accept activation
                  //
                  // it is the first page, disable BACK button
                  PropSheet_SetWizButtons(GetParent(hdlg), PSWIZB_NEXT );
                  DebugLogMsg(eUI, L"The Add Weakened Security wizard page is displayed.");
              }

              //
              // fall through
              //
              case PSN_KILLACTIVE:
              case PSN_WIZBACK:
              case PSN_WIZFINISH:
              case PSN_QUERYCANCEL:
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    return 1;

              case PSN_WIZNEXT:
              {
				  if(IsDlgButtonChecked(hdlg, IDC_RADIO_WEAK))
				  {
				  	  DebugLogMsg(eUser, L"Weakened Security On");
					  SetWeakSecurity(true);
				  }
				  else
				  {
				  	  DebugLogMsg(eUser, L"Weakened Security Off");
				  }
				  SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                  return 1;
              }
			  break;
            }
            break;
        }
        default:
        {
			return 0;
        }
    }
    return 0;
} // MsmqSecurityDlgProc


//+-------------------------------------------------------------------------
//
//  Function:   RemoveWeakSecurityDlgProc
//
//  Synopsis:   Dialog procedure for selection of MSMQ security model on DC.
//				This dialog is shown when installing Downlevel Client Support
//				in an enterprize that has Weakened Security. We give a worning
//				and an option to remove the Weakend Security.
//
//  Returns:    int depending on msg
//
//+-------------------------------------------------------------------------
INT_PTR
CALLBACK
RemoveWeakSecurityDlgProc(
    IN /*const*/ HWND   hdlg,
    IN /*const*/ UINT   msg,
    IN /*const*/ WPARAM /*wParam,*/,
    IN /*const*/ LPARAM lParam
	)
{
    switch( msg )
    {
        case WM_INITDIALOG:
        {
			return 1;
        }

        case WM_COMMAND:
        {
			return 1;
        }

        case WM_NOTIFY:
        {
            switch(((NMHDR *)lParam)->code)
            {
              case PSN_SETACTIVE:
              {   
                  //
                  // show this page only when MQDS subcomponent
                  // is selected for installation
                  //
                  if (g_fCancelled           ||
					  g_fBatchInstall		 ||
					  !g_fWeakSecurityOn
                      )
                  {
                      return SkipWizardPage(hdlg);
				  }                  
				
				  ASSERT(!g_fUpgrade);
			  
                  CResString strPageDescription(IDS_REMOVE_WEAKENED_SECURITY_PAGE_DESCRIPTION);

                  SetDlgItemText(
                        hdlg,
                        IDC_REMOVE_WEAKENED_SECURITY_PAGE_DESCRIPTION,
                        strPageDescription.Get()
						);

                  CheckRadioButton(
                      hdlg,
                      IDC_RADIO_STRONG,
                      IDC_RADIO_WEAK,
                      IDC_RADIO_WEAK
                      );
                  //
                  // Accept activation
                  //
                  // it is the first page, disable BACK button
                  PropSheet_SetWizButtons(GetParent(hdlg), PSWIZB_NEXT);
                  DebugLogMsg(eUI, L"The Remove Weakened Security wizard page is displayed.");
              }

              //
              // fall through
              //
              case PSN_KILLACTIVE:
              case PSN_WIZBACK:
              case PSN_WIZFINISH:
              case PSN_QUERYCANCEL:
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    return 1;

              case PSN_WIZNEXT:
              {
				  if(IsDlgButtonChecked(hdlg, IDC_RADIO_STRONG))
				  {
				      DebugLogMsg(eUser, L"Weakened Security Off");
					  SetWeakSecurity(false);
				  }
				  else
				  {
				  	  DebugLogMsg(eUser, L"Weakened Security On");
				  }
				  SetWindowLongPtr( hdlg, DWLP_MSGRESULT, 0 );
                  return 1;
              }
			  break;
            }
            break;
        }
        default:
        {
			return 0;
        }
    }
    return 0;
} // MsmqSecurityDlgProc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\win.95\migrate\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by migrate.rc
//

#define IDS_PRODUCT_ID                  101
#define IDS_COMPANY                     102
#define IDS_SUPPORT_NUMBER              103
#define IDS_INSTRUCTIONS                105
#define IDS_COMPAT_WARNING              106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           201
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\setup\win.95\migrate\migrate.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    migrate.cpp

Abstract:

    Handles upgrade of Win9x + MSMQ 1.0 to W2K/XP

Author:

    Shai Kariv  (ShaiK)  22-Apr-98

--*/

#include <windows.h>
#include <winuser.h>
#include <stdio.h>
#include <tchar.h>
#include <setupapi.h>
#include <assert.h>
#include <autorel2.h>
#include "uniansi.h"
#define  MQUTIL_EXPORT
#include "mqtypes.h"
#include "_mqdef.h"

#include "..\..\msmqocm\setupdef.h"
#include "..\..\msmqocm\comreg.h"
#include "resource.h"

//
// Info needed for Win95 migration
//
#define PRODUCT_ID     TEXT("Microsoft Message Queuing Services")
#define COMPANY        TEXT("Microsoft Corporation")
#define SUPPORT_NUMBER TEXT("1-800-936-4900 (USA and Canada)")
#define SUPPORT_URL    TEXT("http://go.microsoft.com/fwlink/?LinkId=803")
#define INSTRUCTIONS   TEXT("Please contact Microsoft Technical Support for assistance with this problem.")
typedef struct {
	CHAR	CompanyName[256];
	CHAR	SupportNumber[256];
	CHAR	SupportUrl[256];
	CHAR	InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO; 

//
// Name of log file
//
TCHAR g_szLogPath[MAX_PATH];

//
// HINSTANCE of this module
//
HINSTANCE g_hInstance = NULL;


//+--------------------------------------------------------------
//
// Function: LogMessage
//
// Synopsis: Writes a message to a log file, for debugging.
//
//+--------------------------------------------------------------
void
LogMessage(
    LPCTSTR msg,
    DWORD   ErrorCode
	)
{
    TCHAR message[1000];
    lstrcpy(message, msg);

    if (ErrorCode != 0)
    {
        TCHAR err[20];
        _itoa(ErrorCode, err, 16);
        lstrcat(message, err);
    }

	//
	// Open the log file
	//
	HANDLE hLogFile = CreateFile(
		                  g_szLogPath, 
						  GENERIC_WRITE, 
						  FILE_SHARE_READ, 
						  NULL, 
						  OPEN_ALWAYS,
		                  FILE_ATTRIBUTE_NORMAL, 
						  NULL
						  );
	if (hLogFile != INVALID_HANDLE_VALUE)
	{
		//
		// Append the message to the end of the log file
		//
		lstrcat(message, _T("\r\n"));
		SetFilePointer(hLogFile, 0, NULL, FILE_END);
		DWORD dwNumBytes = lstrlen(message) * sizeof(message[0]);
		WriteFile(hLogFile, message, dwNumBytes, &dwNumBytes, NULL);
		CloseHandle(hLogFile);
	}
} // LogMessage


//+-------------------------------------------------------------------------
//
//  Function:    SaveMsmqInfo
//
//  Description: Saves root directory of MSMQ and MSMQ type (dependent
//               or independent client) in a tmp file. This file
//               will later be read during GUI mode, by msmqocm.dll,
//               to get the info.
//
//--------------------------------------------------------------------------
static
LONG
SaveMsmqInfo(
	IN const LPTSTR szMsmqDir,
	IN const BOOL   fDependentClient
	)
{
	//
	// Generate the info file name (under %WinDir%)
	//
	TCHAR szMsmqInfoFile[MAX_PATH];
	GetWindowsDirectory(
		szMsmqInfoFile, 
		sizeof(szMsmqInfoFile)/sizeof(szMsmqInfoFile[0])
		);
	_stprintf(szMsmqInfoFile, TEXT("%s\\%s"), szMsmqInfoFile, MQMIG95_INFO_FILENAME);

	//
	// Open the file for write. First delete old file if exists.
	//
	DeleteFile(szMsmqInfoFile); 
	HANDLE hFile = CreateFile(
		               szMsmqInfoFile, 
					   GENERIC_WRITE, 
					   FILE_SHARE_READ, 
					   NULL, 
					   OPEN_ALWAYS,
					   FILE_ATTRIBUTE_NORMAL, 
					   NULL
					   );
	if (INVALID_HANDLE_VALUE == hFile)
    {
        DWORD gle = GetLastError();
        LogMessage(_T("Failed to open MSMQINFO.TXT for writing, error 0x"), gle);
		return gle;
    }

	//
	// Create MSMQ section and write the info
	//
	TCHAR szBuffer[MAX_STRING_CHARS];
	
	_stprintf(szBuffer, TEXT("[%s]\r\n"), MQMIG95_MSMQ_SECTION);
	DWORD dwNumBytes = lstrlen(szBuffer) * sizeof(TCHAR);
	BOOL bSuccess = WriteFile(hFile, szBuffer, dwNumBytes, &dwNumBytes, NULL);

    DWORD gle = GetLastError();
	if (bSuccess)
	{
		_stprintf(szBuffer, TEXT("%s = %s\r\n"), MQMIG95_MSMQ_DIR, szMsmqDir);
		dwNumBytes = lstrlen(szBuffer) * sizeof(TCHAR);
		bSuccess = WriteFile(hFile, szBuffer, dwNumBytes, &dwNumBytes, NULL);
        gle = GetLastError();
	}
    else
    {
        LogMessage(_T("Failed to write the MSMQ folder in MSMQINFO.TXT, error 0x"), gle);
    }
	
	if (bSuccess)
	{
		_stprintf(szBuffer, TEXT("%s = %s\r\n"), MQMIG95_MSMQ_TYPE,
			fDependentClient ? MQMIG95_MSMQ_TYPE_DEP : MQMIG95_MSMQ_TYPE_IND);
		dwNumBytes = lstrlen(szBuffer) * sizeof(TCHAR);
		bSuccess = WriteFile(hFile, szBuffer, dwNumBytes, &dwNumBytes, NULL);
        gle = GetLastError();
        if (!bSuccess)
            LogMessage(_T("Failed to write the MSMQ type (flavor) in MSMQINFO.TXT, error 0x"), gle);
	}
	
	CloseHandle(hFile);

	return (bSuccess ? ERROR_SUCCESS : gle);

} // SaveMsmqInfo


//+-------------------------------------------------------------------------
//
//  Function:    MqReadRegistryValue
//
//  Description: Reads values from MSMQ registry section
//
//--------------------------------------------------------------------------
static
LONG
MqReadRegistryValue(
    IN     const LPCTSTR szEntryName,
    IN OUT       DWORD   dwNumBytes,
    IN OUT       PVOID   pValueData
	)
{
    TCHAR szMsg[1024];

	// 
	// Parse the entry to detect key name and value name
	//
    TCHAR szKeyName[256] = {_T("")};
    _stprintf(szKeyName, TEXT("%s\\%s"), FALCON_REG_KEY, szEntryName);
    TCHAR *pLastBackslash = _tcsrchr(szKeyName, TEXT('\\'));
    TCHAR szValueName[256] = {_T("")};
	lstrcpy(szValueName, _tcsinc(pLastBackslash));
	lstrcpy(pLastBackslash, TEXT(""));

	//
	// Open the key for read
	//
	HKEY  hRegKey;
	LONG rc = RegOpenKeyEx(
		          HKEY_LOCAL_MACHINE,
				  szKeyName,
				  0,
				  KEY_READ,
				  &hRegKey
				  );
	if (ERROR_SUCCESS != rc)
	{
        lstrcpy(szMsg, _T("Failed to open MSMQ registry key '"));
        lstrcat(szMsg, szKeyName);
        lstrcat(szMsg, _T("', error 0x"));
        LogMessage(szMsg, rc);
		return rc;
	}

	//
	// Get the value data
	//
    rc = RegQueryValueEx( 
		     hRegKey, 
			 szValueName, 
			 0, 
			 NULL,
             (PBYTE)pValueData, 
			 &dwNumBytes
			 );
	if (ERROR_SUCCESS != rc)
	{
        lstrcpy(szMsg, _T("Failed to query MSMQ registry value '"));
        lstrcat(szMsg, szValueName);
        lstrcat(szMsg, _T("', error 0x"));
        LogMessage(szMsg, rc);
		return rc;
	}

    RegCloseKey(hRegKey);
	return ERROR_SUCCESS;

} // MqReadRegistryValue


//+-------------------------------------------------------------------------
//
//  Function:    CheckMsmqAcmeInstalled
//
//  Description: Detetcs\msmq\src\ac\init ACME installation of MSMQ 1.0
//
//--------------------------------------------------------------------------
static
LONG
CheckMsmqAcmeInstalled(
	OUT LPTSTR pszMsmqDir,
	OUT BOOL   *pfDependentClient
	)
{
    TCHAR szMsg[1024];

    //
    // Open ACME registry key for read
    //
    HKEY hKey ;
    LONG rc = RegOpenKeyEx( 
                  HKEY_LOCAL_MACHINE,
                  ACME_KEY,
                  0L,
                  KEY_READ,
                  &hKey 
                  );
	if (rc != ERROR_SUCCESS)
    {
		//
		// MSMQ 1.0 (ACME) not installed. Get out of here.
		//
        LogMessage(_T("Failed to open ACME registry key (assuming MSMQ 1.0 ACME is not installed), error 0x"), rc);
		return ERROR_NOT_INSTALLED;
	}

    //
    // Enumerate the values for the first MSMQ entry.
    //
    DWORD dwIndex = 0 ;
    TCHAR szValueName[MAX_STRING_CHARS] ;
    TCHAR szValueData[MAX_STRING_CHARS] ;
    DWORD dwType ;
    TCHAR *pFile, *p ;
    BOOL  bFound = FALSE;
    do
    {
        DWORD dwNameLen = MAX_STRING_CHARS;
        DWORD dwDataLen = sizeof(szValueData) ;

        rc =  RegEnumValue( 
                  hKey,
                  dwIndex,
                  szValueName,
                  &dwNameLen,
                  NULL,
                  &dwType,
                  (BYTE*) szValueData,
                  &dwDataLen 
                  );
        if (rc == ERROR_SUCCESS)
        {
            assert(dwType == REG_SZ) ; // Must be a string
            pFile = _tcsrchr(szValueData, TEXT('\\')) ;
            if (!pFile)
            {
                //
                // Bogus entry. Must have a backslash. Ignore it.
                //
                continue ;
            }

            p = CharNext(pFile);
            if (OcmStringsEqual(p, ACME_STF_NAME))
            {
                //
                // Found. Cut the STF file name from the full path name.
                //
                _stprintf(
                    szMsg, 
                    _T("The following MSMQ entry was found in the ACME section of the registry: %s"), 
                    szValueData
                    );
                LogMessage(szMsg, 0);
                *pFile = TEXT('\0') ;
                bFound = TRUE;
            }
            else
            {
                pFile = CharNext(pFile) ;
            }

        }
        dwIndex++ ;

    } while (rc == ERROR_SUCCESS) ;
    RegCloseKey(hKey) ;

    if (!bFound)
    {
        //
        // MSMQ entry was not found (there's no ACME installation
		// of MSMQ 1.0 on this machine).
        //
        LogMessage(_T("No MSMQ entry was found in the ACME section of the registry."), 0);
        return ERROR_NOT_INSTALLED;
    }

    //
    // Remove the "setup" subdirectory from the path name.
    //
    pFile = _tcsrchr(szValueData, TEXT('\\')) ;
    p = CharNext(pFile);
    *pFile = TEXT('\0') ;
    if (!OcmStringsEqual(p, ACME_SETUP_DIR_NAME))
    {
        //
        // That could be a problem. It should have been "setup".
        //
        _stprintf(szMsg, 
            _T("Warning: Parsing the MSMQ 1.0 entry in the ACME section of the registry gave '%s,"
            "' while '%s' was expected."),
            p,
            ACME_SETUP_DIR_NAME
            );
        LogMessage(szMsg, 0);
    }

	//
	// Store MSMQ root directory.
	//
    _stprintf(szMsg, _T("The MSMQ 1.0 ACME folder is %s."), szValueData);
    LogMessage(szMsg, 0);
	if (pszMsmqDir)
        lstrcpy(pszMsmqDir, szValueData);

    //
    // Get MSMQ type: Dependent or Independent Client
    //
    DWORD dwMsmqType;
    rc = MqReadRegistryValue(
             MSMQ_ACME_TYPE_REG,
			 sizeof(DWORD),
			 (PVOID) &dwMsmqType
			 );
    if (ERROR_SUCCESS != rc)
    {
        //
        // MSMQ 1.0 (ACME) is installed but MSMQ type is unknown. 
        // Consider ACME installation to be corrupted (not completed successfully).
        //
        LogMessage(_T("Failed to read the MSMQ type (flavor) from the registry, error 0x"), rc);
        return ERROR_NOT_INSTALLED;
    }

	BOOL fDependentClient;
    switch (dwMsmqType)
    {
        case MSMQ_ACME_TYPE_DEP:
        {
            fDependentClient = TRUE;
            break;
        }
        case MSMQ_ACME_TYPE_IND:
        {
			fDependentClient = FALSE;
            break;
        }

        default:
        {
            //
            // Unknown MSMQ 1.0 type
            // Consider ACME installation to be corrupted 
			// (not completed successfully).
			//
            LogMessage(_T("The MSMQ type (flavor) is unknown, error 0x"), dwMsmqType);
            return ERROR_NOT_INSTALLED;
            break;
        }
    }

	//
	// At this point we know that MSMQ 1.0 was installed by ACME,
	// and we got its root dir and type.
	//
    _stprintf(szMsg, _T("The MSMQ 1.0 computer is %s."), 
        fDependentClient ? _T("a dependent client") : _T("an independent client"));
    LogMessage(szMsg, 0);
	if (pfDependentClient)
		*pfDependentClient = fDependentClient;
    return ERROR_SUCCESS;

} // CheckMsmqAcmeInstalled


//+-------------------------------------------------------------------------
//
//  Function:   CheckInstalledComponents
//
//--------------------------------------------------------------------------
static
LONG
CheckInstalledComponents(
	OUT LPTSTR pszMsmqDir,
	OUT BOOL   *pfDependentClient
	)
{
    TCHAR szMsg[1024];

    //
    // Look in MSMQ registry section for InstalledComponents value.
    // If it exists, MSMQ 1.0 (K2) is installed.
    //
	DWORD dwOriginalInstalled;
	LONG rc = MqReadRegistryValue( 
      		      OCM_REG_MSMQ_SETUP_INSTALLED,
				  sizeof(DWORD),
				  (PVOID) &dwOriginalInstalled
				  );

	TCHAR szMsmqDir[MAX_PATH];
	BOOL fDependentClient = FALSE;
    if (ERROR_SUCCESS != rc)
    {
        //
		// MSMQ 1.0 (K2) not installed.
        // Check if MSMQ 1.0 (ACME) is installed.
        //
        LogMessage(_T("MSMQ 1.0 K2 was not found (trying MSMQ 1.0 ACME), error 0x"), rc);
        rc = CheckMsmqAcmeInstalled(szMsmqDir, &fDependentClient);
		if (ERROR_SUCCESS != rc)
		{
			// 
			// MSMQ 1.0 is not installed on this machine.
			// Get out of here.
			//
            LogMessage(_T("MSMQ 1.0 ACME was not found, error 0x"), rc);
			return ERROR_NOT_INSTALLED;
		}
    }
	else 
	{
		//
		// MSMQ 1.0 (K2) is installed. 
		// Get its root directory.
		//
        LogMessage(_T("MSMQ 1.0 K2 was found."), 0);
		rc = MqReadRegistryValue(
			     OCM_REG_MSMQ_DIRECTORY,
				 sizeof(szMsmqDir),
				 (PVOID) szMsmqDir
				 );
		if (ERROR_SUCCESS != rc)
		{
			//
			// MSMQ registry section is messed up. 
			// Consider K2 installation to be corrupt
			// (not completed successfully).
			//
            LogMessage(_T("Failed to read the MSMQ folder from the registry, error 0x"), rc);
			return ERROR_NOT_INSTALLED;
		}
        _stprintf(szMsg, TEXT("The MSMQ folder is %s."), szMsmqDir);
        LogMessage(szMsg, 0);
		
		//
		// Get type of MSMQ (K2): Dependent or Independent Client
		//
		switch (dwOriginalInstalled & OCM_MSMQ_INSTALLED_TOP_MASK)
		{
            case OCM_MSMQ_IND_CLIENT_INSTALLED:
			{
				fDependentClient = FALSE;
				break;
			}
            case OCM_MSMQ_DEP_CLIENT_INSTALLED:
			{
				fDependentClient = TRUE;
				break;
			}
            default:
			{
				//
				// Unexpected MSMQ type.
				// Consider K2 installation to be corrupt
				// (not completed successfully).
				//
                LogMessage(
                    _T("The type of MSMQ computer is unknown, error 0x"), 
                    dwOriginalInstalled & OCM_MSMQ_INSTALLED_TOP_MASK
                    );
				return ERROR_NOT_INSTALLED;
				break;
			}
		}
	}

	//
	// At this point we know that MSMQ 1.0 was installed by
	// ACME or K2, and we got the root dir and type of MSMQ 1.0
	//
	if (pszMsmqDir)
	    lstrcpy(pszMsmqDir, szMsmqDir);
	if (pfDependentClient)
		*pfDependentClient = fDependentClient;

    _stprintf(szMsg, TEXT("The MSMQ computer is %s."), 
        fDependentClient ? TEXT("a dependent client") : TEXT("an independent client"));
    LogMessage(szMsg, 0);

	return ERROR_SUCCESS;

} // CheckInstalledComponents


//+--------------------------------------------------------------
//
// Function: RemoveDirectoryTree
//
// Synopsis: Remove the specified folder including files/subfolders
//
//+--------------------------------------------------------------
void
RemoveDirectoryTree(
    LPCTSTR Directory
    )
{
    TCHAR msg[MAX_PATH * 2] = _T("Removing folder ");
    lstrcat(msg, Directory);
    LogMessage(msg, 0);

    TCHAR szTemplate[MAX_PATH] = _T("");
    lstrcpy(szTemplate, Directory);
    lstrcat(szTemplate, _T("\\*.*"));

    WIN32_FIND_DATA finddata;
    CFindHandle hEnum(FindFirstFile(szTemplate, &finddata));
    
    if (hEnum == INVALID_HANDLE_VALUE)
    {
        RemoveDirectory(Directory);
        return;
    }

    do
    {
        if (finddata.cFileName[0] == _T('.'))
        {
            continue;
        }

        TCHAR FullPath[MAX_PATH] = _T("");
        lstrcpy(FullPath, Directory);
        lstrcat(FullPath, _T("\\"));
        lstrcat(FullPath, finddata.cFileName);

        if (0 != (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            RemoveDirectoryTree(FullPath);
            continue;
        }

        DeleteFile(FullPath);
    }
    while (FindNextFile(hEnum, &finddata));
    
    RemoveDirectory(Directory);

} //RemoveDirectoryTree


//+-------------------------------------------------------------------------
//
//  Function:   RemoveStartMenuShortcuts
//
//  Description: Remove MSMQ shortcuts from the Start menu
//
//--------------------------------------------------------------------------
static
void
RemoveStartMenuShortcuts(
    void
    )
{
    //
    // Default folder of StartMenu/Programs is %windir%\Start Menu\Programs
    //
    TCHAR folder[MAX_PATH];
    GetWindowsDirectory(folder, sizeof(folder)/sizeof(folder[0]));
    lstrcat(folder, _T("\\Start Menu\\Programs"));

    //
    // Read from registry if alternate folder is used
    //
    HKEY hKey;
    LONG rc;
    rc = RegOpenKeyEx(
             HKEY_USERS, 
             _T(".Default\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
             0,
             KEY_READ,
             &hKey
             );
    if (rc != ERROR_SUCCESS)
    {
        LogMessage(_T("Failed to open registry key 'HKEY_USERS\\Default\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders' for read, error 0x"), rc);
    }
    else
    {
        DWORD size = sizeof(folder);
        rc = RegQueryValueEx(hKey, _T("Programs"), NULL, NULL, reinterpret_cast<PBYTE>(folder), &size);
        RegCloseKey(hKey);
        if (rc != ERROR_SUCCESS)
        {
            LogMessage(_T("Failed to query registry value 'HKEY_USERS\\Default\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\Programs' for read, error 0x"), rc);
        }
    }

    //
    // Append MSMQ group subfolder to StartMenu\Programs
    //
    TCHAR MsmqGroup[MAX_PATH] = MSMQ_ACME_SHORTCUT_GROUP;
    MqReadRegistryValue(MSMQ_ACME_SHORTCUT_GROUP, sizeof(MsmqGroup), MsmqGroup);
    lstrcat(folder, _T("\\"));
    lstrcat(folder, MsmqGroup);

    //
    // Remove the entire MSMQ group shortcuts from the start menu
    //
    RemoveDirectoryTree(folder);
    
} // RemoveStartMenuShortcuts


//+-------------------------------------------------------------------------
//
//  Function:   IsWindowsPersonal
//
//  Description: Check if upgrade to Windows Personal
//
//--------------------------------------------------------------------------
static
bool
IsWindowsPersonal(
    LPCTSTR InfFilename
    )
{
    //
    // Open migrate.inf
    //
    HINF hInf = SetupOpenInfFile(InfFilename, NULL, INF_STYLE_WIN4, NULL);
    if (hInf == INVALID_HANDLE_VALUE)
    {
        DWORD err = GetLastError();
        LogMessage(_T("SetupOpenInfFile failed, error 0x"), err);
        return false;
    }

    //
    // Read the SetupSKU key in the [Version] section
    //
    TCHAR buffer[250];
    DWORD size = sizeof(buffer)/sizeof(buffer[0]);
    BOOL rc = SetupGetLineText(NULL, hInf, _T("Version"), _T("SetupSKU"), buffer, size, NULL);

    //
    // Close migrate.inf
    //
    SetupCloseInfFile(hInf);
    
    if (!rc)
    {
        DWORD err = GetLastError();
        LogMessage(_T("SetupGetLineText failed, error "), err);
        return false;
    }

    TCHAR msg[250] = _T("SetupSKU is ");
    lstrcat(msg, buffer);
    LogMessage(msg, 0);

    return (lstrcmp(buffer, _T("Personal")) == 0);

} // IsWindowsPersonal


//+-------------------------------------------------------------------------
//
//  Function:   HandleWindowsPersonal
//
//  Description: Called on upgrade to Windows Personal. Issue compatibility
//               warning.
//
//--------------------------------------------------------------------------
static
LONG
HandleWindowsPersonal(
    LPCTSTR InfFilename
    )
{
    //
    // Register incompatability warning in [Incompatible Messages] section in the form:
    // MessageQueuing="Message Queuing is not supported on Windows XP Personal"
    //
    TCHAR Warning[250];
    LoadString(g_hInstance, IDS_COMPAT_WARNING, Warning, sizeof(Warning)/sizeof(Warning[0]));

    TCHAR Warning1[250] = _T("\"");
    lstrcat(Warning1, Warning);
    lstrcat(Warning1, _T("\""));

    BOOL rc;
    rc = WritePrivateProfileString(_T("Incompatible Messages"), _T("MessageQueuing"), Warning1, InfFilename);
    if (!rc)
    {
        DWORD err = GetLastError();
        LogMessage(_T("WritePrivateProfileString in [Incompatible Messages] failed, error "), err);
        return err;
    }

    //
    // Create a [MessageQueuing] section only for the compatability warning to work.
    // Register one MSMQ file in the [MessageQueuing] section in the form:
    // "C:\Windows\System\MQRT.DLL"=File
    //
    TCHAR SystemDirectory[MAX_PATH];
    GetSystemDirectory(SystemDirectory, sizeof(SystemDirectory)/sizeof(SystemDirectory[0]));
    TCHAR FullFilename[MAX_PATH * 2] = _T("\"");
    lstrcat(FullFilename, SystemDirectory);
    lstrcat(FullFilename, _T("\\MQRT.DLL\""));
    rc = WritePrivateProfileString(_T("MessageQueuing"), FullFilename, _T("File"), InfFilename);
    if (!rc)
    {
        DWORD err = GetLastError();
        LogMessage(_T("WritePrivateProfileString in [MessageQueuing] failed, error "), err);
        return err;
    }

    WritePrivateProfileString(NULL, NULL, NULL, InfFilename);
    return ERROR_SUCCESS;

} // HandleWindowsPersonal


//+-------------------------------------------------------------------------
//
//  Function:   DllMain
//
//--------------------------------------------------------------------------
BOOL 
DllMain(
	IN const HANDLE DllHandle,
    IN const DWORD  Reason,
    IN const LPVOID Reserved 
	)
{
	UNREFERENCED_PARAMETER(Reserved);

    switch( Reason )    
    {
        case DLL_PROCESS_ATTACH:
            
            g_hInstance = (HINSTANCE) DllHandle;

            //
            // Initialize log file
            //
            
            GetWindowsDirectory(g_szLogPath, sizeof(g_szLogPath)/sizeof(g_szLogPath[0]));
            lstrcat(g_szLogPath, TEXT("\\mqw9xmig.log"));
            DeleteFile(g_szLogPath);

            SYSTEMTIME time;
            GetLocalTime(&time);
            TCHAR szTime[MAX_STRING_CHARS];
            _stprintf(szTime, TEXT("  %u-%u-%u %u:%u:%u:%u \r\n"), time.wMonth, time.wDay, time.wYear, time.wHour, time.wMinute,
                time.wSecond, time.wMilliseconds);
            TCHAR szMsg[1024];
            lstrcpy(szMsg, TEXT("MSMQ migration"));
            lstrcat(szMsg, szTime);
            LogMessage(szMsg, 0);
            break; 

        default:
            break;
    }

    return TRUE;

} // DllMain


//+-------------------------------------------------------------------------
//
//  Function:   QueryVersion
//
//--------------------------------------------------------------------------
LONG
CALLBACK 
QueryVersion(
	OUT LPCSTR *ProductID,
	OUT LPUINT DllVersion,
	OUT LPINT *CodePageArray,	OPTIONAL
	OUT LPCSTR *ExeNamesBuf,	OPTIONAL
	OUT PVENDORINFO *VendorInfo
	)
{
    static CHAR	ProductIDBuff[256];
    if (0 == LoadString(g_hInstance, IDS_PRODUCT_ID, ProductIDBuff, sizeof(ProductIDBuff)/sizeof(TCHAR)))
    {
        lstrcpy(ProductIDBuff, PRODUCT_ID);
    }
    *ProductID = ProductIDBuff;

    *DllVersion = 1;
	*CodePageArray = NULL;
	*ExeNamesBuf = NULL;

    static VENDORINFO MyVendorInfo;
    if (0 == LoadString(g_hInstance, IDS_COMPANY, MyVendorInfo.CompanyName, sizeof(MyVendorInfo.CompanyName)/sizeof(TCHAR)))
    {
        lstrcpy(MyVendorInfo.CompanyName, COMPANY);
    }
    if (0 == LoadString(g_hInstance, IDS_SUPPORT_NUMBER, MyVendorInfo.SupportNumber, sizeof(MyVendorInfo.SupportNumber)/sizeof(TCHAR)))
    {
        lstrcpy(MyVendorInfo.SupportNumber, SUPPORT_NUMBER);
    }

    lstrcpy(MyVendorInfo.SupportUrl, SUPPORT_URL);

    if (0 == LoadString(g_hInstance, IDS_INSTRUCTIONS, MyVendorInfo.InstructionsToUser, sizeof(MyVendorInfo.InstructionsToUser)/sizeof(TCHAR)))
    {
        lstrcpy(MyVendorInfo.InstructionsToUser, INSTRUCTIONS);
    }	
    *VendorInfo = &MyVendorInfo;

    return CheckInstalledComponents(NULL, NULL);

} // QueryVersion 


//+-------------------------------------------------------------------------
//
//  Function:   Initialize9x 
//
//--------------------------------------------------------------------------
LONG
CALLBACK 
Initialize9x(
    LPCSTR WorkingDirectory,
    LPCSTR /*SourceDirectories*/,
    LPCSTR /*MediaDirectory*/
    )
{
    //
    // If MSMQ not installed do nothing
    //
	TCHAR MsmqDirectory[MAX_PATH];
	BOOL  fDependentClient;
    LONG rc = CheckInstalledComponents(MsmqDirectory, &fDependentClient);
    if (rc != ERROR_SUCCESS)
	{
        return rc;
    }

    //
    // Remove MSMQ from the Start menu
    //
    RemoveStartMenuShortcuts();
    
    //
    // Generate full filename for migrate.inf
    //
    TCHAR InfFilename[MAX_PATH];
    lstrcpy(InfFilename, WorkingDirectory);
    lstrcat(InfFilename, _T("\\migrate.inf"));

    //
    // For Windows Personal: generate compatibility warning so the user can decide
    // to cancel or proceed the OS upgrade.
    // Return without saving MSMQ information for later use by msmqocm.dll,
    // thus effectively MSMQ will be uninstalled if user proceeds with the upgrade.
    //
    if (IsWindowsPersonal(InfFilename))
    {
        rc = HandleWindowsPersonal(InfFilename);
        if (rc != ERROR_SUCCESS)
        {
            return rc;
        }

        return ERROR_SUCCESS;
    }

    //
    // Save MSMQ registry information for later use by msmqocm.dll (which handles
    // MSMQ upgrade).
    //
	rc = SaveMsmqInfo(MsmqDirectory, fDependentClient);
    if (rc != ERROR_SUCCESS)
    {
        return rc;
    }

    return ERROR_SUCCESS;

} // Initialize9x

	
//+-------------------------------------------------------------------------
//
//  Function:   MigrateUser9x
//
//--------------------------------------------------------------------------
LONG
CALLBACK 
MigrateUser9x(
    HWND, 
    LPCSTR,
    HKEY, 
    LPCSTR, 
    LPVOID
    )
{
    return ERROR_SUCCESS;

} // MigrateUser9x


//+-------------------------------------------------------------------------
//
//  Function:   MigrateSystem9x 
//
//--------------------------------------------------------------------------
LONG 
CALLBACK 
MigrateSystem9x(
    HWND, 
    LPCSTR,
    LPVOID
    )
{
	return ERROR_SUCCESS;

} // MigrateSystem9x 


//+-------------------------------------------------------------------------
//
//  Function:   InitializeNT 
//
//--------------------------------------------------------------------------
LONG
CALLBACK 
InitializeNT(
    LPCWSTR,
    LPCWSTR,
    LPVOID
    )
{
	return ERROR_SUCCESS;

} // InitializeNT


//+-------------------------------------------------------------------------
//
//  Function:   MigrateUserNT 
//
//--------------------------------------------------------------------------
LONG
CALLBACK 
MigrateUserNT(
    HINF,
    HKEY,
    LPCWSTR, 
    LPVOID
    )
{
	return ERROR_SUCCESS;

} // MigrateUserNT


//+-------------------------------------------------------------------------
//
//  Function:   MigrateSystemNT 
//
//--------------------------------------------------------------------------
LONG
CALLBACK 
MigrateSystemNT(
    HINF,
    LPVOID
    )
{
	return ERROR_SUCCESS;

} // MigrateSystemNT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\cluster\cluscfg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      cluscfg.cpp
//
//  Description:
//      This file contains the implementation of the CClusCfgMQTrigResType
//      class.
//
//  Header File:
//      cluscfg.h
//
//  Maintained By:
//      Nela Karpel (nelak) 17-OCT-2000
//
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Include Files
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "trigres.h"
#include "cluscfg.h"
#include <clusapi.h>
#include <initguid.h>
#include <comdef.h>
#include <mqtg.h>
#include "autorel3.h"

extern HMODULE	g_hResourceMod;


// {031B4FB7-2C82-461a-95BB-EA7EFE2D03E7}
DEFINE_GUID( TASKID_Minor_Configure_My_Resoure_Type, 
0x031B4FB7, 0x2C82, 0x461a, 0x95, 0xBB, 0xEA, 0x7E, 0xFE, 0x2D, 0x03, 0xE7);


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgMQTrigResType::FinalConstruct()
//
//  Description:
//      ATL Constructor of the CClusCfgMQTrigResType class. This initializes
//      the member variables
//
//  Arguments:
//      None.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed. In this case, the object is destoryed.
//
//  Remarks:
//      None.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::FinalConstruct( void )
{
    m_lcid = LOCALE_SYSTEM_DEFAULT;

    return S_OK;

} // CClusCfgMQTrigResType::FinalConstruct()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgInitialize]
//  CClusCfgMQTrigResType::Initialize()
//
//  Description:
//      Initialize this component. This function is called by the cluster
//      configuration server to provide this object with a pointer to the 
//      callback interface (IClusCfgCallback) and with its locale id.
//
//  Arguments:
//      punkCallbackIn
//          Pointer to the IUnknown interface of a component that implements
//          the IClusCfgCallback interface.
//
//      lcidIn
//          Locale id for this component.
//
//  Return Value:
//      S_OK
//          If the call succeeded
//
//      Other HRESULTs
//          If the call failed.
//
//--
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CClusCfgMQTrigResType::Initialize(
      IUnknown *   punkCallbackIn,
	  LCID         lcidIn
    )
{
    m_lcid = lcidIn;

	if ( punkCallbackIn == NULL )
	{
		return S_OK;
	}

	//
    // Query for the IClusCfgCallback interface.
	//
    HRESULT hr;
    IClusCfgCallback * pcccCallback = NULL;

    hr = punkCallbackIn->QueryInterface( __uuidof( pcccCallback ), reinterpret_cast< void ** >( &pcccCallback ) );
    if ( SUCCEEDED( hr ) )
    {
		//
        // Store the pointer to the IClusCfgCallback interface in the member variable.
        // Do not call pcccCallback->Release()
		//
        m_cpcccCallback.Attach( pcccCallback );
    }

    return hr;

} // CClusCfgMQTrigResType::Initialize()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgResourceTypeInfo]
//  CClusCfgMQTrigResType::CommitChanges()
//
//  Description:
//      This method is called to inform a component that this node has either
//      formed, joined or left a cluster. During this call, a component typically
//      performs operations that are required to configure this resource type.
//
//      If the node has just become part of a cluster, the cluster
//      service is guaranteed to be running when this method is called.
//      Querying the punkClusterInfoIn allows the resource type to get more
//      information about the event that caused this method to be called.
//
//  Arguments:
//      punkClusterInfoIn
//          The resource should QI this interface for services provided
//          by the caller of this function. Typically, the component that
//          this punk refers to also implements the IClusCfgClusterInfo
//          interface.
//
//      punkResTypeServicesIn
//          Pointer to the IUnknown interface of a component that provides
//          methods that help configuring a resource type. For example, 
//          during a join or a form, this punk can be queried for the 
//          IClusCfgResourceTypeCreate interface, which provides methods 
//          for resource type creation.
//
//  Return Values:
//      S_OK
//          Success.
//
//      other HRESULTs.
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::CommitChanges(
      IUnknown * punkClusterInfoIn,
	  IUnknown * punkResTypeServicesIn
    )
{
    HRESULT     hr = S_OK;
    CComBSTR    bstrStatusReportText( L"An error occurred trying to load the status report text" );

	//
    // Dummy do-while loop to avoid gotos - we 'break' out of this loop if an error occurs
	//
    do
    {
		//
        // Set the thread locale.
		//
        SetThreadLocale( m_lcid );

        //
        // Validate parameters
        //
        if ( ( punkClusterInfoIn == NULL ) || ( punkResTypeServicesIn == NULL ) )
        {
            hr = E_POINTER;
            break;
        }

		//
        // Load the status report text first
		//
        if ( !bstrStatusReportText.LoadString( g_hResourceMod, IDS_CONFIGURING_RESOURCE_TYPE ) )
        {
            hr = E_UNEXPECTED;
            break;
        }

		//
        // Send a status report up to the UI.
		//
        if ( m_cpcccCallback != NULL )
        {
            hr = m_cpcccCallback->SendStatusReport(
									NULL,
									TASKID_Major_Configure_Resource_Types,
									TASKID_Minor_Configure_My_Resoure_Type,
									0,
									1,
									0,
									hr,
									bstrStatusReportText,
									NULL,
									L""
									);
			if ( FAILED( hr ) )
			{
				break;
			}
        }


        //
        // Find out what event caused this call.
        //
        CComQIPtr<IClusCfgClusterInfo> cpClusterInfo(punkClusterInfoIn);

		ECommitMode commitMode;
        hr = cpClusterInfo->GetCommitMode(&commitMode);

        if ( FAILED(hr) )
        {
            break;
        }


		CComQIPtr< IClusCfgResourceTypeCreate >     cpResTypeCreate( punkResTypeServicesIn );
		
		switch (commitMode)
		{
			case cmCREATE_CLUSTER:
			case cmADD_NODE_TO_CLUSTER:
				
				//
				// If we are forming or joining, create our resource type.
				//

				hr = S_HrCreateResType( cpResTypeCreate );
				
				break;

			case cmCLEANUP_NODE_AFTER_EVICT:

				//
				// By default, no resource type specific processing need be done during eviction.
				//
				break;

			default:

                hr = E_UNEXPECTED;
                break;
        }
    }
    while( false );

	//
    // Complete the status report
	//
    if ( m_cpcccCallback != NULL )
    {
        HRESULT hrTemp = m_cpcccCallback->SendStatusReport(
											NULL,
											TASKID_Major_Configure_Resource_Types,
											TASKID_Minor_Configure_My_Resoure_Type,
											0,
											1,
											1,
											hr,
											bstrStatusReportText,
											NULL,
											L""
											);

        if ( FAILED(hrTemp) && hr == S_OK )
        {
			hr = hrTemp;
        }
    }

    return hr;

} // CClusCfgMQTrigResType::CommitChanges()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgResourceTypeInfo]
//  CClusCfgMQTrigResType::GetTypeName()
//
//  Description:
//      Get the resource type name of this resource type.
//
//  Arguments:
//      pbstrTypeNameOut
//          Pointer to the BSTR that holds the name of the resource type.
//          This BSTR has to be freed by the caller using the function
//          SysFreeString().
//
//  Return Values:
//      S_OK
//          The call succeeded.
//
//      E_OUTOFMEMORY
//          Out of memory.
//
//      other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::GetTypeName( BSTR * pbstrTypeNameOut )
{
    if ( pbstrTypeNameOut == NULL )
    {
        return E_POINTER;
    } 

    *pbstrTypeNameOut = SysAllocString( xTriggersResourceType );
    if ( *pbstrTypeNameOut == NULL )
    {
        return E_OUTOFMEMORY;
    } 

    return S_OK;

} // CClusCfgMQTrigResType::GetTypeName()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgResourceTypeInfo]
//  CClusCfgMQTrigResType::GetTypeGUID()
//
//  Description:
//       Get the globally unique identifier of this resource type.
//
//  Arguments:
//       pguidGUIDOut
//           Pointer to the GUID object which will receive the GUID of this
//           resource type.
//
//  Return Values:
//      S_OK
//          The call succeeded and the *pguidGUIDOut contains the type GUID.
//
//      S_FALSE
//          The call succeeded but this resource type does not have a GUID.
//          The value of *pguidGUIDOut is undefined after this call.
//
//      other HRESULTs
//          The call failed.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::GetTypeGUID( GUID * /*pguidGUIDOut*/ )
{
	//
	// No GUID associated with Triggers cluster resource type
	//
    return S_FALSE;

} // CClusCfgMQTrigResType::GetTypeGUID()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  [IClusCfgStartupListener]
//  CClusCfgMQTrigResType::Notify()
//
//  Description:
//      This method is called by the cluster service to inform a component
//      that the cluster service has started on this computer. If this DLL
//      was installed when this computer was part of a cluster, but when
//      the cluster service was not running, the resource type can be created
//      during this method call.
//
//      This method also deregisters from further cluster startup notifications,
//      since the tasks done by this method need be done only once.
//
//  Arguments:
//      IUnknown * punkIn
//          The component that implements this punk may also provide services
//          that are useful to the implementor of this method. For example,
//          this component usually implements the IClusCfgResourceTypeCreate
//          interface.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::Notify( IUnknown * punkIn )
{
    //
    // Validate parameters
    //
    if ( punkIn == NULL ) 
    {
        return E_POINTER;
    } 

	//
    // Set the thread locale.
	//
    SetThreadLocale( m_lcid );

	//
    // Create our resource type.
	//
    CComQIPtr<IClusCfgResourceTypeCreate> cpResTypeCreate( punkIn );

    HRESULT hr = S_HrCreateResType( cpResTypeCreate );
    if ( FAILED(hr) )
    {
        return hr;
    }

	//
    // Unregister from cluster startup notifications, now that our resource type has
    // been created.
	//
    hr = S_HrRegUnregStartupNotifications( false ); // false means unregister from startup notifications

    return hr;

} // CClusCfgMQTrigResType::Notify()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgMQTrigResType::S_HrCreateResType()
//
//  Description:
//      This method creates this resource type and registers its admin extension.
//
//  Arguments:
//      IClusCfgResourceTypeCreate * pccrtResTypeCreateIn
//          Pointer to the IClusCfgResourceTypeCreate interface, which helps create
//          a resource type.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::S_HrCreateResType( IClusCfgResourceTypeCreate * pccrtResTypeCreateIn )
{
    //
    // Validate parameters
    //
    if ( pccrtResTypeCreateIn == NULL )
    {
        return E_POINTER;
    }

	//
    // Load the display name for this resource type.
	//
	CComBSTR bstrMyResoureTypeDisplayName;
    if ( !bstrMyResoureTypeDisplayName.LoadString(g_hResourceMod, IDS_DISPLAY_NAME) )
    {
        return E_UNEXPECTED;
    }

	//
    // Create the resource type
	//
    HRESULT hr = pccrtResTypeCreateIn->Create(
											xTriggersResourceType,
											bstrMyResoureTypeDisplayName,
											RESOURCE_TYPE_DLL_NAME,
											RESOURCE_TYPE_LOOKS_ALIVE_INTERVAL,
											RESOURCE_TYPE_IS_ALIVE_INTERVAL
											);

	return hr;

} // CClusCfgMQTrigResType::S_HrCreateResType()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgMQTrigResType::S_HrRegUnregStartupNotifications()
//
//  Description:
//      This method either registers or unregisters this component for cluster
//      startup notifications.
//
//  Arguments:
//      bool fRegisterIn
//          If true this component is registered as belonging to the
//          CATID_ClusCfgStartupListeners category. Otherwise, it unregisters this
//          component from that category.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::S_HrRegUnregStartupNotifications( bool fRegisterIn )
{
	//
    // Create the COM component categories manager.
	//
    HRESULT hr;
    CComQIPtr<ICatRegister> cpcrCatReg;

    hr = cpcrCatReg.CoCreateInstance(
						CLSID_StdComponentCategoriesMgr,
						NULL,
						CLSCTX_INPROC_SERVER
						);
    
    if ( FAILED(hr) )
    {
        return hr;
    }

	//
	// Register/Unregister implemented categories
	//
    CATID rgCatId[1];
    rgCatId[0] = CATID_ClusCfgStartupListeners;
    if ( fRegisterIn )
    {
        hr = cpcrCatReg->RegisterClassImplCategories(
							CLSID_ClusCfgMQTrigResType,
							sizeof( rgCatId ) / sizeof( rgCatId[ 0 ] ),
							rgCatId
							);
    }
    else
    {
        hr = cpcrCatReg->UnRegisterClassImplCategories(
							CLSID_ClusCfgMQTrigResType,
							sizeof( rgCatId ) / sizeof( rgCatId[ 0 ] ),
							rgCatId
							);
    }
    
    return hr;

} // CClusCfgMQTrigResType::S_HrRegUnregStartupNotifications()


//////////////////////////////////////////////////////////////////////////////
//++
//
//  CClusCfgMQTrigResType::UpdateRegistry()
//
//  Description:
//      This method is called by the ATL framework to register or unregister
//      this component. Note, the name of this method should not be changed
//      as it is called by the framework.
//
//  Arguments:
//      BOOL bRegister
//          If TRUE, this component needs to be registered. It needs to be
//          unregistered otherwise.
//
//  Return Values:
//      S_OK
//          Success.
//
//      Other HRESULTs
//          The call failed.
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT
CClusCfgMQTrigResType::UpdateRegistry( BOOL bRegister )
{
	HRESULT hr;

    if ( bRegister )
    {
        hr = _Module.UpdateRegistryFromResourceD( IDR_ClusCfgMQTrigResType, bRegister );
        if ( FAILED( hr ) )
        {
           return hr;
        }

		//
        // Check if this node is already part of a cluster.
		//
        DWORD dwError;
        DWORD dwClusterState;

        dwError = GetNodeClusterState( NULL, &dwClusterState );
        if ( dwError != ERROR_SUCCESS )
        {
            hr = HRESULT_FROM_WIN32( dwError );
            return hr;
        }

        if ( dwClusterState == ClusterStateNotRunning )
        {
			//
            // If this node is already part of a cluster, but the cluster service is not running,
            // register for cluster startup notifications, so that we can create our resource type
            // the next time the cluster service starts.
			//
            hr = S_HrRegUnregStartupNotifications( true ); // true means register for startup notifications
			if ( FAILED(hr) )
			{
				return hr;
			}

        }
        else if ( dwClusterState == ClusterStateRunning )
        {
			//
            // The cluster service is running on this node. Create our resource type and register
            // our admin extension now!
			//
            CAutoCluster hCluster( OpenCluster(NULL) );

            if(hCluster == NULL)
            {
               return HRESULT_FROM_WIN32(GetLastError());
            }

            WCHAR szMyResourceTypeDisplayName[256] = L"";
            LoadString(g_hResourceMod, IDS_DISPLAY_NAME, szMyResourceTypeDisplayName, TABLE_SIZE(szMyResourceTypeDisplayName));
            
            hr = CreateClusterResourceType(
                    hCluster,
                    xTriggersResourceType,
                    szMyResourceTypeDisplayName,
                    RESOURCE_TYPE_DLL_NAME,
                    RESOURCE_TYPE_LOOKS_ALIVE_INTERVAL,
                    RESOURCE_TYPE_IS_ALIVE_INTERVAL
                    );
                                            
            if ( FAILED(hr) )
            {
                return hr;
            }
        }
        
        // If the node is not part of a cluster, this component will be notified when it becomes part
        // of one, so there is nothing more that need be done here.
        
    }

    else
    {
        hr = S_HrRegUnregStartupNotifications( false ); // false means unregister from startup notifications
        if ( FAILED( hr ) )
        {
            return hr;
        }

        hr = _Module.UpdateRegistryFromResourceD( IDR_ClusCfgMQTrigResType, bRegister );
        if ( FAILED( hr ) )
        {
            return hr;
        }
    }

    return S_OK;

} // CClusCfgMQTrigResType::UpdateRegistry()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\cluster\stdafx.cpp ===
//  stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\cluster\stdafx.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    stdafx.h

Abstract:

    Main header file

Author:

    Nela Karpel (nelak) Jul 31, 2000

Revision History:

--*/

#ifndef _TRIGCLUS_STDH_H_
#define _TRIGCLUS_STDH_H_

#pragma once

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#undef _DEBUG

#include <libpch.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <ClusCfgGuids.h>
#include <clusapi.h>
#include <resapi.h>

#endif // _TRIGCLUS_STDH_H_

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\cluster\trigres.cpp ===
// trigres.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for ResourceType.idl by adding the following 
//      files to the Outputs.
//          ResourceType_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f ResourceTypeps.mk in the project directory.

#include "stdafx.h"
#include "tclusres.h"
#include "trigres.h"
#include "cluscfg.h"
#include <cm.h>


CComModule _Module;
extern HMODULE	g_hResourceMod;


BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ClusCfgMQTrigResType, CClusCfgMQTrigResType)
END_OBJECT_MAP()


extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /* lpReserved */)
{

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_RESOURCETYPELib);

        DisableThreadLibraryCalls(hInstance);
		
		CmInitialize(HKEY_LOCAL_MACHINE, L"", KEY_ALL_ACCESS);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
        _Module.Term();
	}

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\cluster\trigclusp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    TrigClusp.h

Abstract:

    Header for internal routines

Author:

    Nela Karpel ( nelak ) 27 Jul 2000

Revision History:

--*/

#ifndef _TRIGCLUSP_H_
#define _TRIGCLUSP_H_

#include <autorel2.h>
#include <autorel3.h>
#include "mqnames.h"



extern HMODULE	g_hResourceMod;
extern PLOG_EVENT_ROUTINE           g_pfLogClusterEvent;
extern PSET_RESOURCE_STATUS_ROUTINE g_pfSetResourceStatus;
extern CLRES_FUNCTION_TABLE         g_MqclusFunctionTable;

const WCHAR xMSMQ[] = L"MSMQ";
const WCHAR xNetworkName[] = L"Network Name";

const WCHAR xEventLogRegPath[] = L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\";
const WCHAR xTriggersEventSourceFile[] = MQUTIL_DLL_NAME;

//
// CTrigResource - Holds information of a single resource 
//
class CTrigResource
{

public:
	CTrigResource(LPCWSTR, RESOURCE_HANDLE);
	~CTrigResource(){};

	void CreateRegistryForEventLog();
	void DeleteRegistryForEventLog();

	RESID GetResId(VOID) const { return m_ResId; };
    LPCWSTR GetResourceName(VOID) const { return m_pwzResourceName; };
	LPCWSTR GetServiceName(VOID) const { return m_wzServiceName; }; 
    RESOURCE_HANDLE GetReportHandle(VOID) const { return m_hReport; };

    BOOL CheckIsAlive(VOID) const;
    
	DWORD AddRemoveRegistryCheckpoint(DWORD) const;

    DWORD BringOnline(VOID);
	DWORD StopService(LPCWSTR) const;
    DWORD RemoveService(LPCWSTR) const;

    VOID DeleteTrigRegSection(VOID);
    
	VOID SetState(CLUSTER_RESOURCE_STATE s) { m_ResourceStatus.ResourceState = s; };
    inline VOID ReportState(VOID) const;

	CLUS_WORKER m_OnlineThread;

private:
	DWORD ReportLastError(DWORD, LPCWSTR, LPCWSTR) const;
	
	bool IsResourceOfType(LPCWSTR, LPCWSTR);
	
	DWORD SetServiceEnvironment(VOID) const;
	DWORD QueryResourceDependencies(VOID);
	DWORD RegisterService(VOID) const;
	DWORD StartService(VOID) const;

	DWORD ClusterResourceControl(LPCWSTR, DWORD, LPBYTE*, DWORD*) const;

	VOID  RegDeleteTree(HKEY, LPCWSTR) const;


private:
	RESID                     m_ResId;
    AP<WCHAR>                 m_pwzResourceName; 
	WCHAR                     m_wzServiceName[200];
    WCHAR                     m_wzTrigRegSection[200 + 100];
    mutable RESOURCE_STATUS   m_ResourceStatus;

    RESOURCE_HANDLE           m_hReport;
	CServiceHandle            m_hScm;
	CAutoCluster              m_hCluster;
    CClusterResource          m_hResource;


}; //class CTrigResource


DWORD
TrigCluspStartup(
    VOID
    );


RESID
TrigCluspOpen(
    LPCWSTR pwzResourceName,
    RESOURCE_HANDLE hResourceHandle
    );


VOID
TrigCluspClose(
    CTrigResource * pTrigRes
    );


DWORD
TrigCluspOnlineThread(
    CTrigResource * pTrigRes
    );


DWORD
TrigCluspOffline(
    CTrigResource * pTrigRes
    );


BOOL
TrigCluspCheckIsAlive(
    CTrigResource * pTrigRes
    );


DWORD
TrigCluspClusctlResourceGetRequiredDependencies(
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    );


DWORD
TrigCluspClusctlResourceSetName(
    VOID
    );


DWORD
TrigCluspClusctlResourceDelete(
    CTrigResource * pTrigRes
    );


DWORD
TrigCluspClusctlResourceTypeGetRequiredDependencies(
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    );

#endif //_TRIGCLUSP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\cluster\cluscfg.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      cluscfg.h
//
//  Description:
//      This file contains the declaration of the class CClusCfgMQTrigResType.
//
//  Maintained By:
//      Nela Karpel (nelak) 17-OCT-2000
//
//////////////////////////////////////////////////////////////////////////////


#pragma once


//////////////////////////////////////////////////////////////////////////////
//  Include Files
//////////////////////////////////////////////////////////////////////////////

#include <atlbase.h>        // for CComPtr
#include <ClusCfgGuids.h>   // for the CATID guids
#include "tclusres.h"       // main symbols


const WCHAR RESOURCE_TYPE_DLL_NAME[] = L"mqtgclus.dll";		// name of the resource type dll
const DWORD RESOURCE_TYPE_LOOKS_ALIVE_INTERVAL = 5000;		// looks-alive interval in milliseconds
const DWORD RESOURCE_TYPE_IS_ALIVE_INTERVAL = 60000;		// is-alive interval in milliseconds


//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CClusCfgMQTrigResType
//
//  Description:
//      This class encapsulates the functionality that a resource type needs
//      to participate in the management (creation, deletion, etc.) of the resource 
//      type when the local node forms, joins or leaves a cluster.
//
//      When the COM components in this DLL are registered (during the call to
//      DllRegisterServer()), this class specifies that it implements the
//      CATID_ClusCfgResourceTypes component category. As a result, whenever
//      a cluster is formed on this node, this node joins a cluster or this node
//      is evicted from a cluster, an object of this class is created by the
//      cluster configuration server, and its IClusCfgResourceTypeInfo::CommitChanges()
//      method is called. This method can then perform the actions required to
//      configure this cluster resource type.
//
//      If this DLL is registered when this node is already part of a cluster, but
//      when the cluster service is not running (this is the case if GetNodeClusterState()
//      returns ClusterStateNotRunning), then this class also registers for the 
//      CATID_ClusCfgStartupListeners category. As a result, when the cluster
//      service starts on this node, an object of this class is created and 
//      the IClusCfgStartupListener::Notify() method is called. This method
//      creates this resource type and deregisters from further cluster
//      startup notifications.
//
//      If this DLL is registered when the cluster service is running on this
//      node, the cluster resource type is created in the UpdateRegistry() method
//      of this class.
//
//--
//////////////////////////////////////////////////////////////////////////////
class CClusCfgMQTrigResType :
	public IClusCfgInitialize,
	public IClusCfgResourceTypeInfo,
	public IClusCfgStartupListener,
	public CComObjectRoot,
	public CComCoClass< CClusCfgMQTrigResType, &CLSID_ClusCfgMQTrigResType >
{
public:

    // C++ constructor
    CClusCfgMQTrigResType() {}

    // ATL constructor
    HRESULT
        FinalConstruct( void );

    // ATL interface map
    BEGIN_COM_MAP(CClusCfgMQTrigResType)
	    COM_INTERFACE_ENTRY(IClusCfgInitialize)
	    COM_INTERFACE_ENTRY(IClusCfgResourceTypeInfo)
	    COM_INTERFACE_ENTRY(IClusCfgStartupListener)
    END_COM_MAP()

    // This class cannot be aggregated
    DECLARE_NOT_AGGREGATABLE(CClusCfgMQTrigResType) 

    // Registers this class as implementing the following categories
    BEGIN_CATEGORY_MAP( CClusCfgMQTrigResType )
        IMPLEMENTED_CATEGORY( CATID_ClusCfgResourceTypes )
    END_CATEGORY_MAP()

public:
    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgInitialize methods
    //////////////////////////////////////////////////////////////////////////

    // Initialize this object.
    STDMETHOD( Initialize )(
		IUnknown *   punkCallbackIn,
		LCID         lcidIn
		);


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgResourceTypeInfo methods
    //////////////////////////////////////////////////////////////////////////

    // Indicate that the resource type configuration needs to be performed.
    STDMETHOD( CommitChanges )(
		IUnknown * punkClusterInfoIn,
		IUnknown * punkResTypeServicesIn
        );

    // Get the resource type name of this resource type.
    STDMETHOD( GetTypeName )(
        BSTR *  pbstrTypeNameOut
        );

    // Get the globally unique identifier of this resource type.
    STDMETHOD( GetTypeGUID )(
        GUID * pguidGUIDOut
        );


    //////////////////////////////////////////////////////////////////////////
    //  IClusCfgStartupListener methods
    //////////////////////////////////////////////////////////////////////////

    // Do the tasks that need to be done when the cluster service starts on this
    // computer.
    STDMETHOD( Notify )(
          IUnknown * punkIn
        );


    //////////////////////////////////////////////////////////////////////////
    //  Other public methods
    //////////////////////////////////////////////////////////////////////////

    // Create this resource type and register its admin extension.
    static HRESULT
        S_HrCreateResType( IClusCfgResourceTypeCreate * pccrtResTypeCreateIn );

    // Register or unregister from cluster startup notifications.
    static HRESULT
        S_HrRegUnregStartupNotifications( bool fRegisterIn );


    // Function called by ATL framework to register this component.
    static HRESULT WINAPI
        UpdateRegistry( BOOL bRegister );


private:
    //////////////////////////////////////////////////////////////////////////
    //  Private member variables
    //////////////////////////////////////////////////////////////////////////

    // Locale id
    LCID m_lcid;

    // Pointer to the callback interface
    CComPtr<IClusCfgCallback> m_cpcccCallback;

}; // class CClusCfgMQTrigResType
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\cluster\trigres_i_.c ===
#include <trigres_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\include\compl.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Compl.h

Abstract:
    Trigger COM+ component registration

Author:
    Uri Habusha (urih) 10-Apr-00

--*/

#pragma once

#ifndef __Compl_H__
#define __Compl_H__

//
// Global const definition
//
const DWORD xMaxTimeToNextReport=3000;

//
// Registration in COM+ function
//
HRESULT 
RegisterComponentInComPlusIfNeeded(
	BOOL fAtStartup
	);

HRESULT
UnregisterComponentInComPlus(
	VOID
	);

bool
NeedToRegisterComponent(
	VOID
	);

#endif // __Compl_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\include\cinputparams.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	CInputParams.h

Abstract:
    CInputParams definition
	This class takes the arguments from the command line
    and puts them into a container. You can get each
    argument by calling CInputParams[] operator. 
	You can find if argument exists by calling IsOptionGiven.
	(each argument may be given only once)
	The format of an argument may be:
	/command:value  (no spaces)
	/command

Author:
   Ofer Gigi		
   Yifat Peled 31-Aug-98

--*/

        
#ifndef _CINPUT_PARAMS_H
#define _CINPUT_PARAMS_H



using namespace std;


class CInputParams     
{    
public:  
    CInputParams(int argc, WCHAR *argv[]);
    CInputParams(const wstring& wcs);
    virtual ~CInputParams(){};
    bool IsOptionGiven(const wstring& wcsOption)const;
    wstring operator[](const wstring& wcsOption);
	    
private:
    void ParseToken(const wstring& wcsToken,
					wstring::size_type tokenstart,
					wstring::size_type tokenfinish);

	wstring Covert2Upper(const wstring& wcs)const;

	map<wstring, wstring> m_InputParams;
};    

  
#endif //_CINPUT_PARAMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\cluster\trigclus.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      trigclus.cpp
//
//  Description:
//      This file contains the implementation of the CClusCfgMQTrigResType
//      class.
//
//  Maintained By:
//      Nela Karpel (nelak) 31-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "tclusres.h"
#include "trigclusp.h"
#include <comdef.h>
#include <mqtg.h>
#include "_mqres.h"


//
// Load the mqutil resource only DLL first
//
HMODULE	g_hResourceMod = MQGetResourceHandle();


// Event Logging routine.

PLOG_EVENT_ROUTINE g_pfLogClusterEvent = NULL;

// Resource Status routine for pending Online and Offline calls.

PSET_RESOURCE_STATUS_ROUTINE g_pfSetResourceStatus = NULL;

// Forward reference to our RESAPI function table.

extern CLRES_FUNCTION_TABLE g_TrigClusFunctionTable;

//
// TrigClus resource read-write private properties.
//
RESUTIL_PROPERTY_ITEM
TrigClusResourcePrivateProperties[] = {
    { 0 }
};



DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Startup the resource DLL. This routine verifies that at least one
    currently supported version of the resource DLL is between
    MinVersionSupported and MaxVersionSupported. If not, then the resource
    DLL should return ERROR_REVISION_MISMATCH.

    If more than one version of the resource DLL interface is supported by
    the resource DLL, then the highest version (up to MaxVersionSupported)
    should be returned as the resource DLL's interface. If the returned
    version is not within range, then startup fails.

    The ResourceType is passed in so that if the resource DLL supports more
    than one ResourceType, it can pass back the correct function table
    associated with the ResourceType.

Arguments:

    ResourceType - The type of resource requesting a function table.

    MinVersionSupported - The minimum resource DLL interface version 
        supported by the cluster software.

    MaxVersionSupported - The maximum resource DLL interface version
        supported by the cluster software.

    SetResourceStatus - Pointer to a routine that the resource DLL should 
        call to update the state of a resource after the Online or Offline 
        routine returns a status of ERROR_IO_PENDING.

    LogEvent - Pointer to a routine that handles the reporting of events 
        from the resource DLL. 

    FunctionTable - Returns a pointer to the function table defined for the
        version of the resource DLL interface returned by the resource DLL.

Return Value:

    ERROR_SUCCESS - The operation was successful.

    ERROR_MOD_NOT_FOUND - The resource type is unknown by this DLL.

    ERROR_REVISION_MISMATCH - The version of the cluster service doesn't
        match the versrion of the DLL.

    Win32 error code - The operation failed.

--*/

{
    if ( (MinVersionSupported > CLRES_VERSION_V1_00) ||
         (MaxVersionSupported < CLRES_VERSION_V1_00) ) 
	{
        return(ERROR_REVISION_MISMATCH);
    }

    if ( 0 != _wcsicmp( ResourceType, xTriggersResourceType )  ) 
	{
        return(ERROR_MOD_NOT_FOUND);
    }

    if ( g_pfLogClusterEvent == NULL ) 
	{
        g_pfLogClusterEvent = LogEvent;
        g_pfSetResourceStatus = SetResourceStatus;
    }

    *FunctionTable = &g_TrigClusFunctionTable;

    return TrigCluspStartup();

} // Startup


RESID
WINAPI
TrigClusOpen(
    IN LPCWSTR pwzResourceName,
    IN HKEY /* ResourceKey */,
    IN RESOURCE_HANDLE hResourceHandle
    )

/*++

Routine Description:

    Open routine for TrigClus resources.

    Open the specified resource (create an instance of the resource). 
    Allocate all structures necessary to bring the specified resource 
    online.

Arguments:

    ResourceName - Supplies the name of the resource to open.

    ResourceKey - Supplies handle to the resource's cluster configuration 
        database key.

    ResourceHandle - A handle that is passed back to the resource monitor 
        when the SetResourceStatus or LogEvent method is called. See the 
        description of the SetResourceStatus and LogEvent methods on the
        TrigClusStatup routine. This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogEvent callback.

Return Value:

    RESID of created resource.

    NULL on failure.

--*/

{
    return TrigCluspOpen(pwzResourceName, hResourceHandle);

} // TrigClusOpen


VOID
WINAPI
TrigClusClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for TrigClus resources.

    Close the specified resource and deallocate all structures, etc.,
    allocated in the Open call. If the resource is not in the offline state,
    then the resource should be taken offline (by calling Terminate) before
    the close operation is performed.

Arguments:

    ResourceId - Supplies the RESID of the resource to close.

Return Value:

    None.

--*/

{
    CTrigResource * pTrigRes = static_cast<CTrigResource*>(ResourceId);

    if ( pTrigRes == NULL ) 
    {
        return;
    }

    if ( ResourceId != pTrigRes->GetResId() )
    {
        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, 
                              L"Close sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return;
    }

    //
    // Deallocate resource entry
    //
    TrigCluspClose(pTrigRes);

} // TrigClusClose



DWORD
WINAPI
TrigClusOnlineThread(
    PCLUS_WORKER /*WorkerPtr*/,
    IN CTrigResource * pTrigRes
    )

/*++

Routine Description:

    Worker function which brings a resource from the resource table online.
    This function is executed in a separate thread.

Arguments:

    WorkerPtr - Supplies the worker structure

    pqm - A pointer to the TRIGCLUS_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS - The operation completed successfully.
    
    Win32 error code - The operation failed.

--*/

{
    return TrigCluspOnlineThread(pTrigRes);

} // TrigClusOnlineThread



DWORD
WINAPI
TrigClusOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE /* EventHandle */
    )

/*++

Routine Description:

    Online routine for TrigClus resources.

    Bring the specified resource online (available for use). The resource
    DLL should attempt to arbitrate for the resource if it is present on a
    shared medium, like a shared SCSI bus.

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        online (available for use).

    EventHandle - Returns a signalable handle that is signaled when the 
        resource DLL detects a failure on the resource. This argument is 
        NULL on input, and the resource DLL returns NULL if asynchronous 
        notification of failures is not supported, otherwise this must be 
        the address of a handle that is signaled on resource failures.

Return Value:

    ERROR_SUCCESS - The operation was successful, and the resource is now 
        online.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_RESOURCE_NOT_AVAILABLE - If the resource was arbitrated with some 
        other systems and one of the other systems won the arbitration.

    ERROR_IO_PENDING - The request is pending, a thread has been activated 
        to process the online request. The thread that is processing the 
        online request will periodically report status by calling the 
        SetResourceStatus callback method, until the resource is placed into 
        the ClusterResourceOnline state (or the resource monitor decides to 
        timeout the online request and Terminate the resource. This pending 
        timeout value is settable and has a default value of 3 minutes.).

    Win32 error code - The operation failed.

--*/

{
    CTrigResource * pTrigRes = static_cast<CTrigResource*>(ResourceId);

    if ( pTrigRes == NULL ) 
    {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( ResourceId != pTrigRes->GetResId()) 
    {
        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, 
                              L"Online sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    pTrigRes->SetState(ClusterResourceFailed);
    
	ClusWorkerTerminate( &pTrigRes->m_OnlineThread );
    
	DWORD status = ClusWorkerCreate( 
                       &pTrigRes->m_OnlineThread,
                       reinterpret_cast<PWORKER_START_ROUTINE>(TrigClusOnlineThread),
                       pTrigRes
                       );
    if ( status != ERROR_SUCCESS ) 
    {
        pTrigRes->SetState(ClusterResourceFailed);
        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, 
                              L"Failed to create the online thread. Error 0x%1!x!.\n", status);
    } 
    else 
    {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // TrigClusOnline



DWORD
WINAPI
TrigClusOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for TrigClus resources.

    Take the specified resource offline gracefully (unavailable for use).  
    Wait for any cleanup operations to complete before returning.

Arguments:

    ResourceId - Supplies the resource id for the resource to be shutdown 
        gracefully.

Return Value:

    ERROR_SUCCESS - The request completed successfully and the resource is 
        offline.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_IO_PENDING - The request is still pending, a thread has been 
        activated to process the offline request. The thread that is 
        processing the offline will periodically report status by calling 
        the SetResourceStatus callback method, until the resource is placed 
        into the ClusterResourceOffline state (or the resource monitor decides 
        to timeout the offline request and Terminate the resource).
    
    Win32 error code - Will cause the resource monitor to log an event and 
        call the Terminate routine.

--*/

{
    CTrigResource * pTrigRes = static_cast<CTrigResource*>(ResourceId);

    if ( pTrigRes == NULL ) 
    {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( ResourceId != pTrigRes->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, 
                              L"Offline sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    return TrigCluspOffline(pTrigRes);

} //TrigClusOffline


VOID
WINAPI
TrigClusTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for TrigClus resources.

    Take the specified resource offline immediately (the resource is
    unavailable for use).

Arguments:

    ResourceId - Supplies the resource id for the resource to be brought 
        offline.

Return Value:

    None.

--*/

{
    CTrigResource * pTrigRes = static_cast<CTrigResource*>(ResourceId);

    if ( pTrigRes == NULL ) 
    {
        return;
    }

    if ( ResourceId != pTrigRes->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, 
                              L"Terminate sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return;
    }

    //
    // Terminate the resource.
    //
    // Kill off any pending threads.
    //
    ClusWorkerTerminate( &pTrigRes->m_OnlineThread );

    //
    // SCM does not provide any way to kill a service immediately.
    // Even trying to query the service for its process ID and then 
    // terminating the process will fail with access denied.
    // So we will stop the service gracefully by calling Offline.
    //
    TrigCluspOffline(pTrigRes);
    pTrigRes->SetState(ClusterResourceOffline);

} // TrigClusTerminate


BOOL
TrigClusCheckIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Check to see if the resource is alive for TrigClus resources.

Arguments:

    pTrigRes - Supplies the resource entry for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    CTrigResource * pTrigRes = static_cast<CTrigResource*>(ResourceId);

    if ( pTrigRes == NULL ) 
    {
        return(FALSE);
    }

    if ( ResourceId != pTrigRes->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, 
                              L"IsAlive sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(FALSE);
    }

    //
    // Check to see if the resource is alive.
    //
    return TrigCluspCheckIsAlive(pTrigRes);

} // TrigClusCheckIsAlive


BOOL
WINAPI
TrigClusLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for TrigClus resources.

    Perform a quick check to determine if the specified resource is probably
    online (available for use).  This call should not block for more than
    300 ms, preferably less than 50 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is probably online and available for use.

    FALSE - The specified resource is not functioning normally.

--*/

{
    // NOTE: LooksAlive should be a quick check to see if the resource is
    // available or not, whereas IsAlive should be a thorough check.  If
    // there are no differences between a quick check and a thorough check,
    // IsAlive can be called for LooksAlive, as it is below.  However, if there
    // are differences, replace the call to IsAlive below with your quick
    // check code.

    return TrigClusCheckIsAlive(ResourceId);

} // TrigClusLooksAlive


BOOL
WINAPI
TrigClusIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for TrigClus resources.

    Perform a thorough check to determine if the specified resource is online
    (available for use). This call should not block for more than 400 ms,
    preferably less than 100 ms.

Arguments:

    ResourceId - Supplies the resource id for the resource to polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{

    return TrigClusCheckIsAlive(ResourceId);

} // TrigClusIsAlive


DWORD
WINAPI
TrigClusResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID /* InBuffer */,
    IN DWORD /* InBufferSize */,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for TrigClus resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Supplies the resource id for the specific resource.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    CTrigResource * pTrigRes = static_cast<CTrigResource*>(ResourceId);

    if ( pTrigRes == NULL ) 
    {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( ResourceId != pTrigRes->GetResId() ) 
    {
        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, 
                              L"ResourceControl sanity check failed. Resource ID 0x%1!p!.\n", ResourceId);
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    DWORD status = ERROR_SUCCESS;
    *BytesReturned = 0;
    ZeroMemory(OutBuffer, OutBufferSize);
    switch ( ControlCode ) 
    {

        case CLUSCTL_RESOURCE_UNKNOWN:
        case CLUSCTL_RESOURCE_ENUM_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_SET_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_VALIDATE_PRIVATE_PROPERTIES:
            break;

        case CLUSCTL_RESOURCE_GET_REQUIRED_DEPENDENCIES:
            status = TrigCluspClusctlResourceGetRequiredDependencies(OutBuffer, OutBufferSize, 
                                                                   BytesReturned);
            break;

        case CLUSCTL_RESOURCE_SET_NAME:
            status = TrigCluspClusctlResourceSetName();
            break;

        case CLUSCTL_RESOURCE_DELETE:
            status = TrigCluspClusctlResourceDelete(pTrigRes);
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // TrigClusResourceControl


DWORD
WINAPI
TrigClusResourceTypeControl(
    IN LPCWSTR  pResourceTypeName,
    IN DWORD    ControlCode,
    IN PVOID    /*InBuffer*/,
    IN DWORD    /*InBufferSize*/,
    OUT PVOID   OutBuffer,
    IN DWORD    OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceTypeControl routine for MSMQTriggers resources.

    Perform the control request specified by ControlCode on the specified
    resource type.

Arguments:

    pResourceTypeName - Supplies the type name of the specific resource type.

    ControlCode - Supplies the control code that defines the action
        to be performed.

    InBuffer - Supplies a pointer to a buffer containing input data.

    InBufferSize - Supplies the size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Supplies a pointer to the output buffer to be filled in.

    OutBufferSize - Supplies the size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled in by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function completed successfully.

    ERROR_RESOURCE_TYPE_NOT_FOUND - pResourceTypeName is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    if (0 != _wcsicmp(pResourceTypeName, xTriggersResourceType)) 
    {
        return ERROR_RESOURCE_TYPE_NOT_FOUND;
    }

    DWORD status = ERROR_SUCCESS;
    *BytesReturned = 0;
    ZeroMemory(OutBuffer, OutBufferSize);
    switch ( ControlCode ) 
    {

        case CLUSCTL_RESOURCE_TYPE_UNKNOWN:
        case CLUSCTL_RESOURCE_TYPE_ENUM_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_TYPE_SET_PRIVATE_PROPERTIES:
        case CLUSCTL_RESOURCE_TYPE_VALIDATE_PRIVATE_PROPERTIES:
            break;

        case CLUSCTL_RESOURCE_TYPE_GET_REQUIRED_DEPENDENCIES:
            status = TrigCluspClusctlResourceTypeGetRequiredDependencies(OutBuffer, OutBufferSize, 
                                                                   BytesReturned);
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
	}

    return(status);

} // TrigClusResourceTypeControl


//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( g_TrigClusFunctionTable,     // Name
                         CLRES_VERSION_V1_00,         // Version
                         TrigClus,                    // Prefix
                         NULL,                        // Arbitrate
                         NULL,                        // Release
                         TrigClusResourceControl,     // ResControl
                         TrigClusResourceTypeControl); // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\include\genmqsec.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	GenMQSec.h

Abstract:
    generates a security descriptor matching the desired access to MQ.

Author:
   Dan Bar-Lev
   Yifat Peled	(yifatp)	24-Sep-98

--*/

#ifndef GEN_MQ_SEC_H_
#define GEN_MQ_SEC_H_


DWORD 
GenSecurityDescriptor(	SECURITY_INFORMATION*	pSecInfo,
						const WCHAR*			pwcsSecurityStr,
						PSECURITY_DESCRIPTOR*	ppSD);


#endif // GEN_MQ_SEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\cluster\trigclusp.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      trigclusp.cpp
//
//  Description:
//      This file contains the implementation of the CClusCfgMQTrigResType
//      class.
//
//  Maintained By:
//      Nela Karpel (nelak) 31-JUL-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "tclusres.h"
#include <cm.h>
#include <autorel.h>
#include <autorel2.h>
#include <autorel3.h>
#include <xolehlp.h>
#include <mqwin64a.h>
#include <comdef.h>
#include <mqsymbls.h>
#include <mqtg.h>
#include "trigclusp.h"
#include <mqexception.h>

#include <strsafe.h>

//
// Handle to Win32 event logging source
//
CEventSource     s_hEventSource;


VOID
TrigCluspReportEvent(
    WORD      wType,
    DWORD     dwEventId,
    WORD      wNumStrings,
    ...
    )

/*++

Routine Description:

    Wrapper for ReportEvent Win32 API.

Arguments:

    wType - Event type to log.

    dwEventId - Event identifier.

    wNumStrings - Number of strings to merge with message.

    ... - Array of strings to merge with message.

Return Value:

    None.

--*/

{
    if (s_hEventSource == NULL)
    {
        return;
    }

    const DWORD x_MAX_STRINGS = 20;
    ASSERT(wNumStrings < x_MAX_STRINGS);
    va_list Args;
    LPWSTR ppStrings[x_MAX_STRINGS] = {NULL};
    LPWSTR pStrVal = NULL;

    va_start(Args, wNumStrings);
    pStrVal = va_arg(Args, LPWSTR);

    for (UINT i=0; i < wNumStrings; ++i)
    {
        ppStrings[i]=pStrVal;
        pStrVal = va_arg(Args, LPWSTR);
    }

    ::ReportEvent(s_hEventSource, wType, 0, dwEventId, NULL, wNumStrings, 0, (LPCWSTR*)&ppStrings[0], NULL);

} //TrigCluspReportEvent


void
TrigCluspCreateRegistryForEventLog(
	LPCWSTR szEventSource,
	LPCWSTR szEventMessageFile
	)
/*++

Routine Description:

	Create registry keys for EventLog inforamtion

Arguments:

    szEventSource - Source Application Name

	szEventMessageFile - Message File with Event Inforamtion

Return Value:

    None.
--*/
{
	//
	// Create registery key
	//
	WCHAR appPath[MAX_REGKEY_NAME_SIZE];

	HRESULT hr = StringCchPrintf(appPath, TABLE_SIZE(appPath), L"%s%s", xEventLogRegPath, szEventSource);
	if (FAILED(hr))
	{
		ASSERT(("Buffer to small to contain the registry path", n < 0));
		throw bad_alloc();
	}

	RegEntry appReg(appPath,  NULL, 0, RegEntry::MustExist, NULL);
	CRegHandle hAppKey = CmCreateKey(appReg, KEY_ALL_ACCESS);

	RegEntry eventFileReg(NULL, L"EventMessageFile", 0, RegEntry::MustExist, hAppKey);
	CmSetValue(eventFileReg, szEventMessageFile);


	DWORD types = EVENTLOG_ERROR_TYPE   |
				  EVENTLOG_WARNING_TYPE |
				  EVENTLOG_INFORMATION_TYPE;

	RegEntry eventTypesReg(NULL, L"TypesSupported", 0, RegEntry::MustExist, hAppKey);
	CmSetValue(eventTypesReg, types);

} // TrigCluspCreateRegistryForEventLog


CTrigResource::CTrigResource(
    LPCWSTR pwzResourceName,
    RESOURCE_HANDLE hReportHandle
    ):
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
    m_ResId(this),
#pragma warning(default: 4355) // 'this' : used in base member initializer list    
	m_pwzResourceName(NULL),
    m_hReport(hReportHandle),
    m_hScm(OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS)),
    m_hCluster(OpenCluster(NULL)),
    m_hResource(OpenClusterResource(m_hCluster, pwzResourceName))

/*++

Routine Description:

    Constructor.
    Called by Open entry point function.

    All operations must be idempotent !!

Arguments:

    pwzResourceName - Supplies the name of the resource to open.

    hReportHandle - A handle that is passed back to the resource monitor
        when the SetResourceStatus or LogClusterEvent method is called. See the
        description of the SetResourceStatus and LogClusterEvent methods on the
        MqclusStatup routine. This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogClusterEvent callback.

Return Value:

    None.
    Throws bad_alloc.

--*/

{
	//
	// TODO: Check if MSMQ Triggers is installed on this computer
	//

	ResUtilInitializeResourceStatus(&m_ResourceStatus);
    SetState(ClusterResourceOffline);

    //
    // Dont assume any limit to the resource name.
    // It is defined by client and could be very long.
    // The good thing with resource names is that Cluster
    // guarantees their uniqueness.
    //
    m_pwzResourceName = newwcs(pwzResourceName);

    //
    // Service name is based on the resource name.
    // Long resource name is truncated.
    //
    LPCWSTR x_SERVICE_PREFIX = L"MSMQTriggers$";
	HRESULT hr = StringCchPrintf(
						m_wzServiceName,
						TABLE_SIZE(m_wzServiceName),
						L"%s%s", 
						x_SERVICE_PREFIX, 
						m_pwzResourceName
						);
	if (FAILED(hr))
		throw bad_hresult(hr);

	//
	// Initialize Event Log data
	//
	CreateRegistryForEventLog();
	
	//
    // Initialize registry section - idempotent
    //
    // The registry section name of this Triggers resource MUST
    // be identical to the service name. The registry routines
    // in trigobjs.dll are based on that.
    //

    C_ASSERT(TABLE_SIZE(m_wzTrigRegSection)> TABLE_SIZE(REGKEY_TRIGGER_PARAMETERS) +
											   TABLE_SIZE(REG_SUBKEY_CLUSTERED) +
                                               TABLE_SIZE(m_wzServiceName));

	hr = StringCchPrintf(
    		m_wzTrigRegSection,
    		TABLE_SIZE(m_wzTrigRegSection),
    		L"%s%s%s",
    		REGKEY_TRIGGER_PARAMETERS,
    		REG_SUBKEY_CLUSTERED,
    		m_wzServiceName
    		);
	if (FAILED(hr))
		throw bad_hresult(hr);

	
	try
	{
		//
		// Delete possible leftovers from a resource with the same name.
		// This is possible when a resource with the same name was created on one
		// node, but failed over, and was deleted on another node.
		//
		DeleteTrigRegSection();

		//
		// Create root key for this resource in registry
		//
		RegEntry triggerReg(m_wzTrigRegSection,  NULL, 0, RegEntry::MustExist, NULL);
		CRegHandle hTrigKey = CmCreateKey(triggerReg, KEY_ALL_ACCESS); 

		RegEntry triggerDataRegTriggers(REG_SUBKEY_TRIGGERS,  NULL, 0, RegEntry::MustExist, hTrigKey);
		CRegHandle hTrigKeyTriggers = CmCreateKey(triggerDataRegTriggers, KEY_ALL_ACCESS); 

		RegEntry triggerDataRegRules(REG_SUBKEY_RULES,  NULL, 0, RegEntry::MustExist, hTrigKey);
		CRegHandle hTrigKeyRules = CmCreateKey(triggerDataRegRules, KEY_ALL_ACCESS); 
	}
    catch (const bad_alloc&)
	{
		(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Failed to create registry section.\n");
		
		throw;
	}


	(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Resource constructed OK.\n");

} //CTrigResource::CTrigResource()


DWORD
CTrigResource::ReportLastError(
    DWORD ErrId,
    LPCWSTR pwzDebugLogMsg,
    LPCWSTR pwzArg
    ) const

/*++

Routine Description:

    Report error messages based on last error.
    Most error messages are reported using this routine.
    The report goes to debug output and to cluster
    log file.

Arguments:

    ErrId - ID of the error string in mqsymbls.mc

    pwzDebugLogMsg - Non localized string for debug output.

    pwzArg - Additional string argument.

Return Value:

    Last error.

--*/

{
    DWORD err = GetLastError();
    ASSERT(err != ERROR_SUCCESS);

	HRESULT hr;
    WCHAR wzErr[10];
    _ultow(err, wzErr, 16);

    WCHAR DebugMsg[255] = L"";

    if (pwzArg == NULL)
    {
        TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, ErrId, 1, wzErr);

		hr = StringCchPrintf(DebugMsg, TABLE_SIZE(DebugMsg), L"%s Error 0x%1!x!.\n", pwzDebugLogMsg, err);
		ASSERT(SUCCEEDED(hr));
		
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, DebugMsg, err);
    }
    else
    {
        TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, ErrId, 2, pwzArg, wzErr);

		hr = StringCchPrintf(DebugMsg, TABLE_SIZE(DebugMsg), L"%s Error 0x%2!x!.\n", pwzDebugLogMsg, err); 
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, DebugMsg, pwzArg, err);
    }

    return err;

} //CTrigResource::ReportLastError


void
CTrigResource::CreateRegistryForEventLog(
	VOID
    )

/*++

Routine Description:

	Update Registry with Event Log info
	for the new service

Arguments:

	hReportHandle - Handle for reports to cluster log

Return Value:


--*/

{
	try
	{
		WCHAR systemDirectory[MAX_PATH];
		DWORD cchWrote = GetSystemDirectory(systemDirectory, TABLE_SIZE(systemDirectory));
		if (cchWrote == 0)
		{
			DWORD gle = GetLastError();
			ASSERT(("Buffer to small to contain the system directory", 0));
			throw bad_win32_error(gle);
		}
		
		WCHAR szEventMessagesFile[MAX_PATH];
		HRESULT hr = StringCchPrintf(
							szEventMessagesFile, 
							TABLE_SIZE(szEventMessagesFile), 
							L"%s\\%s",
							systemDirectory,
							xTriggersEventSourceFile
							);

		if (FAILED(hr))
		{
			ASSERT(("Buffer to small to contain the trigger event file path", 0));
			throw bad_hresult(hr);
		}
		
		TrigCluspCreateRegistryForEventLog(m_wzServiceName, szEventMessagesFile);

		return;
	}
	catch(const exception&)
	{
		TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, REGISTRY_UPDATE_ERR, 1, m_wzServiceName);
		(g_pfLogClusterEvent)(GetReportHandle(), LOG_ERROR, L"Failed to update EventLog info in registry.\n");
	}


} // CreateRegistryForEventLog


void
CTrigResource::DeleteRegistryForEventLog(
	VOID
    )

/*++

Routine Description:

	Update Registry with Event Log info
	for the new service

Arguments:


Return Value:


--*/

{
	WCHAR szEventLogRegPath[256];
	HRESULT hr = StringCchPrintf(
					szEventLogRegPath, 
					TABLE_SIZE(szEventLogRegPath),
					L"%s%s",
					xEventLogRegPath,
					m_wzServiceName
					);
	ASSERT(SUCCEEDED(hr));
	UNREFERENCED_PARAMETER(hr);	

	RegDeleteKey(HKEY_LOCAL_MACHINE, szEventLogRegPath);
}


inline
VOID
CTrigResource::ReportState(
    VOID
    ) const

/*++

Routine Description:

    Report status of the resource to resource monitor.
    This routine is called to report progress when the
    resource is online pending, and to report final status
    when the resource is online or offline.

Arguments:

    None

Return Value:

    None

--*/

{
    ++m_ResourceStatus.CheckPoint;
    g_pfSetResourceStatus(m_hReport, &m_ResourceStatus);

} //CTrigResource::ReportState


bool
CTrigResource::IsResourceOfType(
    LPCWSTR pwzResourceName,
	LPCWSTR pwzType
    )

/*++

Routine Description:

    Check if a resource is of type pwzType.

Arguments:

    pwzResourceName - Name of resource to check upon.

	pwzType - Type

Return Value:

    true - Resource is of type pwzType

    false - Resource is not of type pwzType

--*/

{
    AP<BYTE> pType = 0;

	//
	// Get the type of resource with name pwzResourceName
	//
    DWORD status = ClusterResourceControl(
                       pwzResourceName,
                       CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                       &pType,
                       NULL
                       );

    if (status != ERROR_SUCCESS )
    {
        return false;
    }

	//
	// Compare type of the resource with the specified type name
	//
	if ( _wcsicmp(reinterpret_cast<LPWSTR>(pType.get()), pwzType) != 0 )
	{
		return false;
	}

    return true;

} //CTrigResource::IsResourceOfType


DWORD
CTrigResource::QueryResourceDependencies(
    VOID
    )

/*++

Routine Description:

	Check dependenct on MSMQ.
	Keep this routine idempotent.

Arguments:

    None

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    DWORD dwResourceType = CLUSTER_RESOURCE_ENUM_DEPENDS;
    CResourceEnum hResEnum(ClusterResourceOpenEnum(
                               m_hResource,
                               dwResourceType
                               ));
    if (hResEnum == NULL)
    {
        DWORD gle = GetLastError();
        TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, REQUIRED_TRIGGER_DEPENDENCIES_ERR, 0);

        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,L"Failed to enum dependencies. Error 0x%1!x!.\n", gle);

        return gle;
    }

    DWORD dwIndex = 0;
    WCHAR wzResourceName[260] = {0};
    DWORD status = ERROR_SUCCESS;
	bool fMsmq = false;
	bool fNetName = false;

    for (;;)
    {
		
		if ( fMsmq && fNetName )
		{
			return ERROR_SUCCESS;
		}

        DWORD cchResourceName = STRLEN(wzResourceName);
        status = ClusterResourceEnum(
                     hResEnum,
                     dwIndex++,
                     &dwResourceType,
                     wzResourceName,
                     &cchResourceName
                     );

        if (ERROR_SUCCESS != status)
        {
			TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, REQUIRED_TRIGGER_DEPENDENCIES_ERR, 0);
			return status;
        }


        ReportState();

        if (IsResourceOfType(wzResourceName, xMSMQ))
        {
            fMsmq = true;
			continue;
        }

        if (IsResourceOfType(wzResourceName, xNetworkName))
        {
            fNetName = true;
			continue;
        }

    }

    return status;

} //CTrigResource::QueryResourceDependencies




DWORD
CTrigResource::ClusterResourceControl(
    LPCWSTR pwzResourceName,
    DWORD dwControlCode,
    LPBYTE * ppBuffer,
    DWORD * pcbSize
    ) const

/*++

Routine Description:

    Wrapper for ClusterResourceControl.
    We want to control resources such as network name and disk.

    Note that most of the control code functions should not be called
    by resource DLLs, unless from within the online/offline threads.

Arguments:

    pwzResourceName - Name of resource to control.

    dwControlCode - Operation to perform on the resource.

    ppBuffer - Pointer to pointer to output buffer to be allocated.

    pcbSize - Pointer to allocated size of buffer, in bytes.

Return Value:

    Win32 error code.

--*/

{
    ASSERT(("must have a valid handle to cluster", m_hCluster != NULL));

    CClusterResource hResource(OpenClusterResource(
                                   m_hCluster,
                                   pwzResourceName
                                   ));
    if (hResource == NULL)
    {
        return ReportLastError(OPEN_RESOURCE_ERR, L"OpenClusterResource for '%1' failed.", pwzResourceName);
    }

    DWORD dwReturnSize = 0;
    DWORD dwStatus = ::ClusterResourceControl(
                           hResource,
                           0,
                           dwControlCode,
                           0,
                           0,
                           0,
                           0,
                           &dwReturnSize
                           );
    if (dwStatus != ERROR_SUCCESS)
    {
        return dwStatus;
    }
    ASSERT(("failed to get buffer size for a resource", 0 != dwReturnSize));

	// BUGBUG: ... temp pointer
    *ppBuffer = new BYTE[dwReturnSize];

    dwStatus = ::ClusterResourceControl(
                     hResource,
                     0,
                     dwControlCode,
                     0,
                     0,
                     *ppBuffer,
                     dwReturnSize,
                     &dwReturnSize
                     );

    if (pcbSize != NULL)
    {
        *pcbSize = dwReturnSize;
    }

    return dwStatus;

} //CTrigResource::ClusterResourceControl


DWORD
CTrigResource::AddRemoveRegistryCheckpoint(
    DWORD dwControlCode
    ) const

/*++

Routine Description:

    Add or remove registry checkpoint for this resource.
    Convenient wrapper for ClusterResourceControl,
    which does the real work.

Arguments:

    dwControlCode - specifies ADD or REMOVE

Return Value:

    true - The operation was successfull.

    false - The operation failed.

--*/

{
    ASSERT(("Must have a valid resource handle", m_hResource != NULL));

    DWORD dwBytesReturned = 0;
    DWORD status = ::ClusterResourceControl(
                         m_hResource,
                         NULL,
                         dwControlCode,
                         const_cast<LPWSTR>(m_wzTrigRegSection),
                         (wcslen(m_wzTrigRegSection) + 1)* sizeof(WCHAR),
                         NULL,
                         0,
                         &dwBytesReturned
                         );

    ReportState();


    if (ERROR_SUCCESS == status)
    {
        return ERROR_SUCCESS;
    }
    if (CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT == dwControlCode &&
        ERROR_ALREADY_EXISTS == status)
    {
        return ERROR_SUCCESS;
    }

    if (CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT == dwControlCode &&
        ERROR_FILE_NOT_FOUND == status)
    {
        return ERROR_SUCCESS;
    }

    ReportLastError(REGISTRY_CP_ERR, L"Failed to add/remove registry CP", NULL);
    return status;

} //CTrigResource::AddRemoveRegistryCheckpoint


DWORD
CTrigResource::RegisterService(
    VOID
    ) const

/*++

Routine Description:

    Create the msmq service for this QM.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    //
    // Register service (idempotent)
    //

    WCHAR buffer[256] = L"";
    LoadString(g_hResourceMod, IDS_DISPLAY_NAME, buffer, TABLE_SIZE(buffer));

    WCHAR wzDisplayName[256];
	HRESULT hr = StringCchPrintf(
					wzDisplayName, 
					TABLE_SIZE(wzDisplayName),
					L"%s(%s)",
    				buffer,
    				m_pwzResourceName
					);

	if (FAILED(hr))
		return ERROR_INSUFFICIENT_BUFFER;
	
    WCHAR wzPath[MAX_PATH] = {0};
    DWORD cchWrote = GetSystemDirectory(wzPath, TABLE_SIZE(wzPath));
    if (cchWrote == 0)
    	return GetLastError();
    
    hr = StringCchCat(wzPath, TABLE_SIZE(wzPath), L"\\mqtgsvc.exe");
    if (FAILED(hr))
    	return ERROR_INSUFFICIENT_BUFFER;

    DWORD dwType = SERVICE_WIN32_OWN_PROCESS;

    ASSERT(("Must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(CreateService(
                                m_hScm,
                                m_wzServiceName,
                                wzDisplayName,
                                SERVICE_ALL_ACCESS,
                                dwType,
                                SERVICE_DEMAND_START,
                                SERVICE_ERROR_NORMAL,
                                wzPath,
                                NULL,
                                NULL,
                                NULL,
                                L"NT AUTHORITY\\NetworkService",
                                NULL
                                ));
    if (hService == NULL &&
        ERROR_SERVICE_EXISTS != GetLastError())
    {
        return ReportLastError(CREATE_SERVICE_ERR, L"Failed to register service '%1'.", m_wzServiceName);
    }


    ReportState();


    LoadString(g_hResourceMod, IDS_TRIGGER_CLUSTER_SERVICE_DESCRIPTION, buffer, TABLE_SIZE(buffer));
    SERVICE_DESCRIPTION sd;
    sd.lpDescription = buffer;
    ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, &sd);

    return ERROR_SUCCESS;

} //CTrigResource::RegisterService


DWORD
CTrigResource::SetServiceEnvironment(
    VOID
    ) const

/*++

Routine Description:

    Configure the environment for the msmq service of this QM,
    such that code inside the QM that calls GetComputerName will
    get the name of the cluster virtual server (the network name).

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{

    //
    // Set MSMQ trigger service environment
    //
	DWORD status = ResUtilSetResourceServiceEnvironment(
                       m_wzServiceName,
                       m_hResource,
                       g_pfLogClusterEvent,
                       GetReportHandle()
                       );

    //
    // If fail, write to cluster log and create an event log
    //
    if (ERROR_SUCCESS != status)
    {
        SetLastError(status);
        return ReportLastError(START_SERVICE_ERR, L"Failed to set MSMQ trigger service environment for service name '%1'", m_wzServiceName);
    }

    //
    // write to cluster log that we set the MSMQ trigger service environment successfully
    //
    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Set MSMQ trigger service '%1' environment successfully.\n", m_wzServiceName);


    return ERROR_SUCCESS;

} //CTrigResource::SetServiceEnvironment


DWORD
CTrigResource::StartService(
    VOID
    ) const

/*++

Routine Description:

    Configure environment for the MSMQTriggers service of this resource,
    start the service and block until it's up and running.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    ASSERT(("Must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(OpenService(
                                m_hScm,
                                m_wzServiceName,
                                SERVICE_ALL_ACCESS
                                ));
    if (hService == NULL)
    {
        return ReportLastError(START_SERVICE_ERR, L"Failed to open service '%1'.", m_wzServiceName);
    }

    DWORD status = SetServiceEnvironment();
    if (ERROR_SUCCESS != status)
    {
        return status;
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Starting the '%1' service.\n", m_wzServiceName);

    BOOL rc = ::StartService(hService, 0, NULL);

	ReportState();

    //
    // Could take a long time for service to start.
    // This routine can be called more than once.
    //
    if (!rc &&
        ERROR_SERVICE_ALREADY_RUNNING != GetLastError() &&
        ERROR_SERVICE_CANNOT_ACCEPT_CTRL != GetLastError())
    {
        return ReportLastError(START_SERVICE_ERR, L"Failed to start service '%1'.", m_wzServiceName);
    }

    //
    // Wait until service is up
    //
    TrigCluspReportEvent(EVENTLOG_INFORMATION_TYPE, START_SERVICE_OK, 1, m_wzServiceName);
    SERVICE_STATUS ServiceStatus;
    for (;;)
    {
        if (!QueryServiceStatus(hService, &ServiceStatus))
        {
            return ReportLastError(START_SERVICE_ERR, L"Failed to query service '%1'.", m_wzServiceName);
        }


        ReportState();


        if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING)
        {
            Sleep(100);
            continue;
        }

        break;
    }

    if (SERVICE_RUNNING != ServiceStatus.dwCurrentState)
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_ERROR, L"Service '%1' failed to start.\n", m_wzServiceName);

        return ERROR_SERVICE_SPECIFIC_ERROR;
    }

    return ERROR_SUCCESS;

} //CTrigResource::StartService


DWORD
CTrigResource::BringOnline(
    VOID
    )

/*++

Routine Description:

    Handle operations to perform online of this MSMQTriggers 
	resource:
    
    * query dependencies
    * add registry checkpoint
	* start the service

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
	(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Bringing online.\n");

	DWORD status = QueryResourceDependencies();

	if (ERROR_SUCCESS != status) 
    {
        return status;
    }

    status = AddRemoveRegistryCheckpoint(CLUSCTL_RESOURCE_ADD_REGISTRY_CHECKPOINT);
    if (ERROR_SUCCESS != status)
    {
        return status;
    }

	if (ERROR_SUCCESS != (status = RegisterService()) ||
		ERROR_SUCCESS != (status = StartService()) )
    {
        (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Failed to bring online. Error 0x%1!x!.\n",
                              status);

        return status;
    }

	(g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"All first-online operations completed.\n");

    return ERROR_SUCCESS;

} //CTrigResource::BringOnline


DWORD
CTrigResource::StopService(
    LPCWSTR pwzServiceName
    ) const

/*++

Routine Description:

    Stop a service and block until it's stopped (or timeout).

Arguments:

    pwzServiceName - The service to stop.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    ASSERT(("Must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(OpenService(
                                m_hScm,
                                pwzServiceName,
                                SERVICE_ALL_ACCESS
                                ));
    if (hService == NULL)
    {
        if (ERROR_SERVICE_DOES_NOT_EXIST == GetLastError())
        {
            return ERROR_SUCCESS;
        }

        return ReportLastError(STOP_SERVICE_ERR, L"Failed to open service '%1'.", pwzServiceName);
    }

    SERVICE_STATUS ServiceStatus;
    if (!ControlService(hService, SERVICE_CONTROL_STOP, &ServiceStatus) &&
        ERROR_SERVICE_NOT_ACTIVE != GetLastError() &&
        ERROR_SERVICE_CANNOT_ACCEPT_CTRL != GetLastError() &&
        ERROR_BROKEN_PIPE != GetLastError())
    {
        return ReportLastError(STOP_SERVICE_ERR, L"Failed to stop service '%1'.", pwzServiceName);
    }

    //
    // Wait until service is down (or timeout 5 seconds)
    //
    const DWORD x_TIMEOUT = 1000 * 5;

    DWORD dwWaitTime = 0;
    while (dwWaitTime < x_TIMEOUT)
    {
        if (!QueryServiceStatus(hService, &ServiceStatus))
        {
            return ReportLastError(STOP_SERVICE_ERR, L"Failed to query service '%1'.", pwzServiceName);
        }

        if (ServiceStatus.dwCurrentState == SERVICE_START_PENDING)
        {
            //
            // Service is still start pending from a previous call
            // to start it. So it cannot be stopped. We can do
            // nothing about it. Trying to terminate the process
            // of the service will fail with access denied.
            //
            (g_pfLogClusterEvent)(m_hReport, LOG_ERROR,
                              L"Service '%1' can not be stopped because it is start pending.\n", pwzServiceName);

            return SERVICE_START_PENDING;
        }

        if (ServiceStatus.dwCurrentState != SERVICE_STOP_PENDING)
        {
            break;
        }

        const DWORD x_INTERVAL = 50;
        Sleep(x_INTERVAL);
        dwWaitTime += x_INTERVAL;
    }

    if (SERVICE_STOPPED != ServiceStatus.dwCurrentState)
    {
        //
        // Service failed to stop.
        //
        ReportLastError(STOP_SERVICE_ERR, L"Failed to stop service '%1'.", pwzServiceName);
        return ServiceStatus.dwCurrentState;
    }

    return ERROR_SUCCESS;

} //CTrigResource::StopService


DWORD
CTrigResource::RemoveService(
    LPCWSTR pwzServiceName
    ) const

/*++

Routine Description:

    Stop and delete a service.

Arguments:

    pwzServiceName - The service to stop and delete.

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    ASSERT(("Must have a valid handle to SCM", m_hScm != NULL));

    //
    // First check if service exists
    //
    CServiceHandle hService(OpenService(
                                m_hScm,
                                pwzServiceName,
                                SERVICE_ALL_ACCESS
                                ));
    if (hService == NULL)
    {
        if (ERROR_SERVICE_DOES_NOT_EXIST == GetLastError())
        {
            return ERROR_SUCCESS;
        }

        return ReportLastError(DELETE_SERVICE_ERR, L"Failed to open service '%1'", pwzServiceName);
    }

    //
    // Service exists. Make sure it is not running.
    //
    DWORD status = StopService(pwzServiceName);
    if (ERROR_SUCCESS != status)
    {
        return status;
    }

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting service '%1'.\n", pwzServiceName);

    if (!DeleteService(hService) &&
        ERROR_SERVICE_MARKED_FOR_DELETE != GetLastError())
    {
        return ReportLastError(DELETE_SERVICE_ERR, L"Failed to delete service '%1'", pwzServiceName);
    }

    return ERROR_SUCCESS;

} //CTrigResource::RemoveService


BOOL
CTrigResource::CheckIsAlive(
    VOID
    ) const

/*++

Routine Description:

    Checks is the service is up and running.

Arguments:

    None.

Return Value:

    TRUE - The service is up and running.

    FALSE - The service is not up and running.

--*/

{

    ASSERT(("Must have a valid handle to SCM", m_hScm != NULL));

    CServiceHandle hService(OpenService(
                                m_hScm,
                                m_wzServiceName,
                                SERVICE_ALL_ACCESS
                                ));

    SERVICE_STATUS ServiceStatus;
    BOOL fIsAlive = QueryServiceStatus(hService, &ServiceStatus) &&
                    SERVICE_RUNNING == ServiceStatus.dwCurrentState;

    return fIsAlive;

} //CTrigResource::CheckIsAlive


VOID
CTrigResource::RegDeleteTree(
    HKEY hRootKey,
    LPCWSTR pwzKey
    ) const

/*++

Routine Description:

    Recursively delete registry key and all its subkeys - idempotent.

Arguments:

    hRootKey - Handle to the root key of the key to be deleted

    pwzKey   - Key to be deleted

Return Value:

    None

--*/

{
	//
	// TODO: Use CM, write EnumKeys function in CM
	//
    HKEY hKey = 0;
    if (ERROR_SUCCESS != RegOpenKeyEx(hRootKey, pwzKey, 0, KEY_ENUMERATE_SUB_KEYS | KEY_WRITE, &hKey))
    {
        return;
    }

    for (;;)
    {
        WCHAR wzSubkey[255] = {0};
        DWORD cbSubkey = 0;

        cbSubkey = TABLE_SIZE(wzSubkey);
        if (ERROR_SUCCESS != RegEnumKeyEx(hKey, 0, wzSubkey, &cbSubkey, NULL, NULL, NULL, NULL))
        {
            break;
        }

        RegDeleteTree(hKey, wzSubkey);
    }

    RegCloseKey(hKey);

    RegDeleteKey(hRootKey, pwzKey);

} //CTrigResource::RegDeleteTree


VOID
CTrigResource::DeleteTrigRegSection(
    VOID
    )
{

    (g_pfLogClusterEvent)(m_hReport, LOG_INFORMATION, L"Deleting registry section '%1'.\n", m_wzTrigRegSection);

    RegDeleteTree(REGKEY_TRIGGER_POS, m_wzTrigRegSection);

} //CTrigResource::DeleteTrigRegSection


static
bool
TrigCluspIsMainSvcConfigured(
    VOID
    )

/*++

Routine Description:

    Query if main msmq service running on the node is configured
    for clustering, i.e. is demand start.

Arguments:

    None

Return Value:

    true - Main msmq triggers service is configured for clustering.

    false - Main msmq triggers service is not configured, or a failure accured.

--*/

{
    CServiceHandle hScm(OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS));
    if (hScm == NULL)
    {
        return false;
    }

    CServiceHandle hService(OpenService(hScm, xDefaultTriggersServiceName, SERVICE_ALL_ACCESS));
    if (hService == NULL)
    {
        return false;
    }

    P<QUERY_SERVICE_CONFIG> pqsc = new QUERY_SERVICE_CONFIG;
    DWORD cbSize = sizeof(QUERY_SERVICE_CONFIG);
    DWORD dwBytesNeeded = 0;
    memset(pqsc, 0, cbSize);

    BOOL success = QueryServiceConfig(hService, pqsc, cbSize, &dwBytesNeeded);

    if (!success && ERROR_INSUFFICIENT_BUFFER == GetLastError())
    {
        delete pqsc.detach();

        cbSize = dwBytesNeeded + 1;
        pqsc = reinterpret_cast<LPQUERY_SERVICE_CONFIG>(new BYTE[cbSize]);
        memset(pqsc, 0, cbSize);

        success = QueryServiceConfig(hService, pqsc, cbSize, &dwBytesNeeded);
    }

    if (!success)
    {
        return false;
    }
        
    if (pqsc->dwStartType != SERVICE_DEMAND_START)
    {
        return false;
    }

    return true;

} //TrigCluspIsMainSvcConfigured


static
VOID
TrigCluspConfigureMainSvc(
    VOID
    )

/*++

Routine Description:

    If cluster software was installed on this machine after installation
    of msmq, then the main msmq triggers service needs to be reconfigured 
	to manual start

    Since this routine deals only with the main msmq triggers service on the
    node, failure is not critical.

Arguments:

    None

Return Value:

    None.
--*/

{
    if (TrigCluspIsMainSvcConfigured())
    {
        //
        // Dont configure more than once.
        //
        return;
    }

    CServiceHandle hScm(OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS));

    ASSERT(("Must have a valid handle to SCM", hScm != NULL));

    CServiceHandle hService(OpenService(hScm, xDefaultTriggersServiceName, SERVICE_ALL_ACCESS));

    if (hService == NULL)
    {
        return;
    }

    ChangeServiceConfig(
        hService,
        SERVICE_NO_CHANGE,
        SERVICE_DEMAND_START,
        SERVICE_NO_CHANGE,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
        );

} //TrigCluspConfigureMainSvc


VOID
TrigCluspRegisterEventSource(
    VOID
    )

/*++

Routine Description:

    Register event source so that this DLL can log events
    in the Windows Event Log.

    We do not use the routines in trigobjs.dll to do that,
    since this DLL is installed as part of the cluster
    product and should not assume that MSMQ Triggers are installed.

Arguments:

    None

Return Value:

    None.

--*/

{
    if (s_hEventSource != NULL)
    {
        //
        // Already registered
        //
        return;
    }

    WCHAR wzFilename[MAX_PATH] = L"";
    if (0 == GetModuleFileName(g_hResourceMod, wzFilename, STRLEN(wzFilename)))
    {
        return;
    }

    LPCWSTR x_EVENT_SOURCE = L"MSMQTriggers Cluster Resource DLL";

	TrigCluspCreateRegistryForEventLog(x_EVENT_SOURCE, wzFilename);

    s_hEventSource = RegisterEventSource(NULL, x_EVENT_SOURCE);

} //TrigCluspRegisterEventSource


DWORD
TrigCluspStartup(
    VOID
    )

/*++

Routine Description:

    This routine is called when DLL is registered or loaded.
    Could be called by many threads.
    Do not assume that MSMQ / Triggers is installed on the node here.

Arguments:

    None

Return Value:

    ERROR_SUCCESS - The operation was successful

    Win32 error code - The operation failed.

--*/

{
    try
    {
        TrigCluspConfigureMainSvc();
        
        TrigCluspRegisterEventSource();
    }

    catch (const bad_alloc&)
    {
        TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);
        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;

} //TrigCluspStartup


RESID
TrigCluspOpen(
    LPCWSTR pwzResourceName,
    RESOURCE_HANDLE hResourceHandle
    )

/*++

Routine Description:

    Create an object to represent a new MSMQTriggers resource 
	and return a handle to that object.

Arguments:

    pwzResourceName - Name of this MSMQTriggers resource.

    hResourceHandle - report handle for this MSMQTriggers resource.

Return Value:

    NULL - The operation failed.

    Some valid address - the memory offset of this MSMQTriggers object.

--*/

{
    (g_pfLogClusterEvent)(hResourceHandle, LOG_INFORMATION, L"Opening resource.\n");

    CTrigResource * pTrigRes = NULL;
    try
    {
        pTrigRes = new CTrigResource(pwzResourceName, hResourceHandle);

		(g_pfLogClusterEvent)(hResourceHandle, LOG_INFORMATION, L"Resource was opened successfully.\n");

		return static_cast<RESID>(pTrigRes);
   }
    
	catch(const bad_alloc&)
    {
        TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);

        (g_pfLogClusterEvent)(hResourceHandle, LOG_ERROR, L"No memory (CQmResource construction).\n");
        SetLastError(ERROR_NOT_READY);
        return NULL;
    }
    

} //TrigCluspOpen


VOID
TrigCluspClose(
    CTrigResource * pTrigRes
    )

/*++

Routine Description:

    Delete the TrigRes object. Undo TrigCluspOpen.

Arguments:

    pTrigRes - pointer to the CTrigResource object

Return Value:

    None.

--*/

{
    (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_INFORMATION, L"Closing resource.\n");

    delete pTrigRes;

} //TrigCluspClose



DWORD
TrigCluspOnlineThread(
    CTrigResource * pTrigRes
    )

/*++

Routine Description:

    This is the thread where stuff happens: bringing
    the resource online.

Arguments:

    pqm - pointer to the CQmResource object

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
    (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_INFORMATION, L"Starting online thread.\n");

    try
    {
        pTrigRes->SetState(ClusterResourceOnlinePending);
        pTrigRes->ReportState();

        DWORD status = ERROR_SUCCESS;
		status = pTrigRes->BringOnline();

        if (ERROR_SUCCESS != status)
        {
            //
            // We report the resource as failed, so make sure
            // the service and driver are indeed down.
            //
            pTrigRes->StopService(pTrigRes->GetServiceName());

            pTrigRes->SetState(ClusterResourceFailed);
            pTrigRes->ReportState();

            (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_INFORMATION,
                                  L"Failed to bring online. Error 0x%1!x!.\n", status);

            return status;
        }


        pTrigRes->SetState(ClusterResourceOnline);
        pTrigRes->ReportState();
    }

    catch (const bad_alloc&)
    {
        TrigCluspReportEvent(EVENTLOG_ERROR_TYPE, NO_MEMORY_ERR, 0);

        (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_ERROR, L"No memory (online thread).\n");

        return ERROR_OUTOFMEMORY;
    }

    return(ERROR_SUCCESS);

} //TrigCluspOnlineThread


DWORD
TrigCluspOffline(
    CTrigResource * pTrigRes
    )

/*++

Routine Description:

    Brings down this QM resource:
    * stop and remove device driver and msmq service
    * delete the binary for the device driver

    We not only stop the QM, but also undo most of the
    operations done in BringOnline. This way we clean
    the local node before failover to remote node, and
    Delete on the remote node will not leave "garbage"
    on this node.

Arguments:

    pqm - pointer to the CQmResource object

Return Value:

    ERROR_SUCCESS - The operation was successfull.

    Win32 error code - The operation failed.

--*/

{
	pTrigRes->RemoveService(pTrigRes->GetServiceName());

    return ERROR_SUCCESS;

} //TrigCluspOffline


BOOL
TrigCluspCheckIsAlive(
    CTrigResource * pTrigRes
    )

/*++

Routine Description:

    Verify that the msmq service of this QM is up and running.

Arguments:

    pqm - pointer to the CQmResource object

Return Value:

    TRUE - The msmq service for this QM is up and running.

    FALSE - The msmq service for this QM is not up and running.

--*/

{
     
	return pTrigRes->CheckIsAlive();

} //TrigCluspCheckIsAlive


DWORD
TrigCluspClusctlResourceGetRequiredDependencies(
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    )
{
    //
    // MSMQTriggers resource depends on MSMQ service.
    // The code is taken from cluster tree.
    //

typedef struct _COMMON_DEPEND_DATA {
    CLUSPROP_SZ_DECLARE( msmq, TABLE_SIZE(xMSMQ) );
    CLUSPROP_SZ_DECLARE( networkEntry, TABLE_SIZE(xNetworkName) );
    CLUSPROP_SYNTAX endmark;
} COMMON_DEPEND_DATA, *PCOMMON_DEPEND_DATA;

typedef struct _COMMON_DEPEND_SETUP {
    DWORD               Offset;
    CLUSPROP_SYNTAX     Syntax;
    DWORD               Length;
    PVOID               Value;
} COMMON_DEPEND_SETUP, * PCOMMON_DEPEND_SETUP;


static COMMON_DEPEND_SETUP CommonDependSetup[] = {
    { FIELD_OFFSET(COMMON_DEPEND_DATA, msmq), CLUSPROP_SYNTAX_NAME, sizeof(xMSMQ), const_cast<LPWSTR>(xMSMQ) },
    { FIELD_OFFSET(COMMON_DEPEND_DATA, networkEntry), CLUSPROP_SYNTAX_NAME, sizeof(xNetworkName), const_cast<LPWSTR>(xNetworkName) },
    { 0, 0 }
};

    try
    {
        PCOMMON_DEPEND_SETUP pdepsetup = CommonDependSetup;
        PCOMMON_DEPEND_DATA pdepdata = (PCOMMON_DEPEND_DATA)OutBuffer;
        CLUSPROP_BUFFER_HELPER value;

        *BytesReturned = sizeof(COMMON_DEPEND_DATA);
        if ( OutBufferSize < sizeof(COMMON_DEPEND_DATA) )
        {
            if ( OutBuffer == NULL )
            {
                return ERROR_SUCCESS;
            }

            return ERROR_MORE_DATA;
        }
        ZeroMemory( OutBuffer, sizeof(COMMON_DEPEND_DATA) );

        while ( pdepsetup->Syntax.dw != 0 )
        {
            value.pb = (PUCHAR)OutBuffer + pdepsetup->Offset;
            value.pValue->Syntax.dw = pdepsetup->Syntax.dw;
            value.pValue->cbLength = pdepsetup->Length;

            switch ( pdepsetup->Syntax.wFormat )
            {
            case CLUSPROP_FORMAT_DWORD:
                value.pDwordValue->dw = (DWORD) DWORD_PTR_TO_DWORD(pdepsetup->Value); //safe cast, the value is known to be a DWORD constant
                break;

            case CLUSPROP_FORMAT_SZ:
                memcpy( value.pBinaryValue->rgb, pdepsetup->Value, pdepsetup->Length );
                break;

            default:
                break;
            }
            pdepsetup++;
        }
        pdepdata->endmark.dw = CLUSPROP_SYNTAX_ENDMARK;
    }
    catch (const bad_alloc&)
    {
        return ERROR_OUTOFMEMORY;
    }

    return ERROR_SUCCESS;

} //TrigCluspClusctlResourceGetRequiredDependencies


DWORD
TrigCluspClusctlResourceSetName(
    VOID
    )
{
    //
    // Refuse to rename the resource
    //
    return ERROR_CALL_NOT_IMPLEMENTED;

} //TrigCluspClusctlResourceSetName


DWORD
TrigCluspClusctlResourceDelete(
    CTrigResource * pTrigRes
    )
{
    (g_pfLogClusterEvent)(pTrigRes->GetReportHandle(), LOG_INFORMATION, L"Deleting resource.\n");

    pTrigRes->RemoveService(pTrigRes->GetServiceName());

    pTrigRes->AddRemoveRegistryCheckpoint(CLUSCTL_RESOURCE_DELETE_REGISTRY_CHECKPOINT);

	//
	// TODO: when Cm will be used, catch exceptions
	//
    pTrigRes->DeleteTrigRegSection();

	pTrigRes->DeleteRegistryForEventLog();

    return ERROR_SUCCESS;

} //TrigCluspClusctlResourceDelete


DWORD
TrigCluspClusctlResourceTypeGetRequiredDependencies(
    PVOID OutBuffer,
    DWORD OutBufferSize,
    LPDWORD BytesReturned
    )
{
    return TrigCluspClusctlResourceGetRequiredDependencies(OutBuffer, OutBufferSize, BytesReturned);

} // TrigCluspClusctlResourceTypeGetRequiredDependencies
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\include\logcodes.hpp ===
//*******************************************************************
//
// File Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*******************************************************************
#ifndef __LOGCODES_INCLUDED
#define __LOGCODES_INCLUDED

#define LOGCAT_ERROR    3
#define LOGCAT_WARNING  2
#define LOGCAT_INFO     1

// Informational
#define LOGEVNT_TRACE                   0
#define LOGEVNT_STARTUP                 1
#define LOGEVNT_TRIGGER_INITIALISED     2
#define LOGEVNT_STATUS_UPDATE	        3
#define LOGEVNT_QUEUE_CREATED           4

// Warnings
#define LOGEVNT_QUEUE_INVALID           100
#define LOGEVNT_MSGBODY_BUFFER_OVERFLOW 101
#define LOGEVNT_UNKNOWN_ENABLEMENT_ID   102

// ERRORS 
#define LOGEVNT_FAILED                     -1

#define LOGEVNT_INIT_FAILED                -1
#define LOGEVNT_QOPEN_FAILED               -2
#define LOGEVNT_THREAD_STOP_FAILED         -3
#define LOGEVNT_WAIT_FAILED                -4
#define LOGEVNT_EXECUTE_ACTION_FAILED      -5 
#define LOGEVNT_COINITIALIZE_FAILED        -6
#define LOGEVNT_COMPONENT_CREATE_FAILED    -7
#define LOGEVNT_METHOD_INVOCATION_FAILED   -8
#define LOGEVNT_RECV_MSG_FAILED            -9
#define LOGEVNT_CREATE_CURSOR_FAILED       -10
#define LOGEVNT_CREATEIOPORT_FAILED        -11
#define LOGEVNT_BINDIOPORT_FAILED          -12
#define LOGEVNT_STOP_REQUEST_FAILED        -13
#define LOGEVNT_HANDLER_CREATE_FAILED      -14
#define LOGEVNT_RECEIVEMSG_FAILED          -15
#define LOGEVNT_PROPBAG_CREATE_FAILED      -16
#define LOGEVNT_THREADPOOL_INIT_FAILED     -17
#define LOGEVNT_THREADPOOL_SHUTDOWN_FAILED -18
#define LOGENVT_ATTACHTRIGGER_FAILED       -19
#define LOGEVNT_OPEN_LOGQUEUE_FAILED       -20
#define LOGEVNT_CREATE_MONITOR_FAILED      -21
#define LOGEVNT_INVALID_CONFIG_PARM        -22
#define LOGEVNT_MEM_ALLOC_FAILED           -23
#define LOGEVNT_CREATE_KEY_FAILED          -24
#define LOGEVNT_INVALID_OBJECT             -25
#define LOGEVNT_GET_CONFIG_PARM_FAILED     -26
#define LOGEVNT_GETQUEUEREF_FAILED         -27
#define LOGEVNT_UNKNOWN_RESULT             -28
#define LOGEVNT_UNKNOWN_ADMIN_MSG_TYPE     -30
#define LOGEVNT_GET_COMPUTER_NAME_FAILED   -31
#define LOGEVNT_QSEND_FAILED			   -32
#define LOGEVNT_PROCESS_RULE_STATUS_STOP   -33
#define LOGEVNT_IDENTIFIED_COM_EXCEPTION   -900
#define LOGEVNT_UNIDENTIFIED_EXCEPTION     -901

#define LOGEVNT_TRIGGER_HAS_NO_RULES      -1
#define LOGEVNT_RULE_INDEX_INVALID        -2
#define LOGEVNT_INVALID_ARG               -3
#define LOGEVNT_ADDTRIGGER_FAILED         -4
#define LOGEVNT_ADDRULE_FAILED            -5
#define LOGEVNT_DELETETRIGGER_FAILED      -5
#define LOGEVNT_GETTRIGGER_FAILED         -6
#define LOGEVNT_CREATE_RS_FAILED          -8
#define LOGEVNT_QGETPATHNAME_FAILED       -9
#define LOGEVNT_REFRESH_FAILED            -10
#define LOGEVNT_USETRIGGERMAP_FAILED      -11
#define LOGEVNT_PARSE_ACTION_FAILED       -12
#define LOGEVNT_PARSE_CONDITION_FAILED    -13
#define LOGEVNT_ACTION_FAILED             -14
#define LOGEVNT_INVOKECOM_FAILED          -15
#define LOGEVNT_CONDITION_EVAL_FAILED     -16

#define LOGEVNT_REFRESH_RULESET_FAILED    -18
#define LOGEVNT_DETACH_RULES              -19
#define LOGEVNT_UPDATETRIGGER_FAILED      -20
#define LOGEVNT_DELETERULE_FAILED         -21
#define LOGEVNT_GET_RULEDETAILS_FAILED    -22 
#define LOGEVNT_GET_COUNT_FAILED          -23
#define LOGEVNT_RULE_REFRESH_FAILED       -24
#define LOGEVNT_MEMALLOC_FAILED           -23

#define LOGEVNT_INVOKEEXE_FAILED          -26
#define LOGEVNT_CONNECT_REGISTRY_FAILED   -27
#define LOGEVNT_LOAD_RULE_FAILED          -28
#define LOGEVNT_DELETE_RULE_FAILED        -29
#define LOGEVNT_LOAD_TRIGGER_FAILED       -30
#define LOGEVNT_LOAD_TRIGGERRULE_FAILED   -31
#define LOGEVNT_DELETE_TRIGGER_FAILED     -32
#define LOGEVNT_DETACH_RULE_FAILED        -33



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\include\queueutil.hpp ===
//*****************************************************************************
//
// Class Name  :
//
// Author      : Yifat Peled
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 4/07/99	| yifatp	| Initial Release
//
//*****************************************************************************
#pragma once

#ifndef _QUEUE_UTIL_H
#define _QUEUE_UTIL_H

//
// Opens the given queue .
// When indicated, if the queue does not exist and should be local - creates the queue
//
HRESULT 
OpenQueue(
	_bstr_t bstrQueuePath,
	DWORD dwAction,
	bool fCreateIfNotExist,
	QUEUEHANDLE* pQHandle,
	_bstr_t* pbstrFormatName
    );	


_bstr_t 
GetDirectQueueFormatName(
    _bstr_t bstrQueuePath
    );


bool 
IsQueueLocal(
    _bstr_t bstrQueuePath
    );


bool 
IsPrivateQPath(
    std::wstring wcsQPath
    );


SystemQueueIdentifier 
IsSystemQueue(
    _bstr_t QueueName
    );


HRESULT 
GenSystemQueueFormatName(
    SystemQueueIdentifier SystemQueue, 
    _bstr_t* pbstrFormatName
    );



#endif //_QUEUE_UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\include\strparse.hpp ===
// CStringTokens.hpp: interface for the CStringTokens class.
//
//////////////////////////////////////////////////////////////////////

#ifndef __STPARSE_H__
#define __STPARSE_H__

#pragma once


typedef std::list< std::wstring > TOKEN_LIST;


class CStringTokens  
{
public:
	CStringTokens();
	virtual ~CStringTokens();

	void Parse(const _bstr_t& bstrString, WCHAR delimiter);
	void GetToken(DWORD tokenIndex, _bstr_t& strToken);
	DWORD GetNumTokens();

private:
	TOKEN_LIST m_lstTokens;
};

#endif // __STPARSE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\include\stdfuncs.hpp ===
//*****************************************************************************
//
// File Name   : stdfuncs.h
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This file contains standard macros and utility functions
//               that are shared accross the MSMQ triggers projects.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef __stdfuncs__
#define __stdfuncs__

#include <time.h>

// registry key values into. 
#define REGKEY_STRING_BUFFER_SIZE 128 * sizeof(TCHAR)

// Define the maximum size of a registry key (255 Unicode chars + null)
#define MAX_REGKEY_NAME_SIZE       512


// Customized trace definitions - allow super long trace messages to the debug window.

#define TRACE_MSG_BUFFER_SIZE 256

#define STRING_MSG_BUFFER_SIZE 256

// Function prototypes for globally available function
void _cdecl FormatBSTR(_bstr_t * pbstrString, LPCTSTR lpszMsgFormat, ...);
void GetTimeAsBSTR(_bstr_t& bstrTime);
void ObjectIDToString(const OBJECTID *pID, WCHAR *wcsResult, DWORD dwSize);

_bstr_t CreateGuidAsString(void);
HRESULT ConvertFromByteArrayToString(VARIANT * pvData);
HRESULT GetVariantTimeOfTime(time_t iTime, VARIANT FAR* pvarTime);
void GetNumericConfigParm(LPCTSTR lpszParmKeyName,LPCTSTR lpszParmName,DWORD * pdwValue,DWORD dwDefaultValue);
bool SetNumericConfigParm(LPCTSTR lpszParmKeyName,LPCTSTR lpszParmName,DWORD dwValue);
bool UpdateMachineNameInQueuePath(_bstr_t bstrOldQPath, _bstr_t MachineName, _bstr_t* pbstrNewQPath);
DWORD GetLocalMachineName(_bstr_t* pbstrMachine);


#endif // __stdfuncs_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\include\stddefs.hpp ===
//*****************************************************************************
//
// File  Name  : stddefs.hpp
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This file contains definitions of constants that are shared 
//               throughout the MSMQ triggers projects and components.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/05/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef STDDEFS_INCLUDED 
#define STDDEFS_INCLUDED

// Define maximum Triggers service name length
#define MAX_TRIGGERS_SERVICE_NAME  200

//
// Define the message labels that will be used in administrative messages.
//
#define MSGLABEL_TRIGGERADDED           _T("MSMQTriggerNotification:TriggerAdded")
#define MSGLABEL_TRIGGERUPDATED         _T("MSMQTriggerNotification:TriggerUpdated")
#define MSGLABEL_TRIGGERDELETED         _T("MSMQTriggerNotification:TriggerDeleted")
#define MSGLABEL_RULEADDED              _T("MSMQTriggerNotification:RuleAdded")
#define MSGLABEL_RULEUPDATED            _T("MSMQTriggerNotification:RuleUpdated")
#define MSGLABEL_RULEDELETED            _T("MSMQTriggerNotification:RuleDeleted")
//
// Define the property names that are passed into the MSMQRuleHandler interface 
// via the MSMQPropertyBag COM component. These definitions are used by both the
// trigger service and the COM dll that implements the default IMSMQRuleHandler 
// interface. Note that these are defined as _bstr_t objects to facilitate string
// comparisons. 
//
const static LPWSTR g_PropertyName_Label = _T("Label");
const static LPWSTR g_PropertyName_MsgID = _T("MessageID");
const static LPWSTR g_PropertyName_MsgBody = _T("MessageBody");
const static LPWSTR g_PropertyName_MsgBodyType = _T("MessageBodyType");
const static LPWSTR g_PropertyName_CorID = _T("CorrelationID");
const static LPWSTR g_PropertyName_MsgPriority = _T("MessagePriority");
const static LPWSTR g_PropertyName_QueuePathname = _T("QueueNamePathname"); 
const static LPWSTR g_PropertyName_QueueFormatname = _T("QueueNameFormatname"); 
const static LPWSTR g_PropertyName_TriggerName = _T("TriggerName"); 
const static LPWSTR g_PropertyName_TriggerID = _T("TriggerID"); 
const static LPWSTR g_PropertyName_ResponseQueueName = _T("ResponseQueueName"); 
const static LPWSTR g_PropertyName_AdminQueueName = _T("AdminQueueName"); 
const static LPWSTR g_PropertyName_AppSpecific = _T("AppSpecific"); 
const static LPWSTR g_PropertyName_SentTime = _T("SentTime"); 
const static LPWSTR g_PropertyName_ArrivedTime = _T("ArrivedTime");
const static LPWSTR g_PropertyName_SrcMachineId = _T("SrcMachineId"); 
const static LPWSTR g_PropertyName_LookupId = _T("LookupId");

//
// Define the bstr's used to denote a conditional test
//
const static LPWSTR g_ConditionTag_MsgLabelContains =   _T("$MSG_LABEL_CONTAINS");
const static LPWSTR g_ConditionTag_MsgLabelDoesNotContain =   _T("$MSG_LABEL_DOES_NOT_CONTAIN");

const static LPWSTR g_ConditionTag_MsgBodyContains =   _T("$MSG_BODY_CONTAINS");
const static LPWSTR g_ConditionTag_MsgBodyDoesNotContain =   _T("$MSG_BODY_DOES_NOT_CONTAIN");

const static LPWSTR g_ConditionTag_MsgPriorityEquals = _T("$MSG_PRIORITY_EQUALS");
const static LPWSTR g_ConditionTag_MsgPriorityNotEqual = _T("$MSG_PRIORITY_NOT_EQUAL");
const static LPWSTR g_ConditionTag_MsgPriorityGreaterThan = _T("$MSG_PRIORITY_GREATER_THAN");
const static LPWSTR g_ConditionTag_MsgPriorityLessThan = _T("$MSG_PRIORITY_LESS_THAN");

const static LPWSTR g_ConditionTag_MsgAppSpecificEquals = _T("$MSG_APPSPECIFIC_EQUALS");
const static LPWSTR g_ConditionTag_MsgAppSpecificNotEqual = _T("$MSG_APPSPECIFIC_NOT_EQUAL");
const static LPWSTR g_ConditionTag_MsgAppSpecificGreaterThan = _T("$MSG_APPSPECIFIC_GREATER_THAN");
const static LPWSTR g_ConditionTag_MsgAppSpecificLessThan = _T("$MSG_APPSPECIFIC_LESS_THAN");

const static LPWSTR g_ConditionTag_MsgSrcMachineIdEquals = _T("$MSG_SRCMACHINEID_EQUALS");
const static LPWSTR g_ConditionTag_MsgSrcMachineIdNotEqual = _T("$MSG_SRCMACHINEID_NOT_EQUAL");


#define ACTION_EXECUTABLETYPE_ORDINAL  0
#define ACTION_COMPROGID_ORDINAL       1
#define ACTION_COMMETHODNAME_ORDINAL   2
#define ACTION_EXE_NAME                1


//
// Define the bstrs that represents message and / or trigger attributes
//
const static LPWSTR g_PARM_MSG_ID							= _T("$MSG_ID");
const static LPWSTR g_PARM_MSG_LABEL						= _T("$MSG_LABEL");
const static LPWSTR g_PARM_MSG_BODY						= _T("$MSG_BODY");
const static LPWSTR g_PARM_MSG_BODY_AS_STRING				= _T("$MSG_BODY_AS_STRING");
const static LPWSTR g_PARM_MSG_PRIORITY					= _T("$MSG_PRIORITY");
const static LPWSTR g_PARM_MSG_ARRIVEDTIME				= _T("$MSG_ARRIVEDTIME");
const static LPWSTR g_PARM_MSG_SENTTIME					= _T("$MSG_SENTTIME");
const static LPWSTR g_PARM_MSG_CORRELATION_ID				= _T("$MSG_CORRELATION_ID");
const static LPWSTR g_PARM_MSG_APPSPECIFIC				= _T("$MSG_APPSPECIFIC");
const static LPWSTR g_PARM_MSG_QUEUE_PATHNAME				= _T("$MSG_QUEUE_PATHNAME");
const static LPWSTR g_PARM_MSG_QUEUE_FORMATNAME			= _T("$MSG_QUEUE_FORMATNAME");
const static LPWSTR g_PARM_MSG_RESPQUEUE_FORMATNAME		= _T("$MSG_RESPONSE_QUEUE_FORMATNAME");
const static LPWSTR g_PARM_MSG_ADMINQUEUE_FORMATNAME		= _T("$MSG_ADMIN_QUEUE_FORMATNAME");
const static LPWSTR g_PARM_MSG_SRCMACHINEID				= _T("$MSG_SRCMACHINEID");
const static LPWSTR g_PARM_MSG_LOOKUPID    				= _T("$MSG_LOOKUP_ID");

const static LPWSTR g_PARM_TRIGGER_NAME              = _T("$TRIGGER_NAME");
const static LPWSTR g_PARM_TRIGGER_ID                = _T("$TRIGGER_ID");

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\include\ruleinfo.hpp ===
//*****************************************************************************
//
// Class Name  : CRuntimeRuleInfo
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class encapsulates the information about a 
//               trigger rule. It is used to cache rule information
//               at runtime about triggers.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef CRuntimeRuleInfo_INCLUDED 
#define CRuntimeRuleInfo_INCLUDED

#include "mqtg.h"

// Define the maximum lengths of the rule properties in characters.
#define MAX_RULE_ID_LEN          128
#define MAX_RULE_NAME_LEN        128
#define MAX_RULE_DESCRIPTION_LEN 255
#define MAX_RULE_PROGID_LEN      255
#define MAX_RULE_CONDITION_LEN   512
#define MAX_RULE_ACTION_LEN      512

// Define the names of the registry values that store the rule properties.
#define REGISTRY_RULE_VALUE_NAME					_T("Name")
#define REGISTRY_RULE_VALUE_IMP_PROGID				_T("ImplementationProgID")
#define REGISTRY_RULE_VALUE_CONDITION				_T("Condition")
#define REGISTRY_RULE_VALUE_ACTION					_T("Action")
#define REGISTRY_RULE_VALUE_DESCRIPTION				_T("Description")
#define REGISTRY_RULE_VALUE_SHOW_WINDOW	        	_T("ShowWindow")

class CRuntimeRuleInfo  
{
	friend class CMSMQRuleSet;

	private:
		HKEY GetRuleKeyHandle( HKEY hRegistry, LPCTSTR ruleId );


	public:
		CRuntimeRuleInfo( LPCTSTR pwzRegPath );
		
		CRuntimeRuleInfo(
				const _bstr_t& bsRuleID, 
				BSTR bsRuleName,
				BSTR bsDescription,
				BSTR bsRuleCondition,
				BSTR bsRuleAction, 
				BSTR bsRuleImplementationProgID,
				LPCTSTR pwzRegPath,
				bool fShowWindow );

		~CRuntimeRuleInfo();

		_bstr_t m_bstrRuleID;
		_bstr_t m_bstrRuleName;
		_bstr_t m_bstrRuleDescription;
		_bstr_t m_bstrImplementationProgID;
		_bstr_t m_bstrAction;
		_bstr_t m_bstrCondition;

		TCHAR m_wzRuleRegPath[MAX_REGKEY_NAME_SIZE];

		bool	m_fShowWindow;

		// This is a reference count of how many triggers currently use this rule. 
		// It is NOT a dynamic reference count against this class instance. 
		//DWORD m_dwTriggerRefCount;

		// Declare an instance of the default (MS) rule handler
		CComPtr<IUnknown> m_MSMQRuleHandler;

		CCriticalSection m_csRuleHandlerLock;

		// Used to determine if this represents a valid rule
		bool IsValid();

		// Methods for managing the persistence of rule definitions.	
		bool Update(HKEY hRegistry);
		bool Create(HKEY hRegistry);
		bool Delete(HKEY hRegistry);
		bool Retrieve(HKEY hRegistry,_bstr_t bstrRuleID);

		// methods used to increment and decrement the reference count on this rule
		//inline DWORD GetRefCount() { return m_dwTriggerRefCount; };
		//inline DWORD IncrementRefCount() { return ++m_dwTriggerRefCount; };
		//inline DWORD DecrementRefCount() { return --m_dwTriggerRefCount; };

		// Used by create and update methods to flush values to registry.
		void FlushValuesToRegistry(const HKEY& hRuleKey);

		// Static validation methods.
		static bool IsValidRuleID(_bstr_t bstrRuleID);
		static bool IsValidRuleName(_bstr_t bstrRuleName);
		static bool IsValidRuleDescription(_bstr_t bstrRuleDescription);
		static bool IsValidRuleCondition(_bstr_t bstrRuleCondition);
		static bool IsValidRuleAction(_bstr_t bstrRuleAction);
		static bool IsValidRuleProgID(_bstr_t bstrRuleProgID);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\include\triginfo.hpp ===
//*****************************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef CRuntimeTriggerInfo_INCLUDED 
#define CRuntimeTriggerInfo_INCLUDED

// Define the maximum lengths of the rule properties
#define MAX_TRIGGER_NAME_LEN        128
#define MAX_TRIGGER_QUEUE_NAME_LEN  255

// Define the names of the registry values that store the rule properties.
#define REGISTRY_TRIGGER_VALUE_NAME          _T("Name")
#define REGISTRY_TRIGGER_VALUE_QUEUE_NAME    _T("Queue")
#define REGISTRY_TRIGGER_VALUE_ENABLED       _T("Enabled")
#define REGISTRY_TRIGGER_VALUE_SERIALIZED    _T("Serialized")
#define REGKEY_TRIGGER_RULES                 _T("Rules")

// Define the key name (relative to REGKEY_TRIGGER_DATA above) where attached rule info is located.
#define REGKEY_TRIGGER_ATTACHED_RULES      _T("AttachedRules")

// Definition of a trigger rule structure
#include "RuleInfo.hpp"
#include "stddefs.hpp"

// Define a new type - a list of Runtime Rule Info
typedef std::list<CRuntimeRuleInfo*> RUNTIME_RULEINFO_LIST;

class CRuntimeTriggerInfo : public CReference
{

	friend class CMSMQTriggerSet;

	private:

		bool m_bAdminTrigger;
		MsgProcessingType m_msgProcType;

		TCHAR m_wzTriggerRegPath[MAX_REGKEY_NAME_SIZE];
		TCHAR m_wzRegPath[MAX_REGKEY_NAME_SIZE];

	protected:

		bool m_bEnabled;
		bool m_bSerialized;

	public:
		CRuntimeTriggerInfo(LPCTSTR pwzRegPath);
				
		CRuntimeTriggerInfo(
			const _bstr_t& bsTriggerID,
			BSTR bsTriggerName, 
			BSTR bsQueueName, 
			LPCTSTR pwzRegPath, 
			SystemQueueIdentifier SystemQueue, 
			bool bEnabled, 
			bool bSerialized,
			MsgProcessingType msgProcType
			);

		~CRuntimeTriggerInfo();

		// TODO : move to private
		_bstr_t m_bstrTriggerID;
		_bstr_t m_bstrTriggerName;
		_bstr_t m_bstrQueueName;

		SystemQueueIdentifier m_SystemQueue;

		// A handle to the queue that the trigger is attached to.
		//HANDLE m_hQueueHandle;

		// A list of CRuntimeRuleInfo class instances.
		RUNTIME_RULEINFO_LIST m_lstRules;

		bool IsEnabled()         {return(m_bEnabled);}
		bool IsSerialized()      {return(m_bSerialized);} 
		bool IsAdminTrigger()    {return(m_bAdminTrigger);}
		long GetNumberOfRules()  {return numeric_cast<long>(m_lstRules.size());}
		
		MsgProcessingType GetMsgProcessingType() 
		{
			return m_msgProcType;
		}
		
		void SetMsgProcessingType(MsgProcessingType msgProcType)
		{
			m_msgProcType = msgProcType;
		}

		void SetAdminTrigger()
		{
			m_bAdminTrigger = true;
		}

		// Returns a reference to the CRuntimeRuleInfo instance at the specified index.
		CRuntimeRuleInfo * GetRule(long lIndex);
			
		// Used to determine if a rule is attached to a trigger.
		bool IsRuleAttached(BSTR sRuleID);

		// Used to determine if this represents a valid trigger
		bool IsValid();

		// Methods for managing the persistence trigger definitions.	
		bool Update(HKEY hRegistry);
		bool Create(HKEY hRegistry);
		bool Delete(HKEY hRegistry);
		HRESULT Retrieve(HKEY hRegistry,_bstr_t bstrRuleID);
		bool Attach(HKEY hRegistry, _bstr_t bstrRuleID,ULONG ulPriority);
		bool Detach(HKEY hRegistry, _bstr_t bstrRuleID);
		bool DetachAllRules(HKEY hRegistry);


		// Static validation methods.
		static bool IsValidTriggerID(_bstr_t bstrRuleID);
		static bool IsValidTriggerName(_bstr_t bstrRuleName);
		static bool IsValidTriggerQueueName(_bstr_t bstrRuleCondition);

    private:
		// Methods for building and clear the rules list.
		void BuildRulesList(HKEY hRegistry,_bstr_t &bstrTriggerID);
		void ClearRulesList();

		//used by attach/detach and detach all rules
		void FlushAttachedRulesToRegistry(const HKEY& hRegistry);
		
        // Used by create and update methods to flush values to registry.
		void FlushValuesToRegistry(const HKEY& hRegistry);

		HKEY GetTriggerKeyHandle( HKEY hRegistry, LPCTSTR triggerId );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\include\msmqtrigbld.h ===
//
// file: MSMQTrigbld.h
//
// Copyright (c) 1997-2000 Microsoft Corporation, All Rights Reserved
//

//
// This file is empty on all machines and should be out to the build machine only
// for specific build macro decleration
//

//#define MSMQTRIG_OFFICIAL_BUILD	// defined only on the official build machine
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\mqgentr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\mqgentr\mqgentr_i_.c ===
#include <mqgentr_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\mqgentr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#ifndef _MQGENTR_H_
#define _MQGENTR_H_


#include <libpch.h>

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_DEBUG_CRT
#define ATLASSERT ASSERT

#include <atlbase.h>

//
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
//
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

#include "mqtrig.tlh"



#endif // _MQGENTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\mqgentr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mqgentr.rc
//
#define IDR_MQGENOBJ                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\mqgentr\mqgenobj.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    mqgenobj.cpp

Abstract:
    Transactional Object for Rules processing

Author:
    Nela Karpel (nelak) 28-Sep-2000

Environment:
    Platform-independent

--*/

#include "stdafx.h"
#include "Mqgentr.h"
#include "mqgenobj.h"
#include <autorel.h>
#include <mqexception.h>
#include "mqtg.h"

#import "mqoat.tlb" no_namespace


static
IMSMQQueue3Ptr 
OpenQueue(
    LPCWSTR queueFormatName,
    long access,
    long deny
    )
{
    IMSMQQueueInfo3Ptr qinfo(L"MSMQ.MSMQQueueInfo");

    _bstr_t qpn(const_cast<LPWSTR>(queueFormatName));
    qinfo->put_FormatName(qpn);

    return qinfo->Open(access, deny);
}


static
void
ReceiveMsgInTransaction(
	IMSMQPropertyBagPtr	pPropBag
	)
{
	HRESULT hr = S_OK;

	_variant_t queueFormatName;
	hr = pPropBag->Read(_bstr_t(g_PropertyName_QueueFormatname), &queueFormatName);
	ASSERT(("Can not read from property bag", SUCCEEDED(hr)));

    IMSMQQueue3Ptr q = OpenQueue(queueFormatName.bstrVal, MQ_RECEIVE_ACCESS, MQ_DENY_NONE);

	_variant_t lookupId;
	hr = pPropBag->Read(_bstr_t(g_PropertyName_LookupId), &lookupId);
	ASSERT(("Can not read from property bag", SUCCEEDED(hr)));

	//
	// To use current MTS transaction context is the 
	// default for Receive()
	//
    q->ReceiveByLookupId(lookupId);

}


static
R<CRuntimeTriggerInfo>
GetTriggerInfo(
	BSTR bstrTrigID,
	BSTR bstrRegPath
	)
{
	//
	// Connect to registry in order to retrieve trigger details
	//
	CAutoCloseRegHandle hHostRegistry;
	LONG lRes = RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hHostRegistry);

	if ( lRes != ERROR_SUCCESS )
	{
		ATLTRACE("Failed to connect to registry.\n");
		throw bad_win32_error(lRes);
	}

	//
	// Build the Trigger Info object
	//
	R<CRuntimeTriggerInfo> pTriggerInfo = new CRuntimeTriggerInfo(bstrRegPath);

	HRESULT hr = pTriggerInfo->Retrieve(hHostRegistry, bstrTrigID);
	if (FAILED(hr))
	{
		ATLTRACE("Failed to retreive trigger info from registry.\n");
		throw _com_error(E_FAIL);
	}

	return pTriggerInfo;
}


//
// CMqGenObj Implementation
//
CMqGenObj::CMqGenObj()
{
	HRESULT hr = CoGetObjectContext(IID_IObjectContext, reinterpret_cast<LPVOID*>(&m_pObjContext));

	if ( FAILED(hr) )
	{
		ATLTRACE("Failed to get Object Context.\n");
		throw _com_error(hr);
	}

	if (!m_pObjContext->IsInTransaction())
	{
		ATLTRACE("Transactional object not in transaction.\n");
		throw _com_error(E_FAIL);
	}	
}


VOID
CMqGenObj::AbortTransaction()
{
	m_pObjContext->SetAbort();
}


STDMETHODIMP 
CMqGenObj::InvokeTransactionalRuleHandlers(
	BSTR bstrTrigID, 
	BSTR bstrRegPath, 
	IUnknown *pPropBagUnknown,
    DWORD dwRuleResult
	)
{	
	IMSMQRuleHandlerPtr pMSQMRuleHandler;
	IMSMQPropertyBagPtr pIPropertyBag(pPropBagUnknown);

	try
	{
		HRESULT hr;
		
		//
		// Retrieve Trigger info
		//
		R<CRuntimeTriggerInfo> pTriggerInfo = GetTriggerInfo(bstrTrigID, bstrRegPath);

		//
		// Create instance of Rule Handler
		//
		hr = pMSQMRuleHandler.CreateInstance(_T("MSMQTriggerObjects.MSMQRuleHandler")); 

		if ( FAILED(hr) )
		{
			ATLTRACE("Failed to create MSMQRuleHandler instance.\n");
			throw bad_hresult(hr);
		}

		//
		// Start rule processing
		//
        DWORD dwRuleIndex=1;
		for (LONG lRuleCtr=0; lRuleCtr < pTriggerInfo->GetNumberOfRules(); lRuleCtr++)
		{
            //
            //for first 32 rules: if corresponding bit in the dwRuleResult is off
            //rule condition is not satisfied
            // we can start checking next rule
            //
            if((lRuleCtr < 32) && ((dwRuleResult & dwRuleIndex) == 0))
            {
                dwRuleIndex<<=1;
                continue;
            }
            dwRuleIndex<<=1;
			CRuntimeRuleInfo* pRule = pTriggerInfo->GetRule(lRuleCtr);
			ASSERT(("Rule index is bigger than number of rules", pRule != NULL));

			// Test if we have an instance of the MSMQRuleHandler - and if not, create one
			if (!pRule->m_MSMQRuleHandler) 
			{
				// Create the interface
				// Copy the local pointer to the rule store.
				pRule->m_MSMQRuleHandler = pMSQMRuleHandler;
				
				// Initialise the MSMQRuleHandling object.
				pMSQMRuleHandler->Init(
									pRule->m_bstrRuleID,
									pRule->m_bstrCondition,
									pRule->m_bstrAction,
									(BOOL)(pRule->m_fShowWindow) 
									);
			}
			else
			{
				// Get a reference to the existing copy.
				pMSQMRuleHandler = pRule->m_MSMQRuleHandler;
			}

			// Initialize the rule result code. 
			long lRuleResult = 0;

			// trace message to determine what rule are firing and in what order.
			ATLTRACE(L"InvokeMSMQRuleHandlers() is about to call ExecuteRule() on the IMSMQRuleHandler interface for rule (%d) named (%s)\n",(long)lRuleCtr,(wchar_t*)pRule->m_bstrRuleName);

			DWORD dwRuleExecStartTime = GetTickCount();

		
			//
			// !!! This is the point at which the IMSMQRuleHandler component is invoked.
			// Note: fQueueSerialized ( 3rd parameter ) is always true - 
			// wait for completion of every action
			//
            long bConditionSatisfied = true;
            
            //
            //for rule numbers > 32 we have no bitmask
            //have to check if condidtion satisfied before call to ExecuteRule
            //
            if(lRuleCtr > 32)           
            {
                pMSQMRuleHandler->CheckRuleCondition(
								pIPropertyBag.GetInterfacePtr(), 
								&bConditionSatisfied);		
            }

            if(bConditionSatisfied) // always true for lRuleCtr < 32
            {
                pMSQMRuleHandler->ExecuteRule(
								pIPropertyBag.GetInterfacePtr(), 
                                TRUE,
								&lRuleResult);		
            }
        
			DWORD dwRuleExecTotalTime = GetTickCount() - dwRuleExecStartTime;

			//
			// Trace message to show the result of the rule firing
			//
			ATLTRACE(L"InvokeMSMQRuleHandlers() has completed the call to ExecuteRule() on the IMSMQRuleHandler interface for rule (%d) named (%s). The rule result code returned was (%d).The time taken in milliseconds was (%d).\n",(long)lRuleCtr,(wchar_t*)pRule->m_bstrRuleName,(long)lRuleResult,(long)dwRuleExecTotalTime);
			

			// if processing the rule result fails, we do not want to process
			// any more rules attached to this trigger. Hence we will break out of 
			// this rule processing loop. 
			//
			if ( lRuleResult & xRuleResultActionExecutedFailed  )
			{
				AbortTransaction();
				return E_FAIL;
			}
			
	
			if(lRuleResult & xRuleResultStopProcessing)
			{
				ATLTRACE(L"Last processed rule (%s) indicated to stop rules processing on Trigger (%s). No further rules will be processed for this message.\n",(LPCTSTR)pRule->m_bstrRuleName,(LPCTSTR)pTriggerInfo->m_bstrTriggerName);						

				//
				// If no one aborted the transaction, it will be commited
				//
				break;
			}
		} // end of rule processing loop

		//
		// Perform Transactional Receive
		//
		ReceiveMsgInTransaction(pIPropertyBag);
		return S_OK;
	}
	catch(const _com_error& e)
	{
		ATLTRACE("InvokeMSMQRuleHandlers() has caught COM exception. Error: %d\n", e.Error());
		AbortTransaction();
		return e.Error();
	}
	catch(const bad_alloc&)
	{
		ATLTRACE("Not enough memory to allocate resources\n");
		AbortTransaction();
		return ERROR_NO_SYSTEM_RESOURCES;	
	}
	catch(const bad_hresult& b)
	{
		ATLTRACE("Bad HRESULT %d\n", b.error());
		AbortTransaction();
		return b.error();
	}
	catch(const bad_win32_error& b)
	{
		ATLTRACE("Windows error %d\n", b.error());
		AbortTransaction();
		return b.error();
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\mqgentr\mqgentr.cpp ===
// mqgentr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f mqgentrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "mqgentr.h"
#include "mqgenobj.h"
#include "cm.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MqGenObj, CMqGenObj)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
    	try
    	{
        	_Module.Init(ObjectMap, hInstance, &LIBID_MQGENTRLib);
	        DisableThreadLibraryCalls(hInstance);

			CmInitialize(HKEY_LOCAL_MACHINE, L"", KEY_READ);

			TrInitialize();
    	}
    	catch(const exception&)
    	{
			return FALSE;
    	}
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\mqgentr\mqgenobj.h ===
// mqgenobj.h : Declaration of the CMqGenObj

#ifndef __MQGENOBJ_H_
#define __MQGENOBJ_H_

#include "resource.h"       // main symbols
#include "triginfo.hpp"
#include <comsvcs.h>

/////////////////////////////////////////////////////////////////////////////
// CMqGenObj
class ATL_NO_VTABLE CMqGenObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMqGenObj, &CLSID_MqGenObj>,
	public IDispatchImpl<IMqGenObj, &IID_IMqGenObj, &LIBID_MQGENTRLib>
{
public:

	CMqGenObj();
	
private:
	VOID GetMyContext();

	VOID AbortTransaction();

// IMqGenObj
public:

DECLARE_REGISTRY_RESOURCEID(IDR_MQGENOBJ)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMqGenObj)
	COM_INTERFACE_ENTRY(IMqGenObj)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

	STDMETHOD(InvokeTransactionalRuleHandlers)(BSTR bstrTrigID, BSTR bstrRegPath, IUnknown *pPropBagUnknown, DWORD dwRuleResult);

private:
	R<IObjectContext> m_pObjContext;
};

#endif //__MQGENOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\actionstest\actionstest.cpp ===
// ActionsTest.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ActionsTestps.mk in the project directory.

#include "stdafx.h"

#include "resource.h"
#include <initguid.h>
#include "ActionsTest.h"
#include "ActionTest.h"

#include "ActionsTest_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ActionTest, CActionTest)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_ACTIONSTESTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\actionstest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#if !defined(AFX_STDAFX_H__7FE25F75_05AF_46C6_8C8B_1E6A7AE7175F__INCLUDED_)
#define AFX_STDAFX_H__7FE25F75_05AF_46C6_8C8B_1E6A7AE7175F__INCLUDED_

#include <libpch.h>

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_DEBUG_CRT
#define ATLASSERT ASSERT

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.


#endif // !defined(AFX_STDAFX_H__7FE25F75_05AF_46C6_8C8B_1E6A7AE7175F__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\actionstest\actiontest.cpp ===
// ActionTest.cpp : Implementation of CActionTest
#include "stdafx.h"
#include "ActionsTest.h"
#include "ActionTest.h"
#include "stdfuncs.hpp"

/////////////////////////////////////////////////////////////////////////////
// CActionTest

STDMETHODIMP CActionTest::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IActionTest
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

CActionTest::CActionTest()
{
}

CActionTest::~CActionTest()
{
	MQCloseQueue(m_hQ);
}




STDMETHODIMP CActionTest::MessageParams(VARIANT MsgID, BSTR MsgLabel, VARIANT MsgBodyAsVar, BSTR MsgBodyAsString, long Priority, VARIANT MsgCorlID, BSTR QueuePath, BSTR QueueFormat, BSTR ResponseQ, BSTR AdminQ, long AppSpecific, DATE SentTime,DATE ArrivedTime, BSTR SrcMachine, BSTR TriggerName, BSTR TriggerID, BSTR LiteralString, long Number)
{
	try
	{
		HRESULT hr = S_OK;

		_bstr_t FileName = LiteralString;
		
		WCHAR wcsBuf[512];
		wsprintf(wcsBuf, L"%d", Number);

		FileName += wcsBuf;
		FileName += L".txt";

		m_wofsFile.open((char*)FileName, ios_base::out | ios_base::app);


		if(!ComparePathName2FormatName(QueuePath, QueueFormat))
		{
			m_wofsFile << L"FAILED: PathName and FormatName parameters don't match"	<<endl;
			return S_FALSE;
		}
		
		m_wofsFile << L"Queue PathName and FormatName passed successfully. (they match)" <<endl;
	
		hr = ReadMessageFromQueue(QueueFormat);	
		if(hr != S_OK)
			return hr;
			
		//check message Id 
		wstring wcsMsgIdFromTrigger;
		wstring wcsMsgIdFromMessage;

		hr = OBJECTIDVar2String(MsgID, wcsMsgIdFromTrigger);
		if(FAILED(hr))
			return hr;

		hr = OBJECTID2String((OBJECTID*)(m_MsgProps.aPropVar[MSG_ID].caub.pElems), wcsMsgIdFromMessage);
		if(FAILED(hr))
			return hr;

        //
        // BUGBUG: using this ugly code due ambiguoty problem in MSMQ enviroment. 
        //
		if(! (wcsMsgIdFromTrigger == wcsMsgIdFromMessage))
		{
			m_wofsFile << L"FAILED: Msg Id param is diffrent, either different message in queue or passed corrupted" << endl;
			return S_FALSE;
		}
		
		m_wofsFile << L"MsgId parameter was passed successfully"<<endl;
		

		//check messag label
		if( (MsgLabel == NULL && m_MsgProps.aPropVar[MSG_LABEL].pwszVal != NULL) ||
			(MsgLabel != NULL && m_MsgProps.aPropVar[MSG_LABEL].pwszVal == NULL) ||
			(_bstr_t(MsgLabel) != _bstr_t(m_MsgProps.aPropVar[MSG_LABEL].pwszVal)) )
		{
			m_wofsFile << L"FAILED: Msg Label param is different." << endl;
			return S_FALSE;	
		}
			
		m_wofsFile << L"MsgLabel parameter was passed successfully"<<endl;

		//check priority
		if(Priority != m_MsgProps.aPropVar[MSG_PRIORITY].bVal)
		{
			m_wofsFile << L"FAILED: Msg Priority param is different." << endl;
			return S_FALSE;	
		}

		m_wofsFile << L"MsgPriority parameter was passed successfully"<<endl;

		//check AppSpecific
		if(numeric_cast<DWORD>(AppSpecific) != m_MsgProps.aPropVar[MSG_APP_SPECIFIC].ulVal)
		{
			m_wofsFile << L"FAILED: Msg AppSpecific param is different." << endl;
			return S_FALSE;	
		}

		m_wofsFile << L"MsgAppSpecific parameter was passed successfully"<<endl;


		//check response queue
		if( (ResponseQ == NULL && m_MsgProps.aPropVar[MSG_RESPONSEQ].pwszVal != NULL) ||
			(ResponseQ != NULL && m_MsgProps.aPropVar[MSG_RESPONSEQ].pwszVal == NULL) ||
			(_bstr_t(ResponseQ) != _bstr_t(m_MsgProps.aPropVar[MSG_RESPONSEQ].pwszVal)) )
		{
			m_wofsFile << L"FAILED: Msg ResponseQ param is different." << endl;
			return S_FALSE;	
		}
			
		m_wofsFile << L"Msg ResponseQ parameter was passed successfully"<<endl;


		//check admin queue
		if( (AdminQ == NULL && m_MsgProps.aPropVar[MSG_ADMINQ].pwszVal != NULL) ||
			(AdminQ != NULL && m_MsgProps.aPropVar[MSG_ADMINQ].pwszVal == NULL) ||
			(_bstr_t(AdminQ) != _bstr_t(m_MsgProps.aPropVar[MSG_ADMINQ].pwszVal)) )
		{
			m_wofsFile << L"FAILED: Msg AdminQ param is different." << endl;
			return S_FALSE;	
		}
			
		m_wofsFile << L"Msg AdminQ parameter was passed successfully"<<endl;


		//check correlation Id 
		wstring wcsCorrIdFromTrigger;
		wstring wcsCorrIdFromMessage;

		hr = OBJECTIDVar2String(MsgCorlID, wcsCorrIdFromTrigger);
		if(FAILED(hr))
			return hr;

		hr = OBJECTID2String((OBJECTID*)(m_MsgProps.aPropVar[MSG_CORRID].caub.pElems), wcsCorrIdFromMessage);
		if(FAILED(hr))
			return hr;

        //
        // BUGBUG: using this ugly code due ambiguoty problem in MSMQ enviroment. 
        //
		if(!(wcsCorrIdFromTrigger == wcsCorrIdFromMessage))
		{
			m_wofsFile << L"FAILED: Msg Corr param is diffrent" << endl;
			return S_FALSE;
		}
		
		m_wofsFile << L"Msg correlation parameter was passed successfully"<<endl;
		

		//check sent time
		{
			VARIANT vtDate;
			VariantInit(&vtDate);
			vtDate.vt = VT_DATE;
			vtDate.date = SentTime;

			_bstr_t bstrSentTimeFromTriggers = (_bstr_t)(_variant_t(vtDate));

			VARIANT vSentTime;
			VariantInit(&vSentTime);

			GetVariantTimeOfTime(m_aVariant[MSG_SENT_TIME].ulVal, &vSentTime);

			_bstr_t bstrSentTimeFromMessage = (_bstr_t)(_variant_t(vSentTime));

			if(bstrSentTimeFromTriggers != bstrSentTimeFromMessage)
			{
				m_wofsFile << L"FAILED: Msg SentTime param is diffrent" << endl;
				return S_FALSE;
			}
			
			m_wofsFile << L"Msg SentTime parameter was passed successfully"<<endl;
		}

		{

			//check arrived time
			VARIANT vtDate;
			VariantInit(&vtDate);
			vtDate.vt = VT_DATE;
			vtDate.date = ArrivedTime;

			_bstr_t bstrArrivedTimeFromTriggers = (_bstr_t)(_variant_t(vtDate));

			VARIANT vArrivedTime;
			VariantInit(&vArrivedTime);

			GetVariantTimeOfTime(m_aVariant[MSG_ARRIVED_TIME].ulVal, &vArrivedTime);

			_bstr_t bstrArrivedTimeFromMessage = (_bstr_t)(_variant_t(vArrivedTime));

			if(bstrArrivedTimeFromTriggers != bstrArrivedTimeFromMessage)
			{
				m_wofsFile << L"FAILED: Msg ArrivedTime param is diffrent" << endl;
				return S_FALSE;
			}
			
			m_wofsFile << L"Msg ArrivedTime parameter was passed successfully"<<endl;
		}

		
		//check src machine id param
		wstring wcsSrcMachineIdFromMessage;

		hr = GUID2String(m_aVariant[MSG_SRC_MACHINE_ID].puuid, wcsSrcMachineIdFromMessage);
		if(FAILED(hr))
			return hr;
		
		wstring wcsSrcMachineFromTriggers = (SrcMachine == NULL) ? L"" : (WCHAR*)_bstr_t(SrcMachine);
		if(SrcMachine == NULL ||
            //
            // BUGBUG: using this ugly code due ambiguoty problem in MSMQ enviroment. 
            //
			!(wcsSrcMachineFromTriggers == wcsSrcMachineIdFromMessage))
		{
			m_wofsFile << L"FAILED: Msg src machine id different." << endl;
			return S_FALSE;	
		}
			
		m_wofsFile << L"Msg src machine id parameter was passed successfully"<<endl;

		//check body as variant
		if( (MsgBodyAsVar.vt == VT_EMPTY && m_MsgProps.aPropVar[MSG_BODY].caub.pElems!= NULL) ||
			(MsgBodyAsVar.vt != VT_EMPTY && m_MsgProps.aPropVar[MSG_BODY].caub.pElems == NULL) )
		{
			m_wofsFile << L"FAILED: Msg body as variant different." << endl;
			return S_FALSE;	
		}

		bool fEq = CompareVar2ByteArray(MsgBodyAsVar, m_MsgProps.aPropVar[MSG_BODY].caub.pElems, m_MsgProps.aPropVar[MSG_BODY].caub.cElems);  
		if(!fEq)
		{
			m_wofsFile << L"FAILED: Msg body as variant different." << endl;
			return S_FALSE;	
		}
			
		m_wofsFile << L"Msg body as variant parameter was passed successfully"<<endl;

		if( (MsgBodyAsString == NULL && m_MsgProps.aPropVar[MSG_BODY_TYPE].ulVal == VT_BSTR) ||
			(MsgBodyAsString != NULL && m_MsgProps.aPropVar[MSG_BODY_TYPE].ulVal != VT_BSTR) )
		{
			m_wofsFile << L"FAILED: Msg body as string different." << endl;
			return S_FALSE;	
		}

		//check body as string
		if(m_MsgProps.aPropVar[MSG_BODY_TYPE].ulVal == VT_BSTR)
		{
			_bstr_t bstrBodyFromTriggers(MsgBodyAsString);
			_bstr_t bstrBodyFromMessage;

			WCHAR* pwcs = new WCHAR[(m_MsgProps.aPropVar[MSG_BODY].caub.cElems)/sizeof(WCHAR) + 1];
			memcpy((void*)pwcs, m_MsgProps.aPropVar[MSG_BODY].caub.pElems, m_MsgProps.aPropVar[MSG_BODY].caub.cElems);
			pwcs[(m_MsgProps.aPropVar[MSG_BODY].caub.cElems)/sizeof(WCHAR)] = L'\0';
						
			bstrBodyFromMessage = pwcs;
			delete pwcs;
				
			if(bstrBodyFromTriggers != bstrBodyFromMessage)
			{
				m_wofsFile << L"FAILED: Msg body as string different." << endl;
				return S_FALSE;	
			}
			
			m_wofsFile << L"Msg body as string parameter was passed successfully"<<endl;

			
			//check TriggerName and Id
			wstring Body = (WCHAR*)bstrBodyFromMessage;
			wstring::size_type pos = Body.find_first_of(L",");
			if(pos != wstring::npos)
			{
				wstring Name = Body.substr(0, pos);
				wstring Id = Body.substr(pos + 1, wstring::npos);

				wstring NameFromTriggers = (WCHAR*)_bstr_t(TriggerName);
				wstring IDFromTriggers = (WCHAR*)_bstr_t(TriggerID);

                //
                // BUGBUG: using this ugly code due ambiguoty problem in MSMQ enviroment. 
                //
				if(!(Name == NameFromTriggers))
				{
					m_wofsFile << L"FAILED: Trigger Name wasn't passed correctly" << endl;
					return S_FALSE;	
				}

				m_wofsFile << L"Trigger Name was passed successfully"<<endl;

                //
                // BUGBUG: using this ugly code due ambiguoty problem in MSMQ enviroment. 
                //
				if(!(Id == IDFromTriggers))
				{
					m_wofsFile << L"FAILED: Trigger ID wasn't passed correctly" << endl;
					return S_FALSE;	
				}
				
				m_wofsFile << L"Trigger ID was passed successfully"<<endl;
			}

		}
		
		m_wofsFile << endl << L"All message params were passed successfully. TEST PASSED"<<endl;
			
		return S_OK;
	}
	catch(const _com_error&)
	{
		return E_FAIL;
	}
}


bool CActionTest::ComparePathName2FormatName(_bstr_t PathName, _bstr_t FormatName)
{
	_bstr_t FormatNameAccordingToPathName;

	//check direct first
	FormatNameAccordingToPathName = L"DIRECT=OS:";
	FormatNameAccordingToPathName += PathName;

	if(!_wcsicmp((WCHAR*)FormatName, (WCHAR*)FormatNameAccordingToPathName))
	{
		return true;
	}
	
	//check by converting PathName to FormatName
	DWORD dwLen = wcslen((WCHAR*)FormatName) + 1;
	WCHAR* pFormatNameBuffer = new WCHAR[dwLen];
	
	
	HRESULT hr = MQPathNameToFormatName(
						(WCHAR*)PathName, 
						pFormatNameBuffer,
						&dwLen);
	
	if(FAILED(hr))
		return false;
		
	return (!_wcsicmp(FormatName, pFormatNameBuffer));	
}


HRESULT CActionTest::ReadMessageFromQueue(_bstr_t QueueFormat)
{
	
	HRESULT hr = MQOpenQueue(
						(WCHAR*)QueueFormat,
						MQ_RECEIVE_ACCESS,
						MQ_DENY_NONE,
						&m_hQ );

	if(FAILED(hr))
	{
		m_wofsFile << L"FAILED: Failed to open queue with format name "<< (WCHAR*)_bstr_t(QueueFormat) << L" error was "<< hr << endl;
		return S_FALSE;
	}

	m_MsgProps.cProp = 0;
	m_MsgProps.aPropID = m_aPropId;
	m_MsgProps.aPropVar = m_aVariant;
	m_MsgProps.aStatus = NULL;

	m_aPropId[MSG_BODY_SIZE] = PROPID_M_BODY_SIZE;       
	m_aVariant[MSG_BODY_SIZE].vt = VT_UI4;                  
	m_aVariant[MSG_BODY_SIZE].ulVal = 0;

	m_MsgProps.cProp++;

	m_aPropId[MSG_LABEL_LEN] = PROPID_M_LABEL_LEN;
	m_aVariant[MSG_LABEL_LEN].vt = VT_UI4;       
	m_aVariant[MSG_LABEL_LEN].ulVal = 0; 

	m_MsgProps.cProp++;
	
	m_aPropId[MSG_RESPQ_NAME_LEN] = PROPID_M_RESP_QUEUE_LEN;  
	m_aVariant[MSG_RESPQ_NAME_LEN].vt = VT_UI4;               
	m_aVariant[MSG_RESPQ_NAME_LEN].ulVal = 0;    

	m_MsgProps.cProp++;

	m_aPropId[MSG_ADMINQ_NAME_LEN] = PROPID_M_ADMIN_QUEUE_LEN;  
	m_aVariant[MSG_ADMINQ_NAME_LEN].vt = VT_UI4;               
	m_aVariant[MSG_ADMINQ_NAME_LEN].ulVal = 0; 

	m_MsgProps.cProp++;

	
	//peek message len
	hr = MQReceiveMessage(
			m_hQ,
			0,
			MQ_ACTION_PEEK_CURRENT,
			&m_MsgProps,
			NULL,
			NULL,
			NULL, 
			NULL );

	if(FAILED(hr))
	{
		m_wofsFile << L"FAILED: Failed to peek at message from queue "<< (WCHAR*)_bstr_t(QueueFormat) << L" error was "<< hr << endl;
		return S_FALSE;
	}

	DWORD dwBodySize = m_aVariant[MSG_BODY_SIZE].ulVal;
	DWORD dwLabelLen = m_aVariant[MSG_LABEL_LEN].ulVal;
	DWORD dwResponseQLen = m_aVariant[MSG_RESPQ_NAME_LEN].ulVal;
	DWORD dwAdminQLen = m_aVariant[MSG_ADMINQ_NAME_LEN].ulVal;

	m_MsgProps.cProp = MAX_ACTION_PROPS;

	m_aPropId[MSG_ID] = PROPID_M_MSGID;                   
	m_aVariant[MSG_ID].vt = VT_VECTOR | VT_UI1;           
	m_aVariant[MSG_ID].caub.cElems = MSG_ID_BUFFER_SIZE; 
	m_aVariant[MSG_ID].caub.pElems = new unsigned char[MSG_ID_BUFFER_SIZE]; 

	m_aPropId[MSG_LABEL] = PROPID_M_LABEL; 
	m_aVariant[MSG_LABEL].vt = VT_LPWSTR;
	m_aVariant[MSG_LABEL].pwszVal = (WCHAR*)new WCHAR[dwLabelLen];

	m_aPropId[MSG_BODY_TYPE] = PROPID_M_BODY_TYPE;       
	m_aVariant[MSG_BODY_TYPE].vt = VT_UI4;                  
	m_aVariant[MSG_BODY_TYPE].ulVal = 0; 
	
	m_aPropId[MSG_BODY] = PROPID_M_BODY;               
	m_aVariant[MSG_BODY].vt = VT_VECTOR|VT_UI1; 
	m_aVariant[MSG_BODY].caub.cElems = dwBodySize;  
	m_aVariant[MSG_BODY].caub.pElems = new unsigned char[dwBodySize]; 

	m_aPropId[MSG_PRIORITY] = PROPID_M_PRIORITY; 
	m_aVariant[MSG_PRIORITY].vt = VT_UI1;        
		
	m_aPropId[MSG_CORRID] = PROPID_M_CORRELATIONID;      
	m_aVariant[MSG_CORRID].vt = VT_VECTOR|VT_UI1;       
	m_aVariant[MSG_CORRID].caub.cElems = MSG_ID_BUFFER_SIZE; 
	m_aVariant[MSG_CORRID].caub.pElems = new unsigned char[MSG_ID_BUFFER_SIZE]; 

	m_aPropId[MSG_RESPONSEQ] = PROPID_M_RESP_QUEUE;    
	m_aVariant[MSG_RESPONSEQ].vt = VT_LPWSTR;          
	m_aVariant[MSG_RESPONSEQ].pwszVal = new WCHAR[dwResponseQLen];

	m_aPropId[MSG_ADMINQ] = PROPID_M_ADMIN_QUEUE;         
	m_aVariant[MSG_ADMINQ].vt = VT_LPWSTR;               
	m_aVariant[MSG_ADMINQ].pwszVal = new WCHAR[dwAdminQLen]; 

	m_aPropId[MSG_APP_SPECIFIC] = PROPID_M_APPSPECIFIC;       
	m_aVariant[MSG_APP_SPECIFIC].vt = VT_UI4;                  
	m_aVariant[MSG_APP_SPECIFIC].ulVal = 0;    

	m_aPropId[MSG_SENT_TIME] = PROPID_M_SENTTIME;       
	m_aVariant[MSG_SENT_TIME].vt = VT_UI4;                  
	m_aVariant[MSG_SENT_TIME].ulVal = 0; 

	m_aPropId[MSG_ARRIVED_TIME] = PROPID_M_ARRIVEDTIME;       
	m_aVariant[MSG_ARRIVED_TIME].vt = VT_UI4;                  
	m_aVariant[MSG_ARRIVED_TIME].ulVal = 0; 

	m_aPropId[MSG_SRC_MACHINE_ID] = PROPID_M_SRC_MACHINE_ID ;
	m_aVariant[MSG_SRC_MACHINE_ID].vt = VT_CLSID;
	m_aVariant[MSG_SRC_MACHINE_ID].puuid = new GUID;

	hr = MQReceiveMessage(m_hQ, 0, MQ_ACTION_RECEIVE, &m_MsgProps, NULL, NULL, NULL, NULL);
	if(FAILED(hr))
	{
		m_wofsFile << L"FAILED: Failed to receive message from queue "<< (WCHAR*)_bstr_t(QueueFormat) << L" error was "<< hr << endl;
		return S_FALSE;
	}

	return S_OK;
}

HRESULT CActionTest::OBJECTIDVar2String(VARIANT& Val, wstring& wcsVal)
{
	BYTE obj[20];
	WCHAR* pwcs = NULL;
	memset(&obj, 0, sizeof(OBJECTID));

	long type = VT_ARRAY | VT_UI1;

	if(Val.vt == type)
	{
		long i, UBound;

		SafeArrayLock(Val.parray);
		SafeArrayGetUBound(Val.parray, 1, &UBound);
		for(i=0; i<UBound && i < 20;i++)
		{
			SafeArrayGetElement(Val.parray, &i, (void*)&(obj[i]));
		}
		SafeArrayUnlock(Val.parray);
		UuidToString(&(((OBJECTID*)obj)->Lineage), &pwcs);
		wcsVal = pwcs;
		RpcStringFree( &pwcs );

		WCHAR szI4[12];
		_ltow(((OBJECTID*)obj)->Uniquifier, szI4, 10);
	
		wcsVal += L"\\";
		wcsVal += szI4;

		return S_OK;
	}
		
	return E_FAIL;
}


HRESULT CActionTest::OBJECTID2String(OBJECTID* pObj, wstring& wcsVal)
{
	WCHAR* pwcs = NULL;

	RPC_STATUS status = UuidToString(&(pObj->Lineage), &pwcs);
	if(status != RPC_S_OK)
		return E_FAIL;
	wcsVal = pwcs;
	RpcStringFree( &pwcs );

	WCHAR szI4[12];
	_ltow(pObj->Uniquifier, szI4, 10);
	
	wcsVal += L"\\";
	wcsVal += szI4;

	return S_OK;
}


HRESULT CActionTest::GUID2String(GUID* pGuid, wstring& wcsVal)
{
	WCHAR* pwcs = NULL;

	RPC_STATUS status = UuidToString(pGuid, &pwcs);
	if(status != RPC_S_OK)
		return E_FAIL;
	wcsVal = pwcs;
	RpcStringFree( &pwcs );

	return S_OK;
}


bool CActionTest::CompareVar2ByteArray(VARIANT& Var, BYTE* pBuffer, DWORD Size)
{
	if(Var.vt != (VT_ARRAY | VT_UI1))
		return false;

	long UBound = 0;
	BYTE* pVarBuffer;
	SafeArrayLock(Var.parray);

	SafeArrayGetUBound(Var.parray, 1, &UBound);

	if(numeric_cast<DWORD>(UBound + 1) != Size) //starts from 0
		return false;

	SafeArrayAccessData(Var.parray, (void**)&pVarBuffer);

	int fCmp = memcmp((void*)pBuffer, (void*)pVarBuffer , Size);

	SafeArrayUnaccessData(Var.parray);

	SafeArrayUnlock(Var.parray);

	return (fCmp == 0) ? true : false;
}

/*
HRESULT CActionTest::GUIDVarIs(bstr_t bstrPropName,VARIANT& Val)
{
	BYTE obj[20];
	WCHAR* pwcs = NULL;
	memset(&obj, 0, sizeof(OBJECTID));

	long type = VT_ARRAY | VT_UI1;

	std::wstring wcs = (wchar_t*)bstrPropName;
	wcs += L" Is: ";

	if(Val.vt == type)
	{
		long i, UBound;

		SafeArrayLock(Val.parray);
		SafeArrayGetUBound(Val.parray, 1, &UBound);
		for(i=0; i<UBound && i < 20;i++)
		{
			SafeArrayGetElement(Val.parray, &i, (void*)&(obj[i]));
		}
		SafeArrayUnlock(Val.parray);
		UuidToString(&(((OBJECTID*)obj)->Lineage), &pwcs);
		wcs += pwcs;
		RpcStringFree( &pwcs );

		WCHAR szI4[12];
		_ltow(((OBJECTID*)obj)->Uniquifier, szI4, 10);
	
		wcs += L"\\";
		wcs += szI4;

		m_wofsFile << wcs.c_str() << endl;

		return S_OK;
	}
		
	return E_FAIL;
}


HRESULT CActionTest::StringIs(_bstr_t bstrPropName, BSTR& Val)
{
	std::wstring wcs = (wchar_t*)bstrPropName;
	wcs += L" Is: ";
	wcs += (WCHAR*)_bstr_t(Val);

	m_wofsFile << wcs.c_str() << endl;
	return S_OK;
}

HRESULT CActionTest::VarIs(_bstr_t bstrPropName, VARIANT& Val)
{
	std::wstring wcs = (wchar_t*)bstrPropName;
	wcs += L" Is: ";
	_bstr_t bstr = (_bstr_t)(_variant_t(Val));
	wcs += (WCHAR*)bstr;
	
	m_wofsFile << wcs.c_str() << endl;
	return S_OK;
}
	

HRESULT CActionTest::LongIs(_bstr_t bstrPropName, long Val)
{
	std::wstring wcs = bstrPropName;
	wcs += L" Is: ";
	
	WCHAR wcsBuf[512];
	wsprintf(wcsBuf, L"%d", Val);

	wcs += wcsBuf;

	m_wofsFile << wcs.c_str() << endl;
	return S_OK;
}


HRESULT CActionTest::DateIs(_bstr_t bstrPropName, DATE& Val)
{
	VARIANT vtDate;
	VariantInit(&vtDate);
	vtDate.vt = VT_DATE;
	vtDate.date = Val;

	_bstr_t bstr = (_bstr_t)(_variant_t(vtDate));

	std::wstring wcs = bstrPropName;
	wcs += L" Is: ";
	
	wcs += (WCHAR*)bstr;

	m_wofsFile << wcs.c_str() << endl;
	
	return S_OK;
}
*/

/*
HRESULT  CActionTest::ConverFromByteArray2Variant(BYTE* pByteArray, DWORD size,  _variant_t& vtArray)
{
	HRESULT hr = S_OK;
	
	VARIANT Var;
	VariantInit(&Var);

	BYTE* pBuffer;

	SAFEARRAY * psaBytes = NULL;
	SAFEARRAYBOUND aDim[1];
	
	// Initialise the dimension structure for the safe array.
	aDim[0].lLbound = 0;
	aDim[0].cElements = size;

	// Create a safearray of bytes
	psaBytes = SafeArrayCreate(VT_UI1,1,aDim);
	if (psaBytes == NULL)
	{ 
		return S_FALSE;
	}

	hr = SafeArrayAccessData(psaBytes,(void**)&pBuffer);
	if SUCCEEDED(hr)
	{
		// Copy the body from the message object to the safearray data buffer.
		memcpy(pBuffer, pByteArray, size);

		// Return the safe array if created successfully.
		Var.vt = VT_ARRAY | VT_UI1;
		Var.parray = psaBytes;

		hr = SafeArrayUnaccessData(Var.parray);
		if FAILED(hr)
		{
			SafeArrayDestroy(psaBytes);
			Var.vt = VT_ERROR;
		}
	}
	else
	{
		Var.vt = VT_ERROR;
	}

	vtArray = Var;	
	
	return S_OK;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\createtriggerq\createtriggerq.cpp ===
// CreateTriggerQ.cpp : Defines the entry point for the console application.
//
#include "libpch.h"
#include <mq.h>

#include "CInputParams.h"
#include "GenMQSec.h"

using namespace std;

int __cdecl wmain(int argc, wchar_t* argv[])
{
	CInputParams Input(argc, argv);

	wstring wcsQPath = Input[L"QPath"];
	bool fTransacted = Input.IsOptionGiven(L"Trans");

	PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
	SECURITY_INFORMATION* pSecInfo = NULL;
	wstring wscSecurity = L"+:* A";
		
	DWORD dwError = GenSecurityDescriptor(
							pSecInfo,
							wscSecurity.c_str(),
							&pSecurityDescriptor );

	if(dwError != 0)
	{
		wprintf(L"Failed to create security descriptor");					
		return -1;
	}

	WCHAR wcsFormatName[255];
	ZeroMemory(wcsFormatName,sizeof(wcsFormatName));
	DWORD dwFormatNameLen = 255;

	MQQUEUEPROPS QueueProps;
	PROPVARIANT aVariant[2];
	QUEUEPROPID aPropId[2];
	DWORD PropIdCount = 0;

	WCHAR* pwcs = new WCHAR[wcsQPath.length() + 1];
	wcscpy(pwcs, wcsQPath.c_str());

	//Set the PROPID_Q_PATHNAME property.
	aPropId[PropIdCount] = PROPID_Q_PATHNAME;    //PropId
	aVariant[PropIdCount].vt = VT_LPWSTR;        //Type
	aVariant[PropIdCount].pwszVal = pwcs;
    	
	PropIdCount++;
    
	aPropId[PropIdCount] = PROPID_Q_TRANSACTION; 
	aVariant[PropIdCount].vt = VT_UI1;
	aVariant[PropIdCount].bVal = (fTransacted ? MQ_TRANSACTIONAL : MQ_TRANSACTIONAL_NONE);
	
	PropIdCount++;

	//Set the MQQUEUEPROPS structure.
	QueueProps.cProp = PropIdCount;           //No of properties
	QueueProps.aPropID = aPropId;             //Ids of properties
	QueueProps.aPropVar = aVariant;           //Values of properties
	QueueProps.aStatus = NULL;                //No error reports

	// Attempt to create the notifications queue.
	HRESULT hr = MQCreateQueue(
					pSecurityDescriptor,
					&QueueProps,
					wcsFormatName,
					&dwFormatNameLen );

	delete pwcs;

	// Check if the queue already existed or if we got an error etc...
	switch(hr)
	{
		case MQ_OK: 
			break;

		case MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL: 
			break;

		case MQ_ERROR_QUEUE_EXISTS: 
			break;
		
		default: // Error
		{
			wprintf(L"Failed to create the queue\n");
			return -1;
		}
	}


	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\actionstest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ActionsTest.rc
//
#define IDR_ACTIONTEST                  101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\actionstest\actiontest.h ===
// ActionTest.h : Declaration of the CActionTest

#ifndef __ACTIONTEST_H_
#define __ACTIONTEST_H_

#include "resource.h"       // main symbols
#include <mq.h>

using namespace std;

enum ActionMsgProps
{
	MSG_BODY_SIZE = 0,
	MSG_LABEL_LEN, 
	MSG_RESPQ_NAME_LEN,
	MSG_ADMINQ_NAME_LEN, 
	MSG_ID,
	MSG_LABEL,
	MSG_BODY_TYPE,
	MSG_BODY,
	MSG_PRIORITY,
	MSG_CORRID,
	MSG_RESPONSEQ,
	MSG_ADMINQ,
	MSG_APP_SPECIFIC,
	MSG_SENT_TIME,
	MSG_ARRIVED_TIME,
	MSG_SRC_MACHINE_ID,
	MAX_ACTION_PROPS
};

#define MSG_ID_BUFFER_SIZE 20

/////////////////////////////////////////////////////////////////////////////
// CActionTest
class ATL_NO_VTABLE CActionTest : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CActionTest, &CLSID_ActionTest>,
	public ISupportErrorInfo,
	public IDispatchImpl<IActionTest, &IID_IActionTest, &LIBID_ACTIONSTESTLib>
{
public:
	CActionTest();
	~CActionTest();

DECLARE_REGISTRY_RESOURCEID(IDR_ACTIONTEST)
DECLARE_NOT_AGGREGATABLE(CActionTest)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CActionTest)
	COM_INTERFACE_ENTRY(IActionTest)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IActionTest
public:
	STDMETHOD(MessageParams)(/*[in]*/ VARIANT MsgID, /*[in]*/BSTR MsgLabel, /*[in]*/VARIANT MsgBodyAsVar,/*[in]*/BSTR MsgBodyAsString,/*[in]*/long Priority, /*[in]*/VARIANT MsgCorlID, /*[in]*/BSTR QueuePath, /*[in]*/BSTR QueueFormat, /*[in]*/BSTR ResponseQ,/*[in]*/ BSTR AdminQ, /*[in]*/long AppSpecific, /*[in]*/DATE SentTime, /*[in]*/DATE ArrivedTime, /*[in]*/BSTR SrcMachine, /*[in]*/BSTR TriggerName, /*[in]*/BSTR TriggerID, /*[in]*/BSTR LiteralString, /*[in]*/long Number);
private:

	HRESULT ReadMessageFromQueue(_bstr_t QueueFormat);

	HRESULT OBJECTIDVar2String(VARIANT& Val, wstring& wcsVal);
	HRESULT GUID2String(GUID* pGuid, wstring& wcsVal);
	HRESULT OBJECTID2String(OBJECTID* pObj, wstring& wcsVal);
	bool CompareVar2ByteArray(VARIANT& Var, BYTE* pBuffer, DWORD Size);

	bool ComparePathName2FormatName(_bstr_t PathName, _bstr_t FormatName);

private:
    std::wofstream m_wofsFile;

	QUEUEHANDLE m_hQ;

	MQMSGPROPS  m_MsgProps;
	MQPROPVARIANT  m_aVariant[MAX_ACTION_PROPS];
	MSGPROPID m_aPropId[MAX_ACTION_PROPS];
};

#endif //__ACTIONTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\createtriggerq\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7FB3F228_E66A_460A_A83A_ED7A26346E7D__INCLUDED_)
#define AFX_STDAFX_H__7FB3F228_E66A_460A_A83A_ED7A26346E7D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#include <windows.h>
#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7FB3F228_E66A_460A_A83A_ED7A26346E7D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\testlookupidinvokation\checktest.h ===
// checkTest.h : Declaration of the CcheckTest

#ifndef __CHECKTEST_H_
#define __CHECKTEST_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CcheckTest
class ATL_NO_VTABLE CcheckTest : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CcheckTest, &CLSID_checkTest>,
	public IDispatchImpl<IcheckTest, &IID_IcheckTest, &LIBID_TESTLOOKUPIDINVOKATIONLib>
{
public:
	CcheckTest()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CHECKTEST)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CcheckTest)
	COM_INTERFACE_ENTRY(IcheckTest)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IcheckTest
public:
	STDMETHOD(checkLookupIdInvocation)(BSTR queueFormatName, BSTR label, VARIANT lookupId);
};

#endif //__CHECKTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\testlookupidinvokation\checktest.cpp ===
// checkTest.cpp : Implementation of CcheckTest
#include "stdafx.h"
#include "TestLookupidInvokation.h"
#include "checkTest.h"


#import  "mqoa.tlb" no_namespace


/////////////////////////////////////////////////////////////////////////////
// CcheckTest

IMSMQQueue3Ptr 
OpenQueue(
    LPCWSTR queueFormatName,
    long access,
    long deny
    )
{
    try
    {
        IMSMQQueueInfo3Ptr qinfo(L"MSMQ.MSMQQueueInfo");

        BSTR qpn(const_cast<LPWSTR>(queueFormatName));
        qinfo->put_FormatName(qpn);

        //
        // try to create a queue. if exist ignore the error
        //
        return qinfo->Open(access, deny);

    }
    catch(const _com_error& e)
    {
        if (e.Error() != MQ_ERROR_QUEUE_EXISTS)
        {
            wprintf(L"faile to open queue %s. Error %d\n", queueFormatName, e.Error());
            throw;
        }
    }
    return NULL;
}


STDMETHODIMP 
CcheckTest::checkLookupIdInvocation(
    BSTR queueFormatName, 
    BSTR expectedLabel, 
    VARIANT lookupId
    )
{
    try
    {
        IMSMQQueue3Ptr q = OpenQueue(queueFormatName, MQ_RECEIVE_ACCESS, MQ_DENY_NONE);
        IMSMQMessagePtr msg = q->ReceiveByLookupId(lookupId);

        if (msg == NULL)
        {
            MessageBox(NULL, L"Failed to recevive by lookup ID", NULL, MB_OK);
            return S_OK;
        }

        //
        // Open response queue
        //
        IMSMQQueueInfo* pResponseQueue;
        msg->get_ResponseQueueInfo(&pResponseQueue);
        IMSMQQueuePtr rq = (*pResponseQueue).Open(MQ_SEND_ACCESS, MQ_DENY_NONE);

        BSTR label;
        msg->get_Label(&label);
        if (wcscmp(label, expectedLabel) == 0)
        {
            label= L"OK";
        }
        else
        {        
            WCHAR msg[1000];
            swprintf(msg, L"Test Failed. Expected %s. Received %s", expectedLabel, label);
            MessageBox(NULL, msg, NULL, MB_OK);

            label = L"FAILE ";
        }

        //
        // Response message
        //
        IMSMQMessagePtr respMsg(L"MSMQ.MSMQMessage");
        respMsg->put_Label(label);

        respMsg->Send(rq);
    }
    catch (const _com_error& e)
    {
        WCHAR msg[256];
        swprintf(msg, L"Test failed. Error %x", e.Error());

        MessageBox(NULL, msg, NULL, MB_OK);
    }
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\testlookupidinvokation\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\msgrecvtest\rcvtest.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:
    rcvtest.cpp

Abstract:
    Transactional Object for Rules processing

Author:
    Nela Karpel (nelak) 28-Sep-2000

--*/

/* Test description:
	The test consists of 6 stages, on each stage different configuration 
	of the new "Message Receive" feature is tested.
	At each stage a trigger is created, and messages are sent to a queue. 
	After that a check of the results is done. The check is based on the
	expected number of messages in queue after trigger was processed.
	One rule is created and used in every stage: 
		Rule condition is "Message Label Contains STAGE".
	Stage1: Send x messages with label that contains STAGE to regular queue. 
			Create PEEK_MESSAGE trigger. Expect x messages.
	Stage2: Send x messages with label that contains STAGE to regular queue. 
			Create RECEIVE_MESSAGE trigger. Expect 0 messages.
	Stage3: Send x messages with label that contains STAGE to transactional queue. 
			Create PEEK_MESSAGE trigger. Expect x messages.
	Stage4: Send x messages with label that contains STAGE to transactional queue. 
			Create RECEIVE_MESSAGE trigger. Expect 0 messages.
	Stage5: Send x messages with label that contains STAGE to transactional queue. 
			Create RECEIVE_MESSAGE_XACT trigger. Expect 0 messages.
	Stage6: Send x messages with label that does not contain STAGE to regular queue. 
			Create RECEIVE_MESSAGE trigger. Expect x messages.
*/

#include <windows.h>
#include <stdio.h>

//
//  STL include files are using placment format of new
//
#pragma warning(push, 3)

#include <sstream>

#pragma warning(pop)

#import  "mqoa.tlb" no_namespace
#import  "mqtrig.tlb" no_namespace

using namespace std;

#define NO_OF_STAGES 6

const DWORD xNoOfMessages = 10;
const WCHAR xQueuePath[] = L".\\private$\\RecvTestQueue";
const WCHAR xXactQueuePath[] = L".\\private$\\RecvTestQueueXact";

struct StageInfo
{
	MsgProcessingType trigType;
	int numOfExpectedMsgs;
	WCHAR* label;
	bool xact;
};

/* 
stageInfo sructure holds information specific to every stage. 
For each stage a tuple of 4 values is kept.
1. trigType - value of "Message Processing Type" property for
	a trigger in that stage
2. numOfExpectedMsgs - number of messages expected at the end 
	of trigger processing
3. label - label for the messages in that stage. The label is
	important for rule condition evaluation
4. xact - true for stages in which messages are sent to transactional
	queues. 
*/
const StageInfo stageInfo[NO_OF_STAGES] = { 
	{PEEK_MESSAGE,			10, L"Stage1_", false},
	{RECEIVE_MESSAGE,		0,	L"Stage2_", false},
	{PEEK_MESSAGE,			10, L"Stage3_", true},
	{RECEIVE_MESSAGE,		0,	L"Stage4_", true},
	{RECEIVE_MESSAGE_XACT,	0,	L"Stage5_", true},
	{RECEIVE_MESSAGE,		10,	L"Nela1_",	false}
};


void CleanupOldTriggers(LPCWSTR queuePathName)
{
    WCHAR computerName[256];
    DWORD size = sizeof(computerName)/sizeof(WCHAR);
    GetComputerName(computerName, &size);

	WCHAR myQueuePath[256];
	wcscpy(myQueuePath, computerName);
	wcscat(myQueuePath, queuePathName + 1);

    IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
    trigSet->Init(L"");
    trigSet->Refresh();

    try
    {
        long triggersCount = trigSet->GetCount();
        for (long i = 0; i < triggersCount; ++i)
        {
        
            BSTR queueName = NULL;
            BSTR trigId = NULL;
            trigSet->GetTriggerDetailsByIndex(i, &trigId, NULL, &queueName, NULL, NULL, NULL, NULL, NULL);

            if (wcscmp(myQueuePath, queueName) == 0)
            {
                trigSet->DeleteTrigger(trigId);
                --triggersCount;
                --i;
            }

            SysFreeString(trigId);
            SysFreeString(queueName);
        }
    }
    catch (const _com_error&)
    {
    }
}


void
CreateQueue(
	LPCWSTR queuePathName,
	bool xact
	)
{
    IMSMQQueueInfoPtr qinfo(L"MSMQ.MSMQQueueInfo");
    BSTR qpn(const_cast<LPWSTR>(queuePathName));
    qinfo->put_PathName(qpn);
	
	try
	{
		qinfo->Delete();
	}
	catch(const _com_error& e)
	{
        if (e.Error() != MQ_ERROR_QUEUE_NOT_FOUND)
        {
            wprintf(L"Failed to delete old queue %s. Error %d\n", queuePathName, e.Error());
            throw;
        }
	}

	CleanupOldTriggers(queuePathName);

    try
    {
        _variant_t vWorld = true;
		_variant_t vXact = xact;

        qinfo->Create(&vXact, &vWorld);
    }
    catch(const _com_error& e)
    {
        if (e.Error() != MQ_ERROR_QUEUE_EXISTS)
        {
            wprintf(L"Create queue failed. Error %d\n", e.Error());
            throw;
        }
    }
}


void
CreateTestQueues()
{
	CreateQueue(xQueuePath, false);
	CreateQueue(xXactQueuePath, true);
}


IMSMQQueuePtr 
OpenQueue(
    LPCWSTR queuePathName,
    long access,
    long deny
    )
{
    IMSMQQueueInfoPtr qinfo(L"MSMQ.MSMQQueueInfo");

    BSTR qpn(const_cast<LPWSTR>(queuePathName));
    qinfo->put_PathName(qpn);

    return qinfo->Open(access, deny);
}


void SendMessagesToQueue(DWORD noOfMessages, LPCWSTR destQueue, int stageNo)
{
    IMSMQQueuePtr sq;

    //
    // create the destination and response queues
    //
    try
    {
        sq = OpenQueue(destQueue, MQ_SEND_ACCESS, MQ_DENY_NONE);
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to open a queue. Error %d\n", e.Error());
        throw;
    }

    IMSMQMessagePtr msg(L"MSMQ.MSMQMessage");
    try
    {
        for (DWORD i = 0; i < noOfMessages; ++i)
        {
            //
            // Set message label
            //
            WCHAR label[100];
            wsprintf(label, L"%s%d", stageInfo[stageNo].label, i);

            _bstr_t bstrLabel = label;
            msg->put_Label(bstrLabel); 
			
			if ( stageInfo[stageNo].xact )
			{
				_variant_t vTrans(static_cast<long>(MQ_SINGLE_MESSAGE));

				msg->Send(sq, &vTrans);
			}
			else
			{
				msg->Send(sq);
			}
			Sleep(100);
        }
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to send a message. Error %d\n", e.Error());
        throw;
    }

}


BSTR CreateTrigger(
	LPCWSTR trigName, 
	LPCWSTR queuePath, 
	UINT msgProcType, 
	BSTR bstrRuleID
	)
{
	try
	{
		IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
		trigSet->Init(L"");
		trigSet->Refresh();
		
		BSTR bstrTrigID = NULL;
		trigSet->AddTrigger(
					trigName,
					queuePath,
					SYSTEM_QUEUE_NONE,
					true,
					false,
					static_cast<MsgProcessingType>(msgProcType),
					&bstrTrigID
					);
	
		trigSet->AttachRule (bstrTrigID, bstrRuleID, 0);
		return bstrTrigID;
	}
	catch (const _com_error& e)
	{
		printf("Failed to create trigger, error: %d\n", e.Error());
		throw;
	}
}


void DeleteTrigger(BSTR bstrTrigID)
{
	if ( bstrTrigID == NULL )
	{
		return;
	}

	try
	{
		IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
		trigSet->Init(L"");
		trigSet->Refresh();
		
		trigSet->DeleteTrigger(
					bstrTrigID
					);
	
		//SysFreeString(bstrTrigID);
	}
	catch (const _com_error& e)
	{
		printf("Failed to delete trigger, error: %d\n", e.Error());
		throw;
	}
}


BSTR CreateRule(LPCWSTR ProgID, LPCWSTR Method)
{
	try
	{
		IMSMQRuleSetPtr ruleSet(L"MSMQTriggerObjects.MSMQRuleSet");
		ruleSet->Init(L"");
		ruleSet->Refresh();

		wostringstream ruleAction;
		ruleAction << L"COM\t" << ProgID << L"\t" << Method << L"";
		
		BSTR ruleID = NULL;
		ruleSet->Add(
                L"RecvTestRule", 
                L"Rule For MsgRcv Test", 
                L"$MSG_LABEL_CONTAINS=Stage\t", 
                ruleAction.str().c_str(), 
                L"", 
                true, 
                &ruleID
                );
		
		return ruleID;

	}
	catch (const _com_error& e)
	{
		printf("Failed to create rule. Error: %d\n", e.Error());
		throw;
	}
}


void DeleteRule( BSTR bstrRuleId )
{
	if ( bstrRuleId == NULL )
	{
		return;
	}

	try
	{
		IMSMQRuleSetPtr ruleSet(L"MSMQTriggerObjects.MSMQRuleSet");
		ruleSet->Init(L"");
		ruleSet->Refresh();

		ruleSet->Delete(bstrRuleId);
		
		//SysFreeString(bstrRuleId);
	}
	catch (const _com_error& e)
	{
		printf("Failed to delete rule. Error: %d\n", e.Error());
		throw;
	}
}


IMSMQMessagePtr ReceiveMessage(IMSMQQueuePtr pQueue)
{
	_variant_t vtReceiveTimeout = (long)1000;

	return pQueue->Receive(&vtMissing, &vtMissing, &vtMissing, &vtReceiveTimeout);
}


bool CheckResults(LPCWSTR queueName, int stageNo)
{
    IMSMQQueuePtr pQueue;

    try
    {
        pQueue = OpenQueue(queueName, MQ_RECEIVE_ACCESS, MQ_DENY_NONE);
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to open a queue. Error %d\n", e.Error());
        throw;
    }

    try
    {
		if (stageInfo[stageNo].numOfExpectedMsgs == 0)
		{
			IMSMQMessagePtr msg = ReceiveMessage(pQueue);
			if ( msg == NULL )
			{
				return true;
			}
			return false;
		}

        for (long i = 0; i < stageInfo[stageNo].numOfExpectedMsgs; ++i)
        {
  
           IMSMQMessagePtr msg = ReceiveMessage(pQueue);
           if (msg == NULL)
           {
               wprintf(L"Failed to receive message from response queue: %s", queueName);
               return false;
           }

           BSTR label;
		   _bstr_t expectedLabel = L"";

		   wsprintf(expectedLabel, L"%s%d", stageInfo[stageNo].label, i);
           msg->get_Label(&label);

           if (wcscmp(label, expectedLabel) == 0)
           {
			   SysFreeString(label);
               continue;
           }

		   SysFreeString(label);
           return false;
        }
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to receive a message. Error %d\n", e.Error());
        throw;
    }

    return true;
}


void
CleanUp(
	BSTR ruleID,
	BSTR triggerID
	)
{
	DeleteRule(ruleID);
	DeleteTrigger(triggerID);
}


int __cdecl wmain(int , WCHAR**)
{
    HRESULT hr = CoInitialize(NULL);
	if(FAILED(hr))
	{
		wprintf(L"Failed to initialize com. Error=%#x\n", hr);
		return -1;
	}

	wprintf(L"Beginning Message Receive Test. TotaL of %d stages.\n", NO_OF_STAGES);

    BSTR ruleId = NULL;
    BSTR triggerId = NULL;
    try
    {
		CreateTestQueues();

        ruleId = CreateRule(L"XactProj.XactObj", L"XactFunc");

		WCHAR queuePath[256];

		for	( int i = 0; i < NO_OF_STAGES; i++ )
		{
			wprintf(L"Message Receive Test. Stage %d: ", i+1);

			if ( !(stageInfo[i].xact) )
			{
				wcscpy(queuePath, xQueuePath);
			}
			else
			{
				wcscpy(queuePath, xXactQueuePath);
			}

			SendMessagesToQueue(xNoOfMessages, queuePath, i);

			WCHAR trigName[30];
			wsprintf(trigName, L"RecvTrigger%d", i);
			triggerId = CreateTrigger(trigName, queuePath, stageInfo[i].trigType, ruleId);
			Sleep(10000);

			if (CheckResults( queuePath, i ) == false)
			{

				wprintf(L"Failed\n");
				CleanUp(ruleId, triggerId);
				CoUninitialize();
				return -1;
			}
			
			wprintf(L"Passed\n");
			DeleteTrigger(triggerId);
		}
    }
    catch(const _com_error& e)
    {
		CleanUp(ruleId, triggerId);
        CoUninitialize();
    
        wprintf(L"Test Failed. Error: %d\n", e.Error());
        return -1;
    }
    
    DeleteRule(ruleId);
    CoUninitialize();
    wprintf(L"Test pass successfully\n");
    
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\systemqueue\main.cpp ===
#include <windows.h>
#include <stdio.h>

//
//  STL include files are using placment format of new
//
#pragma warning(push, 3)

#include <sstream>

#pragma warning(pop)

#import  "mqoa.tlb" no_namespace
#import  "mqtrig.tlb" no_namespace

using namespace std;

const DWORD xQueuePathName = 256;
const DWORD xNoOfMessages = 100;

void 
GetQueuePaths(
	LPWSTR testJournalQueue, 
	LPWSTR testDeadletterQueue, 
	LPWSTR testXactdedQueue, 
	LPWSTR responseQueue
	)
{
    WCHAR machineName[xQueuePathName];
    DWORD size = xQueuePathName;
    GetComputerName(machineName, &size);

    int n = _snwprintf(testJournalQueue, xQueuePathName, L"%s\\private$\\TestJournalSystemQueue", machineName);
    if (n < 0)
        throw exception();

    n = _snwprintf(testDeadletterQueue, xQueuePathName, L"%s\\private$\\TestDeadletterSystemQueue", machineName);
    if (n < 0)
        throw exception();

    n = _snwprintf(testXactdedQueue, xQueuePathName, L"%s\\private$\\TestXactdeadSystemQueue", machineName);
    if (n < 0)
        throw exception();

    n = _snwprintf(responseQueue, xQueuePathName, L"%s\\private$\\TestSystemQueueResponseQueue", machineName);
    if (n < 0)
        throw exception();
}


//
// DIRECT=OS:<computerName>\SYSTEM$;<suffix>
//
WCHAR x_SystemQueueFormat[] = L"DIRECT=OS:%s\\SYSTEM$%s";
WCHAR x_JOURNAL_SUFFIX[] = L";JOURNAL";
WCHAR x_DEADLETTER_SUFFIX[] = L";DEADLETTER";
WCHAR x_DEADXACT_SUFFIX[] = L";DEADXACT";


void
GetSysytemQueuePaths(
	LPWSTR journalQueue, 
	LPWSTR DeadletterQueue, 
	LPWSTR XactDeadletterQueue
	)
{
    WCHAR machineName[xQueuePathName];
    DWORD size = xQueuePathName;
    GetComputerName(machineName, &size);

	int n = _snwprintf(journalQueue, xQueuePathName, x_SystemQueueFormat, machineName, x_JOURNAL_SUFFIX);
    if (n < 0)
        throw exception();

    n = _snwprintf(DeadletterQueue, xQueuePathName, x_SystemQueueFormat, machineName, x_DEADLETTER_SUFFIX);
    if (n < 0)
        throw exception();

    n = _snwprintf(XactDeadletterQueue, xQueuePathName, x_SystemQueueFormat, machineName, x_DEADXACT_SUFFIX);
    if (n < 0)
        throw exception();
}


IMSMQQueuePtr 
OpenQueue(
    LPCWSTR queuePathName,
    long access,
    long deny,
    bool fDelete,
	bool fTransacted
    )
{
    IMSMQQueueInfoPtr qinfo(L"MSMQ.MSMQQueueInfo");

    BSTR qpn(const_cast<LPWSTR>(queuePathName));
    qinfo->put_PathName(qpn);

    try
    {
        if (fDelete)
            qinfo->Delete();
    }
    catch(const _com_error& e)
    {
        if (e.Error() != MQ_ERROR_QUEUE_NOT_FOUND)
        {
            wprintf(L"Failed to delete queue %s. Error %d\n", queuePathName, e.Error());
            throw;
        }
    }


    //
    // try to create a queue. if exist ignore the error
    //
    try
    {
        VARIANT v[2];
        v[0].vt = VT_BOOL;
        v[0].boolVal = fTransacted ? VARIANT_TRUE : VARIANT_FALSE;
        v[1].vt = VT_BOOL;
        v[1].boolVal = VARIANT_TRUE;

        qinfo->Create(&v[0], &v[1]);
    }
    catch(const _com_error& e)
    {
        if (e.Error() != MQ_ERROR_QUEUE_EXISTS)
        {
            wprintf(L"create queue failed. Error %d\n", e.Error());
            throw;
        }
    }

    return qinfo->Open(access, deny);
}


void 
SendMessageToQueue(
	DWORD noOfMessages, 
	LPCWSTR destQueue, 
	LPCWSTR responseQueue,
	long fJournal,
	long MaxTimeToReceive,
	bool fTransacted

	)
{
    IMSMQQueuePtr sq;
    IMSMQQueuePtr rq;

    //
    // create the destination and response queues
    //
    try
    {
        sq = OpenQueue(destQueue, MQ_SEND_ACCESS, MQ_DENY_NONE, true, fTransacted);
        rq = OpenQueue(responseQueue, MQ_RECEIVE_ACCESS, MQ_DENY_NONE, false, false);
        rq->Close();
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to open a queue. Error %d\n", e.Error());
        throw;
    }

    //
    // Get response queue object
    //
    IMSMQQueueInfoPtr qResponseInfo(L"MSMQ.MSMQQueueInfo");
    BSTR qpn(const_cast<LPWSTR>(responseQueue));
    qResponseInfo->put_PathName(qpn);
	qResponseInfo->Refresh();

    IMSMQMessagePtr msg(L"MSMQ.MSMQMessage");
    msg->ResponseQueueInfo = qResponseInfo;
	msg->Journal = fJournal;
	msg->MaxTimeToReceive = MaxTimeToReceive;

    try
    {
        for (DWORD i = 0; i < noOfMessages; ++i)
        {
            //
            // Set message label
            //
            WCHAR label[100];
            swprintf(label, L"Trigger lookup ID test - message %d", i);

            _bstr_t bstrLabel = label;
            msg->put_Label(bstrLabel); 

			_variant_t bTransaction((LONG_PTR)(fTransacted ? MQ_SINGLE_MESSAGE : MQ_NO_TRANSACTION));     
            msg->Send(sq, &bTransaction);
        }
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to send a message. Error %d\n", e.Error());
        throw;
    }

}


bool ReceiveMessageFromQueue(DWORD noOfMessages, LPCWSTR queueName)
{
    IMSMQQueuePtr rq;

    //
    // open the response queues
    //
    try
    {
        rq = OpenQueue(queueName, MQ_RECEIVE_ACCESS, MQ_DENY_NONE, false, false);
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to open a queue. Error %d\n", e.Error());
        throw;
    }

    for (DWORD i = 0; i < noOfMessages; ++i)
    {
        //          
        // Set value of ReceiveTimout parameter.
        //
        _variant_t vtReceiveTimeout = (long)1000;

       IMSMQMessagePtr msg = rq->Receive(&vtMissing, &vtMissing, &vtMissing, &vtReceiveTimeout);
       if (msg == NULL)
       {
           wprintf(L"Failed to receive message from response queue: %s", queueName);
           return false;
       }
	}

	return true;
}


void CleanupOldTrigger(LPCWSTR queueFormatName)
{
    WCHAR computerName[256];
    DWORD size = sizeof(computerName)/sizeof(WCHAR);

    GetComputerName(computerName, &size);

    IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
    trigSet->Init(computerName);
    trigSet->Refresh();

    try
    {
        long triggersCount = trigSet->GetCount();
        for (long i = 0; i < triggersCount; ++i)
        {
        
            BSTR queueName = NULL;
            BSTR trigId = NULL;
            trigSet->GetTriggerDetailsByIndex(i, &trigId, NULL, &queueName, NULL, NULL, NULL, NULL, NULL);

            if (wcscmp(queueFormatName, queueName) == 0)
            {
                trigSet->DeleteTrigger(trigId);
                --triggersCount;
                --i;
            }

            SysFreeString(trigId);
            SysFreeString(queueName);
        }
    }
    catch (const _com_error&)
    {
    }
}


_bstr_t CreateRule(LPCWSTR progId, LPCWSTR methodId)
{
    WCHAR computerName[256];
    DWORD size = sizeof(computerName)/sizeof(WCHAR);

    GetComputerName(computerName, &size);

    //
    // Create Rule
    //
    IMSMQRuleSetPtr ruleSet(L"MSMQTriggerObjects.MSMQRuleSet");
    ruleSet->Init(computerName);
    ruleSet->Refresh();

    wostringstream ruleAction;
    ruleAction << L"COM\t" << progId << L"\t" << methodId << L"\t$MSG_QUEUE_FORMATNAME\t$MSG_LABEL\t$MSG_LOOKUP_ID";
    BSTR ruleID = NULL;

    ruleSet->Add(
                L"LookupidTest", 
                L"Lookup ID rule", 
                L"", 
                ruleAction.str().c_str(), 
                L"", 
                true, 
                &ruleID
                );

    _bstr_t retRuleId = ruleID;
    SysFreeString(ruleID);
    
    return retRuleId;
}


bool CheckResult(DWORD noOfMessages, LPCWSTR queueName)
{
    IMSMQQueuePtr rq;

    //
    // open the response queues
    //
    try
    {
        rq = OpenQueue(queueName, MQ_RECEIVE_ACCESS, MQ_DENY_NONE, false, false);
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to open a queue. Error %d\n", e.Error());
        throw;
    }

    try
    {
        for (DWORD i = 0; i < noOfMessages; ++i)
        {
            //          
            // Set value of ReceiveTimout parameter.
            //
            _variant_t vtReceiveTimeout = (long)100000;
  
           IMSMQMessagePtr msg = rq->Receive(&vtMissing, &vtMissing, &vtMissing, &vtReceiveTimeout);
           if (msg == NULL)
           {
               wprintf(L"Failed to receive message from response queue: %s", queueName);
               return false;
           }

           BSTR label;
           msg->get_Label(&label);
           if (wcscmp(label, L"OK") == 0)
           {
               SysFreeString(label);
               continue;
           }

           SysFreeString(label);
           return false;
        }
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to send a message. Error %d\n", e.Error());
        throw;
    }

    return true;
}


_bstr_t SetTrigger(SystemQueueIdentifier SystemQueue, LPCWSTR triggerName, const _bstr_t& ruleId)
{
    WCHAR computerName[256];
    DWORD size = sizeof(computerName)/sizeof(WCHAR);

    GetComputerName(computerName, &size);

    IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
    trigSet->Init(computerName);
    trigSet->Refresh();

    BSTR triggerId = NULL;
    trigSet->AddTrigger(
        triggerName,
        L"",
        SystemQueue,
        true,
        false,
		RECEIVE_MESSAGE,
        &triggerId
        );

    trigSet->AttachRule (triggerId, ruleId, 0);

    _bstr_t retTriggerId = triggerId;
    SysFreeString(triggerId);

    return retTriggerId;
}


void CleanupRuleAndTrigger(_bstr_t& ruleId, _bstr_t* triggerId)
{
    try
    {
        WCHAR computerName[256];
        DWORD size = sizeof(computerName)/sizeof(WCHAR);

        GetComputerName(computerName, &size);

        IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
        trigSet->Init(computerName);
        trigSet->Refresh();

        trigSet->DeleteTrigger(triggerId[0]);
        trigSet->DeleteTrigger(triggerId[1]);
        trigSet->DeleteTrigger(triggerId[2]);

        //
        // Delete Rule
        //
        IMSMQRuleSetPtr ruleSet(L"MSMQTriggerObjects.MSMQRuleSet");
        ruleSet->Init(computerName);
        ruleSet->Refresh();

        ruleSet->Delete(ruleId);
    }
    catch(const _com_error&)
    {
    }
}


void 
DeleteQueue(
    LPCWSTR queuePathName
    )
{
    IMSMQQueueInfoPtr qinfo(L"MSMQ.MSMQQueueInfo");

    BSTR qpn(const_cast<LPWSTR>(queuePathName));
    qinfo->put_PathName(qpn);

    try
    {
        qinfo->Delete();
    }
    catch(const _com_error& )
    {
    }
}


int __cdecl wmain(int , WCHAR** )
{
    HRESULT hr = CoInitialize(NULL);
	if(FAILED(hr))
	{
		wprintf(L"Failed to initialize com. Error=%#x\n", hr);
		return -1;
	}

    WCHAR testJournalQueue[xQueuePathName];
    WCHAR testDeadletterQueue[xQueuePathName];
	WCHAR testXactdedQueue[xQueuePathName];
    WCHAR responseQueue[xQueuePathName];
    GetQueuePaths(testJournalQueue, testDeadletterQueue, testXactdedQueue, responseQueue);

	DeleteQueue(testJournalQueue);
	DeleteQueue(testDeadletterQueue);
	DeleteQueue(testXactdedQueue);
	DeleteQueue(responseQueue);
	

    WCHAR journalQueue[xQueuePathName];
	WCHAR DeadletterQueue[xQueuePathName];
	WCHAR XactDeadletterQueue[xQueuePathName];
    GetSysytemQueuePaths(journalQueue, DeadletterQueue, XactDeadletterQueue);

    CleanupOldTrigger(journalQueue);
    CleanupOldTrigger(DeadletterQueue);
    CleanupOldTrigger(XactDeadletterQueue);

    SendMessageToQueue(1, testJournalQueue, responseQueue, MQMSG_JOURNAL, 5, false);
    SendMessageToQueue(1, testDeadletterQueue, responseQueue, MQMSG_DEADLETTER, 1, false);
    SendMessageToQueue(1, testXactdedQueue, responseQueue, MQMSG_DEADLETTER, 1, true);
	ReceiveMessageFromQueue(1, 	testJournalQueue);

    //
    // craete trigger and rule
    //
    _bstr_t ruleId;
    _bstr_t triggerId[3];
    try
    {
        ruleId = CreateRule(L"testLookupidInvokation.checkTest", L"checkLookupIdInvocation");
        triggerId[0] = SetTrigger(SYSTEM_QUEUE_JOURNAL, L"JournalSystemQueueTrigger", ruleId);
        triggerId[1] = SetTrigger(SYSTEM_QUEUE_DEADLETTER, L"DeadletterSystemQueueTrigger", ruleId);
        triggerId[2] = SetTrigger(SYSTEM_QUEUE_DEADXACT, L"XactdeadSystemQueueTrigger", ruleId);
    }
    catch(const _com_error&)
    {
        CoUninitialize();
    
        wprintf(L"Failed to create rule and triggr\n");
        return -1;
    }

	bool fFailed = false;

    if (CheckResult(3, responseQueue) == false)
    {
		fFailed = true;
    }
    
    CleanupRuleAndTrigger(ruleId, triggerId);
	DeleteQueue(testJournalQueue);
	DeleteQueue(testDeadletterQueue);
	DeleteQueue(testXactdedQueue);
	DeleteQueue(responseQueue);

    CoUninitialize();

	if (fFailed)
	{
        wprintf(L"Test Failed\n");
        return -1;
    }
	
	wprintf(L"Test pass successfully\n");
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\testlookupidinvokation\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testLookupidInvokation.rc
//
#define IDR_CHECKTEST                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\lookupid\main.cpp ===
#include <windows.h>
#include <stdio.h>

//
//  STL include files are using placment format of new
//
#pragma warning(push, 3)

#include <sstream>

#pragma warning(pop)

#import  "mqoa.tlb" no_namespace
#import  "mqtrig.tlb" no_namespace

using namespace std;

const DWORD xQueuePathName = 256;
const DWORD xNoOfMessages = 100;

void GetQueuePaths(LPWSTR testQueue, LPWSTR responseQueue)
{
    WCHAR machineName[xQueuePathName];
    DWORD size = xQueuePathName;
    GetComputerName(machineName, &size);

    int n = _snwprintf(testQueue, xQueuePathName, L"%s\\private$\\TestTriggerLookupID", machineName);
    if (n < 0)
        throw exception();

    n = _snwprintf(responseQueue, xQueuePathName, L"%s\\private$\\TestTriggerLookupIDResponseQueue", machineName);
    if (n < 0)
        throw exception();


}


IMSMQQueuePtr 
OpenQueue(
    LPCWSTR queuePathName,
    long access,
    long deny,
    bool fDelete
    )
{
    IMSMQQueueInfoPtr qinfo(L"MSMQ.MSMQQueueInfo");

    BSTR qpn(const_cast<LPWSTR>(queuePathName));
    qinfo->put_PathName(qpn);

    try
    {
        if (fDelete)
            qinfo->Delete();
    }
    catch(const _com_error& e)
    {
        if (e.Error() != MQ_ERROR_QUEUE_NOT_FOUND)
        {
            wprintf(L"Failed to delete queue %s. Error %d\n", queuePathName, e.Error());
            throw;
        }
    }


    //
    // try to create a queue. if exist ignore the error
    //
    try
    {
        VARIANT v;
        v.vt = VT_BOOL;
        v.boolVal = VARIANT_TRUE;

        qinfo->Create(&vtMissing, &v);
    }
    catch(const _com_error& e)
    {
        if (e.Error() != MQ_ERROR_QUEUE_EXISTS)
        {
            wprintf(L"create queue failed. Error %d\n", e.Error());
            throw;
        }
    }

    return qinfo->Open(access, deny);
}


void SendMessageToQueue(DWORD noOfMessages, LPCWSTR destQueue, LPCWSTR responseQueue)
{
    IMSMQQueuePtr sq;
    IMSMQQueuePtr rq;

    //
    // create the destination and response queues
    //
    try
    {
        sq = OpenQueue(destQueue, MQ_SEND_ACCESS, MQ_DENY_NONE, true);
        rq = OpenQueue(responseQueue, MQ_RECEIVE_ACCESS, MQ_DENY_NONE, true);
        rq->Close();
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to open a queue. Error %d\n", e.Error());
        throw;
    }

    //
    // Get response queue object
    //
    IMSMQQueueInfoPtr qResponseInfo(L"MSMQ.MSMQQueueInfo");
    BSTR qpn(const_cast<LPWSTR>(responseQueue));
    qResponseInfo->put_PathName(qpn);


    IMSMQMessagePtr msg(L"MSMQ.MSMQMessage");
    msg->ResponseQueueInfo = qResponseInfo;

    try
    {
        for (DWORD i = 0; i < noOfMessages; ++i)
        {
            //
            // Set message label
            //
            WCHAR label[100];
            swprintf(label, L"Trigger lookup ID test - message %d", i);

            _bstr_t bstrLabel = label;
            msg->put_Label(bstrLabel); 
            msg->Send(sq);
        }
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to send a message. Error %d\n", e.Error());
        throw;
    }

}


void CleanupOldTrigger(LPCWSTR queueFormatName)
{
    WCHAR computerName[256];
    DWORD size = sizeof(computerName)/sizeof(WCHAR);

    GetComputerName(computerName, &size);

    IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
    trigSet->Init(computerName);
    trigSet->Refresh();

    try
    {
        long triggersCount = trigSet->GetCount();
        for (long i = 0; i < triggersCount; ++i)
        {
        
            BSTR queueName = NULL;
            BSTR trigId = NULL;
            trigSet->GetTriggerDetailsByIndex(i, &trigId, NULL, &queueName, NULL, NULL, NULL, NULL, NULL);

            if (wcscmp(queueFormatName, queueName) == 0)
            {
                trigSet->DeleteTrigger(trigId);
                --triggersCount;
                --i;
            }

            SysFreeString(trigId);
            SysFreeString(queueName);
        }
    }
    catch (const _com_error&)
    {
    }
}


_bstr_t CreateRule(LPCWSTR progId, LPCWSTR methodId)
{
    WCHAR computerName[256];
    DWORD size = sizeof(computerName)/sizeof(WCHAR);

    GetComputerName(computerName, &size);

    //
    // Create Rule
    //
    IMSMQRuleSetPtr ruleSet(L"MSMQTriggerObjects.MSMQRuleSet");
    ruleSet->Init(computerName);
    ruleSet->Refresh();

    wostringstream ruleAction;
    ruleAction << L"COM\t" << progId << L"\t" << methodId << L"\t$MSG_QUEUE_FORMATNAME\t$MSG_LABEL\t$MSG_LOOKUP_ID";
    BSTR ruleID = NULL;

    ruleSet->Add(
                L"LookupidTest", 
                L"Lookup ID rule", 
                L"", 
                ruleAction.str().c_str(), 
                L"", 
                true, 
                &ruleID
                );

    _bstr_t retRuleId = ruleID;
    SysFreeString(ruleID);
    
    return retRuleId;
}


bool CheckResult(DWORD noOfMessages, LPCWSTR queueName)
{
    IMSMQQueuePtr rq;

    //
    // open the response queues
    //
    try
    {
        rq = OpenQueue(queueName, MQ_RECEIVE_ACCESS, MQ_DENY_NONE, false);
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to open a queue. Error %d\n", e.Error());
        throw;
    }

    try
    {
        for (DWORD i = 0; i < noOfMessages; ++i)
        {
            //          
            // Set value of ReceiveTimout parameter.
            //
            _variant_t vtReceiveTimeout = (long)100000;
  
           IMSMQMessagePtr msg = rq->Receive(&vtMissing, &vtMissing, &vtMissing, &vtReceiveTimeout);
           if (msg == NULL)
           {
               wprintf(L"Failed to receive message from response queue: %s", queueName);
               return false;
           }

           BSTR label;
           msg->get_Label(&label);
           if (wcscmp(label, L"OK") == 0)
           {
               SysFreeString(label);
               continue;
           }

           SysFreeString(label);
           return false;
        }
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to send a message. Error %d\n", e.Error());
        throw;
    }

    return true;
}


_bstr_t SetTrigger(LPCWSTR queueName, const _bstr_t& ruleId)
{
    WCHAR computerName[256];
    DWORD size = sizeof(computerName)/sizeof(WCHAR);

    GetComputerName(computerName, &size);

    IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
    trigSet->Init(computerName);
    trigSet->Refresh();

    BSTR triggerId = NULL;
    trigSet->AddTrigger(
        L"Lookupid",
        queueName,
        SYSTEM_QUEUE_NONE,
        true,
        false,
		PEEK_MESSAGE,
        &triggerId
        );

    trigSet->AttachRule (triggerId, ruleId, 0);

    _bstr_t retTriggerId = triggerId;
    SysFreeString(triggerId);

    return retTriggerId;
}


void CleanupRuleAndTrigger(_bstr_t& ruleId, _bstr_t& triggerId)
{
    try
    {
        WCHAR computerName[256];
        DWORD size = sizeof(computerName)/sizeof(WCHAR);

        GetComputerName(computerName, &size);

        IMSMQTriggerSetPtr trigSet(L"MSMQTriggerObjects.MSMQTriggerSet");
        trigSet->Init(computerName);
        trigSet->Refresh();

        trigSet->DeleteTrigger(triggerId);

        //
        // Delete Rule
        //
        IMSMQRuleSetPtr ruleSet(L"MSMQTriggerObjects.MSMQRuleSet");
        ruleSet->Init(computerName);
        ruleSet->Refresh();

        ruleSet->Delete(ruleId);
    }
    catch(const _com_error&)
    {
    }
}

int __cdecl wmain(int , WCHAR** )
{
    HRESULT hr = CoInitialize(NULL);
	if(FAILED(hr))
	{
		wprintf(L"Failed to initialize com. Error=%#x\n", hr);
		return -1;
	}

    WCHAR testQueue[xQueuePathName];
    WCHAR responseQueue[xQueuePathName];
    GetQueuePaths(testQueue, responseQueue);

    CleanupOldTrigger(testQueue);
    SendMessageToQueue(xNoOfMessages, testQueue, responseQueue);

    //
    // craete trigger and rule
    //
    _bstr_t ruleId;
    _bstr_t triggerId;
    try
    {
        ruleId = CreateRule(L"testLookupidInvokation.checkTest", L"checkLookupIdInvocation");
        triggerId = SetTrigger(testQueue, ruleId);
    }
    catch(const _com_error&)
    {
        CoUninitialize();
    
        wprintf(L"Failed to create rule and triggr\n");
        return -1;
    }

    if (CheckResult(xNoOfMessages, responseQueue) == false)
    {
        CleanupRuleAndTrigger(ruleId, triggerId);
        CoUninitialize();

        wprintf(L"Test Failed\n");
        return -1;
    }
    
    CleanupRuleAndTrigger(ruleId, triggerId);
    CoUninitialize();
    wprintf(L"Test pass successfully\n");
    
    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\xactproj\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\testlookupidinvokation\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A1C23BD9_7C41_4833_920F_4D6F7BB33DFA__INCLUDED_)
#define AFX_STDAFX_H__A1C23BD9_7C41_4833_920F_4D6F7BB33DFA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#undef _DEBUG

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A1C23BD9_7C41_4833_920F_4D6F7BB33DFA__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\testlookupidinvokation\testlookupidinvokation.cpp ===
// testLookupidInvokation.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f testLookupidInvokationps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "testLookupidInvokation.h"

#include "testLookupidInvokation_i.c"
#include "checkTest.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_checkTest, CcheckTest)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TESTLOOKUPIDINVOKATIONLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\trigadm\trigadm.h ===
class CInputParams;

enum MSMQTriggersRequest
{
	REQUEST_NONE = -2,
	REQUEST_ILLEGAL = -1,
	REQUEST_UPDATE_CONFIG = 0,
	REQUEST_GET_CONFIG,
	REQUEST_ADD_TRIGGER,
	REQUEST_UPDATE_TRIGGER,
	REQUEST_DELETE_TRIGGER,
	REQUEST_ATTACH_RULE,
	REQUEST_DETACH_RULE,
	REQUEST_ADD_RULE,
	REQUEST_UPDATE_RULE,
	REQUEST_DELETE_RULE,
	REQUEST_GET_TRIGGERS_LIST,
	REQUEST_GET_RULES_LIST,
	REQUEST_GET_TRIGGER,
	REQUEST_GET_RULE,
	NUM_OF_REQUESTS,
};


MSMQTriggersRequest IsLegalRequest(std::wstring wcsRequest);

void PrintUsage(MSMQTriggersRequest Request);

HRESULT UpdateConfig(CInputParams& Input);
HRESULT GetConfig();
HRESULT AddTrigger(std::wstring MachineName, CInputParams& Input);
HRESULT UpdateTrigger(std::wstring MachineName, CInputParams& Input);
HRESULT DeleteTrigger(std::wstring MachineName, CInputParams& Input);
HRESULT AttachDetachRule(std::wstring MachineName, CInputParams& Input, bool fAttach);
HRESULT AddRule(std::wstring MachineName, CInputParams& Input);
HRESULT UpdateRule(std::wstring MachineName, CInputParams& Input);
HRESULT DeleteRule(std::wstring MachineName, CInputParams& Input);
HRESULT GetTriggersList(std::wstring MachineName, CInputParams& Input);
HRESULT GetRulesList(std::wstring MachineName, CInputParams& Input);
HRESULT GetTrigger(std::wstring MachineName, CInputParams& Input);
HRESULT GetRule(std::wstring MachineName, CInputParams& Input);

void ConvertSeperatorsToTabs(std::wstring& wcs);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\xactproj\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by xactproj.rc
//
#define IDR_XACTOBJ                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\trigadm\trigadm.cpp ===
#include "libpch.h"
#include <comdef.h>
#include "cinputparams.h"

#include "trigadm.h"
#include "StrParse.hpp"
#import "mqtrig.tlb" 


using namespace std;

const wstring LegalRequests[NUM_OF_REQUESTS] = {
														L"UpdateConfig",
														L"GetConfig",
														L"AddTrigger",
														L"UpdateTrigger",
														L"DeleteTrigger",
														L"AttachRule",
														L"DetachRule",
														L"AddRule",
														L"UpdateRule",
														L"DeleteRule",
														L"GetTriggersList",
														L"GetRulesList",
														L"GetTrigger",
														L"GetRule" 
												};


MSMQTriggersRequest IsLegalRequest(wstring wcsRequest)
{
	if(wcsRequest.empty())
	{
		return REQUEST_NONE;
	}

	for(int i=0; i < NUM_OF_REQUESTS ;i++)
	{
		//
		// Compare without case sensetive
		//
		wstring wcs = LegalRequests[i];
		if( !_wcsicmp( wcs.c_str(), wcsRequest.c_str() ) )
		{
			return (MSMQTriggersRequest)i;
		}
	}
	return REQUEST_ILLEGAL;
}




int __cdecl wmain(int argc, WCHAR* argv[])
{
	try
	{
		HRESULT hr = OleInitialize(NULL);
		if(FAILED(hr))
		{
			wprintf(L"Failed to initialize com %#x\n", hr);
			return -1;
		}

		CInputParams Input(argc, argv);
		
		if(argc == 1)
		{
			PrintUsage(REQUEST_NONE);
			return 0;
		}
		
		wstring wcsRequest = Input[L"Request"];
		MSMQTriggersRequest Request = IsLegalRequest(wcsRequest);
		wstring MachineName = Input[L"Machine"];

		bool fHelp = Input.IsOptionGiven(L"?");
		if(fHelp)
		{
			PrintUsage(Request);
			return 0;
		}
		
		switch(Request)
		{
		case REQUEST_UPDATE_CONFIG:
			hr = UpdateConfig(Input);
			break;

		case REQUEST_GET_CONFIG:
			hr = GetConfig();
			break;

		case REQUEST_ADD_TRIGGER:
			hr = AddTrigger(MachineName, Input);
			break;

		case REQUEST_UPDATE_TRIGGER:
			hr = UpdateTrigger(MachineName, Input);
			break;

		case REQUEST_DELETE_TRIGGER:
			hr = DeleteTrigger(MachineName, Input);
			break;

		case REQUEST_ATTACH_RULE:
			hr = AttachDetachRule(MachineName, Input, true);
			break;

		case REQUEST_DETACH_RULE:
			hr = AttachDetachRule(MachineName, Input, false);
			break;

		case REQUEST_ADD_RULE:
			hr = AddRule(MachineName, Input);
			break;

		case REQUEST_UPDATE_RULE:
			hr = UpdateRule(MachineName, Input);
			break;

		case REQUEST_DELETE_RULE:
			hr = DeleteRule(MachineName, Input);
			break;

		case REQUEST_GET_TRIGGERS_LIST:
			hr = GetTriggersList(MachineName, Input);
			break;

		case REQUEST_GET_RULES_LIST:
			hr = GetRulesList(MachineName, Input);
			break;

		case REQUEST_GET_TRIGGER:
			hr = GetTrigger(MachineName, Input);
			break;
	
		case REQUEST_GET_RULE:
			hr = GetRule(MachineName, Input);
			break;

		case REQUEST_NONE:
			PrintUsage(REQUEST_NONE);
			break;

		case REQUEST_ILLEGAL:
			wprintf(L"Failed : %s is an illegal request\n", wcsRequest.c_str());
			PrintUsage(REQUEST_ILLEGAL);
			hr = -1;
			break;

		default:
			ASSERT(0);
		}

		return hr;
	}
	catch (_com_error& Err)
	{
		_bstr_t ErrStr;
		try
		{
			ErrStr = Err.Description();
		}
		catch(_com_error& )
		{
			return -1;
		}
		if(!(!ErrStr))
		{
			try
			{
				printf("Failed : %ls\n", (wchar_t*)ErrStr);
			}
			catch(_com_error& )
			{
				return -1;
			}
		}
		else
			printf("Failed : 0x%x\n", Err.Error());
			
		return (int)Err.Error();
	}
}



HRESULT UpdateConfig(CInputParams& Input)
{
	wstring wcs;
	MSMQTriggerObjects::IMSMQTriggersConfigPtr TriggersConfig(L"MSMQTriggerObjects.MSMQTriggersConfig.1");

	wcs = Input[L"InitThreads"];
	if(!wcs.empty())
	{
		long InitThreads = 0;
		if(_snwscanf(wcs.c_str(), wcs.length(), L"%d", &InitThreads) != 1)
		{
			wprintf(L"Failed : InitThreads value must be a number between 1 and 99\n");
			return -1;
		}

		if(InitThreads <= 0 || InitThreads >= 100)
		{
			wprintf(L"Failed : InitThreads value must be a number between 1 and 99\n");
			return -1;
		}
		
		TriggersConfig->InitialThreads = InitThreads;
	}

	wcs = Input[L"MaxThreads"];
	if(!wcs.empty())
	{
		long MaxThreads = 0;
		if(_snwscanf(wcs.c_str(), wcs.length(), L"%d", &MaxThreads) != 1)
		{
			wprintf(L"Failed : MaxThreads value must be a number between 1 and 99\n");
			return -1;
		}

		if(MaxThreads <= 0 || MaxThreads >= 100)
		{
			wprintf(L"Failed : MaxThreads value must be a number between 1 and 99\n");
			return -1;
		}

		if(MaxThreads < TriggersConfig->InitialThreads)
		{
			wprintf(L"Failed : Max threads number should be higher than Init threads number\n");
			return -1;
		}
		
		TriggersConfig->MaxThreads = MaxThreads;
	}

	wcs = Input[L"BodySize"];
	if(!wcs.empty())
	{
		long DefaultMsgBodySize = 0;
		if(_snwscanf(wcs.c_str(), wcs.length(), L"%d", &DefaultMsgBodySize) != 1)
		{
			wprintf(L"Failed : DefaultMsgBodySize value must be a number between 0 and 4MB\n");
			return -1;
		}

		if(DefaultMsgBodySize <= 0 || DefaultMsgBodySize >= 4194304)
		{
			wprintf(L"Failed : DefaultMsgBodySize value must be a number between 0 and 4MB\n");
			return -1;
		}

		TriggersConfig->DefaultMsgBodySize = DefaultMsgBodySize;
	}

	wprintf(L"UpdateConfig completed successfuly\n");
	return 0;
}


HRESULT GetConfig()
{
	MSMQTriggerObjects::IMSMQTriggersConfigPtr TriggersConfig(L"MSMQTriggerObjects.MSMQTriggersConfig.1");

	wprintf(L"MSMQ Triggers configuration:\n");
	wprintf(L"Initial number of threads: %d\n", TriggersConfig->InitialThreads);
	wprintf(L"Max number of threads: %d\n", TriggersConfig->MaxThreads);
	wprintf(L"Default message body size is: %d\n", TriggersConfig->DefaultMsgBodySize);

	return 0;
}


HRESULT AddTrigger(wstring MachineName, CInputParams& Input)
{
	wstring wcs;
	MSMQTriggerObjects::IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");	
	TriggerSet->Init(MachineName.c_str());
	TriggerSet->Refresh();

	wstring TriggerName = Input[L"Name"];
	if(TriggerName.empty())
	{
		wprintf(L"Failed : Trigger name must be given\n");
		return -1;
	}

	MSMQTriggerObjects::SystemQueueIdentifier SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_NONE;

    wstring QueuePath = Input[L"Queue"];
	if(QueuePath.empty())
	{
		wprintf(L"Failed : Queue path must be given\n");
		return -1;
	}
	
	if(_wcsicmp(QueuePath.c_str(), L"JOURNAL") == 0)
	{
		SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_JOURNAL;
		QueuePath = L"";
	}
	else if(_wcsicmp(QueuePath.c_str(), L"DEADLETTER") == 0)
	{
		SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_DEADLETTER;
		QueuePath = L"";
	}
	else if(_wcsicmp(QueuePath.c_str(), L"DEADXACT") == 0)
	{
		SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_DEADXACT;
		QueuePath = L"";
	}


	MSMQTriggerObjects::MsgProcessingType MsgProcess = MSMQTriggerObjects::PEEK_MESSAGE;

    wstring wcsMsgProcess = Input[L"MsgProcess"];
	
	if(!wcsMsgProcess.empty())
	{
		if(_wcsicmp(wcsMsgProcess.c_str(), L"peek") == 0)
		{
			MsgProcess = MSMQTriggerObjects::PEEK_MESSAGE;
			wcsMsgProcess = L"";
		}
		else if(_wcsicmp(wcsMsgProcess.c_str(), L"retrieve") == 0)
		{
			MsgProcess = MSMQTriggerObjects::RECEIVE_MESSAGE;
			wcsMsgProcess = L"";
		}
		else if(_wcsicmp(wcsMsgProcess.c_str(), L"xact") == 0)
		{
			MsgProcess = MSMQTriggerObjects::RECEIVE_MESSAGE_XACT;
			wcsMsgProcess = L"";
		}
		else
		{
			wprintf(L"Failed : MsgProcess should be either peek, retrieve or xact");
			return -1;
		}
	}


	long lEnabled = 1, lSerialized = 0;

	wcs = Input[L"Enabled"];
	if(!wcs.empty())
	{
		if(_wcsicmp(wcs.c_str(), L"true") == 0)
		{
			lEnabled = 1;
		}
		else if(_wcsicmp(wcs.c_str(), L"false") == 0)
		{
			lEnabled = 0;
		}
		else
		{
			wprintf(L"Failed : Enabled should be either true or false");
			return -1;
		}
	}

	wcs = Input[L"Serialized"];
	if(!wcs.empty())
	{
		if(_wcsicmp(wcs.c_str(), L"true") == 0)
		{
			lSerialized = 1;
		}
		else if(_wcsicmp(wcs.c_str(), L"false") == 0)
		{
			lSerialized = 0;
		}
		else
		{
			wprintf(L"Failed : Serialized should be either true or false");
			return -1;
		}
	}

    
	BSTR bstrTriggerID = NULL;

	TriggerSet->AddTrigger(
					TriggerName.c_str(),
					QueuePath.c_str(),
					SystemQueue,
					lEnabled,
					lSerialized,
					MsgProcess,
					&bstrTriggerID); 
				
	wprintf(L"%s\n", (WCHAR*)_bstr_t(bstrTriggerID));
	SysFreeString(bstrTriggerID);
	return 0;
}

HRESULT UpdateTrigger(wstring MachineName, CInputParams& Input)
{
	wstring wcs;
	MSMQTriggerObjects::IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");	
	TriggerSet->Init(MachineName.c_str());
	TriggerSet->Refresh();

	wstring TriggerId = Input[L"ID"];
	if(TriggerId.empty())
	{
		wprintf(L"Failed : Trigger Id must be given\n");
		return -1;
	}

	BSTR bstrTriggerName = NULL, bstrQueuePath = NULL;
	long lEnabled = 0, lSerialized = 0, lNumberOfRules = 0;
	MSMQTriggerObjects::SystemQueueIdentifier SystemQueue;
	MSMQTriggerObjects::MsgProcessingType MsgProcess; 
	
	TriggerSet->GetTriggerDetailsByID(
					TriggerId.c_str(),
					&bstrTriggerName,
					&bstrQueuePath,
					&SystemQueue,
					&lNumberOfRules,
					&lEnabled,
					&lSerialized,
					&MsgProcess);

	wstring TriggerName = Input[L"Name"];
	if(TriggerName.empty())
	{
		TriggerName = (WCHAR*)_bstr_t(bstrTriggerName);	
	}
	
	wstring QueuePath = Input[L"Queue"];
	if(QueuePath.empty())
	{
		//SystemQueue is already updated
		QueuePath = (WCHAR*)_bstr_t(bstrQueuePath);
	}
	else //queue path parameter is given and should be updated
	{
		if(_wcsicmp(QueuePath.c_str(), L"JOURNAL") == 0)
		{
			SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_JOURNAL;
			QueuePath = L"";
		}
		else if(_wcsicmp(QueuePath.c_str(), L"DEADLETTER") == 0)
		{
			SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_DEADLETTER;
			QueuePath = L"";
		}
		else if(_wcsicmp(QueuePath.c_str(), L"DEADXACT") == 0)
		{
			SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_DEADXACT;
			QueuePath = L"";
		}
		else //regular path given
		{
			SystemQueue = MSMQTriggerObjects::SYSTEM_QUEUE_NONE;
		}
	}

    wstring wcsMsgProcess = Input[L"MsgProcess"];
	if(!wcsMsgProcess.empty())
	{
		if(_wcsicmp(wcsMsgProcess.c_str(), L"peek") == 0)
		{
			MsgProcess = MSMQTriggerObjects::PEEK_MESSAGE;
			wcsMsgProcess = L"";
		}
		else if(_wcsicmp(wcsMsgProcess.c_str(), L"retrieve") == 0)
		{
			MsgProcess = MSMQTriggerObjects::RECEIVE_MESSAGE;
			wcsMsgProcess = L"";
		}
		else if(_wcsicmp(wcsMsgProcess.c_str(), L"xact") == 0)
		{
			MsgProcess = MSMQTriggerObjects::RECEIVE_MESSAGE_XACT;
			wcsMsgProcess = L"";
		}
		else
		{
			wprintf(L"Failed : MsgProcess should be either peek, retrieve or xact");
			return -1;
		}
	}

	SysFreeString(bstrTriggerName);
	SysFreeString(bstrQueuePath);
	
	wcs = Input[L"Enabled"];
	if(!wcs.empty())
	{
		if(_wcsicmp(wcs.c_str(), L"true") == 0)
		{
			lEnabled = 1;
		}
		else if(_wcsicmp(wcs.c_str(), L"false") == 0)
		{
			lEnabled = 0;
		}
		else
		{
			wprintf(L"Failed : Enabled should be either true or false");
			return -1;
		}
	}

	wcs = Input[L"Serialized"];
	if(!wcs.empty())
	{
		if(_wcsicmp(wcs.c_str(), L"true") == 0)
		{
			lSerialized = 1;
		}
		else if(_wcsicmp(wcs.c_str(), L"false") == 0)
		{
			lSerialized = 0;
		}
		else
		{
			wprintf(L"Failed : Serialized should be either true or false");
			return -1;
		}
	}

    TriggerSet->UpdateTrigger(
					TriggerId.c_str(),			
					TriggerName.c_str(),
					QueuePath.c_str(),
					SystemQueue,
					lEnabled,
					lSerialized,
					MsgProcess
					);
				
	wprintf(L"Trigger was updated successfuly\n");
	return 0;
}


HRESULT DeleteTrigger(wstring MachineName, CInputParams& Input)
{
	MSMQTriggerObjects::IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");	
	TriggerSet->Init(MachineName.c_str());
	TriggerSet->Refresh();

	wstring TriggerId = Input[L"ID"];
	if(TriggerId.empty())
	{
		wprintf(L"Trigger Id must be given\n");
		return -1;
	}

	TriggerSet->DeleteTrigger(TriggerId.c_str());

	wprintf(L"Trigger was deleted successfuly\n");
	return 0;
}


HRESULT AttachDetachRule(wstring MachineName, CInputParams& Input, bool fAttach)
{
	MSMQTriggerObjects::IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");	
	TriggerSet->Init(MachineName.c_str());
	TriggerSet->Refresh();

	wstring TriggerId = Input[L"TriggerID"];
	if(TriggerId.empty())
	{
		wprintf(L"Trigger Id must be given\n");
		return -1;
	}

	wstring RuleId = Input[L"RuleID"];
	if(RuleId.empty())
	{
		wprintf(L"Failed : Rule Id must be given\n");
		return -1;
	}

	if(fAttach)
	{
		long lPriority;
		wstring wcs = Input[L"Priority"];
		if(!wcs.empty())
		{
			if(_snwscanf(wcs.c_str(), wcs.length(), L"%d", &lPriority) != 1)
			{
				wprintf(L"Failed : Priority given must be a number in the range of 0 - number of rules attached\n");
				return -1;
			}
		
			if(lPriority < 0)
			{
				wprintf(L"Failed : Priority given must be a number in the range of 0 - number of rules attached\n");
				return -1;
			}
		}
		else //priority not given, add last
		{
			BSTR bstrTriggerName = NULL, bstrQueuePath = NULL;
			long lEnabled = 0, lSerialized = 0, lNumberOfRules = 0;
			MSMQTriggerObjects::SystemQueueIdentifier SystemQueue;

			TriggerSet->GetTriggerDetailsByID(
							TriggerId.c_str(),
							&bstrTriggerName,
							&bstrQueuePath,
							&SystemQueue,
							&lNumberOfRules,
							&lEnabled,
							&lSerialized,
							NULL);

			lPriority = lNumberOfRules;
			SysFreeString(bstrTriggerName);
			SysFreeString(bstrQueuePath);
		}
		
		TriggerSet->AttachRule(TriggerId.c_str(), RuleId.c_str(), lPriority);
		wprintf(L"Attach operation completed successfuly\n");
	}
	else //detach
	{
		TriggerSet->DetachRule(TriggerId.c_str(), RuleId.c_str());
		wprintf(L"Detach operation completed successfuly\n");
	}

	return 0;
}


HRESULT AddRule(wstring MachineName, CInputParams& Input)
{
	wstring wcs;
	MSMQTriggerObjects::IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet.1");	
	RuleSet->Init(MachineName.c_str());
	RuleSet->Refresh();

	wstring RuleName = Input[L"Name"];
	if(RuleName.empty())
	{
		wprintf(L"Failed : Rule name must be given\n");
		return -1;
	}

	wstring Description = Input[L"Desc"];
	
	wstring Condition = Input[L"Cond"];
	if(!Condition.empty())
	{
		ConvertSeperatorsToTabs(Condition);
	}
		
	wstring Action = Input[L"Action"];
	if(!Action.empty())
	{
		ConvertSeperatorsToTabs(Action);
	}
	else
	{
		Action = L"EXE";
	}

	wstring Implementation;

	long lShowWindow = 1;
	wcs = Input[L"ShowWindow"];
	if(!wcs.empty())
	{
		if(_wcsicmp(wcs.c_str(), L"true") == 0)
		{
			lShowWindow = 1;
		}
		else if(_wcsicmp(wcs.c_str(), L"false") == 0)
		{
			lShowWindow = 0;
		}
		else
		{
			wprintf(L"Failed : ShowWindow should be either true or false");
			return -1;
		}
	}

		
	BSTR  bstrRuleID = NULL;

	RuleSet->Add(
				RuleName.c_str(),
				Description.c_str(),
				Condition.c_str(),
				Action.c_str(),
				Implementation.c_str(),
				lShowWindow,
				&bstrRuleID );

	wprintf(L"%s\n", (WCHAR*)_bstr_t(bstrRuleID));
	SysFreeString(bstrRuleID);
	return 0;
}

HRESULT UpdateRule(wstring MachineName, CInputParams& Input)
{
	wstring wcs;
	MSMQTriggerObjects::IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet.1");	
	RuleSet->Init(MachineName.c_str());
	RuleSet->Refresh();

	wstring RuleId = Input[L"ID"];
	if(RuleId.empty())
	{
		wprintf(L"Failed : Rule Id must be given\n");
		return -1;
	}

	BSTR bstrRuleName = NULL;
    BSTR bstrDescription = NULL;
    BSTR bstrCondition = NULL;
    BSTR bstrAction = NULL;
    BSTR bstrImplementationProgID = NULL;
    long lShowWindow;

	RuleSet->GetRuleDetailsByID(
				RuleId.c_str(),
				&bstrRuleName,
				&bstrDescription,
				&bstrCondition,
				&bstrAction,
				&bstrImplementationProgID,
				&lShowWindow);

	wstring RuleName = Input[L"Name"];
	if(RuleName.empty())
	{
		RuleName = (WCHAR*)_bstr_t(bstrRuleName);
	}
	SysFreeString(bstrRuleName);
	
	wstring Description = Input[L"Desc"];
	if(Description.empty())
	{
		Description = (WCHAR*)_bstr_t(bstrDescription);
	}
	SysFreeString(bstrDescription);

	wstring Condition = Input[L"Cond"];
	if(Condition.empty())
	{
		Condition = (WCHAR*)_bstr_t(bstrCondition);
	}
	else
	{
		ConvertSeperatorsToTabs(Condition);
	}
	SysFreeString(bstrCondition);

	wstring Action = Input[L"Action"];
	if(Action.empty())
	{
		Action = (WCHAR*)_bstr_t(bstrAction);
	}
	else
	{
		ConvertSeperatorsToTabs(Action);
	}
	SysFreeString(bstrAction);
	
	wstring Implementation = (WCHAR*)_bstr_t(bstrImplementationProgID);
	SysFreeString(bstrImplementationProgID);

	wcs = Input[L"ShowWindow"];
	if(!wcs.empty())
	{
		if(_wcsicmp(wcs.c_str(), L"true") == 0)
		{
			lShowWindow = 1;
		}
		else if(_wcsicmp(wcs.c_str(), L"false") == 0)
		{
			lShowWindow = 0;
		}
		else
		{
			wprintf(L"Failed : ShowWindow should be either true or false");
			return -1;
		}
	}

	RuleSet->Update(
				RuleId.c_str(),
				RuleName.c_str(),
				Description.c_str(),
				Condition.c_str(),
				Action.c_str(),
				Implementation.c_str(),
				lShowWindow);

	wprintf(L"Rule was updated successfuly\n");			
	return 0;
}

HRESULT DeleteRule(wstring MachineName, CInputParams& Input)
{
	MSMQTriggerObjects::IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet.1");	
	RuleSet->Init(MachineName.c_str());
	RuleSet->Refresh();

	wstring RuleId = Input[L"ID"];
	if(RuleId.empty())
	{
		wprintf(L"Rule Id must be given\n");
		return -1;
	}

	RuleSet->Delete(RuleId.c_str());

	wprintf(L"Rule was deleted successfuly\n");
	return 0;

}

HRESULT GetTriggersList(wstring MachineName, CInputParams& )
{
	MSMQTriggerObjects::IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");	
	TriggerSet->Init(MachineName.c_str());
	TriggerSet->Refresh();
	

	wstring Triggers;
	long NumberOfTriggers = TriggerSet->GetCount();
	for(long l = 0; l < NumberOfTriggers; l++)
	{
		BSTR bstrTriggerID = NULL;
		BSTR bstrTriggerName = NULL;
		BSTR bstrQueueName = NULL;
        long lNumberOfRules;
        long lEnabled;
        long lSerialized;
		MSMQTriggerObjects::SystemQueueIdentifier SystemQueue;

		TriggerSet->GetTriggerDetailsByIndex(
							l,
							&bstrTriggerID,
							&bstrTriggerName,
							&bstrQueueName,
							&SystemQueue,
							&lNumberOfRules,
							&lEnabled,
							&lSerialized,
							NULL);

		Triggers += (WCHAR*)_bstr_t(bstrTriggerID);
		Triggers += L"\t";
		Triggers += (WCHAR*)_bstr_t(bstrTriggerName);
		Triggers += L"\t\t";

		if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_NONE)
		{
			Triggers += (WCHAR*)_bstr_t(bstrQueueName);
		}
		else if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_JOURNAL)
		{
			Triggers += L"Journal";	
		}
		else if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_DEADLETTER)
		{
			Triggers += L"DeadLetter";	
		}	
		else if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_DEADXACT)
		{
			Triggers += L"DeadXact";	
		}
		Triggers += L"\n";

		SysFreeString(bstrTriggerID);
		SysFreeString(bstrTriggerName);
		SysFreeString(bstrQueueName);
	}

	wprintf(L"Total number of Triggers is:%d\n", NumberOfTriggers);
	if(NumberOfTriggers > 0)
	{
		wprintf(L"The list of Triggers' IDs is:\n");
		wprintf(L"TriggerID\t\t\t\tTriggerName\tTriggerQueuePath\n");
		wprintf(L"---------\t\t\t\t-----------\t----------------\n");
		wprintf(L"%s", Triggers.c_str());
	}
	return 0;
}

HRESULT GetRulesList(wstring MachineName, CInputParams& )
{
	MSMQTriggerObjects::IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet.1");	
	RuleSet->Init(MachineName.c_str());
	RuleSet->Refresh();
	

	wstring Rules;
	long NumberOfRules = RuleSet->GetCount();
	for(long l = 0; l < NumberOfRules; l++)
	{
		BSTR bstrRuleID = NULL;
		BSTR bstrRuleName = NULL;
		BSTR bstrDescription = NULL;
		BSTR bstrCondition = NULL;
		BSTR bstrAction = NULL;
		BSTR bstrImplementationProgID = NULL;
		long lShowWindow = 0;

		RuleSet->GetRuleDetailsByIndex(
							l,
							&bstrRuleID,
							&bstrRuleName,
							&bstrDescription,
							&bstrCondition,
							&bstrAction,
							&bstrImplementationProgID,
							&lShowWindow );

		Rules += (WCHAR*)_bstr_t(bstrRuleID);
		Rules += L"\t";
		Rules += (WCHAR*)_bstr_t(bstrRuleName);
		Rules += L"\t\t";
		Rules += (WCHAR*)_bstr_t(bstrDescription);
		Rules += L"\n";

		SysFreeString(bstrRuleID);
		SysFreeString(bstrRuleName);
		SysFreeString(bstrDescription);
		SysFreeString(bstrCondition);
		SysFreeString(bstrAction);
		SysFreeString(bstrImplementationProgID);		
	}

	wprintf(L"Total number of rules is:%d\n", NumberOfRules);
	if(NumberOfRules > 0)
	{
		wprintf(L"The list of rules' IDs is:\n");
		wprintf(L"RuleId\t\t\t\t\tRuleName\tDescription\n");
		wprintf(L"------\t\t\t\t\t--------\t-----------\n");
		wprintf(L"%s", Rules.c_str());
	}
	return 0;
}

HRESULT GetTrigger(wstring MachineName, CInputParams& Input)
{
	MSMQTriggerObjects::IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");	
	TriggerSet->Init(MachineName.c_str());
	TriggerSet->Refresh();

	wstring TriggerId = Input[L"ID"];
	if(TriggerId.empty())
	{
		wprintf(L"Failed : Trigger Id must be given\n");
		return -1;
	}

	BSTR bstrTriggerName = NULL, bstrQueuePath = NULL;
	long lEnabled = 0, lSerialized = 0, lNumberOfRules = 0;
	MSMQTriggerObjects::SystemQueueIdentifier SystemQueue;

	TriggerSet->GetTriggerDetailsByID(
					TriggerId.c_str(),
					&bstrTriggerName,
					&bstrQueuePath,
					&SystemQueue,
					&lNumberOfRules,
					&lEnabled,
					&lSerialized,
					NULL);

	wstring AttachedRules;
	for(long l = 0; l < lNumberOfRules; l++)
	{
		BSTR bstrRuleID = NULL;
		BSTR bstrRuleName = NULL;
		BSTR bstrDescription = NULL;
		BSTR bstrCondition = NULL;
		BSTR bstrAction = NULL;
		BSTR bstrImplementationProgID = NULL;
		long lShowWindow = 0;

		TriggerSet->GetRuleDetailsByTriggerID (
							TriggerId.c_str(),
							l,
							&bstrRuleID,
							&bstrRuleName,
							&bstrDescription,
							&bstrCondition,
							&bstrAction,
							&bstrImplementationProgID,
							&lShowWindow );

		AttachedRules += L"\t";
		AttachedRules += (WCHAR*)_bstr_t(bstrRuleID);
		AttachedRules += L"\n";

		SysFreeString(bstrRuleID);
		SysFreeString(bstrRuleName);
		SysFreeString(bstrDescription);
		SysFreeString(bstrCondition);
		SysFreeString(bstrAction);
		SysFreeString(bstrImplementationProgID);
	}

	wprintf(L"Details for trigger with Id %s are:\n", TriggerId.c_str());
	wprintf(L"Trigger Name: %s\n", (WCHAR*)_bstr_t(bstrTriggerName));

	wstring QueueName;
	if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_NONE)
	{
		QueueName += (WCHAR*)_bstr_t(bstrQueuePath);
	}
	else if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_JOURNAL)
	{
		QueueName += L"Journal";	
	}
	else if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_DEADLETTER)
	{
		QueueName += L"DeadLetter";	
	}	
	else if(SystemQueue == MSMQTriggerObjects::SYSTEM_QUEUE_DEADXACT)
	{
		QueueName += L"DeadXact";	
	}
	wprintf(L"Queue Path: %s\n", QueueName.c_str());

	if(lEnabled == 0)
	{
		wprintf(L"Trigger is not Enabled\n");
	}
	else
	{
		wprintf(L"Trigger is Enabled\n");
	}

	if(lSerialized == 0)
	{
		wprintf(L"Trigger is not Serialized\n");
	}
	else
	{
		wprintf(L"Trigger is Serialized\n");
	}

	wprintf(L"Number of attached rules is: %d\n", lNumberOfRules);
	if(lNumberOfRules > 0)
	{
		wprintf(L"Attached rules are:\n");
		wprintf(L"%s", AttachedRules.c_str());
	}
	
	SysFreeString(bstrTriggerName);
	SysFreeString(bstrQueuePath);
	return 0;
}

HRESULT GetRule(wstring MachineName, CInputParams& Input)
{
	MSMQTriggerObjects::IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet.1");	
	RuleSet->Init(MachineName.c_str());
	RuleSet->Refresh();

	wstring RuleId = Input[L"ID"];
	if(RuleId.empty())
	{
		wprintf(L"Failed : Rule Id must be given\n");
		return -1;
	}

	BSTR bstrRuleName = NULL;
    BSTR bstrDescription = NULL;
    BSTR bstrCondition = NULL;
    BSTR bstrAction = NULL;
    BSTR bstrImplementationProgID = NULL;
    long lShowWindow = 0;

	RuleSet->GetRuleDetailsByID(
				RuleId.c_str(),
				&bstrRuleName,
				&bstrDescription,
				&bstrCondition,
				&bstrAction,
				&bstrImplementationProgID,
				&lShowWindow);

	wprintf(L"Details for rule with Id %s are:\n", RuleId.c_str());
	wprintf(L"Rule Name: %s\n", (WCHAR*)_bstr_t(bstrRuleName));
	wprintf(L"Description: %s\n", (WCHAR*)_bstr_t(bstrDescription));

	CStringTokens Cond;
	Cond.Parse(bstrCondition, L'\t');

	long lNumOfConds = Cond.GetNumTokens();
	wstring wcsCond;
	for(long l=0 ; l < lNumOfConds; l++)
	{
		_bstr_t bstrCurrCond;
		Cond.GetToken(l, bstrCurrCond);
		if(wcsCond.empty())
		{
			wcsCond = (WCHAR*)bstrCurrCond;
		}
		else
		{
			wcsCond += L" AND ";
			wcsCond += (WCHAR*)bstrCurrCond;
		}
	}

	wprintf(L"Condition is: %s\n", wcsCond.c_str());

	//print action
	CStringTokens Action;
	Action.Parse(bstrAction, L'\t');

	long lNumOfActionParams = Action.GetNumTokens();
	wstring wcsAction;
	for(l=0 ; l < lNumOfActionParams; l++)
	{
		_bstr_t bstrCurrActionParam;
		Action.GetToken(l, bstrCurrActionParam);
		if(wcsAction.empty())
		{
			wcsAction = (WCHAR*)bstrCurrActionParam;
		}
		else
		{
			wcsAction += L" ";
			wcsAction += (WCHAR*)bstrCurrActionParam;
		}
	}

	wprintf(L"Action is: %s\n", wcsAction.c_str());

	wprintf(L"Implementation prog id is: %s\n", (WCHAR*)_bstr_t(bstrImplementationProgID));
	
	if( lShowWindow == 0)
	{
		wprintf(L"ShowWindow is set to false\n");
	}
	else
	{
		wprintf(L"ShowWindow is set to true\n");
	}

	SysFreeString(bstrRuleName);
	SysFreeString(bstrDescription);
	SysFreeString(bstrCondition);
	SysFreeString(bstrAction);
	SysFreeString(bstrImplementationProgID);

	return 0;
}


void ConvertSeperatorsToTabs(wstring& wcs)
{
	CStringTokens Tokens;
	Tokens.Parse(wcs.c_str(), L';');

	wcs = L"";

	long lNumOfTokens = Tokens.GetNumTokens();
	for(long l=0 ; l < lNumOfTokens; l++)
	{
		_bstr_t bstrCurr;
		Tokens.GetToken(l, bstrCurr);
		if(wcs.empty())
		{
			wcs = (WCHAR*)bstrCurr;
		}
		else
		{
			wcs += L"\t";
			wcs += (WCHAR*)bstrCurr;
		}
	}

}

void PrintUsage(MSMQTriggersRequest Request)
{
	switch(Request)
	{
	case REQUEST_UPDATE_CONFIG:
		wprintf(L"UpdateConfig	Updates the Triggers service configuration parameters.\n\n");
		wprintf(L"Usage:\nTRIGADM /Request:UpdateConfig [/InitThreads:number] [/MaxThreads:number] [/BodySize:number]\n\n");		
		wprintf(L"/InitThreads	Initial number of threads that the service should use.\n");
		wprintf(L"/MaxThreads	Maximum number of threads that the service should use.\n");
		wprintf(L"/BodySize	Default message body size.\n");
		break;

	case REQUEST_GET_CONFIG:
		wprintf(L"GetConfig	Prints the Triggers service configuration parameters.\n\n");
		wprintf(L"Usage:\nTRIGADM /Request:GetConfig\n\n");		
		break;

	case REQUEST_ADD_TRIGGER:
		wprintf(L"AddTrigger	Adds a new trigger.\n\n");
		wprintf(L"Usage:\nTRIGADM /Request:AddTrigger [/Machine:name] /Name:name /Queue:name [/Enabled:{true | false}] [/Serailized:{true | false}] [/MsgProcess:{peek | retrieve | xact}]\n\n");		
		wprintf(L"/Machine		Name of the Triggers store computer (the default is the local computer).\n");
		wprintf(L"/Name		Name of the trigger (required).\n");
		wprintf(L"/Queue		Name of the queue that the trigger monitors (required).\n");
		wprintf(L"/Enabled		Specifies whether the trigger definition is enabled.\n");
		wprintf(L"/Serialized 	Specifies whether the monitored queue is serialized.\n");
		wprintf(L"/MsgProcess 	Message processing type (the default is peeking).\n");
		break;

	case REQUEST_UPDATE_TRIGGER:
		wprintf(L"UpdateTrigger	   Updates a trigger's properties.\n\n");
		wprintf(L"Usage:\nTRIGADM /Request:UpdateTrigger [/Machine:name] /ID:identifier [/Name:name] [/Queue:name] [/Enabled:{true | false}] [/Serailized:{true | false}] [/MsgProcess:{peek | retrieve | xact}]\n\n");		
		wprintf(L"/Machine		Name of the Triggers store computer (the default is the local computer).\n");
		wprintf(L"/ID		Trigger identifier (required).\n");
		wprintf(L"/Name		Name of the trigger.\n");
		wprintf(L"/Queue		Name of the queue that the trigger monitors.\n");
		wprintf(L"/Enabled		Specifies whether the trigger definition is enabled.\n");
		wprintf(L"/Serialized 	Specifies whether the monitored queue is serialized.\n");
		wprintf(L"/MsgProcess 	Message processing type (the default is peeking).\n");
 		break;

	case REQUEST_DELETE_TRIGGER:
		wprintf(L"DeleteTrigger    Deletes a trigger\n\n");
		wprintf(L"Usage:\nTRIGADM /Request:DeleteTrigger [/Machine:name] /ID:identifier\n");		
		wprintf(L"/Machine		Name of the Triggers store computer (the default is the local computer).\n\n");
		wprintf(L"/ID		Trigger identifier (required).\n");
		break;

	case REQUEST_ATTACH_RULE:
		wprintf(L"AttachRule	Attaches a rule to a trigger.\n\n");
		wprintf(L"Usage:\nTRIGADM /Request:AttachRule [/Machine:name] /TriggerID:identifier /RuleId:identifier [/Priority:number]\n\n");		
		wprintf(L"/Machine		Name of the Triggers store computer (the default is the local computer).\n");
		wprintf(L"/TriggerID	Trigger identifier (required).\n");
		wprintf(L"/RuleID		Rule identifier (required)..\n");
		wprintf(L"/Priority	Priority of the rule within the attached rules (the default is last).\n");
		break;

	case REQUEST_DETACH_RULE:
		wprintf(L"DetachRule	Detaches a rule from a trigger.\n\n");
		wprintf(L"Usage:\nTRIGADM /Request:DetachRule [/Machine:name] /TriggerID:identifier /RuleId:identifier\n\n");		
		wprintf(L"/Machine		Name of the Triggers store computer (the default is the local computer).\n");
		wprintf(L"/TriggerID	Trigger identifier (required).\n");
		wprintf(L"/RuleID		Rule identifier (required).\n");
		break;

	case REQUEST_ADD_RULE:
		wprintf(L"AddRule		Adds a new rule\n\n");
		wprintf(L"Usage:\nTRIGADM /Request:AddRule [/Machine:name] /Name:name [/Desc:description] [/Cond:condition1[;condition2][;condition3]...] [/Action:action] [/ShowWindow:{true | false}]\n\n");		
		wprintf(L"/Machine		Name of the Triggers store computer (the default is the local computer).\n");
		wprintf(L"/Name		Rule name (required).\n");
		wprintf(L"/Desc		Rule description.\n");
		wprintf(L"/Cond		A string representing rule conditions.\n");
		wprintf(L"			Each condition can be one of the following:\n");
		wprintf(L"				$MSG_LABEL_CONTAINS=xyz\n");
		wprintf(L"				$MSG_LABEL_DOES_NOT_CONTAIN=xyz\n");
		wprintf(L"				$MSG_BODY_CONTAINS=xyz\n");	
		wprintf(L"				$MSG_BODY_DOES_NOT_CONTAIN=xyz\n");
		wprintf(L"				$MSG_PRIORITY_EQUALS=2\n");
		wprintf(L"				$MSG_PRIORITY_DOES_NOT_EQUAL=2\n");
		wprintf(L"				$MSG_PRIORITY_GREATER_THAN=2\n");
		wprintf(L"				$MSG_PRIORITY_LESS_THAN=2\n");
		wprintf(L"				$MSG_APPSPECIFIC_EQUALS=2\n");
		wprintf(L"				$MSG_APPSPECIFIC_DOES_NOT_EQUAL=2\n");
		wprintf(L"				$MSG_APPSPECIFIC_GREATER_THAN=2\n");
		wprintf(L"				$MSG_APPSPECIFIC_LESS_THAN=2\n");
		wprintf(L"				$MSG_SRCMACHINEID_EQUALS=67652B78-2F4D-46f5-AA98-9FFB776B340A\n");
		wprintf(L"				$MSG_SRCMACHINEID_DOES_NOT_EQUAL=67652B78-2F4D-46f5-AA98-9FFB776B340A\n");
		wprintf(L"/Action		A string representing the action invoked by the rule.\n");
		wprintf(L"				EXE;exe path;command line params\n");
		wprintf(L"				COM;progID;method name;method arguments\n");
		wprintf(L"			Params and Arguments can be one of the following:\n");
		wprintf(L"				$MSG_ID\n");
		wprintf(L"				$MSG_LABEL\n");
		wprintf(L"				$MSG_BODY\n");
		wprintf(L"				$MSG_BODY_AS_STRING\n");
		wprintf(L"				$MSG_PRIORITY\n");
		wprintf(L"				$MSG_ARRIVEDTIME\n");
		wprintf(L"				$MSG_SENTTIME\n");
		wprintf(L"				$MSG_CORRELATION_ID\n");
		wprintf(L"				$MSG_APPSPECIFIC\n");
		wprintf(L"				$MSG_QUEUE_PATHNAME\n");
		wprintf(L"				$MSG_QUEUE_FORMATNAME\n");
		wprintf(L"				$MSG_RESPONSE_QUEUE_FORMATNAME\n");
		wprintf(L"				$MSG_ADMIN_QUEUE_FORMATNAME\n");
		wprintf(L"				$MSG_SRCMACHINEID\n");
		wprintf(L"				$TRIGGER_NAME\n");
		wprintf(L"				$TRIGGER_ID\n");
		wprintf(L"				\"string literal\"\n");
		wprintf(L"				numeric literal\n");
		wprintf(L"/ShowWindow	Specifies whether the application window is shown (appiles only when the action type is exe).\n");
		break;

	case REQUEST_UPDATE_RULE:
		wprintf(L"UpdateRule	Updates a rule's properties.\n\n");
		wprintf(L"Usage:\nTRIGADM /Request:UpdateRule [/Machine:name] /ID:identifier [/Name:name] [/Desc:description] [/Cond:condition1[;condition2][;condition3]...] [/Action:action] [/ShowWindow:{true | false}]\n\n");		
		wprintf(L"/Machine		Name of the Triggers store computer (the default is the local computer).\n");
		wprintf(L"/ID		Rule identifier (required).\n");
		wprintf(L"/Name		Rule name.\n");
		wprintf(L"/Desc	 	Rule description.\n");
		wprintf(L"/Cond		A string representing rule conditions.\n");
		wprintf(L"			Each condition can be one of the following:\n");
		wprintf(L"				$MSG_LABEL_CONTAINS=xyz\n");
		wprintf(L"				$MSG_LABEL_DOES_NOT_CONTAIN=xyz\n");
		wprintf(L"				$MSG_BODY_CONTAINS=xyz\n");	
		wprintf(L"				$MSG_BODY_DOES_NOT_CONTAIN=xyz\n");
		wprintf(L"				$MSG_PRIORITY_EQUALS=2\n");
		wprintf(L"				$MSG_PRIORITY_DOES_NOT_EQUAL=2\n");
		wprintf(L"				$MSG_PRIORITY_GREATER_THAN=2\n");
		wprintf(L"				$MSG_PRIORITY_LESS_THAN=2\n");
		wprintf(L"				$MSG_APPSPECIFIC_EQUALS=2\n");
		wprintf(L"				$MSG_APPSPECIFIC_DOES_NOT_EQUAL=2\n");
		wprintf(L"				$MSG_APPSPECIFIC_GREATER_THAN=2\n");
		wprintf(L"				$MSG_APPSPECIFIC_LESS_THAN=2\n");
		wprintf(L"				$MSG_SRCMACHINEID_EQUALS=67652B78-2F4D-46f5-AA98-9FFB776B340A\n");
		wprintf(L"				$MSG_SRCMACHINEID_DOES_NOT_EQUAL=67652B78-2F4D-46f5-AA98-9FFB776B340A\n");
		wprintf(L"/Action		A string representing the rule action.\n");
		wprintf(L"				EXE;exe path;command line params\n");
		wprintf(L"				COM;progID;method name;method arguments\n");
		wprintf(L"			Params and Arguments can be one of the following:\n");
		wprintf(L"				$MSG_ID\n");
		wprintf(L"				$MSG_LABEL\n");
		wprintf(L"				$MSG_BODY\n");
		wprintf(L"				$MSG_BODY_AS_STRING\n");
		wprintf(L"				$MSG_PRIORITY\n");
		wprintf(L"				$MSG_ARRIVEDTIME\n");
		wprintf(L"				$MSG_SENTTIME\n");
		wprintf(L"				$MSG_CORRELATION_ID\n");
		wprintf(L"				$MSG_APPSPECIFIC\n");
		wprintf(L"				$MSG_QUEUE_PATHNAME\n");
		wprintf(L"				$MSG_QUEUE_FORMATNAME\n");
		wprintf(L"				$MSG_RESPONSE_QUEUE_FORMATNAME\n");
		wprintf(L"				$MSG_ADMIN_QUEUE_FORMATNAME\n");
		wprintf(L"				$MSG_SRCMACHINEID\n");
		wprintf(L"				$TRIGGER_NAME\n");
		wprintf(L"				$TRIGGER_ID\n");
		wprintf(L"				\"string literal\"\n");
		wprintf(L"				numeric literal\n");
		wprintf(L"/ShowWindow	Specifies whether the application window is shown (appiles only when the action type is exe).\n");
		break;

	case REQUEST_DELETE_RULE:
		wprintf(L"DeleteRule	Deletes a rule.\n\n");
		wprintf(L"Usage:\nTRIGADM /Request:DeleteRule [/Machine:name] /ID:identifier\n\n");		
		wprintf(L"/Machine		Name of the Triggers store computer (the default is the local computer).\n");
		wprintf(L"/ID		Rule identifier (required).\n");
		break;

	case REQUEST_GET_TRIGGERS_LIST:
		wprintf(L"GetTriggersList    Prints the list of triggers.\n\n");
		wprintf(L"Usage:\nTRIGADM /Request:GetTriggersList [/Machine:name]\n\n");		
		wprintf(L"/Machine		Name of the Triggers store computer (the default is the local computer).\n");
		break;

	case REQUEST_GET_RULES_LIST:
		wprintf(L"GetRulesList    Prints the list of rules.\n\n");
		wprintf(L"Usage:\nTRIGADM /Request:GetRulesList [/Machine:name]\n\n");		
		wprintf(L"/Machine		Name of the Triggers store computer (the default is the local computer).\n");
		break;

	case REQUEST_GET_TRIGGER:
		wprintf(L"GetTrigger	Prints a trigger's properties.\n\n");
		wprintf(L"Usage:\nTRIGADM /Request:GetTrigger [/Machine:name] /ID:identifier\n\n");		
		wprintf(L"/Machine		Name of the Triggers store computer (the default is the local computer).\n");
		wprintf(L"/ID		Trigger identifier (required).\n");
		break;

	case REQUEST_GET_RULE:
		wprintf(L"GetRule		Prints a rule's properties.\n\n");
		wprintf(L"Usage:\nTRIGADM /Request:GetRule [/Machine:name] /ID:identifier\n\n");		
		wprintf(L"/Machine		Name of the Triggers store computer (the default is the local computer).\n");
		wprintf(L"/ID		Rule identifier (required).\n");
		break;

	case REQUEST_ILLEGAL:
	case REQUEST_NONE:
		{

			wprintf(L"TRIGADM is an administrative tool for management of the trigger store.\n\n");
			wprintf(L"Usage:\nTRIGADM /Request:option\n\n");	
			wprintf(L"Request takes any one of the following options:\n");
			wprintf(L"GetConfig			Prints the Triggers service configuration parameters.\n");
			wprintf(L"UpdateConfig		Updates the Triggers service configuration parameters.\n");
			wprintf(L"AddTrigger		Adds a new trigger.\n");
			wprintf(L"UpdateTrigger		Updates a trigger's properties.\n");
			wprintf(L"DeleteTrigger		Deletes a trigger.\n");
			wprintf(L"GetTrigger		Prints a trigger's properties.\n");
			wprintf(L"AddRule			Adds a new rule.\n");
			wprintf(L"UpdateRule		Updates a rule.\n");
			wprintf(L"DeleteRule		Deletes a rule.\n");
			wprintf(L"GetRule			Prints a rule's properties.\n");
			wprintf(L"AttachRule		Attaches a rule to a trigger.\n");
			wprintf(L"DetachRule		Detaches a rule from a trigger.\n");
			wprintf(L"GetTriggersList		Prints the list of triggers.\n");
			wprintf(L"GetRulesList		Prints the list of rules.\n");
			return;
		}
		break;

	default:
		ASSERT(0);
	}
		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\xactproj\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__904E6F81_C4C6_43BE_B7D5_2F325A670FB6__INCLUDED_)
#define AFX_STDAFX_H__904E6F81_C4C6_43BE_B7D5_2F325A670FB6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#undef _DEBUG

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__904E6F81_C4C6_43BE_B7D5_2F325A670FB6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\testrule\main.cpp ===
#include <libpch.h>
//#include <comdef.h>

#import "mqtrig.tlb" no_namespace 

using namespace std;

const LPCWSTR xLableCondition[] = {
    L"\t",
    L"$MSG_LABEL_CONTAINS=HelloWorld\t",
    L"$MSG_LABEL_DOES_NOT_CONTAIN=HelloWorld\t",
};

const LPCWSTR xBodyCondition[] = {
    L"\t",
    L"$MSG_BODY_CONTAINS=HelloWorld\t",
    L"$MSG_BODY_DOES_NOT_CONTAIN=HelloWorld\t",
};

const LPCWSTR xPriorityCondition[] = {
    L"\t",
    L"$MSG_PRIORITY_EQUALS=2\t",
	L"$MSG_PRIORITY_NOT_EQUAL=2\t",
    L"$MSG_PRIORITY_GREATER_THAN=2\t",
    L"$MSG_PRIORITY_LESS_THAN=2\t"
};

const LPCWSTR xAppspecificCondition[] = {
    L"\t",
    L"$MSG_APPSPECIFIC_EQUALS=2\t",
	L"$MSG_APPSPECIFIC_NOT_EQUAL=2\t",
    L"$MSG_APPSPECIFIC_GREATER_THAN=2\t",
    L"$MSG_APPSPECIFIC_LESS_THAN=2\t"
};

const LPCWSTR xSrcmachineCondition[] = {
    L"\t"
    L"$MSG_SRCMACHINEID_EQUALS=67652B78-2F4D-46f5-AA98-9FFB776B340A",
    L"$MSG_SRCMACHINEID_NOT_EQUAL=67652B78-2F4D-46f5-AA98-9FFB776B340A",
};

void BuildRuleCondition(
    wostringstream& ruleCond
    )
{
    ruleCond << xLableCondition[rand() % TABLE_SIZE(xLableCondition)];
    ruleCond << xBodyCondition[rand() % TABLE_SIZE(xBodyCondition)];
    ruleCond << xPriorityCondition[rand() % TABLE_SIZE(xPriorityCondition)];
    ruleCond << xAppspecificCondition[rand() % TABLE_SIZE(xAppspecificCondition)];
    ruleCond << xSrcmachineCondition[rand() % TABLE_SIZE(xSrcmachineCondition)];
}


void BuildRuleAction(
    wostringstream& ruleAction
    )
{
    ruleAction << L"EXE;c:\temp\try.exe;";
	ruleAction << (rand() %2 == 0) ? L"$MSG_ID;" : L"";
	ruleAction << (rand() %2 == 0) ? L"$MSG_LABEL;" : L"";
	ruleAction << (rand() %2 == 0) ? L"$MSG_BODY;" : L"";
	ruleAction << (rand() %2 == 0) ? L"$MSG_BODY_AS_STRING;" : L"";
	ruleAction << (rand() %2 == 0) ? L"$MSG_PRIORITY;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_ARRIVEDTIME;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_SENTTIME;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_CORRELATION_ID;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_APPSPECIFIC;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_QUEUE_PATHNAME;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_QUEUE_FORMATNAME;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_RESPONSE_QUEUE_FORMATNAME;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_ADMIN_QUEUE_FORMATNAME;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$MSG_SRCMACHINEID;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$TRIGGER_NAME;" : L"";
	ruleAction << (rand() %2 == 0) ? L"	$TRIGGER_ID;" : L"";
}


void CreateRules(IMSMQRuleSetPtr& RuleSet, BSTR* ruleIds, DWORD NoOfRules)
{
    //
    // Create rules
    //
    for (DWORD i = 0; i < NoOfRules; ++i)
    {
        wostringstream ruleName;
        wostringstream ruleCond;
        wostringstream ruleAction;

        ruleName << L"Rule" << i;
        BuildRuleCondition(ruleCond);
        BuildRuleAction(ruleAction);

        RuleSet->Add(
                    ruleName.str().c_str(),
                    L"Test - Create Rule",
                    ruleCond.str().c_str(),
                    ruleAction.str().c_str(),
                    L"",
                    rand() %2,
                    &ruleIds[i]
                    );
        //wprintf(L"Success to add rule %ls, rule id = %s\n", ruleName.str().data(), static_cast<LPCWSTR>(ruleIds[i]));

    }
}


void UpdateRules(IMSMQRuleSetPtr& RuleSet, BSTR* ruleIds, DWORD NoOfRules)
{
    //
    // Update rules
    //
    for (DWORD i = 0; i < NoOfRules; ++i)
    {
        wostringstream ruleName;
        wostringstream ruleCond;
        wostringstream ruleAction;

        ruleName << L"Update Rule" << i;
        BuildRuleCondition(ruleCond);
        BuildRuleAction(ruleAction);

        RuleSet->Update(
                    ruleIds[i],
                    ruleName.str().c_str(),
                    L"Test - Update Rule",
                    ruleCond.str().c_str(),
                    ruleAction.str().c_str(),
                    L"",
                    rand() %2
                    );

        //wprintf(L"Success to update rule %s, rule id = %s\n", ruleName.str().data(), static_cast<LPCWSTR>(ruleIds[i]));

    }

}


void RetrieveRules(IMSMQRuleSetPtr& RuleSet, BSTR* ruleIds, DWORD NoOfRules)
{
    //
    // retrieve rules
    //
    for (DWORD i = NoOfRules; i > 0; i--)
    {
        BSTR ruleName = NULL;
        BSTR ruleDescription = NULL;
        BSTR ruleCond = NULL;
        BSTR ruleAction = NULL;
        BSTR ruleProg = NULL;
        long ruleShowWindow = NULL;

        RuleSet->GetRuleDetailsByID(
                    ruleIds[i-1],
                    &ruleName,
                    &ruleDescription,
                    &ruleCond,
                    &ruleAction,
                    &ruleProg,
                    &ruleShowWindow
                    );


        /*
        wprintf(L"Success to retrieve values of rule = %s\n", static_cast<LPCWSTR>(ruleIds[i-1]));
        wprintf(L"\trule name = %s\n", static_cast<LPCWSTR>(ruleName));
        wprintf(L"\trule Description = %s\n", static_cast<LPCWSTR>(ruleDescription));
        wprintf(L"\trule Condition = %s\n", static_cast<LPCWSTR>(ruleCond));
        wprintf(L"\trule Action = %s\n", static_cast<LPCWSTR>(ruleAction));
        wprintf(L"\trule Program = %s\n", static_cast<LPCWSTR>(ruleProg));
        */

        SysFreeString(ruleName);
        SysFreeString(ruleDescription);
        SysFreeString(ruleCond);
        SysFreeString(ruleAction);
        SysFreeString(ruleProg);
    }
}


void DeleteRules(BSTR* ruleIds, DWORD NoOfRules)
{
    IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet.1");

    RuleSet->Init(L"");
    RuleSet->Refresh();
    //
    // Delete rules
    //
    for (DWORD i = 0; i < NoOfRules; ++i)
    {
        RuleSet->Delete(ruleIds[i]);
        // wprintf(L"Success to delete rule: %s\n", static_cast<LPCWSTR>(ruleIds[i]));
    }

    try
    {
        RuleSet->Delete(ruleIds[1]);
    }
    catch(const _com_error&)
    {
        return;
    }

    //
    // delete of unexisiting rule shoule fail
    //
    throw exception();
}


void TestRuleOperation(BSTR* ruleIds, DWORD NoOfRules)
{
    IMSMQRuleSetPtr RuleSet(L"MSMQTriggerObjects.MSMQRuleSet.1");

    try
    {
        RuleSet->Init(L"");
        RuleSet->Refresh();
    
        CreateRules(RuleSet, ruleIds, NoOfRules);
        UpdateRules(RuleSet, ruleIds, NoOfRules);
        RetrieveRules(RuleSet, ruleIds, NoOfRules);
    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to execute rule operation. ErrorMsg: %s. Error: 0x%x", e.ErrorMessage(), e.Error()); 
        throw;
    }
}


void DeleteTriggers(BSTR* triggersIds, DWORD NoOfTriggers)
{
    IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");

    TriggerSet->Init(L"");
    TriggerSet->Refresh();

    //
    // Delete rules
    //
    for (DWORD i = 0; i < NoOfTriggers; ++i)
    {
        TriggerSet->DeleteTrigger(triggersIds[i]);
        //wprintf(L"Success to delete trigger: %s\n", static_cast<LPCWSTR>(triggersIds[i]));
    }

    try
    {
        TriggerSet->DeleteTrigger(triggersIds[1]);
    }
    catch(const _com_error&)
    {
        return;
    }

    //
    // delete of unexisiting rule shoule fail
    //
    throw exception();
}

void     
CreateTriggers(
    IMSMQTriggerSetPtr& TriggerSet,
    const BSTR* ruleIds, 
    DWORD noOfRules,
    BSTR* triggerIds, 
    DWORD noOfTriggers
    )
{
    for (DWORD i = 0; i < noOfTriggers; ++i)
    {
        wostringstream triggerName;


        triggerName << L"Trigger" << i;

        TriggerSet->AddTrigger(
                        triggerName.str().c_str(),
                        L".\\q1",
                        SYSTEM_QUEUE_NONE,
                        rand() %2,
                        rand() %2,
						PEEK_MESSAGE,
                        &triggerIds[i]
                        );

        //
        // Attached rule to trigger
        //
        DWORD NoOfAttachedRule = ( rand() % noOfRules ) + 1;
        DWORD ruleIndex = rand() % noOfRules;
        for (DWORD j = 0; j < NoOfAttachedRule; ++j)
        {
            DWORD rulePriority = rand() % (j + 1);

            TriggerSet->AttachRule(triggerIds[i], ruleIds[(ruleIndex+j) % noOfRules], rulePriority);
        }
            
        try
        {
            //
            // try to add same rule twice
            //
            TriggerSet->AttachRule(triggerIds[i], ruleIds[ruleIndex], 0);
            wprintf(L"Test Failed. Successed to attach the same rule twice");
            throw exception();
        }
        catch(const _com_error&)
        {
            // should failed. Try to attach existing rule 
        }

        //
        // detach rule
        //
        TriggerSet->DetachRule(triggerIds[i], ruleIds[ruleIndex]);

        //
        // attach and detach of invalid rule
        //
        try
        {
            TriggerSet->AttachRule(triggerIds[i], L"52601E36-6ED9-4e41-A7D6-B6B7AEA38348", 0);
            wprintf(L"Test Failed. Success to attach un-exisiting rule");
            throw exception();
        }
        catch(const _com_error&)
        {
            // should failed. Try to attach existing rule 
        }
        try
        {
            TriggerSet->DetachRule(triggerIds[i], L"52601E36-6ED9-4e41-A7D6-B6B7AEA38348");
            wprintf(L"Test Failed. Success to detach un-exisiting rule");
            throw exception();
        }
        catch(const _com_error&)
        {
            // should failed. Try to attach existing rule 
        }
    }
}


void     
TestTriggerOperation(
    const BSTR* ruleIds, 
    DWORD noOfRules,
    BSTR* triggerIds, 
    DWORD noOfTriggers
    )
{
    IMSMQTriggerSetPtr TriggerSet(L"MSMQTriggerObjects.MSMQTriggerSet.1");

    try
    {
        TriggerSet->Init(L"");
        TriggerSet->Refresh();
    
        long NoOfExistingTrigger = TriggerSet->GetCount();

        CreateTriggers(TriggerSet, ruleIds, noOfRules, triggerIds, noOfTriggers);
        
        if (numeric_cast<DWORD>(TriggerSet->GetCount()) != NoOfExistingTrigger + noOfTriggers)
        {
            wprintf(L"Failed to create all the requested triggers\n");
            throw exception();
        }

        TriggerSet->DetachAllRules(triggerIds[0]);


    }
    catch(const _com_error& e)
    {
        wprintf(L"Failed to execute rule operation. ErrorMsg: %s. Error: 0x%x", e.ErrorMessage(), e.Error()); 
        throw;
    }
}




int __cdecl wmain(int , WCHAR**)
{
    try
    {
	    HRESULT hr = CoInitialize(NULL);
	    if(FAILED(hr))
	    {
		    wprintf(L"Failed to initialize com. Error=%#x\n", hr);
		    return -1;
	    }

        BSTR ruleIds[12] = { 0 };
        BSTR triggerIds[1] = { 0 };

        TestRuleOperation(ruleIds, TABLE_SIZE(ruleIds));
        TestTriggerOperation(ruleIds, TABLE_SIZE(ruleIds), triggerIds, TABLE_SIZE(triggerIds));

        DeleteTriggers(triggerIds, TABLE_SIZE(triggerIds));
        DeleteRules(ruleIds, TABLE_SIZE(ruleIds));

        //
        // free BSTR
        //
        for (DWORD i = 0; i < TABLE_SIZE(ruleIds); ++i)
        {
            SysFreeString(ruleIds[i]);
        }

        for (DWORD i = 0; i < TABLE_SIZE(triggerIds); ++i)
        {
            SysFreeString(triggerIds[i]);
        }

        CoUninitialize();
        
        wprintf(L"Test pass successfully\n");
        return 0;
    }
    catch(const exception&)
    {
    }
    catch(const _com_error&)
    {
    }

    wprintf(L"Test Failed\n");
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\xactproj\xactobj.h ===
// XactObj.h : Declaration of the CXactObj

#ifndef __XACTOBJ_H_
#define __XACTOBJ_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CXactObj
class ATL_NO_VTABLE CXactObj : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CXactObj, &CLSID_XactObj>,
	public IDispatchImpl<IXactObj, &IID_IXactObj, &LIBID_XACTPROJLib>
{
public:
	CXactObj()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_XACTOBJ)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CXactObj)
	COM_INTERFACE_ENTRY(IXactObj)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IXactObj
public:
	STDMETHOD(XactFunc)();
};

#endif //__XACTOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\xactproj\xactobj.cpp ===
// XactObj.cpp : Implementation of CXactObj
#include "stdafx.h"
#include "Xactproj.h"
#include "XactObj.h"

/////////////////////////////////////////////////////////////////////////////
// CXactObj


STDMETHODIMP CXactObj::XactFunc()
{
	// TODO: Add your implementation code here

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\tests\xactproj\xactproj.cpp ===
// xactproj.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f xactprojps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "xactproj.h"

#include "xactproj_i.c"
#include "XactObj.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_XactObj, CXactObj)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_XACTPROJLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\clusfunc.h ===
//*****************************************************************************
//
// Class Name  :
//
// Author      : Nela Karpel
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 08/08/00 | nelak     | 
//
//*****************************************************************************
#ifndef ClusFunc_INCLUDED 
#define ClusFunc_INCLUDED


bool
FindTriggersServiceName(
	void
	);


LPCWSTR
GetTrigParamRegPath(
	void
	);


bool 
ClusteredService(
	LPCWSTR wzServiceName
	);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\cpropbag.hpp ===
//*****************************************************************************
//
// Class Name  : CMSMQPropertyBag
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : Header file for the CMSMQPropertyBag class. This 
//               class is used to transport name-value pairs between
//               components.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef __MSMQPROPERTYBAG_H_
#define __MSMQPROPERTYBAG_H_

#include "resource.h"       // main symbols

#pragma warning(disable:4786)

// Define the name of this object as it will appear in the log
#define THIS_OBJECT_NAME   _T("IMSMQPropertyBag")


using namespace std;

// Define a new type - a 2D array of named variants.
typedef map<wstring,VARIANT*, less<wstring> > PROPERTY_MAP;

class ATL_NO_VTABLE CMSMQPropertyBag : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSMQPropertyBag, &CLSID_MSMQPropertyBag>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQPropertyBag, &IID_IMSMQPropertyBag, &LIBID_MSMQTriggerObjects>
{
	public:

		CMSMQPropertyBag();
		~CMSMQPropertyBag();

		DECLARE_REGISTRY_RESOURCEID(IDR_IMSMQPROPERTYBAG)
		DECLARE_GET_CONTROLLING_UNKNOWN()

		DECLARE_PROTECT_FINAL_CONSTRUCT()

		BEGIN_COM_MAP(CMSMQPropertyBag)
			COM_INTERFACE_ENTRY(IMSMQPropertyBag)
			COM_INTERFACE_ENTRY(IDispatch)
			COM_INTERFACE_ENTRY(ISupportErrorInfo)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
		END_COM_MAP()

		HRESULT FinalConstruct()
		{
			return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pUnkMarshaler.p);
		}

		void FinalRelease()
		{
			m_pUnkMarshaler.Release();
		}

		CComPtr<IUnknown> m_pUnkMarshaler;

		// ISupportsErrorInfo
		STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

		// this is the map structure that holds property values (as variants)
		PROPERTY_MAP m_mapPropertyMap;

		STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
		STDMETHOD(Read)(/*[in]*/ BSTR sPropertyName , /*[out]*/ VARIANT * pvPropertyValue);
		STDMETHOD(Write)(/*[in]*/ BSTR sPropertyName,  /*[in]*/ VARIANT vPropertyValue);
};

#endif //__MSMQPROPERTYBAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\clusfunc.cpp ===
//************************************************************************************
//
// File Name:  clusfunc.cpp
//
// Author: Nela Karpel	
// 
// Description : Implementation of functions that deal with clustered nodes
// 
//************************************************************************************#include <stdafx.h>

 
#include <stdafx.h>
#include <clusapi.h>
#include <resapi.h>
#include <mqtg.h>
#include <autorel.h>
#include <autorel2.h>
#include <autorel3.h>
#include "stdfuncs.hpp"
#include "clusfunc.h"
#include "stddefs.hpp"
#include "mqtg.h"

#include <strsafe.h>

#include "clusfunc.tmh"

//
// Type definitions of Cluster API functions that will be loaded
// if the machine we are working on is clustered. The functions will
// be used for resource enumeration on the cluster.
//
typedef HCLUSTER (WINAPI *OpenClus_fn) (LPCWSTR);
typedef HNODE (WINAPI *OpenClusNode_fn) (HCLUSTER, LPCWSTR);
typedef HCLUSENUM (WINAPI *ClusOpenEnum_fn) (HCLUSTER, DWORD);
typedef DWORD (WINAPI *ClusEnum_fn) (HCLUSENUM, DWORD, LPDWORD, LPWSTR, LPDWORD);
typedef HRESOURCE (WINAPI *OpenClusRes_fn) (HCLUSTER, LPCWSTR);
typedef BOOL (WINAPI *GetNetName_fn) (HRESOURCE, LPWSTR, LPDWORD);
typedef DWORD (WINAPI *ClusResCtrl_fn) (HRESOURCE, HNODE, DWORD, LPVOID, DWORD, LPVOID, DWORD, LPDWORD);

//
// Type definitions of Cluster API function that will be 
// overloaded. Overload is needed for use of autohandles.
// Autohandles use Cluster API functions directly, but this
// module is not linked staticly with clusapi.lib.
//
typedef BOOL (WINAPI *CloseClus_fn) (HCLUSTER);
typedef DWORD (WINAPI *ClusCloseEnum_fn) (HCLUSENUM);
typedef BOOL (WINAPI *CloseClusRes_fn) (HRESOURCE);
typedef BOOL (WINAPI *CloseClusNode_fn) (HNODE);


static WCHAR s_wzServiceName[MAX_TRIGGERS_SERVICE_NAME];
static WCHAR s_wzTrigParamPathName[MAX_REGKEY_NAME_SIZE];

//
// Handle to clusapi.dll
//
CAutoFreeLibrary g_hLib;


BOOL 
WINAPI
CloseCluster(
  HCLUSTER hCluster
  )
{
	ASSERT(("clusapi.dll is not loaded", g_hLib != NULL));

    CloseClus_fn pfCloseClus = (CloseClus_fn)GetProcAddress(g_hLib, "CloseCluster");
	if(pfCloseClus == NULL)
	{
		DWORD gle = GetLastError();
		ASSERT(("Can not load CloseCluster() function", 0));
		TrERROR(GENERAL, "Failed to get Proc address of CloseCluster function. %!winerr!", gle);
		return FALSE;
	}

	return pfCloseClus( hCluster );
}


DWORD 
WINAPI 
ClusterCloseEnum(
  HCLUSENUM hEnum  
  )
{
	ASSERT(("clusapi.dll is not loaded", g_hLib != NULL));

    ClusCloseEnum_fn pfClusCloseEnum = (ClusCloseEnum_fn)GetProcAddress(g_hLib, "ClusterCloseEnum");
	if(pfClusCloseEnum == NULL)
	{
		DWORD gle = GetLastError();
		ASSERT(("Can not load CloseClusterEnum() function", 0));
		TrERROR(GENERAL, "Failed to get Proc address of CloseClusterEnum function. %!winerr!", gle);
		return FALSE;
	}

	return pfClusCloseEnum(hEnum);
}


BOOL 
WINAPI 
CloseClusterResource(
  HRESOURCE hResource  
  )
{
	ASSERT(("clusapi.dll is not loaded", g_hLib != NULL));

    CloseClusRes_fn pfCloseClusRes = (CloseClusRes_fn)GetProcAddress(g_hLib, "CloseClusterResource");
	
	if(pfCloseClusRes == NULL)
	{
		DWORD gle = GetLastError();
		ASSERT(("Can not load CloseClusterResource() function", 0));
		TrERROR(GENERAL, "Failed to get Proc address of CloseClusterRes function. %!winerr!", gle);
		return FALSE;
	}

	return pfCloseClusRes(hResource);
}


BOOL 
WINAPI 
CloseClusterNode(
  HNODE hNode  
  )

{
	ASSERT(("clusapi.dll is not loaded", g_hLib != NULL));

    CloseClusNode_fn pfCloseClusNode = (CloseClusNode_fn)GetProcAddress(g_hLib, "CloseClusterNode");
	if(pfCloseClusNode == NULL)
	{
		DWORD gle = GetLastError();
		ASSERT(("Can not load CloseClusterNode() function", 0));
		TrERROR(GENERAL, "Failed to get Proc address of CloseClusterNode function. %!winerr!", gle);
		return FALSE;
	}


	return pfCloseClusNode(hNode);
}


bool
IsLocalSystemCluster()
/*++
From mqutil

Routine Description:

    Check if local machine is a cluster node.

    The only way to know that is try calling cluster APIs.
    That means that on cluster systems, this code should run
    when cluster service is up and running. (ShaiK, 26-Apr-1999)

Arguments:

    None

Return Value:

    true - The local machine is a cluster node.

    false - The local machine is not a cluster node.

--*/
{

    g_hLib = LoadLibrary(L"clusapi.dll");

    if (g_hLib == NULL)
    {
        TrTRACE(GENERAL, "Local machine is NOT a Cluster node");
        return false;
    }

    typedef DWORD (WINAPI *GetState_fn) (LPCWSTR, DWORD*);
    GetState_fn pfGetState = (GetState_fn)GetProcAddress(g_hLib, "GetNodeClusterState");

    if (pfGetState == NULL)
    {
        TrTRACE(GENERAL, "Local machine is NOT a Cluster node");
        return false;
    }

    DWORD dwState = 0;
    if (ERROR_SUCCESS != pfGetState(NULL, &dwState))
    {
        TrTRACE(GENERAL, "Local machine is NOT a Cluster node");
        return false;
    }

    if (dwState != ClusterStateRunning)
    {
        TrTRACE(GENERAL, "Cluster Service is not running on this node");
        return false;
    }


    TrTRACE(GENERAL, "Local machine is a Cluster node !!");
    return true;

} //IsLocalSystemCluster


bool
IsResourceMSMQTriggers (
	HRESOURCE hResource,
	ClusResCtrl_fn pfClusResCtrl
	)
/*++

Routine Description:

	Find if the resource with the given name is of type MSMQ Triggers

Arguments:

    hResource - handle to the resource

	pfClusResCtrl - pointer to ClusterResourceControl function

Return Value:

    true - if resource is of type MSMQ Triggers
	flase - otherwise

--*/
{
	DWORD dwReturnSize = 0;
    DWORD dwStatus = pfClusResCtrl(
                           hResource,
                           0,
                           CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                           0,
                           0,
                           0,
                           0,
                           &dwReturnSize
                           );
   
	if (dwStatus != ERROR_SUCCESS)
    {
        return false;
    }

    AP<BYTE> pType = new BYTE[dwReturnSize];

    dwStatus = pfClusResCtrl(
                     hResource,
                     0,
                     CLUSCTL_RESOURCE_GET_RESOURCE_TYPE,
                     0,
                     0,
                     pType,
                     dwReturnSize,
                     &dwReturnSize
                     );

    if (dwStatus != ERROR_SUCCESS || 
		0 != _wcsicmp(reinterpret_cast<LPWSTR>(pType.get()), xDefaultTriggersServiceName))
	
	{
		return false;
	}
		
	return true;
}


bool 
GetClusteredServiceName (
	VOID
	)
/*++

Routine Description:

	Find the name of MSMQ Triggers service that is running on
	clustered machine. This computer may be a virtual server on a
	cluster, or phisycal node that is part of a cluster.

Arguments:


Return Value:

    true - if succeded to find MSMQ Triggers service on this machine
	flase - otherwise

--*/
{
	TCHAR wzComputerName[200];
	DWORD size = 200;
	GetComputerName( wzComputerName, &size );

    g_hLib = LoadLibrary(L"clusapi.dll");

    if (g_hLib == NULL)
    {
        TrTRACE(GENERAL, "Local machine is NOT a Cluster node");
        return false;
    }

	//
	// Load neccesary functions
	//
    OpenClus_fn pfOpenClus = (OpenClus_fn)GetProcAddress(g_hLib, "OpenCluster");

    OpenClusNode_fn pfOpenClusNode = (OpenClusNode_fn)GetProcAddress(g_hLib, "OpenClusterNode");

    ClusOpenEnum_fn pfClusOpenEnum = (ClusOpenEnum_fn)GetProcAddress(g_hLib, "ClusterOpenEnum");

    ClusEnum_fn pfClusEnum = (ClusEnum_fn)GetProcAddress(g_hLib, "ClusterEnum");

    OpenClusRes_fn pfOpenClusRes = (OpenClusRes_fn)GetProcAddress(g_hLib, "OpenClusterResource");

    GetNetName_fn pfGetNetName = (GetNetName_fn)GetProcAddress(g_hLib, "GetClusterResourceNetworkName");

    ClusResCtrl_fn pfClusResCtrl = (ClusResCtrl_fn)GetProcAddress(g_hLib, "ClusterResourceControl");

 
	if (pfOpenClus == NULL     ||
		pfOpenClusNode == NULL ||
		pfClusOpenEnum == NULL ||
		pfClusEnum == NULL     ||
		pfOpenClusRes == NULL  ||
		pfGetNetName == NULL   ||
		pfClusResCtrl == NULL)
    {
        TrTRACE(GENERAL, "Failed to load cluster API functions");
        return false;
    }

	CAutoCluster hCluster( pfOpenClus(NULL) );

	if ( hCluster == NULL )
	{
		TrTRACE(GENERAL, "Failed to get handle to Cluster");
		return false;
	}

	CClusterNode hNode( pfOpenClusNode(hCluster, wzComputerName) );

	if ( hNode != NULL )
	{
		//
		// Such node exists. Local service.
		// Return default service name
		//
		HRESULT hr = StringCchCopy(s_wzServiceName, TABLE_SIZE(s_wzServiceName), xDefaultTriggersServiceName);
		if (FAILED(hr))
		{
			TrERROR(GENERAL, "Failed to retrieve trigger service name. %!hresult!", hr);
			return false;
		}
		return true;
	}

	ASSERT(("Node Open Failure", GetLastError() == ERROR_CLUSTER_NODE_NOT_FOUND));

	//
	// Enumerate resources on this cluster
	//
	DWORD dwEnumType = CLUSTER_ENUM_RESOURCE;
	CClusterEnum hEnum( pfClusOpenEnum(hCluster, dwEnumType) );

	if ( hEnum == NULL )
	{
		TrTRACE(GENERAL, "Failed to get handle to Cluster resource enumeration");
		return false;
	}

    DWORD dwIndex = 0;
    WCHAR wzResourceName[MAX_TRIGGERS_SERVICE_NAME - STRLEN(xDefaultTriggersServiceName) - 1] = {0};
	DWORD status = ERROR_SUCCESS;

	for( ; ; )
	{
        DWORD cchResourceName = STRLEN(wzResourceName);
  
		status = pfClusEnum(
                     hEnum,
                     dwIndex++,
                     &dwEnumType,
                     wzResourceName,
                     &cchResourceName
                     );

		if ( status != ERROR_SUCCESS )
		{
			return false;
		}

		CClusterResource hResource( pfOpenClusRes(hCluster, wzResourceName) );

		if ( hResource == NULL )
		{
			TrTRACE(GENERAL, "Failed to get handle to resource.");
			return false;
		}

		if ( !IsResourceMSMQTriggers( hResource, pfClusResCtrl ) )
		{
			continue;
		}

		WCHAR wzNetName[200];
		DWORD ccNetName = 200;
		BOOL res = pfGetNetName(hResource,
								wzNetName,
								&ccNetName );
		
		if ( res && ( _wcsicmp(wzComputerName, wzNetName) == 0 ) )
		{
			HRESULT hr = StringCchPrintf(
							s_wzServiceName, 
							TABLE_SIZE(s_wzServiceName), 
							L"%s$%s", 
							xDefaultTriggersServiceName,
							wzResourceName 
							);
			if (FAILED(hr))
			{
				TrERROR(GENERAL, "Failed to retreive the trigger service name. %!hresult!", hr);
				return false;
			}	
			return true;
		}		
	} 

	return false;
}


bool
FindTriggersServiceName(
	VOID
	)
/*++

Routine Description:

	Find the name of MSMQ Triggers service that is running on
	this computer. If the machine is not clustered, service name
	is default name - "MSMQTriggers". If machine is clustered and
	the service is running on virtual server, the name of the service
	is "MSMQTriggers" + "$" + MSMQ Triggers resource name on that 
	node.

Arguments:


Return Value:

    true - if succeded to find MSMQ Triggers service on this machine
	flase - otherwise

--*/

{
	HRESULT hr;
	
	if ( !IsLocalSystemCluster() )
	{
		hr = StringCchCopy(s_wzServiceName, TABLE_SIZE(s_wzServiceName), xDefaultTriggersServiceName );
		if (FAILED(hr))
		{
			TrERROR(GENERAL, "Failed to retreive the trigger service name. %!hresult!", hr);
			return false;
		}
		
		hr = StringCchCopy(s_wzTrigParamPathName, TABLE_SIZE(s_wzTrigParamPathName), REGKEY_TRIGGER_PARAMETERS );
		if (FAILED(hr))
		{
			TrERROR(GENERAL, "Failed to retreive the trigger registry path. %!hresult!", hr);
			return false;
		}
		return true;
	}

	//
	// Get service name on machine that is clustered.
	// 
	bool fRes = GetClusteredServiceName();
	if ( !fRes )
	{
		return false;
	}

	//
	// Service is running on vitual node
	//
	if ( ClusteredService(s_wzServiceName) )
	{
		hr = StringCchPrintf(
				s_wzTrigParamPathName,
				TABLE_SIZE(s_wzTrigParamPathName),
				L"%s%s%s",
				REGKEY_TRIGGER_PARAMETERS,
				REG_SUBKEY_CLUSTERED,
				s_wzServiceName
				);
		
	}
	else
	{
		hr = StringCchCopy(s_wzTrigParamPathName, TABLE_SIZE(s_wzTrigParamPathName), REGKEY_TRIGGER_PARAMETERS );
	}

	if (FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to retreive the trigger service name. %!hresult!", hr);
		return false;
	}
			
	TrTRACE(GENERAL, "The service name is %ls", s_wzServiceName);
	return true;
}


LPCWSTR
GetTriggersServiceName (
	void
	)
{
	return s_wzServiceName;
}


LPCWSTR
GetTrigParamRegPath (
	void
	)
{
	return s_wzTrigParamPathName;
}



bool
ClusteredService( 
	LPCWSTR wzServiceName 
	)
/* 
	true - if service name is not the default - "MSMQTriggers"
*/
{
	bool res = ( _wcsicmp(wzServiceName, xDefaultTriggersServiceName) != 0 );

	return res;
}


bool IsResourceOnline(
	void
	)
{
	CServiceHandle hCm( OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS) );

	if ( hCm == NULL )
	{
		ASSERT(("Cannot get handle to Service Manager.", hCm != NULL));
		return false;
	}

	//
	// Get handle to a service with the given name.
	// The service may not exist, since in cluster Offline() deletes
	// the service from the system.
	//
	CServiceHandle hService(OpenService(
                                hCm,
                                s_wzServiceName,
                                SERVICE_QUERY_STATUS
                                ));
	
	if ( hService == NULL )
	{
		ASSERT(("Access Denied", (GetLastError() == ERROR_INVALID_NAME || GetLastError() == ERROR_SERVICE_DOES_NOT_EXIST) ));
		return false;
	}

	SERVICE_STATUS ServiceStatus;
	BOOL fRes = QueryServiceStatus(hService, &ServiceStatus);
	if ( !fRes )
	{
		TrTRACE(GENERAL, "Can not get service status.");
		return false;
	}

	if ( ServiceStatus.dwCurrentState == SERVICE_RUNNING ||
		 ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING ||
		 ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING ||
		 ServiceStatus.dwCurrentState == SERVICE_PAUSED )
	{
		//
		// The proccess of the service exists
		//
		return true;
	}

	return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__1D9F85BC_9666_11D2_8927_0008C70C0622__INCLUDED_)
#define AFX_DLLDATAX_H__1D9F85BC_9666_11D2_8927_0008C70C0622__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__1D9F85BC_9666_11D2_8927_0008C70C0622__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\mqtrig_i_.c ===
#include <mqtrig_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\cpropbag.cpp ===
//*****************************************************************************
//
// Class Name  : CMSMQPropertyBag
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : Implementation of the MSMQPropertyBag COM component. This 
//               component behaves very much like the standard VB property bag
//               object. It is used to transport message properties into the 
//               IMSMQRuleHandler interface.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#include "stdafx.h"
#include "mqsymbls.h"

//
// Include the definions for standard functions and definitions.
//
#include "stdfuncs.hpp"

#include "mqtrig.h"
#include "cpropbag.hpp"

#include "cpropbag.tmh"

//*****************************************************************************
//
// Method      : InterfaceSupportsErrorInfo
//
// Description : Standard interface for error info support.
//
//*****************************************************************************
STDMETHODIMP CMSMQPropertyBag::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQPropertyBag
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//*****************************************************************************
//
// Method      : Constructor 
//
// Description : Creates an empty property bag.
//
//*****************************************************************************
CMSMQPropertyBag::CMSMQPropertyBag()
{
	m_pUnkMarshaler = NULL;
}

//*****************************************************************************
//
// Method      : Destructor
//
// Description : Destroys the property bag - and it's contents.
//
//*****************************************************************************
CMSMQPropertyBag::~CMSMQPropertyBag()
{
	PROPERTY_MAP::iterator i = m_mapPropertyMap.begin();
	VARIANT * pvStoredPropertyValue = NULL;

	while ((!m_mapPropertyMap.empty()) && (i != m_mapPropertyMap.end()) )
	{
		pvStoredPropertyValue  = (VARIANT*)(*i).second;

		VariantClear(pvStoredPropertyValue);

		// This should never be NULL
		ASSERT(pvStoredPropertyValue != NULL);

		delete pvStoredPropertyValue;
		
		i = m_mapPropertyMap.erase(i);
	}
}

//*****************************************************************************
//
// Method      : Write
//
// Description : Stores a named property value in the property bag. If a 
//               property by the same name already exists in the bag, the write
//               will fail, and this method will return E_FAIL
//
//*****************************************************************************
STDMETHODIMP CMSMQPropertyBag::Write(BSTR PropertyName, VARIANT vPropertyValue)
{
	try
	{
		ASSERT(SysStringLen(PropertyName) > 0);

		// Allocate a new variant
		//
		VARIANT * pvNewPropertyValue = new VARIANT;
	
		//
		// Initialise and copy the new variant if allocated OK
		//
		VariantInit(pvNewPropertyValue);

		HRESULT hr = VariantCopy(pvNewPropertyValue,&vPropertyValue);

		if SUCCEEDED(hr)
		{
			m_mapPropertyMap.insert(PROPERTY_MAP::value_type(PropertyName,pvNewPropertyValue));
			return S_OK;
		}

		TrERROR(GENERAL, "Failed to copy the a variant value into the property bag. Error 0x%x",hr);
		return E_FAIL;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to copy the a variant value into the property bag due to low resource.");
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//*****************************************************************************
//
// Method      : Read
//
// Description : Returns a property value from the property bad, using the 
//               supplied property name as the key.
//
//*****************************************************************************
STDMETHODIMP CMSMQPropertyBag::Read(BSTR PropertyName, VARIANT *pvPropertyValue)
{
	HRESULT hr = S_OK;
	PROPERTY_MAP::iterator i;

	// Assert parameters
	ASSERT(pvPropertyValue != NULL);
	ASSERT(SysStringLen(PropertyName) > 0);

	// Initialise the return value and temp variant
	VariantInit(pvPropertyValue);

	// Attempt to find the named queuue
	i = m_mapPropertyMap.find(PropertyName);

	if ((i == m_mapPropertyMap.end()) || (m_mapPropertyMap.empty()))
	{
		// No value found - set variant to VT_ERROR and set a failed HRESULT
		pvPropertyValue->vt = VT_ERROR;

		hr = E_FAIL;
	}
	else
	{
		// Assign the found value 
		ASSERT((*i).second != NULL);

		hr = VariantCopy(pvPropertyValue,(VARIANT*)(*i).second);
	}

	return hr;
}


//*****************************************************************************
//
// Method      : get_Count
//
// Description : Returns the number of items currently in the property bag.
//
//*****************************************************************************
STDMETHODIMP CMSMQPropertyBag::get_Count(long *pVal)
{
	ASSERT(pVal != NULL);

	(*pVal) = numeric_cast<long>(m_mapPropertyMap.size());

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by trigobjs.rc
//
#define IDR_MSMQTRIGGERSET              101
#define IDR_MSMQRULEHANDLER             102
#define IDR_IMSMQPROPERTYBAG            103
#define IDR_MSMQRULESET                 104
#define IDR_MSMQTRIGGER                 105
#define IDR_MSMQTRIGGERSCONFIG          106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\idspprxy.hpp ===
//*****************************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef CDispatchInterfaceProxy_INCLUDED 
#define CDispatchInterfaceProxy_INCLUDED

#include <windows.h> 
#include <windowsx.h> 
#include <stdarg.h>   
 
class CDispatchInterfaceProxy  
{

	private :

		IDispatch * m_pDisp;

	public:
		CDispatchInterfaceProxy();
		~CDispatchInterfaceProxy();

		HRESULT CreateObjectFromProgID(BSTR bstrProgID);
		HRESULT InvokeMethod(BSTR bstrMethodName,DISPPARAMS * pArguments, VARIANT* pvResult);

	private :

		HRESULT CreateObject(LPOLESTR pszProgID, IDispatch FAR* FAR* ppdisp) ;
		HRESULT __cdecl Invoke(LPDISPATCH pdisp,WORD wFlags,LPVARIANT pvRet,EXCEPINFO FAR* pexcepinfo,UINT FAR* pnArgErr,LPOLESTR pszName,LPCTSTR pszFmt,...);
		HRESULT CountArgsInFormat(LPCTSTR pszFmt, UINT FAR *pn); 
		LPCTSTR GetNextVarType(LPCTSTR pszFmt, VARTYPE FAR* pvt); 

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\idspprxy.cpp ===
//*****************************************************************************
//
// Class Name  : CDispatchInterfaceProxy
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : Implements a helper class that simplifies the creation of a COM 
//               component and the subsequent nvocation of a named method via the
//               IDispatch interface.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*****************************************************************************

#include "stdafx.h"
#include "idspprxy.hpp"

#include "idspprxy.tmh"

//*****************************************************************************
//
// Method      : Constructor
//
// Description : initialize an instance of the CDispatchInterfaceProxy class.
//
//*****************************************************************************
CDispatchInterfaceProxy::CDispatchInterfaceProxy()
{
	m_pDisp = NULL;
}

//*****************************************************************************
//
// Method      : Destructor
//
// Description : destroys an instance of the CDispatchInterfaceProxy class.
//
//*****************************************************************************
CDispatchInterfaceProxy::~CDispatchInterfaceProxy()
{
	// Release the IDispatch interface if we have one.
    if (m_pDisp != NULL)
	{
		m_pDisp->Release(); 
	}
}

//*****************************************************************************
//
// Method      : CreateObjectFromProgID
//
// Description : creates an instance of COM component identified by the supplied
//               prog id.
//
//*****************************************************************************
HRESULT CDispatchInterfaceProxy::CreateObjectFromProgID(BSTR bstrProgID)
{
	HRESULT hr = S_OK;

	hr = CreateObject((LPTSTR)bstrProgID,&m_pDisp); 

	// TODO - check if this method can be rationalised by calling CreateObject.

	return(hr);
}

//*****************************************************************************
//
// Method      : InvokeMethod
//
// Description : invokes a method on the current instance of the IDispatch 
//               interface. 
//
//*****************************************************************************
HRESULT CDispatchInterfaceProxy::InvokeMethod(BSTR bstrMethodName,DISPPARAMS * pArguments, VARIANT* pvResult)
{
	HRESULT hr = S_OK;
    DISPID dispid; 
	UINT uiArgErr = 0;
	EXCEPINFO ExceptionInfo;

	// ensure that we have been supplied valid parameters
	ASSERT(SysStringLen(bstrMethodName) != 0);
	ASSERT(pArguments != NULL);

    // Get DISPID of property/method 
    hr = m_pDisp->GetIDsOfNames(IID_NULL,&bstrMethodName, 1, LOCALE_USER_DEFAULT, &dispid); 

	// Inistialise exeception info structure
	ZeroMemory(&ExceptionInfo,sizeof(ExceptionInfo));
	
	// Make the call to the method.
    hr = m_pDisp->Invoke(dispid,
		                 IID_NULL,
						 LOCALE_USER_DEFAULT,
						 DISPATCH_METHOD,
						 pArguments,
						 pvResult,
						 &ExceptionInfo,
						 &uiArgErr); 


	return(hr);
}

//*****************************************************************************
//
// Method      : CreateObject
//
// Description : Creates an instances of the COM component identified by the 
//               supplied prog id, and then calls QueryInterface for an instance
//               of the IDispatch interface. Returns the IDispatch interface 
//               pointer if successfull.
//
//*****************************************************************************
HRESULT CDispatchInterfaceProxy::CreateObject(LPOLESTR pszProgID, IDispatch FAR* FAR* ppdisp) 
{ 
    CLSID clsid;                   // CLSID of automation object 
    HRESULT hr; 
    LPUNKNOWN punk = NULL;         // IUnknown of automation object 
    LPDISPATCH pdisp = NULL;       // IDispatch of automation object 
     
    *ppdisp = NULL; 
     
    // Retrieve CLSID from the progID that the user specified 
    hr = CLSIDFromProgID(pszProgID, &clsid); 
    if (FAILED(hr)) 
        goto error; 
     
    // Create an instance of the automation object and ask for the IDispatch interface 
    hr = CoCreateInstance(clsid, NULL, CLSCTX_SERVER,  
                          IID_IUnknown, (void FAR* FAR*)&punk); 
    if (FAILED(hr)) 
        goto error; 
                    
    hr = punk->QueryInterface(IID_IDispatch, (void FAR* FAR*)&pdisp); 
    if (FAILED(hr)) 
        goto error; 
 
    *ppdisp = pdisp; 
    punk->Release(); 
    return NOERROR; 
      
error: 
    if (punk) punk->Release(); 
    if (pdisp) pdisp->Release(); 
    return hr; 
}    

//*****************************************************************************
//
// Method      : Invoke 
// 
// Description : Invokes a property accessor function or method of an automation
//               object. Uses Unicode with OLE. 
// 
// Parameters   : 
//
//  pdisp         IDispatch* of automation object. 
//  wFlags        Specfies if property is to be accessed or method to be invoked. 
//                Can hold DISPATCH_PROPERTYGET, DISPATCH_PROPERTYPUT, DISPATCH_METHOD, 
//                DISPATCH_PROPERTYPUTREF or DISPATCH_PROPERTYGET|DISPATCH_METHOD.    
//  pvRet         NULL if caller excepts no result. Otherwise returns result. 
//  pexcepinfo    Returns exception info if DISP_E_EXCEPTION is returned. Can be NULL if 
//                caller is not interested in exception information.  
//  pnArgErr      If return is DISP_E_TYPEMISMATCH, this returns the index (in reverse 
//                order) of argument with incorrect type. Can be NULL if caller is not interested 
//                in this information.  
//  pszName       Name of property or method. 
//  pszFmt        Format string that describes the variable list of parameters that  
//                follows. The format string can contain the follwoing characters. 
//                & = mark the following format character as VT_BYREF  
//                b = VT_BOOL 
//                i = VT_I2 
//                I = VT_I4 
//                r = VT_R2 
//                R = VT_R4 
//                c = VT_CY  
//                s = VT_BSTR (far string pointer can be passed, BSTR will be allocated by this function). 
//                e = VT_ERROR 
//                d = VT_DATE 
//                v = VT_VARIANT. Use this to pass data types that are not described in  
//                                the format string. (For example SafeArrays). 
//                D = VT_DISPATCH 
//                U = VT_UNKNOWN 
//     
//  ...           Arguments of the property or method. Arguments are described by pszFmt.   
//               
// Return Value:
// 
//  HRESULT indicating success or failure         
// 
// Usage examples: 
// 
//  HRESULT hr;   
//  LPDISPATCH pdisp;    
//  BSTR bstr; 
//  short i; 
//  BOOL b;    
//  VARIANT v, v2; 
// 
//1. bstr = SysAllocString(OLESTR("")); 
//   hr = Invoke(pdisp, DISPATCH_METHOD, NULL, NULL, NULL, OLESTR("method1"),  
//        TEXT("bis&b&i&s"), TRUE, 2, (LPOLESTR)OLESTR("param"), (BOOL FAR*)&b, (short FAR*)&i, (BSTR FAR*)&bstr);    
// 
//2. VariantInit(&v); 
//   V_VT(&v) = VT_R8; 
//   V_R8(&v) = 12345.6789;  
//   VariantInit(&v2); 
//   hr = Invoke(pdisp, DISPATCH_METHOD, NULL, NULL, NULL, OLESTR("method2"),  
//         TEXT("v&v"), v, (VARIANT FAR*)&v2); 
//
//*****************************************************************************
HRESULT  
__cdecl
CDispatchInterfaceProxy::Invoke(
    LPDISPATCH pdisp,  
    WORD wFlags, 
    LPVARIANT pvRet, 
    EXCEPINFO FAR* pexcepinfo, 
    UINT FAR* pnArgErr,  
    LPOLESTR pszName, 
    LPCTSTR pszFmt,  
    ...
    ) 
{ 
    va_list argList; 
    va_start(argList, pszFmt);   
    DISPID dispid; 
    HRESULT hr; 
    VARIANTARG* pvarg = NULL; 
    DISPPARAMS dispparams; 
   
    if (pdisp == NULL) 
	{
        return E_INVALIDARG; 
    }

    // Get DISPID of property/method 
    hr = pdisp->GetIDsOfNames(IID_NULL, &pszName, 1, LOCALE_USER_DEFAULT, &dispid); 

    if(FAILED(hr)) 
	{
        return hr; 
    }
	
	// initialize dispparms structure
    _fmemset(&dispparams, 0, sizeof dispparams); 
 
    // determine number of arguments 
    if (pszFmt != NULL) 
	{
        CountArgsInFormat(pszFmt, &dispparams.cArgs); 
    }

    // Property puts have a named argument that represents the value that the property is 
    // being assigned. 
    DISPID dispidNamed = DISPID_PROPERTYPUT; 

    if (wFlags & DISPATCH_PROPERTYPUT) 
    { 
        if (dispparams.cArgs == 0) 
            return E_INVALIDARG; 
        dispparams.cNamedArgs = 1; 
        dispparams.rgdispidNamedArgs = &dispidNamed; 
    } 
 
    if (dispparams.cArgs != 0) 
    { 
        // allocate memory for all VARIANTARG parameters 
        pvarg = new VARIANTARG[dispparams.cArgs]; 

        if(pvarg == NULL) 
		{
            return E_OUTOFMEMORY;    
		}

        dispparams.rgvarg = pvarg; 

        _fmemset(pvarg, 0, sizeof(VARIANTARG) * dispparams.cArgs); 
 
        // get ready to walk vararg list 
        LPCTSTR psz = pszFmt; 
        pvarg += dispparams.cArgs - 1;   // params go in opposite order 
         
        psz = GetNextVarType(psz, &pvarg->vt);
        while (psz) 
        { 
            if (pvarg < dispparams.rgvarg) 
            { 
                hr = E_INVALIDARG; 
                goto cleanup;   
            } 
            switch (pvarg->vt) 
            { 
            case VT_I2: 
                V_I2(pvarg) = va_arg(argList, short); 
                break; 
            case VT_I4: 
                V_I4(pvarg) = va_arg(argList, long); 
                break; 
            case VT_R4: 
                V_R4(pvarg) = va_arg(argList, float); 
                break;  
            case VT_DATE: 
            case VT_R8: 
                V_R8(pvarg) = va_arg(argList, double); 
                break; 
            case VT_CY: 
                V_CY(pvarg) = va_arg(argList, CY); 
                break; 
            case VT_BSTR: 
                V_BSTR(pvarg) = SysAllocString(va_arg(argList, OLECHAR FAR*)); 
                if (pvarg->bstrVal == NULL)  
                { 
                    hr = E_OUTOFMEMORY;   
                    pvarg->vt = VT_EMPTY; 
                    goto cleanup;   
                } 
                break; 
            case VT_DISPATCH: 
                V_DISPATCH(pvarg) = va_arg(argList, LPDISPATCH); 
                break; 
            case VT_ERROR: 
                V_ERROR(pvarg) = va_arg(argList, SCODE); 
                break; 
            case VT_BOOL: 
                V_BOOL(pvarg) = (VARIANT_BOOL)(va_arg(argList, BOOL) ? -1 : 0); 
                break; 
            case VT_VARIANT: 
                *pvarg = va_arg(argList, VARIANTARG);  
                break; 
            case VT_UNKNOWN: 
                V_UNKNOWN(pvarg) = va_arg(argList, LPUNKNOWN); 
                break; 
 
            case VT_I2|VT_BYREF: 
                V_I2REF(pvarg) = va_arg(argList, short FAR*); 
                break; 
            case VT_I4|VT_BYREF: 
                V_I4REF(pvarg) = va_arg(argList, long FAR*); 
                break; 
            case VT_R4|VT_BYREF: 
                V_R4REF(pvarg) = va_arg(argList, float FAR*); 
                break; 
            case VT_R8|VT_BYREF: 
                V_R8REF(pvarg) = va_arg(argList, double FAR*); 
                break; 
            case VT_DATE|VT_BYREF: 
                V_DATEREF(pvarg) = va_arg(argList, DATE FAR*); 
                break; 
            case VT_CY|VT_BYREF: 
                V_CYREF(pvarg) = va_arg(argList, CY FAR*); 
                break; 
            case VT_BSTR|VT_BYREF: 
                V_BSTRREF(pvarg) = va_arg(argList, BSTR FAR*); 
                break; 
            case VT_DISPATCH|VT_BYREF: 
                V_DISPATCHREF(pvarg) = va_arg(argList, LPDISPATCH FAR*); 
                break; 
            case VT_ERROR|VT_BYREF: 
                V_ERRORREF(pvarg) = va_arg(argList, SCODE FAR*); 
                break; 
            case VT_BOOL|VT_BYREF:  
                { 
                    BOOL FAR* pbool = va_arg(argList, BOOL FAR*); 
                    *pbool = 0; 
                    V_BOOLREF(pvarg) = (VARIANT_BOOL FAR*)pbool; 
                }  
                break;               
            case VT_VARIANT|VT_BYREF:  
                V_VARIANTREF(pvarg) = va_arg(argList, VARIANTARG FAR*); 
                break; 
            case VT_UNKNOWN|VT_BYREF: 
                V_UNKNOWNREF(pvarg) = va_arg(argList, LPUNKNOWN FAR*); 
                break; 
 
            default: 
                { 
                    hr = E_INVALIDARG; 
                    goto cleanup;   
                } 
                break; 
            } 
 
            --pvarg; // get ready to fill next argument 
            psz = GetNextVarType(psz, &pvarg->vt);
        } //while 
    } //if 
     
    // Initialize return variant, in case caller forgot. Caller can pass NULL if return 
    // value is not expected. 
    if (pvRet) 
	{
        VariantInit(pvRet);  
	}

    // make the call  
    hr = pdisp->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, wFlags,&dispparams, pvRet, pexcepinfo, pnArgErr); 
 
cleanup: 

    // cleanup any arguments that need cleanup 
    if (dispparams.cArgs != 0) 
    { 
        pvarg = dispparams.rgvarg; 
        UINT cArgs = dispparams.cArgs;    
         
        while (cArgs--) 
        { 
            switch (pvarg->vt) 
            { 
            case VT_BSTR: 
                VariantClear(pvarg); 
                break; 
            } 
            ++pvarg; 
        } 
    } 

    delete dispparams.rgvarg; 

    va_end(argList); 

    return hr;    
}    

//*****************************************************************************
//
// Method      : CountArgsInFormat
//
// Description : returns the number of arguments found in the supplied format 
//               string. See the definition of the Invoke() method for the 
//               definition of this format string.
//
//*****************************************************************************
HRESULT CDispatchInterfaceProxy::CountArgsInFormat(LPCTSTR pszFmt, UINT FAR *pn) 
{ 
    *pn = 0; 
 
    if(pszFmt == NULL) 
      return NOERROR; 
     
    while (*pszFmt)   
    { 
       if (*pszFmt == '&') 
           pszFmt++; 
 
       switch(*pszFmt) 
       { 
           case 'b': 
           case 'i':  
           case 'I': 
           case 'r':  
           case 'R': 
           case 'c': 
           case 's': 
           case 'e': 
           case 'd': 
           case 'v': 
           case 'D': 
           case 'U': 
               ++*pn;  
               pszFmt++; 
               break; 
           case '\0':   
           default: 
               return E_INVALIDARG;    
        } 
    } 
    return NOERROR; 
} 

 
//*****************************************************************************
//
// Method      : GetNextVarType
//
// Description : returns a pointer to the next variable-type declaration in 
//               the supplied format string. 
//
//*****************************************************************************
LPCTSTR CDispatchInterfaceProxy::GetNextVarType(LPCTSTR pszFmt, VARTYPE FAR* pvt) 
{    

    *pvt = 0; 
    if (*pszFmt == '&')  
    { 
         *pvt = VT_BYREF;  
         pszFmt++;     
         if (!*pszFmt) 
             return NULL;     
    }  
    switch(*pszFmt) 
    { 
        case 'b': 
            *pvt |= VT_BOOL; 
            break; 
        case 'i':  
            *pvt |= VT_I2; 
            break; 
        case 'I':  
            *pvt |= VT_I4; 
            break; 
        case 'r':  
            *pvt |= VT_R4; 
            break; 
        case 'R':  
            *pvt |= VT_R8; 
            break; 
        case 'c': 
            *pvt |= VT_CY; 
            break; 
        case 's':  
            *pvt |= VT_BSTR; 
            break; 
        case 'e':  
            *pvt |= VT_ERROR; 
            break; 
        case 'd':  
            *pvt |= VT_DATE;  
            break; 
        case 'v':  
            *pvt |= VT_VARIANT; 
            break; 
        case 'U':  
            *pvt |= VT_UNKNOWN;  
            break; 
        case 'D':  
            *pvt |= VT_DISPATCH; 
            break;   
        case '\0': 
             return NULL;     // End of Format string 
        default: 
            return NULL; 
    }  
    return ++pszFmt;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\rulehdlr.cpp ===
//************************************************************************************
//
// Class Name  : CMSMQRuleHandler
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class represents the generic rule handling 
//               component. This component interprets the condition
//               and action strings for a particular rule - and peforms
//               the appropriate actions. 
//
//               This class is exposed as a COM component with the 
//               progid "MSMQTriggerObjects.MSMQRuleHandler". This 
//               is the default rule handling component instantiated 
//               by the MSMQ Trigger Service.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 20/12/98 | jsimpson  | Initial Release
//
//************************************************************************************
#include "stdafx.h"

//
// Include the definions for standard functions and definitions.
//
#include "stdfuncs.hpp"

//
// Definitions of the return codes used by these object
//
#include "mqexception.h"
#include "mqtrig.h"
#include "rulehdlr.hpp"
#include "mqsymbls.h"


// Include the standard definitions used throughout the triggers projects and components.
#include "stddefs.hpp"
#include "mqtg.h"

// Include the test functions
#include "TriggerTest.hpp"

#include "rulehdlr.tmh"

//************************************************************************************
//
// Method      : InterfaceSupportsErrorInfo
//
// Description : Standard rich error info interface method - built by wizard.
//
//************************************************************************************
STDMETHODIMP CMSMQRuleHandler::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQRuleHandler
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//************************************************************************************
//
// Method      : Constructor
//
// Description : Invoked when a rule handler object is created. 
//
//************************************************************************************
CMSMQRuleHandler::CMSMQRuleHandler()
{
	m_pUnkMarshaler = NULL;

	// Initialise member variables.
	m_bstrCondition = _T("");
	m_bstrAction  = _T("");
	m_fIsSerializedQueue = false;
	m_fShowWindow = false;
}

//************************************************************************************
//
// Method      : Destructor
//
// Description : Invoked when a rule handler object is destroyed.
//
//************************************************************************************
CMSMQRuleHandler::~CMSMQRuleHandler()
{
	TrTRACE(GENERAL, "Destroy rule handle for rule: %ls", static_cast<LPCWSTR>(m_bstrRuleID));
}

//************************************************************************************
//
// Method      : Init
//
// Description : This method is called by the MSMQ Trigger Service once after the 
//               rule handler component has been created. This calling of this method 
//               gives the rule handle the opportunity to perform once-off initializations
//               and resource allocations. The main steps performed during this call are :
//
//               (1) Create an instance of the logging class.
//               (2) Initialize member vars with supplied initialization parms.
//               (3) Parse the rule condition string.
//               (4) Parse the rule action string
//
//************************************************************************************
STDMETHODIMP CMSMQRuleHandler::Init(
								BSTR bstrRuleID,
								BSTR sRuleCondition,
								BSTR sRuleAction,
								BOOL fShowWindow )
{
	TrTRACE(GENERAL, "Init CMSMQRuleHandler for Rule: %ls. Condition string: %ls,  Action string %ls", static_cast<LPCWSTR>(bstrRuleID), static_cast<LPCWSTR>(sRuleCondition), static_cast<LPCWSTR>(sRuleAction));

	//
	// Store the condition and action strings and the queue handle.
	//
	m_bstrRuleID = bstrRuleID;
	m_bstrCondition = sRuleCondition;
	m_bstrAction = sRuleAction;
	m_fShowWindow = (fShowWindow != FALSE);
    m_RulesProcessingStatus = RULES_PROCESSING_CONTINUE;
	 
	//
	// Parse the condition strings
	//
	try
	{
		m_tokCondition.Parse(sRuleCondition, xConditionDelimiter);
	}
	catch(const exception&)
	{
		TrERROR(GENERAL, "Failed to parse rule condition: %ls for rule: %ls", (LPCWSTR)m_bstrCondition, (LPCWSTR)m_bstrRuleID);
		
		SetComClassError(MQTRIG_ERROR_INVALID_RULE_CONDITION_PARAMETER);
		return MQTRIG_ERROR_INVALID_RULE_CONDITION_PARAMETER;
	}

	//
	// Parse the action string
	//
	try
	{
		m_tokAction.Parse(sRuleAction, xActionDelimiter);
	}
	catch(const exception&)
	{
		TrERROR(GENERAL, "Failed to parse rule action: %ls for rule: %ls", (LPCWSTR)m_bstrAction, (LPCWSTR)m_bstrRuleID);
		
		SetComClassError(MQTRIG_ERROR_INVALID_RULE_ACTION_PARAMETER);
		return MQTRIG_ERROR_INVALID_RULE_ACTION_PARAMETER;
	}

    //
	// ISSUE-2000/10/29-urih - perform extra validation on the token set here.
	//

	return S_OK;
}

//************************************************************************************
//
// Method      : CheckRuleCondition
//
// Description : This method is called by the MSMQ Trigger Service every time a msg 
//               arrives on queue that has a trigger attached to it. This method is 
//               evalutate the rule condition
//               
// 
// Parameters   :
//               [in] pIMSMQPropertyBag 
//
//               This is an interface pointer to an instance of the MSMQ property bag 
//			     COM object. This component holds the message properties of the message
//               that has just arrived on a monitorred queue. Using this interface pointer
//               the rule-handler can access the message property values without actually
//               having to visit the queue.
//
//               [out] pbConditionSatisfied 
//
//               This value is used to pass information back to the MSMQ Trigger Service. 
//               Currently it is used to communicate if the rule-condition was satisfied
//               and if the rule-action executed successfully.
//
//************************************************************************************
STDMETHODIMP 
CMSMQRuleHandler::CheckRuleCondition(
	IMSMQPropertyBag * pIMSMQPropertyBag, 
	BOOL *pbConditionSatisfied
	)
{
	TrTRACE(GENERAL, "Rule %ls is tested.", static_cast<LPCWSTR>(m_bstrRuleID));
    *pbConditionSatisfied = false;
	
	//
	// Check if we have a valid property bag object
	//
	if (pIMSMQPropertyBag == NULL)
	{
		TrERROR(GENERAL, "Rule %ls has been invoked with empty property bag. Rule handling cannot be processed.", (LPCWSTR)m_bstrRuleID);

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}



	//
	// Test if the rule condition is satisfied. Note that the HRESULT from this call does not indicate if 
	// condition has been satisfied - instead it indicates if we could perform the evaluation correctly.
	//
    IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);
	
	HRESULT hr = RuleConditionSatisfied(pIPropertyBag.GetInterfacePtr(),pbConditionSatisfied);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "Invalid rule condition %ls for rule %ls. Failed to evaluate the condition.", (LPCWSTR)m_bstrRuleID, (LPCWSTR)m_bstrCondition);
	
		SetComClassError(MQTRIG_ERROR_INVALID_RULE_CONDITION_PARAMETER);
		return MQTRIG_ERROR_INVALID_RULE_CONDITION_PARAMETER;
	}

	if (!(*pbConditionSatisfied))
	{
		TrTRACE(GENERAL, "Rule condition for rule: %ls wasn't satisfied. Continue ...", static_cast<LPCWSTR>(m_bstrRuleID));
	}

	return S_OK;
}


//************************************************************************************
//
// Method      : ExecuteRule
//
// Description : This method is called by the MSMQ Trigger Service every time a msg 
//               arrives on queue that has a trigger attached to it and
//               the condition was true.
// 
// Parameters   :
//               [in] pIMSMQPropertyBag 
//
//               This is an interface pointer to an instance of the MSMQ property bag 
//			     COM object. This component holds the message properties of the message
//               that has just arrived on a monitorred queue. Using this interface pointer
//               the rule-handler can access the message property values without actually
//               having to visit the queue.
//
//               [in] fIsSerializedQueue
//               Indicates if the queue is serialized
//
//               [out] pRuleProcessingStatus 
//
//               This value is used to pass information back to the MSMQ Trigger Service. 
//               Indicates if next rule should be executed
//
//************************************************************************************
STDMETHODIMP 
CMSMQRuleHandler::ExecuteRule(
	IMSMQPropertyBag * pIMSMQPropertyBag, 
	BOOL fIsSerializedQueue, 
	LONG* plRuleResult
	)
{
	TrTRACE(GENERAL, "Rule %ls action is executed.", static_cast<LPCWSTR>(m_bstrRuleID));

	m_fIsSerializedQueue = (fIsSerializedQueue != FALSE);
	
	if (pIMSMQPropertyBag == NULL)
	{
		TrERROR(GENERAL, "Rule %ls has been invoked with empty property bag. Rule handling cannot be processed.", (LPCWSTR)m_bstrRuleID);

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

    *plRuleResult = 0;

	HRESULT hr = ExecuteRuleAction(pIMSMQPropertyBag); 

    if (FAILED(hr))
	{
		*plRuleResult |= xRuleResultActionExecutedFailed;
	    SetComClassError(hr);
        return hr;
	}
 

    if (m_RulesProcessingStatus == RULES_PROCESSING_STOP)
    {
        *plRuleResult |= xRuleResultStopProcessing;
    }
	return S_OK;
}



//************************************************************************************
//
// Method      : RuleConditionSatisfied
//
// Description : Returns true or false (in the form of an out parameter) depending on
//               whether the rule condition is satisfied given the message properties
//               supplied in the MSMQPropertyBag COM object instance (pIMSMQPropertyBag)
//
//************************************************************************************
HRESULT CMSMQRuleHandler::RuleConditionSatisfied(IMSMQPropertyBag * pIMSMQPropertyBag,BOOL * pbConditionSatisfied)
{
	HRESULT hr = S_OK;
	ULONG ulNumTokens = 0 ;
	ULONG ulTokenCtr = 0;
	_bstr_t bstrToken = _T("");
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);

	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);

	// Assume that the group of conditions is satsified - quit loop if proved otherwise.
	(*pbConditionSatisfied) = true;

	// get the number of condition tokens
	ulNumTokens = m_tokCondition.GetNumTokens();

	// If the number of tokens in the condition string is 0, then rule should be fired.
	if (ulNumTokens < 1)
	{
		return(hr);
	}

	// Test each condition token
	while ((ulTokenCtr <= (ulNumTokens - 1))  && (SUCCEEDED(hr)) )
	{
		_bstr_t bstrToken;

		// Get the next token 
		m_tokCondition.GetToken(ulTokenCtr, bstrToken);
		
		hr = EvaluateConditionToken(
				pIPropertyBag.GetInterfacePtr(),
				bstrToken,
				pbConditionSatisfied
				);
		
		if ((*pbConditionSatisfied) == false)
		{ 
			break;
		}

		// Process the next condition token
		ulTokenCtr++;
	}

	return(hr);
} 

//************************************************************************************
//
// Method      : EvaluateConditionToken
//
// Description : A rule condition can be made up of multiple condition tokens. This
//               method is used to determine if a single condition token is true or 
//               false. 
//
//               This method currently supports the following conditional tests:
//
//               (1) Message label contains a specific (literal) string
//               (2) Message Prioriry is at least a specific (literal) value.
//
//************************************************************************************
HRESULT CMSMQRuleHandler::EvaluateConditionToken(IMSMQPropertyBag * pIMSMQPropertyBag, _bstr_t bstrConditionToken,BOOL * pbConditionSatisfied)
{
	_bstr_t bstrToken = _T("");
	_bstr_t bstrTokenValue = _T("");
	CStringTokens spConditionTokenParser;
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);
	HRESULT hr;

	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);

	// Initialise property value variant
	VARIANT vPropertyValue;
	VariantInit(&vPropertyValue);

	// Assume that this individual condition is false - and try to prove otherwise.
	(*pbConditionSatisfied) = false;

	try
	{
		// Parse the conditional expression
		spConditionTokenParser.Parse(bstrConditionToken, xConditionValueDelimiter);
		spConditionTokenParser.GetToken(0,bstrToken);

		// Depending on which token it is - apply a different test.
		if ((_wcsicmp(bstrToken, g_ConditionTag_MsgLabelContains) == 0) ||
			(_wcsicmp(bstrToken, g_ConditionTag_MsgLabelDoesNotContain) == 0))
		{		
			spConditionTokenParser.GetToken(1,bstrTokenValue);

			// Get the message label from the property bag.
			pIPropertyBag->Read(_bstr_t(g_PropertyName_Label),&vPropertyValue);

			_bstr_t bstrLabel = vPropertyValue;
		
			TCHAR* ptcs = _tcsstr((wchar_t*)bstrLabel,(wchar_t*)bstrTokenValue);

			if(_wcsicmp(bstrToken, g_ConditionTag_MsgLabelContains) == 0)
			{
				(*pbConditionSatisfied) = (ptcs != NULL);
			}
			else //gc_bstrConditionTag_MsgLabelDoesNotContain
			{
				(*pbConditionSatisfied) = (ptcs == NULL);
			}

			// Clear property value variant
			hr = VariantClear(&vPropertyValue);
			ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));
			
			return S_OK;
		}
		
		
		if ((_wcsicmp(bstrToken, g_ConditionTag_MsgBodyContains) == 0) ||
			(_wcsicmp(bstrToken, g_ConditionTag_MsgBodyDoesNotContain) == 0))
		{		
			spConditionTokenParser.GetToken(1,bstrTokenValue);

			pIPropertyBag->Read(_bstr_t(g_PropertyName_MsgBodyType),&vPropertyValue);

			DWORD dwBodyType = vPropertyValue.ulVal;

			switch (dwBodyType) 
			{
				case VT_EMPTY:
					*pbConditionSatisfied = (_wcsicmp(bstrToken, g_ConditionTag_MsgBodyDoesNotContain) == 0);
					break;

				case VT_BSTR: 
				case VT_LPWSTR:
				{
					// Get the message Body from the property bag.
					pIPropertyBag->Read(_bstr_t(g_PropertyName_MsgBody),&vPropertyValue);

					_bstr_t bstrBody = vPropertyValue;

					TCHAR* ptcs = NULL;

					// We don't want to use _tcsstr if bstrBody.m_Data is NULL. If it NULL
					// then the TokenValue does not exist in it so ptcs = NULL;
					if (bstrBody.length()!=0)
					{
						ptcs = _tcsstr((wchar_t*)bstrBody,(wchar_t*)bstrTokenValue);
					}

					if(_wcsicmp(bstrToken, g_ConditionTag_MsgBodyContains) == 0)
					{
						(*pbConditionSatisfied) = (ptcs != NULL);
					}
					else //gc_bstrConditionTag_MsgBodyDoesNotContain
					{
						(*pbConditionSatisfied) = (ptcs == NULL);
					}
					break;
				}
				case VT_ARRAY|VT_UI1:
				{
					// Get the message Body from the property bag.
					pIPropertyBag->Read(_bstr_t(g_PropertyName_MsgBody),&vPropertyValue);

					_bstr_t bstrBody = vPropertyValue;
					
					(*pbConditionSatisfied) = ((bstrBody.length() == 0) && (_wcsicmp(bstrToken, g_ConditionTag_MsgBodyDoesNotContain) == 0));
					break;
				}
				default:
					break;
			}

			// Clear property value variant
			hr = VariantClear(&vPropertyValue);
			ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));
			
			return S_OK;
		}


		if  ((_wcsicmp(bstrToken, g_ConditionTag_MsgPriorityGreaterThan) == 0) ||
			(_wcsicmp(bstrToken, g_ConditionTag_MsgPriorityLessThan) == 0) ||
			(_wcsicmp(bstrToken, g_ConditionTag_MsgPriorityEquals) == 0) ||
			(_wcsicmp(bstrToken, g_ConditionTag_MsgPriorityNotEqual) == 0))
		{
			spConditionTokenParser.GetToken(1, bstrTokenValue);

			// Get the message label from the property bag.
			pIPropertyBag->Read(_bstr_t(g_PropertyName_MsgPriority),&vPropertyValue);

			long lActualMsgPriority = vPropertyValue.lVal;
			long lRequirdMsgPriority = _wtol((wchar_t*)bstrTokenValue);

			if(_wcsicmp(bstrToken, g_ConditionTag_MsgPriorityEquals) == 0)
			{
					(*pbConditionSatisfied) = (lRequirdMsgPriority == lActualMsgPriority);
			}
			else if(_wcsicmp(bstrToken, g_ConditionTag_MsgPriorityNotEqual) == 0)
			{
					(*pbConditionSatisfied) = (lRequirdMsgPriority != lActualMsgPriority);
			}
			else if(_wcsicmp(bstrToken, g_ConditionTag_MsgPriorityGreaterThan) == 0)
			{
				(*pbConditionSatisfied) = (lRequirdMsgPriority < lActualMsgPriority);
			}
			else //gc_bstrConditionTag_MsgPriorityLessThan
			{
				(*pbConditionSatisfied) = (lRequirdMsgPriority > lActualMsgPriority);
			}
			
			// Clear property value variant
			hr = VariantClear(&vPropertyValue);
			ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));

			return S_OK;
		}

		if ((_wcsicmp(bstrToken, g_ConditionTag_MsgAppSpecificGreaterThan) == 0) ||
			(_wcsicmp(bstrToken, g_ConditionTag_MsgAppSpecificLessThan) == 0) ||
			(_wcsicmp(bstrToken, g_ConditionTag_MsgAppSpecificEquals) == 0) ||
			(_wcsicmp(bstrToken, g_ConditionTag_MsgAppSpecificNotEqual) == 0)) 
		{
			TCHAR* pEnd = NULL;
			spConditionTokenParser.GetToken(1, bstrTokenValue);

			// Get the message label from the property bag.
			pIPropertyBag->Read(_bstr_t(g_PropertyName_AppSpecific),&vPropertyValue);

			ULONG ulAppSpecific = vPropertyValue.ulVal;
			ULONG ulRequiredAppSpecific = _tcstoul((wchar_t*)bstrTokenValue, &pEnd, 10);


			if(_wcsicmp(bstrToken, g_ConditionTag_MsgAppSpecificEquals) == 0)
			{
					(*pbConditionSatisfied) = (ulRequiredAppSpecific == ulAppSpecific);
			}
			else if(_wcsicmp(bstrToken, g_ConditionTag_MsgAppSpecificNotEqual) == 0)
			{
					(*pbConditionSatisfied) = (ulRequiredAppSpecific != ulAppSpecific);
			}
			else if(_wcsicmp(bstrToken, g_ConditionTag_MsgAppSpecificGreaterThan) == 0)
			{
				(*pbConditionSatisfied) = (ulRequiredAppSpecific < ulAppSpecific);
			}
			else //gc_bstrConditionTag_MsgAppSpecificLessThan
			{
				(*pbConditionSatisfied) = (ulRequiredAppSpecific > ulAppSpecific);
			}
			
			// Clear property value variant
			hr = VariantClear(&vPropertyValue);
			ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));

			return S_OK;
		}

		if ((_wcsicmp(bstrToken, g_ConditionTag_MsgSrcMachineIdEquals) == 0) ||
			(_wcsicmp(bstrToken, g_ConditionTag_MsgSrcMachineIdNotEqual) == 0))
		{
			spConditionTokenParser.GetToken(1, bstrTokenValue);

			// Get the message label from the property bag.
			pIPropertyBag->Read(_bstr_t(g_PropertyName_SrcMachineId), &vPropertyValue);

			_bstr_t bstrSrcMachineId = vPropertyValue;
		
			int ret = _tcsicmp((wchar_t*)bstrSrcMachineId,(wchar_t*)bstrTokenValue);

			if(_wcsicmp(bstrToken, g_ConditionTag_MsgSrcMachineIdEquals) == 0)
			{
				(*pbConditionSatisfied) = (ret == 0);
			}
			else //gc_bstrConditionTag_MsgSrcMachineIdNotEqual
			{
				(*pbConditionSatisfied) = (ret != 0);
			}
			
			// Clear property value variant
			hr = VariantClear(&vPropertyValue);
			ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));
			
			return S_OK;
		}

		// Clear property value variant
		hr = VariantClear(&vPropertyValue);
		ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));
		UNREFERENCED_PARAMETER(hr);

		
		return MQTRIG_ERROR_INVALID_RULE_CONDITION_PARAMETER;
	}
	catch( const exception&)
	{
		// Clear property value variant
		hr = VariantClear(&vPropertyValue);
		ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));

		TrERROR(GENERAL, "Failed to parse rule condition: %ls for rule: %ls", (LPCWSTR)m_bstrCondition, (LPCWSTR)m_bstrRuleID);
		return MQTRIG_ERROR_INVALID_RULE_CONDITION_PARAMETER;
	}
}

//************************************************************************************
//
// Method      : ExecuteRuleAction
//
// Description : This method executes the action component of a rule. It is called only
//               if the rule-condition was evaluated as true. 
//
//               Currently this method supports two broad action types:
//
//               (1) The invocation of a COM component.
//               (2) The invocation of a stand-alone executable.
//
//************************************************************************************
HRESULT CMSMQRuleHandler::ExecuteRuleAction(IMSMQPropertyBag * pIMSMQPropertyBag)
{
	_bstr_t bstrToken = _T("");
	
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);

	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);

	// Get the executable type token
	m_tokAction.GetToken(ACTION_EXECUTABLETYPE_ORDINAL, bstrToken);


	// If we are invoking a COM component - then attempt to crea
	if (bstrToken == _bstr_t(xCOMAction))
	{
		return InvokeCOMComponent(pIPropertyBag.GetInterfacePtr());
	}

	if (bstrToken == _bstr_t(xEXEAction))
	{
		return InvokeEXE(pIPropertyBag.GetInterfacePtr());
	}

	TrERROR(GENERAL, "Failed to parse rule action: %ls for rule: %ls", (LPCWSTR)m_bstrAction, (LPCWSTR)m_bstrRuleID);
	return MQTRIG_ERROR_INVALID_RULE_ACTION_PARAMETER;
}

//************************************************************************************
//
// Method      : InvokeCOMComponent
//
// Description : This method will invoked the COM component specific in the rule's 
//               action string. There are 4 steps required to do this:
//
//                (1) Create the COM component identified in the action string,
//
//                (2) Prepare the array of parameters that will be passed to this 
//                    component instance, based on the rule-action definition,
//
//                (3) Execute the method identified in the rule-action string, passing
//                    the prepared parameter array,
//
//                (4) Clean up the dynamically allocated parameter array.
//
//************************************************************************************
HRESULT CMSMQRuleHandler::InvokeCOMComponent(IMSMQPropertyBag * pIMSMQPropertyBag)
{
	HRESULT hr = S_OK;
	DISPPARAMS disparms;
	_bstr_t bstrProgID = _T("");
	_bstr_t bstrMethodName = _T("");
	
	// in test mode will hold all relevant information about the action and it's parameters
	// when finished adding data it it, it will be sent to the "TriggersTestQueue" queue

	_bstr_t bstrTestMessageBody= _T("");

	CDispatchInterfaceProxy oObject;
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);
	
	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);

	try
	{
		// Get the ProgID of the custom component we are to create. 
		m_tokAction.GetToken(ACTION_COMPROGID_ORDINAL, bstrProgID);
		m_tokAction.GetToken(ACTION_COMMETHODNAME_ORDINAL, bstrMethodName);			
	
		hr = oObject.CreateObjectFromProgID(bstrProgID);
		if FAILED(hr)
		{
			TrERROR(GENERAL, "Failed to create the COM component with the ProgID %ls for rule %ls. Error 0x%x.", (LPCWSTR)bstrProgID, (LPCWSTR)m_bstrRuleID, hr);
			return MQTRIG_ERROR_CREATE_COM_OBJECT;
		}

		//
		// add the trigger ID, RuleID, MessageID, "COM", prog ID and the method name to test message body
		//
		TriggerTestInitMessageBody(&bstrTestMessageBody,pIMSMQPropertyBag,m_bstrRuleID,L"COM",L"",bstrProgID,bstrMethodName);

		//
		// For testing puposes, the bstrTestMessageBody parameter is added to this method
		//
		PrepareMethodParameters(pIPropertyBag.GetInterfacePtr(),&disparms,&bstrTestMessageBody);

        VARIANT vResult;
        VariantInit(&vResult);

		hr = oObject.InvokeMethod(bstrMethodName,&disparms, &vResult);
		if FAILED(hr)
		{
			ReleaseMethodParameters(&disparms);

			TrERROR(GENERAL, "Failed to invoke the method %ls of COM component with ProgID %ls for rule %ls. rule action: %ls. Error 0x%x", (LPCWSTR)bstrMethodName,(LPCWSTR)bstrProgID, (LPCWSTR)m_bstrRuleID, (LPCWSTR)m_bstrAction, hr);
			return MQTRIG_ERROR_INVOKE_COM_OBJECT;
		}

		//
		// send the action & parameters to the test queue
		//
		TriggerTestSendTestingMessage(bstrTestMessageBody);                


		if(vResult.vt == VT_I4)
        {
			m_RulesProcessingStatus = (vResult.lVal == 0) ? RULES_PROCESSING_CONTINUE : RULES_PROCESSING_STOP;
        }

		//
		// Clean up the allocated method parameter
		ReleaseMethodParameters(&disparms);
		return S_OK;
	}
	catch(const _com_error& e)
	{
		TrERROR(GENERAL, "The custome COM component for rule %ls throw an exception. Error 0x%x, Description: %s", m_bstrRuleID, e.Error(), e.Description());
		return MQTRIG_ERROR_INVOKE_COM_OBJECT;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to invoke COM component for rule: %ls, due to insufficient resource", (LPCWSTR)m_bstrRuleID);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
	catch(const exception&)
	{
		TrERROR(GENERAL, "Failed to parse rule action: %ls for rule: %ls. Can't retrieve method name", (LPCWSTR)m_bstrAction, (LPCWSTR)m_bstrRuleID);
		return MQTRIG_ERROR_INVALID_RULE_ACTION_PARAMETER;
	}
}

//************************************************************************************
//
// Method      : InvokeEXE
//
// Description : Controls the invocation of a standalone executable. This method will 
//               control the formatted of the parameters command line to be passed to 
//               the EXE, and it will create the new process.
//
//************************************************************************************
HRESULT CMSMQRuleHandler::InvokeEXE(IMSMQPropertyBag * pIMSMQPropertyBag)
{
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	
	// in test mode will hold all relevant information about the action and it's parameters
	// when finished adding data it it, it will be sent to the "TriggersTestQueue" queue

	_bstr_t bstrTestMessageBody= _T("");
	
	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);

	// Initialize the startup info an process information structures
	ZeroMemory(&si,sizeof(si));
	ZeroMemory(&pi,sizeof(pi));

	si.cb = sizeof(si);
	si.dwFlags = STARTF_USESHOWWINDOW;
	si.wShowWindow = (VARIANT_BOOL)(m_fShowWindow ? SW_SHOW : SW_HIDE);

	// Build the command line we will pass to the EXE
	// For testing puposes, the bstrTestMessageBody parameter is added to this method
	_bstr_t bstrExeName;
	_bstr_t bstrCommandLine;

	HRESULT hr = PrepareEXECommandLine(pIPropertyBag, &bstrExeName, &bstrCommandLine, &bstrTestMessageBody); 

	if (FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to prepare the parameter structure for calling the standalone executable, for rule %ls. Error 0x%x", (LPCWSTR)m_bstrRuleID, hr);
		return MQTRIG_ERROR_INVOKE_EXE;
	}

	TrTRACE(GENERAL, "Invoke EXE for rule %ls with command line %ls", static_cast<LPCWSTR>(m_bstrRuleID), static_cast<LPCWSTR>(bstrCommandLine));

	// Create the new process
	// Note: bstrCommandLine contains the exeName as the first token.
	// We want argv[0] to be the application name
	if(CreateProcess(bstrExeName,				  // Name of the EXE 
					 bstrCommandLine,             // Parameters being passed to EXE
					 NULL,                        // Process security (default)
					 NULL,                        // Thread security (default)
					 FALSE,                       // Do not inherit handles 
					 NULL, //DETACHED_PROCESS     // Creation flags
					 NULL,                        // Use current environment
					 NULL,                        // Use current directory
					 &si,                         // Startup info structure
					 &pi) == FALSE)               // Returned process info
	{
		//
		// The create process failed, log an error
		//
		TrERROR(GENERAL, "Failed to invoke a standalone executable, for rule %ls. Error 0x%x", (LPCWSTR)m_bstrRuleID, GetLastError());
		return MQTRIG_ERROR_INVOKE_EXE;
	}

	CloseHandle(pi.hThread);

	//
	// send the action & parameters to the test queue
	//
	TriggerTestSendTestingMessage(bstrTestMessageBody);

	if(m_fIsSerializedQueue)
	{
		DWORD dwStatus = WaitForSingleObject(pi.hProcess, INFINITE);
		ASSERT(dwStatus == WAIT_OBJECT_0); //WAIT_TIMEOUT is not possible here since timeout is infinite
		DBG_USED(dwStatus);
	}

	CloseHandle(pi.hProcess);

	return S_OK;
}

inline void VariantArrayClear(VARIANTARG* p, int size)
{
	for (int i = 0; i < size; ++i)
	{
		HRESULT hr = VariantClear(&p[i]);		
		ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));	
		UNREFERENCED_PARAMETER(hr);	
	}
}


//************************************************************************************
//
// Method      : PrepareMethodParameters
//
// Description : This method prepares a parameters array for a call to a COM component
//               via the IDispatch interface. The rule action string drives which 
//               parameters are included in the parameters array - and the instance of 
//               the MSMQPropertyBag component is used to retrieve the parameter values 
//
//************************************************************************************
void CMSMQRuleHandler::PrepareMethodParameters(IMSMQPropertyBag * pIMSMQPropertyBag,DISPPARAMS * pdispparms,_bstr_t * pbstrTestMessageBody)
{
	HRESULT hr = S_OK;
	long lArgCounter = 0;
	long lArgCount = 0;
	_bstr_t bstrArg = _T("");
	VARIANTARG vArg;
	AP<VARIANTARG> pvarg = NULL;
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);

	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);

	// Initialise the disparms structure
	_fmemset(pdispparms, 0, sizeof(DISPPARAMS)); 

	// Determine how many args there are to process (remember first three tokens are not args).
	lArgCount = m_tokAction.GetNumTokens() - 3;

	// Check if there are no arguements - in this case - define an empty dispparms block.
	if (lArgCount == 0)
	{
		pdispparms->rgvarg = NULL;
		pdispparms->cArgs = 0;
		pdispparms->cNamedArgs = 0;
		pdispparms->rgdispidNamedArgs = 0;

		return;
	}

	// We definately have arguements to pass, allocate and initialise variant array.
    pvarg = new VARIANTARG[lArgCount]; 
	for (int i = 0; i < lArgCount; ++i)
	{
		VariantInit(&pvarg[i]);
	}
	
	// Initialise our general purpose variant.
	VariantInit(&vArg);

	// NOTE that this index is used with a 1 base.
	lArgCounter = 1;

	try
	{
		// For each token - check if it matches a predefined type. If not - assign a literal value.
		while ((lArgCounter <= lArgCount) && (SUCCEEDED(hr)))
		{
			// Release any memory used by this variant before using again.
			hr = VariantClear(&vArg);
			ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));
			

			// Get the next argument (remember first three tokens are not args and the token list is 0 based.)
			m_tokAction.GetToken(lArgCounter + 2, bstrArg);

			hr = GetArgumentValue(pIMSMQPropertyBag,bstrArg,&vArg);				

			if (FAILED(hr))
			{
 				throw bad_hresult(hr);
			}
			
			// Copy the prepared parameter into the structure.
			hr = VariantCopy(&pvarg[lArgCount - lArgCounter],&vArg);
			if (FAILED(hr))
			{
				ASSERT(("Unexpected error", hr == E_OUTOFMEMORY));
				throw bad_alloc();
			}

			// add parameter and it's type to test message body
			TriggerTestAddParameterToMessageBody(pbstrTestMessageBody,bstrArg,vArg);


			// Process the next arguement
			lArgCounter++;
		}

		//Final clear
		hr = VariantClear(&vArg);
		ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));
		

		// Attach the array of prepared arguments to the dispparms structure
		pdispparms->rgvarg = pvarg.detach();
		pdispparms->cArgs = lArgCount;
		pdispparms->cNamedArgs = 0;
		pdispparms->rgdispidNamedArgs = 0;
	}
	catch(const _com_error& e)
	{
		TrERROR(GENERAL, "Failed to retrieve an arguement value from the MSMQPropertyBag. Rule id: %ls. Parameter: %ls. %!hresult!", (LPCWSTR)m_bstrRuleID, (LPCWSTR)bstrArg, e.Error());
		VariantArrayClear(pvarg, lArgCount);
		throw;
 	}
	catch(const exception&)
	{
		TrERROR(GENERAL, "Failed to retrieve an arguement value from the MSMQPropertyBag. Rule id: %ls. Parameter: %ls", (LPCWSTR)m_bstrRuleID, (LPCWSTR)bstrArg);
		VariantArrayClear(pvarg, lArgCount);
		throw;
	}
}


_bstr_t CMSMQRuleHandler::GetExeName(void)
{
	_bstr_t	exeName;
	m_tokAction.GetToken(ACTION_EXE_NAME, exeName);

	// If the exe name is not in quotes, and there is an embedded space (as often happens w
	// with long filenames), then we will want to enclose the exe name in double quotes now.
	if ((IsEnclosedInQuotes(exeName) == false) && 
		(wcschr(static_cast<LPCWSTR>(exeName), L' ') != NULL))
	{
		return 	L"\"" + exeName + L"\"";
	}

	return exeName;
}

//************************************************************************************
//
// Method      : PrepareEXECommandLine
//
// Description : This method prepares a command line for a call to a standalone EXE.
//               The rule action string determines which parameters are included in the
//               commandline, and the instance of the MSMQPropertyBag component is used
//               to retrieve the parameter values 
//
//************************************************************************************
HRESULT 
CMSMQRuleHandler::PrepareEXECommandLine(
	IMSMQPropertyBag * pIMSMQPropertyBag,
	_bstr_t * pbstrExeName,
	_bstr_t * pbstrCommandLine,
	_bstr_t * pbstrTestMessageBody
	)
{
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);
	ASSERT(pIPropertyBag != NULL);

	//
	// Get the EXE name of the process as the start of the command line.
	//
	if (m_tokAction.GetNumTokens() < ACTION_EXE_NAME)
	{
		TrERROR(GENERAL, "Invalid rule action parameter, %ls", static_cast<LPCWSTR>(m_bstrAction));
		return MQTRIG_ERROR_INVALID_RULE_ACTION_PARAMETER;
	}

	_bstr_t	exeName;
	m_tokAction.GetToken(ACTION_EXE_NAME, exeName);

	_bstr_t commandLine = GetExeName();

	//
	// add the trigger ID, RuleID, MessageID, "EXE" and EXE name to test message body
	//
	TriggerTestInitMessageBody(
		pbstrTestMessageBody,
		pIMSMQPropertyBag,
		m_bstrRuleID,
		L"EXE",
		commandLine,
		L"",
		L""
		);

	//
	// retrieve arguments. remember first two tokens are not args.
	//
	for(DWORD i = 2; i < m_tokAction.GetNumTokens(); ++i)
	{
		//
		// Get the next argument (remember first two tokens are not args and the token list is 0 based.)
		//
		_bstr_t bstrArg;
		m_tokAction.GetToken(i, bstrArg);

		VARIANTARG vArg;
		VariantInit(&vArg);	
		HRESULT hr = GetArgumentValue(pIPropertyBag, bstrArg, &vArg);

		if (FAILED(hr))
		{
			hr = VariantClear(&vArg);
			ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));
			
			TrERROR(GENERAL, "Failed to retrieve an arguement value from the MSMQPropertyBag. Rule id: %ls. Parameter: %ls, Erroe 0x%x.", (LPCWSTR)m_bstrRuleID, (LPCWSTR)bstrArg, hr);
			return MQTRIG_ERROR_INVOKE_EXE;
		}

		//
		// Change the variant into a BSTR type
		//
		_variant_t vConvertedArg;
		hr = VariantChangeType(&vConvertedArg, &vArg, NULL, VT_BSTR);

		if (FAILED(hr))
		{
			hr = VariantClear(&vArg);
			ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));
			
			TrERROR(GENERAL, "Failed to Convert a variant from one type to another for rule %ls.	Error 0x%x", (LPCWSTR)m_bstrRuleID, hr);
			return MQTRIG_ERROR_INVOKE_EXE;
		}

		commandLine += L" ";
		commandLine += L"\"";

		if ((_wcsicmp(bstrArg, g_PARM_MSG_ID) == 0) ||
			(_wcsicmp(bstrArg, g_PARM_MSG_CORRELATION_ID) == 0))
		{
			OBJECTID* pObj = (OBJECTID*)(vConvertedArg.pbVal);

			WCHAR strId[256];
			ObjectIDToString(pObj, strId, 256);

			commandLine += strId;
		}
		else
		{
			commandLine += static_cast<_bstr_t>(vConvertedArg);
		}

		commandLine += L"\"";

		//
		// add parameter and it's type to test message body
		//
		TriggerTestAddParameterToMessageBody(pbstrTestMessageBody, bstrArg, vArg);

		//
		// Release resources used by vArg.
		//
		hr = VariantClear(&vArg);
		ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));
		
	}

	*(pbstrExeName) = exeName;
	*(pbstrCommandLine) = commandLine;
	return S_OK;
}

//************************************************************************************
//
// Method      : ReleaseMethodParameters
//
// Description : This method is used to de-allocate the resources consumed by the 
//               parameters array used when making a call to a COM component.
//
//************************************************************************************
void CMSMQRuleHandler::ReleaseMethodParameters(DISPPARAMS * pdispparms)
{
	if (pdispparms->rgvarg != NULL)
	{
		for(DWORD lArgCounter=0; lArgCounter < pdispparms->cArgs; lArgCounter++)
		{
			HRESULT hr = VariantClear(&pdispparms->rgvarg[lArgCounter]);
			ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));	
			UNREFERENCED_PARAMETER(hr);			
		}

		delete pdispparms->rgvarg;
	}	
}

//************************************************************************************
//
// Method      : GetArgumentValue
//
// Description : This method is used to retrieve a property value from the instance of
//               MSMQPropertyBag component. This retrieval logic is separated out in 
//               a separate method (as opposed to using the pIMSMQPropertyBag instance 
//               from the caller g
//               
//
//************************************************************************************
HRESULT 
CMSMQRuleHandler::GetArgumentValue(
    IMSMQPropertyBag * pIMSMQPropertyBag,
    bstr_t bstrArg,
    VARIANTARG * pvArgValue
    )
{
	IMSMQPropertyBagPtr pIPropertyBag(pIMSMQPropertyBag);

	// Assert that we have a valid property bag instance
	ASSERT(pIPropertyBag != NULL);
	
	if(_wcsicmp(bstrArg, g_PARM_MSG_ID) == 0)
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_MsgID),pvArgValue);
	}			

	if(_wcsicmp(bstrArg, g_PARM_MSG_LABEL) == 0)
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_Label),pvArgValue);
	}

	if(_wcsicmp(bstrArg, g_PARM_MSG_BODY) == 0)
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_MsgBody),pvArgValue);
	}

	if(_wcsicmp(bstrArg, g_PARM_MSG_BODY_AS_STRING) == 0)
	{
		HRESULT hr = pIPropertyBag->Read(_bstr_t(g_PropertyName_MsgBody),pvArgValue);

		if (FAILED(hr))
			return hr;
		
		return ConvertFromByteArrayToString(pvArgValue);
	}

	if(_wcsicmp(bstrArg, g_PARM_MSG_PRIORITY) == 0) 
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_MsgPriority),pvArgValue);
	}		

	if(_wcsicmp(bstrArg, g_PARM_MSG_CORRELATION_ID) == 0)
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_CorID),pvArgValue);			
	}

	if(_wcsicmp(bstrArg, g_PARM_MSG_QUEUE_PATHNAME) == 0)
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_QueuePathname),pvArgValue);
	}
	
	if(_wcsicmp(bstrArg, g_PARM_MSG_QUEUE_FORMATNAME) == 0)
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_QueueFormatname),pvArgValue);
	}

	if(_wcsicmp(bstrArg, g_PARM_MSG_APPSPECIFIC) == 0)
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_AppSpecific),pvArgValue);			
	}
	
	if(_wcsicmp(bstrArg, g_PARM_MSG_RESPQUEUE_FORMATNAME) == 0)
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_ResponseQueueName),pvArgValue);			
	}
	
	if(_wcsicmp(bstrArg, g_PARM_MSG_ADMINQUEUE_FORMATNAME) == 0)
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_AdminQueueName),pvArgValue);			
	}
	
	if(_wcsicmp(bstrArg, g_PARM_MSG_ARRIVEDTIME) == 0)
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_ArrivedTime),pvArgValue);
	}

	if(_wcsicmp(bstrArg, g_PARM_MSG_SENTTIME) == 0)
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_SentTime),pvArgValue);
	}

	if(_wcsicmp(bstrArg, g_PARM_MSG_SRCMACHINEID) == 0)
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_SrcMachineId),pvArgValue);
	}

    if(_wcsicmp(bstrArg, g_PARM_MSG_LOOKUPID) == 0)
    {
        return pIPropertyBag->Read(_bstr_t(g_PropertyName_LookupId),pvArgValue);
    }

	if(_wcsicmp(bstrArg, g_PARM_TRIGGER_NAME) == 0)
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_TriggerName),pvArgValue);
	}
  
	if(_wcsicmp(bstrArg, g_PARM_TRIGGER_ID) == 0)
	{
		return pIPropertyBag->Read(_bstr_t(g_PropertyName_TriggerID),pvArgValue);
	}

	//
	// Interpret as a literal value, either string or numeric.
	//
	if (IsEnclosedInQuotes(bstrArg))
	{
		ConvertToUnquotedVariant(bstrArg,pvArgValue);
		return S_OK;
	}

	VARIANT vStringArg;
	VariantInit(&vStringArg);

	vStringArg.vt = VT_BSTR;
	vStringArg.bstrVal = bstrArg;

	HRESULT hr = VariantChangeType(pvArgValue,&vStringArg,NULL,VT_I4);
	
	if FAILED(hr)
	{
		TrERROR(GENERAL, "Failed to Convert a variant from one type to another. rule %ls.	Error 0x%x", m_bstrRuleID, hr);
	}

	return(hr);
}

//************************************************************************************
//
// Method      : IsEnclosedInQuotes
//
// Description : returns true if the supplied string is wrapped in either single or 
//               double quotes. Returns false otherwise.
//
// Note        : this method test that both the begginning and the end of the string
//               are quote characters , of the same type (i.e. both single quotes or
//               both double quotes)
//
//************************************************************************************
bool CMSMQRuleHandler::IsEnclosedInQuotes(const _bstr_t& bstrString)
{
	size_t length = bstrString.length();
	if (length < 2)
		return false;

	LPCWSTR p = bstrString;
	return (((p[0] == L'\"') && (p[length - 1] == L'\"')) || 
			((p[0] == L'\'') && (p[length - 1] == L'\'')));
}

//************************************************************************************
//
// Method      : ConvertToUnquotedVariant
//
// Description : Converts the supplied quoted string into an unquoted string, and 
//               returns the result in a VARINAT datatype.
//
//************************************************************************************
void 
CMSMQRuleHandler::ConvertToUnquotedVariant(
	const _bstr_t& bstrString, 
	VARIANT * pv
	)
{
	//
	// ensure that the supplied string is actually quoted. 
	//
	ASSERT(IsEnclosedInQuotes(bstrString));

	//
	// intialize the supplied variant value.
	//
	HRESULT hr = VariantClear(pv);
	ASSERT(("VariantClear shouldn't fail", SUCCEEDED(hr)));			
	UNREFERENCED_PARAMETER(hr);

	DWORD length = bstrString.length() - 2;  // Remove quotes
	if (length == 0) // Check for empty string.
	{
		pv->vt = VT_BSTR;
		pv->bstrVal = SysAllocString(_T(""));
		return;
	}
	
	AP<WCHAR> pszBuffer = new WCHAR[length+1];
	wcsncpy(pszBuffer.get(), ((LPWSTR)bstrString) + 1, length);
	pszBuffer.get()[length] = L'\0';

	pv->vt = VT_BSTR;
	pv->bstrVal = SysAllocString(pszBuffer.get());
}


void CMSMQRuleHandler::SetComClassError(HRESULT hr)
{
	WCHAR errMsg[256]; 
	DWORD size = TABLE_SIZE(errMsg);

	GetErrorDescription(hr, errMsg, size);
	Error(errMsg, GUID_NULL, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\ruleset.hpp ===
//*****************************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 02/01/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef __MSMQRULESET_H_
#define __MSMQRULESET_H_

#include "resource.h"        

// Base class that handle receiving and sending notification msgs
#include "trignotf.hpp"

// Used to allow STL to compile without thousands of warnings.
#pragma warning(disable:4786)

// Include the definition of the CRuntimeRuleInfo class (used to hold rule info)
#include "ruleinfo.hpp"

// Define a new type - a 2D map of Rule-ID's and pointers to instance of CRuntimeRuleInfo
typedef std::map<std::wstring,CRuntimeRuleInfo*, std::less<std::wstring> > RULE_MAP;

class ATL_NO_VTABLE CMSMQRuleSet : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQRuleSet, &CLSID_MSMQRuleSet>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQRuleSet, &IID_IMSMQRuleSet, &LIBID_MSMQTriggerObjects>,
	public CMSMQTriggerNotification
{
	public:

		CMSMQRuleSet();
		~CMSMQRuleSet();

		DECLARE_REGISTRY_RESOURCEID(IDR_MSMQRULESET)
		DECLARE_NOT_AGGREGATABLE(CMSMQRuleSet)
		DECLARE_GET_CONTROLLING_UNKNOWN()

		DECLARE_PROTECT_FINAL_CONSTRUCT()

		BEGIN_COM_MAP(CMSMQRuleSet)
			COM_INTERFACE_ENTRY(IMSMQRuleSet)
			COM_INTERFACE_ENTRY(IDispatch)
			COM_INTERFACE_ENTRY(ISupportErrorInfo)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
		END_COM_MAP()

		HRESULT FinalConstruct()
		{
			return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pUnkMarshaler.p);
		}

		void FinalRelease()
		{
			m_pUnkMarshaler.Release();
		}

		CComPtr<IUnknown> m_pUnkMarshaler;

		// ISupportsErrorInfo
		STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	private:
		// A map of CRuntimeRuleInfo objects keyed by Rule ID
		RULE_MAP m_mapRules;

		// Used to destroy the contents of the rule map.
		void ClearRuleMap(void);

		// Builds the map of rules based on registry data.
		bool PopulateRuleMap(void);

		// debug only
		_bstr_t DumpRuleMap(void);

	private:
		void SetComClassError(HRESULT hr);

	public:
		STDMETHOD(get_TriggerStoreMachineName)(/*[out, retval]*/ BSTR *pVal);
		STDMETHOD(Init)(/*[in]*/ BSTR bstrMachineName);

		STDMETHOD(Refresh)();

		STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

		STDMETHOD(Add)(
					/*[in]*/ BSTR sName,
					/*[in]*/ BSTR sDescription,
					/*[in]*/ BSTR sCondition,
					/*[in]*/ BSTR sAction,
					/*[in]*/ BSTR sImplementation,
					/*[in]*/ BOOL fShowWindow,
					/*[out]*/BSTR * psRuleID );
		STDMETHOD(Update)(
					/*[in]*/ BSTR sRuleID,
					/*[in]*/ BSTR sName,
					/*[in]*/ BSTR sDescription,
					/*[in]*/ BSTR sCondition,
					/*[in]*/ BSTR sAction,
					/*[in]*/ BSTR sImplementation,
					/*[in]*/ BOOL fShowWindow );
					
		STDMETHOD(Delete)(/*[in]*/ BSTR sRuleID);
		STDMETHOD(GetRuleDetailsByID)(
					/*[in]*/  BSTR sRuleID,
					/*[out]*/ BSTR * psRuleName,
					/*[out]*/ BSTR * psDescription,
					/*[out]*/ BSTR * psCondition,
					/*[out]*/ BSTR * psAction,
					/*[out]*/ BSTR * psImplementationProgID,
					/*[out]*/ BOOL * pfShowWindow);//,
					///*[out]*/ long * plRefCount );

		STDMETHOD(GetRuleDetailsByIndex)(
					/*[in]*/  long lRuleIndex,
					/*[out]*/ BSTR * psRuleID,
					/*[out]*/ BSTR * psRuleName,
					/*[out]*/ BSTR * psDescription,
					/*[out]*/ BSTR * psCondition,
					/*[out]*/ BSTR * psAction,
					/*[out]*/ BSTR * psImplementationProgID,
					/*[out]*/ BOOL * pfShowWindow);//,
					///*[out]*/ long * plRefCount );
					

};

#endif //__MSMQRULESET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#ifndef __TRIGOBJ_STDAFX_H__
#define __TRIGOBJ_STDAFX_H__

#include <libpch.h>

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_DEBUG_CRT
#define ATLASSERT ASSERT

#include <atlbase.h>

//
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
//
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

void TrigReAllocString(BSTR* pbstr,	LPCWSTR psz);
void GetErrorDescription(HRESULT hr, LPWSTR errmsg, DWORD size);


#endif __TRIGOBJ_STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\ruleset.cpp ===
//************************************************************************************
//
// Class Name  : CMSMQRuleSet
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This is the COM implementation of the IMSMQRuleSet interface. This 
//               component is used for accessing and manipulating trigger rule 
//               definitions.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//************************************************************************************
#include "stdafx.h"
#include "stdfuncs.hpp"
#include "mqsymbls.h"
#include "mqtrig.h"
#include "mqtg.h"
#include "ruleset.hpp"
#include "clusfunc.h"
#include "cm.h"

#include "ruleset.tmh"

using namespace std;


//************************************************************************************
//
// Method      : InterfaceSupportsErrorInfo
//
// Description : Standard rich error info interface.
//
//************************************************************************************
STDMETHODIMP CMSMQRuleSet::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQRuleSet
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//************************************************************************************
//
// Method      : Constructor
//
// Description : Initializes the CMSMQRuleSet instance.
//
//************************************************************************************
CMSMQRuleSet::CMSMQRuleSet()
{
	m_pUnkMarshaler = NULL;
	m_hHostRegistry= NULL;

	// Set the name of this class for future reference in tracing & logging etc..
	m_bstrThisClassName  = _T("MSMQRuleSet");
	m_fHasInitialized = false;
}

//************************************************************************************
//
// Method      : Destructor
//
// Description : Releases resources owned by this class instance.
//
//************************************************************************************
CMSMQRuleSet::~CMSMQRuleSet()
{
	// Release resources currently held by the rule cache
	ClearRuleMap();

	// Close the registry handle 
	if (m_hHostRegistry != NULL)
	{
		RegCloseKey(m_hHostRegistry);
	}
}

STDMETHODIMP CMSMQRuleSet::Init(BSTR bstrMachineName)
{
	TrTRACE(GENERAL, "RuleSet initilization. Computer name: %ls", static_cast<LPCWSTR>(bstrMachineName));

	bool fRes = CMSMQTriggerNotification::Init(bstrMachineName);
	if ( !fRes )
	{
		TrERROR(GENERAL, "Failed to initialize rule set for computer %ls", (LPCWSTR)bstrMachineName);

		SetComClassError(MQTRIG_ERROR_INIT_FAILED);
		return MQTRIG_ERROR_INIT_FAILED;
	}
	
	return S_OK;
}


//************************************************************************************
//
// Method      : ClearRuleMap
//
// Description : This method destroys the contents of the current rule map.
//
//************************************************************************************
void CMSMQRuleSet::ClearRuleMap()
{
	TrTRACE(GENERAL, "Call CMSMQRuleSet::ClearRuleMap().");

	for(RULE_MAP::iterator it = m_mapRules.begin();	it != m_mapRules.end(); )
	{
		P<CRuntimeRuleInfo> pRule = it->second;

		it = m_mapRules.erase(it);
	}
}

//************************************************************************************
//
// Method      : DumpRuleMap
//
// Description : This method dumps the contents of the rule map to the debugger. This
//               should only be invoked from a _DEBUG build.
//
//************************************************************************************
_bstr_t CMSMQRuleSet::DumpRuleMap()
{
	_bstr_t bstrTemp;
	_bstr_t bstrRuleMap;
	long lRuleCounter = 0;
	RULE_MAP::iterator i = m_mapRules.begin();
	CRuntimeRuleInfo * pRule = NULL;

	bstrRuleMap = _T("\n");

	while ((i != m_mapRules.end()) && (!m_mapRules.empty()))
	{
		// Cast to a rule pointer
		pRule = (*i).second;

		// We should never have null pointers in this map.
		ASSERT(pRule != NULL);

		FormatBSTR(&bstrTemp,_T("\nRule(%d)\t ID(%s)\tName(%s)"),lRuleCounter,(wchar_t*)pRule->m_bstrRuleID,(wchar_t*)pRule->m_bstrRuleName);

		bstrRuleMap += bstrTemp;

		// Increment the rule count
		lRuleCounter++;

		// Reinitialize the rule pointer
		pRule = NULL;

		// Look at the next item in the map.
		i++;
	}

	bstrRuleMap += _T("\n");

	return(bstrRuleMap);
}

//************************************************************************************
//
// Method      : Refresh
//
// Description : This method rebuilds the map of rule data cached by this component. 
//               This method must be called at least once by a client component that 
//               intends to manage rule data.
//
//************************************************************************************
STDMETHODIMP CMSMQRuleSet::Refresh()
{
	TrTRACE(GENERAL, "CMSMQRuleSet::Refresh()");

	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);			
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}

	try 
	{	
		// Release resources currently held by the rule cache
		ClearRuleMap();

		if (PopulateRuleMap() == false)
		{
			TrERROR(GENERAL, "Failed to refresh ruleset");

			SetComClassError(MQTRIG_ERROR_COULD_NOT_RETREIVE_RULE_DATA);			
			return MQTRIG_ERROR_COULD_NOT_RETREIVE_RULE_DATA;
		}

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : get_Count
//
// Description : Returns the number of rules currently cached in the map.
//
//************************************************************************************
STDMETHODIMP CMSMQRuleSet::get_Count(long *pVal)
{
	TrTRACE(GENERAL, "CMSMQRuleSet::get_Count. pValue = 0x%p", pVal);
	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}

	if (pVal == NULL)
	{
		TrERROR(GENERAL, "CMSMQRuleSet::get_Count, invalid parameter");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	//
	// Get the size from the map structure.
	//
	*pVal = numeric_cast<long>(m_mapRules.size());

	return S_OK;
}

//************************************************************************************
//
// Method      : GetRuleDetailsByID
//
// Description : Returns the rule details for the rule with the supplied RuleID.
//
//************************************************************************************
STDMETHODIMP CMSMQRuleSet::GetRuleDetailsByID(/* [in] */  BSTR sRuleID,
											  /* [out] */ BSTR *psRuleName,
											  /* [out] */ BSTR *psDescription,
											  /* [out] */ BSTR *psCondition,
											  /* [out] */ BSTR *psAction,
											  /* [out] */ BSTR *psImplementationProgID,
											  /* [out] */ BOOL *pfShowWindow)
{
	TrTRACE(GENERAL, "CMSMQRuleSet::GetRuleDetailsByID. sRuleID = %ls", static_cast<LPCWSTR>(sRuleID));

	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);			
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeRuleInfo::IsValidRuleID(sRuleID))
		{
			TrERROR(GENERAL, "Invalid rule ID passed to GetRuleDetailsByID. sRuleID = %ls", (LPCWSTR)sRuleID);

			SetComClassError(MQTRIG_INVALID_RULEID);
			return MQTRIG_INVALID_RULEID;
		}

		// Convert the BSTR rule ID to an STL basic string.
		wstring bsRuleID;
		bsRuleID = (wchar_t*)sRuleID;

		// Attempt to find this rule id in the map of rules.
		RULE_MAP::iterator i = m_mapRules.find(bsRuleID);

		// Check if we have found the rule
		if (i != m_mapRules.end())
		{
			// Cast to a rule object reference 
			CRuntimeRuleInfo * pRule = (*i).second;

			// We should never have nulls in the map
			ASSERT(pRule != NULL);

			// We should only store valid rules.
			ASSERT(pRule->IsValid());

			// Populate out parameters if they have been supplied. 
			if (psRuleName != NULL)
			{
				TrigReAllocString(psRuleName,pRule->m_bstrRuleName);
			}
			if (psDescription != NULL)
			{
				TrigReAllocString(psDescription,pRule->m_bstrRuleDescription);
			}
			if (psCondition != NULL)
			{
				TrigReAllocString(psCondition,pRule->m_bstrCondition);
			}
			if (psAction != NULL)
			{
				TrigReAllocString(psAction,pRule->m_bstrAction);
			}
			if (psImplementationProgID != NULL)
			{
				TrigReAllocString(psImplementationProgID,pRule->m_bstrImplementationProgID);
			}
			if(pfShowWindow != NULL)
			{
				*pfShowWindow = pRule->m_fShowWindow;
			}
        }
		else
		{
			TrERROR(GENERAL, "The supplied rule id was not found in the rule store. rule: %ls", bsRuleID.c_str());
			
			SetComClassError(MQTRIG_RULE_NOT_FOUND);
			return MQTRIG_RULE_NOT_FOUND;
		}

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : GetRuleDetailsByIndex
//
// Description : Returns the rule details for the rule with the supplied index. Note
//               that this is a 0 base index.
//
//************************************************************************************
STDMETHODIMP CMSMQRuleSet::GetRuleDetailsByIndex(/* [in] */  long lRuleIndex, 
												 /* [out] */ BSTR *psRuleID,
												 /* [out] */ BSTR *psRuleName,
												 /* [out] */ BSTR *psDescription,
												 /* [out] */ BSTR *psCondition,
												 /* [out] */ BSTR *psAction,
												 /* [out] */ BSTR *psImplementationProgID,
												 /* [out] */ BOOL *pfShowWindow)
{
	TrTRACE(GENERAL, "CMSMQRuleSet::GetRuleDetailsByIndex. index = %d", lRuleIndex);

	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}

	// We need to validate that the supplied rule index is within range
 	if ((lRuleIndex < 0) || (numeric_cast<DWORD>(lRuleIndex) > m_mapRules.size()))
	{
		TrERROR(GENERAL, "The supplied rule index was invalid. ruleIndex=%d", lRuleIndex);
		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}
	
	try
	{
		// Get a reference to the beginging of the map
		RULE_MAP::iterator i = m_mapRules.begin();

		// Iterate through to the correct index. 
		for (long lCounter = 0; lCounter < lRuleIndex ; ++i,lCounter++)
		{
			NULL;
		}

		// Cast to a rule object reference 
		CRuntimeRuleInfo* pRule = (*i).second;

		// We should never have nulls in the map
		ASSERT(pRule != NULL);

		// We should only store valid rules.
		ASSERT(pRule->IsValid());

		// Populate out parameters if they have been supplied. 
		if (psRuleID != NULL)
		{
			TrigReAllocString(psRuleID,pRule->m_bstrRuleID);
		}
		if (psRuleName != NULL)
		{
			TrigReAllocString(psRuleName,pRule->m_bstrRuleName);
		}
		if (psDescription != NULL)
		{
			TrigReAllocString(psDescription,pRule->m_bstrRuleDescription);
		}
		if (psCondition != NULL)
		{
			TrigReAllocString(psCondition,pRule->m_bstrCondition);
		}
		if (psAction != NULL)
		{
			TrigReAllocString(psAction,pRule->m_bstrAction);
		}
		if (psImplementationProgID != NULL)
		{
			TrigReAllocString(psImplementationProgID,pRule->m_bstrImplementationProgID);
		}
		if(pfShowWindow != NULL)
		{
			*pfShowWindow = pRule->m_fShowWindow;
		}

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : Delete
//
// Description : This method delete the rule with the specified rule id from the 
//               trigger store.
//
//************************************************************************************
STDMETHODIMP CMSMQRuleSet::Delete(BSTR sRuleID)
{
	TrTRACE(GENERAL, "CMSMQRuleSet::Delete. rule = %ls", static_cast<LPCWSTR>(sRuleID));

	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}


	try
	{
		if (!CRuntimeRuleInfo::IsValidRuleID(sRuleID))
		{
			TrERROR(GENERAL, "Invalid parameter to CMSMQRuleSet::Delete.");

			SetComClassError(MQTRIG_INVALID_RULEID);
			return MQTRIG_INVALID_RULEID;
		}

		// Convert the BSTR rule ID to an STL basic string.
		wstring bsRuleID = (wchar_t*)sRuleID;

		// Attempt to find this rule id in the map of rules.
		RULE_MAP::iterator it = m_mapRules.find(bsRuleID);

		// Check if we have found the rule
		if (it == m_mapRules.end())
        {
            //
            // rule wasn't found
            //
			TrERROR(GENERAL, "The supplied rule id was not found. rule: %ls", bsRuleID.c_str());

			SetComClassError(MQTRIG_RULE_NOT_FOUND);
			return MQTRIG_RULE_NOT_FOUND;
        }

		// Cast to a rule object reference 
    	CRuntimeRuleInfo* pRule = it->second;

		// We should never have nulls in the map
		ASSERT(pRule != NULL);

		// We should only store valid rules.
		ASSERT(pRule->IsValid());

		// Attempt to delete the rule
		bool fSucc = pRule->Delete(m_hHostRegistry);
		if(!fSucc)
		{
			//
			// Failed to delete the rule. Dont remove the rule from the map
			//
			SetComClassError(MQTRIG_ERROR_COULD_NOT_DELETE_RULE);
			return MQTRIG_ERROR_COULD_NOT_DELETE_RULE;
		};

        //
        // Delete success. Remove the rule from rule map and delete the rule instance
        //
		NotifyRuleDeleted(sRuleID);
		m_mapRules.erase(it);
        delete pRule;

        return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : Add
//
// Description : This method add a new rule to the trigger store. 
//
//************************************************************************************
STDMETHODIMP 
CMSMQRuleSet::Add(
    BSTR sName, 
    BSTR sDescription, 
    BSTR sCondition, 
    BSTR sAction, 
    BSTR sImplementation, 
    BOOL fShowWindow, 
    BSTR *psRuleID
    )
{
	TrTRACE(GENERAL, "CMSMQRuleSet::Add. rule name = %ls", static_cast<LPCWSTR>(sName));

	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);			
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}

	try
	{
		//
		// Validate the supplied method parameters.
		//
		if (!CRuntimeRuleInfo::IsValidRuleName(sName))
		{
			TrERROR(GENERAL, "The supplied rule name for CMSMQRuleSet::Add is invalid. rule name: %ls", (LPCWSTR)sName);

			SetComClassError(MQTRIG_INVALID_RULE_NAME);			
			return MQTRIG_INVALID_RULE_NAME;
		}
	
		if (!CRuntimeRuleInfo::IsValidRuleCondition(sCondition))
		{
			TrERROR(GENERAL, "The supplied rule condition for CMSMQRuleSet::Add is invalid. rule condition: %ls", (LPCWSTR)sCondition);

			SetComClassError(MQTRIG_INVALID_RULE_CONDITION);			
			return MQTRIG_INVALID_RULE_CONDITION;
		}

		if (!CRuntimeRuleInfo::IsValidRuleAction(sAction))
		{
			TrERROR(GENERAL, "The supplied rule action for CMSMQRuleSet::Add is invalid. rule action: %ls", (LPCWSTR)sAction);
			
			SetComClassError(MQTRIG_INVALID_RULE_ACTION);			
			return MQTRIG_INVALID_RULE_ACTION;
		}

		if (!CRuntimeRuleInfo::IsValidRuleDescription(sDescription))
		{
			TrERROR(GENERAL, "The supplied rule description for CMSMQRuleSet::Add is invalid. rule description: %ls", (LPCWSTR)sDescription);
			
			SetComClassError(MQTRIG_INVALID_RULE_DESCRIPTION);			
			return MQTRIG_INVALID_RULE_DESCRIPTION;
		}

		//
		// Currently only support use of default MS implementation.
		//
		sImplementation = _T("MSMQTriggerObjects.MSMQRuleHandler");

		//
		// Allocate a new rule object
		//
		P<CRuntimeRuleInfo> pRule = new CRuntimeRuleInfo(
											CreateGuidAsString(),
											sName,
											sDescription,
											sCondition,
											sAction,
											sImplementation,
											m_wzRegPath,
											(fShowWindow != 0) );

		
		bool fSucc = pRule->Create(m_hHostRegistry);
		if (fSucc)
		{
			//
			// Keep rule ID  for later use
			//
			BSTR bstrRuleID = pRule->m_bstrRuleID;

			//
			// Add this rule to our map of rules.
			//
			m_mapRules.insert(RULE_MAP::value_type(bstrRuleID, pRule));
			pRule.detach();


			//
			// If we have been supplied a out parameter pointer for the new rule ID use it.
			//
			if (psRuleID != NULL)
			{
				TrigReAllocString(psRuleID, bstrRuleID);
			}

			NotifyRuleAdded(bstrRuleID, sName);

			return S_OK;
		}

		TrERROR(GENERAL, "Failed to store rule data in registry");
		return MQTRIG_ERROR_STORE_DATA_FAILED;

	}
	catch(const bad_alloc&)
	{
		SysFreeString(*psRuleID);

		TrERROR(GENERAL, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : Update
//
// Description : This method updates the nominated rule with new parameters.
//
//************************************************************************************
STDMETHODIMP 
CMSMQRuleSet::Update(
	BSTR sRuleID, 
	BSTR sName, 
	BSTR sDescription, 
	BSTR sCondition, 
	BSTR sAction, 
	BSTR sImplementation, 
	BOOL fShowWindow
	)
{
	TrTRACE(GENERAL, "CMSMQRuleSet::Update. rule = %ls", static_cast<LPCWSTR>(sRuleID));

	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}

	//
	// Validate the supplied method parameters.
	//
	if (!CRuntimeRuleInfo::IsValidRuleID(sRuleID))
	{
		TrERROR(GENERAL, "Invalid parameter to CMSMQRuleSet::Delete.");

		SetComClassError(MQTRIG_INVALID_RULEID);
		return MQTRIG_INVALID_RULEID;
	}

 	if (!CRuntimeRuleInfo::IsValidRuleName(sName))
	{
		TrERROR(GENERAL, "The supplied rule name for CMSMQRuleSet::Add is invalid. rule name: %ls", (LPCWSTR)sName);

		SetComClassError(MQTRIG_INVALID_RULE_NAME);
		return MQTRIG_INVALID_RULE_NAME;
	}
	
	if (!CRuntimeRuleInfo::IsValidRuleCondition(sCondition))
	{
		TrERROR(GENERAL, "The supplied rule condition for CMSMQRuleSet::Add is invalid. rule condition: %ls", (LPCWSTR)sCondition);

		SetComClassError(MQTRIG_INVALID_RULE_CONDITION);
		return MQTRIG_INVALID_RULE_CONDITION;
	}

	if (!CRuntimeRuleInfo::IsValidRuleAction(sAction))
	{
		TrERROR(GENERAL, "The supplied rule action for CMSMQRuleSet::Add is invalid. rule action: %ls", (LPCWSTR)sAction);

		SetComClassError(MQTRIG_INVALID_RULE_ACTION);
		return MQTRIG_INVALID_RULE_ACTION;
	}

	if (!CRuntimeRuleInfo::IsValidRuleDescription(sDescription))
	{
		TrERROR(GENERAL, "The supplied rule description for CMSMQRuleSet::Add is invalid. rule description: %ls", (LPCWSTR)sDescription);

		SetComClassError(MQTRIG_INVALID_RULE_DESCRIPTION);
		return MQTRIG_INVALID_RULE_DESCRIPTION;
	}

	sImplementation = _T("MSMQTriggerObjects.MSMQRuleHandler");	

	try
	{
		//
		// Convert the BSTR rule ID to an STL basic string.
		//
		wstring bsRuleID = (wchar_t*)sRuleID;

		//
		// Attempt to find this rule id in the map of rules.
		//
		RULE_MAP::iterator it = m_mapRules.find(bsRuleID);

		// Check if we found the nominated rule.
		if (it == m_mapRules.end())
		{
			TrERROR(GENERAL, "The rule could not be found. rule: %ls", (LPCWSTR)sRuleID);

			SetComClassError(MQTRIG_RULE_NOT_FOUND);
			return MQTRIG_RULE_NOT_FOUND;
		}

		// Cast to a rule object reference 
		CRuntimeRuleInfo* pRule = it->second;

		// We should never have nulls in the map
		ASSERT(pRule != NULL);

		// We should only store valid rules.
		ASSERT(pRule->IsValid());

		// Update the rule object with new parameters if they have been supplied. 
		if (sName != NULL)
		{
			pRule->m_bstrRuleName = (wchar_t*)sName;
		}
		if (sCondition != NULL)
		{
			pRule->m_bstrCondition = (wchar_t*)sCondition;
		}
		if (sAction != NULL)
		{
			pRule->m_bstrAction = (wchar_t*)sAction;
		}
		if (sImplementation != NULL)
		{
			pRule->m_bstrImplementationProgID = (wchar_t*)sImplementation;
		}
		if (sDescription != NULL)
		{
			pRule->m_bstrRuleDescription = (wchar_t*)sDescription;
		}

		pRule->m_fShowWindow = (fShowWindow != 0);

		// Confirm that the rule is still valid before updating
		bool fSucc = pRule->Update(m_hHostRegistry);
		if (!fSucc)
		{
			TrERROR(GENERAL, "Failed to store the updated data for rule: %ls in registry", (LPCWSTR)sRuleID);
			SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
			return MQTRIG_ERROR_STORE_DATA_FAILED;
		}

		NotifyRuleUpdated(sRuleID, sName);
		
		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}


//************************************************************************************
//
// Method      : PopulateRuleMap
//
// Description : Populates the rule map with instances of the CRuntimeRuleInfo class
//               based on the data found in the registry.
//
//************************************************************************************
bool CMSMQRuleSet::PopulateRuleMap()
{
	HKEY hRuleKey;
	try
	{
		RegEntry regTrig(m_wzRegPath, L"", 0, RegEntry::MustExist, HKEY_LOCAL_MACHINE);
		HKEY hKey = CmOpenKey(regTrig, KEY_READ);
		CRegHandle ark(hKey);

		RegEntry regRule(REG_SUBKEY_RULES, L"", 0, RegEntry::MustExist, hKey);
		hRuleKey = CmOpenKey(regRule, KEY_READ);
	}
	catch(const exception&)
	{
		//
		// Failed to allocate CRuntimeRuleInfo structure - log an error and set return code.
		//
		TrERROR(GENERAL, "Failed to open the registry key: %ls%ls",  m_wzRegPath, REG_SUBKEY_RULES);
		return false;
	}

	CRegHandle ar(hRuleKey);

    //
	// Enumerate through the keys under the REG_SUBKEY_RULES key.
	// Each Key here should be a RuleID. As we enumerate through these keys,
	// we will populate the rules list with instance of the CRuntimeRuleInfo class.
	// If any rule fails to load, we remove it from the list.
    //
	for(DWORD index =0;; ++index)
    {
		WCHAR ruleName[MAX_REGKEY_NAME_SIZE];
		DWORD len = TABLE_SIZE(ruleName);

		LONG hr = RegEnumKeyEx(	
						hRuleKey,
						index,
						ruleName,
						&len,
						NULL,
						NULL,
						NULL,
						NULL
						);

		if(hr == ERROR_NO_MORE_ITEMS)
		{
			return true;
		}

		if ((hr == ERROR_NOTIFY_ENUM_DIR) || (hr == ERROR_KEY_DELETED)) 
		{
			ClearRuleMap();
			return PopulateRuleMap();
		}

		if (FAILED(hr))
		{
			TrERROR(GENERAL, "Failed to enumerate rule. Error=0x%x", hr);
			return false;
		}

		P<CRuntimeRuleInfo> pRule = new CRuntimeRuleInfo(m_wzRegPath);
		if(pRule->Retrieve(m_hHostRegistry, ruleName))
		{
			pair<RULE_MAP::iterator, bool> p = m_mapRules.insert(RULE_MAP::value_type(wstring(pRule->m_bstrRuleID), pRule));
			if (p.second)
			{
				pRule.detach();
			}
			else
			{
				TrTRACE(GENERAL, "Duplicate rule id was found. rule: %ls.", static_cast<LPCWSTR>(pRule->m_bstrRuleID));
			}
		}
	}

	ASSERT(("this code shouldn't reach", 0));
	return true;

}


STDMETHODIMP CMSMQRuleSet::get_TriggerStoreMachineName(BSTR *pVal)
{
	TrTRACE(GENERAL, "CMSMQRuleSet::get_TriggerStoreMachineName(). pVal = 0x%p", pVal);

	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "Ruleset object wasn't initialized. Before calling any method of RuleSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_RULESET_NOT_INIT);
		return MQTRIG_ERROR_RULESET_NOT_INIT;
	}

	
	if(pVal == NULL)
	{
		TrERROR(GENERAL, "Inavlid parameter to get_TriggerStoreMachineName");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	try
	{
		TrigReAllocString(pVal, (TCHAR*)m_bstrMachineName);
		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}


void CMSMQRuleSet::SetComClassError(HRESULT hr)
{
	WCHAR errMsg[256]; 
	DWORD size = TABLE_SIZE(errMsg);

	GetErrorDescription(hr, errMsg, size);
	Error(errMsg, GUID_NULL, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\rulehdlr.hpp ===
// CMSMQRuleHandler.hpp : Declaration of the CMSMQRuleHandler

#ifndef __MSMQRULEHANDLER_H_
#define __MSMQRULEHANDLER_H_

#include "resource.h"       // main symbols

#include "strparse.hpp"
#include "IDspPrxy.hpp"


// Declare smart pointer type for the MSMQ property bag COM object.
_COM_SMARTPTR_TYPEDEF(IMSMQPropertyBag, __uuidof(IMSMQPropertyBag));

class ATL_NO_VTABLE CMSMQRuleHandler : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQRuleHandler, &CLSID_MSMQRuleHandler>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CMSMQRuleHandler>,
	public IDispatchImpl<IMSMQRuleHandler, &IID_IMSMQRuleHandler, &LIBID_MSMQTriggerObjects>
{
	public:

		CMSMQRuleHandler();
		~CMSMQRuleHandler();


		DECLARE_REGISTRY_RESOURCEID(IDR_MSMQRULEHANDLER)
		DECLARE_GET_CONTROLLING_UNKNOWN()

		DECLARE_PROTECT_FINAL_CONSTRUCT()

		BEGIN_COM_MAP(CMSMQRuleHandler)
			COM_INTERFACE_ENTRY(IMSMQRuleHandler)
			COM_INTERFACE_ENTRY(IDispatch)
			COM_INTERFACE_ENTRY(ISupportErrorInfo)
			COM_INTERFACE_ENTRY(IConnectionPointContainer)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
		END_COM_MAP()
		BEGIN_CONNECTION_POINT_MAP(CMSMQRuleHandler)
		END_CONNECTION_POINT_MAP()


	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}


	CComPtr<IUnknown> m_pUnkMarshaler;

	CStringTokens m_tokCondition;
	CStringTokens m_tokAction;

	_bstr_t m_bstrRuleID;
	_bstr_t m_bstrCondition;
	_bstr_t m_bstrAction;
    RulesProcessingStatus m_RulesProcessingStatus;

	bool	m_fIsSerializedQueue;
	bool	m_fShowWindow;


	// Used to determine if the action portion of this rule should be executed
	HRESULT RuleConditionSatisfied(IMSMQPropertyBag * pIMSMQPropertyBag,BOOL * pbConditionSatisifed);

	// Evaluates a single condition token.
	HRESULT EvaluateConditionToken(IMSMQPropertyBag * pIMSMQPropertyBag,_bstr_t bstrConditionToken,BOOL * pbConditionSatisfied);

	// Used to execute the action portion of a rule
	HRESULT ExecuteRuleAction(IMSMQPropertyBag * pIMSMQPropertyBag);

	// Creates and releases and array of parameters for a method calls.
	void PrepareMethodParameters(IMSMQPropertyBag * pIMSMQPropertyBag,DISPPARAMS * pdispparms,bstr_t * pbstrTestMessageBody);
	void ReleaseMethodParameters(DISPPARAMS * pdispparms);

	// Formats a command line of parameters for standalone EXE invocation
	HRESULT PrepareEXECommandLine(IMSMQPropertyBag * pIMSMQPropertyBag,	_bstr_t * pbstrExeName, _bstr_t * pbstrCommandLine,bstr_t * pbstrTestMessageBody);

	// Methods used to invoke customer functionality
	HRESULT InvokeCOMComponent(IMSMQPropertyBag * pIMSMQPropertyBag);
	HRESULT InvokeEXE(IMSMQPropertyBag * pIMSMQPropertyBag);

	// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

	// Retreive a name arguement value from the property bag, return as a variant
	HRESULT GetArgumentValue(IMSMQPropertyBag * pIMSMQPropertyBag,bstr_t bstrArgName, VARIANTARG * pvArgValue);

	// Helper functions used in testing and manipulating strings
	bool IsEnclosedInQuotes(const _bstr_t& bstrString);
	void ConvertToUnquotedVariant(const _bstr_t& bstrString, VARIANT * pv);


// IMSMQRuleHandler
public:
    STDMETHOD(CheckRuleCondition)(/*[in]*/ IMSMQPropertyBag * pIPropertyBag ,  /*[out]*/ BOOL * pbConditionSatisfied );
	STDMETHOD(ExecuteRule)(/*[in]*/ IMSMQPropertyBag * pIPropertyBag , /*[in]*/ BOOL fIsSerializedQueue, /* [out]*/ LONG * plRuleResult );
	STDMETHOD(Init)(/*[in]*/ BSTR bstrRuleID, /*[in]*/ BSTR sRuleCondition , /*[in]*/ BSTR sRuleAction, /*[in]*/ BOOL fShowWindow);

private:
	void SetComClassError(HRESULT hr);
	_bstr_t GetExeName(void);

};

#endif //__MSMQRULEHANDLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\trigcnfg.hpp ===
//*****************************************************************************
//
// Class Name  : CMSMQTriggersConfig
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : Header file for the CMSMQTriggersConfig class.This 
//               component is used to retrieve and set configuration
//               info for the MSMQ triggers service.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef __MSMQTRIGGERSCONFIG_H_
#define __MSMQTRIGGERSCONFIG_H_

#include "resource.h"       // main symbols


class ATL_NO_VTABLE CMSMQTriggersConfig : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQTriggersConfig, &CLSID_MSMQTriggersConfig>,
	public ISupportErrorInfo,
	public IDispatchImpl<IMSMQTriggersConfig, &IID_IMSMQTriggersConfig, &LIBID_MSMQTriggerObjects>
{
	public:

		CMSMQTriggersConfig()
		{
			m_pUnkMarshaler = NULL;
		}

		DECLARE_REGISTRY_RESOURCEID(IDR_MSMQTRIGGERSCONFIG)
		DECLARE_NOT_AGGREGATABLE(CMSMQTriggersConfig)
		DECLARE_GET_CONTROLLING_UNKNOWN()

		DECLARE_PROTECT_FINAL_CONSTRUCT()

		BEGIN_COM_MAP(CMSMQTriggersConfig)
			COM_INTERFACE_ENTRY(IMSMQTriggersConfig)
			COM_INTERFACE_ENTRY(IDispatch)
			COM_INTERFACE_ENTRY(ISupportErrorInfo)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
		END_COM_MAP()

		HRESULT FinalConstruct()
		{
			return CoCreateFreeThreadedMarshaler(
				GetControllingUnknown(), &m_pUnkMarshaler.p);
		}

		void FinalRelease()
		{
			m_pUnkMarshaler.Release();
		}

		CComPtr<IUnknown> m_pUnkMarshaler;

		private:
			void SetComClassError(HRESULT hr);
			
		public:
			STDMETHOD(get_InitTimeout)(/*[out, retval]*/ long *pVal);
			STDMETHOD(put_InitTimeout)(/*[in]*/ long newVal);

			STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

			STDMETHOD(get_MaxThreads)(/*[out, retval]*/ long *pVal);
			STDMETHOD(put_MaxThreads)(/*[in]*/ long newVal);

			STDMETHOD(get_InitialThreads)(/*[out, retval]*/ long *pVal);
			STDMETHOD(put_InitialThreads)(/*[in]*/ long newVal);

			STDMETHOD(get_DefaultMsgBodySize)(/*[out, retval]*/ long *plDefaultMsgBodySize);
			STDMETHOD(put_DefaultMsgBodySize)(/*[in]*/ long lDefaultMsgBodySize);

			STDMETHOD(get_TriggerStoreMachineName)(/*[out, retval]*/ BSTR *pVal);
};

#endif //__MSMQTRIGGERSCONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\trigcnfg.cpp ===
//*****************************************************************************
//
// Class Name  : CMSMQTriggersConfig
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This is the implemenation for the MSMQ Triggers configuration
//               COM component. This component is used to retrieve and set 
//               configuration info for the MSMQ triggers service.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#include "stdafx.h"
#include "stdfuncs.hpp"
#include "mqtg.h"
#include "mqsymbls.h"
#include "mqtrig.h"
#include "trigcnfg.hpp"
#include "stddefs.hpp"
#include "trignotf.hpp"
#include "QueueUtil.hpp"
#include "clusfunc.h"

#include "trigcnfg.tmh"

//*****************************************************************************
//
// Method      : InterfaceSupportsErrorInfo
//
// Description : Standard support for rich error info.
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQTriggersConfig
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//*****************************************************************************
//
// Method      : get_TriggerStoreMachineName
//
// Description : Returns the machine name on which the triggers data store 
//               can be found.
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::get_TriggerStoreMachineName(BSTR *pVal)
{
	_bstr_t bstrLocalComputerName;
	
	DWORD dwError = GetLocalMachineName(&bstrLocalComputerName);

	if(dwError != 0)
	{
		TrERROR(GENERAL, "Failed to retreive local computer name. Error 0x%x", GetLastError());

		SetComClassError(MQTRIG_ERROR);
		return MQTRIG_ERROR;
	}

	
	try
	{
		if (pVal != NULL)
		{
			SysReAllocString(pVal,(wchar_t*)bstrLocalComputerName);
		}
		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}


//*****************************************************************************
//
// Method      : get_InitialThreads
//
// Description : Returns the initial number of threads that triggers service 
//               should start with.
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::get_InitialThreads(long *plInitialThreads)
{
	// Check that we have been passed a valid parameter
	if (plInitialThreads == NULL)
	{
		// Assign the exception return code
		TrERROR(GENERAL, "Invalid parameter passed to get_InitialThreads routine");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();

	// Attempt to retrieve the trigger store machine name parm.
	GetNumericConfigParm(
						pRegPath,
						CONFIG_PARM_NAME_INITIAL_THREADS,
						(DWORD*)plInitialThreads,
						CONFIG_PARM_DFLT_INITIAL_THREADS
						);

	return S_OK;
}

//*****************************************************************************
//
// Method      : put_InitialThreads
//
// Description : Stores the number of threads the triggers service should 
//               start with.
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::put_InitialThreads(long lInitialThreads)
{
	// Validate that we have been supplied a valid parameter.
	if ((lInitialThreads > xMaxThreadNumber) || (lInitialThreads < 1))
	{
		TrERROR(GENERAL, "Invalid parameter passed to put_InitialThreads routine");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();

	bool fSucc = SetNumericConfigParm(pRegPath,CONFIG_PARM_NAME_INITIAL_THREADS,(DWORD)lInitialThreads);
	if (!fSucc)
	{
		TrERROR(GENERAL, "Failed to store initial thread number in registery");

		SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
		return MQTRIG_ERROR_STORE_DATA_FAILED;
	}
	
	return S_OK;
}

//*****************************************************************************
//
// Method      : get_MaxThreads
//
// Description : Returns the maximum number of threads the triggers service 
//               is allowed to create to service queue messages.
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::get_MaxThreads(long *plMaxThreads)
{
	// Check that we have been passed a valid parameter
	if (plMaxThreads == NULL)
	{
		TrERROR(GENERAL, "Invalid parameter passed to get_InitialThreads routine");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();

	GetNumericConfigParm(
						pRegPath,
						CONFIG_PARM_NAME_MAX_THREADS,
						(DWORD*)plMaxThreads,
						CONFIG_PARM_DFLT_MAX_THREADS
						);

	return S_OK;
}


//*****************************************************************************
//
// Method      : put_MaxThreads
//
// Description : Stores the maximum number of threads the triggers servie is 
//               allowed to create in order to process queue messages.
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::put_MaxThreads(long lMaxThreads)
{
	// Validate that we have been supplied a valid parameter.
	if ((lMaxThreads > xMaxThreadNumber) || (lMaxThreads < 1))
	{
		TrERROR(GENERAL, "Invalid parameter passed to put_InitialThreads routine");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();
	bool fSucc = SetNumericConfigParm(pRegPath,CONFIG_PARM_NAME_MAX_THREADS,(DWORD)lMaxThreads);
	
	if (!fSucc)
	{
		TrERROR(GENERAL, "Failed to store max thread number in registery.");

		SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
		return MQTRIG_ERROR_STORE_DATA_FAILED;
	}
	
	return S_OK;
}



//*****************************************************************************
//
// Method      : get_DefaultMsgBodySize
//
// Description : returns the default size that the MSMQ Triggers service
//               should use to pre-allocate message body buffers. 
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::get_DefaultMsgBodySize(long *plDefaultMsgBodySize)
{
	// Check that we have been passed a valid parameter
	if (plDefaultMsgBodySize == NULL)
	{
		TrERROR(GENERAL, "Invalid parameter passed to get_DefaultMsgBodySize routine");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();

	GetNumericConfigParm(
						pRegPath,
						CONFIG_PARM_NAME_DEFAULTMSGBODYSIZE,
						(DWORD*)plDefaultMsgBodySize,
						CONFIG_PARM_DFLT_DEFAULTMSGBODYSIZE
						);
	
	return S_OK;
}

//*****************************************************************************
//
// Method      : put_DefaultMsgBodySize
//
// Description : sets the default size that the MSMQ Triggers service
//               should use to pre-allocate message body buffers. 
//
//*****************************************************************************
STDMETHODIMP CMSMQTriggersConfig::put_DefaultMsgBodySize(long lDefaultMsgBodySize)
{
	// Validate that we have been supplied a valid parameter.
	if ((lDefaultMsgBodySize > xDefaultMsbBodySizeMaxValue) || (lDefaultMsgBodySize < 0))
	{
		TrERROR(GENERAL, "Invalid parameter passed to put_DefaultMsgBodySize routine");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();

	bool fSucc = SetNumericConfigParm(
								pRegPath,
								CONFIG_PARM_NAME_DEFAULTMSGBODYSIZE,
								(DWORD)lDefaultMsgBodySize
								);

	if (!fSucc)
	{
		TrERROR(GENERAL, "Failed to store default body size in registery");

		SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
		return MQTRIG_ERROR_STORE_DATA_FAILED;
	}
	
	return S_OK;
}


STDMETHODIMP CMSMQTriggersConfig::get_InitTimeout(long *pVal)
{
	// Check that we have been passed a valid parameter
	if (pVal == NULL)
	{
		TrERROR(GENERAL, "Inavlid parameter to get_InitTimeout");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();

	// Attempt to retrieve the trigger store machine name parm.
	GetNumericConfigParm(
		pRegPath,
		CONFIG_PARM_NAME_INIT_TIMEOUT,
		(DWORD*)pVal,
		CONFIG_PARM_DFLT_INIT_TIMEOUT
		);

	return S_OK;
}

STDMETHODIMP CMSMQTriggersConfig::put_InitTimeout(long newVal)
{
	const TCHAR* pRegPath = GetTrigParamRegPath();

	// Validate that we have been supplied a valid parameter.
	bool fSucc = SetNumericConfigParm(pRegPath,CONFIG_PARM_NAME_INIT_TIMEOUT,(DWORD)newVal);

	if (!fSucc)
	{
		TrERROR(GENERAL, "Failed to store init timeout in registery.");

		SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
		return MQTRIG_ERROR_STORE_DATA_FAILED;
	}
	
	return S_OK;
}


void CMSMQTriggersConfig::SetComClassError(HRESULT hr)
{
	WCHAR errMsg[256]; 
	DWORD size = TABLE_SIZE(errMsg);

	GetErrorDescription(hr, errMsg, size);
	Error(errMsg, GUID_NULL, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\triggertest.hpp ===
// Declarations of function for testing purposes

VOID TriggerTestSendTestingMessage(_bstr_t TestingMessageBody);
VOID TriggerTestInitMessageBody(bstr_t * pbstrTestMessageBody,IMSMQPropertyBag * pIMSMQPropertyBag,_bstr_t bstrRuleID,_bstr_t ActionType,_bstr_t EXEName,_bstr_t bstrProgID,_bstr_t bstrMethodName);
VOID TriggerTestAddParameterToMessageBody(_bstr_t * bstrTestMessageBody,_bstr_t TypeToAdd,variant_t vArg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\trignotf.hpp ===
//*****************************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef CMSMQTriggerNotification_INCLUDED 
#define CMSMQTriggerNotification_INCLUDED

// Include definitions required for message queues.
#include <mq.h>

// Include the triggers shared definitions
#include "stddefs.hpp"

// Include the definitions for this project
#include "mqtrig.h"

// Include the definitions for the MSMQ Trigger Configuration COM component.
#include "trigcnfg.hpp"
#include "mqtg.h"

// Define the name of the queue when no queue has been specified. 
#define NO_QUEUE_SPECIFIED L"No Queue Name Specified"

// Define the number message property structures that we are going to use.
#define TRIGGER_NOTIFICATIONS_NMSGPROPS              6
  
// Define max msg body size
#define MAX_MSG_BODY_SIZE      1024

// Define the maximum size of the format queue name 
#define MAX_Q_FORMAT_NAME_LEN  512

// Define the name of the notification queue used by MSMQTriggers
//#define MSMQTRIGGER_NOTIFICATION_QUEUENAME  _T(".\\MSMQTriggerNotifications")

#define MSGBODY_FORMAT_TRIGGERADDED    _T("TriggerID=%s;TriggerName=%s;QueueName=%s")
#define MSGBODY_FORMAT_TRIGGERUPDATED  _T("TriggerID=%s;TriggerName=%s;QueueName=%s")
#define MSGBODY_FORMAT_TRIGGERDELETED  _T("TriggerID=%s")
#define MSGBODY_FORMAT_RULEADDED       _T("RuleID=%s;RuleName=%s")
#define MSGBODY_FORMAT_RULEUPDATED     _T("RuleID=%s;RuleName=%s")
#define MSGBODY_FORMAT_RULEDELETED     _T("RuleID=%s")

class CMSMQTriggerNotification  
{
	public:
	
	protected:

		CMSMQTriggerNotification();
		~CMSMQTriggerNotification();
	
		// The name of the machine that is hosting the trigger data.
		_bstr_t m_bstrMachineName;
		bool m_fHasInitialized;
	
		// A handle to the registry that hosts the trigger data.
		HKEY m_hHostRegistry;

		TCHAR m_wzRegPath[MAX_REGKEY_NAME_SIZE];

		_bstr_t m_bstrThisClassName;

		OVERLAPPED m_Overlapped;

		bool Init(BSTR bstrMachineName);

		// Used to connect to local or remote registry
		bool ConnectToRegistry();

		HRESULT NotifyTriggerAdded(BSTR sTriggerID, BSTR sTriggerName,BSTR sQueueName);
		HRESULT NotifyTriggerDeleted(BSTR sTriggerID);
		HRESULT NotifyTriggerUpdated(BSTR sTriggerID, BSTR sTriggerName,BSTR sQueueName);

		HRESULT NotifyRuleAdded(BSTR sRuleID, BSTR sRuleName);
		HRESULT NotifyRuleDeleted(BSTR sRuleID);
		HRESULT NotifyRuleUpdated(BSTR sRuleID, BSTR sRuleName);
		
	private:

		// Handle to the MSMQTriggerNotifications Queue
		HANDLE m_hSendMsgQueue;
		HANDLE m_hPeekMsgQueue;

		HANDLE m_hQCursor;

		// General send method
		HRESULT SendToQueue(BSTR sLabel,BSTR sMsg);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\trigobjs.cpp ===
// MSMQTriggerObjects.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for trigobjs.idl by adding the following 
//      files to the Outputs.
//          MSMQTriggerObjects_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f trigobjs.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "dlldatax.h"
#include "TrigSet.hpp"
#include "rulehdlr.hpp"
#include "cpropbag.hpp"
#include "ruleset.hpp"
#include "trigcnfg.hpp"
#include "clusfunc.h"
#include "_mqres.h"
#include "Cm.h"
#include "Tr.h"

#include "trigobjs.tmh"

CComModule _Module;

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MSMQTriggerSet, CMSMQTriggerSet)
OBJECT_ENTRY(CLSID_MSMQRuleHandler, CMSMQRuleHandler)
OBJECT_ENTRY(CLSID_MSMQPropertyBag, CMSMQPropertyBag)
OBJECT_ENTRY(CLSID_MSMQRuleSet, CMSMQRuleSet)
//
// NOTE : The MSMQTrigger object has tentatively been removed from this project. 
//
// OBJECT_ENTRY(CLSID_MSMQTrigger, CMSMQTrigger)
//
//
OBJECT_ENTRY(CLSID_MSMQTriggersConfig, CMSMQTriggersConfig)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        WPP_INIT_TRACING(L"Microsoft\\MSMQ");

		try
		{
			try
			{
				//
				// MqTrig.dll can be loaded by the triggers service or by other applications.
				// Since the triggers service runs as local system, calling CmInitialize with KEY_ALL_ACCESS
				// will fail. This is OK since the service dosen't use MqTrig.dll to write to registry.
				//
	        	CmInitialize(HKEY_LOCAL_MACHINE, REGKEY_TRIGGER_PARAMETERS, KEY_ALL_ACCESS);
			}
			catch(const exception&) 
			{
				CmInitialize(HKEY_LOCAL_MACHINE, REGKEY_TRIGGER_PARAMETERS, KEY_READ);
			}
			TrInitialize();

	        _Module.Init(ObjectMap, hInstance, &LIBID_MSMQTriggerObjects);
	        DisableThreadLibraryCalls(hInstance);

			//
			// Try to find MSMQ Triggers service on this
			// machine. This machine may be:
			// 1 - a regular computer
			// 2 - phisycal node of a clustered machine
			// 3 - virtual server on clustered machine
			// The found service name defines the registry section
			// that will be accessed by objects in this DLL
			//
			bool fRes = FindTriggersServiceName();

			if ( !fRes )
			{
				return FALSE;
			}
		}
		catch(const exception&)
		{
			return FALSE;
		}
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        WPP_CLEANUP();
        _Module.Term();
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}


void TrigReAllocString(BSTR* pbstr,	LPCWSTR psz)
{
	BOOL fSucc = SysReAllocString(pbstr, psz);
	if (!fSucc)
		throw bad_alloc();
}


void 
GetErrorDescription(
	HRESULT hr, 
	LPWSTR errMsg, 
	DWORD size
	)
{
	errMsg[0] = L'\0';

	FormatMessage(
			FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_MAX_WIDTH_MASK,
			MQGetResourceHandle(),
            static_cast<DWORD>(hr),
            0,
            errMsg,
            size,
            NULL 
			);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\trignotf.cpp ===
//************************************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//************************************************************************************
#include "stdafx.h"
#include "stdfuncs.hpp"

// Include the definition for this class.
#include "trignotf.hpp"
#include "QueueUtil.hpp"
#include "clusfunc.h"
#include "privque.h"

#include "trignotf.tmh"

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
CMSMQTriggerNotification::CMSMQTriggerNotification()
{
	// Initialise the queue and cursor handles
	m_hSendMsgQueue = NULL;
	m_hPeekMsgQueue = NULL;
	m_hQCursor = NULL;

	// Initialise the Overlapped structure and create an NT event object
	ZeroMemory(&m_Overlapped,sizeof(m_Overlapped));
}

//************************************************************************************
//
// Method      :
//
// Description :
//
// Returns     :
//
//************************************************************************************
CMSMQTriggerNotification::~CMSMQTriggerNotification()
{
}


//************************************************************************************
//
// Method      : Init
//	
// Description : Common initialization function.
//
// Returns     : 
//
//************************************************************************************
bool CMSMQTriggerNotification::Init(BSTR bstrMachineName)
{
	if(m_fHasInitialized)
	{
		TrERROR(GENERAL, "TriggerSet was already initialized.");			
		return false;
	}

	_bstr_t bstrLocalMachineName;
	DWORD dwError = GetLocalMachineName(&bstrLocalMachineName);
	if(dwError != 0)
	{
		TrERROR(GENERAL, "Failed to get Local Computer Name.");			
		return false;
	}

	//
	// Trying to connect to local machine
	//
	if( bstrMachineName == NULL ||
		_bstr_t(bstrMachineName) == _bstr_t(_T("")) ||
		_bstr_t(bstrMachineName) == bstrLocalMachineName)
	{
		m_bstrMachineName = bstrLocalMachineName;
	}
	else
	{
		TrERROR(GENERAL, "Connection to remote machine not supported.");			
		return false;
	}

	const TCHAR* pRegPath = GetTrigParamRegPath();
	_tcscpy( m_wzRegPath, pRegPath );

	ConnectToRegistry();

	m_fHasInitialized = true;
	return true;
}

//*******************************************************************
//
// Method      : ConnectToRegistry
//
// Description : This method will connect this class instance to the 
//               registry on the machine nominated in the configuration 
//               parameters (retreived on construction).
//
//*******************************************************************
bool CMSMQTriggerNotification::ConnectToRegistry()
{
	bool bOK = true;

	// First we need to establish a connection to the nominated registry.
	if (m_hHostRegistry == NULL)
	{
		if(RegConnectRegistry(NULL,HKEY_LOCAL_MACHINE,(PHKEY)&m_hHostRegistry) != ERROR_SUCCESS)
		{
			bOK = false;
			TrERROR(GENERAL, "CMSMQTriggerSet::ConnectToRegistry() has failed to connect to the registry on machine %ls. Error: 0x%x.", (LPCWSTR)m_bstrMachineName, GetLastError());
		}
	}

	return(bOK);
}


//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
HRESULT CMSMQTriggerNotification::NotifyTriggerAdded(BSTR sTriggerID, BSTR sTriggerName,BSTR sQueueName)
{
	HRESULT hr = S_OK;
	_bstr_t bstrBody;
	_bstr_t bstrLabel = MSGLABEL_TRIGGERADDED;

	// Format the message body 
	FormatBSTR(&bstrBody,MSGBODY_FORMAT_TRIGGERADDED,(LPCTSTR)sTriggerID,(LPCTSTR)sTriggerName,(LPCTSTR)sQueueName);

	// Post the message to the notifications queue.
	hr = SendToQueue(bstrLabel,bstrBody);

	return(hr);
}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
HRESULT CMSMQTriggerNotification::NotifyTriggerDeleted(BSTR sTriggerID)
{
	HRESULT hr = S_OK;
	_bstr_t bstrBody;
	_bstr_t bstrLabel = MSGLABEL_TRIGGERDELETED;

	// Format the message body 
	FormatBSTR(&bstrBody,MSGBODY_FORMAT_TRIGGERDELETED,(LPCTSTR)sTriggerID);

	// Post the message to the notifications queue.
	hr = SendToQueue(bstrLabel,bstrBody);

	return(hr);
}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
HRESULT CMSMQTriggerNotification::NotifyTriggerUpdated(BSTR sTriggerID, BSTR sTriggerName, BSTR sQueueName)
{
	HRESULT hr = S_OK;
	_bstr_t bstrBody;
	_bstr_t bstrLabel = MSGLABEL_TRIGGERUPDATED;

	// Format the message body 
	FormatBSTR(&bstrBody,MSGBODY_FORMAT_TRIGGERUPDATED,(LPCTSTR)sTriggerID,(LPCTSTR)sTriggerName,(LPCTSTR)sQueueName);

	// Post the message to the notifications queue.
	hr = SendToQueue(bstrLabel,bstrBody);

	return(hr);
}


//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
HRESULT CMSMQTriggerNotification::NotifyRuleAdded(BSTR sRuleID, BSTR sRuleName)
{
	HRESULT hr = S_OK;
	_bstr_t bstrBody;
	_bstr_t bstrLabel = MSGLABEL_RULEADDED;

	// Format the message body 
	FormatBSTR(&bstrBody,MSGBODY_FORMAT_RULEADDED,(LPCTSTR)sRuleID,(LPCTSTR)sRuleName);

	// Post the message to the notifications queue.
	hr = SendToQueue(bstrLabel,bstrBody);

	return(hr);
}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
HRESULT CMSMQTriggerNotification::NotifyRuleDeleted(BSTR sRuleID)
{
	HRESULT hr = S_OK;
	_bstr_t bstrBody;
	_bstr_t bstrLabel = MSGLABEL_RULEDELETED;

	// Format the message body 
	FormatBSTR(&bstrBody,MSGBODY_FORMAT_RULEDELETED,(LPCTSTR)sRuleID);

	// Post the message to the notifications queue.
	hr = SendToQueue(bstrLabel,bstrBody);

	return(hr);
}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
HRESULT CMSMQTriggerNotification::NotifyRuleUpdated(BSTR sRuleID, BSTR sRuleName)
{
	HRESULT hr = S_OK;
	_bstr_t bstrBody;
	_bstr_t bstrLabel = MSGLABEL_RULEUPDATED;

	// Format the message body 
	FormatBSTR(&bstrBody,MSGBODY_FORMAT_RULEUPDATED,(LPCTSTR)sRuleID,(LPCTSTR)sRuleName);

	// Post the message to the notifications queue.
	hr = SendToQueue(bstrLabel,bstrBody);

	return(hr);
}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
HRESULT CMSMQTriggerNotification::SendToQueue(BSTR sLabel,BSTR sMsg)
{
	HRESULT hr = S_OK;
	MSGPROPID aMsgPropId[TRIGGER_NOTIFICATIONS_NMSGPROPS];
	MQPROPVARIANT aMsgPropVar[TRIGGER_NOTIFICATIONS_NMSGPROPS];
	HRESULT aMsgStatus[TRIGGER_NOTIFICATIONS_NMSGPROPS];
	MQMSGPROPS MsgProps;
	DWORD PropIdCount = 0;
	TCHAR szLabel[MQ_MAX_Q_LABEL_LEN+1];
	_bstr_t bstrLabel = sLabel;
	_bstr_t bstrMsg = sMsg;

	// Convert the label into a null terminated string.
	ZeroMemory(szLabel,sizeof(szLabel));
	wcsncpy(szLabel,(BSTR)bstrLabel,bstrLabel.length());

	TrTRACE(GENERAL, "Sending notification message. Label:%ls", static_cast<LPCWSTR>(szLabel));	

	//Set PROPID_M_LABEL
	aMsgPropId[PropIdCount] = PROPID_M_LABEL;                    //PropId
	aMsgPropVar[PropIdCount].vt = VT_LPWSTR;                     //Type
	aMsgPropVar[PropIdCount].pwszVal = (WCHAR*)(LPCTSTR)szLabel; //Value
	PropIdCount++;   

	//Set PROPID_M_BODY
	aMsgPropId[PropIdCount] = PROPID_M_BODY;             //PropId
	aMsgPropVar[PropIdCount].vt = VT_VECTOR | VT_UI1;
	aMsgPropVar[PropIdCount].caub.pElems = (LPBYTE)(LPCTSTR)sMsg;
	aMsgPropVar[PropIdCount].caub.cElems = SysStringByteLen(sMsg);
	PropIdCount++;

	//Set PROPID_M_DELIVERY
	aMsgPropId[PropIdCount] = PROPID_M_DELIVERY;          //PropId
	aMsgPropVar[PropIdCount].vt = VT_UI1;                 //Type
	aMsgPropVar[PropIdCount].bVal = MQMSG_DELIVERY_EXPRESS;// Set durable (default)
	PropIdCount++;    

	//Set PROPID_M_TIME_TO_BE_RECEIVED
	aMsgPropId[PropIdCount] = PROPID_M_TIME_TO_BE_RECEIVED;          //PropId
	aMsgPropVar[PropIdCount].vt = VT_UI4;                            //Type
	aMsgPropVar[PropIdCount].ulVal = 86400;                          // Live for 1 day
	PropIdCount++;    

	//Set the MQMSGPROPS structure.
	MsgProps.cProp = PropIdCount;       //Number of properties.
	MsgProps.aPropID = aMsgPropId;      //Id of properties.
	MsgProps.aPropVar = aMsgPropVar;    //Value of propertis.
	MsgProps.aStatus  = aMsgStatus;     //Error report.

	// Check that we have a valid queu handle
	if (m_hSendMsgQueue == NULL)
	{
		_bstr_t bstrNotificationsQueuePath = m_bstrMachineName + _bstr_t(L"\\private$\\") + _bstr_t(TRIGGERS_QUEUE_NAME);

		_bstr_t bstrFormatName;

		hr = OpenQueue(
					bstrNotificationsQueuePath,
					MQ_SEND_ACCESS,
					false,
					&m_hSendMsgQueue,
					&bstrFormatName
					);
		
		if(FAILED(hr))
		{
			TrERROR(GENERAL, "Failed to open a notification queue. Error 0x%x", hr);
			return hr;
		}
	}
	
	hr = MQSendMessage(m_hSendMsgQueue,&MsgProps, MQ_NO_TRANSACTION);               
	if(FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to send a message to a notification queue. Error 0x%x", hr);
	}

	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\triggertest.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:
    triggertest.cpp

Abstract:
    Trigger service testing functions

Author:
    Tali Kariv (t-talik) 28-Sep-2000

Environment:
    Platform-independent

--*/

#include "stdafx.h"
#include "stdfuncs.hpp"
#include "mq.h"
#include "mqtrig.h"
#include "stddefs.hpp"
#include "Cm.h"

#include "triggertest.tmh"

const LPWSTR xTriggersTestQueue = L".\\private$\\TriggerTestQueue";
const DWORD FORMAT_NAME_LENGTH = 255;
const DWORD NUM_OF_PROPS = 2;
const LPWSTR MESSAGE_LABEL = L"TriggerMessage";

static QUEUEHANDLE QHandle = NULL;


// TestFlag==0 means the flag hasn't been initialized yet
// TestFlag==1 means the flag has been initialized and it is not test mode
// TestFlag==2 means the flag has been initialized and it is test mode

static DWORD TestFlag=0;

// private function declarations

VOID 
InitTriggerTestFlag(
	VOID);

VOID 
AddTextToTestMessageBody(
	_bstr_t * bstrTestMessageBody,
	_bstr_t TextToAdd,
	DWORD Type);

HRESULT
TriggerTestOpenTestQueue(
	VOID);





VOID 
TriggerTestInitMessageBody(
	bstr_t * pbstrTestMessageBody,
	IMSMQPropertyBag * pIMSMQPropertyBag,
	_bstr_t bstrRuleID,_bstr_t ActionType,
	_bstr_t bstrEXEName,_bstr_t bstrProgID,
	_bstr_t bstrMethodName
	)

/*++
	Description 	:	This method will initialize the testing message body with trigger ID, 
						ruleID, message ID,action type and EXE name or COM prog ID and method.
	Input			:	Action information - trigger ID (in property bag),
						rule ID , message ID, action type , and COM prog ID
						& method or EXE name
	Return value	:	none.
--*/


{
	//
	// Check if flag TestFlag was initialized
	//
	if (TestFlag == 0)
		InitTriggerTestFlag(); 

	//
	// if is not test mode
	//
	if (TestFlag == 1)
	{
		return;	
	}

	//
	// it is test mode
	//


	//
	// add trigger ID
	//
	
	_variant_t vTriggerID;	
	HRESULT hr = pIMSMQPropertyBag->Read(_bstr_t(g_PropertyName_TriggerID),&vTriggerID);
	if (FAILED(hr))
	{
		TrTRACE(GENERAL, "Testing - TriggerTestInitMessageBody - the result of pIMSMQPropertyBag->Read was- 0x%x",hr);
		TestFlag=1;
		return ;
	}

	AddTextToTestMessageBody(pbstrTestMessageBody,static_cast<_bstr_t>(vTriggerID),1);
	
	//
	// add rule ID
	//
	AddTextToTestMessageBody(pbstrTestMessageBody,bstrRuleID,1);

	//
	// add Message ID
	//
	_variant_t vMessageID;	
	hr = pIMSMQPropertyBag->Read(_bstr_t(g_PropertyName_MsgID) , &vMessageID);
	if (FAILED(hr))
	{	
		TrTRACE(GENERAL, "Testing - TriggerTestInitMessageBody - the result of pIMSMQPropertyBag->Read was- 0x%x",hr);
		TestFlag=1;
		return ;
	}	

	//
	// Change the variant into a BSTR type
	//
	_variant_t vConvertedArg;
	hr = VariantChangeType(&vConvertedArg, &vMessageID, NULL, VT_BSTR);
	if (FAILED(hr))
	{	
		TrTRACE(GENERAL, "Testing - TriggerTestInitMessageBody - the result of VariantChangeType was- 0x%x",hr);
		TestFlag=1;
		return ;
	}
	
	OBJECTID* pObj = (OBJECTID*)(vConvertedArg.pbVal);
	WCHAR strId[256];
	ObjectIDToString(pObj, strId, 256);

	AddTextToTestMessageBody(pbstrTestMessageBody , _bstr_t(strId) , 1);


	// add action type
	
	AddTextToTestMessageBody(pbstrTestMessageBody,ActionType,1);

	// check action type

	if (_wcsicmp(ActionType,L"COM") == 0)
	{
		// add Prog ID
		AddTextToTestMessageBody(pbstrTestMessageBody,bstrProgID,1);

		// add Method 
		AddTextToTestMessageBody(pbstrTestMessageBody,bstrMethodName,1);
		return ;
	}

	//
	// else - add EXE name
	//
	AddTextToTestMessageBody(pbstrTestMessageBody,bstrEXEName,1);
}


VOID
InitTriggerTestFlag(
	VOID
	)
/*++
   Description 		:	This method will check if a specific entry is registed in registry.
						if yes - will change TestFlag to 2 otherwise will change it to 1
		 
   Input			:	none.

   Return value		:	none.
--*/
{
	try
	{
		RegEntry TriggerTestQueueNameEntry(L"SOFTWARE\\Microsoft\\MSMQ\\Triggers" ,	L"TriggerTest" , 0 , RegEntry::MustExist , HKEY_LOCAL_MACHINE);
 	}
	catch(const exception&)
	{
		TestFlag=1;
		return ;
	}

	//
	// check if queue exist
	//
	if (QHandle==NULL)
	{
		HRESULT hr=TriggerTestOpenTestQueue();
		if (FAILED(hr))
		{
			TrTRACE(GENERAL, "Testing - InitTriggerTestFlag - the result of TriggerTestOpenTestQueue was- 0x%x",hr);
			TestFlag=1; // change to user mode
			return ;	
		}		
	}
	
	//
	// the registry key was found and the queue was opened - change to test mode
	//
	TrTRACE(GENERAL, "Test option is on");
	TestFlag=2;
}


VOID 
AddTextToTestMessageBody(
	_bstr_t * bstrTestMessageBody,
	_bstr_t TextToAdd,
	DWORD Type
	)
/*++
   Description 		:	This method will add text to the test message body.
		 
   Input			:	The test message body, the text to add and style (with or without "'")

   Return value		:	none.
--*/


{
	if (Type)
	{
		(*bstrTestMessageBody) += L"'";			
		(*bstrTestMessageBody) += TextToAdd;
		(*bstrTestMessageBody) += L"' ";				
	}
	else
	{
		(*bstrTestMessageBody) += TextToAdd;
		(*bstrTestMessageBody) += L" ";
	}


}

VOID 
TriggerTestSendTestingMessage(
	_bstr_t bstrTestMessageBody
	)
/*++
   Description  	:	This method will send a message to a queue which pathname is 
						defined in registry entry with label ="Triggers test" and 
						body=EXE name + parameters or COM name + COM method + parameters

   Input			:	The test message body.

   Return value		:	none.
--*/


{
	
	
	if (TestFlag==1)
		return ; // not test mode
	
	//
	// test mode
	//
	bstrTestMessageBody += L"    "; // just to mark the end of message
	
	MQPROPVARIANT	propVar[NUM_OF_PROPS];
	MSGPROPID	propId[NUM_OF_PROPS];
	MQMSGPROPS	mProps;
	DWORD MessageBodyLength = wcslen(bstrTestMessageBody)+1;
	AP<WCHAR> MessageBody = new WCHAR[MessageBodyLength];
	wcscpy(MessageBody,bstrTestMessageBody);
	
	
	DWORD nProps=0;
	propId[nProps]=PROPID_M_BODY;
	propVar[nProps]	.vt=VT_UI1 | VT_VECTOR;
	propVar[nProps].caub.cElems = MessageBodyLength * sizeof(WCHAR);
	propVar[nProps].caub.pElems=reinterpret_cast<UCHAR*>(MessageBody.get());
	nProps++;

	propId[nProps]=PROPID_M_LABEL;
	propVar[nProps]	.vt=VT_LPWSTR;
	propVar[nProps].pwszVal=MESSAGE_LABEL;
	nProps++;
	
	mProps.cProp=nProps;
	mProps.aPropID=propId;
	mProps.aPropVar=propVar;
	mProps.aStatus=NULL;
	
	HRESULT hr;

	hr = MQSendMessage(QHandle,&mProps,NULL);
	if (FAILED(hr))
	{
		TrTRACE(GENERAL, "Testing - TriggerTestSendTestingMessage - the result of MQSendMessage was- 0x%x",hr);
		TestFlag=1; // change to user mode
	}
}

HRESULT 
TriggerTestOpenTestQueue(
	VOID
	)
/*++
   Description	:	This method will open the queue to which the messages will be sent.

   Input	:	none.
 
   Return value	:	code for success or failure in opening queue.
--*/

{
	//
	// test mode
	//	
	WCHAR		FormatName[FORMAT_NAME_LENGTH]=L"";
	DWORD		FormatNameLength=FORMAT_NAME_LENGTH;
	
	HRESULT hr;		

	hr=MQPathNameToFormatName(xTriggersTestQueue,FormatName,&FormatNameLength);
	if (FAILED(hr))
	{
		TrTRACE(GENERAL, "Testing - TriggerTestOpenTestQueue - the result of MQPathNameToFormatName was - 0x%x",hr);
		TestFlag=1;
		return (hr);
	}
	
	//
	// open the "TriggersTestQueue" 
	//
	hr=MQOpenQueue(FormatName,MQ_SEND_ACCESS,MQ_DENY_NONE,&QHandle);
	if (FAILED(hr))
	{
		TrTRACE(GENERAL, "Testing - TriggerTestOpenTestQueue - the result of MQOpenQueue was- 0x%x",hr);
		TestFlag=1;
		return (hr);
	}
	return (S_OK);
}

VOID 
TriggerTestAddParameterToMessageBody(
	_bstr_t * pbstrTestMessageBody,
	_bstr_t TypeToAdd,
	variant_t vArg
	)
/*++
   Description	:	This method will add to the test message body a parameter and it's type.
 
   Input	:	The test message body argument type and value (as variant)

   Return value :	none.
--*/

{

	if (TestFlag == 1)
	{	
		return;	
	}
	
	//
	// test mode
	//	
	// add parameter type
	//
	AddTextToTestMessageBody(pbstrTestMessageBody,TypeToAdd,1);
		
	//
	// add parameter value
	//
	HRESULT hr;
	_variant_t vConvertedArg;
	
	hr = VariantChangeType(&vConvertedArg,&vArg,NULL,VT_BSTR);
	if (FAILED(hr))
	{	
		TrTRACE(GENERAL, "Testing - TriggerTestAddParameterToMessageBody - the result of VariantChangeType was- 0x%x",hr);
		TestFlag=1;
		return ;
	}
		
	if ((_wcsicmp(TypeToAdd, g_PARM_MSG_ID) == 0) ||
		(_wcsicmp(TypeToAdd, g_PARM_MSG_CORRELATION_ID) == 0))
	{
		OBJECTID* pObj = (OBJECTID*)(vConvertedArg.pbVal);
		WCHAR strId[256];
		ObjectIDToString(pObj, strId, 256);
		AddTextToTestMessageBody(pbstrTestMessageBody,strId,1);
	}
	else
	{				
		AddTextToTestMessageBody(pbstrTestMessageBody,static_cast<_bstr_t>(vConvertedArg),1);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\adminmsg.hpp ===
//*******************************************************************
//
// Class Name  : CAdminMessage
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class represents a message sent to the admin 
//               thread. 
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#ifndef CAdminMessage_INCLUDED 
#define CAdminMessage_INCLUDED

class CAdminMessage 
{
	public :

		enum eMsgTypes
		{
			eNewThreadRequest = 0,
			eTriggerUpdated = 1,
			eTriggerDeleted = 2,
			eTriggerAdded = 3,
			eRuleUpdated = 4,
			eRuleDeleted = 5,
			eRuleAdded = 6
		};

		CAdminMessage(eMsgTypes eMsgType);
		~CAdminMessage();

		eMsgTypes GetMessageType() { return m_eMsgType; };

	private :

		eMsgTypes m_eMsgType;

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\trigset.cpp ===
//************************************************************************************
//
// Class Name  : CMSMQTriggerSet
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This is the implementation of the MSMQTriggerSet object. This is the 
//               main object by which trigger definitons are maintained.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/09/98 | jsimpson  | Initial Release
//
//************************************************************************************
#include "stdafx.h"
#include "stdfuncs.hpp"
#include "mqtrig.h"
#include "mqsymbls.h"
#include "mqtg.h"
#include "trigset.hpp"
#include "QueueUtil.hpp"
#include "clusfunc.h"
#include "cm.h"

#include "trigset.tmh"

using namespace std;

//************************************************************************************
//
// Method      : InterfaceSupportsErrorInfo
//
// Description : Standard interface for rich error info.
//
//************************************************************************************
STDMETHODIMP CMSMQTriggerSet::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSMQTriggerSet
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

//************************************************************************************
//
// Method      : Constructor
//
// Description : Initializes an instance of the MSMQTriggerSet object.
//
//************************************************************************************
CMSMQTriggerSet::CMSMQTriggerSet()
{
	m_pUnkMarshaler = NULL;
	m_hHostRegistry = NULL;

	// Set the name of this class for future reference in tracing & logging etc..
	m_bstrThisClassName  = _T("MSMQTriggerSet");

	m_fHasInitialized = false;
}

//************************************************************************************
//
// Method      : Destructor
//
// Description : Destroys an instance of the MSMQTriggerSet object.
//
//************************************************************************************
CMSMQTriggerSet::~CMSMQTriggerSet()
{
	// Release resources currently held by the trigger cache
	ClearTriggerMap();

	// Close the registry handle 
	if (m_hHostRegistry != NULL)
	{
		RegCloseKey(m_hHostRegistry);
	}
}


//************************************************************************************
//
// Method      : Init
//
// Description : Initialization of the object
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::Init(
	BSTR bstrMachineName
	)
{
	bool fRes = CMSMQTriggerNotification::Init(bstrMachineName);

	if ( !fRes )
	{
		TrERROR(GENERAL, "Failed to initialize CMSMQTriggerSet object");

		SetComClassError(MQTRIG_ERROR_INIT_FAILED);
		return MQTRIG_ERROR_INIT_FAILED;
	}
	
	return S_OK;
}


//************************************************************************************
//
// Method      : ClearTriggerMap
//
// Description : This method destroys the contents of the current trigger map.
//
//************************************************************************************
void 
CMSMQTriggerSet::ClearTriggerMap(
	VOID
	)
{
	m_mapTriggers.erase(m_mapTriggers.begin(), m_mapTriggers.end());
}

//************************************************************************************
//
// Method      : Refresh
//
// Description : This method retrieves a fresh snapshot of the trigger data from the 
//               database. It will rebuild it's list of triggers, rules, and the 
//               associations between triggers and rules. This method needs to be 
//               called before the client of this object can browse trigger info.
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::Refresh(
	VOID
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	try 
	{			
		// Release resources currently held by the trigger cache
		ClearTriggerMap();

		if (PopulateTriggerMap() == false)
		{
			TrERROR(GENERAL, "Failed to refresh trigger set");

			SetComClassError(MQTRIG_ERROR_COULD_NOT_RETREIVE_TRIGGER_DATA);
			return MQTRIG_ERROR_COULD_NOT_RETREIVE_TRIGGER_DATA;
		}

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : FindTriggerInMap
//
// Description : 
//
//************************************************************************************
HRESULT 
CMSMQTriggerSet::FindTriggerInMap(
	BSTR sTriggerID, 
	R<CRuntimeTriggerInfo>& pTrigger,
	TRIGGER_MAP::iterator &it
	)
{
	pTrigger.free();

	//
	// Validate the supplied method parameters.
	//
	if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
	{
		TrERROR(GENERAL, "CMSMQTriggerSet::FindTriggerInMap, invalid parameter");
		return MQTRIG_INVALID_TRIGGER_ID;
	}

	//
	// Convert the BSTR rule ID to an STL basic string.
	//
	wstring bsTriggerID = (wchar_t*)sTriggerID;

	//
	// Attempt to find this trigger id in the map.
	//
	it = m_mapTriggers.find(bsTriggerID);

	if (it == m_mapTriggers.end())
	{
		TrERROR(GENERAL, "Trigger id wasn't found");
		return MQTRIG_TRIGGER_NOT_FOUND;
	}

	pTrigger = it->second;

	ASSERT(pTrigger.get() != NULL);
	ASSERT(pTrigger->IsValid());

	return(S_OK);
}

//************************************************************************************
//
// Method      : get_Count
//
// Description : Returns the number of trigger definitions currently cached by this 
//               object instance. This is not the same as going to the database to 
//               determine how many triggers are defined. 
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::get_Count(
	long *pVal
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	if (pVal == NULL)
	{
		TrERROR(GENERAL, "CMSMQTriggerSet::get_Count, invalid parameter");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}

	// Get the size from the map structure.
	(*pVal) = numeric_cast<long>(m_mapTriggers.size());

	return S_OK;
}

///************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::GetTriggerDetailsByID(
	/*[in]*/ BSTR sTriggerID,
	/*[out]*/ BSTR * psTriggerName,
	/*[out]*/ BSTR * psQueueName,
	/*[out]*/ SystemQueueIdentifier* pSystemQueue,
	/*[out]*/ long * plNumberOfRules,
	/*[out]*/ long * plEnabledStatus,
	/*[out]*/ long * plSerialized,
	/*[out]*/ MsgProcessingType* pMsgProcType
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
		{
			TrERROR(GENERAL, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_ID);
			return MQTRIG_INVALID_TRIGGER_ID;
		}

		TRIGGER_MAP::iterator it;
		R<CRuntimeTriggerInfo> pTrigger;

		//
		// attempt to find this trigger in the map.
		//
		HRESULT hr = FindTriggerInMap(sTriggerID, pTrigger, it);

		if (FAILED(hr))
		{
			TrERROR(GENERAL, "The supplied trigger id was not found in the trigger store. trigger: %ls", (LPCWSTR)sTriggerID);
			
			SetComClassError(hr);
			return hr;
		}

		// Populate out parameters if they have been supplied. 
		if (psTriggerName != NULL)
		{
			TrigReAllocString(psTriggerName,pTrigger->m_bstrTriggerName);
		}
		if(pSystemQueue != NULL)
		{
			(*pSystemQueue) = pTrigger->m_SystemQueue;
		}
		if (psQueueName != NULL)
		{
			TrigReAllocString(psQueueName,pTrigger->m_bstrQueueName);
		}
		if (plEnabledStatus != NULL)
		{
			(*plEnabledStatus) = (long)pTrigger->IsEnabled();
		}
		if (plSerialized != NULL)
		{
			(*plSerialized) = (long)pTrigger->IsSerialized();
		}
		if (plNumberOfRules != NULL)
		{			
			(*plNumberOfRules) = pTrigger->GetNumberOfRules();	
		}
		if (pMsgProcType != NULL)
		{
			(*pMsgProcType) = pTrigger->GetMsgProcessingType();
		}

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to refresh trigger set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::GetTriggerDetailsByIndex(
	/*[in]*/ long lTriggerIndex ,
	/*[out]*/ BSTR * psTriggerID ,
	/*[out]*/ BSTR * psTriggerName ,
	/*[out]*/ BSTR * psQueueName,
	/*[out]*/SystemQueueIdentifier* pSystemQueue,
	/*[out]*/ long * plNumberOfRules,
	/*[out]*/ long * plEnabledStatus,
	/*[out]*/ long * plSerialized,
	/*[out]*/ MsgProcessingType* pMsgProcType
	)
{
	long lCounter = 0;

	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	try
	{
		// Check that the supplied index is within range.
		if ((lTriggerIndex < 0) || (numeric_cast<DWORD>(lTriggerIndex) > m_mapTriggers.size()))
		{
			SetComClassError(MQTRIG_INVALID_PARAMETER);
			return MQTRIG_INVALID_PARAMETER;
		}

		TRIGGER_MAP::iterator it = m_mapTriggers.begin();

		// Move to the lTriggerIndex-th location in the triggers map
		for (lCounter=0; lCounter < lTriggerIndex;lCounter++,++it)
		{
			NULL;
		}

		// Cast to a Trigger object reference 
		R<CRuntimeTriggerInfo> pTrigger = it->second;

		// We should never have nulls in the map
		ASSERT(pTrigger.get() != NULL);
			
		// We should only store valid triggers
		ASSERT(pTrigger->IsValid());

		// Populate out parameters if they have been supplied. 
		if (psTriggerID != NULL)
		{
			TrigReAllocString(psTriggerID,pTrigger->m_bstrTriggerID);
		}
		if (psTriggerName != NULL)
		{
			TrigReAllocString(psTriggerName,pTrigger->m_bstrTriggerName);
		}
		if(pSystemQueue != NULL)
		{
			(*pSystemQueue) = pTrigger->m_SystemQueue;
		}
		if (psQueueName != NULL)
		{
			TrigReAllocString(psQueueName,pTrigger->m_bstrQueueName);
		}
		if (plEnabledStatus != NULL)
		{
			(*plEnabledStatus) = (long)pTrigger->IsEnabled();
		}
		if (plSerialized != NULL)
		{
			(*plSerialized) = (long)pTrigger->IsSerialized();
		}
		if (plNumberOfRules != NULL)
		{
			(*plNumberOfRules) = pTrigger->GetNumberOfRules();
        }
		if (pMsgProcType != NULL)
		{
			(*pMsgProcType) = pTrigger->GetMsgProcessingType();
		}

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::GetRuleDetailsByTriggerIndex(
	long lTriggerIndex,
	long lRuleIndex,
	BSTR *psRuleID,
	BSTR *psRuleName,
	BSTR *psDescription,
	BSTR *psCondition,
	BSTR *psAction ,
	BSTR *psImplementationProgID,
	BOOL *pfShowWindow
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	HRESULT hr = S_OK;
	long lCounter = 0;
	CRuntimeRuleInfo * pRule = NULL;

	try
	{
		// We need to validate that the supplied rule index is within range
 		if ((lTriggerIndex < 0) || (numeric_cast<DWORD>(lTriggerIndex) > m_mapTriggers.size()))
		{
			TrERROR(GENERAL, "Invalid trigger ID passed to GetRuleDetailsByTriggerIndex. lTriggerIndex = %d", lTriggerIndex);

			SetComClassError(MQTRIG_INVALID_PARAMETER);
			return MQTRIG_INVALID_PARAMETER;
		}

		if SUCCEEDED(hr)
		{
			// Get a reference to the beginging of the map
			TRIGGER_MAP::iterator i = m_mapTriggers.begin();

			// Iterate through to the correct index. 
			for (lCounter = 0; lCounter < lTriggerIndex ; ++i,lCounter++)
			{
				NULL;
			}

			// Cast to a rule object reference 
			R<CRuntimeTriggerInfo> pTrigger = i->second;

			// We should never have nulls in the map
			ASSERT(pTrigger.get() != NULL);

			// We should only store valid triggers.
			ASSERT(pTrigger->IsValid());

			// Validate the supplied rule index against the number rule attached to this trigger
			if ((lRuleIndex < 0) || (lRuleIndex > pTrigger->GetNumberOfRules()))
			{
				TrERROR(GENERAL, "Invalid rule index passed to GetRuleDetailsByTriggerIndex. lRuleIndex = %d", lRuleIndex);

				SetComClassError(MQTRIG_INVALID_PARAMETER);
				return MQTRIG_INVALID_PARAMETER;
			}

			pRule = pTrigger->GetRule(lRuleIndex);

			// We should never get a null rule after validating the index.
			ASSERT(pRule != NULL);
		
			// We should never get invalid rule definitions
			ASSERT(pRule->IsValid());

			// Populate out parameters if they have been supplied. 
            if (psRuleID != NULL)
            {
                TrigReAllocString(psRuleID,pRule->m_bstrRuleID);
            }
			if (psRuleName != NULL)
			{
				TrigReAllocString(psRuleName,pRule->m_bstrRuleName);
			}
			if(psDescription != NULL)
			{
				TrigReAllocString(psDescription,pRule->m_bstrRuleDescription);
			}
			if (psCondition != NULL)
			{
				TrigReAllocString(psCondition,pRule->m_bstrCondition);
			}
			if (psAction != NULL)
			{
				TrigReAllocString(psAction,pRule->m_bstrAction);
			}
			if (psImplementationProgID != NULL)
			{
				TrigReAllocString(psImplementationProgID,pRule->m_bstrImplementationProgID);
			}
			if(pfShowWindow != NULL)
			{
				*pfShowWindow = pRule->m_fShowWindow;
			}
        }
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

	return hr;
}

//************************************************************************************
//
// Method      :
//
// Description :
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::GetRuleDetailsByTriggerID(
	BSTR sTriggerID,
	long lRuleIndex,
	BSTR *psRuleID,
	BSTR *psRuleName,
	BSTR *psDescription,
	BSTR *psCondition,
	BSTR *psAction,
	BSTR *psImplementationProgID,
	BOOL *pfShowWindow
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
		{
			TrERROR(GENERAL, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_ID);
			return MQTRIG_INVALID_TRIGGER_ID;
		}



		// find this trigger in the trigger map
		TRIGGER_MAP::iterator it;
		R<CRuntimeTriggerInfo> pTrigger;
		
		HRESULT hr = FindTriggerInMap(sTriggerID, pTrigger, it);
		if (hr != S_OK)
		{
			SetComClassError(hr);
			return hr;
		}

		// Validate that the specified trigger actually has rules.
		if (pTrigger->GetNumberOfRules() < 1)
		{
			TrERROR(GENERAL, "The supplied trigger id has no rules attached. trigger: %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_RULE_NOT_ATTACHED);
			return MQTRIG_RULE_NOT_ATTACHED;
		}

		// Validate the supplied rule index against the number rule attached to this trigger
		if ((lRuleIndex < 0) || (lRuleIndex >= pTrigger->GetNumberOfRules()))
		{
			TrERROR(GENERAL, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_PARAMETER);
			return MQTRIG_INVALID_PARAMETER;
		}

		// Get a reference to the rule at the specified index.
		CRuntimeRuleInfo* pRule = pTrigger->GetRule(lRuleIndex);

		// We should never get a null rule after validating the index.
		ASSERT(pRule != NULL);

		// We should never get invalid rule definitions
		ASSERT(pRule->IsValid());

		// Populate out parameters if they have been supplied. 
		if (psRuleID != NULL)
		{
			TrigReAllocString(psRuleID,pRule->m_bstrRuleID);
		}
		if (psRuleName != NULL)
		{
			TrigReAllocString(psRuleName,pRule->m_bstrRuleName);
		}
		if(psDescription != NULL)
		{
			TrigReAllocString(psDescription,pRule->m_bstrRuleDescription);
		}
		if (psCondition != NULL)
		{
			TrigReAllocString(psCondition,pRule->m_bstrCondition);
		}
		if (psAction != NULL)
		{
			TrigReAllocString(psAction,pRule->m_bstrAction);
		}
		if (psImplementationProgID != NULL)
		{
			TrigReAllocString(psImplementationProgID,pRule->m_bstrImplementationProgID);
		}
		if(pfShowWindow != NULL)
		{
			*pfShowWindow = pRule->m_fShowWindow;
		}

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : AddTrigger
//
// Description : This method will add a new trigger to the underlying trigger store. It
//               will create a new trigger (a GUID in string form) and attempt to insert
//               this into the registry. 
//
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::AddTrigger(
	BSTR sTriggerName, 
	BSTR sQueueName, 
	SystemQueueIdentifier SystemQueue, 
	long lEnabled, 
	long lSerialized, 
	MsgProcessingType msgProcType,
	BSTR * psTriggerID
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	HRESULT hr = S_OK;
	TRIGGER_MAP::iterator i;
	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerName(sTriggerName))
		{
			TrERROR(GENERAL, "Invalid trigger name passed to AddTrigger. sTriggerName = %ls", (LPCWSTR)sTriggerName);

			SetComClassError(MQTRIG_INVALID_TRIGGER_NAME);
			return MQTRIG_INVALID_TRIGGER_NAME;
		}

		if SUCCEEDED(hr)
		{
			if(SystemQueue == SYSTEM_QUEUE_NONE)
			{
				if (!CRuntimeTriggerInfo::IsValidTriggerQueueName(sQueueName))
				{
					TrERROR(GENERAL, "Invalid queue name passed to AddTrigger. sQueueName = %ls", (LPCWSTR)sQueueName);

					SetComClassError(MQTRIG_INVALID_TRIGGER_QUEUE);
					return MQTRIG_INVALID_TRIGGER_QUEUE;
				}
			}
		}

		if SUCCEEDED(hr)
		{
			_bstr_t bstrUpdatedQueueName;
			_bstr_t bstrMachineName;

			if(SystemQueue != SYSTEM_QUEUE_NONE) //one of the system queues is selected
			{
				//generate format name for the selected system queue
				hr = GenSystemQueueFormatName(SystemQueue, &bstrUpdatedQueueName);
				if(hr != S_OK)
				{
					TrERROR(GENERAL, "Failed to generate system queue format name. Error=0x%x", hr);

					SetComClassError(MQTRIG_ERROR_COULD_NOT_ADD_TRIGGER);
					return MQTRIG_ERROR_COULD_NOT_ADD_TRIGGER;
				}
			}
			else //queue path given
			{
				//
				// if queue name contains "." as machine name, replace it with the
				// local machine name
				//
				DWORD dwError = GetLocalMachineName(&bstrMachineName);
				if(dwError != 0)
				{
					TrERROR(GENERAL, "Failed to retreive local machine queue. Error=0x%x", dwError);

					SetComClassError(MQTRIG_ERROR_COULD_NOT_ADD_TRIGGER);
					return MQTRIG_ERROR_COULD_NOT_ADD_TRIGGER;
				}
					
				UpdateMachineNameInQueuePath(
						sQueueName,
						bstrMachineName,
						&bstrUpdatedQueueName );
			}

			//
			// Allow only one receive trigger per queue
			//
			if (msgProcType != PEEK_MESSAGE &&
				ExistTriggersForQueue(bstrUpdatedQueueName))
			{
				TrERROR(GENERAL, "Failed to add new trigger. Multiple trigger isn't allowed on receive trigger");

				SetComClassError(MQTRIG_ERROR_MULTIPLE_RECEIVE_TRIGGER );
				return MQTRIG_ERROR_MULTIPLE_RECEIVE_TRIGGER;
			}

			if (msgProcType == PEEK_MESSAGE &&
					 ExistsReceiveTrigger(bstrUpdatedQueueName))
			{
				TrERROR(GENERAL, "Failed to add new trigger. Multiple trigger isn't allowed on receive trigger");

				SetComClassError(MQTRIG_ERROR_MULTIPLE_RECEIVE_TRIGGER );
				return MQTRIG_ERROR_MULTIPLE_RECEIVE_TRIGGER;
			}

			//
			// Force serialized trigger for transactional receive
			//
			if ( msgProcType == RECEIVE_MESSAGE_XACT )
			{
				lSerialized = 1;
			}

			//
			// Allocate a new trigger object
			//
			R<CRuntimeTriggerInfo> pTrigger = new CRuntimeTriggerInfo(
															CreateGuidAsString(),
															sTriggerName,
															bstrUpdatedQueueName,
															m_wzRegPath,
															SystemQueue, 
															(lEnabled != 0),
															(lSerialized != 0),
															msgProcType
															);
			
			if (pTrigger->Create(m_hHostRegistry) == true)
			{
				//
				// Keep trigger ID and Queue name for later use
				//
				BSTR bstrQueueName = pTrigger->m_bstrQueueName;
				BSTR bstrTriggerID = pTrigger->m_bstrTriggerID;

				//
				// Add this trigger to map.
				//
				m_mapTriggers.insert(TRIGGER_MAP::value_type(bstrTriggerID, pTrigger));

				//
				// If we have been supplied a out parameter pointer for the new rule ID use it.
				//
				if (psTriggerID != NULL)
				{
					TrigReAllocString(psTriggerID, bstrTriggerID);
				}

				//
				// send a notification indicating that a trigger has been added to the trigger store.
				//
				NotifyTriggerAdded(bstrTriggerID, sTriggerName, bstrQueueName); 

				return S_OK;
			}
			else
			{
				// We need to delete the trigger instance object as the create failed.
				TrERROR(GENERAL, "Failed to store trigger data in registry");
				SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED );
				
				return MQTRIG_ERROR_STORE_DATA_FAILED;
			}
		}
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

	return hr;
 }

//************************************************************************************
//
// Method      : DeleteTrigger
//
// Description : This method removes a trigger definiton from the database. It will not
//               delete any rules that are attached to this trigger, however it will 
//               delete any associations between the supplied trigger id and existing 
//               rules in the database. 
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::DeleteTrigger(
	BSTR sTriggerID
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
		{
			TrERROR(GENERAL, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_ID);
			return MQTRIG_INVALID_TRIGGER_ID;
		}

		// find this trigger in the map.
    	TRIGGER_MAP::iterator it;
		R<CRuntimeTriggerInfo> pTrigger;

        long hr = FindTriggerInMap(sTriggerID,pTrigger,it);
		if (hr != S_OK)
		{
			SetComClassError(hr);
			return hr;
		}

		// Delete the Trigger from the underlying data store.
        bool f = pTrigger->Delete(m_hHostRegistry);
        if (!f)
        {
			TrERROR(GENERAL, "Failed to delete trigger from trigger set. trigget %ls", (LPCWSTR)sTriggerID);
			
			SetComClassError(MQTRIG_ERROR_COULD_NOT_DELETE_TRIGGER);
			return MQTRIG_ERROR_COULD_NOT_DELETE_TRIGGER;
        }

        // Send a notification that a trigger has been deleted from the trigger store.
		NotifyTriggerDeleted(pTrigger->m_bstrTriggerID);

		// Now remove this Trigger from our map.
		m_mapTriggers.erase(it);
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

	return S_OK;
}

//************************************************************************************
//
// Method      : 
//
// Description :
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::UpdateTrigger(
	BSTR sTriggerID, 
	BSTR sTriggerName, 
	BSTR sQueueName, 
	SystemQueueIdentifier SystemQueue, 
	long lEnabled, 
	long lSerialized,
	MsgProcessingType msgProcType
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
		{
			TrERROR(GENERAL, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_ID);
			return MQTRIG_INVALID_TRIGGER_ID;
		}

		if (!CRuntimeTriggerInfo::IsValidTriggerName(sTriggerName))
		{
			TrERROR(GENERAL, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_NAME);
			return MQTRIG_INVALID_TRIGGER_NAME;
		}

		if(SystemQueue == SYSTEM_QUEUE_NONE)
		{
			if(sQueueName != NULL)
			{
				if (!CRuntimeTriggerInfo::IsValidTriggerQueueName(sQueueName))
				{
					TrERROR(GENERAL, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

					SetComClassError(MQTRIG_INVALID_TRIGGER_QUEUE);
					return MQTRIG_INVALID_TRIGGER_QUEUE;
				}
			}
		}

		TRIGGER_MAP::iterator it;
		R<CRuntimeTriggerInfo> pTrigger;

		HRESULT hr = FindTriggerInMap(sTriggerID, pTrigger, it);
		if (hr != S_OK)
		{
			SetComClassError(hr);
			return hr;
		}

		_bstr_t bstrUpdatedQueueName;
		SystemQueueIdentifier queueType = SYSTEM_QUEUE_NONE;

		if(SystemQueue != SYSTEM_QUEUE_NONE) //one of the system queues is selected
		{
			//generate format name for the selected system queue
			hr = GenSystemQueueFormatName(SystemQueue, &bstrUpdatedQueueName);
			if(hr != S_OK)
			{
				TrERROR(GENERAL, "Failed to generate system queue format name. Error=0x%x", hr);

				SetComClassError(MQTRIG_ERROR);
				return MQTRIG_ERROR;
			}

			queueType = SystemQueue;
		}
		else if (sQueueName != NULL) //queue path given
		{
			_bstr_t bstrMachineName;
	
			//
			// if queue name contains "." as machine name, replace it with the
			// local machine name
			//
			
			DWORD dwError = GetLocalMachineName(&bstrMachineName);
			if(dwError != 0)
			{
				TrERROR(GENERAL, "Failed to retreive local machine queue. Error=0x%x", dwError);

				SetComClassError(MQTRIG_ERROR);
				return MQTRIG_ERROR;
			}
				
			UpdateMachineNameInQueuePath(
					sQueueName,
					bstrMachineName,
					&bstrUpdatedQueueName );						
			
			queueType = SYSTEM_QUEUE_NONE;
		}

		//
		// Allow only one receive trigger per queue
		//
		if ((msgProcType != PEEK_MESSAGE) && 
			(GetNoOfTriggersForQueue(bstrUpdatedQueueName) > 1))
		{
			TrERROR(GENERAL, "Failed to add new trigger. Multiple trigger isn't allowed on receive trigger");

			SetComClassError(MQTRIG_ERROR_MULTIPLE_RECEIVE_TRIGGER );
			return MQTRIG_ERROR_MULTIPLE_RECEIVE_TRIGGER;
		}

		//
		// Force serialized trigger for transactional receive
		//
		if ( msgProcType == RECEIVE_MESSAGE_XACT )
		{
			lSerialized = 1;
		}

		//
		// Update values
		//
		pTrigger->m_bstrTriggerName = (wchar_t*)sTriggerName;
		pTrigger->m_SystemQueue = queueType;
		pTrigger->m_bstrQueueName = (wchar_t*)bstrUpdatedQueueName;
		pTrigger->m_bEnabled = (lEnabled != 0)?true:false;
		pTrigger->m_bSerialized = (lSerialized != 0)?true:false;
		pTrigger->SetMsgProcessingType(msgProcType);

		if (pTrigger->Update(m_hHostRegistry) == true)
		{			
			// send a notification indicating that a trigger in the trigger store has been updated.
			NotifyTriggerUpdated(
				pTrigger->m_bstrTriggerID,
				pTrigger->m_bstrTriggerName,
				pTrigger->m_bstrQueueName
				);

			return S_OK;
		}

		TrERROR(GENERAL, "Failed to store the updated data for trigger: %ls in registry", (LPCWSTR)pTrigger->m_bstrTriggerID);
		
		SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
		return MQTRIG_ERROR_STORE_DATA_FAILED;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : DetachAllRules
//
// Description : 
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::DetachAllRules(
	BSTR sTriggerID
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
		{
			TrERROR(GENERAL, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_ID);
			return MQTRIG_INVALID_TRIGGER_ID;
		}


		//
		// find this trigger in the map
		//
		TRIGGER_MAP::iterator it;
		R<CRuntimeTriggerInfo> pTrigger;
		HRESULT hr = FindTriggerInMap(sTriggerID, pTrigger, it);
		if (hr != S_OK)
		{
			SetComClassError(hr);
			return hr;
		}

		// Attempt to detach the rule.
		if (!pTrigger->DetachAllRules(m_hHostRegistry))
		{
			TrERROR(GENERAL, "Failed to store the updated data for trigger: %ls in registry", (LPCWSTR)pTrigger->m_bstrTriggerID);
			
			SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
			return MQTRIG_ERROR_STORE_DATA_FAILED;
		}

		NotifyTriggerUpdated(sTriggerID, pTrigger->m_bstrTriggerName, pTrigger->m_bstrQueueName);
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

	return S_OK;
}

//************************************************************************************
//
// Method      : AttachRule
//
// Description :
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::AttachRule(
	BSTR sTriggerID, 
	BSTR sRuleID, 
	long lPriority
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
		{
			TrERROR(GENERAL, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_ID);
			return MQTRIG_INVALID_TRIGGER_ID;
		}

		if (!CRuntimeRuleInfo::IsValidRuleID(sRuleID))
		{
			TrERROR(GENERAL, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_RULEID);
			return MQTRIG_INVALID_RULEID;
		}		

		// find this trigger in the map
		TRIGGER_MAP::iterator it;
		R<CRuntimeTriggerInfo> pTrigger;

		HRESULT hr = FindTriggerInMap(sTriggerID, pTrigger, it);
		if (hr != S_OK)
		{
			SetComClassError(hr);
			return hr;
		}

		// Ensure that this rule is not allready attached.
		if (pTrigger->IsRuleAttached(sRuleID) == true)
		{
			TrERROR(GENERAL, "Unable to attach rule because it is already attached.");

			SetComClassError(MQTRIG_RULE_ALLREADY_ATTACHED);
			return MQTRIG_RULE_ALLREADY_ATTACHED;
		}

		// We should only store valid triggers.
		ASSERT(pTrigger->IsValid());

		if(lPriority > pTrigger->GetNumberOfRules())
		{
			TrERROR(GENERAL, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_PARAMETER);
			return MQTRIG_INVALID_PARAMETER;
		}

		// Attempt to attach the rule.
		if (pTrigger->Attach(m_hHostRegistry,sRuleID,lPriority) == false)
		{
			TrERROR(GENERAL, "Failed to store the updated data for trigger: %ls in registry", (LPCWSTR)pTrigger->m_bstrTriggerID);
			
			SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
			return MQTRIG_ERROR_STORE_DATA_FAILED;
		}

		// send a notification indicating that a trigger in the trigger store has been updated.
		NotifyTriggerUpdated(pTrigger->m_bstrTriggerID,pTrigger->m_bstrTriggerName,pTrigger->m_bstrQueueName);

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}

//************************************************************************************
//
// Method      : 
//
// Description :
//
//************************************************************************************
STDMETHODIMP 
CMSMQTriggerSet::DetachRule(
	BSTR sTriggerID, 
	BSTR sRuleID
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	try
	{
		// Validate the supplied method parameters.
		if (!CRuntimeTriggerInfo::IsValidTriggerID(sTriggerID))
		{
			TrERROR(GENERAL, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_TRIGGER_ID);
			return MQTRIG_INVALID_TRIGGER_ID;
		}

		if (!CRuntimeRuleInfo::IsValidRuleID(sRuleID))
		{
			TrERROR(GENERAL, "Invalid trigger ID passed to GetTriggerDetailsByID. sTriggerID = %ls", (LPCWSTR)sTriggerID);

			SetComClassError(MQTRIG_INVALID_RULEID);
			return MQTRIG_INVALID_RULEID;
		}		

		TRIGGER_MAP::iterator it;
		R<CRuntimeTriggerInfo> pTrigger;

		HRESULT hr = FindTriggerInMap(sTriggerID, pTrigger, it);
		if (hr != S_OK)
		{
			SetComClassError(hr);
			return hr;
		}

		// Check that this rule is really attached.
		if (pTrigger->IsRuleAttached(sRuleID) == false)
		{
			TrERROR(GENERAL, "Unable to detach rule because it is not currently attached.");
			
			SetComClassError(MQTRIG_RULE_NOT_ATTACHED);
			return MQTRIG_RULE_NOT_ATTACHED;
		}

		// We should only store valid triggers.
		ASSERT(pTrigger->IsValid());

		// Attempt to detach the rule.
		if (pTrigger->Detach(m_hHostRegistry,sRuleID) == false)
		{
			TrERROR(GENERAL, "Failed to store the updated data for trigger: %ls in registry", (LPCWSTR)pTrigger->m_bstrTriggerID);
			
			SetComClassError(MQTRIG_ERROR_STORE_DATA_FAILED);
			return MQTRIG_ERROR_STORE_DATA_FAILED;
		}

		//
		// send a notification indicating that a trigger in the trigger store has been updated.
		//
		NotifyTriggerUpdated(pTrigger->m_bstrTriggerID,pTrigger->m_bstrTriggerName,pTrigger->m_bstrQueueName);

		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to get trigger details by index");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}


//*******************************************************************
//
// Method      : PopulateTriggerMap
//
// Description : This method will populate the rule map with instances
//               of the CRuntimeTriggerInfo class based on the data found
//               in the registry. Note that this method will create the 
//               triggers data registry key if it does not already exist.
//
//*******************************************************************
bool 
CMSMQTriggerSet::PopulateTriggerMap(
	VOID
	)
{
	HKEY hTrigKey;
	try
	{
		RegEntry regMsmqTrig(m_wzRegPath, L"", 0, RegEntry::MustExist, HKEY_LOCAL_MACHINE);
		HKEY hKey = CmOpenKey(regMsmqTrig, KEY_READ);
		CRegHandle ark(hKey);

		RegEntry regTrig(REG_SUBKEY_TRIGGERS, L"", 0, RegEntry::MustExist, hKey);
		hTrigKey = CmOpenKey(regTrig, KEY_READ);

	}
	catch(const exception&)
	{
		TrERROR(GENERAL, "Failed to open the registry key: %ls\\%ls",  m_wzRegPath, REG_SUBKEY_TRIGGERS);
		return false;
	}

	CRegHandle ar(hTrigKey);


    //
	// Enumerate through the keys under the REG_SUBKEY_RULES key.
	// Each Key here should be a RuleID. As we enumerate through these keys,
	// we will populate the rules list with instance of the CRuntimeRuleInfo class.
	// If any rule fails to load, we remove it from the list.
    //
	for(DWORD index =0;; ++index)
    {
		WCHAR trigName[MAX_REGKEY_NAME_SIZE];
		DWORD len = TABLE_SIZE(trigName);

		LONG rc = RegEnumKeyEx(	
						hTrigKey,
						index,
						trigName,
						&len,
						NULL,
						NULL,
						NULL,
						NULL
						);

		if(rc == ERROR_NO_MORE_ITEMS)
		{
			return true;
		}

		if ((rc == ERROR_NOTIFY_ENUM_DIR) || (rc== ERROR_KEY_DELETED)) 
		{
			ClearTriggerMap();
			return PopulateTriggerMap();
		}

		if (rc != ERROR_SUCCESS)
		{
			TrERROR(GENERAL, "Failed to enumerate trigger. Error=%!winerr!", rc);
			return false;
		}

		R<CRuntimeTriggerInfo> pTrigger = new CRuntimeTriggerInfo(m_wzRegPath);
		HRESULT hr = pTrigger->Retrieve(m_hHostRegistry, trigName);
		
		if (FAILED(hr))
		{
			//
			// If trigger was deleted between enumeration and retrieval, just ignore
			// it. Another notification message will be recieved.
			//
			if (hr == MQTRIG_TRIGGER_NOT_FOUND)
			{
				continue;
			}
			//
			// Failed to load the rule. Log an error and delete the rule object.
			//
			TrERROR(GENERAL, "PopulateTriggerMap failed to load trigger %ls from registry.", trigName);
			return false;
		}

		//
		// At this point we have successfully loaded the rule, now insert it into the rule map.
		//
		wstring sTriggerID = pTrigger->m_bstrTriggerID;

		//
		// Check if this rule is already in the map.
		//
		if(m_mapTriggers.find(sTriggerID) == m_mapTriggers.end())
		{
			//
			// if queue name contains "." as machine name, replace it with the
			// store machine name
			//
			_bstr_t bstrOldQueueName = pTrigger->m_bstrQueueName;
			
			bool fUpdated = UpdateMachineNameInQueuePath(
								bstrOldQueueName,
								m_bstrMachineName,
								&(pTrigger->m_bstrQueueName) );

			//
			// if queue name was updated, update registry as well
			//
			if(fUpdated)
			{
				if ( !pTrigger->Update(m_hHostRegistry) )
				{
					TrERROR(GENERAL, "CMSMQTriggerSet::PopulateTriggerMap() failed becuse a duplicate rule id was found. The rule id was (%ls).", (LPCWSTR)pTrigger->m_bstrTriggerID);
				}
			}

			m_mapTriggers.insert(TRIGGER_MAP::value_type(sTriggerID,pTrigger));
		}
	}

	ASSERT(("this code shouldn't reach", 0));
	return true;
}


STDMETHODIMP 
CMSMQTriggerSet::get_TriggerStoreMachineName(
	BSTR *pVal
	)
{
	if(!m_fHasInitialized)
	{
		TrERROR(GENERAL, "trigger set object wasn't initialized. Before calling any method of TriggerSet you must initialize the object.");

		SetComClassError(MQTRIG_ERROR_TRIGGERSET_NOT_INIT);
		return MQTRIG_ERROR_TRIGGERSET_NOT_INIT;
	}

	if(pVal == NULL)
	{
		TrERROR(GENERAL, "Inavlid parameter to get_TriggerStoreMachineName");

		SetComClassError(MQTRIG_INVALID_PARAMETER);
		return MQTRIG_INVALID_PARAMETER;
	}
	
	try
	{
		TrigReAllocString(pVal, (TCHAR*)m_bstrMachineName);
		return S_OK;
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Failed to refresg rule set due to insufficient resources");

		SetComClassError(MQTRIG_ERROR_INSUFFICIENT_RESOURCES);
		return MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
}


DWORD 
CMSMQTriggerSet::GetNoOfTriggersForQueue(
	const BSTR& bstrQueueName
	) const
{
	DWORD noOfTriggers = 0;

	for(TRIGGER_MAP::const_iterator it = m_mapTriggers.begin(); it != m_mapTriggers.end(); it++)
	{
		R<CRuntimeTriggerInfo> pTrigger = it->second;

		if ( _wcsicmp( pTrigger->m_bstrQueueName, bstrQueueName ) == 0 )
		{
			++noOfTriggers;
		}
	}

	return noOfTriggers;
}


bool 
CMSMQTriggerSet::ExistTriggersForQueue(
	const BSTR& bstrQueueName
	) const
{
	for (TRIGGER_MAP::const_iterator it = m_mapTriggers.begin(); it != m_mapTriggers.end(); it++)
	{
		R<CRuntimeTriggerInfo> pTrigger = it->second;

		if ( _wcsicmp( pTrigger->m_bstrQueueName, bstrQueueName ) == 0 )
		{
			return true;
		}
	}

	return false;
}


bool 
CMSMQTriggerSet::ExistsReceiveTrigger(
	const BSTR& bstrQueueName
	) const
{
	for (TRIGGER_MAP::const_iterator it = m_mapTriggers.begin(); it != m_mapTriggers.end(); it++)
	{
		R<CRuntimeTriggerInfo> pTrigger = it->second;

		// We should never have null pointers in this map.
		ASSERT(("NULL trigger in triggers list\n", pTrigger.get() != NULL));

		if ((_wcsicmp( pTrigger->m_bstrQueueName, bstrQueueName) == 0) &&
			(pTrigger->GetMsgProcessingType() != PEEK_MESSAGE))
		{
			return true;
		}
	}

	return false;
}


void CMSMQTriggerSet::SetComClassError(HRESULT hr)
{
	WCHAR errMsg[256]; 
	DWORD size = TABLE_SIZE(errMsg);

	GetErrorDescription(hr, errMsg, size);
	Error(errMsg, GUID_NULL, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\adminmsg.cpp ===
//*******************************************************************
//
// Class Name  : CAdminMessage
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class represents a message sent to the admin 
//               thread. 
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#include "stdafx.h"
#include "adminmsg.hpp"

#include "adminmsg.tmh"

//*******************************************************************
//
// Method      : Constructor
//
// Description : 
//
//*******************************************************************
CAdminMessage::CAdminMessage(eMsgTypes eMsgType)
{
	m_eMsgType = eMsgType;
}

//*******************************************************************
//
// Method      : Destructor
//
// Description : 
//
//*******************************************************************
CAdminMessage::~CAdminMessage()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\cmsgprop.cpp ===
//*******************************************************************
//
// Class Name  : CMsgProperties
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This is a 'helper' class that encapsulates the native
//               MSMQ message structures in an object-oriented API.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#include "stdafx.h"
#include "stdfuncs.hpp"
#include "cmsgprop.hpp"

#include "cmsgprop.tmh"

//*******************************************************************
//
// Method      : Constructor
//
// Description : Creates a 'empty' instance of a message. Note that 
//               it is essential that the client of this class uses the 
//               IsValid() method imediately after construction - 
//               before using this class instance. This will guard 
//               against memory allocation failures.
//
//*******************************************************************
CMsgProperties::CMsgProperties(
	DWORD dwDefaultMsgBodySize
	) :
	m_pBody(new UCHAR[dwDefaultMsgBodySize])
{

	// Set the property for receving the Message Label Length
	m_aPropId[MSG_PROP_IDX_LABEL_LEN] = PROPID_M_LABEL_LEN;              //PropId 
	m_aVariant[MSG_PROP_IDX_LABEL_LEN].vt = VT_UI4;                      //Type 
	m_aVariant[MSG_PROP_IDX_LABEL_LEN].ulVal = MSG_LABEL_BUFFER_SIZE;               //Value 

	// Set the property for receving the Message Label 
	m_aPropId[MSG_PROP_IDX_LABEL] = PROPID_M_LABEL; // PropId
	m_aVariant[MSG_PROP_IDX_LABEL].vt = VT_LPWSTR;
	m_aVariant[MSG_PROP_IDX_LABEL].pwszVal = m_label;

	// Set the property for receving the Message Priority
	m_aPropId[MSG_PROP_IDX_PRIORITY] = PROPID_M_PRIORITY;  // PropId
	m_aVariant[MSG_PROP_IDX_PRIORITY].vt = VT_UI1;         // Type

	// Set the property for receving the Message ID
	m_aPropId[MSG_PROP_IDX_MSGID] = PROPID_M_MSGID;                    // PropId
	m_aVariant[MSG_PROP_IDX_MSGID].vt = VT_VECTOR | VT_UI1;           // Type
	m_aVariant[MSG_PROP_IDX_MSGID].caub.cElems = MSG_ID_BUFFER_SIZE ; // Value
	m_aVariant[MSG_PROP_IDX_MSGID].caub.pElems = m_msgId;

	// Set the property for receving the Message Correlation ID
	m_aPropId[MSG_PROP_IDX_MSGCORRID] = PROPID_M_CORRELATIONID;               // PropId
	m_aVariant[MSG_PROP_IDX_MSGCORRID].vt = VT_VECTOR|VT_UI1;                 // Type
	m_aVariant[MSG_PROP_IDX_MSGCORRID].caub.cElems = MSG_CORRID_BUFFER_SIZE ; // Value
	m_aVariant[MSG_PROP_IDX_MSGCORRID].caub.pElems = m_corrId; 

    // Set the property for receiving the delivery style (express or recoverable)
	m_aPropId[MSG_PROP_IDX_ARRIVEDTIME] = PROPID_M_ARRIVEDTIME;       
	m_aVariant[MSG_PROP_IDX_ARRIVEDTIME].vt = VT_UI4;                  
	m_aVariant[MSG_PROP_IDX_ARRIVEDTIME].ulVal = 0; 

	// Set the property for receiving the delivery style (express or recoverable)
	m_aPropId[MSG_PROP_IDX_SENTTIME] = PROPID_M_SENTTIME;       
	m_aVariant[MSG_PROP_IDX_SENTTIME].vt = VT_UI4;                  
	m_aVariant[MSG_PROP_IDX_SENTTIME].ulVal = 0; 

	// Set the property for sending/receiving the response queue name buffer size
	m_aPropId[MSG_PROP_IDX_RESPQNAME_LEN] = PROPID_M_RESP_QUEUE_LEN;  
	m_aVariant[MSG_PROP_IDX_RESPQNAME_LEN].vt = VT_UI4;               
	m_aVariant[MSG_PROP_IDX_RESPQNAME_LEN].ulVal = MSG_RESP_QNAME_BUFFER_SIZE_IN_TCHARS;    

	// Set the property for receiving the Response Queue Name
	m_aPropId[MSG_PROP_IDX_RESPQNAME] = PROPID_M_RESP_QUEUE;         //Property identifier.
	m_aVariant[MSG_PROP_IDX_RESPQNAME].vt = VT_LPWSTR;               //property type.
	m_aVariant[MSG_PROP_IDX_RESPQNAME].pwszVal = m_queueName; 

	// Set the property for receiving the msg body length
	m_aPropId[MSG_PROP_IDX_MSGBODY_LEN] = PROPID_M_BODY_SIZE;       
	m_aVariant[MSG_PROP_IDX_MSGBODY_LEN].vt = VT_UI4;                  
	m_aVariant[MSG_PROP_IDX_MSGBODY_LEN].ulVal = dwDefaultMsgBodySize; 

	// Set the property for receving the msg body itself
	m_aPropId[MSG_PROP_IDX_MSGBODY] = PROPID_M_BODY;               
	m_aVariant[MSG_PROP_IDX_MSGBODY].vt = VT_VECTOR|VT_UI1; 
	m_aVariant[MSG_PROP_IDX_MSGBODY].caub.cElems = dwDefaultMsgBodySize;  
	m_aVariant[MSG_PROP_IDX_MSGBODY].caub.pElems = m_pBody.get(); 

	m_aPropId[MSG_PROP_IDX_MSGBODY_TYPE] = PROPID_M_BODY_TYPE;       
	m_aVariant[MSG_PROP_IDX_MSGBODY_TYPE].vt = VT_UI4;                  
	m_aVariant[MSG_PROP_IDX_MSGBODY_TYPE].ulVal = 0; 
	 
	// Set the property for receiving the application specific unsigned int value.
	m_aPropId[MSG_PROP_IDX_APPSPECIFIC] = PROPID_M_APPSPECIFIC;       
	m_aVariant[MSG_PROP_IDX_APPSPECIFIC].vt = VT_UI4;                  
	m_aVariant[MSG_PROP_IDX_APPSPECIFIC].ulVal = 0;    

	// Set the property for sending/receiving the Admin queue name buffer size
	m_aPropId[MSG_PROP_IDX_ADMINQNAME_LEN] = PROPID_M_ADMIN_QUEUE_LEN;  
	m_aVariant[MSG_PROP_IDX_ADMINQNAME_LEN].vt = VT_UI4;               
	m_aVariant[MSG_PROP_IDX_ADMINQNAME_LEN].ulVal = MSG_ADMIN_QNAME_BUFFER_SIZE_IN_TCHARS; 

	// Set the property for receiving the Admin Queue Name
	m_aPropId[MSG_PROP_IDX_ADMINQNAME] = PROPID_M_ADMIN_QUEUE;         
	m_aVariant[MSG_PROP_IDX_ADMINQNAME].vt = VT_LPWSTR;               
	m_aVariant[MSG_PROP_IDX_ADMINQNAME].pwszVal = m_adminQueueName; 

	// Set the property for receiving the src machine id
	m_aPropId[MSG_PROP_IDX_SRCMACHINEID] = PROPID_M_SRC_MACHINE_ID ;
	m_aVariant[MSG_PROP_IDX_SRCMACHINEID].vt = VT_CLSID;
	m_aVariant[MSG_PROP_IDX_SRCMACHINEID].puuid = &m_srcQmId;

	// Set the property for receiving the message lookup id
	m_aPropId[MSG_PROP_IDX_LOOKUP_ID] = PROPID_M_LOOKUPID;
	m_aVariant[MSG_PROP_IDX_LOOKUP_ID].vt = VT_UI8;
    m_aVariant[MSG_PROP_IDX_LOOKUP_ID].uhVal.QuadPart = 0;

	// Set the MQMSGPROPS structure with the property arrays defined above.
	m_msgProps.cProp = MSG_PROPERTIES_TOTAL_COUNT; // Number of properties.
	m_msgProps.aPropID = m_aPropId;               // Ids of properties.
	m_msgProps.aPropVar = m_aVariant;             // Values of properties.
	m_msgProps.aStatus = NULL;                     // No Error report. 

	// Initialise allocated memory
	ClearValues();

}

//*******************************************************************
//
// Method      : Destructor	
//
// Description : Destroys and deallocates this message object.
//
//*******************************************************************
CMsgProperties::~CMsgProperties()
{
}

//*******************************************************************
//
// Method      : IsValid	
//
// Description : Returns a boolean value indicating if this object 
//               instance is currently in a valid state.
//
//*******************************************************************
bool CMsgProperties::IsValid() const
{
	return((m_aVariant[MSG_PROP_IDX_MSGID].caub.pElems != NULL) &&
	       (m_aVariant[MSG_PROP_IDX_MSGCORRID].caub.pElems != NULL) &&
		   (m_aVariant[MSG_PROP_IDX_MSGBODY].caub.pElems != NULL) &&
	       (m_aVariant[MSG_PROP_IDX_LABEL].pwszVal != NULL) &&	
		   (m_aVariant[MSG_PROP_IDX_RESPQNAME].pwszVal != NULL) &&
		   (m_aVariant[MSG_PROP_IDX_ADMINQNAME].pwszVal != NULL) &&
		   (m_aVariant[MSG_PROP_IDX_SRCMACHINEID].puuid != NULL)); 
}

//*******************************************************************
//
// Method      : ClearValues
//
// Description : Initializes allocated memory for this message.
//
//*******************************************************************
void CMsgProperties::ClearValues()
{
	// Only initialize structures if this is a valid message object.
	if (IsValid())
	{
		ZeroMemory(m_aVariant[MSG_PROP_IDX_MSGCORRID].caub.pElems,MSG_CORRID_BUFFER_SIZE);
		ZeroMemory(m_aVariant[MSG_PROP_IDX_MSGID].caub.pElems,MSG_ID_BUFFER_SIZE);
		ZeroMemory(m_aVariant[MSG_PROP_IDX_MSGBODY].caub.pElems,GetMsgBodyLen());
		ZeroMemory(m_aVariant[MSG_PROP_IDX_LABEL].pwszVal,MSG_LABEL_BUFFER_SIZE);
		ZeroMemory(m_aVariant[MSG_PROP_IDX_RESPQNAME].pwszVal,(MSG_RESP_QNAME_BUFFER_SIZE_IN_TCHARS * sizeof(TCHAR)));
		ZeroMemory(m_aVariant[MSG_PROP_IDX_ADMINQNAME].pwszVal,(MSG_ADMIN_QNAME_BUFFER_SIZE_IN_TCHARS * sizeof(TCHAR)));	          
		ZeroMemory(m_aVariant[MSG_PROP_IDX_SRCMACHINEID].puuid, sizeof(GUID));	          
	}
}

//*******************************************************************
//
// Method      : GetLabel 
//
// Description : Returns the label of the current message as a variant.
//
//*******************************************************************
_variant_t CMsgProperties::GetLabel() const
{
	// This method should only be called on a valid message object - assert this.
	ASSERT(IsValid());

	return (wchar_t*)m_aVariant[MSG_PROP_IDX_LABEL].pwszVal;
}

//*******************************************************************
//
// Method      : GetMessageID
//
// Description : Returns the current message ID as a safearray of 20
//               bytes packaged in a VARIANT.
//
//*******************************************************************
_variant_t CMsgProperties::GetMessageID() const
{
	//
	// This method should only be called on a valid message object - assert this.
	//
	ASSERT(IsValid());

	MQPROPVARIANT* pvArg = &m_aVariant[MSG_PROP_IDX_MSGID];
	ASSERT(("Invalid message ID size", pvArg->caub.cElems == PROPID_M_MSGID_SIZE));

	//
	// Initialise the dimension structure for the safe array.
	//
	SAFEARRAYBOUND aDim[1];
	aDim[0].lLbound = 0;
	aDim[0].cElements = PROPID_M_MSGID_SIZE;

	_variant_t vMessageID;
	vMessageID.vt = VT_ERROR;
	vMessageID.parray = NULL;
	
	//
	// Create a safearray of bytes
	//
	SAFEARRAY* psaBytes = SafeArrayCreate(VT_UI1,1,aDim);

	//
	// Check that we created the safe array OK.
	//
	if (psaBytes == NULL)
		return vMessageID;
	
	BYTE* pByteBuffer = NULL;
	HRESULT hr = SafeArrayAccessData(psaBytes, (void**)&pByteBuffer);

	if (FAILED(hr))
	{
		SafeArrayDestroy(psaBytes);
		return vMessageID;
	}
	
	//
	// set the return value.
	//
	memcpy(pByteBuffer, pvArg->caub.pElems, PROPID_M_MSGID_SIZE);

	vMessageID.vt = VT_ARRAY | VT_UI1;
	vMessageID.parray = psaBytes;

	hr = SafeArrayUnaccessData(vMessageID.parray);

	if FAILED(hr)
	{
		SafeArrayDestroy(psaBytes);
		vMessageID.vt = VT_ERROR;
		vMessageID.parray = NULL;
	}

	return vMessageID;
}

//*******************************************************************
//
// Method      : GetCorrelationID
//
// Description : Returns the current correlation ID as a safearray of 
//               20 bytes packaged in a _variant_t.
//
//*******************************************************************
_variant_t CMsgProperties::GetCorrelationID() const
{
	//
	// This method should only be called on a valid message object - assert this.
	//
	ASSERT(IsValid());

	MQPROPVARIANT* pvArg = &m_aVariant[MSG_PROP_IDX_MSGCORRID];
	ASSERT(("Invalid message ID size", pvArg->caub.cElems == PROPID_M_CORRELATIONID_SIZE));

	//
	// Initialise the dimension structure for the safe array.
	//
	SAFEARRAYBOUND aDim[1];
	aDim[0].lLbound = 0;
	aDim[0].cElements = PROPID_M_CORRELATIONID_SIZE;


	_variant_t vCorrelationID;
	vCorrelationID.vt = VT_ERROR;
	vCorrelationID.parray = NULL;
	
	//
	// Create a safearray of bytes
	//
	SAFEARRAY* psaBytes = SafeArrayCreate(VT_UI1,1,aDim);

	//
	// Check that we created the safe array OK.
	//
	if (psaBytes == NULL)
		return vCorrelationID;
	
	BYTE* pByteBuffer = NULL;
	HRESULT hr = SafeArrayAccessData(psaBytes, (void**)&pByteBuffer);

	if (FAILED(hr))
	{
		SafeArrayDestroy(psaBytes);
		return vCorrelationID;
	}
	
	//
	// set the return value.
	//
	memcpy(pByteBuffer, pvArg->caub.pElems, PROPID_M_CORRELATIONID_SIZE);

	vCorrelationID.vt = VT_ARRAY | VT_UI1;
	vCorrelationID.parray = psaBytes;

	hr = SafeArrayUnaccessData(vCorrelationID.parray);

	if FAILED(hr)
	{
		SafeArrayDestroy(psaBytes);
		vCorrelationID.vt = VT_ERROR;
		vCorrelationID.parray = NULL;
	}

	return vCorrelationID;
}

//*******************************************************************
//
// Method      : GetPriority
//
// Description : Returns the current message priority as a long value.
//               Note that smaller values represent higher priority.
//
//*******************************************************************
_variant_t CMsgProperties::GetPriority() const
{
	_variant_t vPriority;

	// This method should only be called on a valid message object - assert this.
	ASSERT(IsValid());

	vPriority = (long)m_aVariant[MSG_PROP_IDX_PRIORITY].bVal;

	return(vPriority);
}

//*******************************************************************
//
// Method      : GetMsgBody
//
// Description : Returns the message body as a byte array packaged in 
//               a SafeArray.
//*******************************************************************
_variant_t CMsgProperties::GetMsgBody() const
{
	HRESULT hr = S_OK;
	_variant_t vMsgBody;
	BYTE * pByteBuffer = NULL;
	SAFEARRAY * psaBytes = NULL;
	SAFEARRAYBOUND aDim[1];
	MQPROPVARIANT * pvArg = &m_aVariant[MSG_PROP_IDX_MSGBODY];

	// This method should only be called on a valid message object - assert this.
	ASSERT(IsValid());

	// Initialise the dimension structure for the safe array.
	aDim[0].lLbound = 0;
	aDim[0].cElements = GetMsgBodyLen();

	// Create a safearray of bytes
	psaBytes = SafeArrayCreate(VT_UI1,1,aDim);

	// Check that we created the safe array OK.
	if (psaBytes == NULL)
	{ 
		hr = S_FALSE;
	}

	hr = SafeArrayAccessData(psaBytes,(void**)&pByteBuffer);

	// set the return value.
	if SUCCEEDED(hr)
	{
		// Copy the body from the message object to the safearray data buffer.
		memcpy(pByteBuffer, pvArg->caub.pElems, GetMsgBodyLen());

		// Return the safe array if created successfully.
		vMsgBody.vt = VT_ARRAY | VT_UI1;
		vMsgBody.parray = psaBytes;

		hr = SafeArrayUnaccessData(vMsgBody.parray);

		if FAILED(hr)
		{
			SafeArrayDestroy(psaBytes);
			vMsgBody.vt = VT_ERROR;
		}
	}
	else
	{
		vMsgBody.vt = VT_ERROR;
	}

	return(vMsgBody);
}

//*******************************************************************
//
// Method      : ReAllocMsgBody
//
// Description : Reallocates the buffer used to hold the message body
//               The current msg body length is used to determine the 
//               size of the new buffer.
//
//*******************************************************************
bool CMsgProperties::ReAllocMsgBody()
{
	DWORD dwBufferSize = m_aVariant[MSG_PROP_IDX_MSGBODY_LEN].ulVal;

	TrTRACE(GENERAL, "Reallocating message body. Default size was: %d. New size: %d", m_aVariant[MSG_PROP_IDX_MSGBODY].caub.cElems, dwBufferSize);

	m_pBody.free();
	m_aVariant[MSG_PROP_IDX_MSGBODY].caub.pElems = NULL;
	m_aVariant[MSG_PROP_IDX_MSGBODY].caub.cElems = 0;

	//
	// allocate new buffer
	//
	try
	{
		m_pBody = new UCHAR[dwBufferSize];

		m_aVariant[MSG_PROP_IDX_MSGBODY].caub.cElems = dwBufferSize ;  
		m_aVariant[MSG_PROP_IDX_MSGBODY].caub.pElems = m_pBody.get(); 

		ZeroMemory(m_aVariant[MSG_PROP_IDX_MSGBODY].caub.pElems, dwBufferSize);

		return TRUE;
	}
	catch(const bad_alloc&)
	{
		return FALSE;
	}
}

//*******************************************************************
//
// Method      : GetMsgBodyLen
//
// Description : Returns the length of the message body
//
//*******************************************************************
long CMsgProperties::GetMsgBodyLen() const
{
	return(m_aVariant[MSG_PROP_IDX_MSGBODY_LEN].ulVal);
}

long CMsgProperties::GetMsgBodyType() const
{
	return(m_aVariant[MSG_PROP_IDX_MSGBODY_TYPE].ulVal);
}



_variant_t CMsgProperties::GetSrcMachineId() const
{
	TCHAR* pBuffer = NULL;
	
	// This method should only be called on a valid message object - assert this.
	ASSERT(IsValid());

	RPC_STATUS status = UuidToString( m_aVariant[MSG_PROP_IDX_SRCMACHINEID].puuid, &pBuffer);
	if(status != RPC_S_OK)
	{
		return _variant_t(_T(""));
	}

	_variant_t vSrcMachineId = pBuffer;

	RpcStringFree(&pBuffer);
	
	return vSrcMachineId;
}



//*******************************************************************
//
// Method      : GetResponseQueueNameLen
//
// Description : Returns the length of the response queue name.
//
//*******************************************************************
long CMsgProperties::GetResponseQueueNameLen() const
{
	return(m_aVariant[MSG_PROP_IDX_RESPQNAME_LEN].ulVal);
}

//*******************************************************************
//
// Method      : GetResponseQueueName
//
// Description : Returns the name of the response queue for this msg.
//
//*******************************************************************
_bstr_t CMsgProperties::GetResponseQueueName() const
{
	return(m_aVariant[MSG_PROP_IDX_RESPQNAME].pwszVal);
}

//*******************************************************************
//
// Method      : GetAdminQueueNameLen
//
// Description : Returns the length of the Admin queue name.
//
//*******************************************************************
long CMsgProperties::GetAdminQueueNameLen() const
{
	return(m_aVariant[MSG_PROP_IDX_ADMINQNAME_LEN].ulVal);
}
 
//*******************************************************************
//
// Method      : GetAdminQueueName
//
// Description : Returns the name of the Admin queue for this msg.
//
//*******************************************************************
_bstr_t CMsgProperties::GetAdminQueueName() const
{
	return(m_aVariant[MSG_PROP_IDX_ADMINQNAME].pwszVal);
}

//*******************************************************************
//
// Method      : GetAppSpecific
//
// Description : Returns the application specific integer value 
//               associated with the current message.
//
//*******************************************************************
_variant_t CMsgProperties::GetAppSpecific() const
{
	_variant_t v;

	v.vt = VT_UI4;
	v.ulVal = m_aVariant[MSG_PROP_IDX_APPSPECIFIC].ulVal;

	return(v);
}



//*******************************************************************
//
// Method      : GetArrivedTime
//
// Description : Returns the time in coordinated universal time format
//               that the message arrived.
//
//*******************************************************************
_variant_t CMsgProperties::GetArrivedTime() const
{
	_variant_t vArrivedTime;

	GetVariantTimeOfTime(m_aVariant[MSG_PROP_IDX_ARRIVEDTIME].ulVal,&vArrivedTime);

	return vArrivedTime.Detach();
}

//*******************************************************************
//
// Method      : GetSentTime
//
// Description : Returns the time in coordinated universal time format
//               that the message was sent.
//
//*******************************************************************
_variant_t CMsgProperties::GetSentTime() const
{
	_variant_t vSentTime;

	GetVariantTimeOfTime(m_aVariant[MSG_PROP_IDX_SENTTIME].ulVal, &vSentTime);

	return vSentTime.Detach();
}


//*******************************************************************
//
// Method      : GetMsgLookupID 
//
// Description : Returns the label of the current message as a variant.
//
//*******************************************************************
_variant_t CMsgProperties::GetMsgLookupID(void) const
{
	// This method should only be called on a valid message object - assert this.
	ASSERT(IsValid());

    //
    // Get string representation of 64bit lookup id
    //
    TCHAR lookupId[256];
    _ui64tot(m_aVariant[MSG_PROP_IDX_LOOKUP_ID].uhVal.QuadPart, lookupId, 10);
    ASSERT(("_ui64tot failed", lookupId [0] != '\0'));

    return lookupId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\cqmanger.cpp ===
//*******************************************************************
//
// Class Name  : CQManger
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class is a container for the queue objects that the
//               MSMQ trigger service requires. This class acts as the 
//               container for the queue instances, as well as providing
//               the required locking & synchronisation for accessing 
//               the group of queues.
//
//               There are some very strict rules about the use of 
//               Queue references. They are :
//
//               (1) Any method that returns a reference to a queue object
//                   must increment it's reference count.
//
//               (2) The recipient of a queue reference must decrement the
//                   reference count when they are finished with. There is  
//                   a smart pointer class to facilitate this.
// 
//               (3) Periodically the CQmanager will be called to release
//                   expired queue objects. Only those with a reference 
//                   count of zero will actually be destroyed.
//                
//               (4) The CQManager maintains a single-writer / multiple-reader
//                   lock on behalf of all queues. Any method that adds or 
//                   removes queues must acquire a writer lock first. Any 
//                   method that returns a reference to a queue must do so 
//                   within the scope of a reader lock. 
//
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 18/12/98 | jsimpson  | Initial Release
//
//*******************************************************************
#include "stdafx.h"
#include "stdfuncs.hpp"
#include "cqmanger.hpp"
#include "ruleinfo.hpp"
#include "triginfo.hpp"
#include "Tgp.h"    
#include "CQueue.hpp"

#include "cqmanger.tmh"

using namespace std;


//*******************************************************************
//
// Method      : Constructor
//
// Description : Initializes an instance of the CQManager class.
//
//*******************************************************************
CQueueManager::CQueueManager(
	IMSMQTriggersConfigPtr pITriggersConfig
	) : 
	m_pITriggersConfig(pITriggersConfig)	 
{
}

//*******************************************************************
//
// Method      : Destructor
//
// Description : Deallocates an instance of the CQManager class.
//
//*******************************************************************
CQueueManager::~CQueueManager()
{
	CSW wl(m_rwlMapQueue);

	m_mapQueues.erase(m_mapQueues.begin(), m_mapQueues.end());
}


//*******************************************************************
//
// Method      : GetNumberOfQueues
//
// Description : Returns the number of queues currently in contained
//               by this instance of the CQueueManager
//
//*******************************************************************
long CQueueManager::GetNumberOfQueues()
{
	CSR rl(m_rwlMapQueue);

	return ((long)m_mapQueues.size());
}

//*******************************************************************
//
// Method      : RemoveQueueAtIndex
//
// Description : Removes a queue at the specified index from the 
//               queue map. Note that this will delete the queue 
//               object, consequently closing the associated queue 
//               handle and cursor handle.
//
//*******************************************************************
void CQueueManager::RemoveUntriggeredQueues(void)
{
	CSW wl(m_rwlMapQueue);

	for(QUEUE_MAP::iterator it = m_mapQueues.begin(); it != m_mapQueues.end(); )
	{
		CQueue* pQueue = it->second.get();
		ASSERT(("invalid queue object", pQueue->IsValid()));

		if (pQueue->IsTriggerExist())
		{
			++it;
			continue;
		}

		pQueue->CancelIoOperation();

		pQueue->CloseQueueHandle();

		//
		// remove this queue from the map.
		//
		it = m_mapQueues.erase(it); 
	}
}


//
// This routine is called to cancel all the pending operation for a specific thread.
// It doesn't cancel any IO operation related to other threads
//
void CQueueManager::CancelQueuesIoOperation(void)
{
	CSR rl(m_rwlMapQueue);

	for(QUEUE_MAP::iterator it = m_mapQueues.begin(); it != m_mapQueues.end(); ++it)
	{
		CQueue* pQueue = it->second.get();
		ASSERT(("invalid queue object", pQueue->IsValid()));

		pQueue->CancelIoOperation();
	}
}


void CQueueManager::ExpireAllTriggers(void)
{
	CSR rl(m_rwlMapQueue);

	for(QUEUE_MAP::iterator it = m_mapQueues.begin(); it != m_mapQueues.end(); ++it)
	{
		CQueue* pQueue = it->second.get();
		ASSERT(("invalid queue object", pQueue->IsValid()));

		pQueue->ExpireAllTriggers();
	}
}


//*******************************************************************
//
// Method      : AddQueue
//
// Description : Adds a new queue to the queue map. An attempt is made
//               to initialize the new queue object - if this succeeds
//               then the queue object is added to the map and a reference
//               to the new object is returned. If initialization fails, 
//               the queue is not added to the map and this method will 
//               return null.
//
//*******************************************************************
CQueue* 
CQueueManager::AddQueue(
	const _bstr_t& bstrQueueName,
	const _bstr_t& triggerName,
	bool fOpenForReceive,
	HANDLE * phCompletionPort
	)
{
	HRESULT hr = S_OK;
	DWORD dwDefaultMsgBodySize = 0;

	wstring sQueueName;
	
	{ //always use upper case for queue path comparison
		AP<WCHAR> wcs = new WCHAR[wcslen((WCHAR*)bstrQueueName) + 1]; 
		wcscpy((WCHAR*)wcs, (WCHAR*)bstrQueueName);
		CharUpper((WCHAR*)wcs);

		sQueueName = wcs;
	}

	// get the default msg size we expect of messages that arrive in the queue.
	dwDefaultMsgBodySize = m_pITriggersConfig->GetDefaultMsgBodySize();

	// Attempt to find the named queuue
	CSW wl(m_rwlMapQueue);
	
	QUEUE_MAP::iterator it = m_mapQueues.find(sQueueName);

	if (it != m_mapQueues.end())
	{
		CQueue* pQueue = it->second.get();
		if (!fOpenForReceive || pQueue->IsOpenedForReceive())
			return (SafeAddRef(pQueue));

		//
		// There is an existing queue, but it only opened for peaking and now 
		// we need it for receiving. remove this queue object and create a new one
		//
		ASSERT(("Trigger should not associate to queue", !pQueue->IsTriggerExist()));

		pQueue->CancelIoOperation();

		pQueue->CloseQueueHandle();

		//
		// remove this queue from the map.
		//
		m_mapQueues.erase(it); 
	}

	// The queue is not currently in the map. Create a new queue object 
	R<CQueue> pQueue = new CQueue(bstrQueueName, phCompletionPort, dwDefaultMsgBodySize);

	//  Attempt to initialise the new queue object
	hr = pQueue->Initialise(fOpenForReceive, triggerName);

	// If we failed, then release the Queue object and return NULL.
	if(FAILED(hr))
	{
		TrTRACE(GENERAL, "Failed to add a new queue: %ls. Initialization failed", static_cast<LPCWSTR>(bstrQueueName));
		return NULL;
	}

	// Add it to the map of queue maintained by the QueueManager class
	m_mapQueues.insert(QUEUE_MAP::value_type(sQueueName, pQueue));

	// Write a trace message
	TrTRACE(GENERAL, "QueueManager::AddQueue() has successfully added queue %ls", static_cast<LPCWSTR>(bstrQueueName));

	return SafeAddRef(pQueue.get());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\cqmanger.hpp ===
//*******************************************************************
//
// Class Name  : CQManager
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class is a container for the queue objects that the
//               MSMQ trigger service requires. This class acts as the 
//               container for the queue instances, as well as providing
//               the required locking & synchronisation for accessing 
//               the group of queues.
//
//               (1) Any method that returns a reference to a queue object
//                   must increment it's reference count.
//
//               (2) The recipient of a queue reference must decrement the
//                   reference count when they are finished with. There is  
//                   a smart pointer class to facilitate this.
// 
//               (3) Periodically the CQmanager will be called to release
//                   expired queue objects. Only those with a reference 
//                   count of zero will actually be destroyed.
//                
//               (4) The CQManager maintains a single-writer / multiple-reader
//                   lock on behalf of all queues. Any method that adds or 
//                   removes queues must acquire a writer lock first. Any 
//                   method that returns a reference to a queue must do so 
//                   within the scope of a reader lock. 
//
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 20/12/98 | jsimpson  | Initial Release
//
//*******************************************************************
#ifndef CQueueManager_INCLUDED 
#define CQueueManager_INCLUDED

#pragma warning(disable:4786)

// Definitions of the Queue object that this class manages
#include "cqueue.hpp"
#include "rwlock.h"

// Define a new type - a 2D map of queue-names and pointers to queue objects
typedef std::map<std::wstring, R<CQueue>, std::less<std::wstring> > QUEUE_MAP;

class CQueueManager : public CReference 
{
	friend class CTriggerMonitorPool;

	private :
		//
		// Reader writer lock protecting changes to the queue map.
		//
		CReadWriteLock m_rwlMapQueue;
		QUEUE_MAP m_mapQueues;

		HANDLE m_hIOCompletionPort;

		//
		// An interface pointer to the MSMQ Triggers Configuration COM component
		//
		IMSMQTriggersConfigPtr m_pITriggersConfig;

	protected:
		void ExpireAllTriggers(void);

	public:
		CQueueManager(IMSMQTriggersConfigPtr pITriggersConfig);
		~CQueueManager();

		// Returns the number of queue currently in the map.
		long GetNumberOfQueues();

		// Removes a queue from the queue - deleting the instance of the queue object.
		void RemoveUntriggeredQueues(void);
		void CancelQueuesIoOperation(void);

		// Adds queue to the queue returing the new reference, or the existing reference if 
		// the queue is allready present in the map. The QueueName is used as the key.
		CQueue* 
		AddQueue(
			const _bstr_t& sQueueName,
			const _bstr_t& triggerName,
			bool fOpenForReceive,
			HANDLE * phCompletionPort
			);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigobjs\trigset.hpp ===
//*****************************************************************************
//
// Class Name  : CLog
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : Implements a log object that provides the MSMQ trigger objects
//               with a single interface for writing to a log. 
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 02/01/98 | jsimpson  | Initial Release
//
//*****************************************************************************
#ifndef __MSMQTRIGGERSET_H_
#define __MSMQTRIGGERSET_H_

#include "resource.h"        

// Base class that handle receiving and sending notification msgs
#include "trignotf.hpp"

// Used to allow STL to compile without thousands of warnings.
#pragma warning(disable:4786)

// Include the definition of the CRuntimeTriggerInfo class (used to hold trigger info)
#include "triginfo.hpp"

// Define a new type - a 2D map of Trigger-ID's and pointers to instance of CRuntimeTriggerInfo
typedef std::map<std::wstring,R<CRuntimeTriggerInfo>, std::less<std::wstring> > TRIGGER_MAP;

class ATL_NO_VTABLE CMSMQTriggerSet : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CMSMQTriggerSet, &CLSID_MSMQTriggerSet>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CMSMQTriggerSet>,
	public IDispatchImpl<IMSMQTriggerSet, &IID_IMSMQTriggerSet, &LIBID_MSMQTriggerObjects>,
	public CMSMQTriggerNotification
{
	public:

		CMSMQTriggerSet();
		~CMSMQTriggerSet();

		DECLARE_REGISTRY_RESOURCEID(IDR_MSMQTRIGGERSET)
		DECLARE_GET_CONTROLLING_UNKNOWN()

		DECLARE_PROTECT_FINAL_CONSTRUCT()

		BEGIN_COM_MAP(CMSMQTriggerSet)
			COM_INTERFACE_ENTRY(IMSMQTriggerSet)
			COM_INTERFACE_ENTRY(IDispatch)
			COM_INTERFACE_ENTRY(ISupportErrorInfo)
			COM_INTERFACE_ENTRY(IConnectionPointContainer)
			COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
		END_COM_MAP()


		BEGIN_CONNECTION_POINT_MAP(CMSMQTriggerSet)
		END_CONNECTION_POINT_MAP()


		HRESULT FinalConstruct()
		{
			return CoCreateFreeThreadedMarshaler(GetControllingUnknown(), &m_pUnkMarshaler.p);
		}

		void FinalRelease()
		{
			m_pUnkMarshaler.Release();
		}

		CComPtr<IUnknown> m_pUnkMarshaler;

	private:		
		// A map of CRuntimeTriggerInfo objects keyed by Trigger ID.
		TRIGGER_MAP m_mapTriggers;

		// Used to destroy the contents of the rule map.
		void ClearTriggerMap();

		// Builds the map of triggers based on registry data.
		bool PopulateTriggerMap();

		// Used to find a trigger in the map based on the trigger id.
		long 
		FindTriggerInMap(
			BSTR sTriggerID, 
			R<CRuntimeTriggerInfo>& pTrigger,
			TRIGGER_MAP::iterator &it
			);

		// Check if exist triggers that are attached to given queue
		bool ExistTriggersForQueue(const BSTR& bstrQueueName) const;

		// Check if Receive triggers exist for the requested queue
		bool ExistsReceiveTrigger(const BSTR& bstrQueueName) const;

		DWORD GetNoOfTriggersForQueue(const BSTR& bstrQueueName) const;

		void SetComClassError(HRESULT hr);

	public:
		STDMETHOD(get_TriggerStoreMachineName)(/*[out, retval]*/ BSTR *pVal);
		STDMETHOD(Init)(/*[in]*/ BSTR bstrMachineName);
		STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

		STDMETHOD(UpdateTrigger)(/*[in]*/  BSTR sTriggerID,
			                     /*[in]*/  BSTR sTriggerName , 
								 /*[in]*/  BSTR sQueueName, 
								 /*[in]*/  SystemQueueIdentifier SystemQueue, 
								 /*[in]*/  long lEnabled , 
								 /*[in]*/  long lSerialized,
								 /*[in]*/  MsgProcessingType msgProcType);

		STDMETHOD(Refresh)();

		STDMETHOD(AddTrigger)(/*[in]*/  BSTR sTriggerName,
			                  /*[in]*/  BSTR sQueueName,
							  /*[in]*/	SystemQueueIdentifier SystemQueue, 
						 	  /*[in]*/  long lEnabled, 
							  /*[in]*/  long lSerialized,
							  /*[in]*/  MsgProcessingType msgProcType,
							  /*[out]*/ BSTR * psTriggerID);

		STDMETHOD(DeleteTrigger)(/*[in]*/  BSTR sTriggerID);

		STDMETHOD(GetRuleDetailsByTriggerID)(/*[in]*/  BSTR sTriggerID, 
		                                     /*[in]*/  long lRuleIndex, 
											 /*[out]*/ BSTR * psRuleID, 
											 /*[out]*/ BSTR * psRuleName, 
											 /*[out]*/ BSTR * psDescription,
											 /*[out]*/ BSTR * psCondition , 
											 /*[out]*/ BSTR * psAction , 
											 /*[out]*/ BSTR * psImplementationProgID, 
											 /*[out]*/ BOOL * pfShowWindow);//,
											 ///*[out]*/ long * plRefCount );
											 
		STDMETHOD(GetRuleDetailsByTriggerIndex)(/*[in]*/  long lTriggerIndex, 
		                                        /*[in]*/  long lRuleIndex, 
												/*[out]*/ BSTR *psRuleID, 
												/*[out]*/ BSTR *psRuleName, 
												/*[out]*/ BSTR * psDescription,
												/*[out]*/ BSTR *psCondition, 
												/*[out]*/ BSTR *psAction , 
												/*[out]*/ BSTR * psImplementationProgID, 
												/*[out]*/ BOOL * pfShowWindow);//,
												///*[out]*/ long * plRefCount );
												
		STDMETHOD(GetTriggerDetailsByID)(/*[in]*/  BSTR sTriggerID ,
		                                 /*[out]*/ BSTR * psTriggerName , 
										 /*[out]*/ BSTR * psQueueName, 
										 /*[out]*/ SystemQueueIdentifier* pSystemQueue, 
										 /*[out]*/ long * plNumberOfRules,
										 /*[out]*/ long * plEnabledStatus,
										 /*[out]*/ long * plSerialized,
										 /*[out]*/ MsgProcessingType * pMsgProcType);

		STDMETHOD(GetTriggerDetailsByIndex)(/*[in]*/  long lTriggerIndex , 
		                                    /*[out]*/ BSTR * psTriggerID , 
											/*[out]*/ BSTR * psTriggerName , 
											/*[out]*/ BSTR * psQueueName, 
											/*[out]*/ SystemQueueIdentifier* pSystemQueue, 
											/*[out]*/ long * plNumberOfRules,
											/*[out]*/ long * plEnabledStatus,
											/*[out]*/ long * plSerialized,
											/*[out]*/ MsgProcessingType * pMsgProcType);

		STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

		STDMETHOD(DetachRule)(/*[in]*/  BSTR sTriggerID,
			                  /*[in]*/  BSTR sRuleID);

		STDMETHOD(AttachRule)(/*[in]*/  BSTR sTriggerID ,
		                      /*[in]*/  BSTR sRuleID , 
							  /*[in] */ long lPriority);

		STDMETHOD(DetachAllRules)(/*[in]*/  BSTR sTriggerID);

};

#endif //__MSMQTRIGGERSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\cmsgprop.hpp ===
//*******************************************************************
//
// Class Name  : CMsgProperties
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This is a 'helper' class that encapsulates the native
//               MSMQ message structures in an object-oriented API.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#ifndef CMsgProperties_INCLUDED 
#define CMsgProperties_INCLUDED

// Include the definitions for MSMQ structures.
#include "mq.h"

// Define indexs for each message property into the array of message properties.
#define MSG_PROP_IDX_LABEL_LEN       0
#define MSG_PROP_IDX_LABEL           1
#define MSG_PROP_IDX_PRIORITY        2
#define MSG_PROP_IDX_MSGID           3
#define MSG_PROP_IDX_MSGCORRID       4
#define MSG_PROP_IDX_MSGBODY_LEN     5
#define MSG_PROP_IDX_MSGBODY         6
#define MSG_PROP_IDX_APPSPECIFIC     7
#define MSG_PROP_IDX_RESPQNAME_LEN   8
#define MSG_PROP_IDX_RESPQNAME       9
#define MSG_PROP_IDX_ADMINQNAME_LEN  10
#define MSG_PROP_IDX_ADMINQNAME      11
#define MSG_PROP_IDX_ARRIVEDTIME     12
#define MSG_PROP_IDX_SENTTIME        13
#define MSG_PROP_IDX_SRCMACHINEID	 14	
#define MSG_PROP_IDX_MSGBODY_TYPE    15
#define MSG_PROP_IDX_LOOKUP_ID       16

// Define the number of message properties encapsulated by this class.
#define MSG_PROPERTIES_TOTAL_COUNT   17

// Buffer sizes defined in BYTES
#define MSG_LABEL_BUFFER_SIZE       ((MQ_MAX_Q_LABEL_LEN * sizeof(TCHAR)) + sizeof(TCHAR))
#define MSG_ID_BUFFER_SIZE          20
#define MSG_CORRID_BUFFER_SIZE      20 

// Buffer sizes defined in TCHARS
#define MSG_RESP_QNAME_BUFFER_SIZE_IN_TCHARS  (MQ_MAX_Q_NAME_LEN + 1)
#define MSG_ADMIN_QNAME_BUFFER_SIZE_IN_TCHARS (MQ_MAX_Q_NAME_LEN + 1)

class CMsgProperties  
{
public:		
	CMsgProperties(DWORD dwDefaultMsgBodySize);
	~CMsgProperties();

	bool IsValid() const;

	void ClearValues();

	_variant_t GetLabel() const;
	_variant_t GetMessageID() const;
	_variant_t GetCorrelationID() const;
	_variant_t GetSrcMachineId() const;
	_variant_t GetPriority() const;

	
	long GetMsgBodyLen() const;
	bool ReAllocMsgBody();
	_variant_t GetMsgBody() const;
	long GetMsgBodyType() const;

	long GetResponseQueueNameLen() const;
	_bstr_t GetResponseQueueName() const;

	long GetAdminQueueNameLen() const;
	_bstr_t GetAdminQueueName() const;

	_variant_t GetAppSpecific() const;
	
	_variant_t GetArrivedTime() const;
	_variant_t GetSentTime() const;
    _variant_t GetMsgLookupID(void) const;

	MQMSGPROPS* GetMSMQProps(void)
	{
		return &m_msgProps;
	}

private:
	MQMSGPROPS m_msgProps;

	mutable MQPROPVARIANT m_aVariant[MSG_PROPERTIES_TOTAL_COUNT];
	MSGPROPID m_aPropId[MSG_PROPERTIES_TOTAL_COUNT]; 

	WCHAR m_label[MSG_LABEL_BUFFER_SIZE];
	UCHAR m_msgId[MSG_ID_BUFFER_SIZE];
	UCHAR m_corrId[MSG_CORRID_BUFFER_SIZE];
	WCHAR m_queueName[MSG_RESP_QNAME_BUFFER_SIZE_IN_TCHARS];
	WCHAR m_adminQueueName[MSG_ADMIN_QNAME_BUFFER_SIZE_IN_TCHARS];
	GUID m_srcQmId;

	AP<UCHAR> m_pBody;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\cqueue.cpp ===
//*******************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 20/12/98 | jsimpson  | Initial Release
//
//*******************************************************************
#include "stdafx.h"
#include "mqsymbls.h"
#include "mq.h"
#include "Ev.h"
#include "cqueue.hpp"
#include "QueueUtil.hpp"
#include "cmsgprop.hpp"
#include "triginfo.hpp"
#include "monitor.hpp"
#include "tgp.h"
#include "ss.h"

#include "cqueue.tmh"

using namespace std;

extern CCriticalSection g_csSyncTriggerInfoChange;
 
//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
CQueue::CQueue(
	const _bstr_t& bstrQueueName, 
	HANDLE * phCompletionPort,
	DWORD dwDefaultMsgBodySize
	) :
	m_fOpenForReceive(false)
{
	// Assert construction parameters
	ASSERT(phCompletionPort != NULL);

	// Initialise member variables
	m_bstrQueueName = bstrQueueName;
	m_bSerializedQueue = false;
	m_bBoundToCompletionPort = false;
	m_bInitialized = false;
	m_pReceivedMsg = NULL;
	m_phCompletionPort = phCompletionPort;
	m_dwDefaultMsgBodySize = dwDefaultMsgBodySize;

	ZeroMemory(&m_OverLapped,sizeof(m_OverLapped)); 
}

//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
CQueue::~CQueue()
{
	TrTRACE(GENERAL, "Queue %ls is being closed.", static_cast<LPCWSTR>(m_bstrQueueName));
    
    MQCloseQueue(m_hQueueReceive.detach());
}

//*******************************************************************
//
// Method      : IsValid	
//
// Description : Returns a boolean value indicating if this object 
//               instance is currently in a valid state. In the 
//               context of the CQueue object, 'Valid' means that this
//               queue object can participate is handling trigger events.
//
//*******************************************************************
bool CQueue::IsValid(void)
{
	return((m_bBoundToCompletionPort == true) && (m_phCompletionPort != NULL));
}

//*******************************************************************
//
// Method      : IsSerializedQueue
//
// Description :
//
//*******************************************************************
bool CQueue::IsSerializedQueue(void)
{
	return(m_bSerializedQueue);
}


//*******************************************************************
//
// Method      : GetTriggerByIndex
//
// Description : Returns a reference to a instance of the CRuntimeTriggerInfo
//               class.
//
//*******************************************************************
RUNTIME_TRIGGERINFO_LIST CQueue::GetTriggers(void)
{
	CS lock(g_csSyncTriggerInfoChange);
	return m_lstRuntimeTriggerInfo;
}


bool CQueue::IsTriggerExist(void)
{
	CS lock(g_csSyncTriggerInfoChange);
	return (!m_lstRuntimeTriggerInfo.empty());
}

//*******************************************************************
//
// Method      : DetachMessage
//
// Description :
//
// Returns     : A reference to a CMsgProperties class instance.
//
// NOTE        : The caller of this method assumes the responsibility
//               for deleting the message object.
//
//*******************************************************************
CMsgProperties * CQueue::DetachMessage()
{
	CMsgProperties * pTemp = m_pReceivedMsg;

	if (m_pReceivedMsg != NULL)
	{
		// Assert the validity of the message received member variable.
		ASSERT(m_pReceivedMsg->IsValid());

		m_pReceivedMsg = NULL;
	}

	return(pTemp);
}

//*******************************************************************
//
// Method      : RePeekMessage
//
// Description : This method is called when a buffer overflow error 
//               has occurred. This method will reallocate the the 
//               buffer used for collection the message body and try 
//               to peek the message again.
//
//*******************************************************************
HRESULT CQueue::RePeekMessage()
{
	HRESULT hr = S_OK;

	// This method should only be called when this object is valid - assert this.
	ASSERT(this->IsValid());

	// get the message instance to reallocate it's message body buffer
	m_pReceivedMsg->ReAllocMsgBody();

	{
		CSR rl(m_ProtectQueueHandle);
		hr = MQTRIG_ERROR;
		if (m_hQueuePeek != 0)
		{
			// peek at the current message again
			hr = MQReceiveMessage(
					m_hQueuePeek,
					0,
					MQ_ACTION_PEEK_CURRENT,
					m_pReceivedMsg->GetMSMQProps(),
					NULL,
					NULL,
					m_hQueueCursor,
					NULL
					);       
		}
	}
	return(hr);
}

//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
HRESULT CQueue::RequestNextMessage(bool bCreateCursor, bool bAlwaysPeekNext)
{
	HRESULT hr = S_OK;
	DWORD dwAction = MQ_ACTION_PEEK_NEXT;

	// This method should only be called when this object is valid - assert this.
	ASSERT(IsValid());

	// Special case processing for first time call. 
	if (bCreateCursor == true)
	{
		{
			CSR rl(m_ProtectQueueHandle);
			hr = MQTRIG_ERROR;
			if (m_hQueuePeek != 0)
			{
				// Create an MSMQ cursor.
				hr = MQCreateCursor(m_hQueuePeek, &m_hQueueCursor);
			}
		}

		if (SUCCEEDED(hr))
		{
			// On the first call - we want to peek at the current message.
			dwAction = MQ_ACTION_PEEK_CURRENT;
			TrTRACE(GENERAL, "Create new cursor for queue: %ls. Cursor 0x%p.", static_cast<LPCWSTR>(m_bstrQueueName), m_hQueueCursor);
		}
		else
		{
			// Write an error message.
			TrERROR(GENERAL, "Failed to create a cursor for queue: %ls. Error 0x%x", static_cast<LPCWSTR>(m_bstrQueueName), hr);		
		}
	}


	try
	{
		// Attempt to receive a message only if we created the cursor successfully.
		if (SUCCEEDED(hr))
		{
			//
			// Add reference before start of pending operation. From now on we'll have a pending operation 
			// whether on not MQReceiveMessage succeeds.
			//
			AddRef();

			
			// If this queue object still has a message object attached, it means that we are 
			// issuing the MQReceiveMessage() request for the same position in the queue. This 
			// only happens when one thread is picking up after another thread has exited. If 
			// we do not have a message object attached, then we are issuing the request for the 
			// next location in the queue - in which case we will need to allocate another msg object.
			if (m_pReceivedMsg == NULL)
			{
				// Create a new message properties structure - and check that it is valid.
				m_pReceivedMsg = new CMsgProperties(m_dwDefaultMsgBodySize);
			}
			else if (bAlwaysPeekNext == false)
			{
				// We had a asynchronous failure and called this function again. We still need 
				// to receive the message in the current position of the cursor.
				
				// Assert the validity of the message received member variable.
				ASSERT(m_pReceivedMsg->IsValid());

				dwAction = MQ_ACTION_PEEK_CURRENT;
			}
			else
			{
				// We had a synchronous failure of MQReceiveMessage and the cursor was not moved forward yet.
				//
				// Assert the validity of the message received member variable.
				ASSERT(m_pReceivedMsg->IsValid());
			}
		
			// Request the next message
			{
				CSR rl(m_ProtectQueueHandle);
				hr = MQTRIG_ERROR;
				if (m_hQueuePeek != 0)
				{
					hr = MQReceiveMessage( 
							m_hQueuePeek,
							INFINITE,
							dwAction,
							m_pReceivedMsg->GetMSMQProps(),
							&m_OverLapped,
							NULL,
							m_hQueueCursor,
							NULL );                   
				}
			}


			//
			// SPECIAL CASE processing. We received a message from the queue immediately, but the 
			// preallocated body buffer length was insufficient. We will reallocate the body buffer 
			// and try again and let the return code processing continue.
			//
			if (hr == MQ_ERROR_BUFFER_OVERFLOW)
			{
				m_pReceivedMsg->ReAllocMsgBody();
				{
					CSR rl(m_ProtectQueueHandle);
					hr = MQTRIG_ERROR;
					if (m_hQueuePeek != 0)
					{
				    	hr = MQReceiveMessage(
									m_hQueuePeek,
									INFINITE,
									MQ_ACTION_PEEK_CURRENT,
									m_pReceivedMsg->GetMSMQProps(), 
									&m_OverLapped,
									NULL, 
									m_hQueueCursor,
									NULL
									);                   								
					}
				}
			}

			switch(hr)
			{
				case MQ_INFORMATION_OPERATION_PENDING :
				{
					// no message on the queue at the moment - this is ok
					hr = S_OK;
					break;
				}
				case MQ_OK :
				{
					// this is OK - we received a message immediately.
					hr = S_OK;
					break;
				}
				case MQ_ERROR_SERVICE_NOT_AVAILABLE:
				case MQ_ERROR_STALE_HANDLE:
				case MQ_ERROR_QUEUE_DELETED:
				{
					// MSMQ on the local machine is not available or was restarted or the queue was deleted.
					TrERROR(GENERAL, "Failed to receive a message from queue: %ls. Error %!hresult!", (LPCWSTR)m_bstrQueueName, hr);	

					// Release the reference for the asynchronous operation.
					Release();
					break;
				}
				default:
				{
					// an unexpected error has occurred.
					TrERROR(GENERAL, "Failed to receive a message from queue: %ls. Error 0x%x", (LPCWSTR)m_bstrQueueName, hr);		

					Sleep(2000);
				
					if (!PostQueuedCompletionStatus(*m_phCompletionPort,0,TRIGGER_RETRY_KEY,&m_OverLapped))
					{
						TrERROR(GENERAL, "Failed to post a messages to the IOCompletionPort. Error=%!winerr!", GetLastError());
						Release();
					}

					break;
				}
			}
		}
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "Got bad_alloc in RequestNextMessage");
		
		Sleep(2000);
		
		if (!PostQueuedCompletionStatus(*m_phCompletionPort,0,TRIGGER_RETRY_KEY,&m_OverLapped))
		{
			TrERROR(GENERAL, "Failed to post a messages to the IOCompletionPort. Error=%!winerr!.", GetLastError());
			Release();
		}
		hr = MQ_ERROR_INSUFFICIENT_RESOURCES;
	}
	
	return(hr);
}


static CSafeSet < _bstr_t > s_reportedQueues;

HRESULT 
CQueue::OpenQueue(
    DWORD dwAction, 
    HANDLE* pQHandle, 
    const _bstr_t& triggerName
)
{
    HRESULT hr = ::OpenQueue(
		            m_bstrQueueName, 
		            dwAction,
		            false,
		            pQHandle,
		            &m_bstrFormatName
		            );

	if(SUCCEEDED(hr))
        return S_OK;

    if (s_reportedQueues.insert(m_bstrQueueName))
	{
		//
		// First time MSMQ triggers try to open the queue and failes. Carete an 
		// event log message
		//
		if (hr == MQ_ERROR_QUEUE_NOT_FOUND)
		{
			EvReport(MSMQ_TRIGGER_QUEUE_NOT_FOUND, 2, static_cast<LPCWSTR>(m_bstrQueueName), static_cast<LPCWSTR>(triggerName));
			return hr;
		}

		WCHAR strError[256];
		swprintf(strError, L"0x%x", hr);

		EvReport(MSMQ_TRIGGER_OPEN_QUEUE_FAILED, 3, static_cast<LPCWSTR>(m_bstrQueueName), strError, static_cast<LPCWSTR>(triggerName));
	}

	return hr;
}


//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
HRESULT
CQueue::Initialise(
	bool fOpenForReceive,
	const _bstr_t& triggerName
	)
{
	ASSERT(("Attempt to initialize already initilaized queue.\n", !m_bInitialized));
		
	HRESULT	hr = OpenQueue(MQ_PEEK_ACCESS, &m_hQueuePeek, triggerName);
    if (FAILED(hr))
        return hr;

	if (fOpenForReceive)
    {
        hr = OpenQueue(MQ_RECEIVE_ACCESS, &m_hQueueReceive, triggerName);
        if (FAILED(hr))
            return hr;

    	//
	    // Store if the queue opened for recieve or not. This flag is used when attaching a 
	    // new receive trigger to a queue. if the queue already opened for peaking only, the
	    // queue object can't be used for receiving trigger and new queue should be created
	    //
	    m_fOpenForReceive = fOpenForReceive;
    }


	//
	// Queue is opened, bind to the supplied IO Completion port.
	//
 	hr = BindQueueToIOPort();
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to bind queue handle to completion port. Queue %ls initilization failed. Error 0x%x", (LPCWSTR)m_bstrQueueName, hr);
		return hr;
	}

	//
	// Queue is bound, request first message.
	//
	hr = RequestNextMessage(true, false);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to receive a message from queue: %ls. Queue initilization failed. Error 0x%x", (LPCWSTR)m_bstrQueueName, hr);
		return hr;
	}

	m_bInitialized = true;
	TrTRACE(GENERAL, "Queue: %ls initilization completed successfully", static_cast<LPCWSTR>(m_bstrQueueName));
	
	return S_OK;
}


//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
HRESULT CQueue::BindQueueToIOPort()
{
	HRESULT hr = S_OK;
	HANDLE hTemp = NULL;

	ASSERT(m_phCompletionPort != NULL);

	// This implementation of the CQueue object only allows the queue object to be bound
	// to one completion port - once only.
	if (m_bBoundToCompletionPort == false)
	{
		// Attempt to bind - use the reference to the runtime info as our completion key.
		{
			CSR rl(m_ProtectQueueHandle);
			if (m_hQueuePeek != 0)
			{
				hTemp = CreateIoCompletionPort(m_hQueuePeek, (*m_phCompletionPort), 0, 0);
			}
		}

		// Attempt to open the queue that this Monitor watches.
		if (hTemp != NULL)
		{
			// Set member var to indicate that this queue is bound
			m_bBoundToCompletionPort = true;
			TrTRACE(GENERAL, "Successfully bound queue: %ls to IO port", static_cast<LPCWSTR>(m_bstrQueueName));		
		} 
		else
		{
			// Write a log message to indicate what failed.
			TrERROR(GENERAL, "Failed to bind queue: %ls to io port. Error %d", (LPCWSTR)m_bstrQueueName, GetLastError());
			hr = MQTRIG_ERROR;
		}
	}

	return (hr);
}


void CQueue::ExpireAllTriggers()
{
	CS lock(g_csSyncTriggerInfoChange);

	m_lstRuntimeTriggerInfo.erase(m_lstRuntimeTriggerInfo.begin(), m_lstRuntimeTriggerInfo.end());
	m_bSerializedQueue = false;
}


//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
void CQueue::AttachTrigger(R<CRuntimeTriggerInfo>& pTriggerInfo)
{
	// This method should only be called when this object is valid - assert this.
	ASSERT(IsValid());

	//
	// Test if this trigger is serialized - if it is, then this entire queue (i.e. all triggers
	// attached to this queue are serialized).
	//
	if(pTriggerInfo->IsSerialized())
	{
		m_bSerializedQueue = true;
	}

	//
	// Add this to our list of run-time trigger info objects
	//
	m_lstRuntimeTriggerInfo.push_back(pTriggerInfo);
}



HRESULT CQueue::ReceiveMessageByLookupId(_variant_t lookupId)
{
	ASSERT(("Queue is not a Message Receive Queue", m_hQueueReceive != 0));

	ULONGLONG ulLookupID = _ttoi64(lookupId.bstrVal);

	HRESULT hr = MQReceiveMessageByLookupId(
						m_hQueueReceive,
						ulLookupID,
						MQ_LOOKUP_RECEIVE_CURRENT,
						NULL,
						NULL,
						NULL,
						NULL
						);

	//
	// If message does not exist already - it is not an error
	//
	if ( hr == MQ_ERROR_MESSAGE_NOT_FOUND )
	{
		TrERROR(GENERAL, "Failed to receive message from queue: %ls with lookupid. Error 0x%x", (LPCWSTR)m_bstrQueueName, hr);
		return S_OK;
	}

	return hr;
}


_variant_t CQueue::GetLastMsgLookupID()
{
	return m_vLastMsgLookupID;
}


void CQueue::SetLastMsgLookupID(_variant_t vLastMsgLookupId)
{
	m_vLastMsgLookupID = vLastMsgLookupId;
}


void CQueue::CancelIoOperation(void)
{	
	CSR rl(m_ProtectQueueHandle);
	if (m_hQueuePeek != 0)
	{
		CancelIo(m_hQueuePeek); 
	}
}

void CQueue::CloseQueueHandle(void)
{
	//
	// Close the queue handle, so that IO operations 
	// initiated by other threads for this queue will be cancelled.
	//
	CSW wl(m_ProtectQueueHandle);
	MQCloseQueue(m_hQueuePeek.detach());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\cthread.cpp ===
//*******************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#include "stdafx.h"
#include "cthread.hpp"
#include "tgp.h"

#include "cthread.tmh"

//*******************************************************************
//
// Method      : Constructor 
//
// Description : Constructs a thread object. Key tasks performed by 
//               the constructor are :
//
//               1 - Attach a reference to the Triggers Config COM obj
//               2 - Initialize thread parameters (stack size etc...)
//               3 - Create a new thread
//               4 - Create the new thread name
//               5 - Create an instance of the log for this thread.
//               6 - Create an NT event used to signal when this thread
//                   has completed it's intialization code.
//
//*******************************************************************
CThread::CThread(
	DWORD dwStackSize,
	DWORD m_dwCreationFlags, 
	LPTSTR lpszThreadName,
	IMSMQTriggersConfigPtr pITriggersConfig
	) :
	m_pITriggersConfig(pITriggersConfig)
{
	TCHAR szThreadID[10];

	ASSERT(lpszThreadName != NULL);
	ASSERT(pITriggersConfig != NULL);

	// Initialise the psuedo this pointer
	m_pThis = (CThread*)this;

	// Initialise default thread properties.
	m_dwStackSize = dwStackSize;
	m_dwCreationFlags = m_dwCreationFlags;  
	m_iThreadID = NULL;
	m_bstrName = lpszThreadName;
	m_hInitCompleteEvent = NULL;

	// Create a new thread
	m_hThreadHandle = (HANDLE)_beginthreadex(
											NULL,
											0,
											&ThreadProc,
											(void*)this,
											m_dwCreationFlags,
											&m_iThreadID
											);

	// Initialise the flag that indicates if this thread should keep running
	m_bKeepRunning = true;

	// If this thread was created successfully, we will append the
	// new thread ID to the Name of this thread to help identify it 
	// in the log.
	if (m_hThreadHandle != NULL)
	{
		// Initialise string buffer for holding the ThreadID as a string
		ZeroMemory(szThreadID,sizeof(szThreadID));

		// Get string representation of thread-id
		swprintf(szThreadID,_T("%d"),(DWORD)GetThreadID());

		// Append this to the name of this thread. 
		m_bstrName += ((LPCTSTR)szThreadID);
	}

	// Create an NT event object that will be used to signal when the thread has 
	// completed it's intiailisation / startup code. 
	m_hInitCompleteEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
	if (m_hInitCompleteEvent == NULL) 
	{
		TrERROR(GENERAL, "Failed to create an event. CThread construction failed. Error 0x%x", GetLastError());
		throw bad_alloc();
	}

	TrTRACE(GENERAL, "CThread constructor has been called. Thread no: %d", m_iThreadID);
}

//*******************************************************************
//
// Method      : Destructor.
//
// Description : Destroys an instance of the thread object.
//
//*******************************************************************
CThread::~CThread()
{
	// Write a trace message
	TrTRACE(GENERAL, "CThread destructor has been called. Thread no: %d", m_iThreadID);

	if (m_hInitCompleteEvent != NULL)
	{
		CloseHandle(m_hInitCompleteEvent);
	}
	
	// _endthreadex() does not close the handle of the thread
	CloseHandle( m_hThreadHandle );
}

//*******************************************************************
//
// Method      : GetName
//
// Description : Returns the name of this thread instance.
//
//*******************************************************************
_bstr_t CThread::GetName()
{
	return(m_bstrName);
}

//*******************************************************************
//
// Method      : GetThreadID
//
// Description : Returns the thread id of this thread.
//
//*******************************************************************
DWORD CThread::GetThreadID()
{
	return((DWORD)m_iThreadID);
}

//*******************************************************************
//
// Method      : Pause
//
// Description : Suspends the thread execution.
//
//*******************************************************************
bool CThread::Pause()
{
	// Write a trace message
	TrTRACE(GENERAL, "CThread was paused. Thread no: %d", m_iThreadID);

	return(SuspendThread(this->m_hThreadHandle) != 0xFFFFFFFF);
}

//*******************************************************************
//
// Method      : Resume
//
// Description : Unsuspend a threads processing.
//
//*******************************************************************
bool CThread::Resume()
{
	// Write a trace message
	TrTRACE(GENERAL, "CThread was resume. Thread no: %d", m_iThreadID);

	return(ResumeThread(this->m_hThreadHandle) != 0xFFFFFFFF);
}

//*******************************************************************
//
// Method      : Execute
//
// Description : This is the main control method for this thread. 
//               Derivations of this class do not over-ride this method,
//               instead, they over-ride the Init() & Run() & Exit() 
//               methods.
//
//*******************************************************************
void CThread::Execute()
{
	// Write a trace message
	TrTRACE(GENERAL, "Execute method in CThread was called. Thread no: %d", m_iThreadID);

	// Initialise this thread for COM - note that we support Apartment threading.
	HRESULT hr = CoInitializeEx(NULL,COINIT_MULTITHREADED);
	if (FAILED(hr))
	{
		TrTRACE(GENERAL, "Failed to initializes the COM library. CThread execution failed. Error 0x%x", GetLastError());
		return;
	}

	try
	{
		//
		// Invoke the Init() override in the derived class
		//
		bool bOK = Init();

		// Set the NT event object to indicate that the thread has completed initialisation.
		if (SetEvent(m_hInitCompleteEvent) == FALSE)
		{
			bOK = false;
			TrERROR(GENERAL, "Failed set the initialization event object. Unable to continue. Error=0x%x", GetLastError());
		}

		//
		// Invoke the Run() override in the derived class
		//
		if (bOK == true)
		{
			Run();
		}

		//
		// Invoke the Exit() override in the derived class
		//
		Exit();

	}
	catch(const _com_error& e)
	{
		// Write an error message to the log.
		TrERROR(GENERAL, "An unhandled COM thread exception has been caught. Thread no: %d. Error=0x%x", m_iThreadID, e.Error());
		SetEvent(m_hInitCompleteEvent);
	}
	catch(const exception&)
	{
		// Write an error message to the log.
		TrERROR(GENERAL, "An unhandled thread exception has been caught. Thread no: %d", m_iThreadID);
		SetEvent(m_hInitCompleteEvent);
	}

	// unitialize the COM libraries
	 CoUninitialize();

	// Write a trace message
	TrTRACE(GENERAL, "Thread no: %d completed", m_iThreadID);

	//
	// The thread was endded. Decrement the reference count of CThread.
	//
	Release();

	// Time to exit this thread.
	_endthreadex(0);
}

//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
bool CThread::Stop()
{
	TrTRACE(GENERAL, "CThread has been stoped. Thread no: %d", m_iThreadID);

	bool bOriginalValue = m_bKeepRunning;
	m_bKeepRunning = false;

	return(bOriginalValue);
}

//*******************************************************************
//
// Method      : WaitForInitToComplete
//
// Description : This method is called by the owner of this thread 
//               instance. It blocks until this thread pool object 
//               has completed it's initialization or a timeout occurs.
//
//*******************************************************************
bool CThread::WaitForInitToComplete(DWORD dwTimeout)
{
	DWORD dwWait = WAIT_OBJECT_0;

	// The TriggerMonitor thread should not be calling this method - check this.
	ASSERT(this->GetThreadID() != (DWORD)GetCurrentThreadId());

	if(dwTimeout == -1)
	{
		dwTimeout = INFINITE;
	}

	// Block until initialization event is set - or timeout.
	dwWait = WaitForSingleObject(m_hInitCompleteEvent, dwTimeout);

	switch(dwWait)
	{
		case WAIT_OBJECT_0 :
		{	
			return true;
		}
		case WAIT_TIMEOUT:
		default:
		{
			break;
		}
	}
	
	TrERROR(GENERAL, "An unexpected error has occurred whilst waiting for the CTriggerMonitorPool thread to initilise. The wait return code was (%d)", dwWait);
	return false;
}

//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
bool CThread::IsRunning()
{
	return(m_bKeepRunning);
}

//*******************************************************************
//
// Method      :
//
// Description :
//
//*******************************************************************
unsigned __stdcall CThread::ThreadProc(void * pThis)
{
	CThread * pThisThread = (CThread*)pThis;

	pThisThread->Execute();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\cqueue.hpp ===
//*******************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#pragma once 

#ifndef CQueue_INCLUDED 
#define CQueue_INCLUDED

#include "rwlock.h"
class CMsgProperties;
class CRuntimeTriggerInfo;

//
// Define the size of the format name for a queue (in characters)
//
#define MSMQ_FORMAT_NAME_BUFFER_SIZE 256

//
// Define a new type - a list of Runtime Trigger Info
//
typedef std::list< R<CRuntimeTriggerInfo> > RUNTIME_TRIGGERINFO_LIST; 


class CQueue : public CReference 
{
friend 
    class CQueueManager;

public :
	CQueue(
		const _bstr_t& bstrQueueName, 
		HANDLE* phCompletionPort,
		DWORD dwDefaultMsgBodySize
		);
	~CQueue();

	void ExpireAllTriggers();
	void AttachTrigger(R<CRuntimeTriggerInfo>& pTriggerInfo);

	HRESULT BindQueueToIOPort();

	bool IsSerializedQueue(void);
	bool IsValid(void);
	bool IsTriggerExist(void);

	HRESULT 
	Initialise(
		bool fOpenForReceive,
		const _bstr_t& triggerName
		);

	RUNTIME_TRIGGERINFO_LIST GetTriggers(void);

	_variant_t GetLastMsgLookupID();
	void SetLastMsgLookupID(_variant_t vLastNsgLookupId);

	CMsgProperties * DetachMessage();
	HRESULT RePeekMessage();
	HRESULT RequestNextMessage(bool bCreateCursor, bool bAlwaysPeekNext);

	HRESULT ReceiveMessageByLookupId(_variant_t lookupId);

	void CancelIoOperation(void);

	void CloseQueueHandle(void);

	bool IsOpenedForReceive(void) const
	{
		return m_fOpenForReceive;
	}

public:
	bool m_bInitialized;
	bool m_bSerializedQueue;

	bool m_bBoundToCompletionPort;

	CHandle m_hQueuePeek;
    CHandle m_hQueueReceive;

	bool m_fOpenForReceive;

	//
	// Cursor will be closed when the queue handle is closed
	//
	HANDLE m_hQueueCursor;
	HANDLE* m_phCompletionPort;

	OVERLAPPED m_OverLapped;

	// the path name of this queue object
	_bstr_t m_bstrQueueName;

	// the msmq format name of this queue object.
	_bstr_t m_bstrFormatName;

private:
    HRESULT 
    OpenQueue(
        DWORD dwAction, 
        HANDLE* pQHandle,     
        const _bstr_t& triggerName
        );

private:

	RUNTIME_TRIGGERINFO_LIST m_lstRuntimeTriggerInfo;

	// this is the size of the message bodies we expect to see on this queue.
	DWORD m_dwDefaultMsgBodySize;
	CMsgProperties * m_pReceivedMsg;
	_variant_t m_vLastMsgLookupID;
	CReadWriteLock m_ProtectQueueHandle;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\cthread.hpp ===
//*******************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#ifndef CThread_INCLUDED 
#define CThread_INCLUDED

#include <process.h>

// Define the default thread stack size.
#define DEFAULT_THREAD_STACK_SIZE  8000

class CThread :	public CReference
{
	public:

		// Constructor / Destructor
		CThread(
            DWORD dwStackSize = DEFAULT_THREAD_STACK_SIZE,
            DWORD m_dwCreationFlags = CREATE_SUSPENDED, 
            LPTSTR lpszThreadName = _T("CThread"),
            IMSMQTriggersConfigPtr pITriggersConfig = NULL
            );

		~CThread();

		// An interface pointer to the MSMQ Triggers Configuration COM component
		IMSMQTriggersConfigPtr m_pITriggersConfig;

		// The thread ID of this thread object
		unsigned int m_iThreadID;

		// The handle object to this thread
		HANDLE m_hThreadHandle;

		// Each thread object instance will have a name.
		_bstr_t m_bstrName;

		// Thread identification methods
		_bstr_t GetName();
		DWORD  GetThreadID();

		// Thread control and synchronisation 
		bool Pause();
		bool Resume();
		bool Stop();
		bool IsRunning();
		bool WaitForInitToComplete(DWORD dwTimeout);

		// The follow methods are to be over-riden by derivations of this class. 
		virtual bool Init() = 0;
		virtual bool Run() = 0;
		virtual bool Exit() = 0;

	private :

		CThread * m_pThis;
		LPVOID m_lpThreadParms;
		DWORD m_dwCreationFlags;

		// The stack size that this thread was initialized.
		DWORD m_dwStackSize;

		// Flag indicating if this thread should keep running or not.
		bool m_bKeepRunning;

		// An event that is signall when initialization is complete - either successfully or otherwise.
		HANDLE m_hInitCompleteEvent;
		
		// The static starting address for this thread.
		static unsigned __stdcall ThreadProc(void * pThis);	

		// The main thread routine which calls the Init / Run / Exit over-rides.
		void Execute();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\monitor.hpp ===
//*******************************************************************
//
// Class Name  :
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#ifndef CTriggerMonitor_INCLUDED 
#define CTriggerMonitor_INCLUDED

class CTriggerMonitorPool;

// Include the triggers shared definitions
#include "stddefs.hpp"

// Include the definitions for the CThread object
#include "cthread.hpp"

// Definitions for the TriggerMonitor pool
#include "monitorp.hpp"

// Definitions for the global queue-lock manager. 
#include "cqmanger.hpp"

// Definition of the admin message structure
#include "adminmsg.hpp"

// Define the error HRESULT that is returned in the overlapped structure when an 
// asynchronous recieve is terminated because the thread that issued the receive 
// call has terminated. 
#define IO_OPERATION_CANCELLED 0xC0000120


// Define the completion port key that we will give to the MSMQTriggerSEt object
#define TRIGGERSET_NOTIFCATION_KEY 0xFEFEFEFE

// Define the completion port key used to wake up monitor threads
#define TRIGGER_MONITOR_WAKE_UP_KEY  0xAAAAAAAA

// Define the completion port key that will be used to force MQReceiveMessage retries
#define TRIGGER_RETRY_KEY 0xBBBBBBBB

// Define the timeout period we will wait for when waiting for the 
// TriggerMonitor thread to terminate after Stop() has been called.
#define TRIGGER_MONITOR_STOP_TIMEOUT  10000    // 10 seconds.


class CTriggerMonitor : public CThread
{
	friend class CTriggerMonitorPool;

	private:

		HANDLE * m_phIOCompletionPort;

		// The tick when this thread last completed serving a request 
		DWORD m_dwLastRequestTickCount;

		// Reference to the CTriggerMonitorPool instance
		R<CTriggerMonitorPool> m_pMonitorPool;

		// Reference to Queue lock manager - handles thread synchronisatio to queue when required.
		R<CQueueManager> m_pQueueManager;

		// These methods are used to perform before & after wait state processing.
		void MonitorEnteringWaitState(bool bRoutineWakeup);
		void MonitorExitingWaitState(bool bRoutineWakeup);

		// used to map an overlapped pointer to a queue object. 
		CQueue* GetQueueReference(OVERLAPPED * pOverLapped);
		
		// Used to process a message on any of the bound queues.
		void ProcessReceivedMsgEvent(CQueue * pQueue);

		// Invokes the IMSMQTriggerHandler interface for each rule in the trigger.
		HRESULT InvokeMSMQRuleHandlers(
					CMsgProperties * pMessage,
					CRuntimeTriggerInfo * pTriggerInfo,
					CQueue* pQueue
					);

		// Processes messages received from the administration (notifications) queue.
		HRESULT ProcessMessageFromAdminQueue(const CMsgProperties* pMessage);
		
		void
		ProcessTrigger(
			CQueue* pQueue,
			CRuntimeTriggerInfo* pTriggerInfo,
			const CMsgProperties* pMessage
			);

		void
		ProcessAdminMessage(
			CQueue* pQueue,
			const CMsgProperties* pMessage
			);	
		

	public:

		CTriggerMonitor(
			CTriggerMonitorPool * pMonitorPool, 
			IMSMQTriggersConfig * pITriggersConfig,
			HANDLE * phIOCompletionPort,
			CQueueManager * pQueueManger
			);

		
	private:
        HRESULT InvokeRegularRuleHandlers(
                    IMSMQPropertyBagPtr& pIPropertyBag,
					CRuntimeTriggerInfo * pTriggerInfo,
					CQueue* pQueue
					);
        HRESULT InvokeTransactionalRuleHandlers(
                    IMSMQPropertyBagPtr& pIPropertyBag,
					CRuntimeTriggerInfo * pTriggerInfo
					);


		~CTriggerMonitor();

		// Thread control over-rides of the base class CThread
		bool Init();
		bool Run();
		bool Exit();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\monitorp.hpp ===
//*******************************************************************
//
// Class Name  : CTriggerMonitorPool
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class is the container for the set of worker 
//               threads that perform the trigger monitoring and 
//               processing. The key features of this class are 
//
//               (1) It provides aggregate startup and shutdown 
//                   functions for the worker thread group as a whole,
//
//               (2) It provides thread pool maintenance and recovery,
//
//               (3) It intitializes and maintains the cache of 
//                   trigger information,
//
//               (4) It performs the synchronization of the trigger 
//                   data cache as required.
//
//                There will be only one instance of this class in the 
//                entire MSMQ trigger service. 
//
//                This class is derived from the base class CThread, and
//                has it's own thread. This thread is used as an 
//                adminstrative thread only,it does perform trigger rule
//                processing.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#ifndef CTriggerMonitorPool_INCLUDED 
#define CTriggerMonitorPool_INCLUDED

class CTriggerMonitor;

// Definition of the CTriggerMonitor object
#include "monitor.hpp"

// Include the definitions for the CThread object
#include "cthread.hpp"

// Definitions for the global queue-lock manager. 
#include "cqmanger.hpp"

// Definition of the admin message structure
#include "adminmsg.hpp"

#include "triginfo.hpp"

#include "mqtg.h"

#include "rwlock.h"

// Define a new type - a list of CTriggerMonitor objects.
typedef std::list< R<CTriggerMonitor> > TRIGGER_MONITOR_LIST;

// Define a new type - a list of Runtime Trigger Info
typedef std::list< R<CRuntimeTriggerInfo> > RUNTIME_TRIGGERINFO_LIST;

// Define a new type - a list of Messages 
typedef std::list<CAdminMessage*> ADMIN_MESSAGES_LIST;

// Define how long we will wait for shutdown to complete
#define SHUTDOWN_TIMEOUT             120000     // 10 seconds

// Define how often the admin thread will wake to perform periodic processing 
#define ADMIN_THREAD_WAKEUP_PERIOD   60000 //300000    // 5 minutes

// Define how long a monitor thread can be idle for before it becomes a candidate
// for being removed from the thread pool.
#define MONITOR_MAX_IDLE_TIME        120000    // 2 minutes

// Define the list of tasks that the admin thread can do upon request
#define ADMIN_THREAD_IDLE                     0
#define ADMIN_THREAD_PROCESS_NOTIFICATIONS    1
#define ADMIN_THREAD_STOP                     2

class CTriggerMonitorPool  : public CThread
{
	friend class CTriggerMonitor;

	public:

		CTriggerMonitorPool(IMSMQTriggersConfigPtr pITriggersConfig, LPCTSTR bstrServiceName) ;

		HRESULT ShutdownThreadPool();
		
		LPWSTR  GetRegistryPath() 
		{ 
			return m_wzRegPath; 
		}

		bool IsInitialized(void) const
		{
			return m_bInitialisedOK;
		}

		DWORD GetProcessingThreadNumber(void) const
		{
			return numeric_cast<DWORD>(m_lstTriggerMonitors.size());
		}

	private:

		~CTriggerMonitorPool();

   	    // A flag indicating if this thread initialized OK
		bool m_bInitialisedOK;

		//get the admin task flag value and rest it
		long GetAdminTask();

		CCriticalSection m_csAdminTask;
		// Used to indicate what sort of admin task we should process
		long m_lAdminTask;
		

		// A handle to the single IO completion port that all worker thread will 
		// use to receive asynchronous MSMQ messages
		HANDLE m_hIOCompletionPort;

		// the event object that the admin blocks on
		CHandle m_hAdminEvent;

		// This is a count of blocked (available) monitor threads in the thread pool
		LONG m_lNumberOfWaitingMonitors;

		// This is an an instance of the trigger set COM object - used to retrieve 
		// trigger information from the database. 
		IMSMQTriggerSetPtr m_pMSMQTriggerSet;

		// This is the list of TriggerMonitor objects that are managed by this class. 
		TRIGGER_MONITOR_LIST m_lstTriggerMonitors;

		//get a copy of the current admin message list and reset it
		void GetAdminMessageListCopy(ADMIN_MESSAGES_LIST& adminList);

		// This is a list of admin messages that are to be processed by the administrator thread.
		ADMIN_MESSAGES_LIST m_lstAdminMessages;

		// This lock is used to control access to the list of admin messages.
		CCriticalSection m_AdminMsgListLock;

		// Queue lock manager - handles thread synchronisatio to queue when required.
		R<CQueueManager>  m_pQueueManager;

		// The time this thread pool started 
		_bstr_t m_bstrStartTime;

		// The time of the last trigger data synchronization
		_bstr_t m_bstrLastSyncTime;

		_bstr_t	m_bstrThreadStatus;

		TCHAR m_wzRegPath[MAX_REGKEY_NAME_SIZE];

		// Thread controls methods - overrides from the CThread class
		bool Init();
		bool Run();
		bool Exit();

		void 
		CreateIOCompletionPort(
			void
			);
		
		void 
		GetTriggerData(
			RUNTIME_TRIGGERINFO_LIST &lstTriggerInfo
			);

		
		void
		GetAttachedRuleData(
			const BSTR& bsTriggerID,
			long ruleNo,
			RUNTIME_RULEINFO_LIST& ruleList
			);


		R<CRuntimeTriggerInfo>
		CreateNotificationTrigger(
			void
			);

		R<CRuntimeTriggerInfo>
		GetTriggerRuntimeInfo(
			long triggerIndex
			);


		void 
		AttachTriggersToQueues(
			RUNTIME_TRIGGERINFO_LIST &lstTriggerInfo
			);


		HRESULT CreateTriggerMonitor();

		HRESULT PerformPeriodicProcessing();
		HRESULT RefreshServiceStatus();
		HRESULT FlushServiceStatus();

		void ProcessAdminMessages();

		HRESULT AcceptAdminMessage(CAdminMessage * pAdminMessage);

		HRESULT PostMessageToAllMonitors(DWORD dwCompletionKey);

		// used to determine how many live monitors (threads) are in the pool.
		DWORD GetNumberOfRunningTriggerMonitors();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\monitor.cpp ===
//*******************************************************************************
//
// Class Name  : CTriggerMonitor
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class represents a worker thread that performs 
//               trigger monitoring and processing. Each instance of 
//               this class has it's own thread - and it derives from
//               the CThread class. 
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************************
#include "stdafx.h"
#include "Ev.h"
#include "monitor.hpp"
#include "mqsymbls.h"
#include "cmsgprop.hpp"
#include "triginfo.hpp"
#include "Tgp.h"
#include "mqtg.h"
#include "rwlock.h"
#include "ss.h"

#include "monitor.tmh"

#import  "mqgentr.tlb" no_namespace

using namespace std;

static bool s_fReportedRuleHandlerCreationFailure = false;
static CSafeSet< _bstr_t > s_reportedRules;


static
void
ReportInvocationError(
	const _bstr_t& name,
	const _bstr_t& id, 
	HRESULT hr,
	DWORD eventId
	)
{
	WCHAR errorVal[128];
	swprintf(errorVal, L"0x%x", hr);

	EvReport(
		eventId, 
		3, 
		static_cast<LPCWSTR>(name), 
		static_cast<LPCWSTR>(id), 
		errorVal
		);
}


//********************************************************************************
//
// Method      : Constructor	
//
// Description : Initializes a new trigger monitor class instance,
//               and calls the constructor of the base class CThread.
//
//********************************************************************************
CTriggerMonitor::CTriggerMonitor(CTriggerMonitorPool * pMonitorPool, 
								 IMSMQTriggersConfig * pITriggersConfig,
								 HANDLE * phICompletionPort,
								 CQueueManager * pQueueManager) : CThread(8000,CREATE_SUSPENDED,_T("CTriggerMonitor"),pITriggersConfig)
{
	// Ensure that we have been given construction parameters
	ASSERT(pQueueManager != NULL);
	ASSERT(phICompletionPort != NULL);
	
	// Initialise member variables.
	m_phIOCompletionPort = phICompletionPort;

	// Store a reference to the Queue lock manager.
	pQueueManager->AddRef();
	m_pQueueManager = pQueueManager;

	// Store reference to the monitor pool object (parent)
	pMonitorPool->AddRef();
	m_pMonitorPool = pMonitorPool;

}

//********************************************************************************
//
// Method      : Destructor
//
// Description : Destorys an instance of this class.
//
//********************************************************************************
CTriggerMonitor::~CTriggerMonitor()
{
}

//********************************************************************************
//
// Method      : Init
//
// Description : This is an over-ride of the Init() method in the 
//               base class CThread. This method is called by the 
//               new thread prior to entering the normal-execution 
//               loop.
//
//********************************************************************************
bool CTriggerMonitor::Init()
{
	//
	// Only this TiggerMonitor thread should be executing the Init() method - check this.
	//
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	TrTRACE(GENERAL, "Initialize trigger monitor ");
	return (true);
}

//********************************************************************************
//
// Method      : Run
// 
// Description : This is an over-ride of the Init() method in the 
//               base class CThread. This method is called by the 
//               thread after calling Init(). This method contains the 
//               main processing loop of the worker thread. When the
//               thread exits this method - it will begin shutdown 
//               processing.
//
// TODO notes about CQueueReference 
//********************************************************************************
bool CTriggerMonitor::Run()
{
	HRESULT hr = S_OK;
	BOOL bGotPacket = FALSE;
	DWORD dwBytesTransferred = 0;
	ULONG_PTR dwCompletionKey = 0;
	bool bRoutineWakeUp = false;
	OVERLAPPED * pOverLapped = NULL;

	// Only this TiggerMonitor thread should be executing the Run() method - check this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	// Write a trace message
	TrTRACE(GENERAL, "Trigger monitor is runing");

	while (this->IsRunning() && SUCCEEDED(hr))
	{
		bGotPacket = FALSE;
		dwCompletionKey = 0;

		// Notfiy the parent trigger pool that this thread is now entering a wait state.
		MonitorEnteringWaitState(bRoutineWakeUp);

		// Wait on the IO Completion port for a message to process
		bGotPacket = GetQueuedCompletionStatus(
                            *m_phIOCompletionPort,
                            &dwBytesTransferred,
                            &dwCompletionKey,
                            &pOverLapped,
                            MONITOR_MAX_IDLE_TIME
                            );

		// This wait is used to pause and resume the trigger service. 
		DWORD dwState = WaitForSingleObject(g_hServicePaused,INFINITE);
		if(dwState == WAIT_FAILED)
		{
			TrTRACE(GENERAL, "WaitForSingleObject failed.Error code was %d.", GetLastError());			
		}

		// Determine if this is a routine wake-up (due to either a time-out or a wake-up key being sent by the
		// trigger monitor. Set a flag accordingly.
		bRoutineWakeUp = ((dwCompletionKey == TRIGGER_MONITOR_WAKE_UP_KEY) || (pOverLapped == NULL));

		// Notfiy the parent trigger pool that this thread is now in use. 
		MonitorExitingWaitState(bRoutineWakeUp);

		if (bGotPacket == TRUE)
		{
			switch(dwCompletionKey)
			{
				case TRIGGER_MONITOR_WAKE_UP_KEY:
				{
					// we don't need to do anything here - this is simply a request
					// by the administrator to 'wake-up' and check state. If this thread
					// has been asked to stop, the IsRunning() controlling this loop will
					// return false and we will exit this method. 

					break;
				}
				case TRIGGER_RETRY_KEY:
				{
					R<CQueue> pQueueRef = GetQueueReference(pOverLapped);

					if(pQueueRef->IsTriggerExist())
					{
						TrTRACE(GENERAL, "Retry receive operation on queue: %ls", static_cast<LPCWSTR>(pQueueRef->m_bstrQueueName));

						pQueueRef->RequestNextMessage(false, true);
					}
					break;
				}
				default:
				{
					//
					// This reference indicates pending operation that ended
					// At start of every pending operation AddRef() for the queue
					// is performed. If the queue is valid, a real reference to
					// the queue is received, in all other cases pQueueRef will 
					// be NULL.
					//
					R<CQueue> pQueueRef = GetQueueReference(pOverLapped);

					if(pQueueRef->IsTriggerExist())
					{
						ProcessReceivedMsgEvent(pQueueRef.get());
					}
					break;
				}
			}			
		}
		else //failed I/O operation
		{
			if (pOverLapped != NULL)
			{
				switch (pOverLapped->Internal)
				{
					case MQ_ERROR_QUEUE_DELETED:
					{
						// The completion packet was for an outstanding request on a queue that has 
						// been deleted. We do not need to do anything here.
						TrTRACE(GENERAL, "Failed to receive message on queue because the queue has been deleted. Error 0x%Ix", pOverLapped->Internal);


						// TODO - Remove queue from qmanager.

						break;
					}
					case MQ_ERROR_BUFFER_OVERFLOW:
					{
						// This indicates that the buffer used for receiving the message body was not
						// large enough. At this point we can attempt to re-peek the message after 
						// allocating a larger message body buffer. 
						
						//
						// This reference indicates pending operation that ended
						// At start of every pending operation AddRef() for the queue
						// is performed. If the queue is valid, a real reference to
						// the queue is received, in all other cases pQueueRef will 
						// be NULL.
						//
						R<CQueue> pQueueRef = GetQueueReference(pOverLapped);


						TrTRACE(GENERAL, "Failed to receive message on a queue due to buffer overflow. Allocate a bigger buffer and re-peek the message");

						if(pQueueRef->IsTriggerExist())
						{
							hr = pQueueRef->RePeekMessage();

							if SUCCEEDED(hr)
							{
								ProcessReceivedMsgEvent(pQueueRef.get());
							}
							else
							{
								TrERROR(GENERAL, "Failed to repeek a message from queue %s. Error %!hresult!", pQueueRef->m_bstrQueueName, hr);

								if(pQueueRef->IsTriggerExist())
								{
									//
									// This will not create an infinite loop because we already allocated a big enough 
									// space for the message properties in RePeekMessage
									//
									pQueueRef->RequestNextMessage(false, false); 
								}
							}
						}
						break;
					}
					case IO_OPERATION_CANCELLED:
					{
						//
						// The io operation was cancelled, either the thread which initiated
						// the io operation has exited or the CQueue object was removed from the
						// m_pQueueManager
						//
						
						//
						// This reference indicates pending operation that ended
						// At start of every pending operation AddRef() for the queue
						// is performed. If the queue is valid, a real reference to
						// the queue is received, in all other cases pQueueRef will 
						// be NULL.
						//
						R<CQueue> pQueueRef = GetQueueReference(pOverLapped);  

						if(pQueueRef->IsTriggerExist())
						{
							TrTRACE(GENERAL, "Receive operation on queue: %ls was canceled", static_cast<LPCWSTR>(pQueueRef->m_bstrQueueName));

							pQueueRef->RequestNextMessage(false, false); 
						}
						break;
					}
					case E_HANDLE:
					{
						//
						// This is a remote trigger and MSMQ on the remote machine was restarted.
						//
						TrERROR(GENERAL, "Failed to receive a message got E_HANDLE");
						break;
					}
					default:
					{
						hr = static_cast<HRESULT>(pOverLapped->Internal);

						R<CQueue> pQueueRef = GetQueueReference(pOverLapped); 
						TrERROR(GENERAL, "Receive operation on queue: %ls failed. Error: %!hresult!", static_cast<LPCWSTR>(pQueueRef->m_bstrQueueName), hr);

						if(pQueueRef->IsTriggerExist())
						{
							pQueueRef->RequestNextMessage(false, false);
						}
						break;
					}

				} // end switch (pOverLapped->Internal)

			} //  end if (pOverLapped != NULL)

			//
			// Note that we do not specify an else clause for the case where pOverlapped 
			// is NULL. This is interpretted as the regular timeout that occurs with the 
			// call to GetQueuedCompletionStatus(). If this trigger monitor has been asked
			// to stop - it will fall out of the outer-while loop because IsRunning() will 
			// return false. If this monitor has not be asked to stop, this thread will 
			// simply cycle around and reenter a blocked state by calling GetQueuedCompletionStatus()
			//

		} // end if (bGotPacket == TRUE) else clause

	} // end while (this->IsRunning() && SUCCEEDED(hr))

	return(SUCCEEDED(hr) ? true : false);
}

//********************************************************************************
//
// Method      : Exit
// 
// Description : This is an over-ride of the Exit() method in the 
//               base class CThread. This method is called by the 
//               CThread class after the Run() method has exited. It
//               is used to clean up thread specific resources. In this
//               case it cancels any outstanding IO requests made by 
//               this thread.
//
//********************************************************************************
bool CTriggerMonitor::Exit()
{
	// Only this TiggerMonitor thread should be executing the Exit() method - check this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	//
	// Cancel any outstanding IO requests from this thread on this queue handle.
	//
	m_pQueueManager->CancelQueuesIoOperation();

	// Write a trace message
	TrTRACE(GENERAL, "Exit trigger monitor");

	return true;
}


//********************************************************************************
//
// Method      : MonitorEnteringWaitState
//
// Description : Called by this thread before it enters a blocked 
//               state. It increments the count of waiting (available)
//               monitor threads.
//
//********************************************************************************
void CTriggerMonitor::MonitorEnteringWaitState(bool bRoutineWakeUp)
{
	LONG lWaitingMonitors = InterlockedIncrement(&(m_pMonitorPool->m_lNumberOfWaitingMonitors));

	// record the tick count of when this thread last completed a request.
	if (bRoutineWakeUp == false)
	{
		m_dwLastRequestTickCount = GetTickCount();
	}

	TrTRACE(GENERAL, "Entering wait state. There are now %d threads waiting trigger monitors.", lWaitingMonitors);
}

//********************************************************************************
//
// Method      : MonitorExitingWaitState
//
// Description : Called by this thread immediately after it unblocks. It decrements
//               the the count of waiting (available) monitor threads and conditionally
//               requests that another monitor thread be created if the load on the 
//               system is perceived to be high.
//
//********************************************************************************
void CTriggerMonitor::MonitorExitingWaitState(bool bRoutineWakeup)
{
	LONG lWaitingMonitors = InterlockedDecrement(&(m_pMonitorPool->m_lNumberOfWaitingMonitors));

	// If this monitor thread was the last in the pool, then there is a possibility that we will want 
	// to inform the CTriggerMonitorPool instance that more threads are requried to handled the load.
	// We request a new thread if and only if the following conditions have been met 
	// 
	//  (a) the number of waiting monitors is 0, 
	//  (b) the thread was unblocked due to message arrival, not routine time-out or wake-up request
	//  (c) the maximum number of monitors allowed is greater than one.
	//
	if ((lWaitingMonitors < 1) && (bRoutineWakeup == false) &&	(m_pITriggersConfig->GetMaxThreads() > 1)) 
	{
		TrTRACE(GENERAL, "Requesting the creation of a new monitor due to load.");

		// Allocate a new CAdminMessage object instance.
		CAdminMessage * pAdminMsg = new CAdminMessage(CAdminMessage::eMsgTypes::eNewThreadRequest);

		// Ask the TriggerMonitorPool object to process this message
		m_pMonitorPool->AcceptAdminMessage(pAdminMsg);
	}
}

//********************************************************************************
//
// Method      : GetQueueReference
//
// Description : This method is used to convert a pointer to an overlapped structure
//               to a queue reference. 
//
//********************************************************************************
CQueue* CTriggerMonitor::GetQueueReference(OVERLAPPED * pOverLapped)
{
	ASSERT(("Invalid overlapped pointer", pOverLapped != NULL));

	//
	// Map the pOverLapped structure to the containing queue object
	//
	CQueue* pQueue = CONTAINING_RECORD(pOverLapped,CQueue,m_OverLapped);
	//ASSERT(("Invalid queue object", pQueue->IsValid()));

	//
	// use the queue manager to determine if the pointer to the queue is valid and get
	// a refernce to it.
	// This method can return NULL in case the CQueue object was removed
	//
	return pQueue;
}


//********************************************************************************
// static
// Method      : ReceiveMessage	
//
// Description : Initializes a new trigger monitor class instance,
//               and calls the constructor of the base class CThread.
//
//********************************************************************************
inline
HRESULT
ReceiveMessage(
	VARIANT lookupId,
	CQueue* pQueue
	)
{	
	return pQueue->ReceiveMessageByLookupId(lookupId);
}


static CSafeSet< _bstr_t > s_reportedDownLevelQueue;

static
bool
IsValidDownLevelQueue(
	CQueue* pQueue,
	const CMsgProperties* pMessage
	)
{
	if (!pQueue->IsOpenedForReceive())
	{
		//
		// The queue wasn't opened for receive. There is no issue with down-level queue
		//
		return true;
	}

	if (_wtoi64(pMessage->GetMsgLookupID().bstrVal) != 0)
	{
		//
		// It's not down-level queue. Only for down-level queue the returned lookup-id is 0
		//
		return true;
	}

	//
	// Report a message to event log if this is the first time
	//
	if (s_reportedDownLevelQueue.insert(pQueue->m_bstrQueueName))
	{
		EvReport(
			MSMQ_TRIGGER_RETRIEVE_DOWNLEVL_QUEUE_FAILED, 
			1,
			static_cast<LPCWSTR>(pQueue->m_bstrQueueName)
			);
	}

	return false;
}


static
bool
IsDuplicateMessage(
	CQueue* pQueue,
	const CMsgProperties* pMessage
	)
{
	//
	// This check is performed in order to eliminate duplicate last message
	// handling. This may happen when transactional retrieval is aborted
	// and a pending operation has already been initiated
	//
	if ((pQueue->GetLastMsgLookupID() == pMessage->GetMsgLookupID()) &&
		//
		// Down level client (W2K and NT4) doesn't support lookup id. As a result, the returned 
		// lookup id value is always 0.  
		//
		(_wtoi64(pMessage->GetMsgLookupID().bstrVal) != 0)
		)
	{
		return true;
	}

	//
	// Update last message LookupID for this queue, before issuing any
	// new pending operations
	//
	pQueue->SetLastMsgLookupID(pMessage->GetMsgLookupID());
	return false;
}


void
CTriggerMonitor::ProcessAdminMessage(
	CQueue* pQueue,
	const CMsgProperties* pMessage
	)
{
	HRESULT hr = ProcessMessageFromAdminQueue(pMessage);

	if (FAILED(hr))
		return;
	
	//
	// Remove admin message from queue
	//
	_variant_t vLookupID = pMessage->GetMsgLookupID();
	
	hr = ReceiveMessage(vLookupID, pQueue);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to remove message from admin queue. Error=0x%x", hr);
	}
}


void
CTriggerMonitor::ProcessTrigger(
	CQueue* pQueue,
	CRuntimeTriggerInfo* pTriggerInfo,
	const CMsgProperties* pMessage
	)
{
	if (!pTriggerInfo->IsEnabled())
		return;

	TrTRACE(GENERAL, "Process message from queue %ls of trigger %ls", static_cast<LPCWSTR>(pTriggerInfo->m_bstrTriggerName), static_cast<LPCWSTR>(pTriggerInfo->m_bstrQueueName));

	//
	// Invoke the rule handlers for this trigger 
	//
	HRESULT hr = InvokeMSMQRuleHandlers(const_cast<CMsgProperties*>(pMessage), pTriggerInfo, pQueue);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to invoke rules on queue: %ls of trigger %ls", static_cast<LPCWSTR>(pTriggerInfo->m_bstrTriggerName), static_cast<LPCWSTR>(pTriggerInfo->m_bstrQueueName));
	}
}


//********************************************************************************
//
// Method      : ProcessReceivedMsgEvent
//
// Description : Called by the thread to process a message that has 
//               arrived on a monitored queuue. The key steps to 
//               processing a message are :
//
//               (1) Detach the message from the queue object
//               (2) If the firing trigger is not serialized, then 
//                   request the next message on this queue.
//               (3) If the firing trigger is our administration trigger,
//                   then defer this message to the TriggerMonitorPool class.
//               (4) For each trigger attached to this queue, execute
//                   the CheckRuleCondition() method on its rule-handler 
//               (5) If the firing trigger is a serialized trigger, 
//                   then request the next queue message now.
//               (6) Delete the queue message.                
//
//********************************************************************************
void CTriggerMonitor::ProcessReceivedMsgEvent(CQueue * pQueue)
{
	P<CMsgProperties> pMessage = pQueue->DetachMessage();

	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());
	TrTRACE(GENERAL, "Received message for processing from queue: %ls", static_cast<LPCWSTR>(pQueue->m_bstrQueueName));

	//
	// Check if this message already processed. If yes ignore it
	//
	if (IsDuplicateMessage(pQueue, pMessage))
	{
		TrTRACE(GENERAL, "Received duplicate message from queue: %ls. Message will be ignored.", (LPCWSTR)pQueue->m_bstrQueueName);
		pQueue->RequestNextMessage(false, false);
		return;
	}

	//
	// Befor begin to process the message check that the queue isn't down level	queue. For down-level queues
	// MSMQ trigger can't recevie the message since it uses lookup-id mechanism. In such a case write
	// event log messaeg and don't continue	to process messages from this queue.
	//
	if (!IsValidDownLevelQueue(pQueue, pMessage))
	{
		return;
	}

	//
	// If this is not a serialized queue, request the next message now.
	//
	bool fSerialized = pQueue->IsSerializedQueue();
	if(!fSerialized)
	{
		pQueue->RequestNextMessage(false, false);
	}

	//
	// Get the list of trigger that attached to the queue
	//
	RUNTIME_TRIGGERINFO_LIST triggerList = pQueue->GetTriggers();

	for(RUNTIME_TRIGGERINFO_LIST::iterator it = triggerList.begin(); it != triggerList.end(); ++it)
	{
		R<CRuntimeTriggerInfo> pTriggerInfo = *it;

		if (!pTriggerInfo->IsAdminTrigger())
		{
			ProcessTrigger(pQueue, pTriggerInfo.get(), pMessage);
		}
		else
		{
			ProcessAdminMessage(pQueue, pMessage);
		}
	}

	//
	// If this is a serialized queue, we request the next message after we have processed the triggers
	//
	if(fSerialized)
	{
		pQueue->RequestNextMessage(false, false);
	}
}


bool s_fIssueCreateInstanceError = false;
static CSafeSet< _bstr_t > s_reportedTransactedTriggers;

static
void
ExecuteRulesInTransaction(
	const _bstr_t& triggerId,
	LPCWSTR registryPath,
	IMSMQPropertyBagPtr& pPropertyBag,
    DWORD dwRuleResult)
{
	IMqGenObjPtr pGenObj;
	HRESULT hr = pGenObj.CreateInstance(__uuidof(MqGenObj));

	if (FAILED(hr))
	{
		if (!s_fIssueCreateInstanceError)
		{
			WCHAR errorVal[128];
			swprintf(errorVal, L"0x%x", hr);

			EvReport(MSMQ_TRIGGER_MQGENTR_CREATE_INSTANCE_FAILED, 1, errorVal);
			s_fIssueCreateInstanceError = true;
		}

		TrTRACE(GENERAL, "Failed to create Generic Triggers Handler Object. Error=0x%x", hr);
		throw bad_hresult(hr);
	}

	pGenObj->InvokeTransactionalRuleHandlers(triggerId, registryPath, pPropertyBag, dwRuleResult);
}


static
void
CreatePropertyBag(
	const CMsgProperties* pMessage,
	const CRuntimeTriggerInfo* pTriggerInfo,
	const _bstr_t& bstrQueueFormatName,
	IMSMQPropertyBagPtr& pIPropertyBag
	)
{
	HRESULT hr = pIPropertyBag.CreateInstance(__uuidof(MSMQPropertyBag));
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to create the MSMQPropertybag object. Error=0x%x",hr);
		throw bad_hresult(hr);
	}
	

	// TODO - investigate possible memory leaks here.

	// Populate the property bag with some useful information

	pIPropertyBag->Write(_bstr_t(g_PropertyName_Label),pMessage->GetLabel());
	pIPropertyBag->Write(_bstr_t(g_PropertyName_MsgID),pMessage->GetMessageID());
	pIPropertyBag->Write(_bstr_t(g_PropertyName_MsgBody),pMessage->GetMsgBody());
	pIPropertyBag->Write(_bstr_t(g_PropertyName_MsgBodyType),pMessage->GetMsgBodyType());
	pIPropertyBag->Write(_bstr_t(g_PropertyName_CorID),pMessage->GetCorrelationID());
	pIPropertyBag->Write(_bstr_t(g_PropertyName_MsgPriority),pMessage->GetPriority());
	pIPropertyBag->Write(_bstr_t(g_PropertyName_ResponseQueueName),pMessage->GetResponseQueueName());
	pIPropertyBag->Write(_bstr_t(g_PropertyName_AdminQueueName),pMessage->GetAdminQueueName());
	pIPropertyBag->Write(_bstr_t(g_PropertyName_AppSpecific),pMessage->GetAppSpecific());
	pIPropertyBag->Write(_bstr_t(g_PropertyName_QueueFormatname), bstrQueueFormatName);
	pIPropertyBag->Write(_bstr_t(g_PropertyName_QueuePathname),pTriggerInfo->m_bstrQueueName);
	pIPropertyBag->Write(_bstr_t(g_PropertyName_TriggerName),pTriggerInfo->m_bstrTriggerName);
	pIPropertyBag->Write(_bstr_t(g_PropertyName_TriggerID),pTriggerInfo->m_bstrTriggerID);		
	pIPropertyBag->Write(_bstr_t(g_PropertyName_SentTime),pMessage->GetSentTime());
	pIPropertyBag->Write(_bstr_t(g_PropertyName_ArrivedTime),pMessage->GetArrivedTime());
	pIPropertyBag->Write(_bstr_t(g_PropertyName_SrcMachineId),pMessage->GetSrcMachineId());
	pIPropertyBag->Write(_bstr_t(g_PropertyName_LookupId),pMessage->GetMsgLookupID());
}


static 
IMSMQRuleHandlerPtr 
GetRuleHandler(
	CRuntimeRuleInfo* pRule
	)
{
	if (pRule->m_MSMQRuleHandler) 
	{
		//
		// There is an instance of MSMQRuleHandler - use it
		//
		return pRule->m_MSMQRuleHandler;
	}

	//
	// Create the interface
	//
	IMSMQRuleHandlerPtr pMSQMRuleHandler;
	HRESULT hr = pMSQMRuleHandler.CreateInstance(_T("MSMQTriggerObjects.MSMQRuleHandler")); 
	if ( FAILED(hr) )
	{
		TrERROR(GENERAL, "Failed to create MSMQRuleHandler instance for Rule: %ls. Error=0x%x",(LPCTSTR)pRule->m_bstrRuleName, hr);
		if (!s_fReportedRuleHandlerCreationFailure)
		{
			ReportInvocationError(
				pRule->m_bstrRuleName,
				pRule->m_bstrRuleID,
				hr, 
				MSMQ_TRIGGER_RULE_HANDLE_CREATION_FAILED
				);
		}
		throw bad_hresult(hr);
	}

	try
	{
		//
		// Initialise the MSMQRuleHandling object.
		//
		pMSQMRuleHandler->Init(
							pRule->m_bstrRuleID,
							pRule->m_bstrCondition,
							pRule->m_bstrAction,
							(BOOL)(pRule->m_fShowWindow) 
							);

		CS lock(pRule->m_csRuleHandlerLock);

		//
		// We take here the lock because two threads might enter this function and try to assign the rulehandler
		// to their member at the same time. 
		//
		if (pRule->m_MSMQRuleHandler) 
		{
			//
			// There is an instance of MSMQRuleHandler - use it
			//
			return pRule->m_MSMQRuleHandler;
		}

		//
		// Copy the local pointer to the rule store.
		//
		pRule->m_MSMQRuleHandler = pMSQMRuleHandler;

		return pMSQMRuleHandler;
	}
	catch(const _com_error& e)
	{
		//
		// Look if we already report about this problem. If no produce event log message
		//
		if (s_reportedRules.insert(pRule->m_bstrRuleID))
		{
			ReportInvocationError(
				pRule->m_bstrRuleName,
				pRule->m_bstrRuleID,
				e.Error(), 
				MSMQ_TRIGGER_RULE_PARSING_FAILED
				);
		}	
		throw;
	}
}



static 
void
CheckRuleCondition(
	CRuntimeRuleInfo* pRule,
	IMSMQPropertyBagPtr& pIPropertyBag,
	long& bConditionSatisfied
	)
{
	IMSMQRuleHandlerPtr pMSQMRuleHandler = GetRuleHandler(pRule);
	
	//
	// !!! This is the point at which the IMSMQRuleHandler component is invoked.
	// Note: Rules are always serialized - next rule execution starts only after 
	// previous has completed its action
	//
	try
	{
		pMSQMRuleHandler->CheckRuleCondition(
								pIPropertyBag.GetInterfacePtr(), 
								&bConditionSatisfied);		
	}
	catch(const _com_error& e)
	{
		TrERROR(GENERAL, "Failed to process received message for rule: %ls. Error=0x%x",(LPCTSTR)pRule->m_bstrRuleName, e.Error());

		//
		// Look if we already report about this problem. If no produce event log message
		//
		if (s_reportedRules.insert(pRule->m_bstrRuleID))
		{
			ReportInvocationError(
				pRule->m_bstrRuleName,
				pRule->m_bstrRuleID,
				e.Error(), 
				MSMQ_TRIGGER_RULE_INVOCATION_FAILED
				);
		}	
		throw;
	}

	TrTRACE(GENERAL, "Successfully checked condition for rule: %ls.",(LPCTSTR)pRule->m_bstrRuleName);
}


static 
void
ExecuteRule(
	CRuntimeRuleInfo* pRule,
	IMSMQPropertyBagPtr& pIPropertyBag,
	long& lRuleResult
	)
{

    IMSMQRuleHandlerPtr pMSQMRuleHandler = GetRuleHandler(pRule);

	//
	// !!! This is the point at which the IMSMQRuleHandler component is invoked.
	// Note: Rules are always serialized - next rule execution starts only after 
	// previous has completed its action
	//
	try
	{
		pMSQMRuleHandler->ExecuteRule(
								pIPropertyBag.GetInterfacePtr(), 
                                TRUE, //serialized
								&lRuleResult);		
        
	}
	catch(const _com_error& e)
	{
		TrERROR(GENERAL, "Failed to process received message for rule: %ls. Error=0x%x",(LPCTSTR)pRule->m_bstrRuleName, e.Error());

		//
		// Look if we already report about this problem. If no produce event log message
		//
		if (s_reportedRules.insert(pRule->m_bstrRuleID))
		{
			ReportInvocationError(
				pRule->m_bstrRuleName,
				pRule->m_bstrRuleID,
				e.Error(), 
				MSMQ_TRIGGER_RULE_INVOCATION_FAILED
				);
		}	
		throw;
	}

	TrTRACE(GENERAL, "Successfully pexecuted action for rule: %ls.",(LPCTSTR)pRule->m_bstrRuleName);


}


//********************************************************************************
//
// Method      : InvokeRegularRuleHandlers
//
// Description : Invokes the method that will execute the rule handlers
//               associated with the supplied trigger reference. This
//               method also controls what information from the message
//               will be copied into the property bag and passed to the 
//               rule-handler component(s).         
//
// Note        : Note that we create and populate only one instance of
//               the MSMQPropertyBag object, and pass this to each 
//               Rule-Handler : this implies we trust each rule handler
//               not to fool with the contents.
//
//********************************************************************************
HRESULT 
CTriggerMonitor::InvokeRegularRuleHandlers(
	IMSMQPropertyBagPtr& pIPropertyBag,
	CRuntimeTriggerInfo * pTriggerInfo,
	CQueue * pQueue
	)
{

   
	DWORD noOfRules = pTriggerInfo->GetNumberOfRules();
	bool bExistsConditionSatisfied = false;
   
	//
	// For each rule, invoke it's associated IMSMQTriggerHandling interface.
	//

	for (DWORD lRuleCtr = 0; lRuleCtr < noOfRules; lRuleCtr++)
	{
		CRuntimeRuleInfo* pRule = pTriggerInfo->GetRule(lRuleCtr);
		ASSERT(("Rule index is bigger than number of rules", pRule != NULL));

        long bConditionSatisfied=false;
		long lRuleResult=false;
       
		CheckRuleCondition(
						pRule, 
						pIPropertyBag, 
						bConditionSatisfied
						);
        if(bConditionSatisfied)
        {
            bExistsConditionSatisfied=true;
            ExecuteRule(
						pRule, 
						pIPropertyBag, 
						lRuleResult
						);

			if (s_reportedRules.erase(pRule->m_bstrRuleID) != 0)
			{
				EvReport(
					MSMQ_TRIGGER_RULE_INVOCATION_SUCCESS, 
					2, 
					static_cast<LPCWSTR>(pRule->m_bstrRuleName), 
					static_cast<LPCWSTR>(pRule->m_bstrRuleID)
					);
			}

            if(lRuleResult & xRuleResultStopProcessing)
            {
                TrTRACE(GENERAL, "Last processed rule (%ls) indicated to stop rules processing on Trigger (%ls). No further rules will be processed for this message.",(LPCTSTR)pRule->m_bstrRuleName,(LPCTSTR)pTriggerInfo->m_bstrTriggerName);						
                break;
            }
        }
        
	} 
	
	//
	// Receive message if at least one condition was satisdies 
	// and receive was requested
	//
	if (pTriggerInfo->GetMsgProcessingType() == RECEIVE_MESSAGE && bExistsConditionSatisfied)
	{
		_variant_t lookupId;
		HRESULT hr = pIPropertyBag->Read(_bstr_t(g_PropertyName_LookupId), &lookupId);
		ASSERT(("Can not read from property bag", SUCCEEDED(hr)));

		hr = ReceiveMessage(lookupId, pQueue);
		if ( FAILED(hr) )
		{
			TrERROR(GENERAL, "Failed to receive message after processing all rules");
			return hr;
		}
	}

	return S_OK;
}


void 
ReportSucessfullInvocation(
	CRuntimeTriggerInfo * pTriggerInfo,
	bool reportRuleInvocation
	)
{
	if (reportRuleInvocation)
	{
		DWORD noOfRules = pTriggerInfo->GetNumberOfRules();

		for (DWORD i = 0; i < noOfRules; ++i)
		{
			CRuntimeRuleInfo* pRule = pTriggerInfo->GetRule(i);
			ASSERT(("Rule index is bigger than number of rules", pRule != NULL));

			if (s_reportedRules.erase(pRule->m_bstrRuleID) != 0)
			{
				EvReport(
					MSMQ_TRIGGER_RULE_INVOCATION_SUCCESS, 
					2, 
					static_cast<LPCWSTR>(pRule->m_bstrRuleName), 
					static_cast<LPCWSTR>(pRule->m_bstrRuleID)
					);
			}
		} 
	}

	if (s_reportedTransactedTriggers.erase(pTriggerInfo->m_bstrTriggerID) != 0)
	{
		EvReport(
			MSMQ_TRIGGER_TRANSACTIONAL_INVOCATION_SUCCESS, 
			2, 
			static_cast<LPCWSTR>(pTriggerInfo->m_bstrTriggerName), 
			static_cast<LPCWSTR>(pTriggerInfo->m_bstrTriggerID)
			);
	}
}


//********************************************************************************
//
// Method      : InvokeTransactionalRuleHandlers
//
// Description : Invokes the method that will execute the rule handlers
//               associated with the supplied trigger reference. This
//               method also controls what information from the message
//               will be copied into the property bag and passed to the 
//               rule-handler component(s).         
//
// Note        : Note that we create and populate only one instance of
//               the MSMQPropertyBag object, and pass this to each 
//               Rule-Handler : this implies we trust each rule handler
//               not to fool with the contents.
//
//********************************************************************************
HRESULT 
CTriggerMonitor::InvokeTransactionalRuleHandlers(
    IMSMQPropertyBagPtr& pIPropertyBag,
	CRuntimeTriggerInfo * pTriggerInfo
	)
{
    
	DWORD noOfRules = pTriggerInfo->GetNumberOfRules();
	bool bExistsConditionSatisfied = false;

   
	//
	// For each rule, invoke it's associated IMSMQTriggerHandling interface.
	//
    DWORD dwRuleResult=0;
	bool fNeedReportSuccessInvocation = false;

	try
	{
		for (DWORD lRuleCtr = 0, RuleIndex=1; lRuleCtr < noOfRules; lRuleCtr++)
		{
			CRuntimeRuleInfo* pRule = pTriggerInfo->GetRule(lRuleCtr);
			ASSERT(("Rule index is bigger than number of rules", pRule != NULL));

			long bConditionSatisfied = false;

			CheckRuleCondition(
							pRule, 
							pIPropertyBag, 
							bConditionSatisfied
							);

			if(bConditionSatisfied)
			{
				bExistsConditionSatisfied = true;
				dwRuleResult |= RuleIndex;
			}

			RuleIndex <<=1;

			if (s_reportedRules.exist(pRule->m_bstrRuleID))
			{
				fNeedReportSuccessInvocation = true;
			}
		} 

		// Execute Rules && Receive message in Transaction if at least one condition was satisdies 
		//  dwRuleResult contains the bitmask for the rules that has been satisfied (first 32 rules)
		//
		if (bExistsConditionSatisfied)
		{
			ExecuteRulesInTransaction( 
								pTriggerInfo->m_bstrTriggerID,
								m_pMonitorPool->GetRegistryPath(),
								pIPropertyBag,
								dwRuleResult
								);

			ReportSucessfullInvocation(pTriggerInfo, fNeedReportSuccessInvocation);
		}
	}
	catch(const _com_error& e)
	{
		if (s_reportedTransactedTriggers.insert(pTriggerInfo->m_bstrTriggerID))
		{
			ReportInvocationError(
							pTriggerInfo->m_bstrTriggerName, 
							pTriggerInfo->m_bstrTriggerID, 
							e.Error(), 
							MSMQ_TRIGGER_TRANSACTIONAL_INVOCATION_FAILED
							);
			throw;
		}
	}

	return S_OK;
}

//********************************************************************************
//
// Method      : InvokeMSMQRuleHandlers
//
// Description : Invokes the method that will execute the rule handlers
//               associated with the supplied trigger reference. This
//               method also controls what information from the message
//               will be copied into the property bag and passed to the 
//               rule-handler component(s).         
//
// Note        : Note that we create and populate only one instance of
//               the MSMQPropertyBag object, and pass this to each 
//               Rule-Handler : this implies we trust each rule handler
//               not to fool with the contents.
//
//********************************************************************************
HRESULT 
CTriggerMonitor::InvokeMSMQRuleHandlers(
	CMsgProperties * pMessage,
	CRuntimeTriggerInfo * pTriggerInfo,
	CQueue * pQueue
	)
{
	HRESULT hr;

	try
	{
		TrTRACE(GENERAL, "Activate Trigger: %ls  on queue: %ls.",(LPCTSTR)pTriggerInfo->m_bstrTriggerName,(LPCTSTR)pTriggerInfo->m_bstrQueueName);
		
		//
		// Create an instance of the property bag object we will pass to the rule handler, 
		// and populate it with the currently supported property values. Note that we pass
		// the same property bag instance to all rule handlers. 
		//
		IMSMQPropertyBagPtr pIPropertyBag;
		CreatePropertyBag(pMessage, pTriggerInfo, pQueue->m_bstrFormatName, pIPropertyBag);

	
		if (pTriggerInfo->GetMsgProcessingType() == RECEIVE_MESSAGE_XACT)
		{
		    return InvokeTransactionalRuleHandlers(
                                    pIPropertyBag,
	                                pTriggerInfo
	                                );
		    
		}
        else
        {
            return InvokeRegularRuleHandlers(
                               pIPropertyBag,
	                           pTriggerInfo,
	                           pQueue
	                           );
        }	
	}
	catch(const _com_error& e)
	{
		hr = e.Error();
	}
	catch(const bad_hresult& e)
	{
		hr = e.error();
	}
	catch(const bad_alloc&)
	{
		hr = MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}

	TrERROR(GENERAL, "Failed to invoke rule handler. Error=0x%x.", hr);			
	return(hr);
}

//********************************************************************************
//
// Method      : ProcessMessageFromAdminQueue
//
// Description : processes a message that has been received from an administration
//               queue. In the current implementation this will be for messages 
//               indicating that underlying trigger data has changed. This method
//               will construct a new admin message object and hand it over to the 
//               triggermonitorpool object for subsequent processing.
//
//********************************************************************************
HRESULT CTriggerMonitor::ProcessMessageFromAdminQueue(const CMsgProperties* pMessage)
{
	_bstr_t bstrLabel;
	CAdminMessage * pAdminMsg = NULL;
	CAdminMessage::eMsgTypes eMsgType;

	// Ensure that we have been passsed a valid message pointer 
	ASSERT(pMessage != NULL);

	// get a copy of the message label
	bstrLabel = pMessage->GetLabel();
		
	// determine what sort of admin message we should be creating based on label.
	if (_tcsstr((wchar_t*)bstrLabel,MSGLABEL_TRIGGERUPDATED) != NULL)
	{
		eMsgType = CAdminMessage::eMsgTypes::eTriggerUpdated;
	}
	else if (_tcsstr((wchar_t*)bstrLabel,MSGLABEL_TRIGGERADDED) != NULL)
	{
		eMsgType = CAdminMessage::eMsgTypes::eTriggerAdded;
	}
	else if (_tcsstr((wchar_t*)bstrLabel,MSGLABEL_TRIGGERDELETED) != NULL)
	{
		eMsgType = CAdminMessage::eMsgTypes::eTriggerDeleted;
	}
	else if (_tcsstr((wchar_t*)bstrLabel,MSGLABEL_RULEUPDATED) != NULL)
	{
		eMsgType = CAdminMessage::eMsgTypes::eRuleUpdated;
	}
	else if (_tcsstr((wchar_t*)bstrLabel,MSGLABEL_RULEADDED) != NULL)
	{
		eMsgType = CAdminMessage::eMsgTypes::eRuleAdded;
	}
	else if (_tcsstr((wchar_t*)bstrLabel,MSGLABEL_RULEDELETED) != NULL)
	{
		eMsgType = CAdminMessage::eMsgTypes::eRuleDeleted;
	}
	else
	{
		// unrecognized message label on an administrative message - log an error.
		ASSERT(("unrecognized admin message type", 0));

		// set a return code.
		return E_FAIL;
	}

	// Allocate a new CAdminMessage object instance.
	pAdminMsg = new CAdminMessage(eMsgType);

    // Ask the TriggerMonitorPool object to process this message
    return m_pMonitorPool->AcceptAdminMessage(pAdminMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\monitorp.cpp ===
//*******************************************************************
//
// Class Name  : CTriggerMonitorPool
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class is the container for the set of worker 
//               threads that perform the trigger monitoring and 
//               processing. The key features of this class are 
//
//               (1) It provides aggregate startup and shutdown 
//                   functions for the worker thread group as a whole,
//
//               (2) It provides thread pool maintenance and recovery,
//
//               (3) It intitializes and maintains the cache of 
//                   trigger information,
//
//               (4) It performs the synchronization of the trigger 
//                   data cache as required.
//
//                There will be only one instance of this class in the 
//                entire MSMQ trigger service. 
//
//                This class is derived from the base class CThread, and
//                has it's own thread. This thread is used as an 
//                adminstrative thread only,it does perform trigger rule
//                processing.
//
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#include "stdafx.h"
#include "Ev.h"
#include "stdfuncs.hpp"
#include "cmsgprop.hpp"
#include "triginfo.hpp"
#include "ruleinfo.hpp"
#include "monitorp.hpp"
#include "mqsymbls.h"
#include <mqtg.h>
#include "Tgp.h"
#include "ss.h"
#include "privque.h"
#include <strsafe.h>

#include "monitorp.tmh"

using namespace std;

CCriticalSection g_csSyncTriggerInfoChange;


//*******************************************************************
//
// Method      : Constructor 
//
// Description : Initializes a new instance of CTriggerMonitorPool class.
//
//*******************************************************************
CTriggerMonitorPool::CTriggerMonitorPool(
	IMSMQTriggersConfigPtr  pITriggersConfig,
	LPCTSTR pwzServiceName
	) : 
    CThread(8000,CREATE_SUSPENDED,_T("CTriggerMonitorPool"),pITriggersConfig),
	m_hAdminEvent(CreateEvent(NULL,FALSE,FALSE,NULL))
{
	if (m_hAdminEvent == NULL) 
	{
		TrERROR(GENERAL, "Failed to create an event. Error 0x%x", GetLastError());
		throw bad_alloc();
	}

	// Initialise member vars
	m_bInitialisedOK = false;
	m_lNumberOfWaitingMonitors = 0;

	GetTimeAsBSTR(m_bstrStartTime);
	GetTimeAsBSTR(m_bstrLastSyncTime);	

	
	HRESULT hr = StringCchCopy(m_wzRegPath, TABLE_SIZE(m_wzRegPath), REGKEY_TRIGGER_PARAMETERS);
	if FAILED(hr)
	{	
		TrERROR(GENERAL, "Buffer too small");	
		throw bad_hresult(hr);
	}
	//
	// Service is running on cluster virtual server
	//
	if ( _wcsicmp(pwzServiceName, xDefaultTriggersServiceName) != 0 )
	{
		hr = StringCchCat(m_wzRegPath,TABLE_SIZE(m_wzRegPath),REG_SUBKEY_CLUSTERED);
		if FAILED(hr)
		{	
			TrERROR(GENERAL, "Buffer too small");	
			throw bad_hresult(hr);
		}
		hr = StringCchCat(m_wzRegPath,TABLE_SIZE(m_wzRegPath),pwzServiceName);
		if FAILED(hr)
		{	
			TrERROR(GENERAL, "Buffer too small");	
			throw bad_hresult(hr);
		}
	}

	//
	// Create an instance of the MSMQTriggerSet component
	//
	hr = m_pMSMQTriggerSet.CreateInstance(__uuidof(MSMQTriggerSet));
	if FAILED(hr)
	{	
		TrERROR(GENERAL, "Failed to create MSMQTriggerSet component. Error =0x%x", hr);	
		throw bad_hresult(hr);
	}

	BSTR bstrTriggerStoreMahcine = NULL;
	m_pITriggersConfig->get_TriggerStoreMachineName(&bstrTriggerStoreMahcine);

	m_pMSMQTriggerSet->Init(bstrTriggerStoreMahcine);
	SysFreeString(bstrTriggerStoreMahcine);
}


//*******************************************************************
//
// Method      : CTriggerMonitorPool
//
// Description : Destroys an instance of the CTriggerMonitorPool. This 
//               involves deleting any messages remaining in the admin
//               message list, as well as closing some event handles.
//
//*******************************************************************
CTriggerMonitorPool::~CTriggerMonitorPool()
{
	//
	// Clear out any unprocessed messages from the Admin message list.
	// Acquire a writer lock to the list of Admin messsages
	//
	CS cs(m_AdminMsgListLock);

	for(ADMIN_MESSAGES_LIST::iterator it = m_lstAdminMessages.begin(); it != m_lstAdminMessages.end(); )
	{
		P<CAdminMessage> pAdminMessage = *it;
		it = m_lstAdminMessages.erase(it);
	}
}

//*******************************************************************
//
// Method      : Init
//
// Description : This is an over-ride from the CThread base class. This
//               method is called before the thread enters it's main 
//               processing loop (the Run() method). Key initialization 
//               steps are :
//
//               (1) Create an instance of the queue manager,
//
//               (2) Retrieve the trigger data from the database using 
//                   the COM component MSMQTriggerSet,
//
//               (3) Attach this trigger information to the appropriate 
//                   queues.
//
//*******************************************************************
bool CTriggerMonitorPool::Init( )
{
	HRESULT hr = S_OK;

	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());
	ASSERT(m_bInitialisedOK == false);

	// Write a trace message
	TrTRACE(GENERAL, "Trigger monitor pool initialization has been called.");

	// we want the admin thread to have slightly higher priority than worker threads.
	SetThreadPriority(this->m_hThreadHandle,THREAD_PRIORITY_ABOVE_NORMAL);

	//
	// Create an instance of the queue manager to be shared by all threads in the pool
	//
	m_pQueueManager = new CQueueManager(m_pITriggersConfig);

	//
	// Create the IO completion port that will be used to receive async queue events.
	//
	CreateIOCompletionPort(); 

	//
	// Build the runtime triggger and rule info
	//
	RUNTIME_TRIGGERINFO_LIST lstTriggerInfo;		
	GetTriggerData(lstTriggerInfo);

	AttachTriggersToQueues(lstTriggerInfo);

	// Reset the NT event that prevents the monitor threads from processing messages	
	if (ResetEvent(g_hServicePaused) == FALSE)
	{
		TrERROR(GENERAL, "Failed to reset an event. Unable to continue. Error 0x%x", GetLastError());
		throw bad_alloc();
	}

    DWORD initThreadNum = numeric_cast<DWORD>(m_pITriggersConfig->GetInitialThreads()); 
    if (m_pITriggersConfig->GetInitialThreads() > m_pITriggersConfig->GetMaxThreads())
    {
        initThreadNum = numeric_cast<DWORD>(m_pITriggersConfig->GetMaxThreads());            
    }

	// Create the initial pool of trigger monitors			
	for (DWORD ulCounter = 0; ulCounter < initThreadNum; ulCounter++)			
	{
		hr = CreateTriggerMonitor();
		if(FAILED(hr))
		{		
			TrERROR(GENERAL, "Failed to create trigger monitor thread. Unable to continue. Error 0x%x", hr);
			break;
		}
	}

	if (m_lstTriggerMonitors.size() < 1)
	{
		TrERROR(GENERAL, "The Trigger Monitor thread pool has completed initialisation and there are no trigger monitor threads to service queue events. Unable to continue.");
		throw bad_alloc();
	}

	//
	// Set the NT event that allows the monitor threads to start processing.
	//
	if (SetEvent(g_hServicePaused) == FALSE)
	{
		TrERROR(GENERAL, "Failed to set an event. Unable to continue. Error %d", GetLastError());
		throw bad_alloc();
	}

	m_bInitialisedOK = true;
	return true;
}

//*******************************************************************
//
// Method      : CreateTriggerMonitor
//
// Description : Create a new CTriggerMonitor object (trigger worker
//               thread, and add this to the list of trigger monitors.
//
//*******************************************************************
HRESULT CTriggerMonitorPool::CreateTriggerMonitor()
{
	//
	// First we need to determine how many running trigger monitors there are
	//
	DWORD dwRunningMonitors = GetNumberOfRunningTriggerMonitors();

	//
	// First we must check if we are allowed to create an additional thread.
	//
	if (dwRunningMonitors >= (DWORD)m_pITriggersConfig->GetMaxThreads())
	{
		return E_FAIL;
	}

	//
	// Create a new monitor (monitors are created 'suspended')
	//
	R<CTriggerMonitor> pNewMonitor = new CTriggerMonitor(
													this,
													m_pITriggersConfig.GetInterfacePtr(),
													&m_hIOCompletionPort,
													m_pQueueManager.get() 
													);
	
	//
	// Add it to the list of monitor pointers.
	//
	m_lstTriggerMonitors.push_back(pNewMonitor);

	//
	// Let this monitor (thread) go.
	//
	if (!pNewMonitor->Resume())
	{
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "Resume() failed. Error: %!winerr!", gle);
		return (HRESULT_FROM_WIN32(gle));
	}

	pNewMonitor.detach();

	TrTRACE(GENERAL, "New trigger monitor was created and added to the pool.");
	return S_OK;
}

//*******************************************************************
//
// Method      : ShutdownThreadPool
//
// Description : Called by the owner of this thread pool instance, this
//               method initiates and orderly shutdown of all worker 
//               threads in the pool. This is done by setting a 'function
//               code' and signalling an event that will wake up the 
//               threadpool's administrative thread. This method does 
//               returns when either the thread pool has been shut-down,
//               or the timeout period has expired.
//
//*******************************************************************
HRESULT CTriggerMonitorPool::ShutdownThreadPool()
{
	DWORD dwWait = WAIT_OBJECT_0;

	// The TriggerMonitor thread should not be calling this method - check this.
	ASSERT(this->GetThreadID() != (DWORD)GetCurrentThreadId());
	
	{

		CS cs(m_csAdminTask);

		// Set a token indicating what we want the trigger monitor admin thread to do.
		m_lAdminTask = ADMIN_THREAD_STOP;

		// Wake up the trigger monitor admin thread
		BOOL fRet = SetEvent(m_hAdminEvent);
		if(fRet == FALSE)
		{
			TrERROR(GENERAL, "Set admin event failed, Error = %d", GetLastError());
			return E_FAIL;
		}
	}
	//Note: ~cs() must be called before the wait operation

	// Wait for the shutdown to complete, timeout here is infinite since
	// the administrator thread wait for all threads with timeout
	// and should end in a timely manner
	dwWait = WaitForSingleObject(m_hThreadHandle, INFINITE);
	if(dwWait == WAIT_FAILED)
	{
		TrERROR(GENERAL, "WaitForSingleObject failed for the CTriggerMonitorPool to shutdown. Error= %d", dwWait);
		return E_FAIL;
	}
		
	return S_OK;
}

//*******************************************************************
//
// Method      : Run()
//
// Description : This is an over-ride from the CThread base class. This
//               is the main processing loop for this thread. The thread
//               owned by this class is used to :
//
//               (1) handle synchronization between the in-memory data 
//                   cache of trigger information and the trigger DB,
//
//               (2) Perform periodic processing, such as composing and 
//                   issuing status info.
//
//               The CTriggerMonitorPool thread blocks on an NT event 
//               created during the initialization until either :
//              
//               (1) the admin event is signalled - in which case the 
//                   admin function code can be tested to determine 
//                   what sort of admin processing we need to do, or 
//
//               (2) the timeout expires - in which case the thread 
//                   performs whatever periodic processing we have 
//                   defined for it.     
//
//*******************************************************************
bool CTriggerMonitorPool::Run()
{
	bool bOK = true;
	HRESULT hr = S_OK;
	DWORD dwWait = WAIT_OBJECT_0;

	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	while (IsRunning())
	{
		// Block on the admin event object
		dwWait = WaitForSingleObject(m_hAdminEvent,ADMIN_THREAD_WAKEUP_PERIOD);

		switch(dwWait)
		{
			case WAIT_OBJECT_0:
			{
				long lAdminTask = GetAdminTask();//resets admin task as well

				if(lAdminTask == ADMIN_THREAD_PROCESS_NOTIFICATIONS)
				{
					// The thread was woken up to process notifications.
					ProcessAdminMessages();
				}
				else if(lAdminTask == ADMIN_THREAD_STOP)
				{
					// The thread was woken up because it has been asked to stop.
					this->Stop();
				}
				break;
			}
			case WAIT_TIMEOUT:
			{
				// The Admin thread exited the wait because the wake-up time period 
				// has expired. Use this opportunity to perform periodic processing.
				hr = PerformPeriodicProcessing();

				break;
			}
			default:
			{
				ASSERT(false); // This should never happen.
				break;
			}
		}	
	}

	return(bOK);
}


long CTriggerMonitorPool::GetAdminTask()
{
	CS cs(m_csAdminTask);

	long lOldTask = m_lAdminTask;

	//
	// Reset the admin task indicator back to idle only if we aren't in stop mode
	//
	if (m_lAdminTask == ADMIN_THREAD_PROCESS_NOTIFICATIONS)
	{
		m_lAdminTask = ADMIN_THREAD_IDLE;
	}

	return lOldTask;
}


//*******************************************************************
//
// Method      : Exit()
//
// Description : This is an over-ride from the CThread base class. This
//               method is called when the thread has exited it's main 
//               processing loop (Run). This key cleanup performed by
//               this method is the purging of the TriggerMonitor thread
//               instances.
//
//*******************************************************************
bool CTriggerMonitorPool::Exit()
{
	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	// First we need to make sure that the monitor threads are not block on the service
	// pause / resume event object. Here we will reset the event allowing monitors threads
	// to clean up.
	SetEvent(g_hServicePaused);

	// Reset our list iterator to the beggining.
	for(TRIGGER_MONITOR_LIST::iterator it = m_lstTriggerMonitors.begin(); it != m_lstTriggerMonitors.end(); ++it)
	{
		(*it)->Stop();
	}

	// This will wake up all monitors and give them a chance to notice that a stop request
	// has been made. Each monitor will then start shutdown tasks.
	PostMessageToAllMonitors(TRIGGER_MONITOR_WAKE_UP_KEY);


	TRIGGER_MONITOR_LIST::iterator iMonitorRef;

	iMonitorRef = m_lstTriggerMonitors.begin();

	// Initialize trigger monitor reference.
	while ( (iMonitorRef != m_lstTriggerMonitors.end()) && (!m_lstTriggerMonitors.empty()) )
	{
		// Cast the reference to a monitor type
		R<CTriggerMonitor> pTriggerMonitor = (*iMonitorRef);

		// Wait on the thread-handle of this TriggerMonitor.
		DWORD dwWait = WaitForSingleObject(pTriggerMonitor->m_hThreadHandle, TRIGGER_MONITOR_STOP_TIMEOUT);

		// This Trigger monitor won't go quietly - we've got to kill it.
		if (dwWait != WAIT_OBJECT_0) 
		{
			TrERROR(GENERAL, "Failed to stop a trigger monitor within the timeout period %d.", TRIGGER_MONITOR_STOP_TIMEOUT);
		}

		// remove this reference from the list of monitors
		iMonitorRef = m_lstTriggerMonitors.erase(iMonitorRef);
	}

	return(true);
}

//*******************************************************************
//
// Method      : CreateIOCompletionPort
//
// Description : This method creates the NT IO completion port that 
//               will be used to recieve messsages asynchronously.
//
//*******************************************************************
void CTriggerMonitorPool::CreateIOCompletionPort()
{
	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	m_hIOCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE,NULL,0,0);

	// Attempt to open the queue that this Monitor watches.
	if (m_hIOCompletionPort == NULL)
	{
		DWORD rc = GetLastError();

		TrERROR(GENERAL, "Create complition port failed. Error =%d", rc);
		throw bad_win32_error(rc);
	}

	TrTRACE(GENERAL, "Successfully created IO Completion port: %p.", m_hIOCompletionPort);		
}

//get a copy of the current admin message list and reset it
void CTriggerMonitorPool::GetAdminMessageListCopy(ADMIN_MESSAGES_LIST& adminList)
{
	//
	// Only the TriggerMonitor thread should be executing this method - assert this.
	//
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	//
	// Acquire a writer lock to the list of Admin messsages (Note that this will block
	// any TriggerMonitor threads attempting to hand-over an admin message).
	//
	CS csAdminMsgList(m_AdminMsgListLock);

	for(ADMIN_MESSAGES_LIST::iterator it = m_lstAdminMessages.begin(); it != m_lstAdminMessages.end();)
	{
		adminList.push_back(*it);
		it = m_lstAdminMessages.erase(it);
	}
}


//*******************************************************************
//
// Method      : ProcessAdminMessages
//
// Description : Process the messages currently stored in the member 
//               var list of CAdminMessage instances. This list 
//               represents a group of admin requests that need to be 
//               processed by the CTriggerMonitorPool thread.
//            
//               In this implementation of Triggers, we rebuild all the 
//               trigger data whenever a notification message arrives. 
//               Future implementation may anlayze the individual notification
//               messages and change only the trigger info structure that
//               have changed in the underlying data store. For now, we will 
//               clear the contents of the Admin message list - and 
//               rebuild the trigger info once.
//
//*******************************************************************
void CTriggerMonitorPool::ProcessAdminMessages()
{
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	HRESULT hr;
	ADMIN_MESSAGES_LIST AdminList;

	bool fUpdateTriggers = false;
	
	while (GetAdminTask() != ADMIN_THREAD_STOP)
	{
		try
		{
			GetAdminMessageListCopy(AdminList);

			// Record the synchronization time (used in status reporting)
			GetTimeAsBSTR(m_bstrLastSyncTime);

			

			for(ADMIN_MESSAGES_LIST::iterator it = AdminList.begin(); it != AdminList.end(); )
			{
				CAdminMessage* pAdminMessage = *it;

				switch (pAdminMessage->GetMessageType())
				{
					case CAdminMessage::eMsgTypes::eNewThreadRequest:
					{
						// attempt to create a new trigger monitor (thread)
						CreateTriggerMonitor();
						break;  
					} 
					//
					// note we treat any sort of change in the underlying trigger data in the
					// same way - we reload the completed trigger data cache.
					//
					case CAdminMessage::eMsgTypes::eTriggerAdded:
					case CAdminMessage::eMsgTypes::eTriggerDeleted:
					case CAdminMessage::eMsgTypes::eTriggerUpdated:
					case CAdminMessage::eMsgTypes::eRuleAdded:
					case CAdminMessage::eMsgTypes::eRuleUpdated:
					case CAdminMessage::eMsgTypes::eRuleDeleted:
					{
						fUpdateTriggers = true;
						break;
					}
					//
					// unrecognized message type - this should never happen.
					//
					default:
						ASSERT(("unrecognized message type", 0));
						break;
				}

				P<CAdminMessage> pTempAdminMessage = pAdminMessage;
				it = AdminList.erase(it);
			}

			if (fUpdateTriggers)
			{
				RUNTIME_TRIGGERINFO_LIST lstTriggerInfo;
 
				GetTriggerData(lstTriggerInfo);
				AttachTriggersToQueues(lstTriggerInfo);
			}
			
			return;
		}
		catch(const _com_error& e)
		{
			hr = e.Error();
		}
		catch(const bad_alloc&)
		{
			hr = MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
		}
		catch(const exception&)
		{
			hr = MQTRIG_ERROR;
		}

		if (m_lAdminTask != ADMIN_THREAD_STOP)
		{
			ASSERT(FAILED(hr));	
			TrERROR(GENERAL, "Failed to process admin message. Error=%!hresult!. Retrying...", hr);
			Sleep(5000);
		}
	}

	//
	// We got here because we got a ADMIN_THREAD_STOP task. Delete the list and exit.
	//
	for(ADMIN_MESSAGES_LIST::iterator it = AdminList.begin(); it != AdminList.end(); )
	{
		P<CAdminMessage> pAdminMessage = *it;
		it = AdminList.erase(it);
	}
	
}



void 
CTriggerMonitorPool::GetAttachedRuleData(
	const BSTR& bsTriggerID,
	long ruleNo,
	RUNTIME_RULEINFO_LIST& ruleList
	)
{
	ASSERT(ruleNo > 0);

	for(long i = 0; i < ruleNo; i++)
	{
		BSTR bsRuleID = NULL;
		BSTR bsRuleName = NULL;
		BSTR bsRuleDescription = NULL;
		BSTR bsRuleCondition = NULL;
		BSTR bsRuleAction = NULL;
		BSTR bsRuleImplementationProgID = NULL;
		long lShowWindow = 0;

		m_pMSMQTriggerSet->GetRuleDetailsByTriggerID(
											bsTriggerID,
											i,
											&bsRuleID,
											&bsRuleName,
											&bsRuleDescription,													
											&bsRuleCondition,
											&bsRuleAction,
											&bsRuleImplementationProgID,
											&lShowWindow
											); 

		//
		// Allocate a new trigger structure 
		//
		P<CRuntimeRuleInfo> pRuleInfo = new CRuntimeRuleInfo(
														bsRuleID,
														bsRuleName,
														bsRuleDescription,
														bsRuleCondition,
														bsRuleAction,
														bsRuleImplementationProgID,
														m_wzRegPath,
														(lShowWindow != 0) );

		// Attach this rule to the current trigger info structure (at the end);
		ruleList.push_back(pRuleInfo);
		pRuleInfo.detach();
	
		SysFreeString(bsRuleID);
		SysFreeString(bsRuleName);
		SysFreeString(bsRuleCondition);
		SysFreeString(bsRuleAction);
		SysFreeString(bsRuleImplementationProgID);
		SysFreeString(bsRuleDescription);			
	}
}


static bool s_fReportTriggerFailure = false;
static CSafeSet< _bstr_t > s_reported;

R<CRuntimeTriggerInfo>
CTriggerMonitorPool::GetTriggerRuntimeInfo(
	long triggerIndex
	)
{
	ASSERT(("Invalid trigger index",  triggerIndex >= 0));

	long lNumRules = 0;
	long lEnabled = 0;
	long lSerialized = 0;
	MsgProcessingType msgProctype = PEEK_MESSAGE;
	BSTR bsTriggerID = NULL;
	BSTR bsTriggerName = NULL;
	BSTR bsQueueName = NULL;
	SystemQueueIdentifier SystemQueue = SYSTEM_QUEUE_NONE;

	//
	// Get this trigger's details 
	//
	m_pMSMQTriggerSet->GetTriggerDetailsByIndex(
								triggerIndex,
								&bsTriggerID,
								&bsTriggerName,
								&bsQueueName, 
								&SystemQueue, 
								&lNumRules,
								&lEnabled, 
								&lSerialized,
								&msgProctype);
	
	try
	{
		R<CRuntimeTriggerInfo> pTriggerInfo;
		//
		// We only bother with enabled triggers that have rules.
		//
		if ((lNumRules > 0) && (lEnabled != 0))
		{
			//
			// Allocate a new trigger info structure 
			//
			pTriggerInfo = new CRuntimeTriggerInfo(
											bsTriggerID,
											bsTriggerName,
											bsQueueName,
											m_wzRegPath,
											SystemQueue,
											(lEnabled != 0),
											(lSerialized != 0),
											msgProctype
											);


			GetAttachedRuleData(bsTriggerID, lNumRules, pTriggerInfo->m_lstRules);
		}

		//
		// Free the BSTR's !
		//
		SysFreeString(bsTriggerID);
		SysFreeString(bsTriggerName);
		SysFreeString(bsQueueName);

		return pTriggerInfo;
	}
	catch(const _com_error&)
	{
	}
	catch(const exception&)
	{
	}

	TrERROR(GENERAL, "Failed to retreive attched rule information for trigger %ls.", (LPCWSTR)bsTriggerID);
	
	//
	// Look if we already report about this problem. If no produce event log message
	//
	if (s_reported.insert(bsTriggerID))
	{
		EvReport(
			MSMQ_TRIGGER_FAIL_RETREIVE_ATTACHED_RULE_INFORMATION,
			2, 
			static_cast<LPCWSTR>(bsTriggerID),
			static_cast<LPCWSTR>(bsTriggerName)
			);
	}

	SysFreeString(bsTriggerID);
	SysFreeString(bsTriggerName);
	SysFreeString(bsQueueName);
	return NULL;
}


R<CRuntimeTriggerInfo>
CTriggerMonitorPool::CreateNotificationTrigger(
	void
	)
{
	_bstr_t bstrNotificationsTriggerName = _T("MSMQ Trigger Notifications");

	// Use the MSMQ Triggers Configuration component to retrieve the name of the notifications queue.
	_bstr_t bstrNotificationsQueueName = _bstr_t(L".\\private$\\") + _bstr_t(TRIGGERS_QUEUE_NAME);

	// Allocate a new trigger info structure - NOTE that we treat this as a serialized trigger.
	// This trigger is marked as "Admin Trigger" - special message handling
	R<CRuntimeTriggerInfo> pTriggerInfo = new CRuntimeTriggerInfo(
																_T(""),
																bstrNotificationsTriggerName,
																bstrNotificationsQueueName,
																m_wzRegPath,
																SYSTEM_QUEUE_NONE,
																true,
																true,
																PEEK_MESSAGE);
	
	pTriggerInfo->SetAdminTrigger();

	return pTriggerInfo;
}

//*******************************************************************
//
// Method      : GetTriggerData
//
// Description : This method uses the COM object MSMQTriggerSet to 
//               collect the trigger information from the database 
//               and build an in memory cache of trigger-info structures.
//               Note that this method places the instances of the 
//               trigger info structures into a temporary list - each 
//               trigger info structure will eventually be removed from 
//               this temporary list and attached to the appropriate 
//               queue object.
//
//*******************************************************************
void 
CTriggerMonitorPool::GetTriggerData(
	RUNTIME_TRIGGERINFO_LIST &lstTriggerInfo
	)
{
	//
	// Only the TriggerMonitor thread should be executing this method - assert this.
	//
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	//
	// The trigger list should be empty at this point - if it is not, something is seriously wrong.
	//
	ASSERT(lstTriggerInfo.size() == 0);

	try
	{
		//
		// Build the trigger map and determine how many triggers there are.
		//
		m_pMSMQTriggerSet->Refresh();
		
		long lNumTriggers;
		m_pMSMQTriggerSet->get_Count(&lNumTriggers);
		ASSERT(lNumTriggers >= 0);

		//
		// We need to perform 'per trigger' initailization - as each thread can service any defined trigger
		//
		for(long lTriggerCtr = 0; lTriggerCtr < lNumTriggers; lTriggerCtr++)
		{
			//
			// Retreive trigger inforamtion and the attached rules
			//
			R<CRuntimeTriggerInfo> pTriggerInfo = GetTriggerRuntimeInfo(lTriggerCtr);
			
			if (pTriggerInfo.get() != NULL)
			{
				//
				// Add this to our list of run-time trigger info objects
				//
				lstTriggerInfo.push_back(pTriggerInfo);
			}
		}

		//
		// Now we want to add one final trigger for the MSMQ Trigger Notifications queue. This 
		// trigger is a different from normal triggers in that it does not have a rule defined. 
		// By using a private constructor - the TriggerInfo object is marked as a special 'Admin'
		// trigger - and we can test for this on message arrival.
		//
		R<CRuntimeTriggerInfo> pTriggerInfo = CreateNotificationTrigger();

		//
		// Add this to our list of run-time trigger info objects
		//
		lstTriggerInfo.push_back(pTriggerInfo);
		TrTRACE(GENERAL, "Successfully loaded all the trigger(s) into the Active Trigger Map.");
		s_fReportTriggerFailure	= false;
	}
	catch(const exception&)
	{
		TrERROR(GENERAL, "Failed to retrieve trigger information.");

		if (!s_fReportTriggerFailure)
		{
			EvReport(MSMQ_TRIGGER_FAIL_RETREIVE_TRIGGER_INFORMATION);
			s_fReportTriggerFailure	= true;
		}

		throw;
	}
}


//*******************************************************************
//
// Method      : AttachTriggersToQueues
//
// Description : Works through the list of triggers and attaches each
//               one to the apprropriate Queue object. References to 
//               the Queue objects is obtained via the AddQueue() call
//               to the Queue Manager which will either add a new queue
//               or return a reference to an existing queue instance.
//               Once all triggers have been attached, we iterate through
//               the queue list again, removing queues that no longer 
//               have any triggers attached.
//
//*******************************************************************
void CTriggerMonitorPool::AttachTriggersToQueues(RUNTIME_TRIGGERINFO_LIST& lstTriggerInfo)
{
	//
	// Only the TriggerMonitor thread should be executing this method - assert this.
	//
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	//
	// Acquire exclusive lock on queue manager to insure that no one try to access the 
	// trigger info while refreshing it. We use a global read-write lock on queue manager
	// since the trigger object doesn't contains reference counting.
	//
	CS lock(g_csSyncTriggerInfoChange);

	//
	// Firstly we want to iterate through all the current queues instances, and expire 
	// whatever trigger info instances they have attached to them.
	//
	m_pQueueManager->ExpireAllTriggers();

	//
	// Now we iterate through the temporary list of trigger info, attaching each trigger
	// info object to the appropriate queue object. 
	//
	for(RUNTIME_TRIGGERINFO_LIST::iterator it = lstTriggerInfo.begin(); it != lstTriggerInfo.end() ; )
	{
		if (m_lAdminTask == ADMIN_THREAD_STOP)
		{
			//
			// We've been asked to stop before completing initialization.
			//
			throw exception();
		}
		
		//
		// Get a reference to our first trigger info structure				
		//
		R<CRuntimeTriggerInfo> pTriggerInfo = *it;
		bool fOpenForReceive = 	(pTriggerInfo->GetMsgProcessingType() == RECEIVE_MESSAGE) || 
			                    (pTriggerInfo->GetMsgProcessingType() == RECEIVE_MESSAGE_XACT) ||
								pTriggerInfo->IsAdminTrigger();

		// Attempt to add this queue - note that if one already exists we will get a reference to the existing queue.
		R<CQueue> pQueue = m_pQueueManager->AddQueue(
												pTriggerInfo->m_bstrQueueName,
												pTriggerInfo->m_bstrTriggerName,
												fOpenForReceive,
												&m_hIOCompletionPort
												);
					
		//if (pQueue.IsValid())
		if(pQueue.get() != NULL)
		{
			//
			// Attach this trigger to the queue.
			//
			pQueue->AttachTrigger(pTriggerInfo);
		}
		else
		{
			TrERROR(GENERAL, "Failed to attach trigger %ls to queue %ls.", (LPCWSTR)pTriggerInfo->m_bstrTriggerID, (LPCWSTR)pTriggerInfo->m_bstrQueueName);
		}

		// Remove this trigger from the trigger monitor list as it is now attached to a queue,
		// the returned iterator will point to the next item in the list.
		it = lstTriggerInfo.erase(it);
	}

	ASSERT(lstTriggerInfo.size() == 0);

	//
	// Now we can walk through the queue list and remove the queues no longer have 
	// any trigger attached.
	//
	m_pQueueManager->RemoveUntriggeredQueues();

	TrTRACE(GENERAL, "Successfully attached all trigger(s) to queue(s).");
}


//*******************************************************************
//
// Method      : PerformPeriodicProcessing
//
// Description : This method is called periodically to peform routine
//               administration & monitoring tasks. This includes :
//
//               (1) determining if the thread pool need to be scaled
//                   down - and removing CTriggerMonitor thread instances
//                   if this is the case,
//
//               (2) removing any dead monitor threads from the thread 
//                   pool,
//
//*******************************************************************
HRESULT CTriggerMonitorPool::PerformPeriodicProcessing()
{
	TrTRACE(GENERAL, "Trigger monitor pool perform periodic processing");

	HRESULT hr = S_OK;
	DWORD dwWait = WAIT_OBJECT_0;
	long lRunningMonitors = 0;
	long lRequiredMonitors = 0; 
	long lExpiredMonitors = 0;
	TRIGGER_MONITOR_LIST::iterator iMonitorRef;
	

	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	// Calculate how many monitor threads we have in excess of the initial (normal) state.
	lRequiredMonitors = m_pITriggersConfig->GetInitialThreads();

	// If we have excess monitors, then we will walk through the list looking for any monitors
	// that have been idle for a period of time. Keep a count of idle, excess monitors.
	iMonitorRef = m_lstTriggerMonitors.begin();

	while ((iMonitorRef != m_lstTriggerMonitors.end()) && (!m_lstTriggerMonitors.empty()) )
	{
		// Cast the reference to a monitor type
		
		R<CTriggerMonitor> pTriggerMonitor = (*iMonitorRef);

		if (pTriggerMonitor->IsRunning()) 
		{
			// Increment the count of running monitors
			lRunningMonitors++;			

			// If at this point we have more running monitors than we require, examine the each monitor
			// to determine if it has been idle for a period of time that allows us to expire it.
			if ((lRunningMonitors > lRequiredMonitors) && (pTriggerMonitor->m_dwLastRequestTickCount < (GetTickCount() - MONITOR_MAX_IDLE_TIME)))
			{
				// trace message to indicate that we are asking a thread monitor to stop.
				TrTRACE(GENERAL, "Requesting STOP on trigger monitor. Trhead no: %d.", pTriggerMonitor->GetThreadID());

				// Ask this trigger monitor to stop. The next time the monitor wakes up, it  will
				// detect that it has been asked to stop - and it will terminate itself.
				pTriggerMonitor->Stop();

				// Key a count of how many monitors we have tried to stop
				lExpiredMonitors++;
			}
		}

		// look at the next monitor in the list.
		++iMonitorRef;
	}

	// If we have less running threads than the stated config minimum, create some more.
	if (lRunningMonitors < lRequiredMonitors)
	{
		// Write a trace message here indicating that we are scaling up the thread pool. 
		TrTRACE(GENERAL, "Need to add %d threads to the thread pool.", lRequiredMonitors - lRunningMonitors);
	}

	while (lRunningMonitors < lRequiredMonitors)
	{
		hr = CreateTriggerMonitor();

		if SUCCEEDED(hr)
		{
			lRunningMonitors++;
		}
		else
		{		
			TrERROR(GENERAL, "Failed to create a new trigger monitor thread. Error=0x%x", hr);
		}
	}

	// Walk through the monitor list and remove dead monitors. Some may be dead due to the stop
	// requests issued above, but some may also be dead due to errors and exceptions.
	iMonitorRef = m_lstTriggerMonitors.begin();

	// Initialise trigger monitor reference.
	while ( (iMonitorRef != m_lstTriggerMonitors.end()) && (!m_lstTriggerMonitors.empty()) )
	{
		// Cast the reference to a monitor type
		R<CTriggerMonitor> pTriggerMonitor = (*iMonitorRef);

		// Wait on the thread-handle of this TriggerMonitor.
		dwWait = WaitForSingleObject(pTriggerMonitor->m_hThreadHandle,0);

		// If the wait completes successfully, then the thread has stopped executing, and 
		// we can delete it. If the wait times-out, then the monitor is still executing and
		// we will leave it alone. If the monitor is just taking a while to shutdown, then
		// we will pick it up next time we perform this periodic clean up of the monitor list.
		if (dwWait == WAIT_OBJECT_0) 
		{
			TrTRACE(GENERAL, "Remove trigger monitor from the pool. Thread no: %d", pTriggerMonitor->GetThreadID());

			// remove this reference from the list of monitors
			iMonitorRef = m_lstTriggerMonitors.erase(iMonitorRef);

		}
		else
		{
			// look at the next monitor in the list.
			++iMonitorRef;
		}
	}

	// At this point we want to make sure that there is at least one active monitor in the pool.
	// If not, create a new monitor thread.
	if (m_lstTriggerMonitors.size() < 1)
	{
		hr = CreateTriggerMonitor();

		if FAILED(hr)
		{		
			TrERROR(GENERAL, "Failed to create a new trigger monitor. Error=0x%x", hr);
			return hr;
		}
	}

	ASSERT(hr == S_OK);
	
	TrTRACE(GENERAL, "Completed Sucessfully periodic processing. number of active trigger monitors is: %d.", (long)m_lstTriggerMonitors.size());
	return S_OK;
}

//*******************************************************************
//
// Method      : HandleAdminMessage
//
// Description : This method is called by threads in the thread pool
//               when they have recieved a message on the administration
//               queue. Monitor threads call this method to 'hand over' 
//               the administration message. This is done by adding the 
//               message to the list, setting a function code for the 
//               admin thread - and then waking it up to process these
//               messages.
//
//*******************************************************************
HRESULT CTriggerMonitorPool::AcceptAdminMessage(CAdminMessage * pAdminMessage)
{
	HRESULT hr = S_OK;

	// The TriggerMonitor thread should not be executing this method - assert this.
	ASSERT(this->GetThreadID() != (DWORD)GetCurrentThreadId());

	// Ensure that we have been given a valid message structure
	ASSERT(pAdminMessage != NULL);

	CS cs(m_csAdminTask);
	
	if(m_lAdminTask == ADMIN_THREAD_STOP)
	{
		delete pAdminMessage;
		return MSMQ_TRIGGER_STOPPED;
	}

	{
		// Acquire a writer lock to the list of Admin messsages
		CS csList(m_AdminMsgListLock);

		// Add this copy to the list of messages to be processed.
		m_lstAdminMessages.insert(m_lstAdminMessages.end(),pAdminMessage);
	}
	
	// Set a token indicating what we want the admin thread to do.
	m_lAdminTask = ADMIN_THREAD_PROCESS_NOTIFICATIONS;

	// Wake up the admin thread
	SetEvent(m_hAdminEvent);

	return (hr);
}

//*******************************************************************
//
// Method      : PostMessageToAllMonitors
//
// Description : This method posts messages to the IO completion port 
//               that the worker threads are blocking on. It will post
//               one message for every thread in the pool. This message
//               type is determined by the supplied completion key.
//
//*******************************************************************
HRESULT CTriggerMonitorPool::PostMessageToAllMonitors(DWORD dwCompletionKey)
{
	long lThreadCtr = 0;

	// Only the TriggerMonitor thread should be executing this method - assert this.
	ASSERT(this->GetThreadID() == (DWORD)GetCurrentThreadId());

	// log a trace message
	TrTRACE(GENERAL, "CTriggerMonitorPool is about to post the completion port key (%X) (%d) times to IO port (%p)",(DWORD)dwCompletionKey,(long)m_lstTriggerMonitors.size(),m_hIOCompletionPort);

	for(lThreadCtr=0; lThreadCtr < (long)m_lstTriggerMonitors.size(); lThreadCtr++)
	{
		if (PostQueuedCompletionStatus(m_hIOCompletionPort,0,dwCompletionKey,NULL) == FALSE)
		{
			TrTRACE(GENERAL, "Failed when posting a messages to the IOCompletionPort. Error=%d.", GetLastError());
		}
	}

	// Surrender time slice of this thread to allow monitors to clean up and shut down. 
	Sleep(200);

	return(S_OK);
}

//*******************************************************************
//
// Method      : CountRunningTriggerMonitors
//
// Description : returns the number of currently live trigger monitors. Note that 
//               this is possibly different from the number of monitors in the list
//
//*******************************************************************
DWORD CTriggerMonitorPool::GetNumberOfRunningTriggerMonitors()
{
	DWORD dwRunningMonitors = 0;
	
	for(TRIGGER_MONITOR_LIST::iterator it = m_lstTriggerMonitors.begin(); it != m_lstTriggerMonitors.end(); ++it)
	{
		if ((*it)->IsRunning()) 
		{
			// Increment the count of running monitors
			dwRunningMonitors++;			
		}
	}

	return(dwRunningMonitors);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\stdafx.h ===
#pragma once

#ifndef __MQTRIG_STDH__
#define __MQTRIG_STDH__

#include <libpch.h>
#include <mqexception.h>

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_DEBUG_CRT
#define ATLASSERT ASSERT

#include <atlbase.h>
#include <comdef.h>

#include "mqtrig.tlh"

#endif //__MQTRIG_STDH__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\tginit.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    TgInit.cpp

Abstract:
    Trigger service initialization

Author:
    Uri Habusha (urih) 3-Aug-2000

Environment:
    Platform-independent

--*/

#include "stdafx.h"
#include "mq.h"
#include "Ev.h"
#include "Cm.h"
#include "mqsymbls.h"
#include "Svc.h"
#include "monitorp.hpp"
#include "queueutil.hpp"
#include "Tgp.h"
#include "privque.h"
#include "compl.h"
#include <autorel2.h>


#include "tginit.tmh"


//*******************************************************************
//
// Method      : ValidateTriggerStore
//
// Description : 
//
//*******************************************************************
static
void 
ValidateTriggerStore(
	IMSMQTriggersConfigPtr pITriggersConfig
	)
{
	pITriggersConfig->GetInitialThreads();
	pITriggersConfig->GetMaxThreads();
	_bstr_t bstrTemp = pITriggersConfig->GetTriggerStoreMachineName();
}


void ValidateTriggerNotificationQueue(void)
/*++

Routine Description:
    The routine validates existing of notification queue. If the queue doesn't
	exist, the routine creates it.

Arguments:
    None

Returned Value:
    None

Note:
	If the queue can't opened for receive or it cannot be created, the 
	routine throw an exception

--*/
{
	_bstr_t bstrFormatName;
	_bstr_t bstrNotificationsQueue = _bstr_t(L".\\private$\\") + _bstr_t(TRIGGERS_QUEUE_NAME);
	QUEUEHANDLE hQ = NULL;

	HRESULT hr = OpenQueue(
					bstrNotificationsQueue, 
					MQ_RECEIVE_ACCESS,
					false,
					&hQ,
					&bstrFormatName
					);
	
	if(FAILED(hr))
	{
		TrERROR(GENERAL, "Failed to open trigger notification queue. Error 0x%x", hr);
		
		WCHAR strError[256];
		swprintf(strError, L"0x%x", hr);

		EvReport(MSMQ_TRIGGER_OPEN_NOTIFICATION_QUEUE_FAILED, 1, strError);
		throw bad_hresult(hr);
	}

	MQCloseQueue(hQ);
}


static 
bool 
IsInteractiveService(
	SC_HANDLE hService
	)
/*++

Routine Description:
    Checks if the "Interactive with desktop" checkbox is set.

Arguments:
    handle to service

Returned Value:
    is interactive

--*/
{
	P<QUERY_SERVICE_CONFIG> ServiceConfig = new QUERY_SERVICE_CONFIG;
    DWORD Size = sizeof(QUERY_SERVICE_CONFIG);
    DWORD BytesNeeded = 0;
    memset(ServiceConfig, 0, Size);

    BOOL fSuccess = QueryServiceConfig(hService, ServiceConfig, Size, &BytesNeeded);
	if (!fSuccess)
    {
    	DWORD gle = GetLastError();
    	if (gle == ERROR_INSUFFICIENT_BUFFER)
    	{
			ServiceConfig.free();
        
	        ServiceConfig = reinterpret_cast<LPQUERY_SERVICE_CONFIG>(new BYTE[BytesNeeded]);
	        memset(ServiceConfig, 0, BytesNeeded);
	        Size = BytesNeeded;
	        fSuccess = QueryServiceConfig(hService, ServiceConfig, Size, &BytesNeeded);
    	}
    }

    if (!fSuccess)
    {
    	//
    	// Could not verify if the service is inetractive. Assume it's not. If it is,
    	// ChangeServiceConfig will fail since network service cannot be interactive. 
    	//
    	DWORD gle = GetLastError();
    	TrERROR(GENERAL, "QueryServiceConfig failed. Error: %!winerr!", gle);
        return false;
    }
        
    return((ServiceConfig->dwServiceType & SERVICE_INTERACTIVE_PROCESS) == SERVICE_INTERACTIVE_PROCESS);
}


VOID
ChangeToNetworkServiceIfNeeded(
	VOID
	)
/*++

Routine Description:
    Change the triggers logon account to network service if reg key is set.

Arguments:
    None

Returned Value:
    None

--*/
{
	DWORD dwShouldChange;
	RegEntry regEntry(
				REGKEY_TRIGGER_PARAMETERS, 
				CONFIG_PARM_NAME_CHANGE_TO_NETWORK_SERVICE, 
				CONFIG_PARM_DFLT_NETWORK_SERVICE, 
				RegEntry::Optional, 
				HKEY_LOCAL_MACHINE
				);

	CmQueryValue(regEntry, &dwShouldChange);
	if (dwShouldChange == CONFIG_PARM_DFLT_NETWORK_SERVICE)
	{
		TrTRACE(GENERAL, "Don't need to change triggers service account");
		return;
	}

	//
	// We should change the service account to network service. This will be effective 
	// only after restarting the service.
	//
	CServiceHandle hServiceCtrlMgr(OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS));
    if (hServiceCtrlMgr == NULL)
    {
    	DWORD gle = GetLastError();
	    TrERROR(GENERAL, "OpenSCManager failed. Error: %!winerr!. Not changing to network service", gle); 
        return;
    }
    
	CServiceHandle hService(OpenService( 
        						hServiceCtrlMgr,           
        						xDefaultTriggersServiceName,      
        						SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG));
    if (hService == NULL) 
    {
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "OpenService failed with error: %!winerr!. Not changing to network service", gle);
		return;
    }

    if (IsInteractiveService(hService))
    {
		//
		// A network service cannot be interactive with desktop. We don't want to break users that
		// set this checkbox so we just warn in the eventlog that triggers service can't be changed
		// to network service as long as the interactive option is set.
		//
		EvReport(EVENT_WARN_TRIGGER_ACCOUNT_CANNOT_BE_CHANGED);
		return;
    }
	
	if (!ChangeServiceConfig(
		  	hService,          	
		  	SERVICE_NO_CHANGE,       
		  	SERVICE_NO_CHANGE,          
		  	SERVICE_NO_CHANGE,       
		  	NULL,   
		  	NULL,  
		  	NULL,          
		  	NULL,     
		  	L"NT AUTHORITY\\NetworkService", 
		  	L"",        
		  	NULL      
			))
	{
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "ChangeServiceConfig failed. Error: %!winerr!. Not changing to network service", gle); 
		return;
	}	

	TrTRACE(GENERAL, "Service account changed to NetworkService"); 
	EvReport(EVENT_INFO_TRIGGER_ACCOUNT_CHANGED); 

	CmSetValue(regEntry, CONFIG_PARM_DFLT_NETWORK_SERVICE);
}

CTriggerMonitorPool*
TriggerInitialize(
    LPCTSTR pwzServiceName
    )
/*++

Routine Description:
    Initializes Trigger service

Arguments:
    None

Returned Value:
    pointer to trigger monitor pool.

--*/
{

    //
    //  Report a 'Pending' progress to SCM. 
    //
	SvcReportProgress(xMaxTimeToNextReport);

    //
	// Create the instance of the MSMQ Trigger COM component.
    //
	IMSMQTriggersConfigPtr pITriggersConfig;
	HRESULT hr = pITriggersConfig.CreateInstance(__uuidof(MSMQTriggersConfig));
 	if FAILED(hr)
	{
		TrERROR(GENERAL, "Trigger start-up failed. Can't create an instance of the MSMQ Trigger Configuration component, Error 0x%x", hr);					
        throw bad_hresult(hr);
	}

    //
	// If we have create the configuration COM component OK - we will now verify that 
	// the required registry definitions and queues are in place. Note that these calls
	// will result in the appropraite reg-keys & queues being created if they are absent,
    // the validation routine can throw _com_error. It will be catch in the caller
    //
	ValidateTriggerStore(pITriggersConfig);
	SvcReportProgress(xMaxTimeToNextReport);

	ValidateTriggerNotificationQueue();
	SvcReportProgress(xMaxTimeToNextReport);
	
	hr = RegisterComponentInComPlusIfNeeded(TRUE);
	if (FAILED(hr))
	{
		TrERROR(GENERAL, "RegisterComponentInComPlusIfNeeded failed. Error: %!hresult!", hr);
		WCHAR errorVal[128];
		swprintf(errorVal, L"0x%x", hr);
		EvReport(MSMQ_TRIGGER_COMPLUS_REGISTRATION_FAILED, 1, errorVal);
		throw bad_hresult(hr);
	}
	
	SvcReportProgress(xMaxTimeToNextReport);

	ChangeToNetworkServiceIfNeeded();

    //
	// Attempt to allocate a new trigger monitor pool
    //
	R<CTriggerMonitorPool> pTriggerMonitorPool = new CTriggerMonitorPool(
														pITriggersConfig,
														pwzServiceName);

    //
	// Initialise and start the pool of trigger monitors
    //
	bool fResumed = pTriggerMonitorPool->Resume();
    if (!fResumed)
    {
		//
		// Could not resume the thread. Stop the service.
		//
		TrERROR(GENERAL, "Resuming thread failed");
		throw exception();
	}

	//
	// The thread we created is using the pTriggerMonitorPool. After the new CTriggerMonitorPool thread is resumed, it is using
	// this parameter and executing methods from this class. When it terminates it decrements the ref count.
	//
    pTriggerMonitorPool->AddRef();

	try
	{
	    //
		// Block until initialization is complete
	    //
	    long timeOut =  pITriggersConfig->InitTimeout;
	    SvcReportProgress(numeric_cast<DWORD>(timeOut));

		if (! pTriggerMonitorPool->WaitForInitToComplete(timeOut))
	    {
	    	//
	    	// Initialization timeout. Stop the service.
	    	//
	        TrERROR(GENERAL, "The MSMQTriggerService has failed to initialize the pool of trigger monitors. The service is being shutdown. No trigger processing will occur.");
	        throw exception();
	    }

		if (!pTriggerMonitorPool->IsInitialized())
		{
			//
			// Initilization failed. Stop the service
			//
			TrERROR(GENERAL, "Initilization failed. Stop the service");
			throw exception();
		}

		EvReport(MSMQ_TRIGGER_INITIALIZED);
		return pTriggerMonitorPool.detach();
	}
	catch(const exception&)
	{
		ASSERT(pTriggerMonitorPool.get() != NULL);
		pTriggerMonitorPool->ShutdownThreadPool();
		throw;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\ss.h ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:
    ss.h

Abstract:
    Safe Set

Author:
    Uri Habusha (urih) 3-Sep-2001

--*/

#pragma once

#ifndef __SS_H__
#define __SS_H__


#include "rwlock.h"

template<class T>
class CSafeSet 
{
public:
	bool exist(const T& s) const
	{
		CSR rl(m_rwl);
		return (m_set.find(s) != m_set.end());
	}


	bool insert(const T& s)
	{
		CSW rw(m_rwl);
		return m_set.insert(s).second;
	}


	typename std::set< T >::size_type erase(const T& s)
	{
		CSW rw(m_rwl);
		return m_set.erase(s);
	}

private:
	mutable CReadWriteLock m_rwl;
	std::set < T > m_set;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\tgp.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    Tgp.h

Abstract:
    Trigger Service private functions.

Author:
    Uri Habusha (urih) 10-Apr-00

--*/

#pragma once

#ifndef __Tgp_H__
#define __Tgp_H__


//
// Forwarding decleartion
//
extern CHandle g_hServicePaused;

class CTriggerMonitorPool;

//
// Internal interfaces
//
CTriggerMonitorPool*
TriggerInitialize(
    LPCTSTR pwzServiceName
    );


#endif // __Tgp_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigutil\cinputparams.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	CInputParams.cpp    

Abstract:
    CInputParams implementation

Author:
   Ofer Gigi		
   Yifat Peled 31-Aug-98

--*/

#include "stdafx.h"
#include "CInputParams.h"

#include "cinputparams.tmh"


/*++
Routine Description:
    This routine takes the arguments from the command line
    and puts them into a container. Each token 
    ("/command:value") is already apart from the other tokens.

Arguments:
    argc(IN) - number of arguments in the command line.
    argv(IN) - the arguments in the command line.
        
Return Value:
    none.

Note:
    When you are creating this object using THIS constructor
    the first argument is THE NAME OF THE PROGRAM so this 
    argument is not included in the container. 
--*/
CInputParams::CInputParams(int argc, WCHAR*	argv[])
{
    for (int i=1; i < argc; i++)
    {
        ParseToken(argv[i], 0, wstring::npos);
    }
}


/*++
Routine Description:
    This routine takes the string from the command line,
    then takes the tokens ("/command:value") from it and
    puts them into a container. 

Arguments:
    str (IN) - all the arguments contained in one string.

Return Value:
    none.
--*/
CInputParams::CInputParams(const wstring& wcs)
{
    wstring::size_type tokenstart=0;
    wstring::size_type tokenfinish=0;
	
    while ((tokenstart != wstring::npos) && (tokenfinish != wstring::npos))
    {
        tokenstart = wcs.find_first_not_of(L' ',tokenfinish);
        if (tokenstart != wstring::npos)
        {
            tokenfinish = wcs.find_first_of(L' ',tokenstart);     
            if (tokenfinish == wstring::npos)
            {
                ParseToken(wcs, tokenstart, tokenfinish);
            }
            else
            {
                ParseToken(wcs, tokenstart, tokenfinish - 1); 
            }
        }
    }
}

/*++
Routine Description:
    This routine takes the token apart to two parts
    command and value and puts them into the container.

Arguments:
    wcs (IN) - the string from the command-line.
    tokenstart (IN) - where the token begins in the string.
    tokenfinish (IN) - where the token ends in the string.

Return Value:
    none.
--*/
void CInputParams::ParseToken(const wstring& wcs,
                               wstring::size_type tokenstart,
                               wstring::size_type tokenfinish)
{
    wstring command;
    wstring value;
    wstring::size_type commandstart;
    wstring::size_type valuestart;

	commandstart = wcs.find(L"/", tokenstart);
	if(commandstart != wstring::npos)
		commandstart += 1;
    valuestart = wcs.find(L":", tokenstart);
	if(valuestart != wstring::npos)
		valuestart += 1;
	
	if ((commandstart != wstring::npos) &&
		(commandstart >= tokenstart) &&
		(commandstart <= tokenfinish))
	{
		if (// command option with parameters
			(valuestart != wstring::npos) &&
			(commandstart < valuestart) &&
			(valuestart >= tokenstart) &&
			(valuestart <= tokenfinish))
		{
			command = wcs.substr(commandstart, valuestart - commandstart - 1);
			if (tokenfinish != wstring::npos)
			{
				value = wcs.substr(valuestart, tokenfinish - valuestart + 1);
			}
			else
			{ 
				value = wcs.substr(valuestart);
			}
			
			wstring wcsUpperCommand = Covert2Upper(command);
			m_InputParams[wcsUpperCommand] = value;
		}
	    else if ( // command option with no parameters
				 (valuestart == wstring::npos) || (valuestart > tokenfinish))
		{
			if (tokenfinish != wstring::npos)
			{
				if(wcs[tokenfinish] == L':')
					command = wcs.substr(commandstart, tokenfinish - commandstart);
				else
					command = wcs.substr(commandstart, tokenfinish - commandstart + 1);
			}
			else 
			{
				command = wcs.substr(commandstart);
			}
			wstring wcsUpperCommand = Covert2Upper(command);
			m_InputParams[wcsUpperCommand] = L"";
		}
	}
}

/*++
Routine Description:
    This routine takes a string and checks if the string 
    is a key in the container.

Arguments:
    wcs (IN) - the key that we are checking.

Return Value:
    (OUT) - returns true if the key exists in the container.
--*/
bool CInputParams::IsOptionGiven(const wstring& wcsOption) const
{
	wstring wcsUpperOption = Covert2Upper(wcsOption);
	map<wstring, wstring>::const_iterator it = m_InputParams.find(wcsUpperOption);	

    return (it != m_InputParams.end());
}

/*++
Routine Description:
    This routine takes a string - a key in the container
    and if the key exists returns its value, else
    returns empty string.

Arguments:
    wcs (IN) - the key.

Return Value:
    (OUT) - returns the value of the key if the key exists
    in the container else returns empty string.
--*/
wstring CInputParams::operator[](const wstring& wcsOption)
{
    if (IsOptionGiven(wcsOption))
    {
		wstring wcsUpperOption = Covert2Upper(wcsOption);
		return m_InputParams[wcsUpperOption];
    }
    else
    {    
       return L"";
    }
}


wstring CInputParams::Covert2Upper(const wstring& wcs) const
{
	WCHAR* pwcsUpper = new WCHAR[wcs.length() + 1];
	wcscpy(pwcsUpper, wcs.c_str());
	CharUpper(pwcsUpper);
	return wstring(pwcsUpper);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigserv\trigserv.cpp ===
//*******************************************************************
//
// File Name   : trigserv.cpp
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This is the main MSMQ Trigger service file.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*******************************************************************
#include "stdafx.h"
#include "Cm.h"
#include "Ev.h"
#include "Svc.h"
#include "monitorp.hpp"
#include "mqsymbls.h"
#include "Tgp.h"
#include <strsafe.h>

#include "trigserv.tmh"

//
// Create the NT event object that will be used to control service pause and resume
// functionality. We will manually set and reset this event as in response to pause
// and resume requests. This NT event will be named so that other processes on the 
// machine can test if the MSMQ Trigger service is in a pause state or not. 
//
CHandle g_hServicePaused(CreateEvent(NULL,TRUE,TRUE, NULL));

CHandle s_hStopEvent(CreateEvent(NULL, FALSE, FALSE, NULL));


VOID
AppRun(
	LPCWSTR ServiceName
	)
/*++

Routine Description:
    Triggers service start function.

Arguments:
    Service name

Returned Value:
    None.

--*/
{
    //
    //  Report a service is starting status to SCM. 
    //
    SvcReportState(SERVICE_START_PENDING);
	
	try
	{
		EvInitialize(ServiceName);
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL,"Failed to initialize event log library. MSMQ Trigger service can't start. Maybe MSMQTriggers registry key is missing.");
	    SvcReportState(SERVICE_STOPPED);
		return;
	}

	HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr))
    {
		TrERROR(GENERAL, "Trigger start-up failed. CoInitialized Failed, error 0x%x", hr);
        WCHAR errorVal[128];
		HRESULT hr2 = StringCchPrintf(errorVal, TABLE_SIZE(errorVal), L"0x%x", hr);
		ASSERT (SUCCEEDED(hr2));
		DBG_USED(hr2);
		EvReport(MSMQ_TRIGGER_INIT_FAILED, 1, errorVal);
	    SvcReportState(SERVICE_STOPPED);
	    return;
    }

	try
	{
        if ((g_hServicePaused == NULL) || (s_hStopEvent == NULL))
        {
    		TrERROR(GENERAL, "Trigger start-up failed. Can't create an event");
            throw bad_alloc();
        }

        //
        // Initialize the trigger service. If success it returns a pointer 
        // to monitor pool. This needs for graceful shutdown
        //
        R<CTriggerMonitorPool> pTriggerMonitorPool = TriggerInitialize(ServiceName);
        
        //
        //  Report a 'Running' status to SCM. 
        //
        SvcReportState(SERVICE_RUNNING);
        SvcEnableControls(
		    SERVICE_ACCEPT_STOP |
		    SERVICE_ACCEPT_SHUTDOWN |
            SERVICE_ACCEPT_PAUSE_CONTINUE 
		    );

        //
        // Wait for service stop or shutdown
        //
        WaitForSingleObject(s_hStopEvent, INFINITE);

        //
        // Stop Pending was already reported to SCM, now tell how long
        // would it take to stop.
        //
        DWORD stopProcessTimeOut = (pTriggerMonitorPool->GetProcessingThreadNumber() + 1) * TRIGGER_MONITOR_STOP_TIMEOUT;
	    SvcReportProgress(stopProcessTimeOut);

        //
	    // Now that we have get shutdown request attempt to 
	    // shutdown the trigger monitor pool gracefully.
        //
	    pTriggerMonitorPool->ShutdownThreadPool();

        //
        //  Report a 'Stopped' status to SCM. 
        //
        SvcReportState(SERVICE_STOPPED);

        //
        // Report Stopped in event log
        //
		EvReport(MSMQ_TRIGGER_STOPPED);
		CoUninitialize();
		return;
	}
    catch (const _com_error& e)
    {
		hr = e.Error();
    }
	catch (const bad_hresult& e)
	{
		hr = e.error();
	}
	catch (const bad_alloc&)
	{
		hr = MQTRIG_ERROR_INSUFFICIENT_RESOURCES;
	}
	catch (const exception&)
	{
		hr = MQTRIG_ERROR;
	}

    TrERROR(GENERAL, "Trigger service start-up failed. Error=0x%x", hr);

	//
	// Produce Event log message
	//
	WCHAR errorVal[128];
	HRESULT hr2 = StringCchPrintf(errorVal, TABLE_SIZE(errorVal), L"0x%x", hr);
	ASSERT(SUCCEEDED(hr2));
	DBG_USED(hr2);
	EvReport(MSMQ_TRIGGER_INIT_FAILED, 1, errorVal);
    SvcReportState(SERVICE_STOPPED);
    CoUninitialize();
}


VOID
AppStop(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Stop function. It should immidiatly
	report it state back, and take the procedure to stop the service

Arguments:
    None.

Returned Value:
    None.

--*/
{
	//
	//  Report a 'service is stopping' progress to SCM. 
	//
    SvcReportState(SERVICE_STOP_PENDING);

	SetEvent(s_hStopEvent);
}


VOID
AppPause(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Pause function. It should immidiatly
	report it state back, and take the procedure to pause the service

Arguments:
    None.

Returned Value:
    None.

--*/
{
    ResetEvent(g_hServicePaused);
    SvcReportState(SERVICE_PAUSED);
}


VOID
AppContinue(
	VOID
	)
/*++

Routine Description:
    Stub implementation for application Continue function. It should immidiatly
	report it state back, and take the procedure to contineu the service from
	a paused state.

Arguments:
    None.

Returned Value:
    None.

--*/
{
    SetEvent(g_hServicePaused);
	SvcReportState(SERVICE_RUNNING);
}


VOID
AppShutdown(
	VOID
	)
{
	//
	//  Report a 'service is stopping' progress to SCM. 
	//
    SvcReportState(SERVICE_STOP_PENDING);
	SetEvent(s_hStopEvent);
}


//*******************************************************************
//
// Method      :  
//
// Description : 
//
//*******************************************************************
extern "C" int __cdecl _tmain(int argc, LPCTSTR argv[])
{
	try
	{
        WPP_INIT_TRACING(L"Microsoft\\MSMQ");

		try
		{
			//
			// The triggers service usually runs as network service so the first CmInitialize will fail.
			// This is OK since by default the service needs only READ_ACCESS.
			// One exception is when the triggers service run for the first time after upgrade.
			// Only in this case the service will need to write values to the registry.
			// In this case the service will be system so the first CmInitialize wil succeed.
			//
			CmInitialize(HKEY_LOCAL_MACHINE, REGKEY_TRIGGER_PARAMETERS, KEY_ALL_ACCESS);
		}
		catch (const exception&)
		{
			CmInitialize(HKEY_LOCAL_MACHINE, REGKEY_TRIGGER_PARAMETERS, KEY_READ);
		}
		TrInitialize();

        //
        // If a command line parameter is passed, use it as the dummy service
        // name. This is very usful for debugging cluster startup code.
        //
        LPCWSTR DummyServiceName = (argc == 2) ? argv[1] : L"MSMQTriggers";
        SvcInitialize(DummyServiceName);
	}
	catch(const exception&)
	{
		//
		// Cannot initialize the service, bail-out with an error.
		//
		return -1;
	}

    WPP_CLEANUP();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigutil\compl.cpp ===
/*++

Copyright (c) 1995-97  Microsoft Corporation

Module Name:
    complini.cpp

Abstract:
    Trigger COM+ component registration

Author:
    Nela Karpel (nelak) 15-May-2001

Environment:
    Platform-independent

--*/

/*
	These functions can be called from setup or from triggers service startup and their behavior
	should be different according to that. When these functions are called from startup,
	we need to report Pending progress to SCM.
*/

#include "stdafx.h"
#include <comdef.h>
#include "Ev.h"
#include "cm.h"
#include "Svc.h"
#include "mqtg.h"
#include "mqsymbls.h"
#include "comadmin.tlh"
#include "mqexception.h"
#include "compl.h"

#include "compl.tmh"

const WCHAR xMqGenTrDllName[] = L"mqgentr.dll";

static WCHAR s_wszDllFullPath[MAX_PATH];

//+-------------------------------------------------------------------------
//
//  Function:   NeedToRegisterComponent
//
//  Synopsis:   Check if COM+ component registration is needed
//
//--------------------------------------------------------------------------

VOID
InitMqGenTrName(
	VOID
	)
{
	WCHAR wszSystemDir[MAX_PATH];
	if (GetSystemDirectory( wszSystemDir, TABLE_SIZE(wszSystemDir)) == 0)
	{
		DWORD gle = GetLastError();
		TrERROR(GENERAL, "GetSystemDirectory failed. Error: %!winerr!", gle);
		throw bad_hresult(HRESULT_FROM_WIN32(gle));
	}
	
	wsprintf(s_wszDllFullPath, L"%s\\%s", wszSystemDir, xMqGenTrDllName);
}

bool
NeedToRegisterComponent(
	VOID
	)
{
	DWORD dwInstalled;
	RegEntry regEntry(
				REGKEY_TRIGGER_PARAMETERS, 
				CONFIG_PARM_NAME_COMPLUS_INSTALLED, 
				CONFIG_PARM_DFLT_COMPLUS_NOT_INSTALLED, 
				RegEntry::Optional, 
				HKEY_LOCAL_MACHINE
				);

	CmQueryValue(regEntry, &dwInstalled);

	//
	// Need to register if the value does not exist, or it exists and 
	// is equal to 0
	//
	return (dwInstalled == CONFIG_PARM_DFLT_COMPLUS_NOT_INSTALLED);
}


//+-------------------------------------------------------------------------
//
//  Function:   SetComplusComponentRegistered
//
//  Synopsis:   Update triggers Complus component flag. 1 is installed.
//
//--------------------------------------------------------------------------
static
void
SetComplusComponentRegistered(
	VOID
	)
{
	RegEntry regEntry(
		REGKEY_TRIGGER_PARAMETERS, 
		CONFIG_PARM_NAME_COMPLUS_INSTALLED, 
		CONFIG_PARM_DFLT_COMPLUS_NOT_INSTALLED, 
		RegEntry::Optional, 
		HKEY_LOCAL_MACHINE
		);

	CmSetValue(regEntry, CONFIG_PARM_COMPLUS_INSTALLED);


	TrTRACE(GENERAL, "Complus registartion key is set");
}


//+-------------------------------------------------------------------------
//
//  Function:   GetComponentsCollection
//
//  Synopsis:   Create Components collection for application
//
//--------------------------------------------------------------------------
static
ICatalogCollectionPtr
GetComponentsCollection(
	ICatalogCollectionPtr pAppCollection,
	ICatalogObjectPtr pApplication
	)
{
		//
		// Get the Key of MQTriggersApp application
		//
		_variant_t vKey;
		pApplication->get_Key(&vKey);

		//
		// Get components colletion associated with MQTriggersApp application
		//
		ICatalogCollectionPtr pCompCollection = pAppCollection->GetCollection(L"Components", vKey);

		pCompCollection->Populate();

		return pCompCollection.Detach();
}


//+-------------------------------------------------------------------------
//
//  Function:   CreateApplication
//
//  Synopsis:   Create Application in COM+
//
//--------------------------------------------------------------------------
static
ICatalogObjectPtr 
CreateApplication(
	ICatalogCollectionPtr pAppCollection,
	BOOL fAtStartup
	)
{
	if (fAtStartup)
		SvcReportProgress(xMaxTimeToNextReport);

	try
	{
		//
		// Add new application named TrigApp, Activation = Inproc
		//
		ICatalogObjectPtr pApplication = pAppCollection->Add();

		//
		// Update applications name
		//
		_variant_t vName;
        vName = xTriggersComplusApplicationName;
		pApplication->put_Value(_bstr_t(L"Name"), vName);

		//
		// Set application activation to "Library Application"
		//
		_variant_t vActType = static_cast<long>(COMAdminActivationInproc);
		pApplication->put_Value(_bstr_t(L"Activation"), vActType);

		//
		// Save Changes
		//
		pAppCollection->SaveChanges();

		TrTRACE(GENERAL, "Created MqTriggersApp application in COM+.");
		return pApplication.Detach();
	}
	catch(_com_error& e)
	{
		TrERROR(GENERAL, "New Application creation failed while registering Triggers COM+ component. Error=0x%x", e.Error());
		throw;
	}
}


//+-------------------------------------------------------------------------
//
//  Function:   InstallComponent
//
//  Synopsis:   Install Triggers transasctional component in COM+
//
//--------------------------------------------------------------------------
static
void
InstallComponent(
	ICOMAdminCatalogPtr pCatalog,
	ICatalogObjectPtr pApplication,
	LPCWSTR dllName,
	BOOL fAtStartup
	)
{
	if (fAtStartup)
		SvcReportProgress(xMaxTimeToNextReport);

	try
	{
		//
		// Get application ID for the installation
		//
		_variant_t vId;
		pApplication->get_Value(_bstr_t(L"ID"), &vId);

		//
		// Install component from mqgentr.dll
		//
		_bstr_t bstrDllName(dllName);
		pCatalog->InstallComponent(vId.bstrVal, bstrDllName, _bstr_t(L""), _bstr_t(L""));

		TrTRACE(GENERAL, "Installed component from mqgentr.dll in COM+.");
	}
	catch(_com_error& e)
	{
		TrERROR(GENERAL, "The components from %ls could not be installed into COM+. Error=0x%x", xMqGenTrDllName, e.Error());
		throw;
	}

}


//+-------------------------------------------------------------------------
//
//  Function:   SetComponentTransactional
//
//  Synopsis:   Adjust transactional components properties
//
//--------------------------------------------------------------------------
static
void
SetComponentTransactional(
	ICatalogCollectionPtr pAppCollection,
	ICatalogObjectPtr pApplication,
	BOOL fAtStartup
	)
{
	if (fAtStartup)
		SvcReportProgress(xMaxTimeToNextReport);

	try
	{
		ICatalogCollectionPtr pCompCollection = GetComponentsCollection(pAppCollection, pApplication);

		//
		// Check assumption about number of components
		//
		long count;
		pCompCollection->get_Count(&count);
		ASSERT(("More components installes than expected", count == 1));

		//
		// Update the first and only component - set Transaction = Required
		//
		ICatalogObjectPtr pComponent = pCompCollection->GetItem(0);

		_variant_t vTransaction = static_cast<long>(COMAdminTransactionRequired);
		pComponent->put_Value(_bstr_t(L"Transaction"), vTransaction);

		//
		// Save changes
		//
		pCompCollection->SaveChanges();

		TrTRACE(GENERAL, "Configured component from mqgentr.dll to be transactional.");
	}
	catch(_com_error& e)
	{
		TrERROR(GENERAL, "The Triggers transactional component could not be configured in COM+. Error=0x%x", e.Error());
		throw;
	}
}


//+-------------------------------------------------------------------------
//
//  Function:   IsTriggersComponentInstalled
//
//  Synopsis:   Check if triggers component is installed for given 
//				appllication
//
//--------------------------------------------------------------------------
static
bool
IsTriggersComponentInstalled(
	ICatalogCollectionPtr pAppCollection,
	ICatalogObjectPtr pApp,
	BOOL fAtStartup
	)
{
	if (fAtStartup)
		SvcReportProgress(xMaxTimeToNextReport);
		
	ICatalogCollectionPtr pCompCollection = GetComponentsCollection(pAppCollection, pApp);

	long count;
	pCompCollection->get_Count(&count);

	for ( int i = 0; i < count; i++ )
	{
		ICatalogObjectPtr pComp = pCompCollection->GetItem(i);

		_variant_t vDllName;
		pComp->get_Value(_bstr_t(L"DLL"), &vDllName);

		if ( _wcsicmp(vDllName.bstrVal, s_wszDllFullPath) == 0 )
		{
			return true;
		}
	}

	return false;
}


//+-------------------------------------------------------------------------
//
//  Function:   IsTriggersComplusComponentInstalled
//
//  Synopsis:   Check if triggers component is installed in COM+
//
//--------------------------------------------------------------------------
static
bool
IsTriggersComplusComponentInstalled(
	ICatalogCollectionPtr pAppCollection,
	BOOL fAtStartup
	)
{
	long count;
	pAppCollection->Populate();
	pAppCollection->get_Count(&count);

	//
	// Go through the applications, find MQTriggersApp and delete it
	//
	for ( int i = 0; i < count; i++ )
	{
		ICatalogObjectPtr pApp = pAppCollection->GetItem(i);

		_variant_t vName;
		pApp->get_Name(&vName);

		if ( _wcsicmp(vName.bstrVal, xTriggersComplusApplicationName) == 0 )
		{
			//
			// Note: progress is reported for each application
			//
			if ( IsTriggersComponentInstalled(pAppCollection, pApp, fAtStartup) )
			{
				TrTRACE(GENERAL, "Triggers COM+ component is already registered.");
				return true;
			}
		}
	}

	TrTRACE(GENERAL, "Triggers COM+ component is not yet registered.");
	return false;
}


//+-------------------------------------------------------------------------
//
//  Function:   RegisterComponentInComPlus
//
//  Synopsis:   Transactional object registration
//
//--------------------------------------------------------------------------
HRESULT 
RegisterComponentInComPlusIfNeeded(
	BOOL fAtStartup
	)
{
	HRESULT hr;

	try
	{
		//
		// Registration is done only once
		//
		if ( !NeedToRegisterComponent() )
		{
			TrTRACE(GENERAL, "No need to register Triggers COM+ component.");
			return MQ_OK;
		}
		
		TrTRACE(GENERAL, "Need to register Triggers COM+ component.");		

		//
		// Compose full path to mqgentr.dll
		//
		InitMqGenTrName();

		if (fAtStartup)
			SvcReportProgress(xMaxTimeToNextReport);
		
		//
		// Create AdminCatalog Obect - The top level administration object
		//
		ICOMAdminCatalogPtr pCatalog;

		hr = pCatalog.CreateInstance(__uuidof(COMAdminCatalog));
		if ( FAILED(hr) )
		{
			TrERROR(GENERAL, "Creating instance of COMAdminCatalog failed. Error=0x%x", hr);			
			throw bad_hresult(hr);
		}

		//
		// Get Application collection
		//
		
		ICatalogCollectionPtr pAppCollection;
		try
		{
			pAppCollection = pCatalog->GetCollection(L"Applications");
		}
		catch(const _com_error& e)
		{
			TrERROR(GENERAL, "Failed to get 'Application' collection from COM+. Error=0x%x", e.Error());			
			return e.Error();
		}

		if ( IsTriggersComplusComponentInstalled(pAppCollection, fAtStartup) )
		{
			SetComplusComponentRegistered();
			return MQ_OK;
		}

		//
		// Create MQTriggersApp application in COM+
		//
		ICatalogObjectPtr pApplication;
		pApplication = CreateApplication(pAppCollection, fAtStartup);
		
		//
		// Install transactional component from mqgentr.dll
		//
		InstallComponent(pCatalog, pApplication, s_wszDllFullPath, fAtStartup);

		//
		// Configure installed component
		//
		SetComponentTransactional(pAppCollection, pApplication, fAtStartup);
		
		//
		// Update registry
		//
		SetComplusComponentRegistered();

		return MQ_OK;
	}
	catch (const _com_error& e)
	{
		//
		// For avoiding failure in race conditions: if we failed to 
		// install the component, check if someone else did it. In such case
		// do not terminate the service
		//
		Sleep(1000);
		if ( !NeedToRegisterComponent() )
		{
			return MQ_OK;
		}
		return e.Error();
	}
	catch (const bad_alloc&)
	{
		return MQ_ERROR_INSUFFICIENT_PROPERTIES;
	}
	catch (const bad_hresult& b)
	{
		return b.error();
	}
}


//+-------------------------------------------------------------------------
//
//  Function:   UnregisterComponentInComPlus
//
//  Synopsis:   Transactional object registration
//
//--------------------------------------------------------------------------
HRESULT
UnregisterComponentInComPlus(
	VOID
	)
{
	try
	{
		//
		// Compose full path to mqgentr.dll
		//
		InitMqGenTrName();
		
		//
		// Create AdminCatalog Obect - The top level administration object
		//
		ICOMAdminCatalogPtr pCatalog;

		HRESULT hr = pCatalog.CreateInstance(__uuidof(COMAdminCatalog));
		if ( FAILED(hr) )
		{
			TrERROR(GENERAL, "CreateInstance failed. Error: %!hresult!", hr);
			throw _com_error(hr);
		}

		//
		// Get Applications Collection
		//
		ICatalogCollectionPtr pAppCollection = pCatalog->GetCollection(L"Applications");
		pAppCollection->Populate();

		long count;
		pAppCollection->get_Count(&count);

		//
		// Go through the applications, find MQTriggersApp and delete it
		//
		for ( int i = 0; i < count; i++ )
		{
			ICatalogObjectPtr pApp = pAppCollection->GetItem(i);

			_variant_t vName;
			pApp->get_Name(&vName);

			if ( _wcsicmp(vName.bstrVal, xTriggersComplusApplicationName) == 0 )
			{
				if ( IsTriggersComponentInstalled(pAppCollection, pApp, FALSE) )
				{
					pAppCollection->Remove(i);
					break;
				}
			}
		}

		pAppCollection->SaveChanges();
		
		return MQ_OK;
	}
	catch (const bad_alloc&)
	{
		TrERROR(GENERAL, "UnregisterComponentInComPlus got a bad_alloc exception");
		return MQ_ERROR_INSUFFICIENT_PROPERTIES;
	}
	catch (const bad_hresult& e)
	{
		return e.error();
	}
	catch (const _com_error& e)
	{
		return e.Error();
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigutil\genmqsec.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:
	GenMQSec.cpp    

Abstract:
    generates a security descriptor matching the desired access to MQ.

Author:
   Dan Bar-Lev
   Yifat Peled	(yifatp)	24-Sep-98

--*/

#define SECURITY_WIN32

#include "stdafx.h"
#include "mqsec.h"
#include "GenMQSec.h"

#include "genmqsec.tmh"


typedef struct tagSecParse
{
	WCHAR *pwcsName;
	DWORD dwVal;
}tagSecParse;

tagSecParse SecParse[] = {
							{ L"Rj",	MQSEC_RECEIVE_JOURNAL_MESSAGE },
							{ L"Rq",	MQSEC_RECEIVE_MESSAGE },
							{ L"Pq",	MQSEC_PEEK_MESSAGE },
							{ L"Sq",	MQSEC_WRITE_MESSAGE },
							{ L"Sp",	MQSEC_SET_QUEUE_PROPERTIES },
							{ L"Gp",	MQSEC_GET_QUEUE_PROPERTIES },
							{ L"D",		MQSEC_DELETE_QUEUE },
							{ L"Pg",	MQSEC_GET_QUEUE_PERMISSIONS },
							{ L"Ps",	MQSEC_CHANGE_QUEUE_PERMISSIONS },
							{ L"O",		MQSEC_TAKE_QUEUE_OWNERSHIP },
							{ L"R",		MQSEC_QUEUE_GENERIC_READ },
							{ L"W",		MQSEC_QUEUE_GENERIC_WRITE },
							{ L"A",		MQSEC_QUEUE_GENERIC_ALL }
						};

int iSecParseLen = ( sizeof(SecParse) / sizeof(tagSecParse) );


/******************************************************************************

	fAddAce

Parse an access right of the form: +"domain\user" 1234;
Output:
  sid of the domain\user
  access mode
  grant - true if allow, false if deny

******************************************************************************/

DWORD
fAddAce(WCHAR*	pOrginalRight,
		SECURITY_INFORMATION*	pSecInfo,
		PSECURITY_DESCRIPTOR	pSecurityDescriptor,
		PSID*	ppSid,
		DWORD*	pdwSidSize,
		PACL*	ppAcl)
		
{
	DWORD	rc;
	DWORD	dwAccess = 0;
	WCHAR	grant_c;
	WCHAR*	pwcs;
	WCHAR*	pInRight;
	AP<WCHAR> pAutoInRight;
	WCHAR*	pwcsTerminate;
	DWORD	dwSize;


	// make a local copy of the right string 
	pAutoInRight = new WCHAR[wcslen(pOrginalRight) + 1];
	pInRight = pAutoInRight;
	wcscpy(pInRight, pOrginalRight);
	pwcsTerminate = pInRight + wcslen(pInRight);

	// remove leading spaces
	while ( iswspace(*pInRight) )
		pInRight++;

	// keep the grant option
	grant_c = *(pInRight++);

	// skip seperator
	ASSERT(*pInRight == L':');	// seperator should be ':'
    ++ pInRight;

	// remove leading spaces
	while ( iswspace(*pInRight) )
		pInRight++;

	// name starts with quote
	if ( *pInRight == L'"')
	{
		pwcs = wcschr( ++pInRight, L'"' );	// search for closing double quote
		if(pwcs == NULL)
		{
			ASSERT(("Bad access rights string. Missing closing double quote", 0));
			return WSAEINVAL;
		}
	}
	else if ( *pInRight == L'\'' )
	{
		pwcs = wcschr( ++pInRight, L'\'' );	// search for closing quote
		if(pwcs == NULL)
		{
			ASSERT(("Bad access rights string. Missing closing quote", 0));
			return WSAEINVAL;
		}
	}
	else // otherwise we assume white-space delimiter
	{
	 	pwcs = pInRight + wcscspn(pInRight, L" \t\r\f\n");
	}
	*pwcs = L'\0';						// mark the name end
	
	
	//
	// Get SID of the account given
	//

	if ( !(*pInRight) || !wcscmp(pInRight, L".") )// no account or the account is '.' - use current account
	{
		HANDLE hAccessToken;
		UCHAR InfoBuffer[255];
		PTOKEN_USER pTokenUser = (PTOKEN_USER)InfoBuffer;

		if(!OpenProcessToken(GetCurrentProcess(),
							 TOKEN_READ,
							 //TRUE,
							 &hAccessToken))
		{
			return GetLastError();
		}
		
		if(!GetTokenInformation(hAccessToken,
								TokenUser,
								InfoBuffer,
								sizeof(InfoBuffer),
								&dwSize))
		{
			return GetLastError();
		}

		CloseHandle(hAccessToken);

		if(!IsValidSid(pTokenUser->User.Sid))
		{
			return GetLastError();
		}
		dwSize = GetLengthSid(pTokenUser->User.Sid);
		if ( dwSize > (*pdwSidSize))
		{
			delete [] ((BYTE*)(*ppSid));
			*ppSid = (PSID*)new BYTE[dwSize];
			*pdwSidSize = dwSize;		// keep new size
		}
		memcpy(*ppSid, pTokenUser->User.Sid, dwSize );
	}
	else if ( !wcscmp(pInRight, L"*") )	// account is '*' - use WORLD
	{
		SID SecWorld = { 1, 1, SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID };
		if ( !IsValidSid(&SecWorld) )
		{
			return GetLastError();
		}

		dwSize = GetLengthSid( &SecWorld );
		if ( dwSize > *pdwSidSize )
		{
			delete [] ((BYTE*)(*ppSid));
			*ppSid = (PSID*)new BYTE[dwSize];
			*pdwSidSize = dwSize;		// keep new size
		}
		memcpy( *ppSid, &SecWorld, dwSize );
		
	}
	else // a specific account is given
	{
		SID_NAME_USE	Use;
		WCHAR			refdomain[256];
		DWORD			refdomain_size = sizeof(refdomain) /  sizeof(*refdomain);

		while (1)
		{
			dwSize = *pdwSidSize;

			if ( LookupAccountName( NULL,
								    pInRight, 
							        *ppSid,
									&dwSize, 
									refdomain,
									&refdomain_size, 
									&Use ) )
			{
				break;
			}

			DWORD dwError = GetLastError();
			if ( dwError == ERROR_INSUFFICIENT_BUFFER )
			{
				delete [] ((BYTE*)(*ppSid));
				*ppSid = (PSID*) new BYTE[dwSize];
				*pdwSidSize = dwSize;		// keep new size
			}
			else
			{
				return dwError;
			}
		}

		if ( !IsValidSid( *ppSid ) )
		{
			return GetLastError();
		}
	}

	//
	// Set dwAccess according to given access
	//

	// rights start after the username
	if ( pwcs < pwcsTerminate )
		pInRight = ++pwcs;
	else
		pInRight = pwcs;

	if ( *pInRight )
	{
		// remove leading spaces
		while ( iswspace(*pInRight) )
			pInRight++;

		int i, len;

		for( i=0; *pInRight && i < iSecParseLen; i++ )
		{
			WCHAR*	pwcSecName = SecParse[i].pwcsName;
			len = wcslen( pwcSecName );

			if ( !_wcsnicmp( pInRight, pwcSecName, len) )
			{
				dwAccess = dwAccess | SecParse[i].dwVal;
				i = 0;						// restart search
				pInRight += len;			// goto next security token
			}
		} // for

		while ( iswspace(*pInRight) )	// remove spaces
			pInRight++;					
		ASSERT(*pInRight == 0);				// unknown access rights!
	}

	//
	// Add access to ACL
	//

	switch( towupper( grant_c ) )
	{
	case L'+':
		{
			if(!IsValidSid(*ppSid))
			{
				return GetLastError();
			}

			dwSize = GetLengthSid( *ppSid );
			dwSize += sizeof(ACCESS_ALLOWED_ACE);	
			DWORD dwNewAclSize = (*ppAcl)->AclSize + dwSize - sizeof(DWORD /*ACCESS_ALLOWED_ACE.SidStart*/);
			
			//
			// allocate more space for ACL
			//
			PACL pTempAcl = (PACL) new BYTE[dwNewAclSize];
			memcpy(pTempAcl, *ppAcl, (*ppAcl)->AclSize);
			delete [] ((BYTE*)(*ppAcl));
			*ppAcl = pTempAcl;

			(*ppAcl)->AclSize = (WORD)dwNewAclSize;

			rc = AddAccessAllowedAce( *ppAcl, ACL_REVISION, dwAccess, *ppSid );
			
			if ( rc && pSecInfo )
				*pSecInfo |= DACL_SECURITY_INFORMATION;
			break;
		}
	case L'-':
		{
			if(!IsValidSid(*ppSid))
			{
				return GetLastError();
			}
			dwSize = GetLengthSid( *ppSid );
			dwSize += sizeof(ACCESS_DENIED_ACE);
			DWORD dwNewAclSize = (*ppAcl)->AclSize + dwSize - sizeof(DWORD /*ACCESS_DENIED_ACE.SidStart*/);
		
			//
			// allocate more space for ACL
			//
			PACL pTempAcl = (PACL) new BYTE[dwNewAclSize];
			memcpy(pTempAcl, *ppAcl, (*ppAcl)->AclSize);
			delete [] ((BYTE*)(*ppAcl));
			*ppAcl = pTempAcl;

			(*ppAcl)->AclSize = (WORD)dwNewAclSize;

			rc = AddAccessDeniedAce( *ppAcl, ACL_REVISION, dwAccess, *ppSid );

			if ( rc && pSecInfo )
				*pSecInfo |= DACL_SECURITY_INFORMATION;
			break;
		}
	case L'O':	// specify the owner
		rc = SetSecurityDescriptorOwner( pSecurityDescriptor, *ppSid, FALSE );
		if (rc)
		{
			if(pSecInfo)
				*pSecInfo |= OWNER_SECURITY_INFORMATION;
		}
		else 
			return GetLastError();
		break;
	case 'G':	// specify the group
		rc = SetSecurityDescriptorGroup( pSecurityDescriptor, *ppSid, FALSE );
		if (rc)
		{
			if(pSecInfo)
				*pSecInfo |=  GROUP_SECURITY_INFORMATION;
		}
		else 
			return GetLastError();
		break;
	default: // error
		ASSERT(0);
	}

	return 0;
}

/******************************************************************************

	GenSecurityDescriptor


 * Input: string line of the following format:
 *   right --> [+-]domain\username 0x333 
 *   line --> right1,right2,...
 *
 * Notes: 
 *   domain and username that contain spaces should be enclosed in 
 *     double quotes "
 *   white spaces are allowed.
 *
 * output Security descriptor that must be freed by the calling routine.
 *
 * return codes:
 *   0 if everything went well.
******************************************************************************/

#define SID_USUAL_SIZE	64


DWORD 
GenSecurityDescriptor(	SECURITY_INFORMATION*	pSecInfo,
						const WCHAR*			pwcsSecurityStr,
						PSECURITY_DESCRIPTOR*	ppSD)
{
	PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
	PACL	pAcl = NULL;
	PSID	pSid = NULL;
	WCHAR*	pwcsRight;

	ASSERT(pwcsSecurityStr != NULL);
	ASSERT(ppSD != NULL);
	
	//For automatic memory cleanup
	AP<WCHAR> pwcsAutoSecurity = new WCHAR[wcslen(pwcsSecurityStr) + 1];
	WCHAR* pwcsSecurity = pwcsAutoSecurity;

	wcscpy(pwcsSecurity, pwcsSecurityStr);

	*ppSD = NULL;	
	
	// reset the security inforamtion flags
	if (pSecInfo != NULL)
		(*pSecInfo) = 0;


	// remove leading spaces
	while(iswspace(*pwcsSecurity))
		pwcsSecurity++;

	// null input
	if ( !(*pwcsSecurity) || !_wcsicmp(pwcsSecurity, L"null") )
		return 0;

	
	// alocate and initialize a security descriptor
	pSecurityDescriptor = (PSECURITY_DESCRIPTOR)new BYTE[SECURITY_DESCRIPTOR_MIN_LENGTH];
	if ( !InitializeSecurityDescriptor( pSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION) )
	{
        DWORD gle = GetLastError();
		delete [] ((BYTE*)pSecurityDescriptor);
		return gle;
	}

	// alocate and initialize an access-control list
	pAcl = (PACL)new BYTE[sizeof(ACL)];
	if (!InitializeAcl( pAcl, sizeof(ACL), ACL_REVISION) )
	{
        DWORD gle = GetLastError();
		delete [] ((BYTE*)pSecurityDescriptor);
		delete [] ((BYTE*)pAcl);
		return gle;
	}

	DWORD dwSidSize = SID_USUAL_SIZE;
	pSid = (PSID)new BYTE[dwSidSize];
		
	
	// go over all rights
	pwcsRight = wcstok( pwcsSecurity, L";");
	while ( pwcsRight )
	{
		DWORD dwError =  fAddAce( pwcsRight,
								  pSecInfo, 
								  pSecurityDescriptor,
								  &pSid,
								  &dwSidSize,
								  &pAcl);
		if(dwError)
		{
			delete [] ((BYTE*)pSid);
			delete [] ((BYTE*)pAcl);
			delete [] ((BYTE*)pSecurityDescriptor);		
			return dwError;
		}

		pwcsRight = wcstok( NULL, L";");
	}

	DWORD dwStatus = 0;
	// add the dacl
	if(SetSecurityDescriptorDacl( pSecurityDescriptor, TRUE, pAcl, FALSE ))
	{
		// make the security descriptor a self realtive one
		DWORD dwSDLen = 0;
		MakeSelfRelativeSD( pSecurityDescriptor, NULL, &dwSDLen );
		dwStatus =  GetLastError();
		if(dwStatus == ERROR_INSUFFICIENT_BUFFER)
		{
			dwStatus = 0;
			*ppSD = (PSECURITY_DESCRIPTOR)new BYTE[dwSDLen];
 			if(!MakeSelfRelativeSD( pSecurityDescriptor, *ppSD, &dwSDLen ))
			{
				dwStatus = GetLastError();
				delete [] ((BYTE*)(*ppSD));
				*ppSD = NULL;
			}
		}
	}
	else
	{
		dwStatus = GetLastError();
	}
			
	delete [] ((BYTE*)pSid);
	delete [] ((BYTE*)pAcl);
	delete [] ((BYTE*)pSecurityDescriptor);

	return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigutil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once

#if !defined(AFX_STDAFX_H__1D9F85B4_9666_11D2_8927_0008C70C0622__INCLUDED_)
#define AFX_STDAFX_H__1D9F85B4_9666_11D2_8927_0008C70C0622__INCLUDED_

#include <libpch.h>

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_DEBUG_CRT
#define ATLASSERT ASSERT

#include <atlbase.h>

//
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
//
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

//---------------------------------------------------------------------------------
// CUSTOM ADDITION END HERE.
//---------------------------------------------------------------------------------

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1D9F85B4_9666_11D2_8927_0008C70C0622__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigutil\queueutil.cpp ===
//*****************************************************************************
//
// Class Name  :
//
// Author      : Yifat Peled
// 
// Description :
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 4/07/99	| yifatp	| Initial Release
//
//*****************************************************************************

#include "stdafx.h"
#include <mq.h>
#include <mqprops.h>
#include <fntoken.h>

#include "stdfuncs.hpp"

#import "mqtrig.tlb" no_namespace

#include "QueueUtil.hpp"
#include "mqsymbls.h"
#include "GenMQSec.h"

#include "queueutil.tmh"

using namespace std;

//
// Define the maximum size of the format queue name 
//
#define MAX_Q_FORMAT_NAME_LEN  512


//********************************************************************************
//
// Name		: OpenQueue		
// 
// Desc		: Opens the MSMQ queue that is specified by the queue path parameter.
//			  This method will create the queue if indicated to and if it does not already
//            exist and it should be local.
//
// Returns	: HRESULT (S_OK on success, S_FAIL otherwise)
//
//
//********************************************************************************
HRESULT OpenQueue(
			_bstr_t bstrQueuePath,
			DWORD dwAction,
			bool fCreateIfNotExist,
			QUEUEHANDLE * pQHandle,
			_bstr_t* pbstrFormatName
			)
{	
	HRESULT hr = S_OK;

	(*pbstrFormatName) = _T("");
	bool fQueueCreated = false;

	MQQUEUEPROPS QueueProps;
	PROPVARIANT aVariant[2];
	QUEUEPROPID aPropId[2];
	DWORD PropIdCount = 0;

	// Validate that we have been supplied with a valid queue access parameter
	if ((dwAction != MQ_SEND_ACCESS) && (dwAction != MQ_PEEK_ACCESS) && (dwAction != MQ_RECEIVE_ACCESS))
	{
		// create the rich error info object.
		//
		// ISSUE: Need to return appropriate code
		//
		TrERROR(GENERAL, "The supplied queue access parameter is not valid. The supplied value was (%d). Valid values are (%d, %d, %d).",dwAction,(long)MQ_SEND_ACCESS,(long)MQ_PEEK_ACCESS,(long)MQ_RECEIVE_ACCESS);
		return MQTRIG_INVALID_PARAMETER;
	}

	bool fQueueIsLocal = true;
	bool fQueueIsPrivate = true;
	SystemQueueIdentifier SystemQueue = IsSystemQueue(bstrQueuePath);

	if(SystemQueue == SYSTEM_QUEUE_NONE)
	{
		fQueueIsLocal = IsQueueLocal(bstrQueuePath);
		fQueueIsPrivate = IsPrivateQPath((TCHAR*)bstrQueuePath);

		if(fCreateIfNotExist && fQueueIsLocal)
		{
			//we create only private queues for the service
			// Public queue creation will need further handling because of replication
			//
			ASSERT(fQueueIsPrivate); 

			DWORD dwFormatNameLen = 0;
			TCHAR szFormatName[MAX_Q_FORMAT_NAME_LEN];

			// Initialize the buffer that will be used to hold the format name
			ZeroMemory(szFormatName,sizeof(szFormatName));
			dwFormatNameLen = sizeof(szFormatName) / sizeof(TCHAR);

			//Set the PROPID_Q_PATHNAME property.
			aPropId[PropIdCount] = PROPID_Q_PATHNAME;    //PropId
			aVariant[PropIdCount].vt = VT_LPWSTR;        //Type
			aVariant[PropIdCount].pwszVal = (wchar_t*)bstrQueuePath;    

			PropIdCount++;    

			//Set the MQQUEUEPROPS structure.
			QueueProps.cProp = PropIdCount;           //No of properties
			QueueProps.aPropID = aPropId;             //Ids of properties
			QueueProps.aPropVar = aVariant;           //Values of properties
			QueueProps.aStatus = NULL;                //No error reports

			PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
			SECURITY_INFORMATION* pSecInfo = NULL;
			wstring wscSecurity = L"+:* A";
			
			DWORD dwError = GenSecurityDescriptor(
								pSecInfo,
								wscSecurity.c_str(),
								&pSecurityDescriptor );

			if(dwError != 0)
			{
				TrERROR(GENERAL, "Failed to create security descriptor");					
				return MQTRIG_ERROR;
			}

			// Attempt to create the notifications queue.
			hr = MQCreateQueue(
					pSecurityDescriptor,
					&QueueProps,
					szFormatName,
					&dwFormatNameLen );
			
			//Clean allocated memory
			if ( pSecurityDescriptor != NULL )
				delete pSecurityDescriptor;

			// Check if the queue already existed or if we got an error etc...
			switch(hr)
			{
				case MQ_OK: // this is OK - do nothing
					(*pbstrFormatName) = szFormatName;
					fQueueCreated = true;
					break;

				case MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL: //queue was created, we just don't have the format name
					fQueueCreated = true;
					hr = MQ_OK;
					break;

				case MQ_ERROR_QUEUE_EXISTS: // this is OK - remap return code to success.
					hr = MQ_OK;
					break;
				
				default: // Error
				{
					// Build some error context info (note that we do this before we assign general error code to HRESULT)
					TrERROR(GENERAL, "Failed to create the queue %ls.The HRESULT from MSMQ was (%X)", (wchar_t*)bstrQueuePath, hr);					
					return MQTRIG_ERROR;
				}
			}
			
		}
	}
	else //system queue, format name is given instead of path name
	{
		(*pbstrFormatName) = bstrQueuePath;
	}

		
	//
	// Since on NT4 direct format name for send is not available for receive,
	// we'll use the regular format name for local queues that we have from MQCreateQueue
	//
	if((*pbstrFormatName) == _bstr_t(_T("")))
	{
		(*pbstrFormatName) = GetDirectQueueFormatName(bstrQueuePath);
	}
	
	// Attempt to open the message queue 
	hr = MQOpenQueue(
			(*pbstrFormatName),
			(DWORD)dwAction,
			MQ_DENY_NONE,
			pQHandle );

	if(FAILED(hr))
	{
		//
		// again for NT4 machines we can only try to open public queues using regular
		// format name instead of direct
		//
		if(hr == MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION)
		{
			ASSERT(SystemQueue == SYSTEM_QUEUE_NONE);

			//for local queues or public remote queues (which were not created by this function)
			// we can use MQPathNameToFormatName
			if(fQueueIsLocal || (!fQueueIsPrivate && !fQueueCreated) )
			{
				DWORD dwLength = MAX_Q_FORMAT_NAME_LEN;
				AP<TCHAR> ptcs = new TCHAR[MAX_Q_FORMAT_NAME_LEN + 1];

				hr = MQPathNameToFormatName(
									(TCHAR*)bstrQueuePath,
									(TCHAR*)ptcs,
									&dwLength);
				
				if( hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL)	
				{
					//
					// re-alloc a larger buffer for format name
					//
					delete [] ptcs.detach();
					ptcs = new TCHAR[dwLength + 1];
					
					hr = MQPathNameToFormatName(
								(TCHAR*)bstrQueuePath,
								(TCHAR*)ptcs,
								&dwLength );

					ASSERT(hr != MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL);
				}

				if(FAILED(hr))
				{
					TrERROR(GENERAL, "Failed to get format name for the queue %ls. HRESULT = %X",(LPCWSTR)bstrQueuePath, hr);
					return hr;
				}

				(*pbstrFormatName) = ptcs;

				// Attempt to open the message queue 
				hr = MQOpenQueue(
							(*pbstrFormatName),
							(DWORD)dwAction,
							MQ_DENY_NONE,
							pQHandle );
			}
		}
	
		if(FAILED(hr))
		{
			TrERROR(GENERAL, "Failed to open the queue %ls. HRESULT = %X",(LPCWSTR)bstrQueuePath, hr);
			return hr;
		}
	}	

	return S_OK;
}


_bstr_t GetDirectQueueFormatName(_bstr_t bstrQueuePath)
{
	bstr_t bstrDirectFormatName = L"DIRECT=OS:";
	bstrDirectFormatName += bstrQueuePath;

	return bstrDirectFormatName;
}

bool IsPrivateQPath(wstring wcsQPath)
{
	AP<WCHAR> pwcs = new WCHAR[wcsQPath.length() + 1];
	wcscpy(pwcs, wcsQPath.c_str());
	CharLower(pwcs);

	wstring wcs = pwcs;

	return ( wcs.find(L"private$") != wstring::npos );
}


bool IsQueueLocal(_bstr_t bstrQueuePath)
{
	_bstr_t bstrLocalComputerName;
	DWORD dwError = GetLocalMachineName(&bstrLocalComputerName);
	
    ASSERT(dwError == 0);//BUGBUG - should throw an exception
    DBG_USED(dwError);

	// get the machine name from the queue path
	std::wstring wcsQueuePath = (wchar_t*)bstrQueuePath;
	std::wstring::size_type pos = wcsQueuePath.find_first_of(L"\\");
	bstr_t bstrMachineName = wcsQueuePath.substr(0, pos).c_str();
	
	if(bstrMachineName == _bstr_t(L".") || bstrMachineName == bstrLocalComputerName )
		return true;

	return false;
}

SystemQueueIdentifier IsSystemQueue(_bstr_t QueueName)
{
	LPCWSTR systemQueueType = wcschr(static_cast<LPCWSTR>(QueueName), FN_SUFFIX_DELIMITER_C);

	if (systemQueueType	== NULL)
		return SYSTEM_QUEUE_NONE;

	if( _wcsicmp(systemQueueType, FN_JOURNAL_SUFFIX) == 0)
		return SYSTEM_QUEUE_JOURNAL;

	if(_wcsicmp(systemQueueType, FN_DEADLETTER_SUFFIX) == 0)
		return SYSTEM_QUEUE_DEADLETTER;

	if(_wcsicmp(systemQueueType, FN_DEADXACT_SUFFIX) == 0) 
		return SYSTEM_QUEUE_DEADXACT;

	return SYSTEM_QUEUE_NONE;
}


//
// DIRECT=OS:<computerName>\SYSTEM$;<suffix>
//
#define x_SystemQueueFormat FN_DIRECT_TOKEN	FN_EQUAL_SIGN FN_DIRECT_OS_TOKEN L"%s" \
                            FN_PRIVATE_SEPERATOR SYSTEM_QUEUE_PATH_INDICATIOR L"%s"

HRESULT GenSystemQueueFormatName(SystemQueueIdentifier SystemQueue, _bstr_t* pbstrFormatName)
{
	WCHAR computerName[MAX_COMPUTERNAME_LENGTH+1];
	DWORD size = TABLE_SIZE(computerName);

	if (!GetComputerName(computerName, &size))
		return GetLastError();

	LPCWSTR pSuffixType;

	switch(SystemQueue)
	{
	case SYSTEM_QUEUE_JOURNAL:
		pSuffixType = FN_JOURNAL_SUFFIX;
		break;
	
	case SYSTEM_QUEUE_DEADLETTER:
		pSuffixType = FN_DEADLETTER_SUFFIX;
		break;

	case SYSTEM_QUEUE_DEADXACT:
		pSuffixType = FN_DEADXACT_SUFFIX;
		break;

	default:
		ASSERT(0);
		return S_FALSE;
	}

	WCHAR formatName[512];
	int n = _snwprintf(formatName, STRLEN(formatName), x_SystemQueueFormat, computerName, pSuffixType);
	formatName[STRLEN(formatName)] = L'\0';

	if (n < 0)
		return S_FALSE;

	(*pbstrFormatName) = formatName; 
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigutil\ruleinfo.cpp ===
//*****************************************************************************
//
// Class Name  : CRuntimeRuleInfo
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class encapsulates information about a trigger rule. 
//               It is used to cache rule information at runtime about trigger
//               rules, as well as accessing the underlying trigger storage 
//               medium. 
//
// Notes       : The current implementation uses the registry as the storage 
//               medium.
//
//               This class is used by both the trggers service and the trigger
//               COM components.
// 
// When     | Who       | Change Descriptin
// ------------------------------------------------------------------
// 15/01/99 | jsimpson  | Initial Release
//
//*****************************************************************************
#include "stdafx.h"
#include "mqtg.h"
#include "stdfuncs.hpp"
#include "Cm.h"
#include "ruleinfo.hpp"

#include "ruleinfo.tmh"


//*****************************************************************************
//
// Method      : Constructor
//
// Description : Initialize an empty instance of this class.
//
//*****************************************************************************
CRuntimeRuleInfo::CRuntimeRuleInfo( 
	LPCTSTR pwzRegPath 
	) :
	m_MSMQRuleHandler(NULL)
{
	m_bstrRuleID = _T("");
	m_bstrRuleName = _T("");
	m_bstrAction = _T("");
	m_bstrCondition = _T("");
	m_bstrImplementationProgID = _T("");
	m_fShowWindow = false;

	_snwprintf(m_wzRuleRegPath, TABLE_SIZE(m_wzRuleRegPath), L"%s\\%s", pwzRegPath, REG_SUBKEY_RULES);
}

//*****************************************************************************
//
// Method      : Constructor
//
// Description : Initialize an instance of the CRuntimeRuleInfo structure
//
//*****************************************************************************
CRuntimeRuleInfo::CRuntimeRuleInfo(
	const _bstr_t& ruleId,
	BSTR bsRuleName,
	BSTR bsRuleDescription,
	BSTR bsRuleCondition,
	BSTR bsRuleAction,
	BSTR bsRuleImplementationProgID,
	LPCTSTR pwzRegPath,
	bool fShowWindow
	):
	m_bstrRuleID(ruleId),
	m_MSMQRuleHandler(NULL)
{
	ASSERT(bsRuleName != NULL);
	m_bstrRuleName = bsRuleName;

	if(bsRuleDescription == NULL)
	{
		m_bstrRuleDescription = _T("");
	}
	else
	{
		m_bstrRuleDescription = bsRuleDescription;
	}

	ASSERT(bsRuleAction != NULL); //always contains COM or EXE
	m_bstrAction = bsRuleAction;

	if(bsRuleCondition == NULL)
	{
		m_bstrCondition = _T("");
	}
	else
	{
		m_bstrCondition = bsRuleCondition; 
	}

	if(bsRuleImplementationProgID == NULL)
	{
		m_bstrImplementationProgID = _T("");
	}
	else
	{
		m_bstrImplementationProgID = bsRuleImplementationProgID; 
	}
	
	m_fShowWindow = fShowWindow; 

	_snwprintf(m_wzRuleRegPath, TABLE_SIZE(m_wzRuleRegPath), L"%s\\%s", pwzRegPath, REG_SUBKEY_RULES);
}

//*****************************************************************************
//
// Method      : Destructor
//
// Description : Does nothing.
//
//*****************************************************************************
CRuntimeRuleInfo::~CRuntimeRuleInfo()
{
}


//*****************************************************************************
//
// Method      : GetRuleKeyHandle
//
// Description : Returns a handle to specified registry key
//
//*****************************************************************************
HKEY 
CRuntimeRuleInfo::GetRuleKeyHandle(
    HKEY hRegistry,
    LPCTSTR ruleId
    )
{
    TCHAR rulePath[MAX_REGKEY_NAME_SIZE];

	int n = _snwprintf(rulePath, MAX_REGKEY_NAME_SIZE - 1, L"%s%s", m_wzRuleRegPath, ruleId);
	rulePath[MAX_REGKEY_NAME_SIZE - 1] = L'\0';
	if (n < 0)
	{
		TrERROR(GENERAL, "Buffer to small to contain the registry path of a rule.");
		return NULL;
	}

    RegEntry ruleReg(rulePath,  NULL, 0, RegEntry::Optional, hRegistry);
    return CmOpenKey(ruleReg, KEY_READ); 
}



//*****************************************************************************
//
// Method      : IsValid
//
// Description : Returns a boolean value indicating if the current 
//               instance represents a valid rule definition.
//
//*****************************************************************************
bool CRuntimeRuleInfo::IsValid()
{
	return(IsValidRuleID(m_bstrRuleID) &&
		   IsValidRuleName(m_bstrRuleName) &&
		   IsValidRuleDescription(m_bstrRuleDescription) &&
		   IsValidRuleAction(m_bstrAction) &&
		   IsValidRuleCondition(m_bstrCondition) &&
		   IsValidRuleProgID(m_bstrImplementationProgID)); 
}


//*****************************************************************************
//
// Method      : Update
//
// Description : This method is used to update the definition of this
//               rule (currently in persisted in the registry).
//
//*****************************************************************************
bool CRuntimeRuleInfo::Update(HKEY hRegistry)
{
	// Assert that we have valid parameters
	ASSERT(hRegistry != NULL);
	ASSERT(IsValid());

    CRegHandle hRuleKey = GetRuleKeyHandle(hRegistry, m_bstrRuleID );
    if (hRuleKey == NULL)
    {
		TrERROR(GENERAL, "Failed to update rule properties for rule: %ls. Rule does't exist in registry", (LPCWSTR)m_bstrRuleID);
        return false;
    }

    try
    {
	    FlushValuesToRegistry(hRuleKey);
        return true;
    }
    catch (const bad_alloc&)
    {
        //
		// ISSUE-2000/10/26-urih: partial success can cause rule inconsistency
        //
		TrERROR(GENERAL, "Failed to update rule properties for: %ls rule.", (LPCWSTR)m_bstrRuleID);
	    return false;
    }
}

//*****************************************************************************
//
// Method      : Create
//
// Description : This method creates a new rule definition based on 
//               properties values of this class instance. 
//
//*****************************************************************************
bool CRuntimeRuleInfo::Create(HKEY hRegistry)
{
    //
	// Assert that we have valid parameters
    //
	ASSERT(hRegistry != NULL);

    //
    // Check that there the registery doesn't contain another rule with same ID
    //
    CRegHandle hNotExistRuleKey = GetRuleKeyHandle(hRegistry, m_bstrRuleID );
    if (hNotExistRuleKey != NULL)
    {
		TrERROR(GENERAL, "Failed to create a key for rule:%ls . Registry already contains rule with same ID.", (LPCWSTR)m_bstrRuleID);
        return false;
    }

    //
    // Assemble rule registery path
    //
    TCHAR rulePath[MAX_REGKEY_NAME_SIZE];

	int n = _snwprintf(rulePath, MAX_REGKEY_NAME_SIZE - 1, L"%s%s", m_wzRuleRegPath, static_cast<LPCWSTR>(m_bstrRuleID));
	rulePath[MAX_REGKEY_NAME_SIZE - 1] = L'\0';
	if (n < 0)
	{
		TrERROR(GENERAL, "Failed to create a key for rule:%ls. Buffer to small to contain the registry path of a rule.", (LPCWSTR)m_bstrRuleID);
		return false;
	}

    try
    {
        //
        // Create key for the rule in registry
        //
        RegEntry ruleReg(rulePath,  NULL, 0, RegEntry::MustExist, hRegistry);
        CRegHandle hRuleKey = CmCreateKey(ruleReg, KEY_ALL_ACCESS); 

	    FlushValuesToRegistry(hRuleKey);
    	return true;
    }
    catch(const bad_alloc&)
    {
        //
        // Remove the key if already created
        //
        RegEntry ruleReg(rulePath,  NULL, 0, RegEntry::Optional, hRegistry);
        CmDeleteKey(ruleReg);

		TrERROR(GENERAL, "Failed to store rule:%ls in registry.",(LPCWSTR)m_bstrRuleID);
        return false;
	}
}

//*****************************************************************************
//
// Method      : Delete
//
// Description : This method will delete the current rule definition from the 
//               registry. Note that before deleting a rule we must check that 
//               it is not currently in use. We do this by retrieving the rule
//               definition again and checking the reference count. 
//
//*****************************************************************************
bool CRuntimeRuleInfo::Delete(HKEY hRegistry)
{
    try
    {
        RegEntry rulesReg(m_wzRuleRegPath, NULL, 0, RegEntry::MustExist, hRegistry);
        CRegHandle hRuless = CmOpenKey(rulesReg, KEY_ALL_ACCESS);

        RegEntry ruleReg(m_bstrRuleID, NULL, 0, RegEntry::MustExist, hRuless);
        CmDeleteKey(ruleReg);

        return true;
    }
    catch (const exception&)
    {
		TrERROR(GENERAL, "Failed to delete rule:%ls from registry.", (LPCWSTR)m_bstrRuleID);
        return false;
	}
}

//*****************************************************************************
//
// Method      : Retrieve
//
// Description : This method retrieve the specified rule ID from the 
//               supplied registry key. 
//
//*****************************************************************************
bool CRuntimeRuleInfo::Retrieve(HKEY hRegistry, _bstr_t bstrRuleID)
{
    CRegHandle hRuleKey = GetRuleKeyHandle(hRegistry, bstrRuleID );
    if (hRuleKey == NULL)
    {
 		TrERROR(GENERAL, "Failed to retrieve rule properties from registery for %ls. Registery key isn't exist.", (LPCWSTR)m_bstrRuleID);
        return false;
    }

    try
    {
        //
        // Retrieve rule name
        //
        AP<TCHAR> ruleName = NULL;
        RegEntry ruleNameReg(NULL, REGISTRY_RULE_VALUE_NAME, 0, RegEntry::MustExist, hRuleKey);
        CmQueryValue(ruleNameReg, &ruleName);

        //
        // Retrieve rule description
        //
        AP<TCHAR> ruleDescription = NULL;
        RegEntry ruleDescReg(NULL, REGISTRY_RULE_VALUE_DESCRIPTION, 0, RegEntry::MustExist, hRuleKey);
        CmQueryValue(ruleDescReg, &ruleDescription);

        //
        // Retrieve rule prog-id
        //
        AP<TCHAR> ruleProgid = NULL;
        RegEntry ruleProgidReg(NULL, REGISTRY_RULE_VALUE_IMP_PROGID, 0, RegEntry::MustExist, hRuleKey);
        CmQueryValue(ruleProgidReg, &ruleProgid);

        //
	    // Retrieve rule condition
        //
        AP<TCHAR> ruleCond = NULL;
        RegEntry ruleCondReg(NULL, REGISTRY_RULE_VALUE_CONDITION, 0, RegEntry::MustExist, hRuleKey);
        CmQueryValue(ruleCondReg, &ruleCond);

        //
	    // Retrieve rule action
        //
        AP<TCHAR> ruleAction = NULL;
        RegEntry ruleActReg(NULL, REGISTRY_RULE_VALUE_ACTION, 0, RegEntry::MustExist, hRuleKey);
        CmQueryValue(ruleActReg, &ruleAction);

        //
        // Retrieve rule show console window value
        //
        DWORD ruleShowWindow;
        RegEntry ruleShowWinReg(NULL, REGISTRY_RULE_VALUE_SHOW_WINDOW, 0, RegEntry::MustExist, hRuleKey);
        CmQueryValue(ruleShowWinReg, &ruleShowWindow);
        
	    //
        // Initialise the member vars of this rule instance. 
        //
		m_bstrRuleID = bstrRuleID;
		m_bstrRuleName = ruleName;
		m_bstrRuleDescription = ruleDescription;
		m_bstrImplementationProgID = ruleProgid;
		m_bstrCondition = ruleCond;
		m_bstrAction = ruleAction;
		m_fShowWindow = ruleShowWindow != 0;

		if (IsValid())
            return true;

		//
        // Invalid rule. write a log message and return false.
		//
		TrERROR(GENERAL, "Failed to retrieve rule properties for %ls. Rule property isn't valid", (LPCWSTR)m_bstrRuleID);
		return false;
    }
    catch (const exception&)
	{
		TrERROR(GENERAL, "Failed to retrieve rule %ls from registry", (LPCWSTR)bstrRuleID);
        return false;
	}
}

//*****************************************************************************
//
// Method      : FlushValuesToRegistry
//
// Description : This method flushes the member variable values to the 
//               supplied registry key.
//
//*****************************************************************************
void 
CRuntimeRuleInfo::FlushValuesToRegistry(
    const HKEY& hRuleKey
    )
{
    //
	// Set the NAME value for this rule
    //
    RegEntry ruleNameReg(NULL, REGISTRY_RULE_VALUE_NAME, 0, RegEntry::MustExist, hRuleKey);
    CmSetValue(ruleNameReg, m_bstrRuleName);

    //
    // set the DESCRIPTION value for this rule
    //
    RegEntry ruleDescReg(NULL, REGISTRY_RULE_VALUE_DESCRIPTION, 0, RegEntry::MustExist, hRuleKey);
    CmSetValue(ruleDescReg, m_bstrRuleDescription);

	// Create the Implementation value for this rule. Note that in this release we are 
	// not allow the user supplied prog-id to be used - we are forcing the use of the MS
	// supplied rule-handler.
   	m_bstrImplementationProgID = _T("MSQMTriggerObjects.MSMQRuleHandler"); // TO BE REMOVED.
    RegEntry ruleUmpProgReg(NULL, REGISTRY_RULE_VALUE_IMP_PROGID, 0, RegEntry::MustExist, hRuleKey);
    CmSetValue(ruleUmpProgReg, m_bstrImplementationProgID);

    //
	// Set the Condition value for this rule
    //
    RegEntry ruleCondReg(NULL, REGISTRY_RULE_VALUE_CONDITION, 0, RegEntry::MustExist, hRuleKey);
    CmSetValue(ruleCondReg, m_bstrCondition);

    //
    // Set the Action value for this rule
    //
    RegEntry ruleActReg(NULL, REGISTRY_RULE_VALUE_ACTION, 0, RegEntry::MustExist, hRuleKey);
    CmSetValue(ruleActReg, m_bstrAction);

    //
    // Set the show console window value
    //
    DWORD dwShowWindow = m_fShowWindow ? 1 : 0;
    RegEntry ruleShowWinReg(NULL, REGISTRY_RULE_VALUE_SHOW_WINDOW, 0, RegEntry::MustExist, hRuleKey);
    CmSetValue(ruleShowWinReg, dwShowWindow);
}


//*****************************************************************************
//
// Method      : IsValid*
//
// Description : The following static methods are used to validate 
//               the validity of parameters and member vars used by 
//               the CRuntimeRuleInfo class.
//
//*****************************************************************************
bool CRuntimeRuleInfo::IsValidRuleID(_bstr_t bstrRuleID)
{
	return((bstrRuleID.length() > 0) && (bstrRuleID.length() <= MAX_RULE_ID_LEN) ? true:false);
}
bool CRuntimeRuleInfo::IsValidRuleName(_bstr_t bstrRuleName)
{
	return((bstrRuleName.length() > 0) && (bstrRuleName.length() <= MAX_RULE_NAME_LEN) ? true:false);
}
bool CRuntimeRuleInfo::IsValidRuleDescription(_bstr_t bstrRuleDescription)
{
	return((bstrRuleDescription.length() <= MAX_RULE_DESCRIPTION_LEN)  ? true:false);
}
bool CRuntimeRuleInfo::IsValidRuleCondition(_bstr_t bstrRuleCondition)
{
	return((bstrRuleCondition.length() <= MAX_RULE_CONDITION_LEN)? true:false);
}
bool CRuntimeRuleInfo::IsValidRuleAction(_bstr_t bstrRuleAction)
{
	return((bstrRuleAction.length() > 0) && (bstrRuleAction.length() <= MAX_RULE_ACTION_LEN) ? true:false);
}
bool CRuntimeRuleInfo::IsValidRuleProgID(_bstr_t bstrRuleProgID)
{
	return((bstrRuleProgID.length() > 0) && (bstrRuleProgID.length() <= MAX_RULE_PROGID_LEN) ? true:false);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigutil\stdfuncs.cpp ===
//*****************************************************************************
//
// File Name   : stdfuncs.cpp
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This file contains the implementation of standard utility 
//               functions that are shared accross the MSMQ triggers projects.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 15/06/99 | jsimpson  | Initial Release
//
//*****************************************************************************

#include "stdafx.h"
#include "stdfuncs.hpp"

#define DLL_IMPORT
#define AFXAPI __stdcall

#include "_guid.h"
#include "cm.h"

#include "stdfuncs.tmh"

//*****************************************************************************
//
// Function    : FormatBSTR
//
// Description : 
//
//*****************************************************************************
void _cdecl FormatBSTR(_bstr_t * pbstrString, LPCTSTR lpszMsgFormat, ...)
{
	ASSERT(pbstrString != NULL);
	ASSERT(lpszMsgFormat != NULL);

	va_list argList;
	va_start(argList, lpszMsgFormat);

	WCHAR formatBstr[STRING_MSG_BUFFER_SIZE] = { 0 };
	int n = _vsntprintf(formatBstr, STRING_MSG_BUFFER_SIZE -1, lpszMsgFormat, argList);
	if (n > 0)
	{
		*pbstrString = formatBstr;
		va_end(argList);
		return;
	}

	//
	// The buffer is too short
	//
	DWORD size = STRING_MSG_BUFFER_SIZE;
	for(;;)
	{

		size = size + STRING_MSG_BUFFER_SIZE;
		
		AP<WCHAR> formatBstr = new WCHAR[size];

		ZeroMemory(formatBstr, size);

		n = _vsntprintf(formatBstr, size - 1, lpszMsgFormat, argList);
		if (n > 0)
		{
			*pbstrString = formatBstr;
			va_end(argList);
			return;
		}
	}
}

//*****************************************************************************
//
// Function    : GetTimeAsBSTR
//
// Description : 
//
//*****************************************************************************
void GetTimeAsBSTR(_bstr_t& bstrTime)
{
	SYSTEMTIME theTime;

	// Get the current time
	GetLocalTime(&theTime);
	FormatBSTR(&bstrTime,_T("%d%02d%02d %d:%d:%d:%d "),theTime.wYear,theTime.wMonth,theTime.wDay,theTime.wHour,theTime.wMinute,theTime.wSecond,theTime.wMilliseconds);
}


_bstr_t CreateGuidAsString(void)
{
	GUID guid;
	CoCreateGuid(&guid);

	GUID_STRING strGuid;
	MQpGuidToString(&guid, strGuid);

	return strGuid;
}


void ObjectIDToString(const OBJECTID *pID, WCHAR *wcsResult, DWORD dwSize)
{

   StringFromGUID2(pID->Lineage, wcsResult, dwSize);

   WCHAR szI4[12];

   _ltow(pID->Uniquifier, szI4, 10);

   wcscat(wcsResult, L"\\") ;
   wcscat(wcsResult, szI4) ;
}

//*****************************************************************************
//
// Function    : ConvertFromByteArrayToString
//
// Description : converts a one dimensional byte array into a BSTR 
//               type in-situ. Note that this method will clear the 
//               supplied byte array & release it's memory alloc.
//
//*****************************************************************************
HRESULT ConvertFromByteArrayToString(VARIANT * pvData)
{
	HRESULT hr = S_OK;
	BYTE * pByteBuffer = NULL;
	BSTR bstrTemp = NULL;

	// ensure we have been passed valid parameters
	ASSERT(pvData != NULL);
	ASSERT(pvData->vt == (VT_UI1 | VT_ARRAY));
	ASSERT(pvData->parray != NULL);

	// get a pointer to the byte data
	hr = SafeArrayAccessData(pvData->parray,(void**)&pByteBuffer);

	if SUCCEEDED(hr)
	{
		// determine the size of the data to be copied into the BSTR
		long lLowerBound = 0;
		long lUpperBound = 0;
		
		hr = SafeArrayGetLBound(pvData->parray,1,&lLowerBound);

		if SUCCEEDED(hr)
		{
			hr = SafeArrayGetUBound(pvData->parray,1,&lUpperBound);
		}

		if SUCCEEDED(hr)
		{
			DWORD dwDataSize = (lUpperBound - lLowerBound) + 1;

			// allocate a BSTR based on the contents & size of the byte buffer 
			bstrTemp = SysAllocStringLen((TCHAR*)pByteBuffer,dwDataSize/sizeof(TCHAR));

			if (bstrTemp == NULL)
			{
				hr = E_FAIL;
			}
		}
	
		// release the safe array (only if we got access to it originally)
		if (pByteBuffer != NULL)
		{
			hr = SafeArrayUnaccessData(pvData->parray);
		}

		// clear the caller supplied variant - note this will deallocate the safe-array
		if SUCCEEDED(hr)
		{
			hr = VariantClear(pvData);
		}

		// attach BSTR representation of the byte array
		if SUCCEEDED(hr)
		{
			pvData->vt = VT_BSTR;
			pvData->bstrVal = bstrTemp;
		}
	} 

	return(hr);
}

//*****************************************************************************
//
// Function    : GetDateVal
//
// Description : helper: gets a VARIANT VT_DATE or VT_DATE | VT_BYREF
//               returns 0 if invalid
//
//*****************************************************************************
static double GetDateVal(VARIANT *pvar)
{
	ASSERT(pvar != NULL);

    if (pvar)
	{
		if (pvar->vt == (VT_DATE | VT_BYREF))
		{
			return *V_DATEREF(pvar);
		}
		else if (pvar->vt == VT_DATE)
		{
			return V_DATE(pvar);
		}
    }

    return 0;
}

//*****************************************************************************
//
// Function    : SystemTimeOfTime
//
// Description : Converts time into systemtime. Returns TRUE if able to do the 
//               conversion, FALSE otherwise.
//
// Parameters  : iTime [in] time
//               psystime [out] SYSTEMTIME
//
// Notes       : Handles various weird conversions: off-by-one months, 1900 blues.
//
//*****************************************************************************
static BOOL SystemTimeOfTime(time_t iTime, SYSTEMTIME *psystime)
{
    tm *ptmTime; 

	ASSERT(psystime != NULL);

    ptmTime = localtime(&iTime);

    if (ptmTime == NULL)
	{
		// 
		// can't convert time
		//
		return FALSE;
    }

    psystime->wYear = numeric_cast<USHORT>(ptmTime->tm_year + 1900);
    psystime->wMonth = numeric_cast<USHORT>(ptmTime->tm_mon + 1);
    psystime->wDayOfWeek = numeric_cast<USHORT>(ptmTime->tm_wday);
    psystime->wDay = numeric_cast<USHORT>(ptmTime->tm_mday);
    psystime->wHour = numeric_cast<USHORT>(ptmTime->tm_hour);
    psystime->wMinute = numeric_cast<USHORT>(ptmTime->tm_min);
    psystime->wSecond = numeric_cast<USHORT>(ptmTime->tm_sec);
    psystime->wMilliseconds = 0;

    return TRUE;
}

//*****************************************************************************
//
// Function    : TimeOfSystemTime
//
// Converts systemtime into time
//
// Parameters:
//    [in] SYSTEMTIME
//
// Output:
//    piTime       [out] time
//
// Notes:
//    Various weird conversions: off-by-one months, 1900 blues.
//
//*****************************************************************************
static BOOL TimeOfSystemTime(SYSTEMTIME *psystime, time_t *piTime)
{
    tm tmTime;

    tmTime.tm_year = psystime->wYear - 1900;
    tmTime.tm_mon = psystime->wMonth - 1;
    tmTime.tm_wday = psystime->wDayOfWeek;
    tmTime.tm_mday = psystime->wDay;
    tmTime.tm_hour = psystime->wHour; 
    tmTime.tm_min = psystime->wMinute;
    tmTime.tm_sec = psystime->wSecond; 

    //
    // set daylight savings time flag from localtime() #3325 RaananH
    //
    time_t tTmp = time(NULL);
    struct tm * ptmTmp = localtime(&tTmp);
    if (ptmTmp)
    {
        tmTime.tm_isdst = ptmTmp->tm_isdst;
    }
    else
    {
        tmTime.tm_isdst = -1;
    }

    *piTime = mktime(&tmTime);
    return (*piTime != -1); //#3325
}


//*****************************************************************************
//
// Function    : TimeToVariantTime
//
//  Converts time_t to Variant time
//
// Parameters:
//    iTime       [in] time
//    pvtime      [out] 
//
// Output:
//    TRUE if successful else FALSE.
//
//*****************************************************************************
static BOOL TimeToVariantTime(time_t iTime, double *pvtime)
{
    SYSTEMTIME systemtime;

    if (SystemTimeOfTime(iTime, &systemtime))
	{
		return SystemTimeToVariantTime(&systemtime, pvtime);
    }

    return FALSE;
}

//*****************************************************************************
//
// Function    : VariantTimeToTime
//
//  Converts Variant time to time_t
//
// Parameters:
//    pvarTime   [in]  Variant datetime
//    piTime     [out] time_t
//
// Output:
//    TRUE if successful else FALSE.
//
//*****************************************************************************
static BOOL VariantTimeToTime(VARIANT *pvarTime, time_t *piTime)
{
    // WORD wFatDate, wFatTime;
    SYSTEMTIME systemtime;
    double vtime;

    vtime = GetDateVal(pvarTime);
    if (vtime == 0) {
      return FALSE;
    }
    if (VariantTimeToSystemTime(vtime, &systemtime)) {
      return TimeOfSystemTime(&systemtime, piTime);
    }
    return FALSE;
}

//*****************************************************************************
//
// Function    : GetVariantTimeOfTime
//
// Converts time to variant time
//
// Parameters:
//    iTime      [in]  time to convert to variant
//    pvarTime - [out] variant time
//
//*****************************************************************************
HRESULT GetVariantTimeOfTime(time_t iTime, VARIANT FAR* pvarTime)
{
    double vtime;
    VariantInit(pvarTime);
    if (TimeToVariantTime(iTime, &vtime)) {
      V_VT(pvarTime) = VT_DATE;
      V_DATE(pvarTime) = vtime;
    }
    else {
      V_VT(pvarTime) = VT_ERROR;
      V_ERROR(pvarTime) = 13; // UNDONE: VB type mismatch
    }
    return NOERROR;
}

//*****************************************************************************
//
// Function    : BstrOfTime
//
// Description : Converts time into a displayable string in user's locale
//
// Parameters  :  [in] iTime time_t
//                [out] BSTR representation of time
//
//*****************************************************************************
static BSTR BstrOfTime(time_t iTime)
{
    SYSTEMTIME sysTime;
    CHAR bufDate[128] = "";
    CHAR bufTime[128] = "";
    WCHAR wszTmp[128] = L"";
    
    UINT cchDate, cbDate, cbTime;
    BSTR bstrDate = NULL;

	// Convert time_t to a SYSTEMTIME structure
    SystemTimeOfTime(iTime, &sysTime); 
	
	// format the date portion
    cbDate = GetDateFormatA(
              LOCALE_USER_DEFAULT,
              DATE_SHORTDATE, // flags specifying function options
              &sysTime,       // date to be formatted
              0,              // date format string - zero means default for locale
              bufDate,        // buffer for storing formatted string
              sizeof(bufDate) // size of buffer
              );

    if (cbDate == 0)
	{
      ASSERT(GetLastError() == 0);
 
 //     IfNullGo(cbDate);
    }

    // add a space
    bufDate[cbDate - 1] = ' ';
    bufDate[cbDate] = 0;  // null terminate

    cbTime = GetTimeFormatA(
              LOCALE_USER_DEFAULT,
              TIME_NOSECONDS, // flags specifying function options
              &sysTime,       // date to be formatted
              0,              // time format string - zero means default for locale
              bufTime,        // buffer for storing formatted string
              sizeof(bufTime)); // size of buffer
       
    if (cbTime == 0) 
	{
      ASSERT(GetLastError() == 0);
//      IfNullGo(cbTime);
    }
    //
    // concat
    //
    strcat(bufDate, bufTime);
    //
    // convert to BSTR
    //
    cchDate = MultiByteToWideChar(CP_ACP, 
                                  0, 
                                  bufDate, 
                                  -1, 
                                  wszTmp, 
                                  sizeof(wszTmp)/sizeof(WCHAR));
    if (cchDate != 0)
	{
      bstrDate = SysAllocString(wszTmp);
    }
    else 
	{
      ASSERT(GetLastError() == 0);
    }

    // fall through...

    return bstrDate;
}


//*****************************************************************************
//
// Method      : GetNumericConfigParm
//
// Description : Retreives a specific registry numeric value. Inserts
//               a default value if the requested key could not found 
//
//*****************************************************************************
void 
GetNumericConfigParm(
	LPCTSTR lpszParmKeyName,
	LPCTSTR lpszParmName,
	DWORD* pdwValue,
	DWORD dwDefaultValue
	)
{
	try
	{
		RegEntry regParam(lpszParmKeyName, lpszParmName, dwDefaultValue, RegEntry::MustExist, HKEY_LOCAL_MACHINE); 
		CmQueryValue(regParam, pdwValue);

		return;
	}
	catch(const exception&)
	{
		RegEntry regParam(lpszParmKeyName, lpszParmName, 0, RegEntry::Optional, HKEY_LOCAL_MACHINE); 
		CmSetValue(regParam, dwDefaultValue);
	}
}

//*****************************************************************************
//
// Method      : SetNumericConfigParm
//
// Description : Sets a numeric registry value. Returns ERROR_SUCCESS
//               on success, otherwise returns the last Win32 error code.
//               Note that this method will create a key if it is not 
//               found.
//
//*****************************************************************************
bool 
SetNumericConfigParm(
	LPCTSTR lpszParmKeyName,
	LPCTSTR lpszParmName,
	DWORD dwValue
	)
{
	//
	// Ensure that we have been passed valid parameters.
	//
	ASSERT(lpszParmKeyName != NULL);
	ASSERT(lpszParmName != NULL);

	try
	{
		RegEntry reg(lpszParmKeyName, lpszParmName, 0, RegEntry::MustExist, HKEY_LOCAL_MACHINE);
		CmSetValue(reg, dwValue);
		
		return true;
	}
	catch(const exception&)
	{
		return false;
	}
}


bool UpdateMachineNameInQueuePath(_bstr_t bstrOldQPath, _bstr_t MachineName, _bstr_t* pbstrNewQPath)
{
	std::wstring wcsOldQPath = (wchar_t*)(bstrOldQPath);
	if(wcsOldQPath[0] == L'.')
	{
		std::wstring wcsNewQPath;
		
		wcsNewQPath = (wchar_t*)MachineName;
		wcsNewQPath += wcsOldQPath.substr(1);

		*pbstrNewQPath = wcsNewQPath.c_str();
		return true;
	}
	else
	{
		*pbstrNewQPath = bstrOldQPath;
		return false;
	}
}


DWORD GetLocalMachineName(_bstr_t* pbstrMachine)
{
	TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1] = L"";
	DWORD dwComputerNameBufferSize = TABLE_SIZE(szComputerName);

	//
	// get the current machine name (we use this as a default value)
	//
	BOOL fRet = GetComputerName(szComputerName, &dwComputerNameBufferSize);
	if(fRet == FALSE)
	{
		return GetLastError();
	}

	*pbstrMachine = szComputerName;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigutil\triginfo.cpp ===
//*****************************************************************************
//
// Class Name  : CRuntimeTriggerInfo
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : This class encapsulates information about a trigger, as well as
//               being the interface to the underlying trigger data store. This
//               class can be used on its own to store trigger information at 
//               runtime, and it can also wrapped in COM class to provide COM
//               access to the underlying trigger data.
//
// Notes       : The current implementation uses the registry as the storage 
//               medium.
//
//               This class is used by both the trggers service and the trigger
//               COM components.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 18/12/98 | jsimpson  | Initial Release
//
//*****************************************************************************

#include "stdafx.h"
#include <mq.h>
#include "mqtg.h"
#include "stdfuncs.hpp"

#import "mqtrig.tlb" no_namespace

#include "QueueUtil.hpp"
#include "triginfo.hpp"
#include "Cm.h"
#include "mqsymbls.h"

#include "triginfo.tmh"

using namespace std;

#define ATTACH_RULE_PREFIX L"Rule"

//*****************************************************************************
//
// Method      : Constructor
//
// Description : Initializes an empty instance of the CRuntimeTriggerInfo class
//
//*****************************************************************************
CRuntimeTriggerInfo::CRuntimeTriggerInfo( LPCTSTR pwzRegPath )
{
	m_bstrTriggerID = _T("");
	m_bstrTriggerName = _T("");
	m_bstrQueueName = _T("");
	m_bAdminTrigger = false;
	m_bEnabled = true;
	m_bSerialized = false;
	m_msgProcType = PEEK_MESSAGE;
	m_SystemQueue = SYSTEM_QUEUE_NONE;

	_tcscpy( m_wzRegPath, pwzRegPath );
	
	_snwprintf(m_wzTriggerRegPath, TABLE_SIZE(m_wzTriggerRegPath), L"%s\\%s", pwzRegPath, REG_SUBKEY_TRIGGERS);
}


//*****************************************************************************
//
// Method      :
//
// Description :
//
//*****************************************************************************
CRuntimeTriggerInfo::CRuntimeTriggerInfo(
	const _bstr_t& triggerId,
	BSTR bsTriggerName,
	BSTR bsQueueName, 
	LPCTSTR pwzRegPath,
	SystemQueueIdentifier SystemQueue, 
	bool bEnabled, 
	bool bSerialized,
	MsgProcessingType msgProcType
	) :
	m_bstrTriggerID(triggerId)
{
	m_bstrTriggerName = bsTriggerName;

	m_SystemQueue = SystemQueue;
	m_bstrQueueName = bsQueueName;
	
	m_bAdminTrigger = false;
	m_bEnabled = bEnabled;
	m_bSerialized = bSerialized;
	m_msgProcType = msgProcType;

	_tcscpy( m_wzRegPath, pwzRegPath );
	
	_snwprintf(m_wzTriggerRegPath, TABLE_SIZE(m_wzTriggerRegPath), L"%s\\%s", pwzRegPath, REG_SUBKEY_TRIGGERS);
}

//*****************************************************************************
//
// Method      :
//
// Description :
//
//*****************************************************************************
CRuntimeTriggerInfo::~CRuntimeTriggerInfo()
{
	// Release any resources held by the rules list.
	ClearRulesList();
}

//*****************************************************************************
//
// Method      : IsValid
//
// Description : Returns a boolean value indicating if the current 
//               instance represents a valid trigger definition.
//
//*****************************************************************************
bool CRuntimeTriggerInfo::IsValid()
{
	return(IsValidTriggerID(this->m_bstrTriggerID) &&
		   IsValidTriggerName(this->m_bstrTriggerName) &&
		   (m_SystemQueue != SYSTEM_QUEUE_NONE  || IsValidTriggerQueueName(this->m_bstrQueueName)));
}


//*****************************************************************************
//
// Method      : GetRuleKeyHandle
//
// Description : Returns a handle to specified registry key
//
//*****************************************************************************
HKEY 
CRuntimeTriggerInfo::GetTriggerKeyHandle(
    HKEY hRegistry,
    LPCTSTR triggerId
    )
{
    TCHAR triggerPath[MAX_REGKEY_NAME_SIZE];

	int n = _snwprintf(triggerPath, MAX_REGKEY_NAME_SIZE - 1, L"%s%s", m_wzTriggerRegPath, triggerId);
	triggerPath[MAX_REGKEY_NAME_SIZE - 1] = L'\0';
	if (n < 0)
	{
		TrERROR(GENERAL, "Buffer to small to contain the registry path of a trigger.");
		return NULL;
	}

    RegEntry trigReg(triggerPath,  NULL, 0, RegEntry::Optional, hRegistry);
    return CmOpenKey(trigReg, KEY_READ); 
}


//*****************************************************************************
//
// Method      : BuildRulesList
//
// Description : This method populates the member var list of rules
//               that are attached to this trigger. It will clear 
//               the current contents of the rules list - and reload
//               rule information from the registry.
//
// Note        : If the current trigger does not have an 'AttachedRules'
//               key in the registry, this method will create one.
//
//*****************************************************************************
void 
CRuntimeTriggerInfo::BuildRulesList(
    HKEY hRegistry,
    _bstr_t &bstrTriggerID
    )
{
	// Assert that we have valid parameters
	ASSERT(hRegistry != NULL);
	ASSERT(CRuntimeTriggerInfo::IsValidTriggerID(bstrTriggerID));

	// Release any resources currently held by the rules list.
	ClearRulesList();

    //
    // Open trigger key in registry
    //
    CRegHandle hTrigKey = GetTriggerKeyHandle(hRegistry, bstrTriggerID);
    if (hTrigKey == NULL)
    {
		TrERROR(GENERAL, "Failed to load trigger information. Trigger %ls isn't exist.",(LPCWSTR) bstrTriggerID);
        return;
    }

    //
    // Get registry handle key to attached rule
    //
    RegEntry  AttachedRuleReg(REGKEY_TRIGGER_ATTACHED_RULES, NULL, 0, RegEntry::Optional, hTrigKey);
    CRegHandle hAttachedRule = CmOpenKey(AttachedRuleReg, KEY_READ);
	
    if (hAttachedRule == NULL)
    {
        //
        // rule hasn't attached yet
        //
        return;
    }

    bool fDeletedRule = false;
    wostringstream listOfDeletedRules;

	typedef map<DWORD, CRuntimeRuleInfo* > ATTACHED_RULES_MAP;
	ATTACHED_RULES_MAP attachedRulesMap;

    //
	// Enumerate through the keys under the AttachedRules key.
	// Each Value here should be a RuleID. As we enumerate through these keys,
	// we will populate the rules list with instance of the CRuntimeRuleInfo class.
	// If any rule fails to load, we remove it from the list.
    //
	for(DWORD index =0;; ++index)
    {
		WCHAR ruleName[256];
		DWORD len = TABLE_SIZE(ruleName);

		LONG hr = RegEnumValue(	
						hAttachedRule,
						index,
						ruleName,
						&len,
						NULL,
						NULL,
						NULL,
						NULL
						);

		if(hr == ERROR_NO_MORE_ITEMS)
		{
			break;
		}

		if ((hr == ERROR_NOTIFY_ENUM_DIR) || (hr == ERROR_KEY_DELETED)) 
		{
			//
			// The registery was changed while we enumerate it. free all the data and
			// recall to the routine to build the attached rule list
			//
			for(ATTACHED_RULES_MAP::iterator it = attachedRulesMap.begin(); it != attachedRulesMap.end();) 
			{
				delete it->second;
				it = attachedRulesMap.erase(it);
			}
			return BuildRulesList(hRegistry, bstrTriggerID);
		}

		if(hr != ERROR_SUCCESS)
		{
			TrERROR(GENERAL, "Failed to Enumerate the attached rule from registry. Error 0x%x", hr);
			throw bad_alloc();
		}
	
        //
		// New rule id value, allocate a new rule structure and retrieve rule info.
        //
		AP<TCHAR> ruleId = NULL;

		RegEntry  AttRuleVal(REGKEY_TRIGGER_ATTACHED_RULES, ruleName, 0, RegEntry::MustExist, hTrigKey);
		CmQueryValue(AttRuleVal, &ruleId);

		
		P<CRuntimeRuleInfo> pRule = new CRuntimeRuleInfo( m_wzRegPath );
		if(pRule->Retrieve(hRegistry, ruleId.get()))
		{
			DWORD rulePriority;
			int n = _snwscanf(ruleName, TABLE_SIZE(ruleName), ATTACH_RULE_PREFIX L"%d", &rulePriority);

			if (n != 1)
			{
				TrERROR(GENERAL, "Corrupted attached rule registry value name, %ls. The rule is ignored.", ruleName);
				continue;				
			}
			
			attachedRulesMap[rulePriority] = pRule.get();
			pRule.detach();

            continue;
		}

        //
		//rule not found
        //
        if (fDeletedRule)
        {
           listOfDeletedRules << L", ";
        }
        else
        {
           fDeletedRule = true;
        }

        listOfDeletedRules << ruleId;
	}

	try
	{
		for(ATTACHED_RULES_MAP::iterator it = attachedRulesMap.begin(); it != attachedRulesMap.end();) 
		{
			m_lstRules.push_back(it->second);
			it = attachedRulesMap.erase(it);
		}
	}
	catch(const bad_alloc&)
	{
		TrERROR(GENERAL, "BuildRulesList failed due to low resources");

		for(ATTACHED_RULES_MAP::iterator it = attachedRulesMap.begin(); it != attachedRulesMap.end();) 
		{
			delete it->second;
			it = attachedRulesMap.erase(it);
		}

		throw;
	}


	if(fDeletedRule)
	{
		TrWARNING(GENERAL, "The rules: %ls could not be loaded for trigger: %ls.", listOfDeletedRules.str().c_str(), bstrTriggerID);

        //
		//update registry according to changes - some rules were not found
        //
		FlushAttachedRulesToRegistry(hRegistry);
	}
}

//*****************************************************************************
//
// Method      :
//
// Description :
//
//*****************************************************************************
void CRuntimeTriggerInfo::ClearRulesList()
{
	for(RUNTIME_RULEINFO_LIST::iterator it = m_lstRules.begin(); it != m_lstRules.end(); )
    {
	    CRuntimeRuleInfo* pRule = (*it);

		// We should never have null pointers in this list.
		ASSERT(pRule != NULL);

		// delete this rule object.
		delete pRule;

		// Look at the next item in the map and erase this list item.
		it = m_lstRules.erase(it);
	}
}

//*****************************************************************************
//
// Method      :
//
// Description :
//
//*****************************************************************************
CRuntimeRuleInfo* 
CRuntimeTriggerInfo::GetRule(
    long lIndex
    )
{
	if((lIndex < 0) || (lIndex >= numeric_cast<long>(m_lstRules.size())))
    {
		TrERROR(GENERAL, "Illegal rule index for trigger %ls. The max index is: %Id", (LPCWSTR)m_bstrTriggerID, m_lstRules.size()); 
		return NULL;
    }

    long ruleIndex = 0;

	for (RUNTIME_RULEINFO_LIST::iterator it = m_lstRules.begin(); it != m_lstRules.end(); ++it)
    {
		if (lIndex == ruleIndex)
		{
			//
			// ISSUE-2001/3/18-urih the returned object can be deleted if receiving detached rule
			// at the same time. reference count is required.
			//
            return *it;
		}

        ++ruleIndex;
	}

    //
    // Before calling the routine the caller checked that the rule index is valid
    //
    ASSERT(0);
    return NULL;
}


//*****************************************************************************
//
// Method      : IsRuleAttached
//
// Description :
//
//*****************************************************************************
bool 
CRuntimeTriggerInfo::IsRuleAttached(
    BSTR sRuleID
    )
{
	for (RUNTIME_RULEINFO_LIST::iterator it = m_lstRules.begin(); it != m_lstRules.end(); ++it)
	{
		CRuntimeRuleInfo* pRule = *it;

		// We should never store nulls in the rule list.
		ASSERT(pRule != NULL);

		if (_wcsicmp(pRule->m_bstrRuleID, sRuleID) == 0)
			return true; 
	}

	return false; 
}

//*****************************************************************************
//
// Method      : Update
//
// Description : This method is used to update the definition of this
//               trigger (currently in persisted in the registry).
//
//*****************************************************************************
bool CRuntimeTriggerInfo::Update(HKEY hRegistry)
{
	// Assert that we have valid parameters
	ASSERT(hRegistry != NULL);
	ASSERT(IsValid());

    CRegHandle hTrigKey = GetTriggerKeyHandle(hRegistry, m_bstrTriggerID);
    if (hTrigKey == NULL)
    {
		TrERROR(GENERAL, "Failed to upadte trigger %ls. Registery key isn't exist.", (LPCWSTR)m_bstrTriggerID);
        return false;
    }

    try
    {
	    FlushValuesToRegistry(hTrigKey);
        return true;
    }
    catch (const bad_alloc&)
    {
        //
		// ISSUE-2000/10/26-urih: partial success can cause trigger inconsistency
        //
		TrERROR(GENERAL, "Failed to update trigger properties for: %ls.", (LPCWSTR)m_bstrTriggerID);
	    return false;
    }
}

//*****************************************************************************
//
// Method      : Create
//
// Description : This method creates a new trigger definition based on 
//               properties values of this class instance. 
//
//*****************************************************************************
bool CRuntimeTriggerInfo::Create(HKEY hRegistry)
{
    //
	// Assert that we have valid parameters
    //
	ASSERT(hRegistry != NULL);

    //
    // Check that there the registery doesn't contain another rule with same ID
    //
    CRegHandle hNotExistTrigKey = GetTriggerKeyHandle(hRegistry, m_bstrTriggerID);
    if (hNotExistTrigKey != NULL)
    {
		TrERROR(GENERAL, "Failed to create a key for trigger:%ls . Registry already contains trigger with same ID.", (LPCWSTR)m_bstrTriggerID);
        return false;
    }

    //
    // Assemble rule registery path
    //
    TCHAR triggerPath[MAX_REGKEY_NAME_SIZE];

	int n = _snwprintf(triggerPath, MAX_REGKEY_NAME_SIZE - 1, L"%s%s", m_wzTriggerRegPath, static_cast<LPCWSTR>(m_bstrTriggerID));
	triggerPath[MAX_REGKEY_NAME_SIZE - 1] = L'\0';
	if (n < 0)
	{
		TrERROR(GENERAL, "Failed to create a key for trigger:%ls. Buffer to small to contain the registry path of a trigger.", (LPCWSTR)m_bstrTriggerID);
		return false;
	}


    RegEntry triggerReg(triggerPath,  NULL, 0, RegEntry::MustExist, hRegistry);
    try
    {
        //
        // Create key for the rule in registry
        //
        CRegHandle hTrigKey = CmCreateKey(triggerReg, KEY_ALL_ACCESS); 
	    FlushValuesToRegistry(hTrigKey);

        return true;
    }
    catch(const bad_alloc&)
    {
        //
        // Remove the key if already created
        //
        CmDeleteKey(triggerReg);

		TrERROR(GENERAL, "Failed to store trigger:%ls in registry", (LPCWSTR)m_bstrTriggerID);
        return false;
	}
}


//*****************************************************************************
//
// Method      : Delete
//
// Description : This method will delete the current trigger definition 
//               from the registry.
//
//*****************************************************************************
bool CRuntimeTriggerInfo::Delete(HKEY hRegistry)
{
    try
    {
        RegEntry triggersReg(m_wzTriggerRegPath, NULL, 0, RegEntry::MustExist, hRegistry);
        CRegHandle hTriggersData = CmOpenKey(triggersReg, KEY_ALL_ACCESS);

        RegEntry trigReg(m_bstrTriggerID, NULL, 0, RegEntry::MustExist, hTriggersData);
        CRegHandle hTrigger = CmOpenKey(trigReg, KEY_ALL_ACCESS);

        RegEntry attachedRuleReg(REGKEY_TRIGGER_ATTACHED_RULES, NULL, 0, RegEntry::MustExist, hTrigger);

        CmDeleteKey(attachedRuleReg);
        CmDeleteKey(trigReg);

		TrTRACE(GENERAL, "Delete trigger. Delete attached rule registry for trigger: %ls ", (LPCWSTR)m_bstrTriggerID);

        return true;
    }
    catch (const exception&)
    {
		TrERROR(GENERAL, "Failed to delete trigger:%ls from registry.", (LPCWSTR)m_bstrTriggerID);
        return false;
	}
}

//*****************************************************************************
//
// Method      : Retrieve
//
// Description : This method retrieve the specified trigger ID from the 
//               registry.
//
//*****************************************************************************
HRESULT CRuntimeTriggerInfo::Retrieve(HKEY hRegistry,_bstr_t bstrTriggerID)
{
    //
	// Assert that we have valid parameters and member vars
    //
	ASSERT(hRegistry != NULL);
	ASSERT(bstrTriggerID.length() > 0);

    CRegHandle hTrigKey = GetTriggerKeyHandle(hRegistry, bstrTriggerID);
    if (hTrigKey == NULL)
    {
		TrERROR(GENERAL, "Failed to retrieve trigger %ls. Registery key isn't exist.", (LPCWSTR)m_bstrTriggerID);
        return MQTRIG_TRIGGER_NOT_FOUND;
    }

    try
    {
        //
        // Retrieve trigger name
        //
        AP<TCHAR> triggerName = NULL;
        RegEntry trigNameReg(NULL, REGISTRY_TRIGGER_VALUE_NAME, 0, RegEntry::MustExist, hTrigKey);
        CmQueryValue(trigNameReg, &triggerName);
        
        //
        // Retrieve trigger Queue name
        //
        AP<TCHAR> queueName = NULL;
        RegEntry trigQueueReg(NULL, REGISTRY_TRIGGER_VALUE_QUEUE_NAME, 0, RegEntry::MustExist, hTrigKey);
        CmQueryValue(trigQueueReg, &queueName);
        
		//
        // Retrieve trigger enabled attribute
        //
        DWORD trigEnabled = 0;
        RegEntry trigEnabledReg(NULL, REGISTRY_TRIGGER_VALUE_ENABLED, 0, RegEntry::MustExist, hTrigKey);
        CmQueryValue(trigEnabledReg, &trigEnabled);
            
        //
        // Retrieve trigger serialize attribute
        //
        DWORD trigSerialize = 0;
        RegEntry trigSerializeReg(NULL, REGISTRY_TRIGGER_VALUE_SERIALIZED, 0, RegEntry::MustExist, hTrigKey);
        CmQueryValue(trigSerializeReg, &trigSerialize);
    
        //
        // Retrieve message processing type attribute
        //
        DWORD trigMsgProcType = 0;
        RegEntry trigMsgProcTypeReg(NULL, REGISTRY_TRIGGER_MSG_PROCESSING_TYPE, 0, RegEntry::MustExist, hTrigKey);
        CmQueryValue(trigMsgProcTypeReg, &trigMsgProcType);
	    
		if ( trigMsgProcType > static_cast<DWORD>(RECEIVE_MESSAGE_XACT) )
		{
			TrTRACE(GENERAL, "Illegal MsgProcessingType value in registry for trigger: %ls", static_cast<LPCWSTR>(m_bstrTriggerID));
			return MQTRIG_ERROR;
		}

		//
        // Set trigger attributes
        //
	    m_bstrTriggerID = bstrTriggerID;
	    m_bstrTriggerName = triggerName;
	    
	    m_bstrQueueName = queueName;
	    m_SystemQueue = IsSystemQueue(queueName.get());

	    m_bEnabled = (trigEnabled != 0);
	    m_bSerialized = (trigSerialize != 0);

		m_msgProcType = static_cast<MsgProcessingType>(trigMsgProcType);
        //
	    // Attempt to build the rules list. 
        //
		BuildRulesList(hRegistry, bstrTriggerID);
    }
    catch(const exception&)
    {
		TrERROR(GENERAL, "Failed to retrieve triger: %ls properties", (LPCWSTR)bstrTriggerID);
        return MQTRIG_ERROR;
    }

    if (!IsValid())
	{
		TrERROR(GENERAL, "Registry contains invalid property for trigger %ls", (LPCWSTR)bstrTriggerID);
        return MQTRIG_ERROR;
	}

    return S_OK;
}

//*****************************************************************************
//
// Method      : Attach
//
// Description : Attaches a rule definition to this trigger definition.
//
//*****************************************************************************
bool 
CRuntimeTriggerInfo::Attach(
    HKEY hRegistry, 
    _bstr_t bstrRuleID,
    ULONG ulPriority
    )
{ 
    //
	// assert that the supplied priority makes sense
    //
	ASSERT(ulPriority <= m_lstRules.size());
    
    try
    {
        //
	    // Attempt to create instantiate a rule object with this rule id.
	    //
        P<CRuntimeRuleInfo> pRule = new CRuntimeRuleInfo( m_wzRegPath );

        bool fSucc = pRule->Retrieve(hRegistry, bstrRuleID);
	    if (!fSucc)
	    {
			TrERROR(GENERAL, "Failed to attached rule %ls to trigger %ls. Rule doesn't exist.",(LPCWSTR) bstrRuleID, (LPCWSTR)m_bstrTriggerID);
            return false;
	    }

        //
	    // Get a reference to the 'ulPriority' position in the list. 
        //
        RUNTIME_RULEINFO_LIST::iterator it = m_lstRules.begin();

        for (DWORD index =0; index < ulPriority; ++index)
        {
            ASSERT(it != m_lstRules.end());
            ++it;
        }

        //
        // insert the rule into the in-memory list at the correct location.
        //
        m_lstRules.insert(it,pRule);
        pRule.detach();

        //
	    // Delete the existing attached-rules data for this trigger	and write new ones
        //
	    FlushAttachedRulesToRegistry(hRegistry);			

        return true;
    }
    catch(const exception&)
    {
    	TrERROR(GENERAL, "Failed to attached rule %ls to trigger %ls.", (LPCWSTR)bstrRuleID, (LPCWSTR)m_bstrTriggerID);
        return false;
    }
}

//*****************************************************************************
//
// Method      : Detach
//
// Description : Detaches a rule from this trigger definiiton.
//
//*****************************************************************************
bool 
CRuntimeTriggerInfo::Detach(
    HKEY hRegistry, 
    _bstr_t bstrRuleID
    )
{
    //
	// Assert that we have valid parameters
    //
	ASSERT(IsValid());
	ASSERT(hRegistry != NULL);
	ASSERT(CRuntimeRuleInfo::IsValidRuleID(bstrRuleID));

	for(RUNTIME_RULEINFO_LIST::iterator it = m_lstRules.begin(); it != m_lstRules.end(); ++it)
	{
		// Get a reference to the current rule object 
		CRuntimeRuleInfo* pRule = *it;

		// We should never have nulls in the map
		ASSERT(pRule != NULL);

		if(pRule->m_bstrRuleID == bstrRuleID)
		{
		    // We should only ever have valid rules in the map
		    ASSERT(pRule->IsValid());
		    
			m_lstRules.erase(it);
			delete pRule;

            try
            {
                FlushAttachedRulesToRegistry(hRegistry);
                return true;
            }
            catch(const exception&)
            {
		        TrERROR(GENERAL, "Failed to deatch rule: %ls from trigger: %ls", (LPCWSTR)bstrRuleID, (LPCWSTR)m_bstrTriggerID);
                return false;
            }
        }
	}

    //
    // rule ID isn't attached to the trigger 
    //
    return false;
}

//*****************************************************************************
//
// Method      : FlushValuesToRegistry
//
// Description : This method flushes the member variable values to the 
//               supplied registry key.
//
//*****************************************************************************
void 
CRuntimeTriggerInfo::FlushValuesToRegistry(
    const HKEY& hTriggerKey
    )
{
    //
	// Set the NAME value for this trigger
    //
    RegEntry trigNameReg(NULL, REGISTRY_TRIGGER_VALUE_NAME, 0, RegEntry::MustExist, hTriggerKey);
    CmSetValue(trigNameReg, m_bstrTriggerName);

    //
	// Set the Queue path name value for this trigger
    //
    RegEntry trigQueueReg(NULL, REGISTRY_TRIGGER_VALUE_QUEUE_NAME, 0, RegEntry::MustExist, hTriggerKey);
    CmSetValue(trigQueueReg, m_bstrQueueName);

    //
	// Set the Enabled attribute for this trigger
    //
    RegEntry trigEnabledReg(NULL, REGISTRY_TRIGGER_VALUE_ENABLED, 0, RegEntry::MustExist, hTriggerKey);
    CmSetValue(trigEnabledReg, m_bEnabled);

    //
	// Set the Serialize attribute for this trigger
    //
    RegEntry trigSerializeReg(NULL, REGISTRY_TRIGGER_VALUE_SERIALIZED, 0, RegEntry::MustExist, hTriggerKey);
    CmSetValue(trigSerializeReg, m_bSerialized);

    //
	// Set the message processing type attribute for this trigger
    //
    RegEntry trigMsgProcTypeReg(NULL, REGISTRY_TRIGGER_MSG_PROCESSING_TYPE, 0, RegEntry::MustExist, hTriggerKey);
    CmSetValue(trigMsgProcTypeReg, m_msgProcType);

}


//*****************************************************************************
//
// Method      : IsValid*
//
// Description : The following static methods are used to validate 
//               the validity of parameters and member vars used by 
//               the CRuntimeTriggerInfo class.
//
//*****************************************************************************
bool CRuntimeTriggerInfo::IsValidTriggerID(_bstr_t bstrTriggerID)
{
	return((bstrTriggerID.length() > 0) ? true:false);
}
bool CRuntimeTriggerInfo::IsValidTriggerName(_bstr_t bstrTriggerName)
{
	return((bstrTriggerName.length() > 0) ? true:false);
}
bool CRuntimeTriggerInfo::IsValidTriggerQueueName(_bstr_t bstrTriggerQueueName)
{
	return((bstrTriggerQueueName.length() > 0) ? true:false);
}


void 
CRuntimeTriggerInfo::FlushAttachedRulesToRegistry(
    const HKEY& hRegistry
    )
{
    //
    // Open trigger key in registry
    //
    CRegHandle hTrigKey = GetTriggerKeyHandle(hRegistry, m_bstrTriggerID);
    if (hTrigKey == NULL)
    {
		TrERROR(GENERAL, "Failed to load trigger information. Trigger %ls isn't exist.", (LPCWSTR)m_bstrTriggerID);
        throw exception();
    }

    //
    // Delete AttachedRules subkey
    //
    RegEntry  AttachedRuleReg(REGKEY_TRIGGER_ATTACHED_RULES, NULL, 0, RegEntry::MustExist, hTrigKey);
    CmDeleteKey(AttachedRuleReg);

    //
	// Write out the new attached rules data for this trigger. 
    //
    CRegHandle hAttachedRule = CmCreateKey(AttachedRuleReg, KEY_ALL_ACCESS);

	DWORD ruleIndex = 0;
	for(RUNTIME_RULEINFO_LIST::iterator it = m_lstRules.begin(); it != m_lstRules.end(); ++it)
	{
		// Get a reference to the current rule object 
	    CRuntimeRuleInfo* pRule = *it;

		// We should never have nulls in the map
		ASSERT(pRule != NULL);

		// We should only ever have valid rules in the map
		ASSERT(pRule->IsValid());

		// Construct the value name
		_bstr_t bstrValueName;
		FormatBSTR(&bstrValueName,_T("%s%d"),ATTACH_RULE_PREFIX, ruleIndex);
		
		// Write this value out to the registry.
        RegEntry  ruleValue(NULL, bstrValueName, 0, RegEntry::MustExist, hAttachedRule);
        CmSetValue(ruleValue, pRule->m_bstrRuleID);

		// Increment the rule counter used to construct the key-value name.
		++ruleIndex;
	}
}


bool CRuntimeTriggerInfo::DetachAllRules(HKEY hRegistry)
{
	// Assert that we have valid parameters
	ASSERT(hRegistry != NULL);
	
	// Release any resources currently held by the rules list.
	ClearRulesList();

    try
    {
	    FlushAttachedRulesToRegistry(hRegistry);						
        return true;
    }
    catch(const exception&)
    {
		TrERROR(GENERAL, "Failed to detachhed all rule for trigger %ls", (LPCWSTR)m_bstrTriggerID);

        return false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\src\trigger\trigutil\strparse.cpp ===
//*****************************************************************************
//
// Class Name  : CStringTokens
//
// Author      : James Simpson (Microsoft Consulting Services)
// 
// Description : Implements a limited feature string parser. Allows the user of 
//               this class to parse a string and access the resulting tokens 
//               based on an index value.
// 
// When     | Who       | Change Description
// ------------------------------------------------------------------
// 12/20/98 | jsimpson  | Initial Release
//
//*****************************************************************************

#include "stdafx.h"
#include "strparse.hpp"

#include "strparse.tmh"

using namespace std;

//*****************************************************************************
//
// Method      : Constructor
//
// Description : Creates an empty instance.
//
//*****************************************************************************
CStringTokens::CStringTokens()
{
}

//*****************************************************************************
//
// Method      : Destructor
//
// Description : Destroys the string tokens object - free all the 
//               allocated strings in the token list. 
//
//*****************************************************************************
CStringTokens::~CStringTokens()
{
	m_lstTokens.erase(m_lstTokens.begin(), m_lstTokens.end());
}

//*****************************************************************************
//
// Method      : Parse
//
// Description : Parse the supplied string into tokens. It uses the supplied 
//               delimiter string to determine where tokens start and end within
//               the supplied source string. The tokens are stored in a member
//               variable list of tokens for subsequent access.
//
//*****************************************************************************
void 
CStringTokens::Parse(
	const _bstr_t& bstrString, 
	WCHAR delimiter
	)
{
	//
	// remove previous data
	//
	m_lstTokens.erase(m_lstTokens.begin(), m_lstTokens.end());

	for(LPCWSTR pStart = static_cast<LPCWSTR>(bstrString); pStart != NULL;)
	{
		wstring token;
		LPCWSTR p = pStart;
		LPCWSTR pEnd;

		for(;;)
		{
			pEnd = wcschr(p, delimiter);

			if (pEnd == NULL)
			{
				DWORD len = wcslen(pStart);
				token.append(pStart, len);
				break;
			}

			//
			// Check that this is a valid delimeter
			// 
			if((p != pEnd) && (*(pEnd - 1) == L'\\'))
			{
				DWORD len = numeric_cast<DWORD>(pEnd - pStart - 1);
				token.append(pStart, len);
				token.append(pEnd, 1);

				p = pStart = pEnd + 1;
				continue;
			}
		
			//
			// Test, we are not in exiting a quoted item
			//
			DWORD NoOfQuote = 0;
			LPCWSTR pQuote;
			for(pQuote = wcschr(pStart, L'\"');	 ((pQuote != NULL) && (pQuote < pEnd)); pQuote = wcschr(pQuote, L'\"') )
			{	
				++NoOfQuote;
				++pQuote;
			}

			if ((NoOfQuote % 2) == 1)
			{
				p = wcschr(pEnd + 1, L'\"');
				if (p == NULL)
					throw exception();
				continue;
			}

			//
			// copy the token and insert it to token list 
			// 
			DWORD len = numeric_cast<DWORD>(pEnd - pStart);
			token.append(pStart, len);

			break;
		}

		
		if (token.length() > 0)
		{
			m_lstTokens.push_back(token);
		}

		pStart = (pEnd == NULL)	? NULL : pEnd + 1;
	}
}

//*****************************************************************************
//
// Method      : GetToken 
//
// Description : Returns the token at the specific index.
//
//*****************************************************************************
void 
CStringTokens::GetToken(
	DWORD tokenIndex,
	_bstr_t& strToken
	)
{
	DWORD index = 0;

	if (index > GetNumTokens())
		throw exception();

	for (TOKEN_LIST::iterator it = m_lstTokens.begin();	 it != m_lstTokens.end(); ++it, ++index)
	{
		if (index == tokenIndex)
		{
			strToken = it->c_str();
			return;
		}
	}
}

//*****************************************************************************
//
// Method      : GetNumTokens 
//
// Description : Returns the current number of tokens in the list
//
//*****************************************************************************
DWORD CStringTokens::GetNumTokens()
{
	return numeric_cast<DWORD>(m_lstTokens.size());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\tools\dblib\include\sqldb.h ===
#ifndef _INC_SQLDB
#define _INC_SQLDB

#ifdef __cplusplus
	extern "C" {
#endif

/*****************************************************************************
*                                                                            *
*       SQLDB.H - DB-Library header file for the Microsoft SQL Server.       *
*                                                                            *
*     Copyright (c) 1989 - 1995 by Microsoft Corp.  All rights reserved.     *
*                                                                            *
*****************************************************************************/

// Macros for setting the PLOGINREC
#define DBSETLHOST(a,b)    dbsetlname   ((a), (b), DBSETHOST)
#define DBSETLUSER(a,b)    dbsetlname   ((a), (b), DBSETUSER)
#define DBSETLPWD(a,b)     dbsetlname   ((a), (b), DBSETPWD)
#define DBSETLAPP(a,b)     dbsetlname   ((a), (b), DBSETAPP)
#define BCP_SETL(a,b)      bcp_setl     ((a), (b))
#define DBSETLNATLANG(a,b) dbsetlname   ((a), (b), DBSETLANG)
#define DBSETLPACKET(a,b)  dbsetlpacket ((a), (b))
#define DBSETLSECURE(a)    dbsetlname   ((a), 0,   DBSETSECURE)
#define DBSETLVERSION(a,b) dbsetlname   ((a), 0,  (b))
#define DBSETLTIME(a,b)		dbsetlname    ((a), (LPCSTR)(ULONG)(b), DBSETLOGINTIME)
#define DBSETLFALLBACK(a,b) dbsetlname   ((a), (b),   DBSETFALLBACK)

/*****************************************************************************
* Windows 3.x and Non-Windows 3.x differences.                               *
*****************************************************************************/

#ifdef DBMSWIN

extern void SQLAPI dbwinexit(void);

void SQLAPI dblocklib (void);
void SQLAPI dbunlocklib (void);

#define DBLOCKLIB()   dblocklib()
#define DBUNLOCKLIB() dbunlocklib()

#define DBERRHANDLE_PROC FARPROC
#define DBMSGHANDLE_PROC FARPROC

extern DBERRHANDLE_PROC dberrhandle (DBERRHANDLE_PROC);
extern DBMSGHANDLE_PROC dbmsghandle (DBMSGHANDLE_PROC);

#else

#define dbwinexit()

#define DBLOCKLIB()
#define DBUNLOCKLIB()

typedef INT (SQLAPI *DBERRHANDLE_PROC)(PDBPROCESS, INT, INT, INT, LPCSTR, LPCSTR);
typedef INT (SQLAPI *DBMSGHANDLE_PROC)(PDBPROCESS, DBINT, INT, INT, LPCSTR, LPCSTR, LPCSTR, DBUSMALLINT);

extern DBERRHANDLE_PROC SQLAPI dberrhandle(DBERRHANDLE_PROC);
extern DBMSGHANDLE_PROC SQLAPI dbmsghandle(DBMSGHANDLE_PROC);

extern DBERRHANDLE_PROC SQLAPI dbprocerrhandle(PDBHANDLE, DBERRHANDLE_PROC);
extern DBMSGHANDLE_PROC SQLAPI dbprocmsghandle(PDBHANDLE, DBMSGHANDLE_PROC);


#endif


/*****************************************************************************
* Function Prototypes                                                        *
*****************************************************************************/

// Functions macros
#define DBCMDROW(a)      dbcmdrow(a)
#define DBCOUNT(a)       dbcount (a)
#define DBCURCMD(a)      dbcurcmd(a)
#define DBCURROW(a)      dbcurrow(a)
#define DBDEAD(a)        dbdead(a)
#define DBFIRSTROW(a)    dbfirstrow(a)
#define DBGETTIME()      dbgettime()
#define DBISAVAIL(a)     dbisavail(a)
#define DBLASTROW(a)     dblastrow(a)
#define DBMORECMDS(a)    dbmorecmds(a)
#define DBNUMORDERS(a)   dbnumorders(a)
#define dbrbuf(a)        ((DBINT)dbdataready(a))
#define DBRBUF(a)        ((DBINT)dbdataready(a))
#define DBROWS(a)        dbrows (a)
#define DBROWTYPE(a)     dbrowtype (a)

// Two-phase commit functions
extern RETCODE      SQLAPI abort_xact (PDBPROCESS, DBINT);
extern void         SQLAPI build_xact_string (LPCSTR, LPCSTR, DBINT, LPSTR);
extern void         SQLAPI close_commit (PDBPROCESS);
extern RETCODE      SQLAPI commit_xact (PDBPROCESS, DBINT);
extern PDBPROCESS   SQLAPI open_commit (PLOGINREC, LPCSTR);
extern RETCODE      SQLAPI remove_xact (PDBPROCESS, DBINT, INT);
extern RETCODE      SQLAPI scan_xact (PDBPROCESS, DBINT);
extern DBINT        SQLAPI start_xact (PDBPROCESS, LPCSTR, LPCSTR, INT);
extern INT          SQLAPI stat_xact (PDBPROCESS, DBINT);

// BCP functions
extern DBINT        SQLAPI bcp_batch (PDBPROCESS);
extern RETCODE      SQLAPI bcp_bind (PDBPROCESS, LPCBYTE, INT, DBINT, LPCBYTE, INT, INT, INT);
extern RETCODE      SQLAPI bcp_colfmt (PDBPROCESS, INT, BYTE, INT, DBINT, LPCBYTE, INT, INT);
extern RETCODE      SQLAPI bcp_collen (PDBPROCESS, DBINT, INT);
extern RETCODE      SQLAPI bcp_colptr (PDBPROCESS, LPCBYTE, INT);
extern RETCODE      SQLAPI bcp_columns (PDBPROCESS, INT);
extern RETCODE      SQLAPI bcp_control (PDBPROCESS, INT, DBINT);
extern DBINT        SQLAPI bcp_done (PDBPROCESS);
extern RETCODE      SQLAPI bcp_exec (PDBPROCESS, LPDBINT);
extern RETCODE      SQLAPI bcp_init (PDBPROCESS, LPCSTR, LPCSTR, LPCSTR, INT);
extern RETCODE      SQLAPI bcp_moretext (PDBPROCESS, DBINT, LPCBYTE);
extern RETCODE      SQLAPI bcp_readfmt (PDBPROCESS, LPCSTR);
extern RETCODE      SQLAPI bcp_sendrow (PDBPROCESS);
extern RETCODE      SQLAPI bcp_setl (PLOGINREC, BOOL);
extern RETCODE      SQLAPI bcp_writefmt (PDBPROCESS, LPCSTR);

// Standard DB-Library functions
extern LPCBYTE      SQLAPI dbadata (PDBPROCESS, INT, INT);
extern DBINT        SQLAPI dbadlen (PDBPROCESS, INT, INT);
extern RETCODE      SQLAPI dbaltbind (PDBPROCESS, INT, INT, INT, DBINT, LPCBYTE);
extern INT          SQLAPI dbaltcolid (PDBPROCESS, INT, INT);
extern DBINT        SQLAPI dbaltlen (PDBPROCESS, INT, INT);
extern INT          SQLAPI dbaltop (PDBPROCESS, INT, INT);
extern INT          SQLAPI dbalttype (PDBPROCESS, INT, INT);
extern DBINT        SQLAPI dbaltutype (PDBPROCESS, INT, INT);
extern RETCODE      SQLAPI dbanullbind (PDBPROCESS, INT, INT, LPCDBINT);
extern RETCODE      SQLAPI dbbind (PDBPROCESS, INT, INT, DBINT, LPBYTE);
extern LPCBYTE      SQLAPI dbbylist (PDBPROCESS, INT, LPINT);
extern RETCODE      SQLAPI dbcancel (PDBPROCESS);
extern RETCODE      SQLAPI dbcanquery (PDBPROCESS);
extern LPCSTR       SQLAPI dbchange (PDBPROCESS);
extern RETCODE      SQLAPI dbclose (PDBPROCESS);
extern void         SQLAPI dbclrbuf (PDBPROCESS, DBINT);
extern RETCODE      SQLAPI dbclropt (PDBPROCESS, INT, LPCSTR);
extern RETCODE      SQLAPI dbcmd (PDBPROCESS, LPCSTR);
extern RETCODE      SQLAPI dbcmdrow (PDBPROCESS);
extern BOOL         SQLAPI dbcolbrowse (PDBPROCESS, INT);
extern RETCODE      SQLAPI dbcolinfo (PDBHANDLE, INT, INT, INT, LPDBCOL);
extern DBINT        SQLAPI dbcollen (PDBPROCESS, INT);
extern LPCSTR       SQLAPI dbcolname (PDBPROCESS, INT);
extern LPCSTR       SQLAPI dbcolsource (PDBPROCESS, INT);
extern INT          SQLAPI dbcoltype (PDBPROCESS, INT);
extern DBINT        SQLAPI dbcolutype (PDBPROCESS, INT);
extern INT          SQLAPI dbconvert (PDBPROCESS, INT, LPCBYTE, DBINT, INT, LPBYTE, DBINT);
extern DBINT        SQLAPI dbcount (PDBPROCESS);
extern INT          SQLAPI dbcurcmd (PDBPROCESS);
extern DBINT        SQLAPI dbcurrow (PDBPROCESS);
extern RETCODE      SQLAPI dbcursor (PDBCURSOR, INT, INT, LPCSTR, LPCSTR);
extern RETCODE      SQLAPI dbcursorbind (PDBCURSOR, INT, INT, DBINT, LPDBINT, LPBYTE);
extern RETCODE      SQLAPI dbcursorclose (PDBHANDLE);
extern RETCODE      SQLAPI dbcursorcolinfo (PDBCURSOR, INT, LPSTR, LPINT, LPDBINT, LPINT);
extern RETCODE      SQLAPI dbcursorfetch (PDBCURSOR,  INT, INT);
extern RETCODE      SQLAPI dbcursorfetchex (PDBCURSOR, INT, DBINT, DBINT, DBINT);
extern RETCODE      SQLAPI dbcursorinfo (PDBCURSOR, LPINT, LPDBINT);
extern RETCODE      SQLAPI dbcursorinfoex (PDBCURSOR, LPDBCURSORINFO);
extern PDBCURSOR    SQLAPI dbcursoropen (PDBPROCESS, LPCSTR, INT, INT,UINT, LPDBINT);
extern LPCBYTE      SQLAPI dbdata (PDBPROCESS, INT);
extern BOOL         SQLAPI dbdataready (PDBPROCESS);
extern RETCODE      SQLAPI dbdatecrack (PDBPROCESS, LPDBDATEREC, LPCDBDATETIME);
extern DBINT        SQLAPI dbdatlen (PDBPROCESS, INT);
extern BOOL         SQLAPI dbdead (PDBPROCESS);
extern void         SQLAPI dbexit (void);
extern RETCODE 	    SQLAPI dbenlisttrans(PDBPROCESS, LPVOID);
extern RETCODE	    SQLAPI dbenlistxatrans(PDBPROCESS, BOOL);
extern RETCODE	    SQLAPI dbfcmd (PDBPROCESS, LPCSTR, ...);
extern DBINT        SQLAPI dbfirstrow (PDBPROCESS);
extern void         SQLAPI dbfreebuf (PDBPROCESS);
extern void         SQLAPI dbfreelogin (PLOGINREC);
extern void         SQLAPI dbfreequal (LPCSTR);
extern LPSTR        SQLAPI dbgetchar (PDBPROCESS, INT);
extern SHORT        SQLAPI dbgetmaxprocs (void);
extern INT          SQLAPI dbgetoff (PDBPROCESS, DBUSMALLINT, INT);
extern UINT         SQLAPI dbgetpacket (PDBPROCESS);
extern STATUS       SQLAPI dbgetrow (PDBPROCESS, DBINT);
extern INT          SQLAPI dbgettime (void);
extern LPVOID       SQLAPI dbgetuserdata (PDBPROCESS);
extern BOOL         SQLAPI dbhasretstat (PDBPROCESS);
extern LPCSTR       SQLAPI dbinit (void);
extern BOOL         SQLAPI dbisavail (PDBPROCESS);
extern BOOL         SQLAPI dbiscount (PDBPROCESS);
extern BOOL         SQLAPI dbisopt (PDBPROCESS, INT, LPCSTR);
extern DBINT        SQLAPI dblastrow (PDBPROCESS);
extern PLOGINREC    SQLAPI dblogin (void);
extern RETCODE      SQLAPI dbmorecmds (PDBPROCESS);
extern RETCODE      SQLAPI dbmoretext (PDBPROCESS, DBINT, LPCBYTE);
extern LPCSTR       SQLAPI dbname (PDBPROCESS);
extern STATUS       SQLAPI dbnextrow (PDBPROCESS);
extern RETCODE      SQLAPI dbnullbind (PDBPROCESS, INT, LPCDBINT);
extern INT          SQLAPI dbnumalts (PDBPROCESS, INT);
extern INT          SQLAPI dbnumcols (PDBPROCESS);
extern INT          SQLAPI dbnumcompute (PDBPROCESS);
extern INT          SQLAPI dbnumorders (PDBPROCESS);
extern INT          SQLAPI dbnumrets (PDBPROCESS);
extern PDBPROCESS   SQLAPI dbopen (PLOGINREC, LPCSTR);
extern INT          SQLAPI dbordercol (PDBPROCESS, INT);
extern RETCODE      SQLAPI dbprocinfo (PDBPROCESS, LPDBPROCINFO);
extern void         SQLAPI dbprhead (PDBPROCESS);
extern RETCODE      SQLAPI dbprrow (PDBPROCESS);
extern LPCSTR       SQLAPI dbprtype (INT);
extern LPCSTR       SQLAPI dbqual (PDBPROCESS, INT, LPCSTR);
extern DBINT        SQLAPI dbreadpage (PDBPROCESS, LPCSTR, DBINT, LPBYTE);
extern DBINT        SQLAPI dbreadtext (PDBPROCESS, LPVOID, DBINT);
extern RETCODE      SQLAPI dbresults (PDBPROCESS);
extern LPCBYTE      SQLAPI dbretdata (PDBPROCESS, INT);
extern DBINT        SQLAPI dbretlen (PDBPROCESS, INT);
extern LPCSTR       SQLAPI dbretname (PDBPROCESS, INT);
extern DBINT        SQLAPI dbretstatus (PDBPROCESS);
extern INT          SQLAPI dbrettype (PDBPROCESS, INT);
extern RETCODE      SQLAPI dbrows (PDBPROCESS);
extern STATUS       SQLAPI dbrowtype (PDBPROCESS);
extern RETCODE      SQLAPI dbrpcinit (PDBPROCESS, LPCSTR, DBSMALLINT);
extern RETCODE      SQLAPI dbrpcparam (PDBPROCESS, LPCSTR, BYTE, INT, DBINT, DBINT, LPCBYTE);
extern RETCODE      SQLAPI dbrpcsend (PDBPROCESS);
extern RETCODE      SQLAPI dbrpcexec (PDBPROCESS);
extern void         SQLAPI dbrpwclr (PLOGINREC);
extern RETCODE      SQLAPI dbrpwset (PLOGINREC, LPCSTR, LPCSTR, INT);
extern INT          SQLAPI dbserverenum (USHORT, LPSTR, USHORT, LPUSHORT);
extern void         SQLAPI dbsetavail (PDBPROCESS);
extern RETCODE      SQLAPI dbsetmaxprocs (SHORT);
extern RETCODE      SQLAPI dbsetlname (PLOGINREC, LPCSTR, INT);
extern RETCODE      SQLAPI dbsetlogintime (INT);
extern RETCODE      SQLAPI dbsetlpacket (PLOGINREC, USHORT);
extern RETCODE      SQLAPI dbsetnull (PDBPROCESS, INT, INT, LPCBYTE);
extern RETCODE      SQLAPI dbsetopt (PDBPROCESS, INT, LPCSTR);
extern RETCODE      SQLAPI dbsettime (INT);
extern void         SQLAPI dbsetuserdata (PDBPROCESS, LPVOID);
extern RETCODE      SQLAPI dbsqlexec (PDBPROCESS);
extern RETCODE      SQLAPI dbsqlok (PDBPROCESS);
extern RETCODE      SQLAPI dbsqlsend (PDBPROCESS);
extern RETCODE      SQLAPI dbstrcpy (PDBPROCESS, INT, INT, LPSTR);
extern INT          SQLAPI dbstrlen (PDBPROCESS);
extern BOOL         SQLAPI dbtabbrowse (PDBPROCESS, INT);
extern INT          SQLAPI dbtabcount (PDBPROCESS);
extern LPCSTR       SQLAPI dbtabname (PDBPROCESS, INT);
extern LPCSTR       SQLAPI dbtabsource (PDBPROCESS, INT, LPINT);
extern INT          SQLAPI dbtsnewlen (PDBPROCESS);
extern LPCDBBINARY  SQLAPI dbtsnewval (PDBPROCESS);
extern RETCODE      SQLAPI dbtsput (PDBPROCESS, LPCDBBINARY, INT, INT, LPCSTR);
extern LPCDBBINARY  SQLAPI dbtxptr (PDBPROCESS, INT);
extern LPCDBBINARY  SQLAPI dbtxtimestamp (PDBPROCESS, INT);
extern LPCDBBINARY  SQLAPI dbtxtsnewval (PDBPROCESS);
extern RETCODE      SQLAPI dbtxtsput (PDBPROCESS, LPCDBBINARY, INT);
extern RETCODE      SQLAPI dbuse (PDBPROCESS, LPCSTR);
extern BOOL         SQLAPI dbvarylen (PDBPROCESS, INT);
extern BOOL         SQLAPI dbwillconvert (INT, INT);
extern RETCODE      SQLAPI dbwritepage (PDBPROCESS, LPCSTR, DBINT, DBINT, LPBYTE);
extern RETCODE      SQLAPI dbwritetext (PDBPROCESS, LPCSTR, LPCDBBINARY, DBTINYINT, LPCDBBINARY, BOOL, DBINT, LPCBYTE);
extern RETCODE      SQLAPI dbupdatetext(PDBPROCESS, LPCSTR, LPCDBBINARY, LPCDBBINARY, INT, DBINT, DBINT, LPCSTR, DBINT, LPCDBBINARY);

#ifdef __cplusplus
}
#endif

#endif // _INC_SQLDB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3admin.cpp ===
// P3Admin.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f P3Adminps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "P3Admin.h"

#include "P3Admin_i.c"
#include "P3Config.h"
#include "P3Domains.h"
#include "P3Domain.h"
#include "P3Users.h"
#include "P3Service.h"
#include "P3DomainEnum.h"
#include "P3User.h"
#include "P3UserEnum.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_P3Config, CP3Config)
//OBJECT_ENTRY(CLSID_P3Domains, CP3Domains)
//OBJECT_ENTRY(CLSID_P3Domain, CP3Domain)
//OBJECT_ENTRY(CLSID_P3Users, CP3Users)
//OBJECT_ENTRY(CLSID_P3Service, CP3Service)
//OBJECT_ENTRY(CLSID_P3DomainEnum, CP3DomainEnum)
//OBJECT_ENTRY(CLSID_P3User, CP3User)
//OBJECT_ENTRY(CLSID_P3UserEnum, CP3UserEnum)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_P3ADMINLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3adminworker.cpp ===
// P3AdminWorker.cpp: implementation of the CP3AdminWorker class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "P3AdminWorker.h"
#include "P3Admin.h"

#include <mailbox.h>
#include <MetabaseUtil.h>
#include <POP3RegKeys.h>
#include <util.h>
#include <servutil.h>
#include <POP3Server.h>
#include <POP3Auth.h>
#include <AuthID.h>

#include <seo.h>
#include <smtpguid.h>
#include <Iads.h>
#include <Adshlp.h>
#include <smtpinet.h>
#include <inetinfo.h>
#include <windns.h>
#include <sddl.h>
#include <Aclapi.h>
#include <lm.h>

#define DOMAINMUTEX_NAME    L"Global\\P3AdminWorkerDomain-"
#define USERMUTEX_NAME      L"Global\\P3AdminWorkerUser-"
#define ERROR_NO_FILE_ATTR          0xffffffff




DWORD SetMailBoxDACL(LPWSTR wszPath,PSECURITY_DESCRIPTOR pSD, DWORD dwLevel)
{
    HANDLE hFind;
    DWORD dwLastErr;
    WIN32_FIND_DATA FileInfo;
    WCHAR wszMailFilter[POP3_MAX_PATH+6];
    WCHAR wszFullPathFileName[POP3_MAX_PATH];
    DWORD dwRt=ERROR_SUCCESS;
    if(NULL == wszPath || NULL == pSD)
    {
        return ERROR_INVALID_DATA;
    }
    //Now set everything in the directory
    wsprintf(wszMailFilter, 
             L"%s\\*.*",
             wszPath);
    hFind=FindFirstFile(wszMailFilter, 
                        &(FileInfo));
    
    if(INVALID_HANDLE_VALUE == hFind)
    {
        dwLastErr= GetLastError();
        if(ERROR_FILE_NOT_FOUND == dwLastErr ||
           ERROR_SUCCESS == dwLastErr)
        {
           return ERROR_SUCCESS;
        }
        else
        {
           return dwLastErr;
        }
    }
    
    BOOL bMoreFile=TRUE;
    while(bMoreFile)
    {
        if(wcscmp(FileInfo.cFileName, L".")!=0 &&
           wcscmp(FileInfo.cFileName, L"..")!=0)
        {
        
            wnsprintf(wszFullPathFileName,sizeof(wszFullPathFileName)/sizeof(WCHAR),L"%s\\%s", wszPath, FileInfo.cFileName);
            wszFullPathFileName[sizeof(wszFullPathFileName)/sizeof(WCHAR)-1]=0;
            if(!SetFileSecurity(wszFullPathFileName, DACL_SECURITY_INFORMATION, pSD))
            {
                dwRt=GetLastError();
            }


            if( (FileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
                (ERROR_SUCCESS ==dwRt) &&  (dwLevel > 0) )
            {
                //We need to go down the dir
                dwRt=SetMailBoxDACL(wszFullPathFileName, pSD, dwLevel-1);
            }
               
            if( ERROR_SUCCESS != dwRt)
            {
                break;
            }
        }
        bMoreFile=FindNextFile(hFind,&FileInfo);
    }

    FindClose(hFind);
    return dwRt;
}
    







//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CP3AdminWorker::CP3AdminWorker() :
    m_psMachineName(NULL), m_psMachineMailRoot(NULL), m_bImpersonation(false), m_isPOP3Installed(true)
{
    // TODO: dougb this is temporary code to force AD to cache for us, should be removed
    WCHAR   sBuffer[MAX_PATH*2];    
    HRESULT hr = GetSMTPDomainPath( sBuffer, L"", MAX_PATH*2 );
    if ( S_OK == hr )
    {
        sBuffer[ wcslen( sBuffer ) - 1 ] = 0; //Remove the last /
        hr = ADsGetObject( sBuffer, IID_IADs, reinterpret_cast<LPVOID*>( &m_spTemporaryFixIADs ));
    }

    DWORD dwVersion;
    
    if (( ERROR_SUCCESS == RegQueryVersion( dwVersion, NULL )) && ( 0 == dwVersion ))
        m_isPOP3Installed = false;
}

CP3AdminWorker::~CP3AdminWorker()
{
    if ( NULL != m_psMachineName )
        delete m_psMachineName;
    if ( NULL != m_psMachineMailRoot )
        delete m_psMachineMailRoot;
}

//////////////////////////////////////////////////////////////////////
// Implementation, public
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// AddDomain, public
//
// Purpose: 
//    Set the Meta base options required to add a new Local domain to the SMTP service.
//    Add the domain to our Store.
//    This involves:
//         Create a new object of type IIsSmtpDomain
//         Setting the RouteAction Property to 16
//         Creating a directory in the mailroot.
//
// Arguments:
//    LPWSTR psDomainName : Domain name to add
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::AddDomain( LPWSTR psDomainName )
{
    if ( NULL == psDomainName )
        return E_INVALIDARG;

    HRESULT hr, hr2 = S_OK;

    // Valid Domain Name? || DNS_ERROR_NON_RFC_NAME == dnStatus
    DNS_STATUS dnStatus = DnsValidateName_W( psDomainName, DnsNameDomain );
    hr = ( ERROR_SUCCESS == dnStatus ) ? S_OK : HRESULT_FROM_WIN32( ERROR_INVALID_DOMAINNAME );
    // Also need to block domain names with a trailing .
    if ( S_OK == hr )
    {
        if ( L'.' == *(psDomainName + wcslen( psDomainName ) - 1) )
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DOMAINNAME ); 
    }
    // Do we need to add this Domain?
    // Validate the domain in SMTP
    if ( S_OK == hr ) 
        hr = ExistsSMTPDomain( psDomainName );
    if ( S_OK == hr ) 
        hr = HRESULT_FROM_WIN32( ERROR_DOMAIN_EXISTS );
    else if ( HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == hr )
        hr = S_OK;
    // Validate the domain in the Store
    if ( S_OK == hr ) 
        hr = ExistsStoreDomain( psDomainName );
    if ( S_OK == hr ) 
        hr2 = ERROR_FILE_EXISTS;
    else if ( HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == hr )
        hr = S_OK;
    if ( S_OK == hr )
    {
        hr = AddSMTPDomain( psDomainName );
        if ( S_OK == hr && ERROR_FILE_EXISTS != hr2 )
        {
            hr = AddStoreDomain( psDomainName );
            if ( S_OK != hr )
                RemoveSMTPDomain( psDomainName );
        }
    }

    return ( S_OK == hr ) ? hr2 : hr;
}

/////////////////////////////////////////////////////////////////////////////
// AddUser, public
//
// Purpose: 
//    Create a new user mailbox.
//    This involves:
//         Verify the domain exists.
//         Create the mailbox directory and lock file.
//
// Arguments:
//    LPWSTR psDomainName : Domain name to add to
//    LPWSTR psUserName : User name to add
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::AddUser( LPWSTR psDomainName, LPWSTR psUserName )
{
    // psDomainName - checked by ValidateDomain
    // psBuffer - checked by BuildEmailAddrW2A

    HRESULT hr = S_OK;
    CMailBox mailboxX;
    WCHAR   sEmailAddr[POP3_MAX_ADDRESS_LENGTH];
    bool    bLocked;

    // Validate the domain 
    if ( S_OK == hr )
        hr = ValidateDomain( psDomainName );
    // Validate the user
    if ( S_OK == hr )
    {
        if ( !isValidMailboxName( psUserName ))
            hr = HRESULT_FROM_WIN32( ERROR_BAD_USERNAME );
    }
    if ( S_OK == hr )
        bLocked = IsDomainLocked( psDomainName );
    if ( SUCCEEDED( hr ))
    {   // See if the mailbox already exists
        hr = BuildEmailAddr( psDomainName, psUserName, sEmailAddr, sizeof( sEmailAddr ) / sizeof (WCHAR) );
        if ( S_OK == hr )
            hr = MailboxSetRemote();
        if ( S_OK == hr )
        {   // Do we need to enforce uniqueness across domains?
            CComPtr<IAuthMethod> spIAuthMethod;
            BSTR    bstrAuthType = NULL;
            
            hr = GetCurrentAuthentication( &spIAuthMethod );
            if ( S_OK == hr )
                hr = spIAuthMethod->get_ID( &bstrAuthType );
            if ( S_OK == hr )
            {
                if ( 0 == _wcsicmp( bstrAuthType, SZ_AUTH_ID_LOCAL_SAM ) )
                {
                    hr = SearchDomainsForMailbox( psUserName, NULL );
                    if ( S_OK == hr )   // The Mailbox exists in at least one domain
                    {
                        if ( mailboxX.OpenMailBox( sEmailAddr ))
                        {
                            mailboxX.CloseMailBox();
                            hr = HRESULT_FROM_WIN32( ERROR_FILE_EXISTS );
                        }
                        else
                            hr = HRESULT_FROM_WIN32( ERROR_USER_EXISTS );
                    }
                    else if ( HRESULT_FROM_WIN32( ERROR_NO_SUCH_USER ) == hr )  // This is what we were hoping for
                        hr = S_OK;
                }
                SysFreeString( bstrAuthType );
            }
        }
        if ( S_OK == hr )
        {
            if ( mailboxX.OpenMailBox( sEmailAddr ))
            {
                mailboxX.CloseMailBox();
                hr = HRESULT_FROM_WIN32( ERROR_FILE_EXISTS );
            }
            else
            {
                LPWSTR  psMachineName = NULL;
                
                if ( !mailboxX.CreateMailBox( sEmailAddr ))
                    hr = E_FAIL;
                if ( S_OK == hr && bLocked )
                    LockUser( psDomainName, psUserName );   // Hate to fail because of problem here, therefore ignore return code
            }
        }
        MailboxResetRemote();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// ControlService, public
//
// Purpose: 
//    Ask the Service Control Manager to send a cotnrol code to the service.
//
// Arguments:
//    
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::ControlService( LPWSTR psService, DWORD dwControl )
{
    if ( NULL == psService )
        return E_INVALIDARG;
    
    if ( 0 == _wcsicmp( POP3_SERVICE_NAME, psService ) ||
         0 == _wcsicmp( SMTP_SERVICE_NAME_W, psService ) ||
         0 == _wcsicmp( IISADMIN_SERVICE_NAME, psService ) ||
         0 == _wcsicmp( W3_SERVICE_NAME, psService )
       )
        return _ControlService( psService, dwControl, m_psMachineName );
    else
        return E_INVALIDARG;
}

/////////////////////////////////////////////////////////////////////////////
// CreateQuotaSIDFile, public
//
// Purpose: 
//    Create the Quota file for the mailbox.
//    A permanent quota file is created which contains the SID of the user and is used
//    by the SMTP service to assign ownership of new mail files.
//
// Arguments:
//    LPWSTR psDomainName : domain of mailbox
//    LPWSTR psMailboxName : mailbox 
//    PSID *ppSIDOwner : Pointer to buffer to receive Owner SID (must be deleted by caller)
//    LPWSTR psMachineName : system name (remote computer) can be NULL
//    LPWSTR psUserName : user name
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::CreateQuotaSIDFile( LPWSTR psDomainName, LPWSTR psMailboxName, BSTR bstrAuthType, LPWSTR psMachineName, LPWSTR psUserName )
{
    // psDomainName - checked by BuildUserPath
    // psUserName - checked by BuildUserPath
    // bstrAuthType - checked by GetSID
    if ( NULL == psMachineName )
        psMachineName = m_psMachineName;

    HRESULT hr = S_OK;
    WCHAR   sQuotaFile[POP3_MAX_PATH];
    HANDLE  hQuotaFile;

    hr = BuildUserPath( psDomainName, psMailboxName, sQuotaFile, sizeof( sQuotaFile )/sizeof(WCHAR) );
    if ( S_OK == hr )
    {   
        if ( (sizeof( sQuotaFile )/sizeof(WCHAR)) > ( wcslen( sQuotaFile ) + wcslen( QUOTA_FILENAME_W ) + 1 ))
        {
            wcscat( sQuotaFile, L"\\" );
            wcscat( sQuotaFile, QUOTA_FILENAME_W );
            hQuotaFile = CreateFile( sQuotaFile, GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
            if ( INVALID_HANDLE_VALUE != hQuotaFile )
            {
                PSID    pSIDOwner = NULL;
                DWORD   dwOwnerSID, dwBytesWritten;
                
                hr = GetQuotaSID( bstrAuthType, psUserName, psMachineName, &pSIDOwner, &dwOwnerSID );
                if ( S_OK == hr )
                {
                    if ( !WriteFile( hQuotaFile, pSIDOwner, dwOwnerSID, &dwBytesWritten, NULL ))
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    delete [] pSIDOwner;
                }
                CloseHandle( hQuotaFile );
                if ( S_OK != hr )
                    DeleteFile( sQuotaFile );
            }
            else
                hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else
            hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetConfirmAddUser, public
//
// Purpose: 
//    Get the Confirm Add User registry key.
//
// Arguments:
//    BOOL *pbConfirm : current value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetConfirmAddUser( BOOL *pbConfirm )
{
    if ( NULL == pbConfirm )
        return E_INVALIDARG;
    
    DWORD dwValue;
    
    long lRC = RegQueryConfirmAddUser( dwValue, m_psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        *pbConfirm = (dwValue) ? TRUE : FALSE;
        return S_OK;
    }
    return HRESULT_FROM_WIN32( lRC );
}

/////////////////////////////////////////////////////////////////////////////
// GetAuthenticationMethods, public
//
// Purpose: 
//    Get an initialized IAuthMethods interface pointer
//
// Arguments:
//    IAuthMethods* *ppIAuthMethods: return interface pointer to initialized IAuthMethods
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetAuthenticationMethods( IAuthMethods* *ppIAuthMethods ) const
{
    if ( NULL == ppIAuthMethods )
        return E_INVALIDARG;

    HRESULT hr;
    
    hr = CoCreateInstance( __uuidof( AuthMethods ), NULL, CLSCTX_INPROC_SERVER, __uuidof( IAuthMethods ), reinterpret_cast<LPVOID*>( ppIAuthMethods ));
    if ( S_OK == hr )
    {   // If necessary set the machine name property
        if ( NULL != m_psMachineName )
        {
            _bstr_t _bstrMachineName = m_psMachineName;
            hr = (*ppIAuthMethods)->put_MachineName( _bstrMachineName );
        }
    }

    assert( S_OK == hr );
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetCurrentAuthentication, public
//
// Purpose: 
//    Get an initialized IAuthMethod interface pointer for the current active Authentication method
//
// Arguments:
//    IAuthMethod* *ppIAuthMethod: return interface pointer to initialized IAuthMethod
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetCurrentAuthentication( IAuthMethod* *ppIAuthMethod ) const
{
    if ( NULL == ppIAuthMethod )
        return E_INVALIDARG;
    
    HRESULT hr;
    CComPtr<IAuthMethods> spIAuthMethods;
    _variant_t _v;

    hr = GetAuthenticationMethods( &spIAuthMethods );
    if ( S_OK == hr )
        hr = spIAuthMethods->get_CurrentAuthMethod( &_v );
    if ( S_OK == hr )
        hr = spIAuthMethods->get_Item( _v, ppIAuthMethod );

    return hr;    
}

/////////////////////////////////////////////////////////////////////////////
// GetDomainCount, public
//
// Purpose: 
//    Get an Enumerator for the SMTP domains in the Metabase
//
// Arguments:
//    int *piCount : domain count
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetDomainCount( ULONG *piCount)
{
    if ( NULL == piCount )
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    HANDLE  hfSearch;
    WCHAR   sBuffer[POP3_MAX_PATH];
    WIN32_FIND_DATA stFindFileData;
    _bstr_t _bstr;

    *piCount = 0;
    hr = GetMailroot( sBuffer, sizeof( sBuffer )/sizeof(WCHAR));
    // Directory Search
    if ( S_OK == hr )
    {
        if ( ( wcslen( sBuffer ) + 2 ) < sizeof( sBuffer )/sizeof(WCHAR))
        {
            wcscat( sBuffer, L"\\*" );
            hfSearch = FindFirstFileEx( sBuffer, FindExInfoStandard, &stFindFileData, FindExSearchLimitToDirectories, NULL, 0 );
            if ( INVALID_HANDLE_VALUE == hfSearch )
                hr = HRESULT_FROM_WIN32(GetLastError());
            while ( S_OK == hr )
            {   // Count directories
                if ( FILE_ATTRIBUTE_DIRECTORY == ( FILE_ATTRIBUTE_DIRECTORY & stFindFileData.dwFileAttributes ))
                {
                    _bstr = stFindFileData.cFileName;
                    if ( S_OK == ExistsSMTPDomain( _bstr ))
                        (*piCount) += 1;
                }
                if ( !FindNextFile( hfSearch, &stFindFileData ))
                    hr = HRESULT_FROM_WIN32(GetLastError());
            }
            if ( HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr )
                hr = S_OK;
            if(INVALID_HANDLE_VALUE!=hfSearch)
            {
                FindClose(hfSearch);
                hfSearch=INVALID_HANDLE_VALUE;
            }
        }
        else
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER); 
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetNewEnum, public
//
// Purpose: 
//    Get an Enumerator for the SMTP domains in the Metabase
//
// Arguments:
//    IEnumVARIANT **pp : the returned Enumerator object
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetDomainEnum( IEnumVARIANT **pp )
{
    if ( NULL == pp )
        return E_POINTER;

    HRESULT hr = E_FAIL;
    WCHAR   sBuffer[POP3_MAX_PATH];
    _variant_t _v;
    CComPtr<IADsContainer> spIADsContainer;
    CComPtr<IUnknown> spIUnk;

    *pp = NULL;
    hr = GetSMTPDomainPath( sBuffer, NULL, sizeof( sBuffer )/sizeof( WCHAR ));
    if ( S_OK == hr )
        hr = ADsGetObject( sBuffer, IID_IADsContainer, reinterpret_cast<LPVOID*>( &spIADsContainer ));
    if SUCCEEDED( hr )
        hr = spIADsContainer->get__NewEnum( &spIUnk );
    if SUCCEEDED( hr )
        hr = spIUnk->QueryInterface( IID_IEnumVARIANT, reinterpret_cast<LPVOID*>( pp ));

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetDomainLock, public
//
// Purpose: 
//    Determine if the domain is locked.
//
// Arguments:
//    LPWSTR psDomainName : Domain name to check lock
//    BOOL *pisLocked : return value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetDomainLock( LPWSTR psDomainName, BOOL *pisLocked )
{
    // psDomainName - checked by CreateDomainMutex
    if ( NULL == pisLocked )
        return E_INVALIDARG;
    
    HRESULT hr = S_OK;
    HANDLE  hMutex = NULL;

    // Create a Mutex Name for this domain to ensure we are the only one accessing it.
    hr = CreateDomainMutex( psDomainName, &hMutex );
    // Validate
    if ( S_OK == hr )
    {   
        hr = ValidateDomain( psDomainName );
    }
    // Lock all the Mailboxes
    if ( S_OK == hr )
        *pisLocked = IsDomainLocked( psDomainName ) ? TRUE : FALSE;
    // Cleanup
    if ( NULL != hMutex )
        CloseHandle( hMutex );

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetQuotaSID, public
//
// Purpose: 
//    Create the Quota file for the mailbox.
//    A permanent quota file is created which contains the SID of the user and is used
//    by the SMTP service to assign ownership of new mail files.
//
// Arguments:
//    BSTR bstrAuthType : Authentication type <AuthID.h>
//    LPWSTR psUserName : user to lock
//    LPWSTR psMachineName : system name (remote computer) can be NULL
//    PSID *ppSIDOwner : Pointer to buffer to receive Owner SID (must be deleted by caller)
//    LPDWORD pdwOwnerSID : Pointer to variable thate receives the size of the Owner SID
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetQuotaSID( BSTR bstrAuthType, LPWSTR psUserName, LPWSTR psMachineName, PSID *ppSIDOwner, LPDWORD pdwOwnerSID )
{
    if ( NULL == bstrAuthType || NULL == psUserName || NULL == ppSIDOwner || NULL == pdwOwnerSID )
        return E_INVALIDARG;
    if ( 0 != _wcsicmp( SZ_AUTH_ID_LOCAL_SAM, bstrAuthType ) && 0 != _wcsicmp( SZ_AUTH_ID_DOMAIN_AD, bstrAuthType ) && 0 != _wcsicmp( SZ_AUTH_ID_MD5_HASH, bstrAuthType ))
        return E_INVALIDARG;
    // psMachineName == NULL is valid!
    
    HRESULT hr = S_OK;
    DWORD   dwDomSize = 0, dwSize = 0;
    BOOL    bRC;
    LPWSTR  psDomainName = NULL;
    LPWSTR  psAccountName = NULL;
    PSID    pSIDOwner = NULL;
    SID_NAME_USE sidNameUse;
    
    *pdwOwnerSID = 0;
    *ppSIDOwner = NULL;
    if ( 0 == _wcsicmp( SZ_AUTH_ID_DOMAIN_AD, bstrAuthType ))
    {   // UPN name or SAM name?
        if ( NULL == wcsrchr( psUserName, L'@' ))
        {   // SAM name
            NET_API_STATUS netStatus;
            LPWSTR psNameBuffer;
            NETSETUP_JOIN_STATUS enumJoinStatus;
            
            netStatus = NetGetJoinInformation( psMachineName, &psNameBuffer, &enumJoinStatus );
            if ( NERR_Success == netStatus )
            {
                psAccountName = new WCHAR[ wcslen( psUserName ) + wcslen( psNameBuffer ) + 3 ];
                if ( NULL != psAccountName )
                    wsprintf( psAccountName, L"%s\\%s", psNameBuffer, psUserName );
                else
                    hr = E_OUTOFMEMORY;
                NetApiBufferFree( psNameBuffer );
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
        {   // UPN name
            psAccountName = new WCHAR[ wcslen( psUserName ) + 1 ];
            if ( NULL != psAccountName )
                wcscpy( psAccountName, psUserName );
            else
                hr = E_OUTOFMEMORY;
        }
    }
    if ( 0 == _wcsicmp( SZ_AUTH_ID_LOCAL_SAM, bstrAuthType )) 
    {
        if ( NULL != psMachineName )
        {
            psAccountName = new WCHAR[ wcslen( psUserName ) + wcslen( psMachineName ) + 3 ];
            if ( NULL != psAccountName )
                wsprintf( psAccountName, L"%s\\%s", psMachineName, psUserName );
            else
                hr = E_OUTOFMEMORY;
        }
        else
        {
            WCHAR sMachineName[MAX_COMPUTERNAME_LENGTH+1];
            DWORD dwSize = sizeof(sMachineName)/sizeof(WCHAR);
            if ( !GetComputerName( sMachineName, &dwSize ))
                hr = HRESULT_FROM_WIN32( GetLastError());
            if ( S_OK == hr )
            {
                psAccountName = new WCHAR[ wcslen( psUserName ) + wcslen( sMachineName ) + 3 ];
                if ( NULL != psAccountName )
                    wsprintf( psAccountName, L"%s\\%s", sMachineName, psUserName );
                else
                    hr = E_OUTOFMEMORY;
            }
        }
    }
    if ( 0 == _wcsicmp( SZ_AUTH_ID_MD5_HASH, bstrAuthType )) 
        psAccountName = psUserName;

    if ( S_OK == hr )
    {
        bRC = LookupAccountNameW( psMachineName, psAccountName, NULL, pdwOwnerSID, NULL, &dwDomSize, &sidNameUse );
        if ( !bRC && ( ERROR_INSUFFICIENT_BUFFER == GetLastError()) && (0 < *pdwOwnerSID) && (0 < dwDomSize) )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            pSIDOwner = new BYTE[*pdwOwnerSID];
            if ( NULL != pSIDOwner )
            {
                psDomainName = new WCHAR[dwDomSize];
                if ( NULL != psDomainName )
                {
                    if ( LookupAccountNameW( psMachineName, psAccountName, pSIDOwner, pdwOwnerSID, psDomainName, &dwDomSize, &sidNameUse ))
                    {
                        *ppSIDOwner = pSIDOwner;
                        SetLastError( ERROR_SUCCESS );
                    }
                    delete [] psDomainName;
                }
                if ( ERROR_SUCCESS != GetLastError() )
                    delete [] pSIDOwner;
            }
        }
        if ( ERROR_SUCCESS != GetLastError()) hr = HRESULT_FROM_WIN32(GetLastError());
    }
    if ( NULL != psAccountName && 0 != _wcsicmp( SZ_AUTH_ID_MD5_HASH, bstrAuthType ))
        delete [] psAccountName;
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// EnablePOP3SVC, public
//
// Purpose: 
//    Make sure the POP3SVC is Running and startup set to Automatic.
//
// Arguments:
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::EnablePOP3SVC()
{
    HRESULT hr = _ChangeServiceStartType( POP3_SERVICE_NAME, SERVICE_AUTO_START );
    if ( S_OK == hr )
        hr = _StartService( POP3_SERVICE_NAME );

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetLoggingLevel, public
//
// Purpose: 
//    Get Logging Level registry key.
//
// Arguments:
//    long *plLoggingLevel : return value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetLoggingLevel( long *plLoggingLevel )
{
    if ( NULL == plLoggingLevel )
        return E_INVALIDARG;
    
    HRESULT hr = S_OK;
    DWORD   dwLogLevel;
    long    lRC;

    lRC = RegQueryLoggingLevel( dwLogLevel, m_psMachineName );
    if ( ERROR_SUCCESS == lRC )
        *plLoggingLevel = dwLogLevel;
    else
        hr = HRESULT_FROM_WIN32( lRC );

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetMachineName, public
//
// Purpose: 
//    Get the Machine Name that all operations should be performed on..
//
// Arguments:
//    LPWSTR psMachineName : buffer
//    DWORD dwSize : buffer size
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetMachineName( LPWSTR psMachineName, DWORD dwSize )
{
    if ( NULL == psMachineName )
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    
    if ( NULL == m_psMachineName )
        ZeroMemory( psMachineName, dwSize * sizeof( WCHAR ));
    else
    {
        if ( dwSize > wcslen( m_psMachineName ))
            wcscpy( psMachineName, m_psMachineName );
        else
            hr = TYPE_E_BUFFERTOOSMALL;
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetMailroot, public
//
// Purpose: 
//    Get Mailroot registry key.
//
// Arguments:
//    LPWSTR psMailRoot : buffer
//    DWORD dwSize : buffer size
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetMailroot( LPWSTR psMailRoot, DWORD dwSize, bool bUNC /*= true*/ )
{
    if ( NULL == psMailRoot )
        return E_INVALIDARG;

    long lRC;
    
    lRC = RegQueryMailRoot( psMailRoot, dwSize, m_psMachineName );
    if ( ERROR_SUCCESS == lRC && NULL != m_psMachineName && true == bUNC )
    {
        // Replace drive: with drive$
        if ( L':' == psMailRoot[1] )
        {
            psMailRoot[1] = L'$';
            if ( dwSize > (wcslen( psMailRoot ) + wcslen( m_psMachineName ) + 3) )
            {
                LPWSTR psBuffer = new WCHAR[wcslen(psMailRoot)+1];

                if ( NULL != psBuffer )
                {
                    wcscpy( psBuffer, psMailRoot );
                    wcscpy( psMailRoot, L"\\\\" );
                    wcscat( psMailRoot, m_psMachineName );
                    wcscat( psMailRoot, L"\\" );
                    wcscat( psMailRoot, psBuffer );
                    delete [] psBuffer;
                }
                else
                    lRC = ERROR_OUTOFMEMORY;
            }
            else
                lRC = ERROR_INSUFFICIENT_BUFFER;
        }
        //else  dougb commented out because this breaks UNC paths when administering remote machines!
        //    lRC = ERROR_INVALID_DATA;
    }
    if ( ERROR_SUCCESS == lRC )
        return S_OK;
    return HRESULT_FROM_WIN32( lRC );
}

HRESULT CP3AdminWorker::GetNextUser( HANDLE& hfSearch, LPCWSTR psDomainName, LPWSTR psBuffer, DWORD dwBufferSize )
{
    if ( NULL == psDomainName )
        return E_INVALIDARG;
    if ( NULL == psBuffer )
        return E_INVALIDARG;
    
    HRESULT hr = S_OK;
    bool    bFound = false;
    WCHAR   sBuffer[POP3_MAX_ADDRESS_LENGTH];
    _bstr_t _bstr;
    LPWSTR  ps;
    CMailBox mailboxX;
    WIN32_FIND_DATA stFindFileData;

    hr = MailboxSetRemote();
    if ( S_OK == hr )
    {
        if ( !FindNextFile( hfSearch, &stFindFileData ))
            hr = HRESULT_FROM_WIN32(GetLastError());
    }
    while ( S_OK == hr && !bFound )
    {   // Count directories
        if ( FILE_ATTRIBUTE_DIRECTORY == ( FILE_ATTRIBUTE_DIRECTORY & stFindFileData.dwFileAttributes ))
        {
            ps = mailboxX.GetMailboxFromStoreNameW( stFindFileData.cFileName );
            if ( NULL != ps )
            {
                _bstr = ps;
                _bstr += L"@";
                _bstr += psDomainName;
                if ( mailboxX.OpenMailBox( _bstr ))
                {
                    if ( dwBufferSize > wcslen( ps ))
                    {
                        wcscpy( psBuffer, ps );
                        bFound = true;
                        mailboxX.CloseMailBox();
                    }
                }
            }
        }
        if ( !bFound )
        {
            if ( !FindNextFile( hfSearch, &stFindFileData ))
                hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }
    MailboxResetRemote();
    if ( HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) == hr )
    {
        hr = S_FALSE;
        FindClose( hfSearch );
        hfSearch = INVALID_HANDLE_VALUE;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetPort, public
//
// Purpose: 
//    Get the Port registry key.
//
// Arguments:
//    long* plPort : current value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetPort( long *plPort )
{
    if ( NULL == plPort )
        return E_INVALIDARG;
    
    DWORD dwValue;
    
    long lRC = RegQueryPort( dwValue, m_psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        *plPort = dwValue;
        return S_OK;
    }
    return HRESULT_FROM_WIN32( lRC );
}

/////////////////////////////////////////////////////////////////////////////
// GetServiceStatus, public
//
// Purpose: 
//    Get the service status from the Service Control Manager.
//
// Arguments:
//    long* plStatus : the status
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetServiceStatus( LPWSTR psService, LPDWORD plStatus )
{
    if ( NULL == plStatus )
        return E_INVALIDARG;
    if ( NULL == psService )
        return E_INVALIDARG;
    
    HRESULT hr = E_FAIL;
    
    if ( 0 == _wcsicmp( POP3_SERVICE_NAME, psService ) ||
         0 == _wcsicmp( SMTP_SERVICE_NAME_W, psService ) ||
         0 == _wcsicmp( IISADMIN_SERVICE_NAME, psService ) ||
         0 == _wcsicmp( W3_SERVICE_NAME, psService )
       )
    {
        *plStatus = _GetServiceStatus( psService, m_psMachineName );
        if ( 0 != *plStatus )
            hr = S_OK;
    }
    else
        hr = E_INVALIDARG;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetSocketBacklog, public
//
// Purpose: 
//    Get the Socket Backlog registry key.
//
// Arguments:
//    long* plBacklog : current value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetSocketBacklog( long *plBacklog )
{
    if ( NULL == plBacklog )
        return E_INVALIDARG;
    
    DWORD dwValue;
    
    long lRC = RegQuerySocketBacklog( dwValue, m_psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        *plBacklog = dwValue;
        return S_OK;
    }
    return HRESULT_FROM_WIN32( lRC );
}

/////////////////////////////////////////////////////////////////////////////
// GetSocketMax, public
//
// Purpose: 
//    Get the Socket Max registry key.
//
// Arguments:
//    long* plMax : current value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetSocketMax( long *plMax )
{
    if ( NULL == plMax )
        return E_INVALIDARG;
    
    DWORD dwValue;
    
    long lRC = RegQuerySocketMax( dwValue, m_psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        *plMax = dwValue;
        return S_OK;
    }
    return HRESULT_FROM_WIN32( lRC );
}

/////////////////////////////////////////////////////////////////////////////
// GetSocketMin, public
//
// Purpose: 
//    Get the Socket Min registry key.
//
// Arguments:
//    long* plMax : current value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetSocketMin( long *plMin )
{
    if ( NULL == plMin )
        return E_INVALIDARG;
    
    DWORD dwValue;
    
    long lRC = RegQuerySocketMin( dwValue, m_psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        *plMin = dwValue;
        return S_OK;
    }
    return HRESULT_FROM_WIN32( lRC );
}

/////////////////////////////////////////////////////////////////////////////
// GetSocketThreshold, public
//
// Purpose: 
//    Get the Socket Threshold registry key.
//
// Arguments:
//    long* plThreshold : current value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetSocketThreshold( long *plThreshold )
{
    if ( NULL == plThreshold )
        return E_INVALIDARG;
    
    DWORD dwValue;
    
    long lRC = RegQuerySocketThreshold( dwValue, m_psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        *plThreshold = dwValue;
        return S_OK;
    }
    return HRESULT_FROM_WIN32( lRC );
}

/////////////////////////////////////////////////////////////////////////////
// GetSPARequired, public
//
// Purpose: 
//    Get the SPARequired registry key.
//
// Arguments:
//    BOOL *pbSPARequired : current value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetSPARequired( BOOL *pbSPARequired )
{
    if ( NULL == pbSPARequired )
        return E_INVALIDARG;
    
    DWORD dwValue;
    
    long lRC = RegQuerySPARequired( dwValue, m_psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        *pbSPARequired = (dwValue) ? TRUE : FALSE;
        return S_OK;
    }
    return HRESULT_FROM_WIN32( lRC );
}

/////////////////////////////////////////////////////////////////////////////
// GetThreadCountPerCPU, public
//
// Purpose: 
//    Get the ThreadCountPerCPU registry key.
//
// Arguments:
//    long* plCount : current value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetThreadCountPerCPU( long *plCount )
{
    if ( NULL == plCount )
        return E_INVALIDARG;
    
    DWORD dwValue;
    
    long lRC = RegQueryThreadCountPerCPU( dwValue, m_psMachineName );
    if ( ERROR_SUCCESS == lRC )
    {
        *plCount = dwValue;
        return S_OK;
    }
    return HRESULT_FROM_WIN32( lRC );
}

HRESULT CP3AdminWorker::GetUserCount( LPWSTR psDomainName, long *plCount )
{
    // psDomainName - checked by BuildDomainPath
    if ( NULL == plCount )
        return E_INVALIDARG;

    HRESULT hr;
    HANDLE  hfSearch;
    WCHAR   sBuffer[POP3_MAX_PATH];
    WIN32_FIND_DATA stFindFileData;
    LPWSTR  ps;
    _bstr_t _bstr;
    CMailBox mailboxX;

    *plCount = 0;
    hr = BuildDomainPath( psDomainName, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) );
    if (S_OK == hr)
    {
        if ((sizeof( sBuffer )/sizeof(WCHAR)) > (wcslen( sBuffer ) + wcslen(MAILBOX_PREFIX_W) + wcslen(MAILBOX_EXTENSION_W) + 2 ))
        {
            wcscat( sBuffer, L"\\" );
            wcscat( sBuffer, MAILBOX_PREFIX_W );
            wcscat( sBuffer, L"*" );
            wcscat( sBuffer, MAILBOX_EXTENSION_W );
        }
        else
            hr = E_UNEXPECTED;
    }
    if ( S_OK == hr )
        hr = MailboxSetRemote();
    if ( S_OK == hr )
    {
        // Directory Search
        hfSearch = FindFirstFileEx( sBuffer, FindExInfoStandard, &stFindFileData, FindExSearchLimitToDirectories, NULL, 0 );
        if ( INVALID_HANDLE_VALUE == hfSearch )
            hr = HRESULT_FROM_WIN32(GetLastError());
        while ( S_OK == hr )
        {   // Count directories
            if ( FILE_ATTRIBUTE_DIRECTORY == ( FILE_ATTRIBUTE_DIRECTORY & stFindFileData.dwFileAttributes ))
            {
                ps = mailboxX.GetMailboxFromStoreNameW( stFindFileData.cFileName );
                if ( NULL != ps )
                {
                    _bstr = ps;
                    _bstr += L"@";
                    _bstr += psDomainName;
                    if ( mailboxX.OpenMailBox( _bstr ))
                    {
                        mailboxX.CloseMailBox();
                        (*plCount) += 1;
                    }
                }
            }
            if ( !FindNextFile( hfSearch, &stFindFileData ))
                hr = HRESULT_FROM_WIN32(GetLastError());
        }
        if ( HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr )
            hr = S_OK;
        if(INVALID_HANDLE_VALUE!=hfSearch)
        {
            FindClose(hfSearch);
            hfSearch=INVALID_HANDLE_VALUE;
        }

    }
    MailboxResetRemote();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetUserLock, public
//
// Purpose: 
//    Determine if the user is locked.
//
// Arguments:
//    LPWSTR psDomainName : Domain  of user
//    LPWSTR psUserName : User to check lock
//    BOOL *pisLocked : return value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetUserLock( LPWSTR psDomainName, LPWSTR psUserName, BOOL *pisLocked )
{
    // psDomainName - checked by CreateUserMutex
    // psBuffer - checked by CreateUserMutex
    if ( NULL == pisLocked )
        return E_INVALIDARG;
    
    HRESULT hr = S_OK;
    HANDLE  hMutex = NULL;

    // Create a Mutex Name for this domain to ensure we are the only one accessing it.
    hr = CreateUserMutex( psDomainName, psUserName, &hMutex );
    if ( S_OK == hr )
        *pisLocked = isUserLocked( psDomainName, psUserName ) ? TRUE : FALSE;
    // Cleanup
    if ( NULL != hMutex )
        CloseHandle( hMutex );

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetUserMessageDiskUsage, public
//
// Purpose: 
//    Get the number of messages in the mailbox.
//
// Arguments:
//    LPWSTR psDomainName : Domain of user
//    LPWSTR psUserName : User to check 
//    long *plFactor : Base 10 multiplicand for plUsage
//    long *plUsage : Disk Usage
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetUserMessageDiskUsage( LPWSTR psDomainName, LPWSTR psUserName, long *plFactor, long *plUsage )
{
    // psDomainName - checked by BuildEmailAddrW2A
    // psBuffer - checked by BuildEmailAddrW2A
    if ( NULL == plFactor )
        return E_INVALIDARG;
    if ( NULL == plUsage )
        return E_INVALIDARG;

    HRESULT hr;
    CMailBox mailboxX;
    WCHAR    sEmailAddr[POP3_MAX_ADDRESS_LENGTH];
    DWORD   dwTotalSize;
 
    hr = BuildEmailAddr( psDomainName, psUserName, sEmailAddr, sizeof( sEmailAddr )/sizeof(WCHAR) );
    if ( S_OK == hr )
        hr = MailboxSetRemote();
    if ( S_OK == hr )
    {
        hr = E_FAIL;
        if ( mailboxX.OpenMailBox( sEmailAddr ))
        {
            if ( mailboxX.EnumerateMailBox() )
            {
                dwTotalSize = mailboxX.GetTotalSize();
                if (  INT_MAX > dwTotalSize )
                {
                    *plFactor = 1;
                    *plUsage = dwTotalSize;
                }
                else
                {
                    *plFactor = 10;
                    *plUsage = dwTotalSize / 10;
                }
                hr = S_OK;
            }
            mailboxX.CloseMailBox();
        }
    }
    MailboxResetRemote();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// GetUserMessageCount, public
//
// Purpose: 
//    Get the number of messages in the mailbox.
//
// Arguments:
//    LPWSTR psDomainName : Domain of user
//    LPWSTR psUserName : User to check 
//    long *plCount : return value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::GetUserMessageCount( LPWSTR psDomainName, LPWSTR psUserName, long *plCount )
{
    // psDomainName - checked by BuildEmailAddrW2A
    // psBuffer - checked by BuildEmailAddrW2A
    if ( NULL == plCount )
        return E_INVALIDARG;

    HRESULT hr;
    CMailBox mailboxX;
    WCHAR    sEmailAddr[POP3_MAX_ADDRESS_LENGTH];
 
    hr = BuildEmailAddr(psDomainName, psUserName, sEmailAddr, sizeof( sEmailAddr )/sizeof(WCHAR) );
    if ( S_OK == hr )
        hr = MailboxSetRemote();
    if ( S_OK == hr )
    {
        hr = E_FAIL;
        if ( mailboxX.OpenMailBox( sEmailAddr ))
        {
            if ( mailboxX.EnumerateMailBox() )
            {
                *plCount = mailboxX.GetMailCount();
                hr = S_OK;
            }
            mailboxX.CloseMailBox();
        }
    }
    MailboxResetRemote();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// InitFindFirstFile, public
//
// Purpose: 
//    Initialize a file search.  Used for enumerating users.
//
// Arguments:
//    HANDLE& hfSearch : search handle to initialize
//
// Returns: S_OK or S_FALSE (no users) on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::InitFindFirstUser( HANDLE& hfSearch, LPCWSTR psDomainName, LPWSTR psBuffer, DWORD dwBufferSize )
{
    // psDomainName - checked by BuildEmailAddrW2A
    if ( NULL == psBuffer )
        return E_INVALIDARG;
    
    HRESULT hr = S_OK;
    bool    bFound = false;
    WCHAR   sBuffer[POP3_MAX_PATH];
    _bstr_t _bstr;
    LPWSTR  ps;
    CMailBox mailboxX;
    WIN32_FIND_DATA stFindFileData;

    if ( INVALID_HANDLE_VALUE != hfSearch )
    {
        FindClose( hfSearch );
        hfSearch = INVALID_HANDLE_VALUE;
    }
    // Build the Path
    hr = BuildDomainPath( psDomainName, sBuffer, (sizeof( sBuffer )/sizeof(WCHAR)));
    if (S_OK == hr)
    {
        if ((sizeof( sBuffer )/sizeof(WCHAR)) > (wcslen( sBuffer ) + wcslen(MAILBOX_PREFIX_W) + wcslen(MAILBOX_EXTENSION_W) + 2 ))
        {
            wcscat( sBuffer, L"\\" );
            wcscat( sBuffer, MAILBOX_PREFIX_W );
            wcscat( sBuffer, L"*" );
            wcscat( sBuffer, MAILBOX_EXTENSION_W );
        }
        else
            hr = E_UNEXPECTED;
    }
    if ( S_OK == hr )
        hr = MailboxSetRemote();
    if ( S_OK == hr )
    {
        // Directory Search
        hfSearch = FindFirstFileEx( sBuffer, FindExInfoStandard, &stFindFileData, FindExSearchLimitToDirectories, NULL, 0 );
        if ( INVALID_HANDLE_VALUE == hfSearch )
            hr = HRESULT_FROM_WIN32(GetLastError());
        while ( S_OK == hr && !bFound )
        {   // Make sure we have a mailbox directory
            if ( FILE_ATTRIBUTE_DIRECTORY == ( FILE_ATTRIBUTE_DIRECTORY & stFindFileData.dwFileAttributes ))
            {
                ps = mailboxX.GetMailboxFromStoreNameW( stFindFileData.cFileName );
                if ( NULL != ps )
                {
                    _bstr = ps;
                    _bstr += L"@";
                    _bstr += psDomainName;
                    if ( mailboxX.OpenMailBox( _bstr ))
                    {
                        if ( dwBufferSize > wcslen( ps ))
                        {
                            wcscpy( psBuffer, ps );
                            bFound = true;
                            mailboxX.CloseMailBox();
                        }
                        else
                            hr = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
                    }
                }
            }
            if ( !bFound )
            {
                if ( !FindNextFile( hfSearch, &stFindFileData ))
                    hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        if ( HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr )
            hr = S_FALSE;
    }
    MailboxResetRemote();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IsDomainLocked, public
//
// Purpose: 
//    Determine if the domain is locked.
//    Domain locking involved renaming all the mailbox lock files to LOCKRENAME_FILENAME plus 
//    creating a file in the domain directory.
//    Checking for the file in the domain directory is a sufficient check for our purposes.
//
// Arguments:
//    LPWSTR psDomainName : domain to check
//
// Returns: S_OK on success, appropriate HRESULT otherwise
bool CP3AdminWorker::IsDomainLocked( LPWSTR psDomainName )
{
    // psDomainName - checked by BuildDomainPath

    HRESULT hr;
    bool    bRC = false;
    WCHAR   sDomainPath[POP3_MAX_PATH];
    WCHAR   sBuffer[POP3_MAX_PATH];

    hr = BuildDomainPath( psDomainName, sDomainPath, sizeof( sDomainPath )/sizeof(WCHAR) );
    if ( S_OK == hr )
    {   // Directory Search
        if ( (sizeof( sBuffer )/sizeof(WCHAR)) > (wcslen( sDomainPath ) + wcslen(LOCKRENAME_FILENAME) + 1 ))
        {
            wcscpy( sBuffer, sDomainPath );
            wcscat( sBuffer, L"\\" );
            wcscat( sBuffer, LOCKRENAME_FILENAME );
            if ( ERROR_NO_FILE_ATTR != GetFileAttributes( sBuffer ))
                bRC = true;
        }
        else
            hr = E_UNEXPECTED;
    }

    return bRC;
}


/////////////////////////////////////////////////////////////////////////////
// isUserLocked, public
//
// Purpose: 
//    Determine if the user is locked.  Users can be locked in one of two fashions:
//    Domain locking involved renaming all the mailbox lock files to LOCKRENAME_FILENAME,
//    or the LOCK_FILENAME may be in use.  Either way OpenMailbox will fail.
//
// Arguments:
//    LPWSTR psDomainName : domain of user
//    LPWSTR psUserName : user to check
//
// Returns: S_OK on success, appropriate HRESULT otherwise
bool CP3AdminWorker::isUserLocked( LPWSTR psDomainName, LPWSTR psUserName )
{
    // psDomainName - checked by BuildEmailAddrW2A
    // psBuffer - checked by BuildEmailAddrW2A

    bool bRC = false;
    HRESULT hr;
    CMailBox mailboxX;
    WCHAR   sEmailAddr[POP3_MAX_ADDRESS_LENGTH];
 
    hr = BuildEmailAddr( psDomainName, psUserName, sEmailAddr, sizeof( sEmailAddr )/sizeof(WCHAR) );
    if ( S_OK == hr )
        hr = MailboxSetRemote();
    if ( S_OK == hr )
    {
        if ( mailboxX.OpenMailBox( sEmailAddr ))
        {
            HRESULT hr = S_OK;
            WCHAR   sBuffer[POP3_MAX_PATH];
            WCHAR   sLockFile[POP3_MAX_PATH];

            hr = BuildUserPath( psDomainName, psUserName, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) );
            if ( S_OK == hr )
            {   
                if ((sizeof( sLockFile )/sizeof(WCHAR)) > ( wcslen( sBuffer ) + wcslen( LOCK_FILENAME ) + 1 ))
                {
                    wcscpy( sLockFile, sBuffer );
                    wcscat( sLockFile, L"\\" );
                    wcscat( sLockFile, LOCK_FILENAME );
                    if ( -1 == GetFileAttributes( sLockFile ))
                        bRC = true;
                }
            }
            mailboxX.CloseMailBox();
        }
    }
    MailboxResetRemote();

    return bRC;
}

BYTE g_ASCII128[128] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 00-0F
                         0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, // 10-1F
                         0,1,0,1,1,1,1,1,0,0,0,1,0,1,1,0, // 20-2F
                         1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0, // 30-3F
                         0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 40-4F
                         1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1, // 50-5F
                         1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, // 60-6F
                         1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1  // 70-7F
                      };  

/////////////////////////////////////////////////////////////////////////////
// isValidMailboxName, public
//
// Purpose: 
//    Perform RFC 821 validation on the mailbox name
//    user - The maximum total length of a user name is 64 characters.
//   <mailbox> ::= <local-part> "@" <domain>
//   <local-part> ::= <dot-string> | <quoted-string>
//   <dot-string> ::= <string> | <string> "." <dot-string>  -> . 0x2e
//   <quoted-string> ::=  """ <qtext> """                   -> " 0x22 not going to allow this because it creates other complications
//   <string> ::= <char> | <char> <string>
//   <char> ::= <c> | "\" <x>                          
//   <x> ::= any one of the 128 ASCII characters (no exceptions) -> This means any thing is permitted, even the special characters!
//   <c> ::= any one of the 128 ASCII characters, 
//           but not any <special> or <SP>
//   <special> ::= "<" | ">" | "(" | ")" | "[" | "]" | "\" | "."
//               | "," | ";" | ":" | "@"  """ | the control
//               characters (ASCII codes 0 through 31 inclusive and 127)
//   <SP> ::= the space character (ASCII code 32)
//
// Arguments:
//    LPWSTR psMailbox : name to validate
//
// Returns: S_OK on success, appropriate HRESULT otherwise
bool CP3AdminWorker::isValidMailboxName( LPWSTR psMailbox )
{
    if ( NULL == psMailbox )
        return false;
    if ( POP3_MAX_MAILBOX_LENGTH <= wcslen( psMailbox ) || 0 == wcslen( psMailbox ))
        return false;
    
    bool    bRC = true;
    WCHAR   *pch = psMailbox;
    
    for ( pch = psMailbox; 0x0 != *pch && bRC; pch++ )
    {
        if ( 127 < *pch || !g_ASCII128[*pch] )
            bRC = false;
    }
    if ( bRC && ( 0x2e == psMailbox[0] || 0x2e == psMailbox[wcslen( psMailbox )-1] ))
        bRC = false;
    
    return bRC;
}

/////////////////////////////////////////////////////////////////////////////
// LockDomain, public
//
// Purpose: 
//    Lock all the mailboxes in the domain.
//    This involves renaming all the mailbox lock files so that the Service
//    can no longer access them.
//    Also create a Lock file in the domain directory to distinguish between
//    a domain lock and all mailboxes locked.
//
// Arguments:
//    LPWSTR psDomainName : domain to lock
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::LockDomain( LPWSTR psDomainName, bool bVerifyNotInUse /*= false*/ )
{
    // psDomainName - checked by BuildDomainPath

    HRESULT hr = S_OK;
    HANDLE  hfSearch, hf;
    WCHAR   sDomainPath[POP3_MAX_PATH];
    WCHAR   sBuffer[POP3_MAX_PATH];
    WCHAR   sLockFile[POP3_MAX_PATH];
    WCHAR   sRenameFile[POP3_MAX_PATH];
    WIN32_FIND_DATA stFindFileData;

    hr = BuildDomainPath( psDomainName, sDomainPath, sizeof( sDomainPath )/sizeof(WCHAR) );
    if ( S_OK == hr )
    {   // Directory Search
        wcscpy( sBuffer, sDomainPath );
        if ((sizeof( sBuffer )/sizeof(WCHAR)) > (wcslen( sBuffer ) + wcslen(MAILBOX_PREFIX_W) + wcslen(MAILBOX_EXTENSION_W)) + 2 )
        {
            wcscat( sBuffer, L"\\" );
            wcscat( sBuffer, MAILBOX_PREFIX_W );
            wcscat( sBuffer, L"*" );
            wcscat( sBuffer, MAILBOX_EXTENSION_W );
        }
        else
            hr = E_UNEXPECTED;
        hfSearch = FindFirstFileEx( sBuffer, FindExInfoStandard, &stFindFileData, FindExSearchLimitToDirectories, NULL, 0 );
        if ( INVALID_HANDLE_VALUE == hfSearch )
            hr = HRESULT_FROM_WIN32(GetLastError());
        while ( S_OK == hr )
        {   // Lock each directory (user)
            if ( FILE_ATTRIBUTE_DIRECTORY == ( FILE_ATTRIBUTE_DIRECTORY & stFindFileData.dwFileAttributes ))
            {
                if (( (sizeof( sLockFile )/sizeof(WCHAR)) > ( wcslen( sDomainPath ) + wcslen( stFindFileData.cFileName ) + wcslen( LOCK_FILENAME ) + 2 )) &&
                    ( (sizeof( sRenameFile )/sizeof(WCHAR)) > ( wcslen( sDomainPath ) + wcslen( stFindFileData.cFileName ) + wcslen( LOCKRENAME_FILENAME ) + 2 )))
                {
                    wcscpy( sLockFile, sDomainPath );
                    wcscat( sLockFile, L"\\" );
                    wcscat( sLockFile, stFindFileData.cFileName );
                    wcscat( sLockFile, L"\\" );
                    wcscpy( sRenameFile, sLockFile );
                    wcscat( sLockFile, LOCK_FILENAME );
                    wcscat( sRenameFile, LOCKRENAME_FILENAME );
                    if ( !MoveFile( sLockFile, sRenameFile ))
                    {   // If the lock file does not exist, that is okay (this must not be one of our directories)
                        DWORD dwRC = GetLastError();
                        if ( ERROR_FILE_NOT_FOUND != dwRC )
                            hr = HRESULT_FROM_WIN32(dwRC);
                    }
                    else
                    {   // Try an exclusive lock on the file to make sure the service does not have access to it.
                        if ( bVerifyNotInUse )
                        {
                            hf = CreateFile( sRenameFile, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING, FILE_ATTRIBUTE_HIDDEN, NULL );
                            if ( INVALID_HANDLE_VALUE == hf )
                                hr = HRESULT_FROM_WIN32( GetLastError() );
                            else
                                CloseHandle( hf );
                        }
                    }
                }
                else
                    hr = E_FAIL;
            }
            if ( S_OK == hr && !FindNextFile( hfSearch, &stFindFileData ))
                hr = HRESULT_FROM_WIN32(GetLastError());
        }
        if ( HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr )
            hr = S_OK;
        if(INVALID_HANDLE_VALUE!=hfSearch)
        {
            FindClose(hfSearch);
            hfSearch=INVALID_HANDLE_VALUE;
        }
        if ( S_OK == hr )
        {
            if ((sizeof( sBuffer )/sizeof(WCHAR)) > (wcslen( sDomainPath ) + wcslen(LOCKRENAME_FILENAME) + 1 ))
            {
                HANDLE  hf;
                
                wcscpy( sBuffer, sDomainPath );
                wcscat( sBuffer, L"\\" );
                wcscat( sBuffer, LOCKRENAME_FILENAME );
                hf = CreateFile( sBuffer, GENERIC_ALL, 0, NULL, CREATE_NEW, FILE_ATTRIBUTE_HIDDEN, NULL );
                if ( INVALID_HANDLE_VALUE != hf )
                    CloseHandle( hf );
                else
                {   // If the lock file already exists, that is okay (domain already locked) - we only expect this error in the LockForDelete scenario
                    DWORD dwRC = GetLastError();
                    if ( !(bVerifyNotInUse && ERROR_FILE_EXISTS == dwRC ))
                        hr = HRESULT_FROM_WIN32(dwRC);
                }
            }
        }
        // Ran into a problem need to undo everything we've done
        if ( S_OK != hr )   
            UnlockDomain( psDomainName );   // Don't overwrite existing return code
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// LockUser, public
//
// Purpose: 
//    Lock the user mailbox.
//    A permanent lock is created by renaming all the mailbox lock file so that the Service
//    can no longer it.
//
// Arguments:
//    LPWSTR psDomainName : domain of user
//    LPWSTR psUserName : user to lock
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::LockUser( LPWSTR psDomainName, LPWSTR psUserName )
{
    // psDomainName - checked by BuildUserPath
    // psUserName - checked by BuildUserPath

    HRESULT hr = S_OK;
    WCHAR   sBuffer[POP3_MAX_PATH];
    WCHAR   sLockFile[POP3_MAX_PATH];
    WCHAR   sRenameFile[POP3_MAX_PATH];

    hr = BuildUserPath( psDomainName, psUserName, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) );
    if ( S_OK == hr )
    {   
        if (( (sizeof( sLockFile )/sizeof(WCHAR)) > ( wcslen( sBuffer ) + wcslen( LOCK_FILENAME ) + 1 )) &&
            ( (sizeof( sRenameFile )/sizeof(WCHAR)) > ( wcslen( sBuffer ) + wcslen( LOCKRENAME_FILENAME ) + 1 )))
        {
            wcscpy( sLockFile, sBuffer );
            wcscat( sLockFile, L"\\" );
            wcscpy( sRenameFile, sLockFile );
            wcscat( sLockFile, LOCK_FILENAME );
            wcscat( sRenameFile, LOCKRENAME_FILENAME );
            if ( !MoveFile( sLockFile, sRenameFile ))
            {   
                DWORD dwRC = GetLastError();
                hr = HRESULT_FROM_WIN32(dwRC);
            }
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// MailboxSetRemote, public
//
// Purpose: 
//    Set the Mailbox static path to the remote machine, if necessary.
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::MailboxSetRemote()
{
    
    if ( NULL != m_psMachineMailRoot )
    {
        if ( !CMailBox::SetMailRoot( m_psMachineMailRoot ) )
            return E_FAIL;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// MailboxResetRemote, public
//
// Purpose: 
//    Reset the Mailbox static path back to the local machine, if necessary.
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::MailboxResetRemote()
{
    if ( NULL != m_psMachineMailRoot )
    {
        if ( !CMailBox::SetMailRoot( ))
            return E_FAIL;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// RemoveDomain, public
//
// Purpose: 
//    Remove the Meta base options required to remove a Local domain from the SMTP service.
//    Remove the domain from our Store.
//
// Arguments:
//    LPWSTR psDomainName : Domain name to remove
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::RemoveDomain( LPWSTR psDomainName )
{
    // psDomainName - checked by CreateDomainMutex

    HRESULT hr = S_OK;
    HANDLE  hMutex = NULL;

    // Create a Mutex Name for this domain to ensure we are the only one accessing it.
    hr = CreateDomainMutex( psDomainName, &hMutex );
    // Validate
    if ( S_OK == hr )
    {   
        hr = ValidateDomain( psDomainName );
        if ( HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr )
        {   // Domain exists in SMTP but not in Store, let's delete from SMTP anyway
            hr = RemoveSMTPDomain( psDomainName );
            if ( S_OK == hr )
                hr = ERROR_PATH_NOT_FOUND;
        }   
    }
    // Lock all the Mailboxes
    if ( S_OK == hr )
    {
        hr = LockDomainForDelete( psDomainName );
        // Remove
        if ( S_OK == hr )
        {
            hr = RemoveSMTPDomain( psDomainName );
            if ( S_OK == hr )
            {
                hr = RemoveStoreDomain( psDomainName );
                if FAILED( hr )
                    AddSMTPDomain( psDomainName );
            }
            if ( S_OK != hr )
                UnlockDomain( psDomainName );
        }
    }
    // Cleanup
    if ( NULL != hMutex )
        CloseHandle( hMutex );

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// RemoveUser, public
//
// Purpose: 
//    Remove a user mailbox.
//
// Arguments:
//    LPWSTR psDomainName : Domain name to remove from 
//    LPWSTR psUserName : User name to remove
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::RemoveUser( LPWSTR psDomainName, LPWSTR psUserName )
{
    // psDomainName - checked by BuildUserPath
    // psUserName - checked by BuildUserPath

    HRESULT hr;
    HANDLE  hMutex = NULL;
    WCHAR    sEmailAddr[POP3_MAX_ADDRESS_LENGTH];
    WCHAR   sRenameFile[POP3_MAX_PATH];
    WCHAR   sUserFile[POP3_MAX_PATH];
    CMailBox mailboxX;

    hr = BuildUserPath( psDomainName, psUserName, sUserFile, sizeof( sUserFile )/sizeof(WCHAR) );
    if ( S_OK == hr )
    {   // build the path to the mail dir \MailRoot\Domain@User
        hr = BuildDomainPath( psDomainName, sRenameFile, sizeof( sRenameFile )/sizeof(WCHAR) );
        if ( S_OK == hr )
        {
            if ( (wcslen( sRenameFile ) + wcslen( MAILBOX_PREFIX_W ) + wcslen( psUserName ) + wcslen( MAILBOX_EXTENSION2_W ) + 1) < (sizeof( sRenameFile )/sizeof(WCHAR)) )
            {   // build the path to the mail dir \MailRoot\Domain\User
                wcscat( sRenameFile, L"\\" );
                wcscat( sRenameFile, MAILBOX_PREFIX_W );
                wcscat( sRenameFile, psUserName );
                wcscat( sRenameFile, MAILBOX_EXTENSION2_W );
            }
            else
                hr = E_FAIL;
        }
    }

    // Validate the domain 
    if ( S_OK == hr )
    {   
        hr = ValidateDomain( psDomainName );
    }
    if ( S_OK == hr )
        hr = MailboxSetRemote();
    if ( S_OK == hr )
    {   // See if the mailbox already exists
        hr = BuildEmailAddr( psDomainName, psUserName, sEmailAddr, sizeof( sEmailAddr )/sizeof(WCHAR) );
        if ( mailboxX.OpenMailBox( sEmailAddr ))
        {   // Create a Mutex Name for this user@domain to ensure we are the only one accessing it.
            hr = CreateUserMutex( psDomainName, psUserName, &hMutex );
            //  Lock the Mailbox to make sure we are the only one accessing it then
            //  rename it to something unique, release our lock on the mailbox, then kill it.
            if ( S_OK == hr )
            {   
                if ( MoveFile( sUserFile, sRenameFile ))    // rename
                { 
                    if ( !BDeleteDirTree( sRenameFile ))    // kill
                    {
                        hr = HRESULT_FROM_WIN32( GetLastError());
                        if SUCCEEDED( hr ) hr = E_FAIL;     // Make sure we have a failure code
                        // Now what?  Try to repair what's left of this mess.
                        if ( MoveFile( sRenameFile, sUserFile ))
                        {   // What if the lock file was deleted?
                            if ( mailboxX.OpenMailBox( sEmailAddr ))
                                mailboxX.RepairMailBox();
                        }
                    }
                }
                else
                    hr = HRESULT_FROM_WIN32( GetLastError());
            }
            // Cleanup
            if ( NULL != hMutex )
                CloseHandle( hMutex );
            mailboxX.CloseMailBox();    // It's okay to do this even if the mailbox is already closed.
        }
        else
            hr = HRESULT_FROM_WIN32( GetLastError());
    }
    MailboxResetRemote();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// SearchDomainsForMailbox, public
//
// Purpose: 
//    Search all domains for the first occurance of a given mailbox
//
// Arguments:
//    LPWSTR psUserName : Mailbox to search for
//    LPWSTR *ppsDomain : Name of domain mailbox found in   !Must be freed by caller
//
// Returns: S_OK if mailbox found (if not NULL ppsDomain will contain the domain name),
//      HRESULT_FROM_WIN32( ERROR_NO_SUCH_USER ) if mailbox not found in any domain, 
//      appropriate HRESULT otherwise
HRESULT CP3AdminWorker::SearchDomainsForMailbox( LPTSTR psUserName, LPTSTR *ppsDomain )
{
    if ( NULL == psUserName )
        return E_INVALIDARG;
    if ( 0 == wcslen( psUserName ))
        return E_INVALIDARG;
    if ( NULL != ppsDomain )
        *ppsDomain = NULL;

    HRESULT hr = S_OK;
    bool    bFound = false;
    BSTR    bstrName;
    WCHAR    sEmailAddr[POP3_MAX_ADDRESS_LENGTH];
    VARIANT v;
    CMailBox mailboxX;
    CComPtr<IP3Config> spIConfig;
    CComPtr<IP3Domains> spIDomains;
    CComPtr<IP3Domain> spIDomain = NULL;
    CComPtr<IEnumVARIANT> spIEnumVARIANT;
    
    VariantInit( &v );
    hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
    if ( S_OK == hr )
        hr = spIConfig->get_Domains( &spIDomains );
    if ( S_OK == hr )
        hr = spIDomains->get__NewEnum( &spIEnumVARIANT );
    if ( S_OK == hr )
        hr = spIEnumVARIANT->Next( 1, &v, NULL );
    while ( S_OK == hr && !bFound )
    {
        if ( VT_DISPATCH != V_VT( &v ))
            hr = E_UNEXPECTED;
        else
        {
            if ( NULL != spIDomain.p )
                spIDomain.Release();
            hr = V_DISPATCH( &v )->QueryInterface( __uuidof( IP3Domain ), reinterpret_cast<void**>( &spIDomain ));
        }
        if ( S_OK == hr )
        {
            hr = spIDomain->get_Name( &bstrName );
            if ( S_OK == hr )
            {   // See if the mailbox already exists
                hr = BuildEmailAddr( bstrName, psUserName, sEmailAddr, sizeof( sEmailAddr )/sizeof(WCHAR) );
                if ( S_OK == hr )
                {
                    if ( mailboxX.OpenMailBox( sEmailAddr ))
                    {   // We found the mailbox, time to exit
                        bFound = true;
                        mailboxX.CloseMailBox();    // return void!
                        if ( NULL != ppsDomain )
                        {   // Let's return the domain name
                            *ppsDomain = new WCHAR[ wcslen( bstrName ) + 1];
                            if ( NULL == *ppsDomain )
                                hr = E_OUTOFMEMORY;
                            else
                                wcscpy( *ppsDomain, bstrName );
                        }
                    }
                }
                SysFreeString( bstrName );
            }
        }
        VariantClear( &v );
        if ( S_OK == hr && !bFound )
        {
            hr = spIEnumVARIANT->Next( 1, &v, NULL );
        }
    }

    if ( S_FALSE == hr )
    {
        hr = HRESULT_FROM_WIN32( ERROR_NO_SUCH_USER ) ;  // Reached end of enumeration
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// SetConfirmAddUser, public
//
// Purpose: 
//    Set the Confirm Add User registry key.
//
// Arguments:
//    BOOL bConfirm: new value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::SetConfirmAddUser( BOOL bConfirm )
{
    HRESULT hr = S_OK;
    
    if ( TRUE != bConfirm && FALSE != bConfirm )
        hr = HRESULT_FROM_WIN32( ERROR_DS_RANGE_CONSTRAINT );
    else
    {
        DWORD dwValue = bConfirm ? 1 : 0;

        long lRC = RegSetConfirmAddUser( dwValue, m_psMachineName );
        if ( ERROR_SUCCESS != lRC ) 
            hr = HRESULT_FROM_WIN32( lRC );
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// SetDomainLock, public
//
// Purpose: 
//    Set the domain lock.
//
// Arguments:
//    LPWSTR psDomainName : Domain name to lock
//    BOOL bLock : TRUE - to lock the domain, FALSE - to unlock the domain
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::SetDomainLock( LPWSTR psDomainName, BOOL bLock )
{
    // psDomainName - checked by CreateDomainMutex
 
    HRESULT hr = S_OK;
    HANDLE  hMutex = NULL;

    // Validate
    if ( S_OK == hr )
    {   
        hr = ValidateDomain( psDomainName );
    }
    // Create a Mutex Name for this domain to ensure we are the only one accessing it.
    hr = CreateDomainMutex( psDomainName, &hMutex );
    // Lock all the Mailboxes
    if ( S_OK == hr )
    {
        if ( bLock )
        {
            if ( !IsDomainLocked( psDomainName ))
                hr = LockDomain( psDomainName );
            else
                hr = HRESULT_FROM_WIN32( ERROR_LOCKED );
        }
        else
        {
            if ( IsDomainLocked( psDomainName ))
                hr = UnlockDomain( psDomainName );
            else
                hr = HRESULT_FROM_WIN32( ERROR_NOT_LOCKED );
        }
    }
    // Cleanup
    if ( NULL != hMutex )
        CloseHandle( hMutex );

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// SetUserLock, public
//
// Purpose: 
//    Set the domain lock.
//
// Arguments:
//    LPWSTR psDomainName : Domain name of user
//    LPWSTR psUserName : User name to lock
//    BOOL bLock : TRUE - to lock the user, FALSE - to unlock the user
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::SetUserLock( LPWSTR psDomainName, LPWSTR psUserName, BOOL bLock )
{
    // psDomainName - checked by CreateUserMutex
    // psUserName - checked by CreateUserMutex

    HRESULT hr = S_OK;
    HANDLE  hMutex = NULL;
    WCHAR    sEmailAddr[POP3_MAX_ADDRESS_LENGTH];
    CMailBox mailboxX;

    // Create a Mutex Name for this user to ensure we are the only one accessing it.
    hr = CreateUserMutex( psDomainName,  psUserName, &hMutex );
    if ( S_OK == hr )
    {
        if ( FALSE == bLock )
        {
            if ( IsDomainLocked( psDomainName ))
                hr = HRESULT_FROM_WIN32( ERROR_INVALID_DOMAIN_STATE );
        }
    }
    if ( S_OK == hr )
        hr = BuildEmailAddr( psDomainName, psUserName, sEmailAddr, sizeof( sEmailAddr )/sizeof(WCHAR));
    if ( S_OK == hr )
        hr = MailboxSetRemote();
    if ( S_OK == hr )
    {   // Validate the Mailbox
        if ( !mailboxX.OpenMailBox( sEmailAddr ))
            hr = HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND );
    }
     // Lock/Unlock the Mailbox
    if ( S_OK == hr )
    {
        if ( bLock )
        {
            if ( !isUserLocked( psDomainName, psUserName ))
            {   // Lock the user
                hr = LockUser( psDomainName, psUserName );
            }
            else
                hr = HRESULT_FROM_WIN32( ERROR_LOCKED );
        }
        else
        {
            if ( isUserLocked( psDomainName, psUserName ))
            {   // UnLock the user
                hr = UnlockUser( psDomainName, psUserName );
            }
            else
                hr = HRESULT_FROM_WIN32( ERROR_NOT_LOCKED );
        }
        mailboxX.CloseMailBox();
    }
    MailboxResetRemote();
    // Cleanup
    if ( NULL != hMutex )
        CloseHandle( hMutex );

    return hr;
}
/////////////////////////////////////////////////////////////////////////////
// SetIISConfig, public
/////////////////////////////////////////////////////////////////////////////

// exchange OnSMTP event sink bindings directions
// {1b3c0666-e470-11d1-aa67-00c04fa345f6}
//DEFINE_GUID(GUID_PLAT_SMTPSVC, 
//0x1b3c0666, 0xe470, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);
#define GUID_PLAT_SMTPSVC   L"{1b3c0666-e470-11d1-aa67-00c04fa345f6}"
// {fb65c4dc-e468-11d1-aa67-00c04fa345f6}
//DEFINE_GUID(SMTP_PLAT_SOURCE_TYPE_GUID,
//0xfb65c4dc, 0xe468, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);
#define SMTP_PLAT_SOURCE_TYPE_GUID  L"{fb65c4dc-e468-11d1-aa67-00c04fa345f6}"
// SMTP Store Events
// {59175850-e533-11d1-aa67-00c04fa345f6}
//DECLARE_EVENTGUID_STRING( g_szcatidSmtpStoreDriver, "{59175850-e533-11d1-aa67-00c04fa345f6}");
//DEFINE_GUID(CATID_SMTP_STORE_DRIVER, 0x59175850, 0xe533, 0x11d1, 0xaa, 0x67, 0x0, 0xc0, 0x4f, 0xa3, 0x45, 0xf6);
#define CATID_SMTP_STORE_DRIVER L"{59175850-e533-11d1-aa67-00c04fa345f6}"

#define STR_P3STOREDRIVER_DISPLAY_NAME     L"POP 3 SMTP Store Driver"
#define STR_P3STOREDRIVER_SINKCLASS        L"POP3SMTPStoreDriver.CPOP3SMTPStoreDriver"
#define CLSID_CSimpleDriver                L"{9100BE35-711B-4b34-8AC9-BA350C2117BE}"

/////////////////////////////////////////////////////////////////////////////
// SetIISConfig, public
//
// Purpose: 
//    Set the Meta base options required for our SMTP Store Driver to work.
//    This involves:
//         DELETE SMTPSVC/1/DropDirectory
//         Bind our SMTP Store Driver
//
// Arguments:
//    BOOL bBindSink : TRUE, perform the necessary configuration
//                     FALSE, remove any configuration changes (try to reconstruct DropDirectory setting)
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::SetIISConfig( bool bBindSink )
{
    HRESULT hr;

    CComPtr<IEventBindingManager>   spIBindingManager;
    CComPtr<IEventBindings>         spIBindings;
    CComPtr<IEventBinding>          spIBinding;
    CComPtr<IEventPropertyBag>      spISourceProps;

    CComPtr<IEventUtil>             spIUtil;

    /////////////////////////////
    // Bind our SMTP Store Driver
    /////////////////////////////

    hr = CoCreateInstance( __uuidof( CEventUtil ), NULL, CLSCTX_ALL, __uuidof( IEventUtil ),reinterpret_cast<LPVOID*>( &spIUtil ));
    if ( S_OK == hr && NULL != spIUtil.p )
    {
        hr = spIUtil->RegisterSource(CComBSTR( SMTP_PLAT_SOURCE_TYPE_GUID ),
                                    CComBSTR( GUID_PLAT_SMTPSVC ),
                                    1,
                                    CComBSTR( L"smtpsvc" ),
                                    CComBSTR( L"" ),
                                    CComBSTR( L"event.metabasedatabasemanager" ),
                                    CComBSTR( L"smtpsvc 1" ),   // Set up the default site (instance)
                                    &spIBindingManager);
        if ( S_OK == hr )
        {
            hr = spIBindingManager->get_Bindings( _bstr_t( CATID_SMTP_STORE_DRIVER ), &spIBindings );
            if ( S_OK == hr )
            {
                if ( bBindSink )
                {   // Create binding
                    hr = spIBindings->Add( _bstr_t( CLSID_CSimpleDriver ),&spIBinding );
                    if ( S_OK == hr  )
                    {
                        hr = spIBinding->put_DisplayName( _bstr_t( STR_P3STOREDRIVER_DISPLAY_NAME ));
                        if SUCCEEDED( hr )
                            hr = spIBinding->put_SinkClass( _bstr_t( STR_P3STOREDRIVER_SINKCLASS ));
                        if SUCCEEDED( hr )
                            hr = spIBinding->get_SourceProperties(&spISourceProps);
                        if SUCCEEDED( hr )
                        {
                            _variant_t _v(static_cast<long>(0));

                            hr = spISourceProps->Add( _bstr_t( L"priority" ), &_v );
                        }
                        if SUCCEEDED( hr )
                            hr = spIBinding->Save();
                    }
                }
                else
                {   // Delete binding
                    _variant_t _v( CLSID_CSimpleDriver );
                    hr = spIBindings->Remove( &_v );
                }
            }
        }
    }

    if ( SUCCEEDED( hr ) && !bBindSink )   // Unregistering
    {   // Remove all domains from SMTP
        ULONG   ulFetch;
        BSTR bstrDomainName;
        VARIANT v;
        CComPtr<IADs> spIADs = NULL;
        CComPtr<IEnumVARIANT> spIEnumVARIANT = NULL;
        
        VariantInit( &v );
        hr = GetDomainEnum( &spIEnumVARIANT );
        while ( S_OK == hr )
        {
            hr = spIEnumVARIANT->Next( 1, &v, &ulFetch );
            if ( S_OK == hr && 1 == ulFetch )
            {
                if ( VT_DISPATCH == V_VT( &v ))
                    hr = V_DISPATCH( &v )->QueryInterface( __uuidof( IADs ), reinterpret_cast<void**>( &spIADs ));
                else
                    hr = E_UNEXPECTED;
                VariantClear( &v );
                if ( S_OK == hr )
                {
                    hr = spIADs->get_Name( &bstrDomainName );
                    if ( S_OK == hr )
                    {
                        hr = ValidateDomain( bstrDomainName );
                        if ( S_OK == hr )
                            hr = RemoveSMTPDomain( bstrDomainName );
                        SysFreeString( bstrDomainName );
                    }
                    spIADs.Release();
                    spIADs = NULL;
                }
            }
            if ( S_OK == hr )
            {   // We deleted an SMTP domain, therefore we need a new Enum
                spIEnumVARIANT.Release();
                hr = GetDomainEnum( &spIEnumVARIANT );
            }
            else if ( HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == hr )
                hr = S_OK;  // Some of the domains might not be our domains.
        }
        if ( S_FALSE == hr )
            hr = S_OK;
    }
    
    ///////////////////////////////////////
    // Make some final registry key changes
    ///////////////////////////////////////
    if SUCCEEDED( hr )
    {
        WCHAR   sBuffer[POP3_MAX_MAILROOT_LENGTH];
        
        hr = GetDefaultMailRoot( sBuffer, sizeof(sBuffer)/sizeof(WCHAR) );
        if ( S_OK == hr )
            hr = SetMailroot( sBuffer );
        if ( S_OK == hr )
        {
            long lRC;
            
            lRC = RegSetupOCM();
            if ( ERROR_SUCCESS != lRC )
                hr = HRESULT_FROM_WIN32(lRC);
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// SetLoggingLevel, public
//
// Purpose: 
//    Set the LoggingLevel registry key.
//
// Arguments:
//    long lLoggingLevel : new value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::SetLoggingLevel( long lLoggingLevel )
{
    if ( 0 > lLoggingLevel || 3 < lLoggingLevel )
        return HRESULT_FROM_WIN32( ERROR_DS_RANGE_CONSTRAINT );
    
    HRESULT hr = S_OK;
    long    lRC;

    lRC = RegSetLoggingLevel( lLoggingLevel, m_psMachineName );
    if ( ERROR_SUCCESS != lRC )
        hr = HRESULT_FROM_WIN32( lRC );

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// SetMachineName, public
//
// Purpose: 
//    Set the Machine Name that all operations should be performed on.
//    Note: We can not administer remote machine using AD authentication if they are in a different domain
//
// Arguments:
//    LPWSTR psMachineName : new value, NULL means Local Machine.
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::SetMachineName( LPWSTR psMachineName )
{
    if ( !m_isPOP3Installed )
        return E_UNEXPECTED;
    
    HRESULT hr = S_OK;

    if ( NULL != m_psMachineName )
    {
        delete m_psMachineName;
        m_psMachineName = NULL;
    }
    if ( NULL != m_psMachineMailRoot  )
    {
        delete m_psMachineMailRoot ;
        m_psMachineMailRoot = NULL;
    }
    if ( NULL != psMachineName )
    {
        DWORD dwLength = wcslen( psMachineName );
        if ( 0 < dwLength )
        {
            if ( S_OK == hr )
            {
                m_psMachineName = new WCHAR[dwLength+1];
                m_psMachineMailRoot = new WCHAR[POP3_MAX_MAILROOT_LENGTH];
                if ( NULL != m_psMachineName && NULL != m_psMachineMailRoot )
                {
                    wcscpy( m_psMachineName, psMachineName );
                    hr = GetMailroot( m_psMachineMailRoot, POP3_MAX_MAILROOT_LENGTH );
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            if ( S_OK == hr )
            {   // Check the Auth Method of the remote machine
                CComPtr<IAuthMethod> spIAuthMethod;
               
                hr = GetCurrentAuthentication( &spIAuthMethod );    // Enforces that remote machine using AD authentication are in our domain!
            }
        }
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// SetMailroot, public
//
// Purpose: 
//    Set the Mail root registry key.
//
// Arguments:
//    LPWSTR psMailRoot : new value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::SetMailroot( LPWSTR psMailRoot )
{
    if ( NULL == psMailRoot )
        return E_INVALIDARG;
    if ( POP3_MAX_MAILROOT_LENGTH < wcslen( psMailRoot ))
        return E_INVALIDARG;
        
    HRESULT hr = S_OK;
    TCHAR   sBuffer[POP3_MAX_MAILROOT_LENGTH-6], sBuffer2[POP3_MAX_MAILROOT_LENGTH-6]; // Need to leave room for \\? or \\?\UNC
    DWORD   dwRC;
    WCHAR   sMailRoot[POP3_MAX_PATH];

    // Same logic as GetMailroot
    wcscpy( sMailRoot, psMailRoot );
    if ( NULL != m_psMachineName )
    {   // Replace drive: with drive$
        if ( L':' == sMailRoot[1] )
        {
            sMailRoot[1] = L'$';
            if ( sizeof( sMailRoot )/sizeof(WCHAR) > (wcslen( sMailRoot ) + wcslen( m_psMachineName ) + 3) )
            {
                LPWSTR psBuffer = new WCHAR[wcslen(psMailRoot)+1];

                if ( NULL != psBuffer )
                {
                    wcscpy( psBuffer, sMailRoot );
                    wcscpy( sMailRoot, L"\\\\" );
                    wcscat( sMailRoot, m_psMachineName );
                    wcscat( sMailRoot, L"\\" );
                    wcscat( sMailRoot, psBuffer );
                    delete [] psBuffer;
                }
                else
                    hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
            }
            else
                hr = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
        }
    }
    if ( S_OK == hr )
    {
        hr = HRESULT_FROM_WIN32( ERROR_BAD_PATHNAME );
        dwRC = GetFileAttributes( sMailRoot );
        if ( -1 != dwRC )
        {   // Must begin with x:\ or \\.
            if ( ( FILE_ATTRIBUTE_DIRECTORY & dwRC ) && ( ( 0 == _wcsnicmp( psMailRoot+1, L":\\", 2 )) || ( 0 == _wcsnicmp( psMailRoot, L"\\\\", 2 ))))
            {
                if ( GetVolumePathName( sMailRoot, sBuffer, sizeof( sBuffer )/sizeof( TCHAR )))
                {
                    if ( GetVolumeNameForVolumeMountPoint( sBuffer, sBuffer2, sizeof( sBuffer2 )/sizeof( TCHAR )))
                    {   // Make sure the mailroot is not CDROM or removable disk
                        if ( DRIVE_FIXED == GetDriveType( sBuffer ))
                            hr = S_OK;
                    }
                    else
                    {   // Make sure this is a UNC Path
                        if ( NULL == wcschr( sMailRoot, L':' ))
                            hr = S_OK;
                    }
                }
            }
            else
                hr = HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND );
        }
        else
            hr = HRESULT_FROM_WIN32( GetLastError());
    }

    if ( S_OK == hr )
    {
        //Set the default ACLs for the mailroot directory
        WCHAR wszSDL[MAX_PATH]=L"O:BAG:BAD:PAR(A;OICI;GA;;;BA)(A;OICIIO;GA;;;CO)(A;OICI;GA;;;NS)(A;OICI;GA;;;SY)";
        PSECURITY_DESCRIPTOR pSD;
        ULONG lSize=0;
        if(ConvertStringSecurityDescriptorToSecurityDescriptorW( wszSDL, SDDL_REVISION_1, &pSD, &lSize))
        { 
            if( !SetFileSecurityW(sMailRoot, DACL_SECURITY_INFORMATION|PROTECTED_DACL_SECURITY_INFORMATION, pSD) )
                hr = HRESULT_FROM_WIN32( GetLastError());
            else
                hr = HRESULT_FROM_WIN32( SetMailBoxDACL(sMailRoot, pSD, 2));
            LocalFree(pSD);
        }
        else
            hr = HRESULT_FROM_WIN32( GetLastError());
    }
    if( S_OK == hr )
    {
        hr = HRESULT_FROM_WIN32( RegSetMailRoot( psMailRoot, m_psMachineName ));
        if( S_OK == hr )
        {
            if ( NULL == m_psMachineName )
            {
                if ( !CMailBox::SetMailRoot( ))
                    hr = E_FAIL;
            }
            else
                hr = GetMailroot( m_psMachineMailRoot, POP3_MAX_MAILROOT_LENGTH );
        }
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// SetPort, public
//
// Purpose: 
//    Set the Port registry key.
//
// Arguments:
//    long lPort : new value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::SetPort( long lPort )
{
    long lRC;
    
    if ( 1 > lPort || 65535 < lPort )
        lRC = ERROR_DS_RANGE_CONSTRAINT;
    else
        lRC = RegSetPort( lPort, m_psMachineName );

    if ( ERROR_SUCCESS == lRC )
        return S_OK;
    return HRESULT_FROM_WIN32( lRC );
}

/////////////////////////////////////////////////////////////////////////////
// SetSockets, public
//
// Purpose: 
//    Set the Sockets registry keys;
//
// Arguments:
//    long lMax: new Max ( must be >= lMin && >= lMin + lThreshold )
//    long lMin: new Min ( must be >= lThreshold )
//    long lThreshold: new Threshold ( must be > 0 && < lMax. Special case 0 if lMin == lMax
//    long lBacklog: new Backlog ( must be > 0 )
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::SetSockets( long lMax, long lMin, long lThreshold, long lBacklog )
{
    long lRC;

    if ( (1 > lMax       || 32000 < lMax) ||
         (1 > lMin       || 32000 < lMin) ||
         (0 > lThreshold || 100 < lThreshold) ||
         (0 > lBacklog   || 100 < lBacklog)
       )
       return HRESULT_FROM_WIN32( ERROR_DS_RANGE_CONSTRAINT );
    if ( (lMax < lMin) || (lMax < lMin + lThreshold) )
        return E_INVALIDARG;
    if ( lMin < lThreshold )
        return E_INVALIDARG;
    if ( (1 > lThreshold) && !((lMin == lMax) && (lThreshold == 0)) )
        return E_INVALIDARG;
    
    lRC = RegSetSocketMax( lMax, m_psMachineName );
    if ( ERROR_SUCCESS == lRC )
        lRC = RegSetSocketMin( lMin, m_psMachineName );
    if ( ERROR_SUCCESS == lRC )
        lRC = RegSetSocketThreshold( lThreshold, m_psMachineName );
    if ( ERROR_SUCCESS == lRC )
        lRC = RegSetSocketBacklog( lBacklog, m_psMachineName );
    if ( ERROR_SUCCESS == lRC )
        return S_OK;
    return HRESULT_FROM_WIN32( lRC );
}

/////////////////////////////////////////////////////////////////////////////
// SetSPARequired, public
//
// Purpose: 
//    Set the SPA Required registry key.
//
// Arguments:
//    BOOL bSPARequired : new value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::SetSPARequired( BOOL bSPARequired )
{
    HRESULT hr = S_OK;
    
    if ( TRUE != bSPARequired && FALSE != bSPARequired )
        hr = HRESULT_FROM_WIN32( ERROR_DS_RANGE_CONSTRAINT );
    else
    {
        DWORD dwValue = bSPARequired ? 1 : 0;

        if ( 1 == dwValue )
        {
            CComPtr<IAuthMethod> spIAuthMethod;
            BSTR bstrAuthType;
            
            hr = GetCurrentAuthentication( &spIAuthMethod );
            if ( S_OK == hr )
                hr = spIAuthMethod->get_ID( &bstrAuthType );
            if ( S_OK == hr )
            {
                if ( 0 == _wcsicmp( bstrAuthType, SZ_AUTH_ID_MD5_HASH ))
                    hr = HRESULT_FROM_WIN32( ERROR_DS_INAPPROPRIATE_AUTH );                    
                SysFreeString( bstrAuthType );
            }
        }
        if ( S_OK == hr )
        {
            long lRC = RegSetSPARequired( dwValue, m_psMachineName );
            if ( ERROR_SUCCESS != lRC ) 
                hr = HRESULT_FROM_WIN32( lRC );
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// SetThreadCountPerCPU, public
//
// Purpose: 
//    Set the thread count registry key.
//
// Arguments:
//    long lCount : new value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::SetThreadCountPerCPU( long lCount )
{
    long lRC;
    
    if ( 1 > lCount || 32 < lCount )
        lRC = ERROR_DS_RANGE_CONSTRAINT;
    else
        lRC = RegSetThreadCount( lCount, m_psMachineName );

    if ( ERROR_SUCCESS == lRC )
        return S_OK;
    return HRESULT_FROM_WIN32( lRC );
}

/////////////////////////////////////////////////////////////////////////////
// StartService, public
//
// Purpose: 
//    Ask the Service Control Manager to start the service.
//
// Arguments:
//    
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::StartService( LPWSTR psService )
{
    if ( NULL == psService )
        return E_INVALIDARG;
    
    if ( 0 == _wcsicmp( POP3_SERVICE_NAME, psService ) ||
         0 == _wcsicmp( SMTP_SERVICE_NAME_W, psService ) ||
         0 == _wcsicmp( IISADMIN_SERVICE_NAME, psService ) ||
         0 == _wcsicmp( W3_SERVICE_NAME, psService )
       )
        return _StartService( psService, m_psMachineName );
    else
        return E_INVALIDARG;
}

/////////////////////////////////////////////////////////////////////////////
// StopService, public
//
// Purpose: 
//    Ask the Service Control Manager to stop the service.
//
// Arguments:
//    
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::StopService( LPWSTR psService )
{
    if ( NULL == psService )
        return E_INVALIDARG;
    
    if ( 0 == _wcsicmp( POP3_SERVICE_NAME, psService ) ||
         0 == _wcsicmp( SMTP_SERVICE_NAME_W, psService ) ||
         0 == _wcsicmp( IISADMIN_SERVICE_NAME, psService ) ||
         0 == _wcsicmp( W3_SERVICE_NAME, psService )
       )
        return _StopService( psService, TRUE, m_psMachineName);
    else
        return E_INVALIDARG;
}

/////////////////////////////////////////////////////////////////////////////
// UnlockDomain, public
//
// Purpose: 
//    Unlock all the mailboxes in the domain.
//    This involves renaming all the mailbox lock files so that the Service
//    can once again access them
//    Plus deleting the file in the domain directory.
//
// Arguments:
//    LPWSTR psDomainName : domain to unlock
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::UnlockDomain( LPWSTR psDomainName )
{
    // psDomainName - checked by BuildDomainPath

    HRESULT hr;
    HANDLE  hfSearch;
    WCHAR   sBuffer[POP3_MAX_PATH];
    WCHAR   sDomainPath[POP3_MAX_PATH];
    WCHAR   sLockFile[POP3_MAX_PATH];
    WCHAR   sRenameFile[POP3_MAX_PATH];
    WIN32_FIND_DATA stFindFileData;

    hr = BuildDomainPath( psDomainName, sDomainPath, sizeof( sBuffer )/sizeof(WCHAR) );
    if ( S_OK == hr )
    {   // Directory Search
        wcscpy( sBuffer, sDomainPath );
        if ((sizeof( sBuffer )/sizeof(WCHAR)) > (wcslen( sBuffer ) + wcslen(MAILBOX_PREFIX_W) + wcslen(MAILBOX_EXTENSION_W)) + 2 )
        {
            wcscat( sBuffer, L"\\" );
            wcscat( sBuffer, MAILBOX_PREFIX_W );
            wcscat( sBuffer, L"*" );
            wcscat( sBuffer, MAILBOX_EXTENSION_W );
        }
        else
            hr = E_UNEXPECTED;
        hfSearch = FindFirstFileEx( sBuffer, FindExInfoStandard, &stFindFileData, FindExSearchLimitToDirectories, NULL, 0 );
        if ( INVALID_HANDLE_VALUE == hfSearch )
            hr = HRESULT_FROM_WIN32( GetLastError());
        while ( S_OK == hr )
        {   // Lock each directory (user)
            if ( FILE_ATTRIBUTE_DIRECTORY == ( FILE_ATTRIBUTE_DIRECTORY & stFindFileData.dwFileAttributes ))
            {
                if (( (sizeof( sLockFile )/sizeof(WCHAR)) > ( wcslen( sDomainPath ) + wcslen( stFindFileData.cFileName ) + wcslen( LOCK_FILENAME ) + 2 )) &&
                    ( (sizeof( sRenameFile )/sizeof(WCHAR)) > ( wcslen( sDomainPath ) + wcslen( stFindFileData.cFileName ) + wcslen( LOCKRENAME_FILENAME ) + 2 )))
                {
                    wcscpy( sLockFile, sDomainPath );
                    wcscat( sLockFile, L"\\" );
                    wcscat( sLockFile, stFindFileData.cFileName );
                    wcscat( sLockFile, L"\\" );
                    wcscpy( sRenameFile, sLockFile );
                    wcscat( sLockFile, LOCK_FILENAME );
                    wcscat( sRenameFile, LOCKRENAME_FILENAME );
                    if ( !MoveFile( sRenameFile, sLockFile ))
                    {   // If the rename file does not exist, that is okay.
                        DWORD dwRC = GetLastError();
                        if ( ERROR_FILE_NOT_FOUND != dwRC )
                            hr = HRESULT_FROM_WIN32(dwRC);
                    }
                }
            }
            if ( !FindNextFile( hfSearch, &stFindFileData ))
                hr = HRESULT_FROM_WIN32(GetLastError());
        }
        if ( HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) == hr || HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr )
            hr = S_OK;
        if(INVALID_HANDLE_VALUE!=hfSearch)
        {
            FindClose(hfSearch);
            hfSearch=INVALID_HANDLE_VALUE;
        }
        if ( S_OK == hr )
        {
            if ((sizeof( sBuffer )/sizeof(WCHAR)) > (wcslen( sDomainPath ) + wcslen(LOCKRENAME_FILENAME) + 1 ))
            {
                wcscpy( sBuffer, sDomainPath );
                wcscat( sBuffer, L"\\" );
                wcscat( sBuffer, LOCKRENAME_FILENAME );
                if ( !DeleteFile( sBuffer ))
                    hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// UnlockUser, public
//
// Purpose: 
//    Unlock all the mailboxes in the domain.
//    This involves renaming all the mailbox lock files so that the Service
//    can once again access them
//
// Arguments:
//    LPWSTR psDomainName : domain of user
//    LPWSTR psUserName : user to unlock
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::UnlockUser( LPWSTR psDomainName, LPWSTR psUserName )
{
    // psDomainName - checked by BuildUserPath
    // psUserName - checked by BuildUserPath

    HRESULT hr = S_OK;
    WCHAR   sBuffer[POP3_MAX_PATH];
    WCHAR   sLockFile[POP3_MAX_PATH];
    WCHAR   sRenameFile[POP3_MAX_PATH];

    hr = BuildUserPath( psDomainName, psUserName, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) );
    if ( S_OK == hr )
    {   
        if (( (sizeof( sLockFile )/sizeof(WCHAR)) > ( wcslen( sBuffer ) + wcslen( LOCK_FILENAME ) + 1 )) &&
            ( (sizeof( sRenameFile )/sizeof(WCHAR)) > ( wcslen( sBuffer ) + wcslen( LOCKRENAME_FILENAME ) + 1 )))
        {
            wcscpy( sLockFile, sBuffer );
            wcscat( sLockFile, L"\\" );
            wcscpy( sRenameFile, sLockFile );
            wcscat( sLockFile, LOCK_FILENAME );
            wcscat( sRenameFile, LOCKRENAME_FILENAME );
            if ( !MoveFile( sRenameFile, sLockFile ))
            {   
                DWORD dwRC = GetLastError();
                hr = HRESULT_FROM_WIN32(dwRC);
            }
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// ValidateDomain, public
//
// Purpose: 
//    Validate the Domain.  
//    This involves:
//         Verify it exists in SMTP and our store
//
// Arguments:
//    LPWSTR psDomainName : Domain name to validate
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::ValidateDomain( LPWSTR psDomainName ) const
{
    // psDomainName - checked by ExistsSMTPDomain
     HRESULT hr;

    // Validate the domain in SMTP
    hr = ExistsSMTPDomain( psDomainName );
    if ( HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == hr ) 
        hr = HRESULT_FROM_WIN32( ERROR_NO_SUCH_DOMAIN );
    if ( S_OK == hr )  // Validate the domain in the Store
        hr = ExistsStoreDomain( psDomainName );

    return hr;
}


//////////////////////////////////////////////////////////////////////
// Implementation, private
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CreateDomainMutex, protected
//
// Purpose: 
//    Synchronize access for domain operations.
//
// Arguments:
//    LPWSTR psDomainName : Domain name 
//    HANDLE *hMutex : return value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::CreateDomainMutex( LPWSTR psDomainName, HANDLE *phMutex )
{
    if ( NULL == psDomainName )
        return E_INVALIDARG;
    if ( NULL == phMutex )
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    WCHAR   sName[POP3_MAX_DOMAIN_LENGTH+64];

    *phMutex = NULL;
    if ( (sizeof( sName )/sizeof(WCHAR)) > ( wcslen( DOMAINMUTEX_NAME ) + wcslen( psDomainName )))
    {
        wcscpy( sName, DOMAINMUTEX_NAME );
        wcscat( sName, psDomainName );
        *phMutex = CreateMutex( NULL, TRUE, sName );
    }
    if ( NULL == *phMutex )
    {
        hr = HRESULT_FROM_WIN32( GetLastError());
        if SUCCEEDED( hr ) hr = E_FAIL;
    }
    else if ( ERROR_ALREADY_EXISTS == GetLastError() )
    {
        hr = E_ACCESSDENIED;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CreateUserMutex, protected
//
// Purpose: 
//    Synchronize access for user operations.
//
// Arguments:
//    LPWSTR psDomainName : Domain name 
//    LPWSTR psUserName : User
//    HANDLE *hMutex : return value
//
// Returns: S_OK on success, appropriate HRESULT otherwise
HRESULT CP3AdminWorker::CreateUserMutex( LPWSTR psDomainName, LPWSTR psUserName, HANDLE *phMutex )
{
    if ( NULL == psDomainName )
        return E_INVALIDARG;
    if ( NULL == psUserName )
        return E_INVALIDARG;
    if ( NULL == phMutex )
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    WCHAR   sName[POP3_MAX_ADDRESS_LENGTH+64];

    *phMutex = NULL;
    if ( (sizeof( sName )/sizeof(WCHAR)) > ( wcslen( USERMUTEX_NAME ) + wcslen( psUserName ) + wcslen( psDomainName ) + 1))
    {
        wcscpy( sName, USERMUTEX_NAME );
        wcscat( sName, psUserName );
        wcscat( sName, L"@" );
        wcscat( sName, psDomainName );
        *phMutex = CreateMutex( NULL, TRUE, sName );
    }
    if ( NULL == *phMutex )
    {
        hr = HRESULT_FROM_WIN32( GetLastError());
        if SUCCEEDED( hr ) hr = E_FAIL;
    }
    else if ( ERROR_ALREADY_EXISTS == GetLastError() )
        hr = E_ACCESSDENIED;

    return hr;
}

HRESULT CP3AdminWorker::AddSMTPDomain( LPWSTR psDomainName )
{
    HRESULT hr;
    WCHAR   sBuffer[POP3_MAX_PATH];
    _bstr_t _bstrClass( L"IIsSmtpDomain" );
    _variant_t _v;
    CComPtr<IADsContainer> spIADsContainer;
    CComPtr<IADs> spIADs;
    CComPtr<IDispatch> spIDispatch = NULL;
    _bstr_t _bstrDomain = psDomainName;

    hr = GetSMTPDomainPath( sBuffer, NULL, sizeof( sBuffer )/sizeof( WCHAR ));
    if ( S_OK == hr )
        hr = ADsGetObject( sBuffer, IID_IADsContainer, reinterpret_cast<LPVOID*>( &spIADsContainer ));
    if ( SUCCEEDED( hr ))
    {   // Invoke the create method on the container object to create the new object of default class, in this case, IIsSmtpDomain.
        hr = spIADsContainer->Create( _bstrClass, _bstrDomain, &spIDispatch );
        if SUCCEEDED( hr )
        {    // Get the newly created object
            hr = spIDispatch->QueryInterface( IID_IADs, reinterpret_cast<LPVOID*>( &spIADs ));
            if SUCCEEDED( hr )
            {
                _v.vt = VT_I4;
                _v.lVal = SMTP_DELIVER; // This is what David Braun told us to do!  SMTP_ALIAS;   // This is what the native tool sets
                hr = spIADs->Put( L"RouteAction", _v );
                if SUCCEEDED( hr )
                    hr = spIADs->SetInfo();
            }
        }
    }

    return hr;
}

HRESULT CP3AdminWorker::AddStoreDomain( LPWSTR psDomainName )
{
    // psDomainName - checked by ExistsStoreDomain
    HRESULT hr;
    WCHAR   sBuffer[POP3_MAX_PATH];

    hr = ExistsStoreDomain( psDomainName );
    if SUCCEEDED( hr ) 
        hr = HRESULT_FROM_WIN32( ERROR_FILE_EXISTS );
    else if ( HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == hr )
        hr = S_OK;
    if SUCCEEDED( hr ) 
    {
        hr = BuildDomainPath( psDomainName, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) );
        if ( S_OK == hr )
        {   
            if ( !CreateDirectory( sBuffer, NULL ))
            {
                hr = HRESULT_FROM_WIN32( GetLastError());
                if SUCCEEDED( hr ) hr = E_FAIL;
            }
        }
        else
            if SUCCEEDED( hr ) hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT CP3AdminWorker::BuildDomainPath( LPCWSTR psDomainName, LPWSTR psBuffer, DWORD dwBufferSize ) const
{
    if ( NULL == psDomainName )
        return E_INVALIDARG;
    if ( NULL == psBuffer )
        return E_INVALIDARG;
    
    USES_CONVERSION;
    HRESULT hr = S_OK;
    LPCWSTR  psMailRoot;

    if ( NULL != m_psMachineMailRoot )
        psMailRoot = m_psMachineMailRoot;
    else
        psMailRoot = CMailBox::GetMailRoot();
    
    if ( (NULL != psMailRoot) && ( 0 < wcslen( psMailRoot )) && (wcslen( psMailRoot ) + wcslen( psDomainName ) + 1) < dwBufferSize )
    {   // build the path to the mail dir \MailRoot\Domain
        wcscpy( psBuffer, psMailRoot );
        wcscat( psBuffer, L"\\" );
        wcscat( psBuffer, psDomainName );
    }
    else
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        if SUCCEEDED( hr ) hr = E_FAIL;
    }
    
    return hr;
}

HRESULT CP3AdminWorker::BuildEmailAddr( LPCWSTR psDomainName, LPCWSTR psUserName, LPWSTR psEmailAddr, DWORD dwBufferSize ) const
{
    if ( NULL == psDomainName )
        return E_INVALIDARG;
    if ( NULL == psUserName )
        return E_INVALIDARG;
    if ( NULL == psEmailAddr )
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    
    if ( ( wcslen( psDomainName ) + wcslen( psUserName ) + 1 ) < dwBufferSize )
    {   // build the emailaddress
         wcscpy( psEmailAddr, psUserName );
         wcscat( psEmailAddr, L"@" );
         wcscat( psEmailAddr, psDomainName );
    }
    else
        hr = E_UNEXPECTED;
    return hr;
}

HRESULT CP3AdminWorker::BuildEmailAddrW2A( LPCWSTR psDomainName, LPCWSTR psUserName, LPSTR psEmailAddr, DWORD dwBufferSize ) const
{
    if ( NULL == psDomainName )
        return E_INVALIDARG;
    if ( NULL == psUserName )
        return E_INVALIDARG;
    if ( NULL == psEmailAddr )
        return E_INVALIDARG;

    USES_CONVERSION;
    HRESULT hr = S_OK;
    
    if ( ( wcslen( psDomainName ) + wcslen( psUserName ) + 1 ) < dwBufferSize )
    {   // build the emailaddress
         strcpy( psEmailAddr, W2A( psUserName ));
         strcat( psEmailAddr, "@" );
         strcat( psEmailAddr, W2A( psDomainName ));
    }
    else
        hr = E_UNEXPECTED;
    return hr;
}

HRESULT CP3AdminWorker::BuildUserPath( LPCWSTR psDomainName, LPCWSTR psUserName, LPWSTR psBuffer, DWORD dwBufferSize ) const
{
    // psDomainName - checked by BuildDomainPath
    // psBuffer - checked by BuildDomainPath
    if ( NULL == psUserName )
        return E_INVALIDARG;
    
    HRESULT hr;

    hr = BuildDomainPath( psDomainName, psBuffer, dwBufferSize );
    if (S_OK == hr) 
    {
        if ( (wcslen( psBuffer ) + wcslen( MAILBOX_PREFIX_W ) + wcslen( psUserName ) + wcslen( MAILBOX_EXTENSION_W ) + 1) < dwBufferSize )
        {   // build the path to the mail dir \MailRoot\Domain\User
            wcscat( psBuffer, L"\\" );
            wcscat( psBuffer, MAILBOX_PREFIX_W );
            wcscat( psBuffer, psUserName );
            wcscat( psBuffer, MAILBOX_EXTENSION_W );
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

bool CP3AdminWorker::ExistsDomain( LPWSTR psDomainName ) const
{
    // psDomainName - checked by ExistsSMTPDomain
    HRESULT hr;

    hr = ExistsSMTPDomain( psDomainName );
    if SUCCEEDED( hr )
        hr = ExistsStoreDomain( psDomainName );

    return SUCCEEDED( hr ) ? true : false;
}

HRESULT CP3AdminWorker::ExistsSMTPDomain( LPWSTR psDomainName ) const
{
    if ( NULL == psDomainName )
        return E_INVALIDARG;
    if ( !m_isPOP3Installed )
        return S_OK;    // By pass checking if running in Pop2Exch scenario.
    
    HRESULT hr = E_INVALIDARG;
    WCHAR   sBuffer[POP3_MAX_PATH];
    _variant_t _v;
    CComPtr<IADs> spIADs;

    hr = GetSMTPDomainPath( sBuffer, psDomainName, sizeof( sBuffer )/sizeof( WCHAR ));
    if ( S_OK == hr )
       hr = ADsGetObject( sBuffer, IID_IADs, reinterpret_cast<LPVOID*>( &spIADs ));

    return hr;
}

HRESULT CP3AdminWorker::ExistsStoreDomain( LPWSTR psDomainName ) const
{
    if ( NULL == psDomainName )
        return E_INVALIDARG;
    
    HRESULT hr = S_OK;
    WCHAR   sBuffer[POP3_MAX_PATH];
    DWORD   dwAttrib;

    // Valid Domain Name? || DNS_ERROR_NON_RFC_NAME == dnStatus
    DNS_STATUS dnStatus = DnsValidateName_W( psDomainName, DnsNameDomain );
    hr = ( ERROR_SUCCESS == dnStatus ) ? S_OK : HRESULT_FROM_WIN32( ERROR_INVALID_DOMAINNAME );

    if ( S_OK == hr )
    {   
        hr = BuildDomainPath( psDomainName, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) );
        if ( S_OK == hr )
        {   // Check the existance of the dir
            dwAttrib = GetFileAttributes( sBuffer );
            if ( (ERROR_NO_FILE_ATTR == dwAttrib) || (FILE_ATTRIBUTE_DIRECTORY != ( FILE_ATTRIBUTE_DIRECTORY & dwAttrib )) )
            {   // Domain does not exist!
                hr = HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND );
            }
        }
        else
            if SUCCEEDED( hr ) hr = E_UNEXPECTED;
    }

    return hr;
}

HRESULT CP3AdminWorker::GetSMTPDomainPath( LPWSTR psBuffer, LPWSTR psSuffix, DWORD dwBufferSize ) const
{
    if ( NULL == psBuffer )
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    DWORD   dwSuffixLength = 0;

    if ( NULL != psSuffix )
        dwSuffixLength = wcslen( psSuffix ) + 1;
    
    if ( NULL == m_psMachineName )
    {   // Local
        if ( (wcslen( ADS_SMTPDOMAIN_PATH_LOCAL ) + dwSuffixLength) < dwBufferSize )
            wcscpy( psBuffer, ADS_SMTPDOMAIN_PATH_LOCAL );
        else
            hr = E_FAIL;
    }
    else
    {   // Remote
        if ( (wcslen( ADS_SMTPDOMAIN_PATH_REMOTE ) + wcslen( m_psMachineName ) + dwSuffixLength) < dwBufferSize )
            swprintf( psBuffer, ADS_SMTPDOMAIN_PATH_REMOTE, m_psMachineName );
        else
            hr = E_FAIL;
    }
    if ( S_OK == hr && NULL != psSuffix )
    {
        wcscat( psBuffer, L"/" );
        wcscat( psBuffer, psSuffix );
    }
    
    return hr;
}

HRESULT CP3AdminWorker::RemoveSMTPDomain( LPWSTR psDomainName )
{
    HRESULT hr;
    WCHAR   sBuffer[POP3_MAX_PATH];
    _bstr_t _bstrClass( L"IIsSmtpDomain" );
    _variant_t _v;
    CComPtr<IADsContainer> spIADsContainer;
    CComPtr<IADs> spIADs;
    _bstr_t _bstrDomain = psDomainName;

    hr = GetSMTPDomainPath( sBuffer, NULL, sizeof( sBuffer )/sizeof( WCHAR ));
    if ( S_OK == hr )
        hr = ADsGetObject( sBuffer, IID_IADsContainer, reinterpret_cast<LPVOID*>( &spIADsContainer ));
    if ( SUCCEEDED( hr ))
    {
        hr = spIADsContainer->Delete( _bstrClass, _bstrDomain );
        if SUCCEEDED( hr )
        {    // Commit the change
            hr = spIADsContainer->QueryInterface( IID_IADs, reinterpret_cast<LPVOID*>( &spIADs ));
            if SUCCEEDED( hr )
                hr = spIADs->SetInfo();
        }
    }

    return hr;
}

HRESULT CP3AdminWorker::RemoveStoreDomain( LPWSTR psDomainName )
{
    // psDomainName - checked by ExistsStoreDomain
 
    HRESULT hr = S_OK;
    WCHAR   sBuffer[POP3_MAX_PATH];

    hr = ExistsStoreDomain( psDomainName );
    if SUCCEEDED( hr ) 
    {
        hr = BuildDomainPath( psDomainName, sBuffer, sizeof( sBuffer )/sizeof(WCHAR));
        if ( S_OK == hr )
        {
            if ( !BDeleteDirTree( sBuffer ))
            {
                hr = HRESULT_FROM_WIN32( GetLastError());
                if SUCCEEDED( hr ) hr = E_FAIL;
            }
        }
        else
            if SUCCEEDED( hr ) hr = E_UNEXPECTED;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\msmq\tools\dblib\include\sqlfront.h ===
#ifndef _INC_SQLFRONT
#define _INC_SQLFRONT

#ifdef DBNTWIN32
	#ifndef _WINDOWS_
		#pragma message (__FILE__ " : db-library error: windows.h must be included before sqlfront.h.")
	#endif
#endif

#ifdef __cplusplus
	extern "C" {
#endif

/*****************************************************************************
*                                                                            *
*     SQLFRONT.H - DB-Library header file for the Microsoft SQL Server.      *
*                                                                            *
*     Copyright (c) 1989 - 1995 by Microsoft Corp.  All rights reserved.     *
*                                                                            *
* All constant and macro definitions for DB-Library applications programming *
* are contained in this file.  This file must be included before SQLDB.H and *
* one of the following #defines must be made, depending on the operating     *
* system: DBMSDOS, DBMSWIN or DBNTWIN32.                                     *
*                                                                            *
*****************************************************************************/


/*****************************************************************************
* Datatype definitions                                                       *
*****************************************************************************/

// Note this has changed because Windows 3.1 defines API as 'pascal far'

#if !defined(M_I86SM) && !defined(DBNTWIN32)
#define SQLAPI cdecl far
#else
#define SQLAPI _cdecl
#endif

#ifndef  API
#define  API  SQLAPI
#endif

#ifndef DOUBLE
typedef double DOUBLE;
#endif


/*****************************************************************************
* DBPROCESS, LOGINREC and DBCURSOR                                           *
*****************************************************************************/

#define DBPROCESS void   // dbprocess structure type
#define LOGINREC  void   // login record type
#define DBCURSOR  void   // cursor record type
#define DBHANDLE  void   // generic handle

// DOS Specific
#ifdef DBMSDOS
typedef DBPROCESS * PDBPROCESS;
typedef LOGINREC  * PLOGINREC;
typedef DBCURSOR  * PDBCURSOR;
typedef DBHANDLE  * PDBHANDLE;
#define PTR *
#endif


// WIN 3.x Specific.  The handle pointers are near for Windows 3.x
#ifdef DBMSWIN
typedef DBPROCESS near * PDBPROCESS;
typedef LOGINREC  near * PLOGINREC;
typedef DBCURSOR  near * PDBCURSOR;
typedef DBHANDLE  near * PDBHANDLE;
#define PTR far *
#endif


// Windows NT Specific
#ifdef DBNTWIN32
typedef DBPROCESS * PDBPROCESS;
typedef LOGINREC  * PLOGINREC;
typedef DBCURSOR  * PDBCURSOR;
typedef DBHANDLE  * PDBHANDLE;
#define PTR *
typedef int (SQLAPI *SQLFARPROC)();
#else
typedef long (far pascal *LGFARPROC)();  // Windows loadable driver fp
#endif


/*****************************************************************************
* Win32 compatibility datatype definitions                                   *
* Note: The following datatypes are provided for Win32 compatibility.        *
* Since some of the datatypes are already defined in unrelated include files *
* there may definition duplication.  Every attempt has been made to check    *
* for such problems.                                                         *
*****************************************************************************/

#ifndef DBNTWIN32

#ifndef SHORT
typedef short SHORT;
#endif

#ifndef INT
typedef int INT;
#endif

#ifndef UINT
typedef unsigned int UINT;
#endif

#ifndef USHORT
typedef unsigned short USHORT;
#endif

#ifndef ULONG
typedef unsigned long ULONG;
#endif

#ifndef CHAR
typedef char CHAR;
#endif

#ifndef LPINT
typedef INT PTR LPINT;
#endif

typedef unsigned char BYTE;

typedef       CHAR PTR LPSTR;
typedef       BYTE PTR LPBYTE;
typedef       void PTR LPVOID;	
typedef const CHAR PTR LPCSTR;

typedef int BOOL;

#endif


/*****************************************************************************
* DB-Library datatype definitions                                            *
*****************************************************************************/

#define DBMAXCHAR 256 // Max length of DBVARBINARY and DBVARCHAR, etc.

#ifndef DBTYPEDEFS    // srv.h (Open Server include) not already included

#define DBTYPEDEFS

#define RETCODE INT
#define STATUS INT

// DB-Library datatypes
typedef char            DBCHAR;
typedef unsigned char   DBBINARY;
typedef unsigned char   DBTINYINT;
typedef short           DBSMALLINT;
typedef unsigned short  DBUSMALLINT;
typedef long            DBINT;
typedef double          DBFLT8;
typedef unsigned char   DBBIT;
typedef unsigned char   DBBOOL;
typedef float           DBFLT4;
typedef long            DBMONEY4;

typedef DBFLT4 DBREAL;
typedef UINT   DBUBOOL;

typedef struct dbdatetime4
{
	USHORT numdays;        // No of days since Jan-1-1900
	USHORT nummins;        // No. of minutes since midnight
} DBDATETIM4;


typedef struct dbvarychar
{
	DBSMALLINT  len;
	DBCHAR      str[DBMAXCHAR];
} DBVARYCHAR;

typedef struct dbvarybin
{
	DBSMALLINT  len;
	BYTE        array[DBMAXCHAR];
} DBVARYBIN;

typedef struct dbmoney
{
	DBINT mnyhigh;
	ULONG mnylow;
} DBMONEY;

typedef struct dbdatetime
{
	DBINT dtdays;
	ULONG dttime;
} DBDATETIME;

// DBDATEREC structure used by dbdatecrack
typedef struct dbdaterec
{
	INT     year;         // 1753 - 9999
	INT     quarter;      // 1 - 4
	INT     month;        // 1 - 12
	INT     dayofyear;    // 1 - 366
	INT     day;          // 1 - 31
	INT     week;         // 1 - 54 (for leap years)
	INT     weekday;      // 1 - 7  (Mon - Sun)
	INT     hour;         // 0 - 23
	INT     minute;       // 0 - 59
	INT     second;       // 0 - 59
	INT     millisecond;  // 0 - 999
} DBDATEREC;

#define MAXNUMERICLEN 16
#define MAXNUMERICDIG 38

#define DEFAULTPRECISION 18
#define DEFAULTSCALE     0

typedef struct dbnumeric
{
	BYTE precision;
	BYTE scale;
	BYTE sign; // 1 = Positive, 0 = Negative
	BYTE val[MAXNUMERICLEN];
} DBNUMERIC;

typedef DBNUMERIC DBDECIMAL;


// Pack the following structures on a word boundary
#ifdef __BORLANDC__
#pragma option -a+
#else
	#ifndef DBLIB_SKIP_PRAGMA_PACK   // Define this if your compiler does not support #pragma pack()
	#pragma pack(2)
    #pragma warning(disable: 4121)   // alignment of a member was sensitive to packing
	#endif
#endif

#define MAXCOLNAMELEN 30
#define MAXTABLENAME  30

typedef struct
{
	DBINT SizeOfStruct;
	CHAR  Name[MAXCOLNAMELEN+1];
	CHAR  ActualName[MAXCOLNAMELEN+1];
	CHAR  TableName[MAXTABLENAME+1];
	SHORT Type;
	DBINT UserType;
	DBINT MaxLength;
	BYTE  Precision;
	BYTE  Scale;
	BOOL  VarLength;     // TRUE, FALSE
	BYTE  Null;          // TRUE, FALSE or DBUNKNOWN
	BYTE  CaseSensitive; // TRUE, FALSE or DBUNKNOWN
	BYTE  Updatable;     // TRUE, FALSE or DBUNKNOWN
	BOOL  Identity;      // TRUE, FALSE
} DBCOL, PTR LPDBCOL;


#define MAXSERVERNAME 30
#define MAXNETLIBNAME 255
#define MAXNETLIBCONNSTR 255

typedef struct
{
	DBINT  SizeOfStruct;
	BYTE   ServerType;
	USHORT ServerMajor;
	USHORT ServerMinor;
	USHORT ServerRevision;
	CHAR   ServerName[MAXSERVERNAME+1];
	CHAR   NetLibName[MAXNETLIBNAME+1];
	CHAR   NetLibConnStr[MAXNETLIBCONNSTR+1];
} DBPROCINFO, PTR LPDBPROCINFO;

typedef struct
{
	DBINT SizeOfStruct;   // Use sizeof(DBCURSORINFO)
	ULONG TotCols;        // Total Columns in cursor
	ULONG TotRows;        // Total Rows in cursor
	ULONG CurRow;         // Current actual row in server
	ULONG TotRowsFetched; // Total rows actually fetched
	ULONG Type;           // See CU_...
	ULONG Status;         // See CU_...
} DBCURSORINFO, PTR LPDBCURSORINFO;

#define INVALID_UROWNUM ((ULONG)(-1))

// Reset default alignment
#ifdef __BORLANDC__
#pragma option -a-
#else
	#ifndef DBLIB_SKIP_PRAGMA_PACK   // Define this if your compiler does not support #pragma pack()
	#pragma pack()
    #pragma warning(default: 4121)   // alignment of a member was sensitive to packing
	#endif
#endif


#endif // End DBTYPEDEFS


/*****************************************************************************
* Pointer Datatypes                                                          *
*****************************************************************************/

typedef const LPINT          LPCINT;
#ifndef _LPCBYTE_DEFINED
typedef const LPBYTE         LPCBYTE ;
#endif
typedef       USHORT PTR     LPUSHORT;
typedef const LPUSHORT       LPCUSHORT;
typedef       DBINT PTR      LPDBINT;
typedef const LPDBINT        LPCDBINT;
typedef       DBBINARY PTR   LPDBBINARY;
typedef const LPDBBINARY     LPCDBBINARY;
typedef       DBDATEREC PTR  LPDBDATEREC;
typedef const LPDBDATEREC    LPCDBDATEREC;
typedef       DBDATETIME PTR LPDBDATETIME;
typedef const LPDBDATETIME   LPCDBDATETIME;


/*****************************************************************************
* General #defines                                                           *
*****************************************************************************/

#define TIMEOUT_IGNORE (ULONG)-1
#define TIMEOUT_INFINITE (ULONG)0
#define TIMEOUT_MAXIMUM (ULONG)1200 // 20 minutes maximum timeout value

// Used for ServerType in dbgetprocinfo
#define SERVTYPE_UNKNOWN   0
#define SERVTYPE_MICROSOFT 1

// Used by dbcolinfo
enum CI_TYPES { CI_REGULAR=1, CI_ALTERNATE=2, CI_CURSOR=3 };

// Bulk Copy Definitions (bcp)
#define DB_IN	1         // Transfer from client to server
#define DB_OUT	2         // Transfer from server to client

#define BCPMAXERRS   1    // bcp_control parameter
#define BCPFIRST     2    // bcp_control parameter
#define BCPLAST      3    // bcp_control parameter
#define BCPBATCH     4    // bcp_control parameter
#define BCPKEEPNULLS 5    // bcp_control parameter
#define BCPABORT     6    // bcp_control parameter

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#define TINYBIND         1
#define SMALLBIND        2
#define INTBIND          3
#define CHARBIND         4
#define BINARYBIND       5
#define BITBIND          6
#define DATETIMEBIND     7
#define MONEYBIND        8
#define FLT8BIND         9
#define STRINGBIND      10
#define NTBSTRINGBIND   11
#define VARYCHARBIND    12
#define VARYBINBIND     13
#define FLT4BIND        14
#define SMALLMONEYBIND  15
#define SMALLDATETIBIND 16
#define DECIMALBIND     17
#define NUMERICBIND     18
#define SRCDECIMALBIND  19
#define SRCNUMERICBIND  20
#define MAXBIND         SRCNUMERICBIND

#define DBSAVE          1
#define DBNOSAVE        0

#define DBNOERR         -1
#define DBFINDONE       0x04  // Definately done
#define DBMORE          0x10  // Maybe more commands waiting
#define DBMORE_ROWS     0x20  // This command returned rows

#define MAXNAME         31


#define DBTXTSLEN       8     // Timestamp length

#define DBTXPLEN        16    // Text pointer length

// Error code returns
#define INT_EXIT        0
#define INT_CONTINUE    1
#define INT_CANCEL      2


// dboptions
#define DBBUFFER        0
#define DBOFFSET        1
#define DBROWCOUNT      2
#define DBSTAT          3
#define DBTEXTLIMIT     4
#define DBTEXTSIZE      5
#define DBARITHABORT    6
#define DBARITHIGNORE   7
#define DBNOAUTOFREE    8
#define DBNOCOUNT       9
#define DBNOEXEC        10
#define DBPARSEONLY     11
#define DBSHOWPLAN      12
#define DBSTORPROCID		13

#if defined(DBMSWIN) || defined(DBNTWIN32)
#define DBANSItoOEM		14
#endif

#ifdef DBNTWIN32
#define DBOEMtoANSI		15
#endif

#define DBCLIENTCURSORS 16
#define DBSETTIME 17
#define DBQUOTEDIDENT 18


// Data Type Tokens
#define SQLVOID        0x1f
#define SQLTEXT        0x23
#define SQLVARBINARY   0x25
#define SQLINTN        0x26
#define SQLVARCHAR     0x27
#define SQLBINARY      0x2d
#define SQLIMAGE       0x22
#define SQLCHAR        0x2f
#define SQLINT1        0x30
#define SQLBIT         0x32
#define SQLINT2        0x34
#define SQLINT4        0x38
#define SQLMONEY       0x3c
#define SQLDATETIME    0x3d
#define SQLFLT8        0x3e
#define SQLFLTN        0x6d
#define SQLMONEYN      0x6e
#define SQLDATETIMN    0x6f
#define SQLFLT4        0x3b
#define SQLMONEY4      0x7a
#define SQLDATETIM4    0x3a
#define SQLDECIMAL     0x6a
#define SQLNUMERIC     0x6c

// Data stream tokens
#define SQLCOLFMT      0xa1
#define OLD_SQLCOLFMT  0x2a
#define SQLPROCID      0x7c
#define SQLCOLNAME     0xa0
#define SQLTABNAME     0xa4
#define SQLCOLINFO     0xa5
#define SQLALTNAME     0xa7
#define SQLALTFMT      0xa8
#define SQLERROR       0xaa
#define SQLINFO        0xab
#define SQLRETURNVALUE 0xac
#define SQLRETURNSTATUS 0x79
#define SQLRETURN      0xdb
#define SQLCONTROL     0xae
#define SQLALTCONTROL  0xaf
#define SQLROW         0xd1
#define SQLALTROW      0xd3
#define SQLDONE        0xfd
#define SQLDONEPROC    0xfe
#define SQLDONEINPROC  0xff
#define SQLOFFSET      0x78
#define SQLORDER       0xa9
#define SQLLOGINACK    0xad // NOTICE: change to real value

// Ag op tokens
#define SQLAOPCNT		0x4b
#define SQLAOPSUM    0x4d
#define SQLAOPAVG    0x4f
#define SQLAOPMIN    0x51
#define SQLAOPMAX    0x52
#define SQLAOPANY    0x53
#define SQLAOPNOOP   0x56

// Error numbers (dberrs) DB-Library error codes
#define SQLEMEM         10000
#define SQLENULL        10001
#define SQLENLOG        10002
#define SQLEPWD         10003
#define SQLECONN        10004
#define SQLEDDNE        10005
#define SQLENULLO       10006
#define SQLESMSG        10007
#define SQLEBTOK        10008
#define SQLENSPE        10009
#define SQLEREAD        10010
#define SQLECNOR        10011
#define SQLETSIT        10012
#define SQLEPARM        10013
#define SQLEAUTN        10014
#define SQLECOFL        10015
#define SQLERDCN        10016
#define SQLEICN         10017
#define SQLECLOS        10018
#define SQLENTXT        10019
#define SQLEDNTI        10020
#define SQLETMTD        10021
#define SQLEASEC        10022
#define SQLENTLL        10023
#define SQLETIME        10024
#define SQLEWRIT        10025
#define SQLEMODE        10026
#define SQLEOOB         10027
#define SQLEITIM        10028
#define SQLEDBPS        10029
#define SQLEIOPT        10030
#define SQLEASNL        10031
#define SQLEASUL        10032
#define SQLENPRM        10033
#define SQLEDBOP        10034
#define SQLENSIP        10035
#define SQLECNULL       10036
#define SQLESEOF        10037
#define SQLERPND        10038
#define SQLECSYN        10039
#define SQLENONET       10040
#define SQLEBTYP        10041
#define SQLEABNC        10042
#define SQLEABMT        10043
#define SQLEABNP        10044
#define SQLEBNCR        10045
#define SQLEAAMT        10046
#define SQLENXID        10047
#define SQLEIFNB        10048
#define SQLEKBCO        10049
#define SQLEBBCI        10050
#define SQLEKBCI        10051
#define SQLEBCWE        10052
#define SQLEBCNN        10053
#define SQLEBCOR        10054
#define SQLEBCPI        10055
#define SQLEBCPN        10056
#define SQLEBCPB        10057
#define SQLEVDPT        10058
#define SQLEBIVI        10059
#define SQLEBCBC        10060
#define SQLEBCFO        10061
#define SQLEBCVH        10062
#define SQLEBCUO        10063
#define SQLEBUOE        10064
#define SQLEBWEF        10065
#define SQLEBTMT        10066
#define SQLEBEOF        10067
#define SQLEBCSI        10068
#define SQLEPNUL        10069
#define SQLEBSKERR      10070
#define SQLEBDIO        10071
#define SQLEBCNT        10072
#define SQLEMDBP        10073
#define SQLINIT         10074
#define SQLCRSINV       10075
#define SQLCRSCMD       10076
#define SQLCRSNOIND     10077
#define SQLCRSDIS       10078
#define SQLCRSAGR       10079
#define SQLCRSORD       10080
#define SQLCRSMEM       10081
#define SQLCRSBSKEY     10082
#define SQLCRSNORES     10083
#define SQLCRSVIEW      10084
#define SQLCRSBUFR      10085
#define SQLCRSFROWN     10086
#define SQLCRSBROL      10087
#define SQLCRSFRAND     10088
#define SQLCRSFLAST     10089
#define SQLCRSRO        10090
#define SQLCRSTAB       10091
#define SQLCRSUPDTAB    10092
#define SQLCRSUPDNB     10093
#define SQLCRSVIIND     10094
#define SQLCRSNOUPD     10095
#define SQLCRSOS2       10096
#define SQLEBCSA        10097
#define SQLEBCRO        10098
#define SQLEBCNE        10099
#define SQLEBCSK        10100
#define SQLEUVBF        10101
#define SQLEBIHC        10102
#define SQLEBWFF        10103
#define SQLNUMVAL       10104
#define SQLEOLDVR       10105
#define SQLEBCPS	10106
#define SQLEDTC 	10107
#define SQLENOTIMPL	10108
#define SQLENONFLOAT	10109
#define SQLECONNFB   10110


// The severity levels are defined here
#define EXINFO          1  // Informational, non-error
#define EXUSER          2  // User error
#define EXNONFATAL      3  // Non-fatal error
#define EXCONVERSION    4  // Error in DB-LIBRARY data conversion
#define EXSERVER        5  // The Server has returned an error flag
#define EXTIME          6  // We have exceeded our timeout period while
                           // waiting for a response from the Server - the
                           // DBPROCESS is still alive
#define EXPROGRAM       7  // Coding error in user program
#define EXRESOURCE      8  // Running out of resources - the DBPROCESS may be dead
#define EXCOMM          9  // Failure in communication with Server - the DBPROCESS is dead
#define EXFATAL         10 // Fatal error - the DBPROCESS is dead
#define EXCONSISTENCY   11 // Internal software error  - notify MS Technical Supprt

// Offset identifiers
#define OFF_SELECT      0x16d
#define OFF_FROM        0x14f
#define OFF_ORDER       0x165
#define OFF_COMPUTE     0x139
#define OFF_TABLE       0x173
#define OFF_PROCEDURE   0x16a
#define OFF_STATEMENT   0x1cb
#define OFF_PARAM       0x1c4
#define OFF_EXEC        0x12c

// Print lengths for certain fixed length data types
#define PRINT4     11
#define PRINT2     6
#define PRINT1     3
#define PRFLT8     20
#define PRMONEY    26
#define PRBIT      3
#define PRDATETIME 27
#define PRDECIMAL (MAXNUMERICDIG + 2)
#define PRNUMERIC (MAXNUMERICDIG + 2)

#define SUCCEED  1
#define FAIL     0
#define SUCCEED_ABORT 2

#define DBUNKNOWN 2

#define MORE_ROWS    -1
#define NO_MORE_ROWS -2
#define REG_ROW      MORE_ROWS
#define BUF_FULL     -3

// Status code for dbresults(). Possible return values are
// SUCCEED, FAIL, and NO_MORE_RESULTS.
#define NO_MORE_RESULTS 2
#define NO_MORE_RPC_RESULTS 3

// Macros for dbsetlname()
#define DBSETHOST 1
#define DBSETUSER 2
#define DBSETPWD  3
#define DBSETAPP  4
#define DBSETID   5
#define DBSETLANG 6
#define DBSETSECURE 7
#define DBVER42    8
#define DBVER60    9
#define DBSETLOGINTIME 10
#define DBSETFALLBACK 12

// Standard exit and error values
#define STDEXIT  0
#define ERREXIT  -1

// dbrpcinit flags
#define DBRPCRECOMPILE  0x0001
#define DBRPCRESET      0x0004
#define DBRPCCURSOR     0x0008

// dbrpcparam flags
#define DBRPCRETURN     0x1
#define DBRPCDEFAULT    0x2


// Cursor related constants

// Following flags are used in the concuropt parameter in the dbcursoropen function
#define CUR_READONLY 1 // Read only cursor, no data modifications
#define CUR_LOCKCC   2 // Intent to update, all fetched data locked when
                       // dbcursorfetch is called inside a transaction block
#define CUR_OPTCC    3 // Optimistic concurrency control, data modifications
                       // succeed only if the row hasn't been updated since
                       // the last fetch.
#define CUR_OPTCCVAL 4 // Optimistic concurrency control based on selected column values

// Following flags are used in the scrollopt parameter in dbcursoropen
#define CUR_FORWARD 0       // Forward only scrolling
#define CUR_KEYSET  -1      // Keyset driven scrolling
#define CUR_DYNAMIC 1       // Fully dynamic
#define CUR_INSENSITIVE -2  // Server-side cursors only

// Following flags define the fetchtype in the dbcursorfetch function
#define FETCH_FIRST    1  // Fetch first n rows
#define FETCH_NEXT     2  // Fetch next n rows
#define FETCH_PREV     3  // Fetch previous n rows
#define FETCH_RANDOM   4  // Fetch n rows beginning with given row #
#define FETCH_RELATIVE 5  // Fetch relative to previous fetch row #
#define FETCH_LAST     6  // Fetch the last n rows

// Following flags define the per row status as filled by dbcursorfetch and/or dbcursorfetchex
#define FTC_EMPTY         0x00  // No row available
#define FTC_SUCCEED       0x01  // Fetch succeeded, (failed if not set)
#define FTC_MISSING       0x02  // The row is missing
#define FTC_ENDOFKEYSET   0x04  // End of the keyset reached
#define FTC_ENDOFRESULTS  0x08  // End of results set reached

// Following flags define the operator types for the dbcursor function
#define CRS_UPDATE   1  // Update operation
#define CRS_DELETE   2  // Delete operation
#define CRS_INSERT   3  // Insert operation
#define CRS_REFRESH  4  // Refetch given row
#define CRS_LOCKCC   5  // Lock given row

// Following value can be passed to the dbcursorbind function for NOBIND type
#define NOBIND -2       // Return length and pointer to data

// Following are values used by DBCURSORINFO's Type parameter
#define CU_CLIENT        0x00000001
#define CU_SERVER        0x00000002
#define CU_KEYSET        0x00000004
#define CU_MIXED         0x00000008
#define CU_DYNAMIC       0x00000010
#define CU_FORWARD       0x00000020
#define CU_INSENSITIVE   0x00000040
#define CU_READONLY      0x00000080
#define CU_LOCKCC        0x00000100
#define CU_OPTCC         0x00000200
#define CU_OPTCCVAL      0x00000400

// Following are values used by DBCURSORINFO's Status parameter
#define CU_FILLING       0x00000001
#define CU_FILLED        0x00000002


// Following are values used by dbupdatetext's type parameter
#define UT_TEXTPTR      0x0001
#define UT_TEXT         0x0002
#define UT_MORETEXT     0x0004
#define UT_DELETEONLY   0x0008
#define UT_LOG          0x0010


// The following values are passed to dbserverenum for searching criteria.
#define NET_SEARCH  0x0001
#define LOC_SEARCH  0x0002

// These constants are the possible return values from dbserverenum.
#define ENUM_SUCCESS         0x0000
#define MORE_DATA            0x0001
#define NET_NOT_AVAIL        0x0002
#define OUT_OF_MEMORY        0x0004
#define NOT_SUPPORTED        0x0008
#define ENUM_INVALID_PARAM   0x0010


// Netlib Error problem codes.  ConnectionError() should return one of
// these as the dblib-mapped problem code, so the corresponding string
// is sent to the dblib app's error handler as dberrstr.  Return NE_E_NOMAP
// for a generic DB-Library error string (as in prior versions of dblib).

#define NE_E_NOMAP              0   // No string; uses dblib default.
#define NE_E_NOMEMORY           1   // Insufficient memory.
#define NE_E_NOACCESS           2   // Access denied.
#define NE_E_CONNBUSY           3   // Connection is busy.
#define NE_E_CONNBROKEN         4   // Connection broken.
#define NE_E_TOOMANYCONN        5   // Connection limit exceeded.
#define NE_E_SERVERNOTFOUND     6   // Specified SQL server not found.
#define NE_E_NETNOTSTARTED      7   // The network has not been started.
#define NE_E_NORESOURCE         8   // Insufficient network resources.
#define NE_E_NETBUSY            9   // Network is busy.
#define NE_E_NONETACCESS        10  // Network access denied.
#define NE_E_GENERAL            11  // General network error.  Check your documentation.
#define NE_E_CONNMODE           12  // Incorrect connection mode.
#define NE_E_NAMENOTFOUND       13  // Name not found in directory service.
#define NE_E_INVALIDCONN        14  // Invalid connection.
#define NE_E_NETDATAERR         15  // Error reading or writing network data.
#define NE_E_TOOMANYFILES       16  // Too many open file handles.
#define NE_E_CANTCONNECT		  17  // SQL Server does not exist or access denied.

#define NE_MAX_NETERROR         17

#ifdef __cplusplus
}
#endif

#endif // _INC_SQLFRONT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3adminworker.h ===
// P3AdminWorker.h: interface for the CP3AdminWorker class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_P3ADMINWORKER_H__66B0B77E_555D_4F2B_81EF_661DA3B066B2__INCLUDED_)
#define AFX_P3ADMINWORKER_H__66B0B77E_555D_4F2B_81EF_661DA3B066B2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define ADS_SMTPDOMAIN_PATH_LOCAL   L"IIS://LocalHost/SMTPSVC/1/Domain"
#define ADS_SMTPDOMAIN_PATH_REMOTE  L"IIS://%s/SMTPSVC/1/Domain"
#define LOCKRENAME_FILENAME     L"kcoL"

struct IAuthMethods; //forward declaration
struct IAuthMethod; //forward declaration

#include <Iads.h>   // TODO: dougb this is temporary code to force AD to cache for us, should be removed

class CP3AdminWorker  
{
public:
    CP3AdminWorker();
    virtual ~CP3AdminWorker();

// Implementation
public:

    // Authentication
    HRESULT GetAuthenticationMethods( IAuthMethods* *ppIAuthMethods ) const;
    HRESULT GetCurrentAuthentication( IAuthMethod* *ppIAuthMethod ) const;
    // Domain
    HRESULT AddDomain( LPWSTR psDomainName );
    HRESULT GetDomainCount( ULONG *piCount );
    HRESULT GetDomainEnum( IEnumVARIANT **pp );
    HRESULT GetDomainLock( LPWSTR psDomainName, BOOL *pisLocked );
    bool IsDomainLocked( LPWSTR psDomainName );
    HRESULT RemoveDomain( LPWSTR psDomainName );
    HRESULT SetDomainLock( LPWSTR psDomainName, BOOL bLock );
    HRESULT ValidateDomain( LPWSTR psDomainName ) const;
    // User
    HRESULT AddUser( LPWSTR psDomainName, LPWSTR psUserName );
    HRESULT GetUserCount( LPWSTR psDomainName, long *plCount );
    HRESULT GetUserLock( LPWSTR psDomainName, LPWSTR psUserName, BOOL *pisLocked );
    HRESULT GetUserMessageDiskUsage( LPWSTR psDomainName, LPWSTR psUserName, long *plFactor, long *plUsage );
    HRESULT GetUserMessageCount( LPWSTR psDomainName, LPWSTR psUserName, long *plCount );
    HRESULT RemoveUser( LPWSTR psDomainName, LPWSTR psUserName );
    HRESULT SetUserLock( LPWSTR psDomainName, LPWSTR psUserName, BOOL bLock );
    // Quota
    HRESULT CreateQuotaSIDFile( LPWSTR psDomainName, LPWSTR psMailboxName, BSTR bstrAuthType, LPWSTR psMachineName, LPWSTR psUserName );
    HRESULT GetQuotaSID( BSTR bstrAuthType, LPWSTR psUserName, LPWSTR psMachineName, PSID *ppSIDOwner, LPDWORD pdwOwnerSID );
    // Other
    HRESULT BuildEmailAddr( LPCWSTR psDomainName, LPCWSTR psUserName, LPWSTR psEmailAddr, DWORD dwBufferSize ) const;
    HRESULT ControlService( LPWSTR psService, DWORD dwControl );
    HRESULT EnablePOP3SVC();
    HRESULT GetConfirmAddUser( BOOL *pbConfirm );
    HRESULT GetLoggingLevel( long *plLoggingLevel );
    HRESULT GetMachineName( LPWSTR psMachineName, DWORD dwSize );
    HRESULT GetMailroot( LPWSTR psMailRoot, DWORD dwSize, bool bUNC = true );
    HRESULT GetNextUser( HANDLE& hfSearch, LPCWSTR psDomainName, LPWSTR psBuffer, DWORD dwBufferSize );
    HRESULT GetPort( long *plPort );
    HRESULT GetServiceStatus( LPWSTR psService, LPDWORD plStatus );
    HRESULT GetSocketBacklog( long *plBacklog );
    HRESULT GetSocketMax( long *plMax );
    HRESULT GetSocketMin( long *plMin );
    HRESULT GetSocketThreshold( long *plThreshold );
    HRESULT GetSPARequired( BOOL *pbSPARequired );
    HRESULT GetThreadCountPerCPU( long *plCount );
    HRESULT InitFindFirstUser( HANDLE& hfSearch, LPCWSTR psDomainName, LPWSTR psBuffer, DWORD dwBufferSize );
    HRESULT MailboxSetRemote();
    HRESULT MailboxResetRemote();
    HRESULT SearchDomainsForMailbox( LPWSTR psUserName, LPWSTR *ppsDomain = NULL );
    HRESULT SetConfirmAddUser( BOOL bConfirm );
    HRESULT SetIISConfig( bool bBindSink );
    HRESULT SetLoggingLevel( long lLoggingLevel );
    HRESULT SetMachineName( LPWSTR psMachineName );
    HRESULT SetMailroot( LPWSTR psMailRoot );
    HRESULT SetPort( long lPort );
    HRESULT SetSockets( long lMax, long lMin, long lThreshold, long lBacklog );
    HRESULT SetThreadCountPerCPU( long lCount );
    HRESULT SetSPARequired( BOOL bSPARequired );
    HRESULT StartService( LPWSTR psService );
    HRESULT StopService( LPWSTR psService );

protected:

    // Domain
    HRESULT AddSMTPDomain( LPWSTR psDomainName );
    HRESULT AddStoreDomain( LPWSTR psDomainName );
    HRESULT BuildDomainPath( LPCWSTR psDomainName, LPWSTR psBuffer, DWORD dwBufferSize ) const;
    HRESULT CreateDomainMutex( LPWSTR psDomainName, HANDLE *phMutex );
    bool ExistsDomain( LPWSTR psDomainName ) const;
    HRESULT ExistsSMTPDomain( LPWSTR psDomainName ) const;
    HRESULT ExistsStoreDomain( LPWSTR psDomainName ) const;
    HRESULT GetSMTPDomainPath( LPWSTR psBuffer, LPWSTR psSuffix, DWORD dwBufferSize ) const;
    HRESULT LockDomain( LPWSTR psDomainName, bool bVerifyNotInUse = false );
    HRESULT LockDomainForDelete( LPWSTR psDomainName ){ return LockDomain( psDomainName, true ); }
    HRESULT RemoveSMTPDomain( LPWSTR psDomainName );
    HRESULT RemoveStoreDomain( LPWSTR psDomainName  );
    HRESULT UnlockDomain( LPWSTR psDomainName );
    // User
    HRESULT BuildUserPath( LPCWSTR psDomainName, LPCWSTR psUserName, LPWSTR psBuffer, DWORD dwBufferSize ) const;
    HRESULT CreateUserMutex( LPWSTR psDomainName, LPWSTR psUserName, HANDLE *phMutex );
    bool isUserLocked( LPWSTR psDomainName, LPWSTR psUserName );
    bool isValidMailboxName( LPWSTR psMailbox );
    HRESULT LockUser( LPWSTR psDomainName, LPWSTR psUserName );
    HRESULT UnlockUser( LPWSTR psDomainName, LPWSTR psUserName );
    // Other
    HRESULT BuildEmailAddrW2A( LPCWSTR psDomainName, LPCWSTR psUserName, LPSTR psEmailAddr, DWORD dwBufferSize ) const;

// Attributes
protected:
    LPWSTR  m_psMachineName;
    LPWSTR  m_psMachineMailRoot; // Path to remote machine's mailroot
    bool    m_bImpersonation;
    bool    m_isPOP3Installed;  // If this interfaces (P3ADMIN) are being used and POP3 Service is not installed
                                // then all SMTP checking is bi-passed.
                                // This solves the problem of using this with the Pop2Exch utility.
    
    CComPtr<IADs> m_spTemporaryFixIADs;
    
};

#endif // !defined(AFX_P3ADMINWORKER_H__66B0B77E_555D_4F2B_81EF_661DA3B066B2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3domain.h ===
// P3Domain.h : Declaration of the CP3Domain

#ifndef __P3DOMAIN_H_
#define __P3DOMAIN_H_

#include "resource.h"       // main symbols
#include <POP3Server.h>

/////////////////////////////////////////////////////////////////////////////
// CP3Domain
class ATL_NO_VTABLE CP3Domain : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CP3Domain, &CLSID_P3Domain>,
    public IDispatchImpl<IP3Domain, &IID_IP3Domain, &LIBID_P3ADMINLib>
{
public:
    CP3Domain();
    virtual ~CP3Domain();

DECLARE_REGISTRY_RESOURCEID(IDR_P3DOMAIN)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CP3Domain)
    COM_INTERFACE_ENTRY(IP3Domain)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IP3Domain
public:
    STDMETHOD(GetMessageDiskUsage)(/*[out]*/ VARIANT *pvFactor, /*[out]*/ VARIANT *pvValue);
    STDMETHOD(get_Lock)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Lock)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_MessageDiskUsage)(/*[out]*/ long *plFactor, /*[out]*/ long *pVal);
    STDMETHOD(get_MessageCount)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Users)(/*[out, retval]*/ IP3Users* *ppIP3Users);

// Implementation
public:
    HRESULT Init( IUnknown *pIUnk, CP3AdminWorker *pAdminX, LPWSTR psDomainName );

// Attributes
protected:
    IUnknown *m_pIUnk;
    CP3AdminWorker *m_pAdminX;   // This is the object that actually does all the work.
    WCHAR   m_sDomainName[POP3_MAX_DOMAIN_LENGTH];

};

#endif //__P3DOMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3domainenum.cpp ===
// P3DomainEnum.cpp : Implementation of CP3DomainEnum
#include "stdafx.h"
#include "P3Admin.h"
#include "P3DomainEnum.h"

#include "P3Domain.h"

#include <Iads.h>
#include <Adshlp.h>

/////////////////////////////////////////////////////////////////////////////
// CP3DomainEnum

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CP3DomainEnum::CP3DomainEnum() :
    m_pIUnk(NULL), m_pAdminX(NULL), m_pIEnumVARIANT(NULL)
{
}

CP3DomainEnum::~CP3DomainEnum()
{
    if ( NULL != m_pIUnk )
        m_pIUnk->Release();
    if ( NULL != m_pIEnumVARIANT )
        m_pIEnumVARIANT->Release();
}

/////////////////////////////////////////////////////////////////////////////
// IEnumVARIANT

STDMETHODIMP CP3DomainEnum::Next( /* [in] */ ULONG celt, /* [length_is][size_is][out] */ VARIANT __RPC_FAR *rgVar, /* [out] */ ULONG __RPC_FAR *pCeltFetched)
{
    if ( NULL == rgVar || ( 1 != celt && NULL == pCeltFetched ))
        return E_POINTER;
    if ( NULL == m_pAdminX ) return E_POINTER;
    if ( NULL == m_pIEnumVARIANT ) return E_POINTER;

    HRESULT hr;
    ULONG   nActual = 0;
    bool    bValidDomain = false;
    VARIANT __RPC_FAR *pVar = rgVar;
    VARIANT v;
    BSTR bstr = NULL;
    LPWSTR  ps = NULL;
    IUnknown    *pIUnk;
    CComObject<CP3Domain> *p;
    CComPtr<IADs> spIADs = NULL;

    VariantInit( &v );
    hr = m_pIEnumVARIANT->Next( 1, &v, pCeltFetched );
    while ( S_OK == hr && !bValidDomain )
    {
        if ( S_OK == hr )
        {
            if ( VT_DISPATCH == V_VT( &v ))
            {
                if ( NULL != spIADs.p )
                    spIADs.Release();
                hr = V_DISPATCH( &v )->QueryInterface( IID_IADs, reinterpret_cast<LPVOID*>( &spIADs ));
            }
            else
                hr = E_UNEXPECTED;
            VariantClear( &v );
        }
        if ( S_OK == hr )
            hr = spIADs->get_Name( &bstr );
        if ( S_OK == hr )
        {
            hr = m_pAdminX->ValidateDomain( bstr );
            if ( S_OK == hr )
                bValidDomain = true;
            else
            {
                hr = m_pIEnumVARIANT->Next( 1, &v, pCeltFetched );
                SysFreeString( bstr );
                bstr = NULL;
            }
        }
    }
    if ( S_OK == hr )
    {
        hr = CComObject<CP3Domain>::CreateInstance( &p );   // Reference count still 0
        if ( S_OK == hr )
        {
            // Increment the reference count on the source object and pass it to the new object
            hr = m_pIUnk->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>( &pIUnk ));
            if ( S_OK == hr )
            {
                hr = p->Init( pIUnk, m_pAdminX, bstr );
                if ( S_OK == hr )
                {
                    V_VT( &v ) = VT_DISPATCH;
                    hr = p->QueryInterface(IID_IDispatch, reinterpret_cast<void**>( &V_DISPATCH( &v )));
                    if ( S_OK == hr )
                        hr = VariantCopy( pVar, &v );
                    VariantClear( &v );
                    nActual++;
                }
            }
            if FAILED( hr )
                delete p;
        }
    }
    if ( NULL != bstr )
        SysFreeString( bstr );
    if (pCeltFetched)
        *pCeltFetched = nActual;
    if ((S_OK == hr) && (nActual < celt))
        hr = S_FALSE;

    return hr;
}

STDMETHODIMP CP3DomainEnum::Skip(ULONG celt)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    if ( NULL == m_pIEnumVARIANT ) return E_POINTER;
    
    HRESULT hr = S_OK;
    BSTR bstrDomainName;
    VARIANT v;
    CComPtr<IADs> spIADs = NULL;
    
    VariantInit( &v );
    while (( S_OK == hr ) && ( 0 < celt ))
    {
        if ( S_OK == hr )
        {
            hr = m_pIEnumVARIANT->Next( 1, &v, NULL );
            if ( S_OK == hr )
            {
                if ( VT_DISPATCH == V_VT( &v ))
                {
                    if ( NULL != spIADs.p )
                        spIADs.Release();
                    hr = V_DISPATCH( &v )->QueryInterface( IID_IADs, reinterpret_cast<LPVOID*>( &spIADs ));
                }
                else
                    hr = E_UNEXPECTED;
                VariantClear( &v );
            }
        }
        if ( S_OK == hr )
        {
            hr = spIADs->get_Name( &bstrDomainName );
            if ( S_OK == hr )
            {
                hr = m_pAdminX->ValidateDomain( bstrDomainName );
                if ( S_OK == hr )
                    celt--;
                else
                    hr = S_OK;
                SysFreeString( bstrDomainName );
            }
        }
    }
    
    return hr;
}

STDMETHODIMP CP3DomainEnum::Reset(void)
{
    if ( NULL == m_pIEnumVARIANT ) return E_POINTER;
    
    return m_pIEnumVARIANT->Reset();
}

STDMETHODIMP CP3DomainEnum::Clone( /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppEnum)
{
    if ( NULL == ppEnum ) return E_INVALIDARG;

    HRESULT     hr;
    LPUNKNOWN   pIUnk;
    CComObject<CP3DomainEnum> *p;
    IEnumVARIANT *pIEnumVARIANT;

    *ppEnum = NULL;
    hr = m_pIEnumVARIANT->Clone( &pIEnumVARIANT );
    if SUCCEEDED( hr )
    {
        hr = CComObject<CP3DomainEnum>::CreateInstance(&p); // Reference count still 0
        if SUCCEEDED( hr )
        {   // Increment the reference count on the source object and pass it to the new enumerator
            hr = m_pIUnk->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>( &pIUnk ));
            if SUCCEEDED( hr )
            {
                hr = p->Init( pIUnk, m_pAdminX, pIEnumVARIANT );  // p must call release on pIUnk when done.
                if SUCCEEDED( hr )
                    hr = p->QueryInterface( IID_IUnknown, reinterpret_cast<LPVOID*>( ppEnum ));
            }
            if FAILED( hr )
                delete p;   // Release
        }
        pIEnumVARIANT->Release();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// Implementation: public

HRESULT CP3DomainEnum::Init(IUnknown *pIUnk, CP3AdminWorker *p, IEnumVARIANT *pIEnumVARIANT )
{
    if ( NULL == pIUnk ) return E_INVALIDARG;
    if ( NULL == p ) return E_INVALIDARG;
    if ( NULL == pIEnumVARIANT ) return E_INVALIDARG;

    m_pIUnk = pIUnk;
    m_pAdminX = p;
    pIEnumVARIANT->AddRef();
    m_pIEnumVARIANT = pIEnumVARIANT;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3config.cpp ===
// P3Config.cpp : Implementation of CP3Config
#include "stdafx.h"
#include "P3Admin.h"
#include "P3Config.h"

#include <POP3Server.h>
#include "P3Domains.h"
#include "P3Service.h"

/////////////////////////////////////////////////////////////////////////////
// CP3Config


STDMETHODIMP CP3Config::IISConfig( BOOL bRegister )
{
    return m_AdminX.SetIISConfig( bRegister ? true:false );
}

STDMETHODIMP CP3Config::get_Authentication(IAuthMethods* *ppIAuthMethods)
{   // ppIAuthMethods - validated by GetAuthenticationMethods
    return m_AdminX.GetAuthenticationMethods( ppIAuthMethods );
}

STDMETHODIMP CP3Config::get_ConfirmAddUser(BOOL *pVal)
{   // ppIAuthMethods - validated by GetAuthenticationMethods
    return m_AdminX.GetConfirmAddUser( pVal );
}

STDMETHODIMP CP3Config::put_ConfirmAddUser(BOOL newVal)
{   // ppIAuthMethods - validated by GetAuthenticationMethods
    return m_AdminX.SetConfirmAddUser( newVal );
}

STDMETHODIMP CP3Config::GetFormattedMessage(/*[in]*/ long lError, /*[out]*/ VARIANT *pVal)
{
    if ( NULL == pVal )
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    LPVOID lpMsgBuf;

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, lError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), reinterpret_cast<LPWSTR>( &lpMsgBuf ), 0, NULL ))
    {
        VariantInit( pVal );
        V_VT( pVal ) = VT_BSTR;
        V_BSTR( pVal ) = SysAllocString( reinterpret_cast<LPWSTR>( lpMsgBuf )); 
        LocalFree( lpMsgBuf );
    }
    else
    {
        hr = S_FALSE;
    }
    
    return hr;
}

STDMETHODIMP CP3Config::get_Service(IP3Service **ppIService)
{
    if ( NULL == ppIService )
        return E_POINTER;

    HRESULT     hr;
    LPUNKNOWN   pIUnk;
    CComObject<CP3Service> *p;

    *ppIService = NULL;
    hr = CComObject<CP3Service>::CreateInstance( &p );   // Reference count still 0
    if ( S_OK == hr )
    {
        hr = _InternalQueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>( &pIUnk ));
        if ( S_OK == hr )
        {
            if ( S_OK == hr )
                hr = p->Init( pIUnk, &m_AdminX );
            if ( S_OK == hr )
                hr = p->QueryInterface(IID_IP3Service, reinterpret_cast<void**>( ppIService ));
        }
        if ( S_OK != hr )
            delete p;   // Release
    }

    assert( S_OK == hr );
    return hr;
}

STDMETHODIMP CP3Config::get_Domains(IP3Domains **ppIDomains)
{
    if ( NULL == ppIDomains )
        return E_POINTER;

    HRESULT     hr;
    LPUNKNOWN   pIUnk;
    CComObject<CP3Domains> *p;

    *ppIDomains = NULL;
    hr = CComObject<CP3Domains>::CreateInstance( &p );   // Reference count still 0
    if SUCCEEDED( hr )
    {
        hr = _InternalQueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>( &pIUnk ));
        if SUCCEEDED( hr )
        {
            hr = p->Init( pIUnk, &m_AdminX );
            if SUCCEEDED( hr )
                hr = p->QueryInterface(IID_IP3Domains, reinterpret_cast<void**>( ppIDomains ));
        }
        if FAILED( hr )
            delete p;   // Release
    }

    assert( S_OK == hr );
    return hr;
}

STDMETHODIMP CP3Config::get_LoggingLevel(long *pVal)
{
    return m_AdminX.GetLoggingLevel( pVal );
}

STDMETHODIMP CP3Config::put_LoggingLevel(long newVal)
{
    return m_AdminX.SetLoggingLevel( newVal );
}

STDMETHODIMP CP3Config::get_MachineName(BSTR *pVal)
{
    if ( NULL == pVal )
        return E_INVALIDARG;
    
    HRESULT hr;
    WCHAR   sMachineName[MAX_PATH];

    hr = m_AdminX.GetMachineName( sMachineName, sizeof( sMachineName )/sizeof(WCHAR));
    if SUCCEEDED( hr )
    {
        *pVal = SysAllocString( sMachineName );
    }

    return hr;
}

STDMETHODIMP CP3Config::put_MachineName(BSTR newVal)
{
    return m_AdminX.SetMachineName( newVal );
}

STDMETHODIMP CP3Config::get_MailRoot(BSTR *pVal)
{
    if ( NULL == pVal )
        return E_INVALIDARG;
    
    HRESULT hr;
    WCHAR   sMailRoot[POP3_MAX_MAILROOT_LENGTH];

    hr = m_AdminX.GetMailroot( sMailRoot, sizeof( sMailRoot )/sizeof(WCHAR), false );
    if SUCCEEDED( hr )
    {
        *pVal = SysAllocString( sMailRoot );
    }

    return hr;
}

STDMETHODIMP CP3Config::put_MailRoot(BSTR newVal)
{
    return m_AdminX.SetMailroot( newVal );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3config.h ===
// P3Config.h : Declaration of the CP3Config

#ifndef __P3CONFIG_H_
#define __P3CONFIG_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CP3Config
class ATL_NO_VTABLE CP3Config : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CP3Config, &CLSID_P3Config>,
    public IDispatchImpl<IP3Config, &IID_IP3Config, &LIBID_P3ADMINLib>
{
public:
    CP3Config()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_P3CONFIG)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CP3Config)
    COM_INTERFACE_ENTRY(IP3Config)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IP3Config
public:
    STDMETHOD(get_ConfirmAddUser)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_ConfirmAddUser)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_MachineName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_MachineName)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_MailRoot)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_MailRoot)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_LoggingLevel)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_LoggingLevel)(/*[in]*/ long newVal);
    STDMETHOD(GetFormattedMessage)(/*[in]*/ long lError, /*[out]*/ VARIANT *pVal);
    STDMETHOD(get_Domains)(/*[out, retval]*/ IP3Domains* *ppIDomains);
    STDMETHOD(get_Service)(/*[out, retval]*/ IP3Service* *ppIService);
    STDMETHOD(IISConfig)(/*[in]*/ BOOL bRegister );
    STDMETHOD(get_Authentication)(/*[out, retval]*/ IAuthMethods* *ppIAuthMethods);

private:
    CP3AdminWorker m_AdminX;   // This is the object that actually does all the work.

};

#endif //__P3CONFIG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3domainenum.h ===
// P3DomainEnum.h : Declaration of the CP3DomainEnum

#ifndef __P3DOMAINENUM_H_
#define __P3DOMAINENUM_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CP3DomainEnum
class ATL_NO_VTABLE CP3DomainEnum : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CP3DomainEnum, &CLSID_P3DomainEnum>,
    public IEnumVARIANT
{
public:
    CP3DomainEnum();
    virtual ~CP3DomainEnum();

DECLARE_REGISTRY_RESOURCEID(IDR_P3DOMAINENUM)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CP3DomainEnum)
    COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

// IEnumVARIANT
public:
    HRESULT STDMETHODCALLTYPE Next( /* [in] */ ULONG celt, /* [length_is][size_is][out] */ VARIANT __RPC_FAR *rgVar, /* [out] */ ULONG __RPC_FAR *pCeltFetched);
    HRESULT STDMETHODCALLTYPE Skip( /* [in] */ ULONG celt);
    HRESULT STDMETHODCALLTYPE Reset( void);
    HRESULT STDMETHODCALLTYPE Clone( /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppEnum);

// Implementation
public:
    HRESULT Init( IUnknown *pIUnk, CP3AdminWorker *pAdminX, IEnumVARIANT *pIEnumVARIANT );

// Attributes
protected:
    IUnknown *m_pIUnk;
    CP3AdminWorker *m_pAdminX;   // This is the object that actually does all the work.
    IEnumVARIANT *m_pIEnumVARIANT;// IADsContainer::get__NewEnum for L"IIS://LocalHost/SMTPSVC/1/Domain"

};

#endif //__P3DOMAINENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3domain.cpp ===
// P3Domain.cpp : Implementation of CP3Domain
#include "stdafx.h"
#include "P3Admin.h"
#include "P3Domain.h"

#include "P3Users.h"

#include <limits.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CP3Domain::CP3Domain() :
    m_pIUnk(NULL), m_pAdminX(NULL)
{
    ZeroMemory( m_sDomainName, sizeof(m_sDomainName));
}

CP3Domain::~CP3Domain()
{
    if ( NULL != m_pIUnk )
        m_pIUnk->Release();
}

//////////////////////////////////////////////////////////////////////
// IP3Domain
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CP3Domain::get_Lock(BOOL *pVal)
{
    if ( NULL == pVal ) return E_INVALIDARG;
    if ( NULL == m_pAdminX ) return E_POINTER;

    return m_pAdminX->GetDomainLock( m_sDomainName, pVal );
}

STDMETHODIMP CP3Domain::put_Lock(BOOL newVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->SetDomainLock( m_sDomainName, newVal );
}

STDMETHODIMP CP3Domain::get_MessageCount(long *pVal)
{
    if ( NULL == pVal ) return E_INVALIDARG;

    HRESULT hr;
    long    lMessageCount = 0, lUserMessageCount;
    VARIANT v;
    IP3Users *pIUsers;
    IEnumVARIANT *pIEnumVARIANT;
    IP3User *pIUser;

    *pVal = -1;
    VariantInit( &v );
    hr = get_Users( &pIUsers );
    if ( S_OK == hr )
    {
        hr = pIUsers->get__NewEnum( &pIEnumVARIANT );
        if ( S_OK == hr )
        {
            hr = pIEnumVARIANT->Next( 1, &v, NULL );
            while ( S_OK == hr )
            {
                if ( VT_DISPATCH == V_VT( &v ))
                {
                    hr = V_DISPATCH( &v )->QueryInterface( IID_IP3User, reinterpret_cast<LPVOID*>( &pIUser ));
                    if ( S_OK == hr )
                    {
                        hr = pIUser->get_MessageCount( &lUserMessageCount );
                        if ( S_OK == hr )
                            lMessageCount += lUserMessageCount;
                        pIUser->Release();
                    }
                }
                else
                    hr = E_UNEXPECTED;
                VariantClear( &v );
                if ( S_OK == hr )
                    hr = pIEnumVARIANT->Next( 1, &v, NULL );
            }
            if ( S_FALSE == hr )   // Reached the end of the enumeration
                hr = S_OK;
        }
        pIUsers->Release();
    }
    if ( S_OK == hr )
        *pVal = lMessageCount;

    return hr;
}

STDMETHODIMP CP3Domain::get_MessageDiskUsage(long *plFactor, long *pVal)
{
    if ( NULL == plFactor ) return E_INVALIDARG;
    if ( NULL == pVal ) return E_INVALIDARG;

    HRESULT hr = S_OK;
    long    lDiskUsage, lFactor;
    __int64 i64DiskUsage = 0;
    VARIANT v;
    IP3Users *pIUsers;
    IEnumVARIANT *pIEnumVARIANT;
    IP3User *pIUser;

    *pVal = -1;
    VariantInit( &v );
    hr = get_Users( &pIUsers );
    if ( S_OK == hr )
    {
        hr = pIUsers->get__NewEnum( &pIEnumVARIANT );
        if ( S_OK == hr )
        {
            hr = pIEnumVARIANT->Next( 1, &v, NULL );
            while ( S_OK == hr )
            {
                if ( VT_DISPATCH == V_VT( &v ))
                {
                    hr = V_DISPATCH( &v )->QueryInterface( IID_IP3User, reinterpret_cast<LPVOID*>( &pIUser ));
                    if ( S_OK == hr )
                    {
                        hr = pIUser->get_MessageDiskUsage( &lFactor, &lDiskUsage );
                        if ( S_OK == hr )
                            i64DiskUsage += (lDiskUsage * lFactor);
                        pIUser->Release();
                    }
                }
                else
                    hr = E_UNEXPECTED;
                VariantClear( &v );
                if ( S_OK == hr )
                    hr = pIEnumVARIANT->Next( 1, &v, NULL );
            }
            if ( S_FALSE == hr )   // Reached the end of the enumeration
                hr = S_OK;
        }
        pIUsers->Release();
    }

    lFactor = 1;
    while ( i64DiskUsage > INT_MAX )
    {
        lFactor *= 10;
        i64DiskUsage = i64DiskUsage / 10;
    }
    *plFactor = lFactor;
    *pVal = static_cast<int>( i64DiskUsage );

    return hr;
}

// VB Script can't use the property above!
STDMETHODIMP CP3Domain::GetMessageDiskUsage(VARIANT *pvFactor, VARIANT *pvValue)
{
    if ( NULL == pvValue ) return E_INVALIDARG;
    
    HRESULT hr;
    long    lFactor, lValue;

    VariantInit( pvFactor );
    VariantInit( pvValue );
    hr = get_MessageDiskUsage( &lFactor, &lValue );
    if ( S_OK == hr )
    {
        V_VT( pvFactor ) = VT_I4;
        V_I4( pvFactor ) = lFactor;
        V_VT( pvValue ) = VT_I4;
        V_I4( pvValue ) = lValue;
    }

    return hr;
}

STDMETHODIMP CP3Domain::get_Name(BSTR *pVal)
{
    if ( NULL == pVal ) return E_INVALIDARG;

    *pVal = SysAllocString( m_sDomainName );
    return S_OK;
}

STDMETHODIMP CP3Domain::get_Users(IP3Users **ppIUsers)
{
    if ( NULL == ppIUsers ) return E_INVALIDARG;

    HRESULT hr;
    LPUNKNOWN   pIUnk;
    CComObject<CP3Users> *p;

    hr = CComObject<CP3Users>::CreateInstance( &p );   // Reference count still 0
    if SUCCEEDED( hr )
    {
        hr = m_pIUnk->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>( &pIUnk ));
        if SUCCEEDED( hr )
        {
            hr = p->Init( pIUnk, m_pAdminX, m_sDomainName );
            if SUCCEEDED( hr )
                hr = p->QueryInterface(IID_IP3Users, reinterpret_cast<void**>( ppIUsers ));
        }
        if FAILED( hr )
            delete p;   // Release
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// Implementation: public
//////////////////////////////////////////////////////////////////////

HRESULT CP3Domain::Init(IUnknown *pIUnk, CP3AdminWorker *p, LPWSTR psDomainName )
{
    if ( NULL == pIUnk ) return E_INVALIDARG;
    if ( NULL == p ) return E_INVALIDARG;
    if ( NULL == psDomainName ) return E_INVALIDARG;

    m_pIUnk = pIUnk;
    m_pAdminX = p;
    wcsncpy( m_sDomainName, psDomainName, sizeof(m_sDomainName)/sizeof(WCHAR)-1);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3domains.cpp ===
// P3Domains.cpp : Implementation of CP3Domains
#include "stdafx.h"
#include "P3Admin.h"
#include "P3Domains.h"

#include "P3Domain.h"
#include "P3DomainEnum.h"

#include <Iads.h>
#include <Adshlp.h>

/////////////////////////////////////////////////////////////////////////////
// CP3Domains

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CP3Domains::CP3Domains() :
    m_pIUnk(NULL), m_pAdminX(NULL)
{

}

CP3Domains::~CP3Domains()
{
    if ( NULL != m_pIUnk )
        m_pIUnk->Release();
}

//////////////////////////////////////////////////////////////////////
// IP3Domains
//////////////////////////////////////////////////////////////////////

STDMETHODIMP CP3Domains::get__NewEnum(IEnumVARIANT* *ppIEnumVARIANT)
{
    if ( NULL == ppIEnumVARIANT ) return E_INVALIDARG;
    if ( NULL == m_pAdminX ) return E_POINTER;

    HRESULT hr;
    LPUNKNOWN pIUnk;
    IEnumVARIANT *pIEnumVARIANT;
    CComObject<CP3DomainEnum>* p;

    *ppIEnumVARIANT = NULL;
    hr = m_pAdminX->GetDomainEnum( &pIEnumVARIANT );
    if SUCCEEDED( hr )
    {
        hr = CComObject<CP3DomainEnum>::CreateInstance(&p); // Reference count still 0
        if SUCCEEDED( hr )
        {
            // Increment the reference count on the source object and pass it to the new enumerator
            hr = m_pIUnk->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>( &pIUnk ));
            if SUCCEEDED( hr )
            {
                hr = p->Init( pIUnk, m_pAdminX, pIEnumVARIANT );
                if SUCCEEDED( hr )
                    hr = p->QueryInterface( IID_IEnumVARIANT, reinterpret_cast<LPVOID*>( ppIEnumVARIANT ));
            }
            if FAILED( hr )
                delete p;
        }
        pIEnumVARIANT->Release();
    }

    return hr;
}

STDMETHODIMP CP3Domains::get_Count(long *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;

    return m_pAdminX->GetDomainCount( reinterpret_cast<ULONG*>( pVal ));
}

STDMETHODIMP CP3Domains::get_Item(VARIANT vIndex, IP3Domain **ppIP3Domain)
{
    VARIANT *pv = &vIndex;
    
    if ( NULL == ppIP3Domain ) return E_INVALIDARG;    
    if ( (VT_VARIANT|VT_BYREF) == V_VT( pv ))
        pv = V_VARIANTREF( pv );
    if ( VT_BSTR != V_VT( pv ) && VT_I4 != V_VT( pv ))
        return E_INVALIDARG;
    if ( VT_BSTR == V_VT( pv ) && NULL == V_BSTR( pv ))
        return E_INVALIDARG;
    if ( NULL == m_pAdminX ) return E_POINTER;

    HRESULT hr = E_INVALIDARG;
    _bstr_t _bstrDomainName;
    VARIANT v;

    VariantInit( &v );
    // Find the requested item
    if ( VT_I4 == V_VT( pv ))
    {   // Find by Index
        int iIndex = V_I4( pv );
        CComPtr<IEnumVARIANT> spIEnumVARIANT;
        CComPtr<IP3Domain> spIDomain;

        hr = get__NewEnum( &spIEnumVARIANT );
        if ( S_OK == hr )
        {
            if ( (S_OK == hr) && (0 < iIndex - 1) )
                hr = spIEnumVARIANT->Skip( iIndex - 1 );
            if ( S_OK == hr )
            {
                hr = spIEnumVARIANT->Next( 1, &v, NULL );
                if ( S_OK == hr )
                {
                    if ( VT_DISPATCH == V_VT( &v ))
                        hr = V_DISPATCH( &v )->QueryInterface( __uuidof( IP3Domain ), reinterpret_cast<void**>( &spIDomain ));
                    else
                        hr = E_UNEXPECTED;
                    VariantClear( &v );
                }
            }
            if ( S_OK == hr )
            {
                BSTR bstrDomainName;
                
                hr = spIDomain->get_Name( &bstrDomainName );
                _bstrDomainName = bstrDomainName;
                SysFreeString( bstrDomainName );
            }
        }
    }
    if ( VT_BSTR == V_VT( pv ))
    {   // Find by Name
        _bstrDomainName = V_BSTR( pv );
        hr = m_pAdminX->ValidateDomain( _bstrDomainName );
    }
        
    // Wrap it with COM
    if SUCCEEDED( hr )
    {
        LPUNKNOWN   pIUnk;
        CComObject<CP3Domain> *p;

        hr = CComObject<CP3Domain>::CreateInstance( &p );   // Reference count still 0
        if SUCCEEDED( hr )
        {
            hr = m_pIUnk->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>( &pIUnk ));
            if SUCCEEDED( hr )
            {
                hr = p->Init( pIUnk, m_pAdminX, _bstrDomainName );
                if SUCCEEDED( hr )
                    hr = p->QueryInterface(IID_IP3Domain, reinterpret_cast<void**>( ppIP3Domain ));
            }
            if FAILED( hr )
                delete p;   // Release
        }
    }

    return hr;
}

STDMETHODIMP CP3Domains::Add(BSTR bstrDomainName)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    HRESULT hr = m_pAdminX->AddDomain( bstrDomainName );
    if ( S_OK == hr || ERROR_FILE_EXISTS == hr )
    {
        ULONG   ulCount;

        // Don't want to fail because of this.  The operation was really succeesful, just may have an issue with the service state.
        HRESULT hr2 = m_pAdminX->GetDomainCount( &ulCount );
        if ( S_OK == hr2 && 1 == ulCount )
            hr2 = m_pAdminX->EnablePOP3SVC();
    }

    return hr;
}

STDMETHODIMP CP3Domains::Remove(BSTR bstrDomainName)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->RemoveDomain( bstrDomainName );
}

STDMETHODIMP CP3Domains::SearchForMailbox(BSTR bstrUserName, BSTR *pbstrDomainName)
{
    if ( NULL == pbstrDomainName ) return E_INVALIDARG;
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    HRESULT hr;
    LPWSTR psDomainName = NULL;

    hr = m_pAdminX->SearchDomainsForMailbox( bstrUserName, &psDomainName );
    if ( S_OK == hr )
    {
        *pbstrDomainName = SysAllocString( psDomainName );
        delete [] psDomainName;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// Implementation: public
//////////////////////////////////////////////////////////////////////

HRESULT CP3Domains::Init(IUnknown *pIUnk, CP3AdminWorker *p)
{
    if ( NULL == pIUnk ) return E_INVALIDARG;
    if ( NULL == p ) return E_INVALIDARG;

    m_pIUnk = pIUnk;
    m_pAdminX = p;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3service.cpp ===
// P3Service.cpp : Implementation of CP3Service
#include "stdafx.h"
#include "P3Admin.h"
#include "P3Service.h"

#include <POP3Server.h>

#include <smtpinet.h>
#include <inetinfo.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CP3Service::CP3Service() :
    m_pIUnk(NULL), m_pAdminX(NULL)
{

}

CP3Service::~CP3Service()
{
    if ( NULL != m_pIUnk )
        m_pIUnk->Release();
}

//////////////////////////////////////////////////////////////////////
// IP3Domains
//////////////////////////////////////////////////////////////////////


STDMETHODIMP CP3Service::get_ThreadCountPerCPU(long *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    return m_pAdminX->GetThreadCountPerCPU( pVal );
}

STDMETHODIMP CP3Service::put_ThreadCountPerCPU(long newVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->SetThreadCountPerCPU( newVal );
}

STDMETHODIMP CP3Service::get_SocketsMax(long *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    return m_pAdminX->GetSocketMax( pVal );
}

STDMETHODIMP CP3Service::get_SocketsMin(long *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    return m_pAdminX->GetSocketMin( pVal );
}

STDMETHODIMP CP3Service::get_SocketsThreshold(long *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    return m_pAdminX->GetSocketThreshold( pVal );
}

STDMETHODIMP CP3Service::SetSockets(long lMax, long lMin, long lThreshold, long lBacklog)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->SetSockets( lMax, lMin, lThreshold, lBacklog );
}

STDMETHODIMP CP3Service::get_SocketsBacklog(long *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    return m_pAdminX->GetSocketBacklog( pVal );
}

STDMETHODIMP CP3Service::get_Port(long *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    return m_pAdminX->GetPort( pVal );
}

STDMETHODIMP CP3Service::put_Port(long newVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->SetPort( newVal );
}

STDMETHODIMP CP3Service::get_SPARequired(BOOL *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    return m_pAdminX->GetSPARequired( pVal );
}

STDMETHODIMP CP3Service::put_SPARequired(BOOL newVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->SetSPARequired( newVal );
}

STDMETHODIMP CP3Service::get_POP3ServiceStatus(/*[out, retval]*/ long *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->GetServiceStatus( POP3_SERVICE_NAME, reinterpret_cast<LPDWORD>( pVal ));
}

STDMETHODIMP CP3Service::StartPOP3Service()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->StartService( POP3_SERVICE_NAME );
}

STDMETHODIMP CP3Service::StopPOP3Service()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->StopService( POP3_SERVICE_NAME );
}

STDMETHODIMP CP3Service::PausePOP3Service()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->ControlService( POP3_SERVICE_NAME, SERVICE_CONTROL_PAUSE);
}

STDMETHODIMP CP3Service::ResumePOP3Service()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->ControlService( POP3_SERVICE_NAME, SERVICE_CONTROL_CONTINUE );
}

STDMETHODIMP CP3Service::get_SMTPServiceStatus(/*[out, retval]*/ long *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->GetServiceStatus( SMTP_SERVICE_NAME, reinterpret_cast<LPDWORD>( pVal ));
}

STDMETHODIMP CP3Service::StartSMTPService()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->StartService( SMTP_SERVICE_NAME );
}

STDMETHODIMP CP3Service::StopSMTPService()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->StopService( SMTP_SERVICE_NAME );
}

STDMETHODIMP CP3Service::PauseSMTPService()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->ControlService( SMTP_SERVICE_NAME, SERVICE_CONTROL_PAUSE);
}

STDMETHODIMP CP3Service::ResumeSMTPService()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->ControlService( SMTP_SERVICE_NAME, SERVICE_CONTROL_CONTINUE );
}

STDMETHODIMP CP3Service::get_IISAdminServiceStatus(/*[out, retval]*/ long *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->GetServiceStatus( IISADMIN_SERVICE_NAME, reinterpret_cast<LPDWORD>( pVal ));
}

STDMETHODIMP CP3Service::StartIISAdminService()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->StartService( IISADMIN_SERVICE_NAME );
}

STDMETHODIMP CP3Service::StopIISAdminService()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->StopService( IISADMIN_SERVICE_NAME );
}

STDMETHODIMP CP3Service::PauseIISAdminService()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->ControlService( IISADMIN_SERVICE_NAME, SERVICE_CONTROL_PAUSE);
}

STDMETHODIMP CP3Service::ResumeIISAdminService()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->ControlService( IISADMIN_SERVICE_NAME, SERVICE_CONTROL_CONTINUE );
}

STDMETHODIMP CP3Service::get_W3ServiceStatus(/*[out, retval]*/ long *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->GetServiceStatus( W3_SERVICE_NAME, reinterpret_cast<LPDWORD>( pVal ));
}

STDMETHODIMP CP3Service::StartW3Service()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->StartService( W3_SERVICE_NAME );
}

STDMETHODIMP CP3Service::StopW3Service()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->StopService( W3_SERVICE_NAME );
}

STDMETHODIMP CP3Service::PauseW3Service()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->ControlService( W3_SERVICE_NAME, SERVICE_CONTROL_PAUSE);
}

STDMETHODIMP CP3Service::ResumeW3Service()
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->ControlService( W3_SERVICE_NAME, SERVICE_CONTROL_CONTINUE );
}

//////////////////////////////////////////////////////////////////////
// Implementation: public
//////////////////////////////////////////////////////////////////////

HRESULT CP3Service::Init(IUnknown *pIUnk, CP3AdminWorker *p)
{
    if ( NULL == pIUnk )
        return E_INVALIDARG;
    if ( NULL == p )
        return E_INVALIDARG;

    m_pIUnk = pIUnk;
    m_pAdminX = p;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3service.h ===
// P3Service.h : Declaration of the CP3Service

#ifndef __P3SERVICE_H_
#define __P3SERVICE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CP3Service
class ATL_NO_VTABLE CP3Service : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CP3Service, &CLSID_P3Service>,
    public IDispatchImpl<IP3Service, &IID_IP3Service, &LIBID_P3ADMINLib>
{
public:
    CP3Service();
    virtual ~CP3Service();

DECLARE_REGISTRY_RESOURCEID(IDR_P3SERVICE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CP3Service)
    COM_INTERFACE_ENTRY(IP3Service)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IP3Service
public:
    STDMETHOD(get_Port)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_Port)(/*[in]*/ long newVal);
    STDMETHOD(get_SocketsBacklog)(/*[out, retval]*/ long *pVal);
    STDMETHOD(SetSockets)(/*[in]*/ long lMax, /*[in]*/ long lMin, /*[in]*/ long lThreshold, /*[in]*/ long lBacklog);
    STDMETHOD(get_SocketsThreshold)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_SocketsMin)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_SocketsMax)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_ThreadCountPerCPU)(/*[out, retval]*/ long *pVal);
    STDMETHOD(put_ThreadCountPerCPU)(/*[in]*/ long newVal);
    STDMETHOD(get_SPARequired)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_SPARequired)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_POP3ServiceStatus)(/*[out, retval]*/ long *pVal);
    STDMETHOD(StartPOP3Service)();
    STDMETHOD(StopPOP3Service)();
    STDMETHOD(PausePOP3Service)();
    STDMETHOD(ResumePOP3Service)();
    STDMETHOD(get_SMTPServiceStatus)(/*[out, retval]*/ long *pVal);
    STDMETHOD(StartSMTPService)();
    STDMETHOD(StopSMTPService)();
    STDMETHOD(PauseSMTPService)();
    STDMETHOD(ResumeSMTPService)();
    STDMETHOD(get_IISAdminServiceStatus)(/*[out, retval]*/ long *pVal);
    STDMETHOD(StartIISAdminService)();
    STDMETHOD(StopIISAdminService)();
    STDMETHOD(PauseIISAdminService)();
    STDMETHOD(ResumeIISAdminService)();
    STDMETHOD(get_W3ServiceStatus)(/*[out, retval]*/ long *pVal);
    STDMETHOD(StartW3Service)();
    STDMETHOD(StopW3Service)();
    STDMETHOD(PauseW3Service)();
    STDMETHOD(ResumeW3Service)();

// Implementation
public:
    HRESULT Init( IUnknown *pIUnk, CP3AdminWorker *pAdminX);

// Attributes
protected:
    IUnknown  *m_pIUnk;
    CP3AdminWorker *m_pAdminX;   // This is the object that actually does all the work.

};

#endif //__P3SERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3domains.h ===
// P3Domains.h : Declaration of the CP3Domains

#ifndef __P3DOMAINS_H_
#define __P3DOMAINS_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CP3Domains
class ATL_NO_VTABLE CP3Domains : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CP3Domains, &CLSID_P3Domains>,
    public IDispatchImpl<IP3Domains, &IID_IP3Domains, &LIBID_P3ADMINLib>
{
public:
    CP3Domains();
    virtual ~CP3Domains();

DECLARE_REGISTRY_RESOURCEID(IDR_P3DOMAINS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CP3Domains)
    COM_INTERFACE_ENTRY(IP3Domains)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IP3Domains
public:
    STDMETHOD(SearchForMailbox)(/*[in]*/ BSTR bstrUserName, /*[out]*/ BSTR *pbstrDomainName);
    STDMETHOD(Remove)(/*[in]*/ BSTR bstrDomainName);
    STDMETHOD(Add)(/*[in]*/ BSTR bstrDomainName);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT vIndex, /*[out, retval]*/ IP3Domain* *ppIP3Domain);
    STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get__NewEnum)(/*[out, retval]*/ IEnumVARIANT* *ppIEnumVARIANT);

// Implementation
public:
    HRESULT Init( IUnknown *pIUnk, CP3AdminWorker *pAdminX);

// Attributes
protected:
    IUnknown  *m_pIUnk;
    CP3AdminWorker *m_pAdminX;   // This is the object that actually does all the work.

};

#endif //__P3DOMAINS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3user.cpp ===
// P3User.cpp : Implementation of CP3User
#include "stdafx.h"
#include "P3Admin.h"
#include "P3User.h"

#include <AuthID.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CP3User::CP3User() :
    m_pIUnk(NULL), m_pAdminX(NULL)
{
    ZeroMemory( m_sUserName, sizeof(m_sUserName));
    ZeroMemory( m_sDomainName, sizeof(m_sDomainName));
}

CP3User::~CP3User()
{
    if ( NULL != m_pIUnk )
        m_pIUnk->Release();
}

/////////////////////////////////////////////////////////////////////////////
// CP3User

STDMETHODIMP CP3User::get_ClientConfigDesc(BSTR *pVal)
{
    if ( NULL == pVal )
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    WCHAR   sMachineName[POP3_MAX_PATH];
    BSTR    bstrAuthType;
    BSTR    bstrEmailName = NULL;
    BOOL    bSPARequired = FALSE;
    _variant_t _vSAMName;
    CComPtr<IAuthMethod> spIAuthMethod;

    hr = get_EmailName( &bstrEmailName );
    if ( S_OK == hr )
        hr = m_pAdminX->GetCurrentAuthentication( &spIAuthMethod );
    if ( S_OK == hr )
        hr = spIAuthMethod->get_ID( &bstrAuthType );
    if ( S_OK == hr )
    {
        if ( 0 == _wcsicmp( bstrAuthType, SZ_AUTH_ID_DOMAIN_AD ))   // In AD the SAMName does not have to match the mailbox name
        {
            _vSAMName = bstrEmailName;
            if ( S_OK == hr )
                 hr = spIAuthMethod->Get( SZ_SAMACCOUNT_NAME, &_vSAMName );
            if ( S_OK == hr )
            {
                if ( VT_BSTR != V_VT( &_vSAMName ))
                    hr = E_FAIL;
            }
            if ( S_OK == hr )
                hr = m_pAdminX->GetSPARequired( &bSPARequired );
        }
        else if ( 0 == _wcsicmp( bstrAuthType, SZ_AUTH_ID_LOCAL_SAM ))
        {
            hr = m_pAdminX->GetSPARequired( &bSPARequired );
            _vSAMName = m_sUserName;
        }
        SysFreeString( bstrAuthType );
    }
    if ( S_OK == hr )
    {
        hr = m_pAdminX->GetMachineName( sMachineName, sizeof( sMachineName )/sizeof(WCHAR));
        if ( S_OK == hr && 0 == wcslen( sMachineName ))    
        {
            DWORD dwSize = sizeof(sMachineName)/sizeof(WCHAR);
            if ( !GetComputerName( sMachineName, &dwSize ))
                hr = HRESULT_FROM_WIN32( GetLastError());
        }
    }
    if ( S_OK == hr )
    {
        WCHAR sBuffer[1024];
        LPWSTR psVal = NULL;
        LPWSTR psArgs[4];

        psArgs[1] = psArgs[3] = sMachineName;        
        psArgs[0] = psArgs[2] = bstrEmailName;
        if ( VT_BSTR != V_VT( &_vSAMName ))
        {
            if ( !LoadString( _Module.GetResourceInstance(), IDS_CLIENTCONFIG_CONFIRMATION, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) ))
                sBuffer[0] = 0;
        }
        else if ( bSPARequired )
        {
            psArgs[0] = psArgs[2] = V_BSTR( &_vSAMName );
            if ( !LoadString( _Module.GetResourceInstance(), IDS_CLIENTCONFIG_CONFIRMATION, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) ))
                sBuffer[0] = 0;
        }
        else
        {
            psArgs[2] = V_BSTR( &_vSAMName );
            if ( !LoadString( _Module.GetResourceInstance(), IDS_CLIENTCONFIG_CONFIRMATION2, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) ))
                sBuffer[0] = 0;
            if ( 0 != _wcsicmp( m_sUserName, V_BSTR( &_vSAMName )))
            {
                WCHAR sBuffer2[1024];
                
                if ( !LoadString( _Module.GetResourceInstance(), IDS_CLIENTCONFIG_CONFIRMNOTE, sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR) ))
                    sBuffer2[0] = 0;
                StrCatBuff( sBuffer, sBuffer2, sizeof( sBuffer )/sizeof(WCHAR));    // returns sBuffer
            }
        }
        if ( 0 == FormatMessageW( FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_ARGUMENT_ARRAY, sBuffer, 0, 0, reinterpret_cast<LPWSTR>(&psVal), 0, reinterpret_cast<va_list*>( psArgs )))
            hr = HRESULT_FROM_WIN32( GetLastError());
        if ( S_OK == hr )
        {
            *pVal = SysAllocString( psVal );
            LocalFree( psVal );
        }
    }
    return hr;
}

STDMETHODIMP CP3User::get_EmailName(BSTR *pVal)
{
    if ( NULL == pVal )
        return E_INVALIDARG;

    HRESULT hr = E_FAIL;
    WCHAR   sBuffer[POP3_MAX_ADDRESS_LENGTH];

    if ( sizeof( sBuffer )/sizeof(WCHAR) > ( wcslen( m_sDomainName ) + wcslen( m_sUserName ) + 1 ))
    {
        wcscpy( sBuffer, m_sUserName );
        wcscat( sBuffer, L"@" );
        wcscat( sBuffer, m_sDomainName );
        *pVal = SysAllocString( sBuffer );
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CP3User::get_Lock(BOOL *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;

    return m_pAdminX->GetUserLock( m_sDomainName, m_sUserName, pVal );
}

STDMETHODIMP CP3User::put_Lock(BOOL newVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->SetUserLock( m_sDomainName, m_sUserName, newVal );
}

STDMETHODIMP CP3User::get_MessageCount(long *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->GetUserMessageCount( m_sDomainName, m_sUserName, pVal );
}

STDMETHODIMP CP3User::get_MessageDiskUsage(long *plFactor, long *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->GetUserMessageDiskUsage( m_sDomainName, m_sUserName, plFactor, pVal );
}

STDMETHODIMP CP3User::get_SAMName(BSTR *pVal)
{
    if ( NULL == pVal )
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    WCHAR   sBuffer[POP3_MAX_ADDRESS_LENGTH];
    BSTR    bstrAuthType;
    CComPtr<IAuthMethod> spIAuthMethod;
    
    hr = m_pAdminX->GetCurrentAuthentication( &spIAuthMethod );
    if ( S_OK == hr )
        hr = spIAuthMethod->get_ID( &bstrAuthType );
    if ( S_OK == hr )
    {
        if ( 0 == _wcsicmp( bstrAuthType, SZ_AUTH_ID_DOMAIN_AD ))   // In AD the SAMName does not have to match the mailbox name
        {
            BSTR bstrAccount;
            _variant_t _v;
            
            hr = get_EmailName( &bstrAccount );
            if ( S_OK == hr )
            {
                _v = bstrAccount;
                if ( S_OK == hr )
                     hr = spIAuthMethod->Get( SZ_SAMACCOUNT_NAME, &_v );
                if ( S_OK == hr )
                {
                    if ( VT_BSTR == V_VT( &_v ))
                        wcsncpy( sBuffer, V_BSTR( &_v ), sizeof( sBuffer )/sizeof(WCHAR));
                    else
                        hr = E_FAIL;
                }
                SysFreeString ( bstrAccount );
            }
        }
        else if ( 0 == _wcsicmp( bstrAuthType, SZ_AUTH_ID_LOCAL_SAM ))
            wcsncpy( sBuffer, m_sUserName, sizeof( sBuffer )/sizeof(WCHAR));
        else
            hr = HRESULT_FROM_WIN32( ERROR_DS_INAPPROPRIATE_AUTH );
        SysFreeString( bstrAuthType );
    }
    if ( S_OK == hr )
    {
        sBuffer[sizeof( sBuffer )/sizeof(WCHAR)-1] = 0;
        *pVal = SysAllocString( sBuffer );
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CP3User::CreateQuotaFile( BSTR bstrMachineName, BSTR bstrUserName )
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    // bstrMachineName == NULL, bstrUserName == NULL acceptable

    HRESULT hr = S_OK;    
    BSTR bstrAuthType = NULL;
    
    // Get iAuthType!
    if ( S_OK == hr )
    {   // Do we need to enforce uniqueness across domains?
        CComPtr<IAuthMethod> spIAuthMethod;
        
        hr = m_pAdminX->GetCurrentAuthentication( &spIAuthMethod );
        if ( S_OK == hr )
            hr = spIAuthMethod->get_ID( &bstrAuthType );
    }
    if ( S_OK == hr )
    {
        if ( NULL == bstrUserName )
        {
            if ( 20 < wcslen( m_sUserName ))
            {   // Too long for a SAM name, this will only work with the UPN name
                WCHAR   sEmailAddr[POP3_MAX_ADDRESS_LENGTH];
                
                hr = m_pAdminX->BuildEmailAddr( m_sDomainName, m_sUserName, sEmailAddr, sizeof( sEmailAddr )/sizeof(WCHAR) );
                if ( S_OK == hr )
                    hr = m_pAdminX->CreateQuotaSIDFile( m_sDomainName, m_sUserName, bstrAuthType, bstrMachineName, sEmailAddr );
            }
            else
                hr = m_pAdminX->CreateQuotaSIDFile( m_sDomainName, m_sUserName, bstrAuthType, bstrMachineName, m_sUserName );
        }
        else
            hr = m_pAdminX->CreateQuotaSIDFile( m_sDomainName, m_sUserName, bstrAuthType, bstrMachineName, bstrUserName );
        SysFreeString( bstrAuthType );
    }
        
    return hr;
}

// VB Script can't use the property above!
STDMETHODIMP CP3User::GetMessageDiskUsage(VARIANT *pvFactor, VARIANT *pvValue)
{
    HRESULT hr;
    long    lFactor, lValue;

    VariantInit( pvFactor );
    VariantInit( pvValue );
    hr = get_MessageDiskUsage( &lFactor, &lValue );
    if ( S_OK == hr )
    {
        V_VT( pvFactor ) = VT_I4;
        V_I4( pvFactor ) = lFactor;
        V_VT( pvValue ) = VT_I4;
        V_I4( pvValue ) = lValue;
    }

    return hr;
}

STDMETHODIMP CP3User::get_Name(BSTR *pVal)
{
    if ( NULL == pVal )
        return E_INVALIDARG;

    *pVal = SysAllocString( m_sUserName );
    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Implementation: public

HRESULT CP3User::Init(IUnknown *pIUnk, CP3AdminWorker *p, LPCWSTR psDomainName , LPCWSTR psUserName )
{
    if ( NULL == pIUnk )
        return E_INVALIDARG;
    if ( NULL == p )
        return E_INVALIDARG;
    if ( NULL == psUserName )
        return E_INVALIDARG;
    if ( NULL == psDomainName )
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    m_pIUnk = pIUnk;
    m_pAdminX = p;
    wcsncpy( m_sUserName, psUserName, sizeof( m_sUserName )/sizeof(WCHAR) );
    wcsncpy( m_sDomainName, psDomainName, sizeof( m_sDomainName )/sizeof(WCHAR) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3user.h ===
// P3User.h : Declaration of the CP3User

#ifndef __P3USER_H_
#define __P3USER_H_

#include "resource.h"       // main symbols
#include <POP3Server.h>

/////////////////////////////////////////////////////////////////////////////
// CP3User
class ATL_NO_VTABLE CP3User : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CP3User, &CLSID_P3User>,
    public IDispatchImpl<IP3User, &IID_IP3User, &LIBID_P3ADMINLib>
{
public:
    CP3User();
    virtual ~CP3User();

DECLARE_REGISTRY_RESOURCEID(IDR_P3USER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CP3User)
    COM_INTERFACE_ENTRY(IP3User)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IP3User
public:
    STDMETHOD(get_ClientConfigDesc)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_SAMName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(CreateQuotaFile)(/*[in]*/ BSTR bstrMachineName, /*[in]*/ BSTR bstrUserName );
    STDMETHOD(GetMessageDiskUsage)(/*[out]*/ VARIANT *pvFactor, /*[out]*/ VARIANT *pvValue);
    STDMETHOD(get_EmailName)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_MessageDiskUsage)(/*[out]*/ long *plFactor, /*[out]*/ long *pVal);
    STDMETHOD(get_MessageCount)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
    STDMETHOD(get_Lock)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_Lock)(/*[in]*/ BOOL newVal);

// Implementation
public:
    HRESULT Init( IUnknown *pIUnk, CP3AdminWorker *pAdminX, LPCWSTR psDomainName , LPCWSTR psUserName );

// Attributes
protected:
    IUnknown *m_pIUnk;
    CP3AdminWorker *m_pAdminX;   // This is the object that actually does all the work.
    WCHAR   m_sDomainName[POP3_MAX_DOMAIN_LENGTH];
    WCHAR   m_sUserName[POP3_MAX_MAILBOX_LENGTH];

};

#endif //__P3USER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3userenum.cpp ===
// P3UserEnum.cpp : Implementation of CP3UserEnum
#include "stdafx.h"
#include "P3Admin.h"
#include "P3UserEnum.h"

#include "P3User.h"

/////////////////////////////////////////////////////////////////////////////
// CP3UserEnum

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CP3UserEnum::CP3UserEnum() :
    m_pIUnk(NULL), m_pAdminX(NULL), m_hfSearch(INVALID_HANDLE_VALUE)
{
    ZeroMemory( m_sDomainName, sizeof(m_sDomainName));
}

CP3UserEnum::~CP3UserEnum()
{
    if ( NULL != m_pIUnk )
        m_pIUnk->Release();
    if ( INVALID_HANDLE_VALUE != m_hfSearch )
        FindClose( m_hfSearch );
}

/////////////////////////////////////////////////////////////////////////////
// IEnumVARIANT

STDMETHODIMP CP3UserEnum::Next( /* [in] */ ULONG celt, /* [length_is][size_is][out] */ VARIANT __RPC_FAR *rgVar, /* [out] */ ULONG __RPC_FAR *pCeltFetched)
{
    if ( NULL == rgVar || ( 1 != celt && NULL == pCeltFetched ))
        return E_POINTER;
    if ( NULL == m_pAdminX ) return E_POINTER;

    ULONG   nActual = 0;
    HRESULT hr = S_OK;
    VARIANT __RPC_FAR *pVar = rgVar;
    VARIANT v;
    WCHAR   sBuffer[POP3_MAX_PATH];
    LPWSTR  ps = NULL;
    IUnknown    *pIUnk;
    CComObject<CP3User> *p;
    WIN32_FIND_DATA stFindData;

    VariantInit( &v );
    if ( S_OK == hr )
    {
        if ( INVALID_HANDLE_VALUE == m_hfSearch )
            hr = m_pAdminX->InitFindFirstUser( m_hfSearch, m_sDomainName, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) );
        else
            hr = m_pAdminX->GetNextUser( m_hfSearch, m_sDomainName, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) );
    }
    if ( S_OK == hr )
    {
        hr = CComObject<CP3User>::CreateInstance( &p );   // Reference count still 0
        if SUCCEEDED( hr )
        {
            // Increment the reference count on the source object and pass it to the new object
            hr = m_pIUnk->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>( &pIUnk ));
            if SUCCEEDED( hr )
            {
                hr = p->Init( pIUnk, m_pAdminX, m_sDomainName, sBuffer );
                if SUCCEEDED( hr )
                {
                    V_VT( &v ) = VT_DISPATCH;
                    hr = p->QueryInterface(IID_IDispatch, reinterpret_cast<void**>( &V_DISPATCH( &v )));
                    if SUCCEEDED( hr )
                        hr = VariantCopy( pVar, &v );
                    VariantClear( &v );
                    nActual++;
                }
            }
            if FAILED( hr )
                delete p;
        }
    }
    if (pCeltFetched)
        *pCeltFetched = nActual;
    if (SUCCEEDED(hr) && (nActual < celt))
        hr = S_FALSE;

    return hr;
}

STDMETHODIMP CP3UserEnum::Skip(ULONG celt)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    HRESULT hr = S_OK;
    WCHAR   sBuffer[POP3_MAX_PATH];
    WIN32_FIND_DATA stFindData;
    
    while ( (S_OK == hr) && (0 < celt) )
    {
        hr = m_pAdminX->GetNextUser( m_hfSearch, m_sDomainName, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) );
        celt--;
    }

    return hr;
}

STDMETHODIMP CP3UserEnum::Reset(void)
{
    CloseHandle( m_hfSearch );
    m_hfSearch = INVALID_HANDLE_VALUE;

    return S_OK;
}

STDMETHODIMP CP3UserEnum::Clone( /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppEnum)
{
    if ( NULL == ppEnum ) return E_INVALIDARG;
    if ( NULL == m_pAdminX ) return E_POINTER;

    HRESULT     hr;
    LPUNKNOWN   pIUnk;
    CComObject<CP3UserEnum> *p;

    *ppEnum = NULL;
    hr = CComObject<CP3UserEnum>::CreateInstance(&p); // Reference count still 0
    if SUCCEEDED( hr )
    {   // Increment the reference count on the source object and pass it to the new enumerator
        hr = m_pIUnk->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>( &pIUnk ));
        if SUCCEEDED( hr )
        {
            hr = p->Init( pIUnk, m_pAdminX, m_sDomainName );  // p must call release on pIUnk when done.
            if SUCCEEDED( hr )
                hr = p->QueryInterface( IID_IUnknown, reinterpret_cast<LPVOID*>( ppEnum ));
        }
        if FAILED( hr )
            delete p;   // Release
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// Implementation: public

HRESULT CP3UserEnum::Init(IUnknown *pIUnk, CP3AdminWorker *p, LPCWSTR psDomainName )
{
    if ( NULL == pIUnk )
        return E_INVALIDARG;
    if ( NULL == p )
        return E_INVALIDARG;
    if ( NULL == psDomainName )
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    m_pIUnk = pIUnk;
    m_pAdminX = p;
    wcsncpy( m_sDomainName, psDomainName, sizeof( m_sDomainName )/sizeof(WCHAR) );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3users.cpp ===
// P3Users.cpp : Implementation of CP3Users
#include "stdafx.h"
#include "P3Admin.h"
#include "P3Users.h"

#include "P3UserEnum.h"
#include "P3User.h"

#include <mailbox.h>
#include <AuthID.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CP3Users::CP3Users() :
    m_pIUnk(NULL), m_pAdminX(NULL), m_hfSearch(INVALID_HANDLE_VALUE)
{
    ZeroMemory( m_sDomainName, sizeof(m_sDomainName));
}

CP3Users::~CP3Users()
{
    if(INVALID_HANDLE_VALUE!=m_hfSearch)
    {
        FindClose(m_hfSearch);
    }
    if ( NULL != m_pIUnk )
        m_pIUnk->Release();
}

//////////////////////////////////////////////////////////////////////
// IP3Users
//////////////////////////////////////////////////////////////////////


STDMETHODIMP CP3Users::get__NewEnum(IEnumVARIANT* *ppIEnumVARIANT)
{
    if ( NULL == ppIEnumVARIANT ) return E_INVALIDARG;
    if ( NULL == m_pAdminX ) return E_POINTER;

    HRESULT hr = S_OK;
    LPUNKNOWN pIUnk;
    CComObject<CP3UserEnum>* p;

    *ppIEnumVARIANT = NULL;
    if SUCCEEDED( hr )
    {
        hr = CComObject<CP3UserEnum>::CreateInstance(&p); // Reference count still 0
        if SUCCEEDED( hr )
        {
            // Increment the reference count on the source object and pass it to the new enumerator
            hr = m_pIUnk->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>( &pIUnk ));
            if SUCCEEDED( hr )
            {
                hr = p->Init( pIUnk, m_pAdminX, m_sDomainName );
                if SUCCEEDED( hr )
                    hr = p->QueryInterface( IID_IEnumVARIANT, reinterpret_cast<LPVOID*>( ppIEnumVARIANT ));
            }
            if FAILED( hr )
                delete p;
        }
    }

    return hr;
}

STDMETHODIMP CP3Users::get_Count(long *pVal)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    return m_pAdminX->GetUserCount( m_sDomainName, pVal );
}

#define E_USERNOTFOUND  0x800708ad
STDMETHODIMP CP3Users::get_Item(VARIANT vIndex, IP3User **ppIUser)
{
    VARIANT *pv = &vIndex;
    
    if ( NULL == ppIUser ) return E_INVALIDARG;    
    if ( (VT_VARIANT|VT_BYREF) == V_VT( pv )) 
        pv = V_VARIANTREF( pv );
    if ( VT_BSTR != V_VT( pv ) && VT_I4 != V_VT( pv ))
        return E_INVALIDARG;
    if ( VT_BSTR == V_VT( pv ) && NULL == V_BSTR( pv ))
        return E_INVALIDARG;
    if ( NULL == m_pAdminX ) return E_POINTER;

    HRESULT hr;
    WCHAR   sMailbox[POP3_MAX_ADDRESS_LENGTH];
    WCHAR   sBuffer[POP3_MAX_PATH];
    CMailBox mailboxX;

    hr = m_pAdminX->MailboxSetRemote();
    // Find the requested item
    if ( VT_BSTR == V_VT( pv ))
    {   // Find by Name
        if ( sizeof( sMailbox )/sizeof(WCHAR) > wcslen( V_BSTR( pv )) + wcslen( m_sDomainName ) + 1 )
        {
            wcscpy( sMailbox, V_BSTR( pv ));
            wcscat( sMailbox, L"@" );
            wcscat( sMailbox, m_sDomainName );
            if ( mailboxX.OpenMailBox( sMailbox ))
                mailboxX.CloseMailBox();
            else
               hr = E_USERNOTFOUND;
            if ( sizeof( sBuffer )/sizeof(WCHAR) > wcslen( V_BSTR( pv ) ))
                wcscpy( sBuffer, V_BSTR( pv ));
            else
                hr = E_UNEXPECTED;
        }
    }
    if ( VT_I4 == V_VT( pv ))
    {   // Find by Index
        int iIndex = V_I4( pv );

        if ( iIndex < m_iCur )
        {
            hr = m_pAdminX->InitFindFirstUser( m_hfSearch, m_sDomainName, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) );
            m_iCur = 1;
        }
        while ( (S_OK == hr) && (iIndex > m_iCur) )
        {
            hr = m_pAdminX->GetNextUser( m_hfSearch, m_sDomainName, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) );
            m_iCur++;
        }
        if ( S_OK == hr )
        {
            if ( sizeof( sMailbox )/sizeof(WCHAR) > wcslen( sBuffer ) + wcslen( m_sDomainName ) + 1 )
            {
                wcscpy( sMailbox, sBuffer );
                wcscat( sMailbox, L"@" );
                wcscat( sMailbox, m_sDomainName );
                if ( mailboxX.OpenMailBox( sMailbox ))
                    mailboxX.CloseMailBox();
                else
                   hr = E_USERNOTFOUND;
            }
        }
    }
    m_pAdminX->MailboxResetRemote();
    
    // Wrap it with COM
    if SUCCEEDED( hr )
    {
        LPUNKNOWN   pIUnk;
        CComObject<CP3User> *p;

        hr = CComObject<CP3User>::CreateInstance( &p );   // Reference count still 0
        if SUCCEEDED( hr )
        {
            hr = m_pIUnk->QueryInterface(IID_IUnknown, reinterpret_cast<LPVOID*>( &pIUnk ));
            if SUCCEEDED( hr )
            {
                hr = p->Init( pIUnk, m_pAdminX, m_sDomainName, sBuffer );
                if SUCCEEDED( hr )
                    hr = p->QueryInterface(IID_IP3User, reinterpret_cast<void**>( ppIUser ));
            }
            if FAILED( hr )
                delete p;   // Release
        }
    }

    return hr;
}

STDMETHODIMP CP3Users::Add(BSTR bstrUserName)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    // Associate email address with user, if this fails the user does not exist
    // This will always fail in the MD5 case because we need a password!  Thus the user must use the /createuser flag
    HRESULT hr;
    CComPtr<IAuthMethod> spIAuthMethod;
    WCHAR   sEmailAddr[POP3_MAX_ADDRESS_LENGTH];
    _bstr_t _bstrEmailAddr;

    hr = m_pAdminX->GetCurrentAuthentication( &spIAuthMethod );
    if ( S_OK == hr )
        hr = m_pAdminX->BuildEmailAddr( m_sDomainName, bstrUserName, sEmailAddr, sizeof( sEmailAddr )/sizeof(WCHAR) );
    if ( S_OK == hr )
    {
        _bstrEmailAddr = sEmailAddr;
        hr = spIAuthMethod->AssociateEmailWithUser( _bstrEmailAddr );
    } 
    if ( S_OK == hr )
    {
        hr = m_pAdminX->AddUser( m_sDomainName, bstrUserName );
        if ( S_OK != hr )
        {   // Unassociate the user with the mailbox
            spIAuthMethod->UnassociateEmailWithUser( _bstrEmailAddr );  // Don't want to overwrite the error code
        }
    }
    if ( S_OK == hr )   // Create Quota SID File - won't revert from this operation
    {
        BSTR    bstrAuthType = NULL;
        
        hr = spIAuthMethod->get_ID( &bstrAuthType );
        if ( S_OK == hr )
        {
            if ( 0 == _wcsicmp( bstrAuthType, SZ_AUTH_ID_DOMAIN_AD ))   // In AD case use the UPN name instead of the SAM name
                hr = m_pAdminX->CreateQuotaSIDFile( m_sDomainName, bstrUserName, bstrAuthType, NULL, sEmailAddr );
            else if ( 0 == _wcsicmp( bstrAuthType, SZ_AUTH_ID_LOCAL_SAM ))
                hr = m_pAdminX->CreateQuotaSIDFile( m_sDomainName, bstrUserName, bstrAuthType, NULL, bstrUserName );
            SysFreeString( bstrAuthType );
        }
    }
    
    return hr;
}

STDMETHODIMP CP3Users::AddEx(BSTR bstrUserName, BSTR bstrPassword)
{
    if ( NULL == bstrUserName ) return E_INVALIDARG;
    if ( NULL == bstrPassword ) return E_INVALIDARG;
    if ( NULL == m_pAdminX ) return E_POINTER;

    HRESULT hr;    
    CComPtr<IAuthMethod> spIAuthMethod;
    WCHAR   sEmailAddr[POP3_MAX_ADDRESS_LENGTH];
    _bstr_t _bstrAccount;
    _variant_t _vPassword;
    BSTR    bstrAuthType = NULL;

    // Add to our store
    hr = m_pAdminX->AddUser( m_sDomainName, bstrUserName );
    if ( S_OK == hr )   // Add to the Authentication source
    {
        hr = m_pAdminX->GetCurrentAuthentication( &spIAuthMethod );
        if ( S_OK == hr )
            hr = spIAuthMethod->get_ID( &bstrAuthType );
        if ( S_OK == hr )
            hr = m_pAdminX->BuildEmailAddr( m_sDomainName, bstrUserName, sEmailAddr, sizeof( sEmailAddr )/sizeof(WCHAR) );
        if ( S_OK == hr )
        {
            _bstrAccount = sEmailAddr;
            _vPassword = bstrPassword;
            hr = spIAuthMethod->CreateUser( _bstrAccount, _vPassword );
        }
        if ( S_OK != hr )   // Failed let's revert the Add to our store
            m_pAdminX->RemoveUser( m_sDomainName, bstrUserName );
    }
    if ( S_OK == hr )   // Create Quota SID File
    {
        if ( 0 == _wcsicmp( bstrAuthType, SZ_AUTH_ID_DOMAIN_AD ))   // In AD case use the UPN name instead of the SAM name
            hr = m_pAdminX->CreateQuotaSIDFile( m_sDomainName, bstrUserName, bstrAuthType, NULL, sEmailAddr );
        else if ( 0 == _wcsicmp( bstrAuthType, SZ_AUTH_ID_LOCAL_SAM ))
            hr = m_pAdminX->CreateQuotaSIDFile( m_sDomainName, bstrUserName, bstrAuthType, NULL, bstrUserName );
    }
    if ( NULL != bstrAuthType )
        SysFreeString( bstrAuthType );

    return hr;
}

STDMETHODIMP CP3Users::Remove(BSTR bstrUserName)
{
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    // Associate email address with user, if this fails the user does not exist
    // This will always fail in the MD5 case because we need a password!  Thus the user must use the /createuser flag
    CComPtr<IAuthMethod> spIAuthMethod;
    WCHAR   sEmailAddr[POP3_MAX_ADDRESS_LENGTH];
    _bstr_t _bstrEmailAddr;

    HRESULT hr = m_pAdminX->GetCurrentAuthentication( &spIAuthMethod );
    if ( S_OK == hr )
        hr = m_pAdminX->BuildEmailAddr( m_sDomainName, bstrUserName, sEmailAddr, sizeof( sEmailAddr )/sizeof(WCHAR) );
    if ( S_OK == hr )
    {
        _bstrEmailAddr = sEmailAddr;
        hr = spIAuthMethod->UnassociateEmailWithUser( _bstrEmailAddr );
    } 
    if ( S_OK == hr )
    {
        hr = m_pAdminX->RemoveUser( m_sDomainName, bstrUserName );
        if ( S_OK != hr )
        {   // Unassociate the user with the mailbox
            spIAuthMethod->AssociateEmailWithUser( _bstrEmailAddr );  // Don't want to overwrite the error code
        }
    }
    return hr;
}

STDMETHODIMP CP3Users::RemoveEx(BSTR bstrUserName)
{
    if ( NULL == bstrUserName ) return E_INVALIDARG;
    if ( NULL == m_pAdminX ) return E_POINTER;
    
    HRESULT hr = m_pAdminX->RemoveUser( m_sDomainName, bstrUserName );
    if ( S_OK == hr )
    {
        CComPtr<IAuthMethod> spIAuthMethod;
        WCHAR   sEmailAddr[POP3_MAX_ADDRESS_LENGTH];
        _bstr_t _bstrAccount;

        hr = m_pAdminX->GetCurrentAuthentication( &spIAuthMethod );
        if ( S_OK == hr )
            hr = m_pAdminX->BuildEmailAddr( m_sDomainName, bstrUserName, sEmailAddr, sizeof( sEmailAddr )/sizeof(WCHAR) );
        if ( S_OK == hr )
        {
            _bstrAccount = sEmailAddr;
            hr = spIAuthMethod->DeleteUser( _bstrAccount );
            if ( S_FALSE == hr )
                hr = S_OK;
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////
// Implementation: public
//////////////////////////////////////////////////////////////////////

HRESULT CP3Users::Init(IUnknown *pIUnk, CP3AdminWorker *p, LPWSTR psDomainName )
{
    if ( NULL == pIUnk ) return E_INVALIDARG;
    if ( NULL == p ) return E_INVALIDARG;
    if ( NULL == psDomainName ) return E_INVALIDARG;
    
    m_pIUnk = pIUnk;
    m_pAdminX = p;
    wcsncpy( m_sDomainName, psDomainName, sizeof(m_sDomainName)/sizeof(WCHAR)-1);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////
// Implementation: protected
//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3userenum.h ===
// P3UserEnum.h : Declaration of the CP3UserEnum

#ifndef __P3USERENUM_H_
#define __P3USERENUM_H_

#include "resource.h"       // main symbols
#include <POP3Server.h>

/////////////////////////////////////////////////////////////////////////////
// CP3UserEnum
class ATL_NO_VTABLE CP3UserEnum : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CP3UserEnum, &CLSID_P3UserEnum>,
    public IEnumVARIANT
{
public:
    CP3UserEnum();
    virtual ~CP3UserEnum();

DECLARE_REGISTRY_RESOURCEID(IDR_P3USERENUM)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CP3UserEnum)
    COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

// IEnumVARIANT
public:
    HRESULT STDMETHODCALLTYPE Next( /* [in] */ ULONG celt, /* [length_is][size_is][out] */ VARIANT __RPC_FAR *rgVar, /* [out] */ ULONG __RPC_FAR *pCeltFetched);
    HRESULT STDMETHODCALLTYPE Skip( /* [in] */ ULONG celt);
    HRESULT STDMETHODCALLTYPE Reset( void);
    HRESULT STDMETHODCALLTYPE Clone( /* [out] */ IEnumVARIANT __RPC_FAR *__RPC_FAR *ppEnum);

// Implementation
public:
    HRESULT Init( IUnknown *pIUnk, CP3AdminWorker *pAdminX, LPCWSTR psDomainName );

// Attributes
protected:
    IUnknown *m_pIUnk;
    CP3AdminWorker *m_pAdminX;   // This is the object that actually does all the work.
    WCHAR   m_sDomainName[POP3_MAX_DOMAIN_LENGTH];

    HANDLE  m_hfSearch;
};

#endif //__P3USERENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by P3Admin.rc
//
#define IDS_PROJNAME                    100
#define IDR_P3CONFIG                    101
#define IDR_P3DOMAINS                   102
#define IDR_P3DOMAIN                    103
#define IDR_P3USERS                     104
#define IDR_P3SERVICE                   105
#define IDR_P3DOMAINENUM                106
#define IDR_P3USER                      107
#define IDR_P3USERENUM                  108
#define IDS_CLIENTCONFIG_CONFIRMATION   202
#define IDS_CLIENTCONFIG_CONFIRMATION2  203
#define IDS_CLIENTCONFIG_CONFIRMNOTE    204

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           109
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\sakui\msg\main.cpp ===
//++--------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Disabling thread calls
//
//  Arguments:  [in]    HINSTANCE - module handle
//              [in]    DWORD     - reason for call
//              reserved 
//
//  Returns:    BOOL    -   sucess/failure
//
//
//  History:    TMarsh      Created     11/07/2001
//
//----------------------------------------------------------------

#include "windows.h"

extern "C" BOOL WINAPI 
DllMain(
    HINSTANCE   hInstance, 
    DWORD       dwReason, 
    LPVOID      lpReserved
    )
{
	return (TRUE);
}   //  end of DllMain method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\sakui\msg\makefile.inc ===
pop3msg.rc: msg00001.bin

pop3msg.h msg00001.bin: pop3msg.mc
    mc -v pop3msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__657AE699_5C46_4024_B4DA_7ECBC3CA8E2F__INCLUDED_)
#define AFX_STDAFX_H__657AE699_5C46_4024_B4DA_7ECBC3CA8E2F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#define _WINSOCKAPI_   /* Prevent inclusion of winsock.h in windows.h */
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
//#include <winsock2.h>
#include <atlcom.h>
#include <comdef.h>
#include <assert.h>

#include "P3AdminWorker.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__657AE699_5C46_4024_B4DA_7ECBC3CA8E2F__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\p3admin\p3users.h ===
// P3Users.h : Declaration of the CP3Users

#ifndef __P3USERS_H_
#define __P3USERS_H_

#include "resource.h"       // main symbols
#include <POP3Server.h>

/////////////////////////////////////////////////////////////////////////////
// CP3Users
class ATL_NO_VTABLE CP3Users : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CP3Users, &CLSID_P3Users>,
    public IDispatchImpl<IP3Users, &IID_IP3Users, &LIBID_P3ADMINLib>
{
public:
    CP3Users();
    virtual ~CP3Users();

DECLARE_REGISTRY_RESOURCEID(IDR_P3USERS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CP3Users)
    COM_INTERFACE_ENTRY(IP3Users)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IP3Users
public:
    STDMETHOD(RemoveEx)(/*[in]*/ BSTR bstrUserName);
    STDMETHOD(AddEx)(/*[in]*/ BSTR bstrUserName, BSTR bstrPassword);
    STDMETHOD(Remove)(/*[in]*/ BSTR bstrUserName);
    STDMETHOD(Add)(/*[in]*/ BSTR bstrUserName);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT vIndex, /*[out, retval]*/ IP3User **ppIUser);
    STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get__NewEnum)(/*[out, retval]*/ IEnumVARIANT* *ppIEnumVARIANT);

// Implementation
public:
    HRESULT Init( IUnknown *pIUnk, CP3AdminWorker *pAdminX, LPWSTR psDomainName );

// Attributes
protected:
    IUnknown *m_pIUnk;
    CP3AdminWorker *m_pAdminX;   // This is the object that actually does all the work.
    WCHAR   m_sDomainName[POP3_MAX_DOMAIN_LENGTH];

    int     m_iCur;                 // Index of current user
    WIN32_FIND_DATA m_stFindData;   // Current User
    HANDLE  m_hfSearch;

};

#endif //__P3USERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\connserverdlg.h ===
#ifndef __CONNSERVERDLG_H
#define __CONNSERVERDLG_H

class CConnectServerDlg : public CDialogImpl<CConnectServerDlg>
{
public:
    typedef CDialogImpl<CConnectServerDlg> BC;

    enum { IDD = IDD_CONNECT_SERVER };

    BEGIN_MSG_MAP( CConnectServerDlg )        
        COMMAND_HANDLER         ( IDC_SERVERNAME, EN_CHANGE, OnEditChange )
        COMMAND_HANDLER         ( IDC_BROWSE_SERVERS, BN_CLICKED, OnBrowse )
        COMMAND_RANGE_HANDLER   ( IDOK, IDCANCEL, OnClose )
    END_MSG_MAP()

    // message handlers        
    LRESULT OnEditChange     ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );        
    LRESULT OnBrowse         ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );    
    LRESULT OnClose          ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    tstring    m_strName;    
};

#endif //__CONNSERVERDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\connserverdlg.cpp ===
//////////////////////////////////////////////////////////////
//
//  ConnServerDlg.cpp
//
//  Implementation of the "Connect..." dialog
//
//////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ConnServerDlg.h"

#include <dsrole.h>
#include <shlobj.h>

LRESULT CConnectServerDlg::OnEditChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    // Check for Domain Name length
    int nLen = SendDlgItemMessage( IDC_SERVERNAME, WM_GETTEXTLENGTH );    
    Prefix_EnableWindow( m_hWnd, IDOK, (nLen > 0));

    return 0;
}

LRESULT CConnectServerDlg::OnClose( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    StrGetEditText( m_hWnd, IDC_SERVERNAME, m_strName );    
    
    EndDialog(wID);
    return 0;
}

LRESULT CConnectServerDlg::OnBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    TCHAR   szPath[MAX_PATH];    
    
    int     nImage      = 0;
    tstring strTitle    = StrLoadString( IDS_MENU_POP3_CONNECT );
    HRESULT hr          = S_OK;

    ITEMIDLIST*      pidlRoot  = NULL;    
    LPITEMIDLIST     pList     = NULL;
    CComPtr<IMalloc> spMalloc  = NULL;
    hr = SHGetMalloc(&spMalloc);

    if( SUCCEEDED(hr) )
    {
        hr = SHGetFolderLocation( m_hWnd, CSIDL_NETWORK, NULL, NULL, &pidlRoot );
    }    
    
    if( SUCCEEDED(hr) )
    {
        BROWSEINFO BrowseInfo;
        BrowseInfo.hwndOwner        = m_hWnd;
        BrowseInfo.pidlRoot         = pidlRoot;
        BrowseInfo.pszDisplayName   = szPath;
        BrowseInfo.lpszTitle        = strTitle.c_str();
        BrowseInfo.ulFlags          = BIF_BROWSEFORCOMPUTER;
        BrowseInfo.lpfn             = NULL;
        BrowseInfo.lParam           = NULL;
        BrowseInfo.iImage           = nImage;

        pList = SHBrowseForFolder(&BrowseInfo);
    }

    if( pList ) 
    {
        SetDlgItemText( IDC_SERVERNAME, szPath );

        spMalloc->Free( pList );
        pList = NULL;
    }        

    if( pidlRoot )
    {
        spMalloc->Free( pidlRoot );
        pidlRoot = NULL;
    }    

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\deletemaildlg.h ===
#ifndef __DELMAILDLG_H
#define __DELMAILDLG_H

class CDeleteMailboxDlg : public CDialogImpl<CDeleteMailboxDlg>
{
public:
    typedef CDialogImpl<CDeleteMailboxDlg> BC;

    CDeleteMailboxDlg::CDeleteMailboxDlg(BOOL bHashPW) : m_bHashPW(bHashPW), m_bCreateUser(bHashPW) {};

    enum { IDD = IDD_DELETE_MAILBOX };

    BEGIN_MSG_MAP( CDeleteMailboxDlg )                
        MESSAGE_HANDLER         (WM_INITDIALOG, OnInitDialog)
        COMMAND_RANGE_HANDLER   (IDYES, IDNO, OnClose)
    END_MSG_MAP()

    LRESULT OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam,  BOOL& bHandled )
    {
        CheckDlgButton(IDC_DELETE_ACCOUNT, (m_bHashPW  ? BST_CHECKED : BST_UNCHECKED) );
        Prefix_EnableWindow( m_hWnd, IDC_DELETE_ACCOUNT, (m_bHashPW ? FALSE : TRUE) );
        ::ShowWindow( GetDlgItem(IDC_DELETE_ACCOUNT), (m_bHashPW ? SW_HIDE : SW_SHOW) );
        return 0;
    }

    // message handlers            
    LRESULT OnClose( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
    {        
        m_bCreateUser = (IsDlgButtonChecked(IDC_DELETE_ACCOUNT) == BST_CHECKED);
        EndDialog(wID);
        return 0;
    }
    
    BOOL    m_bHashPW;
    BOOL    m_bCreateUser;
};

#endif //__DELMAILDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\newdomaindlg.cpp ===
//////////////////////////////////////////////////////////////
//
//  NewDomainDlg.cpp
//
//  Implementation of the "Add Domain" dialog
//
//////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "NewDomainDlg.h"

LRESULT CNewDomainDlg::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    Prefix_EnableWindow( m_hWnd, IDOK, FALSE );        
    SendDlgItemMessage( IDC_DOMAIN_NAME,  EM_LIMITTEXT, 255, 0 );
    
    HWND hWndDomain = GetDlgItem(IDC_DOMAIN_NAME);
    if( hWndDomain && ::IsWindow(hWndDomain) )
    {
        m_wndDomainName.SubclassWindow( hWndDomain );
    }

    return 0;
}

LRESULT CNewDomainDlg::OnEditChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    // Check for Domain Name length
    int nLen = SendDlgItemMessage( IDC_DOMAIN_NAME, WM_GETTEXTLENGTH );        
    
    Prefix_EnableWindow( m_hWnd, IDOK, (nLen > 0) );

    return 0;
}

LRESULT CNewDomainDlg::OnClose( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    StrGetEditText( m_hWnd, IDC_DOMAIN_NAME, m_strName );

    EndDialog(wID);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\domainnode.cpp ===
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// CDomainNode
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#include "pop3.h"
#include "pop3snap.h"

#include "DomainNode.h"
#include "ServerNode.h"

#include "NewUserDlg.h"

static const GUID CDomainNodeGUID_NODETYPE   = 
{ 0xa30bd5b4, 0xf3f1, 0x4b42, { 0xba, 0x27, 0x62, 0x23, 0x9a, 0xd, 0xc1, 0x43 } };

const GUID*    CDomainNode::m_NODETYPE       = &CDomainNodeGUID_NODETYPE;
const OLECHAR* CDomainNode::m_SZNODETYPE     = OLESTR("A30BD5B4-F3F1-4b42-BA27-62239A0DC143");
const OLECHAR* CDomainNode::m_SZDISPLAY_NAME = OLESTR("");
const CLSID*   CDomainNode::m_SNAPIN_CLASSID = &CLSID_POP3ServerSnap;

/////////////////////////////////////////////////////////////////////////
//
//  Class implementation
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//  CDomainNode::CDomainNode
//
//  Constructor : Uses Domain interface for initialization

CDomainNode::CDomainNode(IP3Domain* pDomain, CServerNode* pParent)
{
    // Initialize our domain    
    m_spDomain = pDomain;
    m_pParent  = pParent;    
        
    BOOL bLocked = FALSE;
    HRESULT hr = E_FAIL;
    if( m_spDomain )
    {
        // Get our initial lock state for icon display        
        m_spDomain->get_Lock( &bLocked );

        // Get our name
        hr = m_spDomain->get_Name( &m_bstrDisplayName );        
    }

    if( FAILED(hr) )
    {
        m_bstrDisplayName = _T("");
    }

    // Initialize our column information
    m_bstrNumBoxes      = _T("");
    m_bstrSize          = _T("");
    m_bstrNumMessages   = _T("");
    m_bstrState         = _T("");
    
    // Initialize our Scope item 
    memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
    m_scopeDataItem.mask        = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
    m_scopeDataItem.cChildren   = 0;
    m_scopeDataItem.displayname = MMC_CALLBACK;
    m_scopeDataItem.nImage      = (bLocked ? DOMAINNODE_LOCKED_ICON : DOMAINNODE_ICON);
    m_scopeDataItem.nOpenImage  = (bLocked ? DOMAINNODE_LOCKED_ICON : DOMAINNODE_ICON);
    m_scopeDataItem.lParam      = (LPARAM) this;
    
    // Initialize our Result item
    memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
    m_resultDataItem.mask   = RDI_STR | RDI_IMAGE | RDI_PARAM;
    m_resultDataItem.str    = MMC_CALLBACK;
    m_resultDataItem.nImage = (bLocked ? DOMAINNODE_LOCKED_ICON : DOMAINNODE_ICON);
    m_resultDataItem.lParam = (LPARAM) this;    
}

/////////////////////////////////////////////////////////////////////////
//  CDomainNode::~CDomainNode
//
//  Destructor : Clean up our member-list of Users

CDomainNode::~CDomainNode()
{
    for(USERLIST::iterator iter = m_lUsers.begin(); iter != m_lUsers.end(); iter++)
    {
        delete (*iter);
    }
    m_lUsers.clear();
}

/////////////////////////////////////////////////////////////////////////
//  CDomainNode::DeleteUser
//
//  Helper function to delete a user from all of POP3

HRESULT CDomainNode::DeleteUser(CUserNode* pUser, BOOL bDeleteAccount)
{
    if( !pUser ) return E_INVALIDARG;
    if( !m_spDomain ) return E_FAIL;

    // Delete from POP3 Admin Interface

    // Get the User Container object
    CComPtr<IP3Users> spUsers;
    HRESULT hr = m_spDomain->get_Users( &spUsers );

    if( SUCCEEDED(hr) )
    {    
        // Delete the User from the container
        if( bDeleteAccount )
        {
            hr = spUsers->RemoveEx( pUser->m_bstrDisplayName );
        }
        else
        {
            hr = spUsers->Remove( pUser->m_bstrDisplayName );
        }
    }

    if( SUCCEEDED(hr) )
    {        
        // Update our list
        m_lUsers.remove(pUser);
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////
//  CDomainNode::IsLocked
//
//  Helper function to Allow children to not show their locks if the 
//  domain is locked

BOOL CDomainNode::IsLocked()
{
    if( !m_spDomain ) return TRUE;
    
    BOOL bLocked = TRUE;
    m_spDomain->get_Lock( &bLocked );

    return bLocked;
}

/////////////////////////////////////////////////////////////////////////
//  CDomainNode::BuildUsers
//
//  Helper function to refresh list of users and insert them

HRESULT CDomainNode::BuildUsers()
{    
    if( !m_spDomain ) return E_FAIL;

    HRESULT hr   = S_OK;
    HWND    hWnd = NULL;

    // Delete our Users            
    for(USERLIST::iterator iter = m_lUsers.begin(); iter != m_lUsers.end(); iter++)
    {
        delete (*iter);
    }    
    m_lUsers.clear();

    // Fill in all of our users
    CComPtr<IP3Users> spUsers;
    CComPtr<IEnumVARIANT> spUserEnum;

    // Get the User Container object
	hr = m_spDomain->get_Users( &spUsers );
    if( FAILED(hr) ) return hr;	

    // Get the enumeration of the users
	hr = spUsers->get__NewEnum( &spUserEnum );
    if( FAILED(hr) ) return hr;

    // Loop through all users, and add them to our vector	
	CComVariant var;				
    ULONG       lResult = 0;

	VariantInit( &var );

	while ( spUserEnum->Next(1, &var, &lResult) == S_OK )
    {
        if ( lResult == 1 )
        {
            CComQIPtr<IP3User> spUser;
            spUser = V_DISPATCH(&var);
            if( !spUser ) continue;

			CUserNode* spUserNode = new CUserNode(spUser, this);
            if( !spUserNode ) continue;
            
            m_lUsers.push_back(spUserNode);
        }

        VariantClear(&var);
    }   
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////
//
//  SnapInItemImpl
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//  CDomainNode::GetScopePaneInfo
//
//  Callback used to get Scope-Pane display information by MMC

HRESULT CDomainNode::GetScopePaneInfo(SCOPEDATAITEM *pScopeDataItem)
{
    if( !pScopeDataItem ) return E_INVALIDARG;
    if( !m_spDomain ) return E_FAIL;

    BOOL bLocked = FALSE;
    m_spDomain->get_Lock( &bLocked );

    if( pScopeDataItem->mask & SDI_STR )
        pScopeDataItem->displayname = m_bstrDisplayName;
    if( pScopeDataItem->mask & SDI_IMAGE )
        pScopeDataItem->nImage      = (bLocked ? DOMAINNODE_LOCKED_ICON : DOMAINNODE_ICON);
    if( pScopeDataItem->mask & SDI_OPENIMAGE )
        pScopeDataItem->nOpenImage  = (bLocked ? DOMAINNODE_LOCKED_ICON : DOMAINNODE_ICON);
    if( pScopeDataItem->mask & SDI_PARAM )
        pScopeDataItem->lParam      = m_scopeDataItem.lParam;
    if( pScopeDataItem->mask & SDI_STATE )
        pScopeDataItem->nState      = m_scopeDataItem.nState;
    if( pScopeDataItem->mask & SDI_CHILDREN )
        pScopeDataItem->cChildren   = 0;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::GetResultPaneInfo
//
//  Callback used to get Result Pane display information by MMC

HRESULT CDomainNode::GetResultPaneInfo(RESULTDATAITEM *pResultDataItem)
{
    if( !pResultDataItem ) return E_INVALIDARG;
    if( !m_spDomain ) return E_FAIL;

    BOOL bLocked = FALSE;
    m_spDomain->get_Lock( &bLocked );

    if( pResultDataItem->bScopeItem )
    {
        if( pResultDataItem->mask & RDI_STR )        
            pResultDataItem->str    = GetResultPaneColInfo(pResultDataItem->nCol);        
        if( pResultDataItem->mask & RDI_IMAGE )        
            pResultDataItem->nImage = (bLocked ? DOMAINNODE_LOCKED_ICON : DOMAINNODE_ICON);        
        if( pResultDataItem->mask & RDI_PARAM )        
            pResultDataItem->lParam = m_scopeDataItem.lParam;        

        return S_OK;
    }

    if( pResultDataItem->mask & RDI_STR )            
        pResultDataItem->str    = GetResultPaneColInfo(pResultDataItem->nCol);
    if( pResultDataItem->mask & RDI_IMAGE )
        pResultDataItem->nImage = (bLocked ? DOMAINNODE_LOCKED_ICON : DOMAINNODE_ICON);
    if( pResultDataItem->mask & RDI_PARAM )
        pResultDataItem->lParam = m_resultDataItem.lParam;
    if( pResultDataItem->mask & RDI_INDEX )
        pResultDataItem->nIndex = m_resultDataItem.nIndex;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::GetResultPaneColInfo
//
//  Helper function used as part of the GetResultPaneInfo.  This function
//  will supply the text for the different columns.

LPOLESTR CDomainNode::GetResultPaneColInfo(int nCol)
{   
    if( !m_spDomain ) return L"";

    switch( nCol )
    {
        case 0:     // Name
        {
            return m_bstrDisplayName;
        }

        case 1:     // Number of Mailboxes
        {
            long lCount = 0L;

            // Get the Users container object for this domain
            CComPtr<IP3Users> spUsers;
            HRESULT hr = m_spDomain->get_Users( &spUsers );

            if( SUCCEEDED(hr) )
            {
                // Get the number of mailboxes
                hr = spUsers->get_Count( &lCount );                
            }

            if( FAILED(hr) )
            {
                lCount = 0;  // Make sure we put in a valid error value.
            }

            // 1K buffer: Not likely we'll exceed that many digits
            TCHAR szNum[1024] = {0};
            _sntprintf( szNum, 1023, _T("%d"), lCount );            
            
            m_bstrNumBoxes = szNum;
            return m_bstrNumBoxes;
        }

        case 2:     // Domain Size (MB)
        {
            // We want our result in Megabytes
            long    lFactor = 0;
            long    lUsage  = 0;
            HRESULT hr      = m_spDomain->get_MessageDiskUsage( &lFactor, &lUsage );            

            if( FAILED(hr) )
            {
                lUsage = 0;  // Make sure we have a valid error value
            }

            // Convert to KiloBytes
            __int64 i64Usage = lFactor * lUsage;            
            i64Usage /= 1024;

            // 1K buffer: Not likely we'll exceed that many digits
            tstring strKiloByte = StrLoadString( IDS_KILOBYTE_EXTENSION );
            TCHAR   szNum[1024] = {0};
            _sntprintf( szNum, 1023, strKiloByte.c_str(), i64Usage );

            m_bstrSize = szNum;
            return m_bstrSize;
        }

        case 3:     // Number of Messages
        {
            long    lCount  = 0;
            HRESULT hr      = m_spDomain->get_MessageCount( &lCount );

            // 1K buffer: Not likely we'll exceed that many digits
            TCHAR szNum[1024] = {0};
            _sntprintf( szNum, 1023, _T("%d"), lCount );            
            
            m_bstrNumMessages = szNum;
            return m_bstrNumMessages;
        }

        case 4:     // State of Domain
        {            
            BOOL bLocked = FALSE;            
            m_spDomain->get_Lock( &bLocked );

            m_bstrState.LoadString( bLocked ? IDS_STATE_LOCKED : IDS_STATE_UNLOCKED );

            return m_bstrState;
        }

        default:
        {
            return L"";
        }
    }
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::Notify
//
//  Core callback functionality of this Node.  MMC will use this function
//  for all MMC provided functionality, such as Expanding, Renaming, and
//  Context Help

HRESULT CDomainNode::Notify( MMC_NOTIFY_TYPE event,
                                  LPARAM arg,
                                  LPARAM param,
                                  IComponentData* pComponentData,
                                  IComponent* pComponent,
                                  DATA_OBJECT_TYPES type)
{    
    HRESULT hr = S_FALSE;

    _ASSERT(pComponentData != NULL || pComponent != NULL);

    // Get a pointer to the console
    CComPtr<IConsole> spConsole = NULL;    
    if( pComponentData )
    {
        spConsole = ((CPOP3ServerSnapData*)pComponentData)->m_spConsole;
    }
    else if( pComponent )
    {
        spConsole = ((CPOP3ServerSnapComponent*)pComponent)->m_spConsole;
    }

    if( !spConsole ) return E_INVALIDARG;

    switch( event )
    {
    case MMCN_SHOW:
        {   
            hr = S_OK;
            
            CComQIPtr<IHeaderCtrl2> spHeaderCtrl = spConsole;            
            if( !spHeaderCtrl ) return E_NOINTERFACE;

            tstring strHeader = _T("");
            
            strHeader = StrLoadString(IDS_HEADER_USER_NAME);            
            spHeaderCtrl->InsertColumn(0, strHeader.c_str(), LVCFMT_LEFT, 100);
        
            strHeader = StrLoadString(IDS_HEADER_USER_SIZE);
            spHeaderCtrl->InsertColumn(1, strHeader.c_str(), LVCFMT_LEFT, 100);
        
            strHeader = StrLoadString(IDS_HEADER_USER_NUMMES);
            spHeaderCtrl->InsertColumn(2, strHeader.c_str(), LVCFMT_LEFT, 100);

            strHeader = StrLoadString(IDS_HEADER_USER_LOCKED);
            spHeaderCtrl->InsertColumn(3, strHeader.c_str(), LVCFMT_LEFT, 100);

            CComQIPtr<IResultData> spResultData = spConsole;
            if( !spResultData ) return E_NOINTERFACE;
            
            // Showing the list
            if( arg )
            {
                // Empty?  Then build the list.
                if( m_lUsers.empty() )
                {                    
                    hr = BuildUsers();
                }

                if( SUCCEEDED(hr) )
                {
                    // Display our users
                    for(USERLIST::iterator iter = m_lUsers.begin(); iter != m_lUsers.end(); iter++)
                    {
                        CUserNode* pUser = *iter;        
                        hr = spResultData->InsertItem(&(pUser->m_resultDataItem));
                        if( FAILED(hr) ) break;
                    }                
                }

                if( SUCCEEDED(hr) )
                {
                    CComQIPtr<IConsole2> spCons2 = spConsole;
                    if( spCons2 )
                    {
                        // Output the number of servers we added
                        tstring strMessage = StrLoadString(IDS_DOMAIN_STATUSBAR);
                        OLECHAR pszStatus[1024] = {0};
                        _sntprintf( pszStatus, 1023, strMessage.c_str(), m_lUsers.size() );
                        spCons2->SetStatusText( pszStatus );
                    }
                }
            }
            else
            {
                // We should delete our items
                hr = spResultData->DeleteAllRsltItems();                
            }

            break;
        }    

    case MMCN_ADD_IMAGES:
        {                           
            IImageList* pImageList = (IImageList*)arg;
            if( !pImageList ) return E_INVALIDARG;

            hr = LoadImages(pImageList);            
            break;
        } 
    case MMCN_VIEW_CHANGE:
        {   
            CComQIPtr<IResultData> spResultData = spConsole;
            if( !spResultData ) return E_NOINTERFACE;

            if( param == NAV_REFRESH )
            {
                // The "arg" controls clearing, for refresh
                if( arg )
                {
                    // Clear out the list
                    hr = spResultData->DeleteAllRsltItems();
                }
                else
                {
                    // Re-Add to our list
                    for(USERLIST::iterator iter = m_lUsers.begin(); iter != m_lUsers.end(); iter++)
                    {
                        CUserNode* pUser = *iter;        
                        hr = spResultData->InsertItem(&(pUser->m_resultDataItem));
                        if( FAILED(hr) ) break;
                    }                          
                }
            }

            if( param == NAV_ADD )
            {
                CUserNode* pUser = (CUserNode*)arg;
                if( !pUser ) return E_INVALIDARG;

                hr = spResultData->InsertItem(&(pUser->m_resultDataItem));
            }

            if( param == NAV_DELETE )
            {
                HRESULTITEM hrItem;
                hr = spResultData->FindItemByLParam( arg, &hrItem );

                if( SUCCEEDED(hr) )
                {
                    hr = spResultData->DeleteItem( hrItem, 0 );
                }
            }

            if( param == NAV_REFRESHCHILD )
            {
                CUserNode* pUser = (CUserNode*)arg;
                if( !pUser ) return E_INVALIDARG;
                
                RESULTDATAITEM rdi;
                ZeroMemory( &rdi, sizeof(rdi) );
                rdi.mask = RDI_IMAGE;
                hr = pUser->GetResultPaneInfo( &rdi );

                if( SUCCEEDED(hr) )
                {
                    hr = spResultData->FindItemByLParam( arg, &(rdi.itemID) );
                }

                if( SUCCEEDED(hr) )
                {
                    hr = spResultData->UpdateItem( rdi.itemID );
                }

                if( SUCCEEDED(hr) )
                {
                    // In order to actually update the icon, we have to do a set item
                    hr = spResultData->SetItem( &rdi );
                }
            }

            if( SUCCEEDED(hr) )
            {
                CComQIPtr<IConsole2> spCons2 = spConsole;
                if( spCons2 ) 
                {
                    // Output the number of servers we added
                    tstring strMessage = StrLoadString(IDS_DOMAIN_STATUSBAR);
                    OLECHAR pszStatus[1024] = {0};
                    _sntprintf( pszStatus, 1023, strMessage.c_str(), m_lUsers.size() );
                    spCons2->SetStatusText( pszStatus );
                }
            }

            break;
        }
    
    case MMCN_REFRESH:
        {
            hr = S_OK;

            // Get our Data Object
            CComPtr<IDataObject> spDataObject = NULL;
            GetDataObject(&spDataObject, CCT_SCOPE);
            if( !spDataObject ) return E_FAIL;

            // Update all the Views to have them remove their lists
            hr = spConsole->UpdateAllViews( spDataObject, 1, (LONG_PTR)NAV_REFRESH );
            if( FAILED(hr) ) return E_FAIL;

            // Rebuild the users list
            hr = BuildUsers();
            if( FAILED(hr) ) return hr;

            // Update all the Views to have them re-Add their lists
            hr = spConsole->UpdateAllViews( spDataObject, 0, (LONG_PTR)NAV_REFRESH );
            
            break;
        }

    case MMCN_DELETE:
        {
            hr = S_OK;
            
            tstring strMessage = _T("");
            HWND hWnd = NULL;    
            spConsole->GetMainWindow(&hWnd);

            strMessage         = StrLoadString(IDS_DOMAIN_CONFIRMDELETE);            
            tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
            if( MessageBox(hWnd, strMessage.c_str(), strTitle.c_str(), MB_YESNO | MB_ICONWARNING ) == IDYES )
            {
                hr = E_FAIL;

                // The parent needs to do the deletion
                if( m_pParent )
                {
                    hr = m_pParent->DeleteDomain(this);
                }

                // Check for non-existance condition
                if( hr == ERROR_PATH_NOT_FOUND )
                {
                    strMessage = StrLoadString( IDS_WARNING_DOMAINMISSING );                    
                    MessageBox( hWnd, strMessage.c_str(), strTitle.c_str(), MB_OK | MB_ICONWARNING );
                }

                if( SUCCEEDED(hr) )
                {
                    hr = E_FAIL;
                    // Remove ourselves from the tree
                    CComQIPtr<IConsoleNameSpace2> spNameSpace = spConsole;
                    if( spNameSpace )
                    {
                        hr = spNameSpace->DeleteItem( m_scopeDataItem.ID, TRUE );
                    }
                }

                if( SUCCEEDED(hr) )
                {
                    // Update our parent node, but ignore the result
                    CComPtr<IDataObject> spDataObject = NULL;
                    hr = m_pParent->GetDataObject( &spDataObject, CCT_SCOPE );
                    if( spDataObject )                     
                    {
                        spConsole->UpdateAllViews( spDataObject, (LPARAM)this, (LONG_PTR)NAV_DELETE );
                    }
                }

                if( SUCCEEDED(hr) )
                {
                    delete this;
                }                 

                if( FAILED(hr) )
                {                    
                    strMessage = StrLoadString(IDS_ERROR_DELETEDOMAIN);                    
                    DisplayError( hWnd, strMessage.c_str(), strTitle.c_str(), hr );                    
                }
            }
            break;
        }

    case MMCN_SELECT:
        {
            // if selecting node
            if( HIWORD(arg) )
            {
                hr = S_OK;

                // get the verb interface and enable rename
                CComPtr<IConsoleVerb> spConsVerb;
                if( spConsole->QueryConsoleVerb(&spConsVerb) == S_OK )
                {
                    // Enable the Refresh Menu                    
                    hr = spConsVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE); 
                    if( FAILED(hr) ) return hr;

                    hr = spConsVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
                    if( FAILED(hr) ) return hr;
                    
                    // Enable the Delete Menu
                    hr = spConsVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE); 
                    if( FAILED(hr) ) return hr;

                    hr = spConsVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
                    if( FAILED(hr) ) return hr;
                }
            }
            
            break;
        }

    case MMCN_CONTEXTHELP:
        {
            hr                                = S_OK;
            TCHAR    szWindowsDir[MAX_PATH+1] = {0};
            tstring  strHelpFile              = _T("");
            tstring  strHelpFileName          = StrLoadString(IDS_HELPFILE);
            tstring  strHelpTopicName         = StrLoadString(IDS_HELPTOPIC);

            if( strHelpFileName.empty() || strHelpTopicName.empty() )
            {
                return E_FAIL;
            }
            
            // Build path to %systemroot%\help
            UINT nSize = GetSystemWindowsDirectory( szWindowsDir, MAX_PATH );
            if( nSize == 0 || nSize > MAX_PATH )
            {
                return E_FAIL;
            }            
        
            strHelpFile = szWindowsDir;       // D:\windows
            strHelpFile += _T("\\Help\\");    // \help
            strHelpFile += strHelpFileName;   // \filename.chm
            strHelpFile += _T("::/");         // ::/
            strHelpFile += strHelpTopicName;  // index.htm            
        
            // Show the Help topic
            CComQIPtr<IDisplayHelp> spHelp = spConsole;
            if( !spHelp ) return E_NOINTERFACE;

            hr = spHelp->ShowTopic( (LPTSTR)strHelpFile.c_str() );
        
            break;
        }

    }// switch

    return hr;
}

/////////////////////////////////////////////////////////////////////////
//
//  ContextMenuImpl
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//  CDomainNode::AddMenuItems
//
//  Adds our context menus into the appropriate MMC provided menu 
//  locations.

HRESULT CDomainNode::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long* pInsertionAllowed, DATA_OBJECT_TYPES type )
{
    if( !pInsertionAllowed || !piCallback ) return E_INVALIDARG;
    if( !m_spDomain ) return E_FAIL;

    HRESULT             hr      = S_OK;    
    tstring             strMenu = _T("");
    tstring             strDesc = _T("");    
    CONTEXTMENUITEM2    singleMenuItem;
    ZeroMemory(&singleMenuItem, sizeof(CONTEXTMENUITEM2));
    
    CComQIPtr<IContextMenuCallback2> spContext2 = piCallback;
    if( !spContext2 ) return E_NOINTERFACE;
           
    // Add the Lock or Unlock Menu to the "Top" part of the MMC Context Menu    
    if( *pInsertionAllowed & CCM_INSERTIONALLOWED_TOP )
    {                
        singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
        singleMenuItem.fFlags            = MF_ENABLED;
        singleMenuItem.fSpecialFlags     = 0;

        // Query the state of this domain to see which menu to load
        BOOL bLocked = FALSE;
        m_spDomain->get_Lock( &bLocked );

        if( bLocked )
        {
            strMenu = StrLoadString(IDS_MENU_DOMAIN_UNLOCK);
            strDesc = StrLoadString(IDS_MENU_DOMAIN_UNLOCK_DESC);

            singleMenuItem.strName                      = (LPWSTR)strMenu.c_str();
            singleMenuItem.strStatusBarText             = (LPWSTR)strDesc.c_str();
            singleMenuItem.strLanguageIndependentName   = L"DOMAIN_UNLOCK";
            singleMenuItem.lCommandID                   = IDM_DOMAIN_TOP_UNLOCK;            
        }
        else
        {
            strMenu = StrLoadString(IDS_MENU_DOMAIN_LOCK);
            strDesc = StrLoadString(IDS_MENU_DOMAIN_LOCK_DESC);

            singleMenuItem.strName                      = (LPWSTR)strMenu.c_str();
            singleMenuItem.strStatusBarText             = (LPWSTR)strDesc.c_str();
            singleMenuItem.strLanguageIndependentName   = L"DOMAIN_LOCK";
            singleMenuItem.lCommandID                   = IDM_DOMAIN_TOP_LOCK;
        }

        if( !strMenu.empty() )
        {
            hr = spContext2->AddItem( &singleMenuItem );
            if( FAILED(hr) ) return hr;
        }
    }

    // Add the User Menu to the "New" part of the MMC Context Menu
    if( (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
    {   
        singleMenuItem.lInsertionPointID            = CCM_INSERTIONPOINTID_PRIMARY_NEW;
        singleMenuItem.fFlags                       = MF_ENABLED;
        singleMenuItem.fSpecialFlags                = 0;

        strMenu = StrLoadString(IDS_MENU_DOMAIN_NEWUSER);
        strDesc = StrLoadString(IDS_MENU_DOMAIN_NEWUSER_DESC);
        
        singleMenuItem.strName                      = (LPWSTR)strMenu.c_str();
        singleMenuItem.strStatusBarText             = (LPWSTR)strDesc.c_str();
        singleMenuItem.strLanguageIndependentName   = L"NEW_USER";
        singleMenuItem.lCommandID                   = IDM_DOMAIN_NEW_USER;

        if( !strMenu.empty() )
        {
            hr = spContext2->AddItem( &singleMenuItem );        
            if( FAILED(hr) ) return hr;
        }
    }    

    return hr;
}

/////////////////////////////////////////////////////////////////////////
//  CDomainNode::OnDomainLock
//
//  Lock or unlock the domain, depending on its current state

HRESULT CDomainNode::OnDomainLock( bool& bHandled, CSnapInObjectRootBase* pObj )
{
    bHandled = true;
    if( !pObj ) return E_INVALIDARG;   
    if( !m_spDomain ) return E_FAIL;

    // Lock this domain        
    HRESULT           hr        = S_OK;
    BOOL              bLocked   = FALSE;
    CComPtr<IConsole> spConsole = NULL;
    hr = GetConsole( pObj, &spConsole );
    if( FAILED(hr) || !spConsole ) return E_NOINTERFACE;

    hr      = m_spDomain->get_Lock( &bLocked );
    bLocked = !bLocked;

    if( SUCCEEDED(hr) )
    {
        hr = m_spDomain->put_Lock( bLocked );
    }

    if( SUCCEEDED(hr) )
    {
        // Set our icons here
        m_scopeDataItem.nImage      = (bLocked ? DOMAINNODE_LOCKED_ICON : DOMAINNODE_ICON);
        m_scopeDataItem.nOpenImage  = (bLocked ? DOMAINNODE_LOCKED_ICON : DOMAINNODE_ICON);
        m_resultDataItem.nImage     = (bLocked ? DOMAINNODE_LOCKED_ICON : DOMAINNODE_ICON);

        // Insert it into the scope tree                
        CComQIPtr<IConsoleNameSpace2> spConsoleNameSpace = spConsole;
        if( !spConsoleNameSpace ) return E_NOINTERFACE;

        hr = spConsoleNameSpace->SetItem(&m_scopeDataItem);        
    }

    // Do a FULL Refresh to update the user lists.
    // Get our Data Object
    CComPtr<IDataObject> spDataObject = NULL;
    GetDataObject(&spDataObject, CCT_SCOPE);
    if( !spDataObject ) return E_FAIL;

    // Update all the Views to have them remove their lists
    hr = spConsole->UpdateAllViews( spDataObject, 1, (LONG_PTR)NAV_REFRESH );
    if( FAILED(hr) ) return E_FAIL;

    // Rebuild the users list
    hr = BuildUsers();
    if( FAILED(hr) ) return hr;

    // Update all the Views to have them re-Add their lists
    hr = spConsole->UpdateAllViews( spDataObject, 0, (LONG_PTR)NAV_REFRESH );

    return hr;
}

/////////////////////////////////////////////////////////////////////////
//  CDomainNode::OnNewUser
//
//  Display the New User Dialog, and use the info to create a new POP3 
//  user/mailbox and update the Result view

HRESULT CDomainNode::OnNewUser( bool& bHandled, CSnapInObjectRootBase* pObj )
{
    bHandled   = true;   
    if( !pObj ) return E_INVALIDARG;    
    if( !m_pParent || !m_spDomain ) return E_FAIL;

    // Grab our Current Authentication method
    HRESULT                 hr        = S_OK;
    HWND                    hWnd      = NULL;
    CComPtr<IConsole>       spConsole = NULL;    
    hr = GetConsole( pObj, &spConsole );
    if( FAILED(hr) || !spConsole ) return E_NOINTERFACE;

    CComQIPtr<IConsole2> spConsole2 = spConsole;
    if( !spConsole2 ) return E_NOINTERFACE;
    
    spConsole2->GetMainWindow(&hWnd);

    BOOL bSAM  = FALSE;
    BOOL bHash = FALSE;
    BOOL bConfirm = TRUE;
    hr = GetAuth(&bHash, &bSAM);
    if( FAILED(hr) )
    {
        // bail out here
        tstring strMessage = StrLoadString(IDS_ERROR_RETRIEVEAUTH);
        tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
        ::MessageBox( hWnd, strMessage.c_str(), strTitle.c_str(), MB_OK | MB_ICONWARNING );
        return hr;
    }    
    
    // Get the username and load a Dialog box that asks for a user name, and user email name
    CComPtr<IP3Users> spUsers;                    
    hr = m_spDomain->get_Users( &spUsers );
    if ( S_OK == hr )
        hr = GetConfirmAddUser( &bConfirm );
    if( FAILED(hr) )
    {
        // Failed to add the user
        tstring strMessage = StrLoadString(IDS_ERROR_CREATEMAIL);
        tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
        DisplayError( hWnd, strMessage.c_str(), strTitle.c_str(), hr );
        return hr;
    }
    
    CNewUserDlg dlg(spUsers, m_bstrDisplayName, m_pParent->m_bCreateUser, bHash, bSAM, bConfirm );

    if( dlg.DoModal() == IDOK )
    {
        if ( dlg.isHideDoNotShow() )
            SetConfirmAddUser( FALSE );
        CComVariant var;
        CComPtr<IP3User> spUser;
        VariantInit(&var);
        var = dlg.m_strName.c_str();
        hr = spUsers->get_Item( var, &spUser );

        CUserNode* pUserNode =  new CUserNode(spUser, this);

        if( pUserNode )
        {
			m_lUsers.push_back( pUserNode );
        }

        // Re-Select our node to update the result
        // Get our Data Object
        CComPtr<IDataObject> spDataObject = NULL;
        GetDataObject(&spDataObject, CCT_SCOPE);
        if( !spDataObject ) return E_FAIL;

        hr = spConsole2->UpdateAllViews( spDataObject, (LPARAM)pUserNode, (LONG_PTR)NAV_ADD );
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////
//
//  Helper Functions
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//  CDomainNode::GetAuth
//
//  pbHashPW : Return Boolean for Hash Password Authentication
//  pbSAM    : Return Boolean for Local SAM Authentication

HRESULT CDomainNode::GetAuth(BOOL* pbHashPW, BOOL* pbSAM)
{
    if( !m_pParent ) return E_FAIL;

    return m_pParent->GetAuth(pbHashPW, pbSAM);
}

/////////////////////////////////////////////////////////////////////////
//  CDomainNode::GetConfirmAddUser
//
//  pbConfirm : Return Boolean for User Add Confirmation

HRESULT CDomainNode::GetConfirmAddUser( BOOL *pbConfirm )
{
    if( !m_pParent ) return E_POINTER;

    return m_pParent->GetConfirmAddUser( pbConfirm );
}

/////////////////////////////////////////////////////////////////////////
//  CDomainNode::SetConfirmAddUser
//
//  bConfirm : New Boolean Value for User Add Confirmation

HRESULT CDomainNode::SetConfirmAddUser( BOOL bConfirm )
{
    if( !m_pParent ) return E_POINTER;

    return m_pParent->SetConfirmAddUser( bConfirm );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\newuserconfirmdlg.cpp ===
//////////////////////////////////////////////////////////////
//
//  NewUserConfirmDlg.cpp
//
//  Implementation of the "Add Mailbox" dialog
//
//////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "NewUserConfirmDlg.h"

LRESULT CNewUserConfirmDlg::OnCancel( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    EndDialog( IDCANCEL );
    return 0;
}

LRESULT CNewUserConfirmDlg::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    // initialize the checkbox based on the passed in default    
    ::ShowWindow( GetDlgItem(IDC_optDoNotShow), (m_bHideDoNotShow ? SW_HIDE : SW_SHOW) );
    SetDlgItemText( IDC_lblConfirm, m_psDesc );

    int     x = GetSystemMetrics(SM_CXICON);
    int     y = GetSystemMetrics(SM_CYICON);
    HANDLE  hIcon = LoadImage( NULL, MAKEINTRESOURCE(IDI_INFORMATION), IMAGE_ICON, x, y, LR_SHARED );
    LONG_PTR lStyle;

    if (hIcon)
    {
        HWND hWndIcon = GetDlgItem( IDC_ICON_INFO );
        if (hWndIcon)
        {
            // Set the style to size the icon according to the size of control
            lStyle = ::GetWindowLongPtr(hWndIcon, GWL_STYLE);
            if (0 != lStyle)
            {
                if ( ::SetWindowLongPtr(hWndIcon, GWL_STYLE, lStyle | SS_REALSIZECONTROL))
                {
                    ::SetWindowPos( hWndIcon, 0, 0, 0, x, y, SWP_NOMOVE | SWP_NOZORDER );  
                    ::SendMessage( hWndIcon, STM_SETIMAGE, (WPARAM) IMAGE_ICON, (LPARAM)hIcon );
                }
            }
        }
    }
    return 0;
}

LRESULT CNewUserConfirmDlg::OnOK( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    m_bHideDoNotShow = (IsDlgButtonChecked(IDC_optDoNotShow) == BST_CHECKED);
    EndDialog( IDOK );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\newdomaindlg.h ===
#ifndef __NEWDOMAINDLG_H
#define __NEWDOMAINDLG_H

#include <tmplEdit.h>

class CNewDomainDlg : public CDialogImpl<CNewDomainDlg>
{
public:
    typedef CDialogImpl<CNewDomainDlg> BC;

    enum { IDD = IDD_NEW_DOMAIN };

    BEGIN_MSG_MAP( CNewDomainDlg )        
        COMMAND_HANDLER         (IDC_DOMAIN_NAME, EN_CHANGE, OnEditChange)        
        MESSAGE_HANDLER         (WM_INITDIALOG, OnInitDialog)
        COMMAND_RANGE_HANDLER   (IDOK, IDCANCEL, OnClose)
    END_MSG_MAP()

    // message handlers        
    LRESULT OnEditChange     ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );        
    LRESULT OnClose          ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnInitDialog     ( UINT mMsg, WPARAM wParam, LPARAM lParam,  BOOL& bHandled );

    tstring                 m_strName;  
    CWindowImplDomainName<> m_wndDomainName;
};

#endif //__NEWDOMAINDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\domainnode.h ===
#ifndef DomainNode_h
#define DomainNode_h

#include "resource.h"
#include ".\atlsnap.h"
#include <objidl.h>

#include "pop3.h"
#include <P3Admin.h>
#include "UserNode.h"

class CPOP3ServerSnapData;
class CServerNode;
typedef std::list<CUserNode*> USERLIST;

//////////////////////////////////////////////////////////////////////////////////
//
// CDomainNode
//
//////////////////////////////////////////////////////////////////////////////////
class CDomainNode : public CSnapInItemImpl<CDomainNode>
{
public:
    static const GUID* m_NODETYPE;
    static const OLECHAR* m_SZNODETYPE;
    static const OLECHAR* m_SZDISPLAY_NAME;
    static const CLSID* m_SNAPIN_CLASSID;

    CComPtr<IControlbar> m_spControlBar;
    
    BEGIN_SNAPINCOMMAND_MAP(CDomainNode, FALSE)
        SNAPINCOMMAND_ENTRY         ( IDM_DOMAIN_TOP_LOCK,   OnDomainLock )
        SNAPINCOMMAND_ENTRY         ( IDM_DOMAIN_TOP_UNLOCK, OnDomainLock )
        SNAPINCOMMAND_ENTRY         ( IDM_DOMAIN_NEW_USER,   OnNewUser    )
    END_SNAPINCOMMAND_MAP()


    // Standard Class Constructor/Destructor
    CDomainNode(IP3Domain* pDomain, CServerNode* pParent);
    virtual ~CDomainNode();
    
    // Standard ATL Snap-In Impl Over-rides
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if ( type == CCT_SCOPE || type == CCT_RESULT )
            return S_OK;
        return S_FALSE;
    }
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem);
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem);
    LPOLESTR GetResultPaneColInfo(int nCol);
    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param, IComponentData* pComponentData, IComponent* pComponent, DATA_OBJECT_TYPES type);
       
    // MenuItem Implementations
    STDMETHOD(AddMenuItems) (LPCONTEXTMENUCALLBACK piCallback, long* pInsertionAllowed, DATA_OBJECT_TYPES type );
    STDMETHOD(OnNewUser)    (bool& bHandled, CSnapInObjectRootBase* pObj );
    STDMETHOD(OnDomainLock) (bool& bHandled, CSnapInObjectRootBase* pObj );

public:
    
    // Public function for childrent to delete themselves
    HRESULT DeleteUser(CUserNode* pUser, BOOL bDeleteAccount = FALSE);    
    BOOL    IsLocked();

    // Helper Function
    HRESULT GetAuth(BOOL* pbHashPW = NULL, BOOL* pbSAM = NULL);
    HRESULT GetConfirmAddUser( BOOL *pbConfirm );
    HRESULT SetConfirmAddUser( BOOL bConfirm );

private:    

    // Private function to help with refresh and expanding
    HRESULT BuildUsers( );    
    
    // Domain Information
    USERLIST            m_lUsers;   
    CComPtr<IP3Domain>  m_spDomain;  

    // Parent Information
    CServerNode* m_pParent;    

    // Column text needs to be allocated by us, so we'll free them in the destructor
    CComBSTR    m_bstrNumBoxes;
    CComBSTR    m_bstrSize;
    CComBSTR    m_bstrNumMessages;    
    CComBSTR    m_bstrState;    
};

#endif // DomainNode_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\newuserdlg.cpp ===
//////////////////////////////////////////////////////////////
//
//  NewUserDlg.cpp
//
//  Implementation of the "Add Mailbox" dialog
//
//////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "NewUserDlg.h"

#include "NewUserConfirmDlg.h"

LRESULT CNewUserDlg::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{
    // initialize the checkbox based on the passed in default    
    CheckDlgButton( IDC_USER_CREATEUSER, ((m_bCreateUser && !m_bHashPW) ? BST_CHECKED : BST_UNCHECKED) );
    Prefix_EnableWindow( m_hWnd, IDC_USER_CREATEUSER, !m_bHashPW );
    ::ShowWindow( GetDlgItem(IDC_USER_CREATEUSER), (m_bHashPW ? SW_HIDE : SW_SHOW) );

    Prefix_EnableWindow( m_hWnd, IDC_PASSWORD,        (m_bCreateUser || m_bHashPW) );
    Prefix_EnableWindow( m_hWnd, IDC_CONFIRM,         (m_bCreateUser || m_bHashPW) );
    Prefix_EnableWindow( m_hWnd, IDC_PASSWORD_STATIC, (m_bCreateUser || m_bHashPW) );
    Prefix_EnableWindow( m_hWnd, IDC_CONFIRM_STATIC,  (m_bCreateUser || m_bHashPW) );    

    // Max Text length of 40 for all three boxes
    SendDlgItemMessage( IDC_USER_NAME, EM_LIMITTEXT, m_bSAM ? 20 : 64, 0 );
    SendDlgItemMessage( IDC_PASSWORD,  EM_LIMITTEXT, 40, 0 );
    SendDlgItemMessage( IDC_CONFIRM,   EM_LIMITTEXT, 40, 0 );

    HWND hwndAlias = GetDlgItem(IDC_USER_NAME);
    if( hwndAlias && ::IsWindow(hwndAlias) )
    {
        m_wndAlias.SubclassWindow( hwndAlias );
    }

    return 0;
}

LRESULT CNewUserDlg::OnEditChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{    
    EnableButtons();

    return 0;
}

LRESULT CNewUserDlg::OnCreateClicked( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    BOOL bChecked = (IsDlgButtonChecked(IDC_USER_CREATEUSER) == BST_CHECKED);

    Prefix_EnableWindow( m_hWnd, IDC_PASSWORD,        bChecked );
    Prefix_EnableWindow( m_hWnd, IDC_CONFIRM,         bChecked );
    Prefix_EnableWindow( m_hWnd, IDC_PASSWORD_STATIC, bChecked );
    Prefix_EnableWindow( m_hWnd, IDC_CONFIRM_STATIC,  bChecked );

    EnableButtons();
    return 0;
}

LRESULT CNewUserDlg::OnClose( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{
    m_bCreateUser = (IsDlgButtonChecked(IDC_USER_CREATEUSER) == BST_CHECKED);
    StrGetEditText( m_hWnd, IDC_USER_NAME, m_strName );    

    if( wID == IDOK )
    {
        tstring strPassword = _T("");
        tstring strConfirm  = _T("");
        StrGetEditText( m_hWnd, IDC_PASSWORD, strPassword );
        StrGetEditText( m_hWnd, IDC_CONFIRM,  strConfirm  );    

        // Verify the password
        if( _tcscmp(strPassword.c_str(), strConfirm.c_str()) != 0 )
        {
            tstring strMessage = StrLoadString(IDS_ERROR_PASSNOMATCH);
            tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
            ::MessageBox( m_hWnd, strMessage.c_str(), strTitle.c_str(), MB_OK | MB_ICONWARNING );
            SecureZeroMemory( (LPTSTR)strPassword.c_str(), sizeof(TCHAR)*strPassword.length() );
            SecureZeroMemory( (LPTSTR)strConfirm.c_str(),  sizeof(TCHAR)*strConfirm.length()  );            
            return -1;
        }

        // Create the account
        HRESULT hr = S_OK;
        
        if( m_bCreateUser || m_bHashPW )
        {
            CComBSTR bstrName = m_strName.c_str();
            CComBSTR bstrPass = strPassword.c_str();
            hr = m_spUsers->AddEx( bstrName, bstrPass );
            SecureZeroMemory( (LPOLESTR)bstrPass.m_str, sizeof(OLECHAR)*bstrPass.Length() );            
        }
        else
        {
            CComBSTR bstrName = m_strName.c_str();
            hr = m_spUsers->Add( bstrName );
        }
        SecureZeroMemory( (LPTSTR)strPassword.c_str(), sizeof(TCHAR)*strPassword.length() );
        SecureZeroMemory( (LPTSTR)strConfirm.c_str(),  sizeof(TCHAR)*strConfirm.length()  );

        if ( S_OK == hr )
        {   // Do we need confirmation text?
            BOOL    bSAMNameDifferent = FALSE;
            VARIANT v;
            CComPtr<IP3User> spUser;

            VariantInit( &v );
            V_VT( &v ) = VT_BSTR;
            V_BSTR( &v ) = SysAllocString( m_strName.c_str() );
            if ( NULL == V_BSTR( &v ))
                hr = E_OUTOFMEMORY;
            if ( S_OK == hr )                   
                hr = m_spUsers->get_Item( v, &spUser );
            VariantClear( &v );
            if ( S_OK == hr )
            {
                BSTR bstrSAMName = NULL;
                
                hr = spUser->get_SAMName( &bstrSAMName );
                if ( S_OK == hr )
                {
                    if ( 0 != _wcsicmp( bstrSAMName, m_strName.c_str() ))
                        bSAMNameDifferent = TRUE;
                    SysFreeString( bstrSAMName );
                }
                else if ( HRESULT_FROM_WIN32( ERROR_DS_INAPPROPRIATE_AUTH ) == hr )
                    hr = S_OK;
            }
            if ( S_OK == hr && ( m_bConfirm || bSAMNameDifferent ))
            {   // Get confirmation text
                BSTR    bstrConfirm;
                
                hr = spUser->get_ClientConfigDesc( &bstrConfirm );
                if ( S_OK == hr )
                {
                    CNewUserConfirmDlg dlgConfirm( bstrConfirm, (m_bConfirm && !bSAMNameDifferent)?false:true);
                    if ( IDOK == dlgConfirm.DoModal() && !bSAMNameDifferent )
                        m_bConfirm = !dlgConfirm.isHideDoNotShow();
                    SysFreeString( bstrConfirm );
                }
            }
        }
        else
        {
            // Failed to add the user
            tstring strMessage = StrLoadString(IDS_ERROR_CREATEMAIL);
            tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
            if(HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr)
                hr = HRESULT_FROM_WIN32(ERROR_USER_EXISTS);
            DisplayError( m_hWnd, strMessage.c_str(), strTitle.c_str(), hr );
            return -1;
        }
    }    
    
    EndDialog( wID );
    return 0;
}

void CNewUserDlg::EnableButtons()
{
    // Check for Password match and Name length     
    BOOL bPasswordValid = FALSE;
    BOOL bChecked       = (IsDlgButtonChecked(IDC_USER_CREATEUSER) == BST_CHECKED);

    // Get the length of the name
    int nNameLen = SendDlgItemMessage( IDC_USER_NAME, WM_GETTEXTLENGTH );

    if( !m_bHashPW && !bChecked )
    {
        bPasswordValid = TRUE;
    }
    else 
    {
        int     nPasswordLen = SendDlgItemMessage( IDC_PASSWORD, WM_GETTEXTLENGTH );     
        int     nConfirmLen  = SendDlgItemMessage( IDC_PASSWORD, WM_GETTEXTLENGTH );             
        
        bPasswordValid = ((nPasswordLen > 0) || (nConfirmLen > 0));
    }

    Prefix_EnableWindow( m_hWnd, IDOK, ((nNameLen > 0) && bPasswordValid) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\newuserdlg.h ===
#ifndef __NEWUSERDLG_H
#define __NEWUSERDLG_H

#include <P3Admin.h>
#include <tmplEdit.h>

class CNewUserDlg : public CDialogImpl<CNewUserDlg>
{
public:
    typedef CDialogImpl<CNewUserDlg> BC;

    CNewUserDlg(IP3Users* pUsers, LPWSTR psDomainName, BOOL bCreateDefault = FALSE, BOOL bHashPassword = FALSE, BOOL bSAMAuthentication = FALSE, BOOL bConfirm = TRUE) :             
            m_spUsers(pUsers),
            m_psDomainName(psDomainName),
            m_bCreateUser(bCreateDefault),
            m_bHashPW(bHashPassword),
            m_bSAM(bSAMAuthentication),
            m_bConfirm(bConfirm)
    {
    };

    enum { IDD = IDD_NEW_USER };

    BEGIN_MSG_MAP( CNewUserDlg )        
        COMMAND_HANDLER         (IDC_USER_NAME, EN_CHANGE, OnEditChange)        
        COMMAND_HANDLER         (IDC_PASSWORD,  EN_CHANGE, OnEditChange)        
        COMMAND_HANDLER         (IDC_CONFIRM,   EN_CHANGE, OnEditChange)        
        COMMAND_HANDLER         (IDC_USER_CREATEUSER, BN_CLICKED, OnCreateClicked)
        COMMAND_RANGE_HANDLER   (IDOK, IDCANCEL, OnClose)
        MESSAGE_HANDLER         (WM_INITDIALOG, OnInitDialog)
    END_MSG_MAP()

    // message handlers        
    LRESULT OnEditChange     ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );    
    LRESULT OnCreateClicked  ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnClose          ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnInitDialog     ( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled  );

    BOOL isHideDoNotShow(){ return !m_bConfirm; }

    tstring     m_strName;
    BOOL        m_bCreateUser;

private:

    void        EnableButtons();    

    LPWSTR              m_psDomainName;
    BOOL                m_bConfirm;
    BOOL                m_bSAM;
    BOOL                m_bHashPW;
    CComPtr<IP3Users>   m_spUsers;
    CWindowImplAlias<>  m_wndAlias;
};

#endif //__NEWUSERDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\newuserconfirmdlg.h ===
#ifndef __NEWUSERCONFIRMDLG_H
#define __NEWUSERCONFIRMDLG_H

class CNewUserConfirmDlg : public CDialogImpl<CNewUserConfirmDlg>
{
public:
    typedef CDialogImpl<CNewUserConfirmDlg> BC;

    CNewUserConfirmDlg( LPWSTR psDesc, bool bHideDoNotShow ) : 
        m_psDesc(psDesc), m_bHideDoNotShow(bHideDoNotShow) 
    {;}

    enum { IDD = IDD_NEW_USER_CONFIRM };

    BEGIN_MSG_MAP( CNewUserConfirmDlg )        
        COMMAND_ID_HANDLER   (IDOK, OnOK)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        MESSAGE_HANDLER         (WM_INITDIALOG, OnInitDialog)
    END_MSG_MAP()

    // message handlers        
    LRESULT OnCancel         ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );
    LRESULT OnInitDialog     ( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled  );
    LRESULT OnOK             ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );

    BOOL isHideDoNotShow(){ return m_bHideDoNotShow; }

// Attributes
protected:
    LPWSTR      m_psDesc;
    bool        m_bHideDoNotShow;
    
};

#endif //__NEWUSERCONFIRMDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\pop3.cpp ===
// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f svrgrpsnapps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "pop3.h"

#include "Pop3_i.c"
#include "pop3Snap.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_POP3ServerSnap, CPOP3ServerSnapData)
OBJECT_ENTRY(CLSID_POP3ServerSnapAbout, CPOP3ServerSnapAbout)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_POP3ServerSNAPLib);
        DisableThreadLibraryCalls(hInstance);

        tstring strTemp = StrLoadString( IDS_SNAPINNAME );
        CRootNode::m_SZDISPLAY_NAME = new OLECHAR[strTemp.length()+1];
        if( CRootNode::m_SZDISPLAY_NAME )
        {
            ocscpy( (LPOLESTR)CRootNode::m_SZDISPLAY_NAME, strTemp.c_str() );
        }
        else
        {            
            return FALSE;
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        if( CRootNode::m_SZDISPLAY_NAME )
        {
            delete [] CRootNode::m_SZDISPLAY_NAME;
        }
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\pop3snap.cpp ===
#include "stdafx.h"
#include "pop3snap.h"

////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////
//
// CPOP3ServerSnapData
//
//////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

HRESULT CPOP3ServerSnapData::Initialize(LPUNKNOWN pUnknown)
{    
    if( !pUnknown ) return E_INVALIDARG;

    HRESULT hr = IComponentDataImpl<CPOP3ServerSnapData, CPOP3ServerSnapComponent >::Initialize(pUnknown);
    if( FAILED(hr) ) return hr;
    
    CComPtr<IImageList> spImageList;
    if( m_spConsole->QueryScopeImageList(&spImageList) != S_OK )
    {
        ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
        return E_UNEXPECTED;
    }

    hr = LoadImages(spImageList);

    return hr;
}

HRESULT WINAPI CPOP3ServerSnapData::UpdateRegistry(BOOL bRegister)
{
    // Load snap-in name 
    tstring strSnapinName = StrLoadString(IDS_SNAPINNAME);

    // Specify the substitution parameters for IRegistrar.
    _ATL_REGMAP_ENTRY rgEntries[] =
    {
        {TEXT("SNAPIN_NAME"), strSnapinName.c_str()},
        {NULL, NULL},
    };

    // Register the component data object
    HRESULT hr = _Module.UpdateRegistryFromResource(IDR_POP3SERVERSNAP, bRegister, rgEntries);

    return hr;
}

HRESULT CPOP3ServerSnapData::GetHelpTopic(LPOLESTR* ppszHelpFile)
{
    if( !ppszHelpFile ) return E_INVALIDARG;

	*ppszHelpFile = NULL;	
    
    TCHAR    szWindowsDir[MAX_PATH+1] = {0};
    tstring  strHelpFile              = _T("");
    tstring  strHelpFileName          = StrLoadString(IDS_HELPFILE);
    
    if( strHelpFileName.empty() ) return E_FAIL;
    
    // Build path to %systemroot%\help
    UINT nSize = GetSystemWindowsDirectory( szWindowsDir, MAX_PATH );
    if( nSize == 0 || nSize > MAX_PATH )
    {
        return E_FAIL;
    }            

    strHelpFile = szWindowsDir;       // D:\windows
    strHelpFile += _T("\\Help\\");    // \help
    strHelpFile += strHelpFileName;   // \filename.chm

    // Form file path in allocated buffer
    int nLen = strHelpFile.length() + 1;

    *ppszHelpFile = (LPOLESTR)CoTaskMemAlloc(nLen * sizeof(WCHAR));
    if( *ppszHelpFile == NULL ) return E_OUTOFMEMORY;

    // Copy into allocated buffer
    ocscpy( *ppszHelpFile, T2OLE((LPTSTR)strHelpFile.c_str()) );

    return S_OK;
}


HRESULT CPOP3ServerSnapData::GetLinkedTopics(LPOLESTR* ppszLinkedFiles)
{
    if( !ppszLinkedFiles ) return E_INVALIDARG;

	// no linked files
	*ppszLinkedFiles = NULL;
	
    return S_FALSE;
}

// called by menu handlers
HRESULT GetConsole( CSnapInObjectRootBase *pObj, IConsole** pConsole )
{
    if( !pObj || !pConsole ) return E_INVALIDARG;
    if( (pObj->m_nType != 1) && (pObj->m_nType != 2) ) return E_INVALIDARG;

    if (pObj->m_nType == 1)
    {
        *pConsole = ((CPOP3ServerSnapData*) pObj)->m_spConsole;
    }
    else
    {
        *pConsole = ((CPOP3ServerSnapComponent*) pObj)->m_spConsole;
    }

    if( !*pConsole ) return E_NOINTERFACE;

    (*pConsole)->AddRef();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\pop3snap.h ===
#ifndef POP3Serversnap_h
#define POP3Serversnap_h

#include "resource.h"

#include <atlsnap.h>
#include <objidl.h>

#include "pop3.h"
#include "RootNode.h"
#include <P3Admin.h>

enum _node_icons {
    ROOTNODE_ICON   = 0,
    SERVERNODE_ICON = 0,
    DOMAINNODE_ICON,
    USERNODE_ICON,
    DOMAINNODE_LOCKED_ICON,
    USERNODE_LOCKED_ICON,
    MAX_NODE_ICON
};

enum _notify_allviews {
    NAV_REFRESH,
    NAV_DELETE,
    NAV_ADD,
    NAV_REFRESHCHILD    
};

class CPOP3ServerSnapComponent;

//////////////////////////////////////////////////////////////////////////////////////////////////
//
// CPOP3ServerSnapData
//
/////////////////////////////////////////////////////////////////////////////////////////////////
class CPOP3ServerSnapData : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CSnapInObjectRoot<1, CPOP3ServerSnapData>,
    public IComponentDataImpl<CPOP3ServerSnapData, CPOP3ServerSnapComponent>,
    public IExtendContextMenuImpl<CPOP3ServerSnapData>,
    public IExtendPropertySheetImpl<CPOP3ServerSnapData>,    
    public CComCoClass<CPOP3ServerSnapData, &CLSID_POP3ServerSnap>,
    public IPersistStream,
    public ISnapinHelp2
{
public:        

    CPOP3ServerSnapData()
    {
        m_pNode = new CRootNode;
        _ASSERTE(m_pNode != NULL);

        m_pComponentData = this;        
    }

    virtual ~CPOP3ServerSnapData()
    {
        if( m_pNode )
        {
            delete m_pNode;
            m_pNode = NULL;
        }
    }

    BEGIN_COM_MAP(CPOP3ServerSnapData)
        COM_INTERFACE_ENTRY(IComponentData)
        COM_INTERFACE_ENTRY(ISnapinHelp2)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
        COM_INTERFACE_ENTRY(IPersistStream)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CPOP3ServerSnapData)
    
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

    static void WINAPI ObjectMain(bool bStarting)
    {
        if ( bStarting )
        {
            CSnapInItem::Init();
        }
    }    

    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
    {
        // On a property change (Server only) we need to update all views of the Server Node completely.        
        if( event == MMCN_PROPERTY_CHANGE && !lpDataObject && param )
        {
            CSnapInItem* pItem = (CSnapInItem*)param;            

            HRESULT hr = pItem->Notify( MMCN_REFRESH, arg, param, m_pComponentData, NULL, CCT_SCOPE );
            if( SUCCEEDED(hr) )
            {
                // Get our Data Object
                CComPtr<IDataObject> spDataObject = NULL;
                pItem->GetDataObject(&spDataObject, CCT_SCOPE);
                if( !spDataObject ) return E_FAIL;

                // Call the Update, but don't update return result                
                return m_spConsole->UpdateAllViews( spDataObject, 0, (LONG_PTR)NAV_ADD );
            }

            return hr;
        }

        if ( lpDataObject != NULL )
        {
            return IComponentDataImpl<CPOP3ServerSnapData, CPOP3ServerSnapComponent>::Notify(lpDataObject, event, arg, param);
        }

        return E_NOTIMPL;
    }

    // ISnapinHelp2
	STDMETHOD(GetHelpTopic)(LPOLESTR* ppszHelpFile);
	STDMETHOD(GetLinkedTopics)(LPOLESTR* ppszHelpFiles);

    // IPersistStream    
    STDMETHOD(IsDirty)()
    {
        return S_FALSE;
    }

    STDMETHOD(Load)(IStream *pStream)
    {
        if( m_pNode )
        {
            return static_cast<CRootNode*>(m_pNode)->Load(pStream);
        }

        return E_FAIL;
    }

    STDMETHOD(Save)(IStream *pStream, BOOL fClearDirty)
    {
        if( m_pNode )
        {
            return static_cast<CRootNode*>(m_pNode)->Save(pStream);
        }

        return E_FAIL;
    }

    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize)
    {
        return E_NOTIMPL;
    }

    STDMETHOD(GetClassID)(CLSID *pClassID)
    {
        if( pClassID )
        {
            memcpy(pClassID, &CLSID_POP3ServerSnap, sizeof(CLSID));
            return S_OK;
        }

        return E_POINTER;
    }

    // Class registration method
    static HRESULT WINAPI UpdateRegistry(BOOL bRegister); 
};

/////////////////////////////////////////////////////////////////////////////////
//
// CPOP3ServerSnapComponent
//
////////////////////////////////////////////////////////////////////////////////
class CPOP3ServerSnapComponent : 
        public CComObjectRootEx<CComSingleThreadModel>,
        public CSnapInObjectRoot<2, CPOP3ServerSnapData>,
        public IExtendContextMenuImpl<CPOP3ServerSnapComponent>,
        public IExtendPropertySheetImpl<CPOP3ServerSnapComponent>,
        public IComponentImpl<CPOP3ServerSnapComponent>
{
public:
    BEGIN_COM_MAP(CPOP3ServerSnapComponent)
        COM_INTERFACE_ENTRY(IComponent)
        COM_INTERFACE_ENTRY(IExtendContextMenu)
        COM_INTERFACE_ENTRY(IExtendPropertySheet)
    END_COM_MAP()

public:

    CPOP3ServerSnapComponent()
    {
        m_pCurrentItem = NULL;
    }

    // IComponent    
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
    {        
        if( event == MMCN_SHOW )
        {            
            if( arg )
            {
                // Cache the currently selected node
                CSnapInItem* pItem;
			    DATA_OBJECT_TYPES type;
                m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);                
                m_pCurrentItem = pItem;                
            }
            else
            {
                m_pCurrentItem = NULL;
            }
        }
        
        if( event == MMCN_VIEW_CHANGE )
        {            
            CSnapInItem* pItem;
			DATA_OBJECT_TYPES type;
            m_pComponentData->GetDataClass(lpDataObject, &pItem, &type);

            if( pItem != m_pCurrentItem )
            {
                // Only Change view of selected item
                return S_FALSE;
            }
        }
        
        if( event == MMCN_PROPERTY_CHANGE )
        {            
            // On a property change (Server only) we need to update all views of the Server Node completely.
            CSnapInItem* pItem = (CSnapInItem*)param;            

            HRESULT hr = pItem->Notify( MMCN_REFRESH, arg, param, m_pComponentData, NULL, CCT_SCOPE );
            if( SUCCEEDED(hr) )
            {
                // Get our Data Object
                CComPtr<IDataObject> spDataObject = NULL;
                pItem->GetDataObject(&spDataObject, CCT_SCOPE);
                if( !spDataObject ) return E_FAIL;

                // Call the Update, but don't update return result                
                return m_spConsole->UpdateAllViews( spDataObject, 0, (LONG_PTR)NAV_ADD );
            }
            
            return hr;
        }

        if ( lpDataObject )
        {
            return IComponentImpl<CPOP3ServerSnapComponent>::Notify(lpDataObject, event, arg, param);
        }

        return E_NOTIMPL;
    }  

protected:
    CSnapInItem* m_pCurrentItem;
};

//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// CPOP3ServerSnapAbout
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
class ATL_NO_VTABLE CPOP3ServerSnapAbout : public ISnapinAbout,
public CComObjectRoot,
public CComCoClass< CPOP3ServerSnapAbout, &CLSID_POP3ServerSnapAbout>
{
public:
    DECLARE_REGISTRY(CPOP3ServerSnapAbout, _T("POP3ServerSnapAbout.1"), _T("POP3ServerSnapAbout.1"), IDS_POP3SERVERSNAP_DESC, THREADFLAGS_BOTH);

    HICON m_hIcon;

    BEGIN_COM_MAP(CPOP3ServerSnapAbout)
        COM_INTERFACE_ENTRY(ISnapinAbout)
    END_COM_MAP()

    CPOP3ServerSnapAbout()
    {
        m_hIcon = NULL;
    }

    STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
    {
        if( !lpDescription ) return E_INVALIDARG;

        USES_CONVERSION;
        
        // Load the string
        tstring strDescription = StrLoadString( IDS_POP3SERVERSNAP_DESC );        
        if( strDescription.empty() ) return E_FAIL;

        // Make a copy to return
        *lpDescription = (LPOLESTR)CoTaskMemAlloc( (strDescription.length() + 1) * sizeof(OLECHAR) );
        if( *lpDescription == NULL ) return E_OUTOFMEMORY;

        ocscpy( *lpDescription, T2OLE((LPTSTR)strDescription.c_str()) );

        return S_OK;
    }

    STDMETHOD(GetProvider)(LPOLESTR *lpName)
    {
        if( !lpName ) return E_INVALIDARG;

        USES_CONVERSION;

        // Load the string
        tstring strProvider = StrLoadString( IDS_POP3SERVERSNAP_PROVIDER );
        if( strProvider.empty() ) return E_FAIL;

        // Make a copy to return
        *lpName = (LPOLESTR)CoTaskMemAlloc( (strProvider.length() + 1) * sizeof(OLECHAR) );
        if ( *lpName == NULL ) return E_OUTOFMEMORY;

        ocscpy( *lpName, T2OLE((LPTSTR)strProvider.c_str()) );

        return S_OK;
    }

    STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
    {
        if( !lpVersion ) return E_INVALIDARG;

        USES_CONVERSION;

        TCHAR szBuf[MAX_PATH+1] = {0};
        DWORD dwLen = GetModuleFileName( _Module.GetModuleInstance(), szBuf, MAX_PATH );        

        if( dwLen < MAX_PATH )
        {            
            LPDWORD pTranslation    = NULL;
            UINT    uNumTranslation = 0;
            DWORD   dwHandle        = NULL;
            DWORD   dwSize          = GetFileVersionInfoSize(szBuf, &dwHandle);
            if( !dwSize ) return E_FAIL;

            BYTE* pVersionInfo = new BYTE[dwSize];           
            if( !pVersionInfo ) return E_OUTOFMEMORY;

            if (!GetFileVersionInfo( szBuf, dwHandle, dwSize, pVersionInfo ) ||
                !VerQueryValue( (const LPVOID)pVersionInfo, _T("\\VarFileInfo\\Translation"), (LPVOID*)&pTranslation, &uNumTranslation ) ||
                !pTranslation ) 
            {
                delete [] pVersionInfo;
                
                pVersionInfo    = NULL;                
                pTranslation    = NULL;
                uNumTranslation = 0;

                return E_FAIL;
            }

            uNumTranslation /= sizeof(DWORD);           

            tstring strQuery = _T("\\StringFileInfo\\");            

            // 8 characters for the language/char-set, 
            // 1 for the slash, 
            // 1 for terminating NULL
            TCHAR szTranslation[128] = {0};            
            _sntprintf( szTranslation, 127, _T("%04x%04x\\"), LOWORD(*pTranslation), HIWORD(*pTranslation));

            strQuery += szTranslation;            
            strQuery += _T("FileVersion");

            LPBYTE lpVerValue = NULL;
            UINT uSize = 0;

            if (!VerQueryValue(pVersionInfo, (LPTSTR)strQuery.c_str(), (LPVOID *)&lpVerValue, &uSize)) 
            {
                delete [] pVersionInfo;
                return E_FAIL;
            }

            // check the version            
            _tcsncpy( szBuf, (LPTSTR)lpVerValue, MAX_PATH-1 );

            delete [] pVersionInfo;
        }        

        *lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
        if( *lpVersion == NULL ) return E_OUTOFMEMORY;

        ocscpy( *lpVersion, T2OLE(szBuf) );

        return S_OK;
    }

    STDMETHOD(GetSnapinImage)(HICON* phAppIcon)
    {
        if( !phAppIcon ) return E_INVALIDARG;
        
        if ( !m_hIcon )
        {
            m_hIcon = LoadIcon(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_Icon));
        }

        *phAppIcon = m_hIcon;
        return S_OK;
    }

    STDMETHOD(GetStaticFolderImage)(HBITMAP*  phSmallImage,
                                    HBITMAP*  phSmallImageOpen,
                                    HBITMAP*  phLargeImage,
                                    COLORREF* pcMask)
    {
        if( !phSmallImage || !phSmallImageOpen || !phLargeImage || !pcMask ) return E_INVALIDARG;

        *phSmallImage     = LoadBitmap( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_RootSmall) );
        *phSmallImageOpen = LoadBitmap( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_RootSmall) );
        *phLargeImage     = LoadBitmap( _Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_RootLarge) );
        *pcMask           = RGB(255,0,255);

        return S_OK;
    }
};

// Extra helper functions
HRESULT GetConsole( CSnapInObjectRootBase *pObj, IConsole** pConsole );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\rootnode.h ===
#ifndef RootNode_h
#define RootNode_h

#include "resource.h"
#include <atlsnap.h>
#include <objidl.h>

#include "pop3.h"
#include <P3Admin.h>

class CServerNode;
typedef std::list<CServerNode*> SERVERLIST;

//////////////////////////////////////////////////////////////////////////////////
//
// CRootNode
//
//////////////////////////////////////////////////////////////////////////////////
class CRootNode : public CSnapInItemImpl<CRootNode>
{
public:
    static const GUID* m_NODETYPE;
    static const OLECHAR* m_SZNODETYPE;
    static const OLECHAR* m_SZDISPLAY_NAME;
    static const CLSID* m_SNAPIN_CLASSID;

    CComPtr<IControlbar> m_spControlBar;   
    
    BEGIN_SNAPINCOMMAND_MAP(CRootNode, FALSE)        
        SNAPINCOMMAND_ENTRY( IDM_POP3_TOP_CONNECT, OnConnect )
    END_SNAPINCOMMAND_MAP()

    CRootNode();
    virtual ~CRootNode();    

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if ( type == CCT_SCOPE || type == CCT_RESULT )
        {
            return S_OK;
        }
        return S_FALSE;
    }
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem);
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem);    
    STDMETHOD(GetResultViewType)( LPOLESTR* ppViewType, long* pViewOptions );
    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
                       LPARAM arg,
                       LPARAM param,
                       IComponentData* pComponentData,
                       IComponent* pComponent,
                       DATA_OBJECT_TYPES type);    

    // MenuItem Implementations
    STDMETHOD(AddMenuItems) (LPCONTEXTMENUCALLBACK piCallback, long* pInsertionAllowed, DATA_OBJECT_TYPES type );
    STDMETHOD(OnConnect)    (bool& bHandled, CSnapInObjectRootBase* pObj );

    // IPersistStream Implementations
    STDMETHOD(Load)         (IStream *pStream);
    STDMETHOD(Save)         (IStream *pStream);

public:

    // Public function for children to delete themselves
    HRESULT     DeleteServer(CServerNode* pServerNode);

private:
    SERVERLIST m_lServers;
};

#endif // RootNode_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\servernode.cpp ===
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// CServerNode
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <Pop3RegKeys.h>
#include <AuthID.h>

// Access to Snapin
#include "pop3.h"
#include "pop3snap.h"

// Access to Nodes we use
#include "ServerNode.h"
#include "DomainNode.h"

// Access to dialogs we'll display
#include "NewDomainDlg.h"
#include "ServerProp.h"


static const GUID CServerNodeGUID_NODETYPE             = 
{ 0x4c30b06c, 0x1dc3, 0x4c0d, { 0x87, 0xb4, 0x64, 0xbf, 0xe8, 0x22, 0xf4, 0x50 } };

const           GUID*    CServerNode::m_NODETYPE       = &CServerNodeGUID_NODETYPE;
const           OLECHAR* CServerNode::m_SZNODETYPE     = OLESTR("4C30B06C-1DC3-4c0d-87B4-64BFE822F450");
const           OLECHAR* CServerNode::m_SZDISPLAY_NAME = OLESTR("");
const           CLSID*   CServerNode::m_SNAPIN_CLASSID = &CLSID_POP3ServerSnap;

/////////////////////////////////////////////////////////////////////////
//
//  Class implementation
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//  CServerNode::CServerNode
//
//  Constructor : Uses servername for remote Servers

CServerNode::CServerNode(BSTR strServerName, CRootNode* pParent, BOOL bLocalServer) :
    m_lRefCount(1),
    m_hrValidServer(S_OK),
    m_bstrAuthentication(_T("")),
    m_bstrMailRoot(_T("")),
    m_bstrPort(_T("")),
    m_bstrLogLevel(_T("")),
    m_bstrServiceStatus(_T(""))
{
    // Initialize our Scope item
    memset( &m_scopeDataItem, 0, sizeof(m_scopeDataItem) );
    m_scopeDataItem.mask        = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
    m_scopeDataItem.displayname = MMC_CALLBACK;
    m_scopeDataItem.nImage      = 0;         
    m_scopeDataItem.nOpenImage  = 0;     
    m_scopeDataItem.lParam      = (LPARAM) this;
    
    // Initialize our Result item
    memset( &m_resultDataItem, 0, sizeof(m_resultDataItem) );
    m_resultDataItem.mask   = RDI_STR | RDI_IMAGE | RDI_PARAM;
    m_resultDataItem.str    = MMC_CALLBACK;
    m_resultDataItem.nImage = 0;    
    m_resultDataItem.lParam = (LPARAM) this;    

    if( bLocalServer )
    {
        // We are the local server for now.
        TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1] = {0};
        DWORD dwBuffer = MAX_COMPUTERNAME_LENGTH+1;
        if( GetComputerName(szComputerName, &dwBuffer) )
        {
            m_bstrDisplayName = szComputerName;
        }
        else
        {
#if DBG
            m_bstrDisplayName = CComBSTR("Local Server");
#else
            m_bstrDisplayName = CComBSTR("");
#endif
        }
    }

    // Get Parent Information
    m_pParent     = pParent;

    // Open our Pop3 Admin Interface and store it
	HRESULT hr = CoCreateInstance(__uuidof(P3Config), NULL, CLSCTX_ALL, __uuidof(IP3Config), (LPVOID*)&m_spConfig);    

    if( FAILED(hr) || !m_spConfig )
    {
        m_hrValidServer = FAILED(hr) ? hr : E_FAIL;
        return;
    }

    if( !bLocalServer )
    {
        // Configure our remote computer setup    
        m_bstrDisplayName = strServerName;
    
        hr = m_spConfig->put_MachineName( strServerName );
        if( FAILED(hr) )
        {
            // Invalid Server Name!
            m_hrValidServer = hr;
            return;
        }        
    }
    
    // Do our User creation property   
    DWORD dwValue = 0;
    RegQueryCreateUser( dwValue, m_bstrDisplayName );
    m_bCreateUser = dwValue;
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::~CServerNode
//
//  Destructor : Make sure to clean up our member-list

CServerNode::~CServerNode()
{
    for(DOMAINLIST::iterator iter = m_lDomains.begin(); iter != m_lDomains.end(); iter++)
    {
        delete (*iter);
    }   
    m_lDomains.clear();
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::DeleteDomain
//
//  Helper function to delete a child domain from all of POP3

HRESULT CServerNode::DeleteDomain(CDomainNode* pDomainNode)
{
    if( !pDomainNode ) return E_INVALIDARG;
    if( !m_spConfig ) return E_FAIL;

    // Delete from POP3 Admin Interface
    CComPtr<IP3Domains> spDomains;
    HRESULT hr = m_spConfig->get_Domains( &spDomains );

    // Update the P3Admin Interface
    if( SUCCEEDED(hr) )
    {
        hr = spDomains->Remove( pDomainNode->m_bstrDisplayName );
    }    

    // Update our list
    if( SUCCEEDED(hr) )
    {
        m_lDomains.remove(pDomainNode);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::OnExpand
//
//  Helper function to refresh list of domains and insert them

HRESULT CServerNode::OnExpand(BOOL bExpand, HSCOPEITEM hScopeItem, IConsole* pConsole)
{
    if( !hScopeItem || !pConsole ) return E_INVALIDARG;
    if( !m_spConfig ) return E_FAIL;

    HRESULT hr = S_OK;
    CComQIPtr<IConsoleNameSpace> spConsoleNameSpace = pConsole;
    if( !spConsoleNameSpace ) return E_NOINTERFACE;
   
    // If we have any children, delete them all from the namespace
    HSCOPEITEM hChild = NULL;
    MMC_COOKIE cookie = 0;
    hr = spConsoleNameSpace->GetChildItem(m_scopeDataItem.ID, &hChild, &cookie);
    if( SUCCEEDED(hr) && hChild )
    {                
        hr = spConsoleNameSpace->DeleteItem(m_scopeDataItem.ID, FALSE);
    }

    if( SUCCEEDED(hr) )
    {
        // then delete all of our member-list of domains
        for(DOMAINLIST::iterator iter = m_lDomains.begin(); iter != m_lDomains.end(); iter++)
        {
            delete (*iter);
        }    
        m_lDomains.clear();
    }

    if( FAILED(hr) || !bExpand )  
    {
        // Error, or we are Contracting
        return S_OK;
    }

    // Expanding

    // Fill in our list of domains
    CComPtr<IP3Domains>     spDomains;
    CComPtr<IEnumVARIANT>   spDomainEnum;
    
    // Get the Domains
	hr = m_spConfig->get_Domains( &spDomains );

    // Get an Enumerator for the Domains
	if( SUCCEEDED(hr) )
	{		
		hr = spDomains->get__NewEnum( &spDomainEnum );
    }

    // Loop through the domains, and add each new domain
	if( SUCCEEDED(hr) )
	{
		CComVariant var;				
        ULONG       lResult = 0;

		VariantInit( &var );

		while ( spDomainEnum->Next(1, &var, &lResult) == S_OK )
        {
            if ( lResult == 1 )
            {
                CComQIPtr<IP3Domain> spDomain;
                spDomain = V_DISPATCH(&var);

				CDomainNode* spDomainNode = new CDomainNode(spDomain, this);
                if( spDomainNode )
                {
				    m_lDomains.push_back(spDomainNode);
                }
            }

            VariantClear(&var);
        }
	}

    if( SUCCEEDED(hr) )
    {
        for(DOMAINLIST::iterator iter = m_lDomains.begin(); iter != m_lDomains.end(); iter++)
        {
            CDomainNode* pDomain = *iter; 

            pDomain->m_scopeDataItem.mask       |= SDI_PARENT;
            pDomain->m_scopeDataItem.relativeID  = m_scopeDataItem.ID;
            
            hr = spConsoleNameSpace->InsertItem( &(pDomain->m_scopeDataItem) );
            if( FAILED(hr) ) return hr;
        }
    }

    if( SUCCEEDED(hr) )
    {
        CComQIPtr<IConsole2> spCons2 = pConsole;
        if( spCons2 ) 
        {
            // Output the number of servers we added
            tstring strMessage = StrLoadString(IDS_SERVER_STATUSBAR);
            OLECHAR pszStatus[1024] = {0};
            _sntprintf( pszStatus, 1023, strMessage.c_str(), m_lDomains.size() );
            spCons2->SetStatusText( pszStatus );
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////
//
//  SnapInItemImpl
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//  CServerNode::GetScopePaneInfo
//
//  Callback used to get Scope-Pane display information by MMC

HRESULT CServerNode::GetScopePaneInfo(SCOPEDATAITEM *pScopeDataItem)
{
    if( !pScopeDataItem ) return E_INVALIDARG;

    if( pScopeDataItem->mask & SDI_STR )
        pScopeDataItem->displayname = m_bstrDisplayName;
    if( pScopeDataItem->mask & SDI_IMAGE )
        pScopeDataItem->nImage = m_scopeDataItem.nImage;
    if( pScopeDataItem->mask & SDI_OPENIMAGE )
        pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
    if( pScopeDataItem->mask & SDI_PARAM )
        pScopeDataItem->lParam = m_scopeDataItem.lParam;
    if( pScopeDataItem->mask & SDI_STATE )
        pScopeDataItem->nState = m_scopeDataItem.nState;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::GetResultPaneInfo
//
//  Callback used to get Result Pane display information by MMC

HRESULT CServerNode::GetResultPaneInfo(RESULTDATAITEM *pResultDataItem)
{
    if( !pResultDataItem ) return E_INVALIDARG;

    if( pResultDataItem->bScopeItem )
    {
        if( pResultDataItem->mask & RDI_STR )        
            pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
        if( pResultDataItem->mask & RDI_IMAGE )
            pResultDataItem->nImage = m_scopeDataItem.nImage;
        if( pResultDataItem->mask & RDI_PARAM )
            pResultDataItem->lParam = m_scopeDataItem.lParam;
        
        return S_OK;
    }

    if( pResultDataItem->mask & RDI_STR )
        pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
    if( pResultDataItem->mask & RDI_IMAGE )
        pResultDataItem->nImage = m_resultDataItem.nImage;
    if( pResultDataItem->mask & RDI_PARAM )
        pResultDataItem->lParam = m_resultDataItem.lParam;
    if( pResultDataItem->mask & RDI_INDEX )
        pResultDataItem->nIndex = m_resultDataItem.nIndex;
    
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::GetResultPaneColInfo
//
//  Helper function used as part of the GetResultPaneInfo.  This function
//  will supply the text for the different columns.

LPOLESTR CServerNode::GetResultPaneColInfo(int nCol)
{
    if( !m_spConfig ) return L"";

    switch( nCol )
    {
        case 0:     // Name
        {    
		    return m_bstrDisplayName;
        }

        case 1:     // Authentication Type
        {            
            CComPtr<IAuthMethods> spMethods;
            CComPtr<IAuthMethod>  spAuth;
            CComVariant           var;

            HRESULT hr = m_spConfig->get_Authentication( &spMethods );

            if( SUCCEEDED(hr) )
            {
                hr = spMethods->get_CurrentAuthMethod( &var );
            }

            if( SUCCEEDED(hr) )
            {
                hr = spMethods->get_Item( var, &spAuth );
            }

            if( SUCCEEDED(hr) )
            {
                hr = spAuth->get_Name( &m_bstrAuthentication );
            }

            if( FAILED(hr) )
            {
#if DBG
                m_bstrAuthentication = _T("Unknown");
#else
                m_bstrAuthentication = _T("");
#endif
            }            

            return m_bstrAuthentication;
        }

        case 2:     // Root Mail Directory
        {
            HRESULT hr = m_spConfig->get_MailRoot( &m_bstrMailRoot );
            
            if( FAILED(hr) )
            {
#if DBG
                m_bstrMailRoot = _T("Unknown");
#else
                m_bstrMailRoot = _T("");
#endif
            }            
            
            return m_bstrMailRoot;
        }

        case 3:     // Port
        {
            long lPort = 0;
            CComPtr<IP3Service> spService;
            HRESULT hr = m_spConfig->get_Service( &spService );

            if( SUCCEEDED(hr) )
            {
                hr = spService->get_Port( &lPort );

                if( FAILED(hr) )
                {
                    lPort = 0;
                }
            }

            // 1K buffer: Not likely we'll exceed that many digits
            TCHAR szNum[1024] = {0};
            _sntprintf( szNum, 1023, _T("%d"), lPort );

            m_bstrPort = szNum;
            return m_bstrPort;
        }

        case 4:     // Logging Level
        {
            long lLevel = 0;
            HRESULT hr = m_spConfig->get_LoggingLevel( &lLevel );            

            switch( lLevel )
            {
            case 0:
                {
                    m_bstrLogLevel = StrLoadString(IDS_SERVERPROP_LOG_0).c_str();
                    break;
                }
            case 1:
                {
                    m_bstrLogLevel = StrLoadString(IDS_SERVERPROP_LOG_1).c_str();
                    break;
                }
            case 2:
                {
                    m_bstrLogLevel = StrLoadString(IDS_SERVERPROP_LOG_2).c_str();
                    break;
                }
            case 3:
                {
                    m_bstrLogLevel = StrLoadString(IDS_SERVERPROP_LOG_3).c_str();
                    break;
                }
            default:
                {
                    m_bstrLogLevel = StrLoadString(IDS_SERVERPROP_LOG_0).c_str();
                    break;
                }
            }
            
            return m_bstrLogLevel;
        }

        case 5:     // Service Status
        {
            CComPtr<IP3Service> spService = NULL;
            long lServiceStatus = 0;

            HRESULT hr = m_spConfig->get_Service( &spService );
            if( SUCCEEDED(hr) )
            {            
                hr = spService->get_POP3ServiceStatus( &lServiceStatus );
            }
            
            switch( lServiceStatus )
            {
            case SERVICE_STOPPED:
                {
                    m_bstrServiceStatus = StrLoadString(IDS_STATE_STOPPED).c_str();
                    break;
                }
            case SERVICE_RUNNING:
                {
                    m_bstrServiceStatus = StrLoadString(IDS_STATE_RUNNING).c_str();
                    break;
                }

            case SERVICE_PAUSED:
                {
                    m_bstrServiceStatus = StrLoadString(IDS_STATE_PAUSED).c_str();
                    break;
                }

            default:
                {
                    m_bstrServiceStatus = StrLoadString(IDS_STATE_PENDING).c_str();
                    break;
                }
            }

            return m_bstrServiceStatus;
        }

        default:
        {
#if DBG
            return L"No Information";
#else
            return L"";
#endif
        }        
    }    
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::GetResultViewType
//
//  Sets the Result Pane to be:
//      0 Domains     : Message View     
//      Non-0 Domains : List View

HRESULT CServerNode::GetResultViewType( LPOLESTR* ppViewType, long* pViewOptions )
{
    // Get the Count of Domains
    CComPtr<IP3Domains> spDomains = NULL;    
    long                lDomains  = 0;
    
    // Get the Domains
	HRESULT hr = m_spConfig->get_Domains( &spDomains );

    if( SUCCEEDED(hr) )
    {
        spDomains->get_Count( &lDomains );
    }

    if( lDomains == 0 )
    {
        // Message View
        return StringFromCLSID(CLSID_MessageView, ppViewType);
    }

    return S_FALSE; // Default List View
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::Notify
//
//  Core callback functionality of this Node.  MMC will use this function
//  for all MMC provided functionality, such as Expanding, Renaming, and
//  Context Help

HRESULT CServerNode::Notify( MMC_NOTIFY_TYPE    event,
                             LPARAM             arg,
                             LPARAM             param,
                             IComponentData*    pComponentData,
                             IComponent*        pComponent,
                             DATA_OBJECT_TYPES  type)
{    
    HRESULT hr = S_FALSE;

    _ASSERTE(pComponentData != NULL || pComponent != NULL);

    CComPtr<IConsole> spConsole = NULL;
    if( pComponentData )
    {
        spConsole = ((CPOP3ServerSnapData*)pComponentData)->m_spConsole;        
    }
    else if( pComponent )
    {
        spConsole = ((CPOP3ServerSnapComponent*)pComponent)->m_spConsole;        
    }

    if( !spConsole ) return E_INVALIDARG;

    switch( event )
    {
    case MMCN_SHOW:
        {   
            tstring                 strHeader;
            CComQIPtr<IHeaderCtrl2> spHeaderCtrl = spConsole;
            CComQIPtr<IResultData>  spResultData = spConsole;
            
            if( !spHeaderCtrl || !spResultData ) return E_NOINTERFACE;

            hr = spResultData->DeleteAllRsltItems();

            if( arg )
            {
                if( m_lDomains.empty() )
                {
                    // configure the ocx message in the result pane
                    IMessageView* pIMessageView = NULL;
                    LPUNKNOWN     pIUnk         = NULL;

                    hr = spConsole->QueryResultView(&pIUnk);

                    if( SUCCEEDED(hr) )
                    {
                        hr = pIUnk->QueryInterface(_uuidof(IMessageView), reinterpret_cast<void**>(&pIMessageView));
                    }

                    if( SUCCEEDED(hr) )
                    {
                        hr = pIMessageView->SetIcon(Icon_Information);
                    }
                    
                    if( SUCCEEDED(hr) )
                    {
                        tstring strTitle = StrLoadString( IDS_SNAPINNAME );
                        hr = pIMessageView->SetTitleText( strTitle.c_str() );
                    }
                    
                    if( SUCCEEDED(hr) )
                    {
                        tstring strMessage = StrLoadString( IDS_ERROR_NODOMAIN );
                        hr = pIMessageView->SetBodyText( strMessage.c_str() );
                    }

                    if( pIMessageView )
                    {
                        pIMessageView->Release();
                        pIMessageView = NULL;
                    }

                    if( pIUnk )
                    {
                        pIUnk->Release();
                        pIUnk = NULL;
                    }

                    return hr;
                }
                else
                {
                    if( SUCCEEDED(hr) )
                    {
                        strHeader = StrLoadString(IDS_HEADER_DOMAIN_NAME);            
                        hr = spHeaderCtrl->InsertColumn(0, strHeader.c_str(), LVCFMT_LEFT, 100);
                    }

                    if( SUCCEEDED(hr) )
                    {
                        strHeader = StrLoadString(IDS_HEADER_DOMAIN_NUMBOX);            
                        hr = spHeaderCtrl->InsertColumn(1, strHeader.c_str(), LVCFMT_LEFT, 100);
                    }

                    if( SUCCEEDED(hr) )
                    {
                        strHeader = StrLoadString(IDS_HEADER_DOMAIN_SIZE);            
                        hr = spHeaderCtrl->InsertColumn(2, strHeader.c_str(), LVCFMT_LEFT, 100);
                    }

                    if( SUCCEEDED(hr) )
                    {
                        strHeader = StrLoadString(IDS_HEADER_DOMAIN_NUMMES);            
                        hr = spHeaderCtrl->InsertColumn(3, strHeader.c_str(), LVCFMT_LEFT, 100);
                    }

                    if( SUCCEEDED(hr) )
                    {
                        strHeader = StrLoadString(IDS_HEADER_DOMAIN_LOCKED);            
                        hr = spHeaderCtrl->InsertColumn(4, strHeader.c_str(), LVCFMT_LEFT, 100);
                    }

                    if( SUCCEEDED(hr) )
                    {
                        CComQIPtr<IConsole2> spCons2 = spConsole;
                        if( spCons2 ) 
                        {
                            // Output the number of servers we added
                            tstring strMessage = StrLoadString(IDS_SERVER_STATUSBAR);
                            OLECHAR pszStatus[1024] = {0};
                            _sntprintf( pszStatus, 1023, strMessage.c_str(), m_lDomains.size() );
                            spCons2->SetStatusText( pszStatus );
                        }
                    }
                }
            }

            break;
        }
    case MMCN_EXPAND:
        {                
            hr = OnExpand(arg, m_scopeDataItem.ID, spConsole);
            break;
        }
    case MMCN_ADD_IMAGES:
        {
            IImageList* pImageList = (IImageList*)arg;
            if( !pImageList ) return E_INVALIDARG;

            hr = LoadImages(pImageList);            
            break;
        }

    case MMCN_REFRESH:
        {            
            hr = OnExpand(TRUE, m_scopeDataItem.ID, spConsole);

            if( SUCCEEDED(hr) )
            {
                CComQIPtr<IConsole2> spCons2 = spConsole;
                if( spCons2 ) 
                {
                    // Output the number of servers we added
                    tstring strMessage = StrLoadString(IDS_SERVER_STATUSBAR);
                    OLECHAR pszStatus[1024] = {0};
                    _sntprintf( pszStatus, 1023, strMessage.c_str(), m_lDomains.size() );
                    spCons2->SetStatusText( pszStatus );
                }
            }
            break;
        }

    case MMCN_SELECT:
        {
            // if selecting node
            if( HIWORD(arg) )
            {
                hr = S_OK;

                // get the verb interface and enable rename
                CComPtr<IConsoleVerb> spConsVerb;
                if( spConsole->QueryConsoleVerb(&spConsVerb) == S_OK )
                {
                    // Enable the Properties Menu                                        
                    hr = spConsVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE); 
                    if( FAILED(hr) ) return hr;
                    hr = spConsVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
                    if( FAILED(hr) ) return hr;

                    // Enable the Refresh Menu
                    hr = spConsVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE); 
                    if( FAILED(hr) ) return hr;
                    hr = spConsVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
                    if( FAILED(hr) ) return hr;
                }
            }

            break;
        }
    
    case MMCN_VIEW_CHANGE:
        {
            if( (param == NAV_ADD) || 
                (param == NAV_DELETE) )
            {
                CComQIPtr<IConsole2> spCons2 = spConsole;
                if( spCons2 ) 
                {                    
                    hr = spCons2->SelectScopeItem( m_scopeDataItem.ID );
                }
            }            
            break;
        }

    case MMCN_CONTEXTHELP:
        {
            hr                                = S_OK;
            TCHAR    szWindowsDir[MAX_PATH+1] = {0};
            tstring  strHelpFile              = _T("");
            tstring  strHelpFileName          = StrLoadString(IDS_HELPFILE);
            tstring  strHelpTopicName         = StrLoadString(IDS_HELPTOPIC);

            if( strHelpFileName.empty() || strHelpTopicName.empty() )
            {
                return E_FAIL;
            }
            
            // Build path to d:\windows\help
            UINT nSize = GetSystemWindowsDirectory( szWindowsDir, MAX_PATH );
            if( nSize == 0 || nSize > MAX_PATH )
            {
                return E_FAIL;
            }            
        
            strHelpFile = szWindowsDir;       // D:\windows
            strHelpFile += _T("\\Help\\");    // \help
            strHelpFile += strHelpFileName;   // \filename.chm
            strHelpFile += _T("::/");         // ::/
            strHelpFile += strHelpTopicName;  // index.htm            
        
            // Show the Help topic
            CComQIPtr<IDisplayHelp> spHelp = spConsole;
            if( !spHelp ) return E_NOINTERFACE;

            hr = spHelp->ShowTopic( (LPTSTR)strHelpFile.c_str() );
        
            break;
        }

    }// switch

    return hr;
}

/////////////////////////////////////////////////////////////////////////
//
//  ContextMenuImpl
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//  CServerNode::AddMenuItems
//
//  Adds our context menus into the appropriate MMC provided menu 
//  locations.

HRESULT CServerNode::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long* pInsertionAllowed, DATA_OBJECT_TYPES type )
{    
    if( !piCallback || !pInsertionAllowed ) return E_INVALIDARG;
    if( !m_spConfig ) return E_FAIL;

    HRESULT hr      = S_OK;            
    tstring strMenu = _T("");
    tstring strDesc = _T("");    
    
    CComQIPtr<IContextMenuCallback2> spContext2 = piCallback;
    if( !spContext2 ) return E_NOINTERFACE;

    CONTEXTMENUITEM2 singleMenuItem;
    ZeroMemory(&singleMenuItem, sizeof(CONTEXTMENUITEM2));
    
    singleMenuItem.fFlags = MF_ENABLED;        

    // Add the Disconnect Menu to the "Top" part of the MMC Context Menu
    if( *pInsertionAllowed & CCM_INSERTIONALLOWED_TOP )
    {                
        strMenu = StrLoadString(IDS_MENU_SERVER_DISCON);
        strDesc = StrLoadString(IDS_MENU_SERVER_DISCON_DESC);
        
        singleMenuItem.lInsertionPointID            = CCM_INSERTIONPOINTID_PRIMARY_TOP;        
        singleMenuItem.strName                      = (LPWSTR)strMenu.c_str();
        singleMenuItem.strStatusBarText             = (LPWSTR)strDesc.c_str();
        singleMenuItem.strLanguageIndependentName   = L"SERVER_DISCONNECT";
        singleMenuItem.lCommandID                   = IDM_SERVER_TOP_DISCONNECT;

        if( !strMenu.empty() )
        {
            hr = spContext2->AddItem( &singleMenuItem );
            if( FAILED(hr) ) return hr;
        }
    }

    // Add the Domain Menu to the "New" part of the MMC Context Menu
    if( (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
    {                        
        strMenu = StrLoadString(IDS_MENU_SERVER_NEWDOM);
        strDesc = StrLoadString(IDS_MENU_SERVER_NEWDOM_DESC);
        
        singleMenuItem.lInsertionPointID            = CCM_INSERTIONPOINTID_PRIMARY_NEW;
        singleMenuItem.strName                      = (LPWSTR)strMenu.c_str();
        singleMenuItem.strStatusBarText             = (LPWSTR)strDesc.c_str();
        singleMenuItem.strLanguageIndependentName   = L"NEW_DOMAIN";
        singleMenuItem.lCommandID                   = IDM_SERVER_NEW_DOMAIN;

        if( !strMenu.empty() )
        {
            hr = spContext2->AddItem( &singleMenuItem );
            if( FAILED(hr) ) return hr;
        }
    }

    // Add the Service Operation Menus to the "Task" part of the MMC Context Menu
    if( *pInsertionAllowed & CCM_INSERTIONALLOWED_TASK )
    {
        CComPtr<IP3Service> spService;

        hr = m_spConfig->get_Service( &spService );
        if( FAILED(hr) ) return hr;
            
        long lServiceStatus = 0;
        hr = spService->get_POP3ServiceStatus( &lServiceStatus );
        if( FAILED(hr) ) return hr;

        singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
        
        if( lServiceStatus == SERVICE_STOPPED )
        {
            strMenu = StrLoadString(IDS_MENU_SERVER_START);
            strDesc = StrLoadString(IDS_MENU_SERVER_START_DESC);

            singleMenuItem.strName                      = (LPWSTR)strMenu.c_str();
            singleMenuItem.strStatusBarText             = (LPWSTR)strDesc.c_str();
            singleMenuItem.strLanguageIndependentName   = L"SERVER_START";
            singleMenuItem.lCommandID                   = IDM_SERVER_TASK_START;

            if( !strMenu.empty() )
            {
                hr = spContext2->AddItem( &singleMenuItem );
                if( FAILED(hr) ) return hr;
            }
        }

        if( lServiceStatus == SERVICE_PAUSED )
        {            
            strMenu = StrLoadString(IDS_MENU_SERVER_RESUME);
            strDesc = StrLoadString(IDS_MENU_SERVER_RESUME_DESC);

            singleMenuItem.strName                      = (LPWSTR)strMenu.c_str();
            singleMenuItem.strStatusBarText             = (LPWSTR)strDesc.c_str();
            singleMenuItem.strLanguageIndependentName   = L"SERVER_RESUME";
            singleMenuItem.lCommandID                   = IDM_SERVER_TASK_RESUME;

            if( !strMenu.empty() )
            {
                hr = spContext2->AddItem( &singleMenuItem );
                if( FAILED(hr) ) return hr;
            }
        }

        if( lServiceStatus == SERVICE_RUNNING )
        {
            strMenu = StrLoadString(IDS_MENU_SERVER_PAUSE);
            strDesc = StrLoadString(IDS_MENU_SERVER_PAUSE_DESC);

            singleMenuItem.strName                      = (LPWSTR)strMenu.c_str();
            singleMenuItem.strStatusBarText             = (LPWSTR)strDesc.c_str();
            singleMenuItem.strLanguageIndependentName   = L"SERVER_PAUSE";
            singleMenuItem.lCommandID                   = IDM_SERVER_TASK_PAUSE;

            if( !strMenu.empty() )
            {
                hr = spContext2->AddItem( &singleMenuItem );
                if( FAILED(hr) ) return hr;
            }
        }

        if( (lServiceStatus == SERVICE_RUNNING) ||
            (lServiceStatus == SERVICE_PAUSED) )
        {        
            strMenu = StrLoadString(IDS_MENU_SERVER_STOP);
            strDesc = StrLoadString(IDS_MENU_SERVER_STOP_DESC);

            singleMenuItem.strName                      = (LPWSTR)strMenu.c_str();
            singleMenuItem.strStatusBarText             = (LPWSTR)strDesc.c_str();
            singleMenuItem.strLanguageIndependentName   = L"SERVER_STOP";
            singleMenuItem.lCommandID                   = IDM_SERVER_TASK_STOP;

            if( !strMenu.empty() )
            {
                hr = spContext2->AddItem( &singleMenuItem );
                if( FAILED(hr) ) return hr;
            }
        }        

        if( (lServiceStatus == SERVICE_RUNNING) ||
            (lServiceStatus == SERVICE_PAUSED) )
        {            
            strMenu = StrLoadString(IDS_MENU_SERVER_RESTART);
            strDesc = StrLoadString(IDS_MENU_SERVER_RESTART_DESC);

            singleMenuItem.strName                      = (LPWSTR)strMenu.c_str();
            singleMenuItem.strStatusBarText             = (LPWSTR)strDesc.c_str();
            singleMenuItem.strLanguageIndependentName   = L"SERVER_RESTART";
            singleMenuItem.lCommandID                   = IDM_SERVER_TASK_RESTART;

            if( !strMenu.empty() )
            {
                hr = spContext2->AddItem( &singleMenuItem );
                if( FAILED(hr) ) return hr;
            }
        }        
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::OnNewDomain
//
//  Display a NewDomain dialog, and add the new domain

HRESULT CServerNode::OnNewDomain( bool& bHandled, CSnapInObjectRootBase* pObj )
{        
    if( !pObj ) return E_INVALIDARG;
    if( !m_spConfig ) return E_FAIL;

    bHandled = true;
    HRESULT hr = S_OK;
    
    // Load a dialog that asks for a Domain Name
    CNewDomainDlg dlg;

    if( dlg.DoModal() == IDOK )
    {
        HWND              hWnd      = NULL;            
        CComPtr<IConsole> spConsole = NULL;

        // Get a window handle
        hr = GetConsole( pObj, &spConsole );
        if( FAILED(hr) || !spConsole ) return E_NOINTERFACE;
        spConsole->GetMainWindow(&hWnd);

        // Access our POP3 Domain list
        CComPtr<IP3Domains> spDomains;
	    hr = m_spConfig->get_Domains( &spDomains );

        // Add our domain to the POP3 Admin domainlist
        if( SUCCEEDED(hr) )
        {            
            CComBSTR bstrName = dlg.m_strName.c_str();
            hr = spDomains->Add( bstrName );            
        }  

        // Check for weird pre-existance condition
        if( hr == ERROR_FILE_EXISTS )
        {
            tstring strMessage = StrLoadString( IDS_WARNING_DOMAINEXISTS );
            tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
            MessageBox( hWnd, strMessage.c_str(), strTitle.c_str(), MB_OK | MB_ICONWARNING );
        }

        if( SUCCEEDED(hr) )
        {
            CComVariant        var;
            CComPtr<IP3Domain> spDomain = NULL;
            CDomainNode*    pDomainNode = NULL;
            
            // Get a grasp of the Domain interface to pass to the node            
            VariantInit(&var);
            var = dlg.m_strName.c_str();
            hr  = spDomains->get_Item( var, &spDomain );            

            if( SUCCEEDED(hr) )
            {
                // Add the new Domain to our list of domains
                pDomainNode = new CDomainNode( spDomain, this );
                if( !pDomainNode ) hr = E_OUTOFMEMORY;
            }

            if( SUCCEEDED(hr) )
            {
                pDomainNode->m_scopeDataItem.mask       |= SDI_PARENT;
                pDomainNode->m_scopeDataItem.relativeID  = m_scopeDataItem.ID;

			    m_lDomains.push_back( pDomainNode );

                // Add the new domain into the namespace
                // Insert it into the result tree            
                CComQIPtr<IConsoleNameSpace2> spNameSpace = spConsole;
                if( !spNameSpace ) return E_NOINTERFACE;

                hr = spNameSpace->InsertItem( &(pDomainNode->m_scopeDataItem) );
            }            

            if( SUCCEEDED(hr) )
            {
                // Get our Data Object
                CComPtr<IDataObject> spDataObject = NULL;
                GetDataObject(&spDataObject, CCT_SCOPE);
                if( !spDataObject ) return E_FAIL;

                // Call the Update, but don't update return result
                spConsole->UpdateAllViews( spDataObject, 0, (LONG_PTR)NAV_ADD );
            }
        }        
        
        if( FAILED(hr) )
        {            
            // Failed to add the Domain            
            tstring strMessage = StrLoadString(IDS_ERROR_CREATEDOMAIN);
            tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
            DisplayError( hWnd, strMessage.c_str(), strTitle.c_str(), hr );            
        }
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::OnDisconnect
//
//  Disconnect is essentially deleting ourselves from the list of servers

HRESULT CServerNode::OnDisconnect( bool& bHandled, CSnapInObjectRootBase* pObj )
{
    if( !pObj ) return E_INVALIDARG;
    if( !m_pParent ) return E_FAIL;

    bHandled = true;    
    HRESULT hr = S_OK;
    


    // Get the Window Handle
    HWND              hWnd      = NULL;       
    CComPtr<IConsole> spConsole = NULL;
    hr = GetConsole( pObj, &spConsole );
    if( FAILED(hr) || !spConsole ) return E_NOINTERFACE;
    spConsole->GetMainWindow(&hWnd);

    // Load the message box
    tstring strDeleteWarning = StrLoadString( IDS_SERVER_CONFIRMDISCONNECT );
    tstring strTitle         = StrLoadString( IDS_SNAPINNAME );
    tstring strPropPageOpen  = StrLoadString( IDS_WARNING_PROP_PAGE_OPEN );
    if(1!=m_lRefCount)
    {
        MessageBox(hWnd, strPropPageOpen.c_str(),strTitle.c_str(),MB_OK);
        return hr; //Not error case
    }

    if( MessageBox(hWnd, strDeleteWarning.c_str(), strTitle.c_str(), MB_YESNO | MB_ICONWARNING ) == IDYES )
    {
        // Remove ourselves from the tree        
        CComQIPtr<IConsoleNameSpace2> spNameSpace = spConsole;
        if( !spNameSpace ) return E_NOINTERFACE;

        hr = spNameSpace->DeleteItem( m_scopeDataItem.ID, TRUE );

        // The parent needs to do the deletion
        if( SUCCEEDED(hr) )
        {
            hr = m_pParent->DeleteServer(this);                       
        }

        if( SUCCEEDED(hr) )
        {
            delete this;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::OnServerService
//
//  Function to handle the Start/Stop/Pause/Restart of the POP3 Service 
//  on this computer

HRESULT CServerNode::OnServerService( UINT nID, bool& bHandled, CSnapInObjectRootBase* pObj )
{
    if( !m_spConfig ) return E_FAIL;

    bHandled = true;
    
    HCURSOR hOldCursor  = NULL;
    HCURSOR hWaitCursor = ::LoadCursor(NULL, IDC_WAIT);
    if (hWaitCursor) 
    {        
        hOldCursor = ::SetCursor(hWaitCursor);
    }

    // Get the Window Handle
    HWND              hWnd      = NULL;       
    CComPtr<IConsole> spConsole = NULL;
    tstring strTitle            = StrLoadString( IDS_SNAPINNAME );
    tstring strMessage          = _T("");
    
    HRESULT hr = GetConsole( pObj, &spConsole );
    if( FAILED(hr) || !spConsole ) return E_NOINTERFACE;
    
    spConsole->GetMainWindow(&hWnd);    

    // Get the POP3 Service
    CComPtr<IP3Service> spService = NULL;    
    hr = m_spConfig->get_Service( &spService );     

    // Do the appropriate service operation
    switch( nID )
    {
    case IDM_SERVER_TASK_START:
        {    
            if( SUCCEEDED(hr) )
            {
                hr = spService->StartPOP3Service();
            }

            // Used for both Start failure, and Service retreival failure
            if( FAILED(hr) )
            {
                strMessage = StrLoadString( IDS_ERROR_STARTSERVICE );
                DisplayError( hWnd, strMessage.c_str(), strTitle.c_str(), hr );
            }
            break;
        }

    case IDM_SERVER_TASK_RESUME:
        {    
            if( SUCCEEDED(hr) )
            {
                hr = spService->ResumePOP3Service();
            }

            // Used for both Start failure, and Service retreival failure
            if( FAILED(hr) )
            {
                strMessage = StrLoadString( IDS_ERROR_RESUMESERVICE );
                DisplayError( hWnd, strMessage.c_str(), strTitle.c_str(), hr );
            }
            break;
        }

    case IDM_SERVER_TASK_STOP:
        {
            if( SUCCEEDED(hr) )
            {
                hr = spService->StopPOP3Service();
            }
            
            // Used for both Start failure, and Service retreival failure
            if( FAILED(hr) )
            {
                strMessage = StrLoadString( IDS_ERROR_STOPSERVICE );
                DisplayError( hWnd, strMessage.c_str(), strTitle.c_str(), hr );
            }
            break;
        }
    
    case IDM_SERVER_TASK_PAUSE:
        {  
            if( SUCCEEDED(hr) )
            {
                hr = spService->PausePOP3Service();
            }

            if( FAILED(hr) )
            {
                strMessage = StrLoadString( IDS_ERROR_PAUSESERVICE );
                DisplayError( hWnd, strMessage.c_str(), strTitle.c_str(), hr );
            }            
            break;
        }

    case IDM_SERVER_TASK_RESTART:
        {
            if( SUCCEEDED(hr) )
            {
                hr = spService->StopPOP3Service();
            }

            if( SUCCEEDED(hr) )
            {
                hr = spService->StartPOP3Service();
            }

            // Used for both Start failure, and Service retreival failure
            if( FAILED(hr) )
            {
                strMessage = StrLoadString( IDS_ERROR_RESTARTSERVICE );
                DisplayError( hWnd, strMessage.c_str(), strTitle.c_str(), hr );
            }
            break;
        }
    }

    ::SetCursor(hOldCursor);

    if( SUCCEEDED(hr) )
    {        
        CComQIPtr<IConsoleNameSpace2> spNameSpace = spConsole;
        if( spNameSpace ) 
        {
            spNameSpace->SetItem( &m_scopeDataItem );
        }
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////
//
//  PropertyPageImpl
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//  CServerNode::CreatePropertyPages
//
//  Fills MMC's callback with our property pages

HRESULT CServerNode::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, IUnknown* pUnk, DATA_OBJECT_TYPES type)
{
    if( !lpProvider ) return E_INVALIDARG;
    if( !m_spConfig ) return E_FAIL;

    HRESULT hr = E_FAIL;    
        
    // Load our Server's General page
    HPROPSHEETPAGE      hpageGen = NULL;
    InterlockedIncrement(&m_lRefCount);
    CServerGeneralPage* pGenPage = new CServerGeneralPage(m_spConfig, handle, this);
    
    if( pGenPage != NULL )
    {
        hpageGen = pGenPage->Create();
    }


    // Add it to the list of pages
    if( hpageGen )
    {
        hr = lpProvider->AddPage(hpageGen);
    }

    // Destruct correctly if failure results
    if( FAILED(hr) )
    {
        InterlockedDecrement(&m_lRefCount);
        if( hpageGen )
        {
            DestroyPropertySheetPage(hpageGen);
        }
        else if (pGenPage)
        {
            delete pGenPage;
            pGenPage = NULL;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////
//
//  Helper Functions
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//  CServerNode::GetAuth
//
//  pbHashPW : Return Boolean for Hash Password Authentication
//  pbSAM    : Return Boolean for Local SAM Authentication

HRESULT CServerNode::GetAuth(BOOL* pbHashPW, BOOL* pbSAM)
{
    if( !m_spConfig ) return E_FAIL;

    CComPtr<IAuthMethods>   spMethods;
    CComPtr<IAuthMethod>    spAuth;
    CComVariant             var;
    CComBSTR                bstrID;
    long                    lCurrent  = 0L;    

    HRESULT hr = m_spConfig->get_Authentication( &spMethods );    

    if ( SUCCEEDED(hr) )
    {
        hr = spMethods->get_CurrentAuthMethod( &var );
    }

    if ( SUCCEEDED(hr) )
    {        
        hr = spMethods->get_Item( var, &spAuth );
    }

    if( SUCCEEDED(hr) )
    {        
        hr = spAuth->get_ID( &bstrID );        
    }

    if( SUCCEEDED(hr) && pbHashPW )
    {
        *pbHashPW = (_tcsicmp(bstrID, SZ_AUTH_ID_MD5_HASH) == 0);        
    }

    if( SUCCEEDED(hr) && pbSAM )
    {
        *pbSAM = (_tcsicmp(bstrID, SZ_AUTH_ID_LOCAL_SAM) == 0);        
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::GetConfirmAddUser
//
//  pbConfirm : Return Boolean for User Add Confirmation

HRESULT CServerNode::GetConfirmAddUser( BOOL *pbConfirm )
{
    if( !m_spConfig ) return E_POINTER;

    return m_spConfig->get_ConfirmAddUser( pbConfirm );    
}

/////////////////////////////////////////////////////////////////////////
//  CServerNode::SetConfirmAddUser
//
//  pbConfirm : New Boolean Value for User Add Confirmation

HRESULT CServerNode::SetConfirmAddUser( BOOL bConfirm )
{
    if( !m_spConfig ) return E_POINTER;

    return m_spConfig->put_ConfirmAddUser( bConfirm );    
}

void CServerNode::Release()
{
    InterlockedDecrement(&m_lRefCount);
    if(m_lRefCount<1)
        InterlockedIncrement(&m_lRefCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\rootnode.cpp ===
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// CRootNode
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

// Access to the snapin
#include "pop3.h"
#include "pop3snap.h"

// Access to Nodes that we use
#include "RootNode.h"
#include "ServerNode.h"

// Access to the dialog to connect a remote server
#include "ConnServerDlg.h"

// The first version did not exist...  it was saving some server properties 
// that needed to be defined elsewhere.  From now on, we will query the 
// version.
#define SNAPIN_VERSION (DWORD)100  

static const    GUID     CRootNodeGUID_NODETYPE      = 
{ 0x5c0afaad, 0xab69, 0x4a34, { 0xa9, 0xe, 0x92, 0xf1, 0x10, 0x56, 0xda, 0xce } };

const           GUID*    CRootNode::m_NODETYPE       = &CRootNodeGUID_NODETYPE;
const           OLECHAR* CRootNode::m_SZNODETYPE     = OLESTR("5C0AFAAD-AB69-4a34-A90E-92F11056DACE");
const           OLECHAR* CRootNode::m_SZDISPLAY_NAME = NULL;
const           CLSID*   CRootNode::m_SNAPIN_CLASSID = &CLSID_POP3ServerSnap;

/////////////////////////////////////////////////////////////////////////
//
//  Class implementation
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//  CRootNode::CRootNode
//
//  Constructor : Base Node for POP3
CRootNode::CRootNode()
{
    // Initialize the Scope Pane information
    memset( &m_scopeDataItem, 0, sizeof(m_scopeDataItem) );
    m_scopeDataItem.mask        = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
    m_scopeDataItem.displayname = L"";
    m_scopeDataItem.nImage      = 0;         
    m_scopeDataItem.nOpenImage  = 0;     
    m_scopeDataItem.lParam      = (LPARAM) this;
    
    // Initialize the Result Pane Information
    memset( &m_resultDataItem, 0, sizeof(m_resultDataItem) );
    m_resultDataItem.mask   = RDI_STR | RDI_IMAGE | RDI_PARAM;
    m_resultDataItem.str    = L"";
    m_resultDataItem.nImage = 0;    
    m_resultDataItem.lParam = (LPARAM) this;
    
    // Initialize the Snapin Name
    tstring strTemp   = StrLoadString( IDS_SNAPINNAME );
    m_bstrDisplayName = strTemp.c_str();    

    // Add our Local Server always for now    
    CServerNode* spServerNode = new CServerNode(CComBSTR(_T("")), this, TRUE); 
    if( spServerNode )
    {
        m_lServers.push_back(spServerNode);
    }
}

CRootNode::~CRootNode()
{
    for(SERVERLIST::iterator iter = m_lServers.begin(); iter != m_lServers.end(); iter++)
    {                                        
        delete (*iter);        
    }
    m_lServers.clear();
}

HRESULT CRootNode::DeleteServer(CServerNode* pServerNode)
{
    if( !pServerNode ) return E_INVALIDARG;

    // Update our list
    m_lServers.remove(pServerNode);      

    return S_OK;
}

HRESULT CRootNode::GetScopePaneInfo(SCOPEDATAITEM *pScopeDataItem)
{
    if( !pScopeDataItem ) return E_INVALIDARG;

    if( pScopeDataItem->mask & SDI_STR )
        pScopeDataItem->displayname = m_bstrDisplayName;
    if( pScopeDataItem->mask & SDI_IMAGE )
        pScopeDataItem->nImage = 0;
    if( pScopeDataItem->mask & SDI_OPENIMAGE )
        pScopeDataItem->nOpenImage = 0;
    if( pScopeDataItem->mask & SDI_PARAM )
        pScopeDataItem->lParam = m_scopeDataItem.lParam;
    if( pScopeDataItem->mask & SDI_STATE )
        pScopeDataItem->nState = m_scopeDataItem.nState;

    return S_OK;
}

HRESULT CRootNode::GetResultPaneInfo(RESULTDATAITEM *pResultDataItem)
{
    if( !pResultDataItem ) return E_INVALIDARG;

    if( pResultDataItem->bScopeItem )
    {
        if( pResultDataItem->mask & RDI_STR )
            pResultDataItem->str = m_bstrDisplayName;
        if( pResultDataItem->mask & RDI_IMAGE )
            pResultDataItem->nImage = 0;
        if( pResultDataItem->mask & RDI_PARAM )
            pResultDataItem->lParam = m_scopeDataItem.lParam;

        return S_OK;
    }

    if( pResultDataItem->mask & RDI_STR )
        pResultDataItem->str = m_bstrDisplayName;
    if( pResultDataItem->mask & RDI_IMAGE )
        pResultDataItem->nImage = 0;
    if( pResultDataItem->mask & RDI_PARAM )
        pResultDataItem->lParam = m_resultDataItem.lParam;
    if( pResultDataItem->mask & RDI_INDEX )
        pResultDataItem->nIndex = m_resultDataItem.nIndex;

    return S_OK;
}

HRESULT CRootNode::GetResultViewType( LPOLESTR* ppViewType, long* pViewOptions )
{
    if( !ppViewType ) return E_POINTER;

    if( !IsAdmin() )
    {
        // show standard MMC OCX with message in the result pane
        return StringFromCLSID(CLSID_MessageView, ppViewType);
    }    

    return S_FALSE;
}

HRESULT CRootNode::Notify( MMC_NOTIFY_TYPE event,
                           LPARAM arg,
                           LPARAM param,
                           IComponentData* pComponentData,
                           IComponent* pComponent,
                           DATA_OBJECT_TYPES type)
{   
    if( (event != MMCN_SHOW) && !IsAdmin() ) return E_ACCESSDENIED;

    HRESULT hr = S_FALSE;

    _ASSERTE(pComponentData != NULL || pComponent != NULL);

    CComPtr<IConsole> spConsole = NULL;
    if( pComponentData )
    {
        spConsole = ((CPOP3ServerSnapData*)pComponentData)->m_spConsole;
    }
    else if( pComponent )
    {
        spConsole = ((CPOP3ServerSnapComponent*)pComponent)->m_spConsole;        
    }

    if( !spConsole ) return E_INVALIDARG;

    switch( event )
    {
    case MMCN_SHOW:
        {            
            hr = S_OK;            
            
            if( !IsAdmin() )
            {
                // configure the ocx message in the result pane
                IMessageView* pIMessageView = NULL;
                LPUNKNOWN     pIUnk         = NULL;

                hr = spConsole->QueryResultView(&pIUnk);

                if( SUCCEEDED(hr) )
                {
                    hr = pIUnk->QueryInterface(_uuidof(IMessageView), reinterpret_cast<void**>(&pIMessageView));
                }

                if( SUCCEEDED(hr) )
                {
                    hr = pIMessageView->SetIcon(Icon_Information);
                }
                
                if( SUCCEEDED(hr) )
                {
                    tstring strTitle = StrLoadString( IDS_SNAPINNAME );
                    hr = pIMessageView->SetTitleText( strTitle.c_str() );
                }
                
                if( SUCCEEDED(hr) )
                {
                    tstring strMessage = StrLoadString( IDS_ERROR_ADMINONLY );
                    hr = pIMessageView->SetBodyText( strMessage.c_str() );
                }

                if( pIMessageView )
                {
                    pIMessageView->Release();
                    pIMessageView = NULL;
                }

                if( pIUnk )
                {
                    pIUnk->Release();
                    pIUnk = NULL;
                }

                return hr;
            }

            if(arg)
            {                
                tstring                 strHeader;
                CComQIPtr<IHeaderCtrl2> spHeaderCtrl = spConsole;
                CComQIPtr<IResultData>  spResultData = spConsole;

                if( !spResultData || !spHeaderCtrl ) return E_NOINTERFACE;

                hr = spResultData->DeleteAllRsltItems();

                if( SUCCEEDED(hr) )
                {
                    strHeader = StrLoadString(IDS_HEADER_SERVER_NAME);
                    hr = spHeaderCtrl->InsertColumn(0, strHeader.c_str(), LVCFMT_LEFT, 100);
                }
            
                if( SUCCEEDED(hr) )
                {
                    strHeader = StrLoadString(IDS_HEADER_SERVER_AUTH);
                    hr = spHeaderCtrl->InsertColumn(1, strHeader.c_str(), LVCFMT_LEFT, 100);
                }
            
                if( SUCCEEDED(hr) )
                {
                    strHeader = StrLoadString(IDS_HEADER_SERVER_ROOT);
                    hr = spHeaderCtrl->InsertColumn(2, strHeader.c_str(), LVCFMT_LEFT, 100);
                }
            
                if( SUCCEEDED(hr) )
                {
                    strHeader = StrLoadString(IDS_HEADER_SERVER_PORT);
                    hr = spHeaderCtrl->InsertColumn(3, strHeader.c_str(), LVCFMT_LEFT, 100);
                }
            
                if( SUCCEEDED(hr) )
                {
                    strHeader = StrLoadString(IDS_HEADER_SERVER_LOG);
                    hr = spHeaderCtrl->InsertColumn(4, strHeader.c_str(), LVCFMT_LEFT, 100);
                }

                if( SUCCEEDED(hr) )
                {
                    strHeader = StrLoadString(IDS_HEADER_SERVER_STATUS);
                    hr = spHeaderCtrl->InsertColumn(5, strHeader.c_str(), LVCFMT_LEFT, 100);
                }

                if( SUCCEEDED(hr) )
                {
                    CComQIPtr<IConsole2> spCons2 = spConsole;
                    if( spCons2 ) 
                    {
                        // Output the number of servers we added
                        tstring strMessage = StrLoadString(IDS_ROOT_STATUSBAR);
                        OLECHAR pszStatus[1024] = {0};
                        _sntprintf( pszStatus, 1023, strMessage.c_str(), m_lServers.size() );
                        spCons2->SetStatusText( pszStatus );
                    }
                }
            }

            break;
        }    

    case MMCN_EXPAND:
        {   
            hr = S_OK;            
            
            // The Parameter is our inserted ID
            m_scopeDataItem.ID = (HSCOPEITEM)param;

            CComQIPtr<IConsoleNameSpace> spConsoleNameSpace = spConsole;
            if( !spConsoleNameSpace ) return E_NOINTERFACE;
           
            // If we have any children, delete them all from the namespace
            HSCOPEITEM hChild = NULL;
            MMC_COOKIE cookie = 0;
            hr = spConsoleNameSpace->GetChildItem( m_scopeDataItem.ID, &hChild, &cookie );
            if( SUCCEEDED(hr) && hChild )
            {                
                hr = spConsoleNameSpace->DeleteItem(m_scopeDataItem.ID, FALSE);
            }            

            if( FAILED(hr) || !arg )
            {
                // Error, or we are Contracting
                return hr;
            }            
            
            for(SERVERLIST::iterator iter = m_lServers.begin(); iter != m_lServers.end(); iter++)
            {                                        
                CServerNode* pServer = *iter;
                
                pServer->m_scopeDataItem.mask       |= SDI_PARENT;
                pServer->m_scopeDataItem.relativeID  = param;

                hr = spConsoleNameSpace->InsertItem( &(pServer->m_scopeDataItem) );
                if( FAILED(hr) ) return hr;
            }
            break;
        }

    case MMCN_ADD_IMAGES:
        {
            IImageList* pImageList = (IImageList*)arg;
            if( !pImageList ) return E_INVALIDARG;

            hr = LoadImages(pImageList);
            break;
        }

    case MMCN_SELECT:
        {
            // if selecting node
            if( HIWORD(arg) )
            {
                hr = S_OK;

                // get the verb interface and enable rename
                CComPtr<IConsoleVerb> spConsVerb;
                if( spConsole->QueryConsoleVerb(&spConsVerb) == S_OK )
                {                    
                    // Enable the Refresh Menu
                    hr = spConsVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE); 
                    if( FAILED(hr) ) return hr;

                    hr = spConsVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
                    if( FAILED(hr) ) return hr;
                }
            }            
            break;
        }

    case MMCN_RENAME:
        {
            // Allow mmc to rename node
            hr = S_OK;
            break;
        }

    case MMCN_CONTEXTHELP:
        {
            hr                                = S_OK;
            TCHAR    szWindowsDir[MAX_PATH+1] = {0};
            tstring  strHelpFile              = _T("");
            tstring  strHelpFileName          = StrLoadString(IDS_HELPFILE);
            tstring  strHelpTopicName         = StrLoadString(IDS_HELPTOPIC);

            if( strHelpFileName.empty() || strHelpTopicName.empty() )
            {
                return E_FAIL;
            }
            
            // Build path to d:\windows\help
            UINT nSize = GetSystemWindowsDirectory( szWindowsDir, MAX_PATH );
            if( nSize == 0 || nSize > MAX_PATH )
            {
                return E_FAIL;
            }            
        
            strHelpFile = szWindowsDir;       // D:\windows
            strHelpFile += _T("\\Help\\");    // \help
            strHelpFile += strHelpFileName;   // \filename.chm
            strHelpFile += _T("::/");         // ::/
            strHelpFile += strHelpTopicName;  // index.htm            
        
            // Show the Help topic
            CComQIPtr<IDisplayHelp> spHelp = spConsole;
            if( !spHelp ) return E_NOINTERFACE;

            hr = spHelp->ShowTopic( (LPTSTR)strHelpFile.c_str() );
        
            break;
        }

    }// switch

    return hr;
}

HRESULT CRootNode::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long* pInsertionAllowed, DATA_OBJECT_TYPES type )
{
    if( !piCallback || !pInsertionAllowed ) return E_INVALIDARG;    

    HRESULT hr      = S_OK;     
    tstring strMenu = _T("");
    tstring strDesc = _T("");
    
    // Connecting to a remote server happens on top
    if( (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) && IsAdmin() )
    {   
        CComQIPtr<IContextMenuCallback2> spContext2 = piCallback;
        if( !spContext2 ) return E_NOINTERFACE;
        
        CONTEXTMENUITEM2 singleMenuItem;
        ZeroMemory(&singleMenuItem, sizeof(CONTEXTMENUITEM2));        

        strMenu = StrLoadString(IDS_MENU_POP3_CONNECT);
        strDesc = StrLoadString(IDS_MENU_POP3_CONNECT_DESC);

        singleMenuItem.fFlags                       = MF_ENABLED;
        singleMenuItem.lInsertionPointID            = CCM_INSERTIONPOINTID_PRIMARY_TOP;        
        singleMenuItem.strName                      = (LPWSTR)strMenu.c_str();
        singleMenuItem.strStatusBarText             = (LPWSTR)strDesc.c_str();
        singleMenuItem.strLanguageIndependentName   = L"POP3_CONNECT";
        singleMenuItem.lCommandID                   = IDM_POP3_TOP_CONNECT;
        
        if( !strMenu.empty() )
        {
            hr = spContext2->AddItem( &singleMenuItem );
        }
    }

    return hr;
}


HRESULT CRootNode::OnConnect( bool& bHandled, CSnapInObjectRootBase* pObj )
{
    if( !pObj ) return E_INVALIDARG;

    bHandled = true;

    HRESULT hr = S_OK;

    // Load a dialog that asks for a Server Name
    CConnectServerDlg dlg;

    if( dlg.DoModal() == IDOK )
    {                               
        HWND              hWnd      = NULL;
        CComPtr<IConsole> spConsole = NULL;
        
        hr = GetConsole(pObj, &spConsole);
        if( FAILED(hr) || !spConsole ) return E_NOINTERFACE;

        spConsole->GetMainWindow( &hWnd );

        // Check if the server is already connected.
        for(SERVERLIST::iterator iter = m_lServers.begin(); iter != m_lServers.end(); iter++)
        {   
            if( (_tcsicmp((*iter)->m_bstrDisplayName, dlg.m_strName.c_str()) == 0) ||
                (_tcsicmp(_T("localhost"), dlg.m_strName.c_str()) == 0) )
            {
                // Server already connected
                tstring strMessage = StrLoadString(IDS_ERROR_SERVERNAMEEXISTS);
                tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
                ::MessageBox( hWnd, strMessage.c_str(), strTitle.c_str(), MB_OK | MB_ICONWARNING );
                return E_FAIL;
            }
        }        

        // Add the new Domain to our list of domains
        CComBSTR bstrName = dlg.m_strName.c_str();
        CServerNode* spServerNode = new CServerNode( bstrName, this );
        if( spServerNode && SUCCEEDED(spServerNode->m_hrValidServer) )
        {
            spServerNode->m_scopeDataItem.relativeID = m_scopeDataItem.ID;
		    m_lServers.push_back(spServerNode);

            // Add the new domain into the namespace
            // Insert it into the result tree            
            CComQIPtr<IConsoleNameSpace2> spNameSpace = spConsole;
            if( !spNameSpace ) return E_NOINTERFACE;

            hr = spNameSpace->InsertItem(&(spServerNode->m_scopeDataItem));
        }
        else
        {
            delete spServerNode;

            if( spServerNode->m_hrValidServer != E_ACCESSDENIED )
            {
                // Invalid Server Name
                tstring strMessage = StrLoadString(IDS_ERROR_SERVERNAMEBAD);
                tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
                ::MessageBox( hWnd, strMessage.c_str(), strTitle.c_str(), MB_OK | MB_ICONWARNING );                
            }        
            else
            {
                // No Access to Server
                tstring strMessage = StrLoadString(IDS_ERROR_SERVERACCESS);
                tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
                ::MessageBox( hWnd, strMessage.c_str(), strTitle.c_str(), MB_OK | MB_ICONWARNING );            
            }
            
            return E_FAIL;
        }
    }
    return hr;
}

HRESULT CRootNode::Load(IStream *pStream)
{
    if( !pStream ) return E_INVALIDARG;

    // Name, Local Server, and State of User creation checkbox are what we currently save.
    tstring  strServerName  = _T("");
    BOOL     bLocalServer   = FALSE;    
    DWORD    dwVersion      = 0;

    // New functionality to read the version.
    *pStream >> dwVersion;

    *pStream >> strServerName;

    while( strServerName != _T("-1") )
    {
        // For now we will put one entry.
        *pStream >> bLocalServer;        
        
        if( !bLocalServer )
        {
            CServerNode* spServerNode = new CServerNode(CComBSTR(strServerName.c_str()), this);
            if( spServerNode )
            {
                m_lServers.push_back(spServerNode);
            }
        }        
        
        *pStream >> strServerName;
    }

    return S_OK;
}

HRESULT CRootNode::Save(IStream *pStream)
{
    if( !pStream ) return E_INVALIDARG;

    // Name, Local Server, and State of User creation checkbox are what we currently save.
    *pStream << SNAPIN_VERSION;

    tstring strName = _T("");
    for(SERVERLIST::iterator iter = m_lServers.begin(); iter != m_lServers.end(); iter++)
    {   
        strName = (*iter)->m_bstrDisplayName;
        *pStream << strName;
        *pStream << (BOOL)(iter == m_lServers.begin());        
    }

    strName = _T("-1");
    *pStream << strName;    

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Pop3.rc
//
/////////////////////////////////////////////////////////////////////////////
//
// Localizable Strings
//

#define IDS_POP3SERVERSNAP_DESC         100
#define IDS_POP3SERVERSNAP_VERSION      101
#define IDS_SNAPINNAME				    102

#define IDS_MENU_POP3_CONNECT           200
#define IDS_MENU_POP3_CONNECT_DESC      201

#define IDS_MENU_SERVER_NEWDOM          210
#define IDS_MENU_SERVER_NEWDOM_DESC     211
#define IDS_MENU_SERVER_DISCON          214
#define IDS_MENU_SERVER_DISCON_DESC     215
#define IDS_MENU_SERVER_START           216
#define IDS_MENU_SERVER_START_DESC      217
#define IDS_MENU_SERVER_STOP            218
#define IDS_MENU_SERVER_STOP_DESC       219
#define IDS_MENU_SERVER_PAUSE           220 
#define IDS_MENU_SERVER_PAUSE_DESC      221
#define IDS_MENU_SERVER_RESTART         222
#define IDS_MENU_SERVER_RESTART_DESC    223
#define IDS_MENU_SERVER_RESUME          224
#define IDS_MENU_SERVER_RESUME_DESC     225

#define IDS_MENU_DOMAIN_NEWUSER         230
#define IDS_MENU_DOMAIN_NEWUSER_DESC    231
#define IDS_MENU_DOMAIN_LOCK            232
#define IDS_MENU_DOMAIN_LOCK_DESC       233
#define IDS_MENU_DOMAIN_UNLOCK          234
#define IDS_MENU_DOMAIN_UNLOCK_DESC     235

#define IDS_MENU_USER_LOCK              240
#define IDS_MENU_USER_LOCK_DESC         241
#define IDS_MENU_USER_UNLOCK            242
#define IDS_MENU_USER_UNLOCK_DESC       243

#define IDS_HEADER_SERVER_NAME          300
#define IDS_HEADER_SERVER_AUTH          301
#define IDS_HEADER_SERVER_ROOT          302
#define IDS_HEADER_SERVER_PORT          303
#define IDS_HEADER_SERVER_LOG           304
#define IDS_HEADER_SERVER_STATUS        305

#define IDS_HEADER_DOMAIN_NAME          310
#define IDS_HEADER_DOMAIN_NUMBOX        311
#define IDS_HEADER_DOMAIN_SIZE          312
#define IDS_HEADER_DOMAIN_NUMMES        313
#define IDS_HEADER_DOMAIN_LOCKED        314

#define IDS_HEADER_USER_NAME            320
#define IDS_HEADER_USER_SIZE            321
#define IDS_HEADER_USER_NUMMES          322
#define IDS_HEADER_USER_LOCKED          323

#define IDS_STATE_LOCKED                340
#define IDS_STATE_UNLOCKED              341
#define IDS_STATE_RUNNING               342
#define IDS_STATE_STOPPED               343
#define IDS_STATE_PAUSED                344
#define IDS_STATE_PENDING               345

#define IDS_KILOBYTE_EXTENSION          350

#define IDS_ROOT_STATUSBAR              360
#define IDS_SERVER_STATUSBAR            361
#define IDS_DOMAIN_STATUSBAR            362

#define IDS_SERVERPROP_BROWSE_TITLE     400
#define IDS_SERVERPROP_LOG_0            410
#define IDS_SERVERPROP_LOG_1            411
#define IDS_SERVERPROP_LOG_2            412
#define IDS_SERVERPROP_LOG_3            413

#define IDS_DOMAIN_CONFIRMDELETE        500
#define IDS_SERVER_CONFIRMDISCONNECT    501

#define IDS_ERROR_CREATEMAIL            600
#define IDS_ERROR_CREATEDOMAIN          601
#define IDS_ERROR_DELETEUSER            602
#define IDS_ERROR_DELETEDOMAIN          603
#define IDS_ERROR_RETRIEVEAUTH          604
#define IDS_ERROR_SERVERNAMEEXISTS      605
#define IDS_ERROR_SETLOGGING            606
#define IDS_ERROR_SETPORT               607
#define IDS_ERROR_SETAUTH               608
#define IDS_ERROR_SETROOT               609
#define IDS_ERROR_SERVERNAMEBAD         610
#define IDS_ERROR_UNSPECIFIED           611
#define IDS_ERROR_PORTRANGE             612
#define IDS_ERROR_STARTSERVICE          613
#define IDS_ERROR_STOPSERVICE           614
#define IDS_ERROR_RESTARTSERVICE        615
#define IDS_ERROR_PAUSESERVICE          616
#define IDS_ERROR_RESUMESERVICE         617
#define IDS_ERROR_PASSNOMATCH           618
#define IDS_ERROR_ADMINONLY             619
#define IDS_ERROR_NODOMAIN              620
#define IDS_ERROR_SERVERACCESS          621
#define IDS_ERROR_SMTP_STARTSERVICE     622
#define IDS_ERROR_SMTP_STOPSERVICE      623

#define IDS_WARNING_MAILROOT            700
#define IDS_WARNING_DOMAINEXISTS        701
#define IDS_WARNING_DOMAINMISSING       702
#define IDS_WARNING_POP3SVC_RESTART     703
#define IDS_WARNING_POP_SMTP_RESTART    704
#define IDS_WARNING_PROP_PAGE_OPEN      705 

/////////////////////////////////////////////////////////////////////////////
//
// Menus
//

#define IDM_POP3_MENU                   1000
#define IDM_SERVER_MENU                 1001
#define IDM_DOMAIN_MENU                 1002
#define IDM_USER_MENU                   1003

#define IDM_POP3_TOP_CONNECT            1500

#define IDM_SERVER_TOP_DISCONNECT       1600
#define IDM_SERVER_NEW_DOMAIN           1610
#define IDM_SERVER_TASK_START           1620
#define IDM_SERVER_TASK_STOP            1621
#define IDM_SERVER_TASK_PAUSE           1622
#define IDM_SERVER_TASK_RESTART         1623
#define IDM_SERVER_TASK_RESUME          1624

#define IDM_DOMAIN_TOP_LOCK             1700
#define IDM_DOMAIN_TOP_UNLOCK           1701
#define IDM_DOMAIN_NEW_USER             1710

#define IDM_USER_TOP_LOCK               1800
#define IDM_USER_TOP_UNLOCK             1801

/////////////////////////////////////////////////////////////////////////////
//
// Dialogs
//

#define IDD_SERVER_GENERAL_PAGE         2000
#define IDC_AUTHENTICATION              2001
#define IDC_PORT                        2002
#define IDC_LOGGING                     2003
#define IDC_DIRECTORY                   2004
#define IDC_BROWSE                      2005
#define IDC_SERVER_CREATEUSER           2006
#define IDC_AUTHENTICATION_STATIC       2007
#define IDC_PORT_STATIC                 2008
#define IDC_LOGGING_STATIC              2009
#define IDC_DIRECTORY_STATIC            2010
#define IDC_NAME                        2011
#define IDC_SERVER_SPA_REQ              2012
#define IDC_optDoNotShow                2013
#define IDC_lblConfirm                  2014

#define IDD_NEW_DOMAIN                  2100
#define IDC_DOMAIN_NAME                 2101

#define IDD_NEW_USER                    2200
#define IDC_USER_NAME                   2201
#define IDC_PASSWORD                    2202
#define IDC_CONFIRM                     2203
#define IDC_USER_CREATEUSER             2204
#define IDC_CONFIRM_STATIC              2205
#define IDC_PASSWORD_STATIC             2206
#define IDD_NEW_USER_CONFIRM            2207
#define IDC_ICON_INFO                   2208


#define IDD_DELETE_MAILBOX              2300
#define IDC_DELETE_ACCOUNT              2301

#define IDD_CONNECT_SERVER              2400
#define IDC_SERVERNAME                  2401
#define IDC_BROWSE_SERVERS              2402


/////////////////////////////////////////////////////////////////////////////
//
// NON-Localized information
//

#define IDS_POP3SERVERSNAP_PROVIDER     8001
#define IDS_HELPFILE                    8002
#define IDS_CONTEXTHELPFILE             8003
#define IDS_HELPTOPIC                   8004

/////////////////////////////////////////////////////////////////////////////
//
// Images
//
#define IDI_Icon					    9000
#define IDB_Small					    9001
#define IDB_Large					    9002
#define IDB_RootSmall                   9003
#define IDB_RootLarge                   9004
#define IDI_ServerIcon                  9005

/////////////////////////////////////////////////////////////////////////////
//
// Registry
//

#define IDR_POP3SERVERSNAP              10002

/////////////////////////////////////////////////////////////////////////////
//
// Help Topics
//

#define IDH_POP3_server_prop_authMech					100011
#define IDH_POP3_server_prop_servPort					100012
#define IDH_POP3_server_prop_logLvl						100013
#define IDH_POP3_server_prop_mailRoot					100014
#define IDH_POP3_server_prop_createUser					100015
#define IDH_POP3_server_prop_spaRequired                100016

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2209
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         100
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\servernode.h ===
#ifndef ServerNode_h
#define ServerNode_h

#include "resource.h"
#include <atlsnap.h>
#include <objidl.h>

#include "pop3.h"
#include <P3Admin.h>

class CRootNode;
class CDomainNode;

typedef std::list<CDomainNode*> DOMAINLIST;

// This change is necessary in order to get a range of Menu ID entries that works
#define SNAPINCOMMAND_RANGE_ENTRY_POP3(id1, id2, func) \
		if (id1 <= nID && nID <= id2) \
		{ \
			hr = func(nID, bHandled, pObj); \
			if (bHandled) \
				return hr; \
		}

//////////////////////////////////////////////////////////////////////////////////
//
// CServerNode
//
//////////////////////////////////////////////////////////////////////////////////
class CServerNode : public CSnapInItemImpl<CServerNode>
{
public:
    static const GUID* m_NODETYPE;
    static const OLECHAR* m_SZNODETYPE;
    static const OLECHAR* m_SZDISPLAY_NAME;
    static const CLSID* m_SNAPIN_CLASSID;


    CComPtr<IControlbar> m_spControlBar;

    BEGIN_SNAPINCOMMAND_MAP(CServerNode, FALSE)        
        SNAPINCOMMAND_ENTRY           ( IDM_SERVER_TOP_DISCONNECT, OnDisconnect )
        SNAPINCOMMAND_ENTRY           ( IDM_SERVER_NEW_DOMAIN, OnNewDomain )
        SNAPINCOMMAND_RANGE_ENTRY_POP3( IDM_SERVER_TASK_START, IDM_SERVER_TASK_RESUME, OnServerService )
    END_SNAPINCOMMAND_MAP()


    // Standard Class Constructor/Destructor
    CServerNode(BSTR strServerName, CRootNode* pParent, BOOL bLocalServer = FALSE);
    virtual ~CServerNode();    

    // Standard ATL Snap-In Impl Over-rides
    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if ( type == CCT_SCOPE || type == CCT_RESULT )
        {
            return S_OK;
        }
        return S_FALSE;
    }    
    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem);
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem);
    LPOLESTR GetResultPaneColInfo(int nCol);
    STDMETHOD(GetResultViewType)( LPOLESTR* ppViewType, long* pViewOptions );
    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param, IComponentData* pComponentData, IComponent* pComponent, DATA_OBJECT_TYPES type);

    // MenuItem Implementations
    STDMETHOD(AddMenuItems)     (LPCONTEXTMENUCALLBACK piCallback, long* pInsertionAllowed, DATA_OBJECT_TYPES type );
    STDMETHOD(OnNewDomain)      (bool& bHandled, CSnapInObjectRootBase* pObj );
    STDMETHOD(OnDisconnect)     (bool& bHandled, CSnapInObjectRootBase* pObj );
    STDMETHOD(OnServerService)  (UINT nID, bool& bHandled, CSnapInObjectRootBase* pObj );

    // PropertySheet Implementation
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, LONG_PTR handle, IUnknown* pUnk, DATA_OBJECT_TYPES type);    
    
public:
    
    // Public function for children to delete themselves
    HRESULT DeleteDomain(CDomainNode* pDomainNode);
    
    // Server Properties
    HRESULT m_hrValidServer;
    BOOL m_bCreateUser;
    CComPtr<IP3Config>  m_spConfig;    

    // Helper Function    
    HRESULT GetAuth(BOOL* pbHashPW = NULL, BOOL* pbSAM = NULL);
    HRESULT GetConfirmAddUser( BOOL *pbConfirm );
    HRESULT SetConfirmAddUser( BOOL bConfirm );
    void Release();

private:

    // Private function to help with refresh and expanding
    HRESULT OnExpand(BOOL bExpand, HSCOPEITEM hScopeItem, IConsole* pConsole);

    // Parent Information
    CRootNode*  m_pParent;

    // Server Information	
    DOMAINLIST  m_lDomains;    

    // Column text needs to be allocated by us, so we'll free them in the destructor
    CComBSTR    m_bstrAuthentication;
    CComBSTR    m_bstrMailRoot;
    CComBSTR    m_bstrPort;
    CComBSTR    m_bstrLogLevel;
    CComBSTR    m_bstrServiceStatus;

    //Ref Count 
    LONG        m_lRefCount;
};

#endif // ServerNode_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\serverprop.cpp ===
//////////////////////////////////////////////////////////////
//
//  NewDomainDlg.cpp
//
//  Implementation of the "Add Domain" dialog
//
//////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ServerProp.h"
#include "ServerNode.h"

#include <dsrole.h>
#include <shlobj.h>
#include <htmlhelp.h>

#include "Pop3Auth.h"
#include <AuthID.h>
#include <Pop3RegKeys.h>

LRESULT CServerGeneralPage::OnInitDialog( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{    
    if( !m_spServerConfig || !m_pParent ) return 0;

    HRESULT hr = S_OK;
        
    //IDC_NAME
    SetDlgItemText( IDC_NAME, m_pParent->m_bstrDisplayName );


    //IDC_PORT
    // Read in the current port, and set it as the default
    long                lPort       = 0L;
    TCHAR               szPort[128] = {0};
    CComPtr<IP3Service> spService   = NULL;
    
    hr = m_spServerConfig->get_Service( &spService );
    if( FAILED(hr) || !spService ) return 0;

    hr = spService->get_Port( &lPort );
    if( FAILED(hr) ) return 0;

    _sntprintf( szPort, 127, _T("%d"), lPort );    
    SetDlgItemText( IDC_PORT, szPort );


    //IDC_DIRECTORY
    // Read in the current mail root directory, and set it as the default
    CComBSTR bstrRoot = _T("");   
    
    hr = m_spServerConfig->get_MailRoot(&bstrRoot);
    if( FAILED(hr) ) return 0;

    SetDlgItemText(IDC_DIRECTORY, bstrRoot);
    
    
    //IDC_SERVER_CREATEUSER
    // Read in the current state of Creating Users for accounts
    CheckDlgButton(IDC_SERVER_CREATEUSER, (m_pParent->m_bCreateUser  ? BST_CHECKED : BST_UNCHECKED) );


    //IDC_SERVER_SPA_REQ
    // Read in the current state of SPA Requirement for the server
    // Do our SPA Required Property
    DWORD dwValue = 0;
    RegQuerySPARequired( dwValue, m_pParent->m_bstrDisplayName );    
    CheckDlgButton(IDC_SERVER_SPA_REQ, (dwValue  ? BST_CHECKED : BST_UNCHECKED) );


    //IDC_AUTHENTICATION    
    // Loop through all Authentication methods, and add them to our combo box    
    CComBSTR                bstrName;
    CComVariant             var;
    CComPtr<IAuthMethods>   spMethods = NULL;
    CComPtr<IAuthMethod>    spAuth    = NULL;
    long                    lCount    = 0L;    
    long                    lCurrent  = 0L;
    int                     nIndex    = 0;

    // Variables used to make sure the drop box of the combo is the right width
    HWND    hwndCombo       = GetDlgItem(IDC_AUTHENTICATION);    
    if( !hwndCombo ) return 0;

    // Get the width information
    int     iScrollBarWidth = GetSystemMetrics(SM_CXHSCROLL);
    long    lOriginalMax    = ::SendMessage(hwndCombo, CB_GETDROPPEDWIDTH, 0, 0) - iScrollBarWidth;
    long    lMax            = lOriginalMax;    
    
    // Get the DC to the Combo box
    HDC     hDC             = ::GetWindowDC(hwndCombo);
    if( !hDC ) return 0;

    // Set the mapping mode
    SIZE    size;
    int     iMode           = ::SetMapMode( hDC, MM_TEXT );
    
    // Select the font
    HGDIOBJ hObj            = ::SelectObject( hDC, reinterpret_cast<HGDIOBJ>(::SendMessage((hwndCombo), WM_GETFONT, 0, 0 )));
    if( !hObj )
    {
        ::ReleaseDC(hwndCombo, hDC);
        return 0;
    }

    hr = m_spServerConfig->get_Authentication( &spMethods );
    if ( SUCCEEDED(hr) )
    {
        hr = spMethods->get_Count( &lCount );
    }

    if ( SUCCEEDED(hr) )
    {
        hr = spMethods->get_CurrentAuthMethod( &var );
    }
    
    if ( SUCCEEDED(hr) )
    {
        lCurrent = V_I4( &var );
    }
    else if ( HRESULT_FROM_WIN32(ERROR_DS_AUTH_METHOD_NOT_SUPPORTED) == hr )
    {
        lCurrent = -1;
        var = lCurrent; // Set variant type
        hr = S_OK;
    }

    for ( V_I4(&var) = 1, nIndex = 0; SUCCEEDED(hr) && ( V_I4(&var) <= lCount ); V_I4(&var)++, nIndex++ )
    {
        hr = spMethods->get_Item( var, &spAuth );
        if ( SUCCEEDED(hr) )
        {
            hr = spAuth->get_Name( &bstrName );
        }
        if ( SUCCEEDED(hr) )
        {
            if(::GetTextExtentPoint32(hDC, bstrName, bstrName.Length(), &size))
            {
                lMax = (size.cx > lMax ? size.cx : lMax);                                
            }
            ::SendMessage( hwndCombo, CB_INSERTSTRING, nIndex, (LPARAM)(LPCTSTR)bstrName );            
            ::SendMessage( hwndCombo, CB_SETITEMDATA,  nIndex, (LPARAM)V_I4(&var) );
            if( V_I4(&var) == lCurrent )
            {
                ::SendMessage(hwndCombo, CB_SETCURSEL, nIndex, 0);
            }            
        }
    }    

    // Finish making sure the combo drop box is the right width
    ::SetMapMode( hDC, iMode );
    ::SelectObject( hDC, hObj );

    const int ciExtraRoomEndOfLine = 10;
    if(lMax > lOriginalMax)
    {
        lMax += iScrollBarWidth + ciExtraRoomEndOfLine;
        ::SendMessage( hwndCombo, CB_SETDROPPEDWIDTH, lMax, 0 );
    }

    ::ReleaseDC(hwndCombo, hDC);
    ::DeleteObject(hObj);

    // If there are any domains, do not allow change of authentication    
    long lDomains = 0L;
    CComPtr<IP3Domains> spDomains = NULL;

    hr = m_spServerConfig->get_Domains( &spDomains );

    if( SUCCEEDED(hr) )
    {
        hr = spDomains->get_Count( &lDomains );        
    }
    
    Prefix_EnableWindow( m_hWnd, IDC_AUTHENTICATION, ((lDomains == 0) && SUCCEEDED(hr)) );        

    // Check if the Auth is Hash Password and disable the checkbox.
    CComBSTR bstrID;
    if ( SUCCEEDED(hr) )
    {
        var.Clear();
        V_VT( &var ) = VT_I4;
        V_I4( &var ) = lCurrent;
        hr = spMethods->get_Item( var, &spAuth );
    }

    if( SUCCEEDED(hr) )
    {        
        hr = spAuth->get_ID( &bstrID );
    }

    if( SUCCEEDED(hr) )
    {
        BOOL bHashPW = (_tcsicmp(bstrID, SZ_AUTH_ID_MD5_HASH) == 0);                
        Prefix_EnableWindow( m_hWnd, IDC_SERVER_CREATEUSER, !bHashPW);        
        Prefix_EnableWindow( m_hWnd, IDC_SERVER_SPA_REQ,    !bHashPW);
    }
    
    //IDC_LOGGING
    // Some initialization of variables used for combo box sizing
    tstring strComboItem = _T("");
    hwndCombo       = GetDlgItem(IDC_LOGGING);
    if( !hwndCombo ) return 0;

    iScrollBarWidth = GetSystemMetrics(SM_CXHSCROLL);
    lOriginalMax    = ::SendMessage(hwndCombo, CB_GETDROPPEDWIDTH, 0, 0) - iScrollBarWidth;
    lMax            = lOriginalMax;    
    hDC             = ::GetWindowDC(hwndCombo);
    if( !hDC ) return 0;

    iMode           = ::SetMapMode( hDC, MM_TEXT );
    hObj            = ::SelectObject( hDC, reinterpret_cast<HGDIOBJ>(::SendMessage((hwndCombo), WM_GETFONT, 0, 0 )));    
    if( !hObj )
    {
        ::ReleaseDC( hwndCombo, hDC );
        return 0;
    }

    // Fill in the options for logging
    strComboItem = StrLoadString(IDS_SERVERPROP_LOG_0);
    if( ::GetTextExtentPoint32( hDC, strComboItem.c_str(), strComboItem.length(), &size ) )
    {
        lMax = (size.cx > lMax ? size.cx : lMax);                                
    }
    SendDlgItemMessage( IDC_LOGGING, CB_INSERTSTRING, 0, (LPARAM)(LPCTSTR)strComboItem.c_str() );

    strComboItem = StrLoadString(IDS_SERVERPROP_LOG_1);
    if( ::GetTextExtentPoint32( hDC, strComboItem.c_str(), strComboItem.length(), &size ) )
    {
        lMax = (size.cx > lMax ? size.cx : lMax);                                
    }
    SendDlgItemMessage( IDC_LOGGING, CB_INSERTSTRING, 1, (LPARAM)(LPCTSTR)strComboItem.c_str() );
    
    strComboItem = StrLoadString(IDS_SERVERPROP_LOG_2);
    if( ::GetTextExtentPoint32( hDC, strComboItem.c_str(), strComboItem.length(), &size ) )
    {
        lMax = (size.cx > lMax ? size.cx : lMax);                                
    }
    SendDlgItemMessage( IDC_LOGGING, CB_INSERTSTRING, 2, (LPARAM)(LPCTSTR)strComboItem.c_str() );
    
    strComboItem = StrLoadString(IDS_SERVERPROP_LOG_3);
    if( ::GetTextExtentPoint32( hDC, strComboItem.c_str(), strComboItem.length(), &size ) )
    {
        lMax = (size.cx > lMax ? size.cx : lMax);                                
    }
    SendDlgItemMessage( IDC_LOGGING, CB_INSERTSTRING, 3, (LPARAM)(LPCTSTR)strComboItem.c_str() );

    // Finish making sure the combo drop box is the right width
    ::SetMapMode( hDC, iMode );
    ::SelectObject( hDC, hObj );
    
    if(lMax > lOriginalMax)
    {
        lMax += iScrollBarWidth + ciExtraRoomEndOfLine;
        ::SendMessage( hwndCombo, CB_SETDROPPEDWIDTH, lMax, 0 );
    }

    ::ReleaseDC(hwndCombo, hDC);
    ::DeleteObject(hObj);

    // Then select the logging level
    long lLoggingLevel = 0L;
    hr = m_spServerConfig->get_LoggingLevel(&lLoggingLevel);    
    if( FAILED(hr) ) return 0;
    
    ::SendMessage(GetDlgItem(IDC_LOGGING), CB_SETCURSEL, lLoggingLevel, 0);

    // Limit the text length of these controls
    SendDlgItemMessage( IDC_PORT,      EM_LIMITTEXT, 5,        0 );
    SendDlgItemMessage( IDC_DIRECTORY, EM_LIMITTEXT, MAX_PATH, 0 );

    HWND hwndPort = GetDlgItem(IDC_PORT);

    if( hwndPort && ::IsWindow(hwndPort) )
    {
        m_wndPort.SubclassWindow( hwndPort );
    }

    //No service restart
    m_dwSvcRestart=0;

    return 0;
}

LRESULT CServerGeneralPage::OnChange( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled )
{    
    if( !m_spServerConfig ) return 0;

    SetModified(TRUE);    
    if( wID == IDC_PORT || wID == IDC_SERVER_SPA_REQ )
    {
        m_dwSvcRestart |= RESTART_POP3SVC;
    }
    else if( wID == IDC_LOGGING || wID == IDC_DIRECTORY )
    {
        m_dwSvcRestart |= RESTART_SMTP;
    }
    else if( wID == IDC_AUTHENTICATION )
    {
        m_dwSvcRestart |= RESTART_POP3SVC;
        long lIndex = SendDlgItemMessage(IDC_AUTHENTICATION, CB_GETCURSEL, 0, 0);
        long lAuth  = SendDlgItemMessage(IDC_AUTHENTICATION, CB_GETITEMDATA, lIndex, 0);

        HRESULT hr = S_OK;
        CComPtr<IAuthMethods>   spMethods;
        CComPtr<IAuthMethod>    spAuth;
        CComBSTR                bstrID;
        CComVariant             var;                

        hr = m_spServerConfig->get_Authentication( &spMethods );            

        if ( SUCCEEDED(hr) )
        {
            var.Clear();
            V_VT( &var ) = VT_I4;
            V_I4( &var ) = lAuth;            
            hr = spMethods->get_Item( var, &spAuth );
        }

        if( SUCCEEDED(hr) )
        {        
            hr = spAuth->get_ID( &bstrID );
        }

        if( SUCCEEDED(hr) )
        {        
            // Disable the checkbox if necessary
            BOOL bHashPW = (_tcsicmp(bstrID, SZ_AUTH_ID_MD5_HASH) == 0);        
            
            CheckDlgButton( IDC_SERVER_CREATEUSER, ( bHashPW ? BST_UNCHECKED : BST_CHECKED) );
            Prefix_EnableWindow( m_hWnd, IDC_SERVER_CREATEUSER, !bHashPW);        

            CheckDlgButton( IDC_SERVER_SPA_REQ, BST_UNCHECKED );
            Prefix_EnableWindow( m_hWnd, IDC_SERVER_SPA_REQ, !bHashPW);
        }        
    }

    

    return 0;
}

BOOL CServerGeneralPage::OnApply()
{
    if( !m_spServerConfig || !m_pParent ) return FALSE;

    // Validate settings
    HRESULT hr          = S_OK;        

    if( !ValidateControls() )
    {
        return FALSE;
    }
    
    // Set the Logging Level
    long    lLogLevel   = SendDlgItemMessage(IDC_LOGGING, CB_GETCURSEL, 0, 0);
    hr = m_spServerConfig->put_LoggingLevel( lLogLevel );

    if( FAILED(hr) )
    {
        // Error placing the Logging Level
        tstring strMessage = StrLoadString( IDS_ERROR_SETLOGGING );
        tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
        DisplayError( m_hWnd, strMessage.c_str(), strTitle.c_str(), hr );        
        ::SetFocus( GetDlgItem(IDC_LOGGING) );
        return FALSE;
    }
    
    // Set the Port Number    
    long  lPort = 0L;    
    CComPtr<IP3Service> spService = NULL;
    hr = m_spServerConfig->get_Service( &spService );

    if( SUCCEEDED(hr) && spService )
    {
        lPort = (long)GetDlgItemInt( IDC_PORT, NULL, FALSE );        
        hr = spService->put_Port( lPort );
    }    

    if( FAILED(hr) )
    {
        // Error Setting the port
        tstring strMessage = StrLoadString( IDS_ERROR_SETPORT );
        tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
        DisplayError( m_hWnd, strMessage.c_str(), strTitle.c_str(), hr );        
        ::SetFocus( GetDlgItem(IDC_PORT) );        
        return FALSE;
    }

    // Set the Authentication type
    if( ::IsWindowEnabled(GetDlgItem(IDC_AUTHENTICATION)) )
    {
        long lIndex = SendDlgItemMessage( IDC_AUTHENTICATION, CB_GETCURSEL, 0, 0 );
        long lAuth  = SendDlgItemMessage( IDC_AUTHENTICATION, CB_GETITEMDATA, lIndex, 0 );
        CComVariant var;
        CComPtr<IAuthMethods> spMethods = NULL;

        hr = m_spServerConfig->get_Authentication( &spMethods );

        if( SUCCEEDED(hr) )
        {
            var.Clear();
            V_VT( &var ) = VT_I4;
            V_I4( &var ) = lAuth;
            hr = spMethods->put_CurrentAuthMethod( var );
        }        

        if( SUCCEEDED(hr) )
        {
            hr = spMethods->Save();
        }
    }

    if( FAILED(hr) )
    {
        // Error setting the Authentication type
        tstring strMessage = StrLoadString( IDS_ERROR_SETAUTH );
        tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
        DisplayError( m_hWnd, strMessage.c_str(), strTitle.c_str(), hr );                
        ::SetFocus( GetDlgItem(IDC_AUTHENTICATION) );
        return FALSE;
    }

    // Set the Mail Root    
    CComBSTR bstrOldRoot = _T("");   
    hr = m_spServerConfig->get_MailRoot( &bstrOldRoot );

    if( SUCCEEDED(hr) )
    {
        TCHAR szMailRoot[MAX_PATH+1];
        GetDlgItemText(IDC_DIRECTORY, szMailRoot, MAX_PATH+1);        
        
        // If there are any domains, display message
        long lDomains = 0L;
        CComPtr<IP3Domains> spDomains = NULL;

        HRESULT hrDomain = m_spServerConfig->get_Domains( &spDomains );

        if( SUCCEEDED(hrDomain) )
        {
            hrDomain = spDomains->get_Count( &lDomains );        
        }

        CComBSTR bstrNewRoot = szMailRoot;
        hr = m_spServerConfig->put_MailRoot( bstrNewRoot );
        if( SUCCEEDED(hr) )
        {
            // Issue a warning after they've switched mail roots            
            if( (FAILED(hrDomain) || (lDomains > 0)) && (_tcsicmp( OLE2T(bstrOldRoot), szMailRoot) != 0) )
            {
                tstring strMessage = StrLoadString(IDS_WARNING_MAILROOT);
                tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
                ::MessageBox( m_hWnd, strMessage.c_str(), strTitle.c_str(), MB_OK | MB_ICONWARNING );
            }
        }
        else
        {
            // Error setting the Mail Root
            tstring strMessage = StrLoadString(IDS_ERROR_SETROOT);
            tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
            DisplayError( m_hWnd, strMessage.c_str(), strTitle.c_str(), hr );
            ::SetFocus( GetDlgItem(IDC_DIRECTORY) );            
            return FALSE;
        }    
    }

    // Set the User Creation Flag
    m_pParent->m_bCreateUser  = (IsDlgButtonChecked(IDC_SERVER_CREATEUSER) == BST_CHECKED);        
    BOOL bSPARequired = (IsDlgButtonChecked(IDC_SERVER_SPA_REQ) == BST_CHECKED);

    // Do our User creation and SPA property            
    RegSetCreateUser ( m_pParent->m_bCreateUser,  m_pParent->m_bstrDisplayName );
    RegSetSPARequired( bSPARequired, m_pParent->m_bstrDisplayName );
    MMCPropertyChangeNotify(m_lNotifyHandle, (LPARAM)m_pParent);    
    
    UINT uID=0;  
    UINT uErrID=0;
    if( m_dwSvcRestart )
    {   
        long lP3Status=SERVICE_STOPPED;
        long lSMTPStatus=SERVICE_STOPPED;

        if( RESTART_POP3SVC == m_dwSvcRestart ) 
        { 
            hr = spService->get_POP3ServiceStatus(&lP3Status);
            if(FAILED(hr) || SERVICE_STOPPED != lP3Status )
            {
                uID = IDS_WARNING_POP3SVC_RESTART;
            }
        }
        else
        {
            hr = spService->get_POP3ServiceStatus(&lP3Status);
            if(SUCCEEDED(hr))
            {
                hr = spService->get_SMTPServiceStatus(&lSMTPStatus);
            }
            if (FAILED (hr) || 
                SERVICE_STOPPED != lP3Status || 
                SERVICE_STOPPED != lSMTPStatus )
            {
                uID = IDS_WARNING_POP_SMTP_RESTART;
            }
            

        }

        if(uID)
        {
            tstring strMessage = StrLoadString( uID );
            tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
            if(IDYES == 
               ::MessageBox( m_hWnd, strMessage.c_str(), strTitle.c_str(), MB_YESNO))
            {
                if(SERVICE_STOPPED != lP3Status)
                {
                    hr=spService->StopPOP3Service();
                    if(SUCCEEDED(hr))
                    {
                        hr=spService->StartPOP3Service();
                        if(FAILED(hr))
                        {
                            uErrID=IDS_ERROR_STARTSERVICE;
                        }                            
                    }
                    else
                    {
                        uErrID=IDS_ERROR_STOPSERVICE;
                    }
                }
                if(SUCCEEDED(hr))
                {
                    if(IDS_WARNING_POP_SMTP_RESTART == uID &&
                       SERVICE_STOPPED != lSMTPStatus )
                    {
                        hr=spService->StopSMTPService();
                        if(SUCCEEDED(hr))
                        {
                            hr=spService->StartSMTPService();
                            if(FAILED(hr))
                            {
                                uErrID=IDS_ERROR_SMTP_STARTSERVICE;
                            }
                                
                        }
                        else
                        {
                            uErrID=IDS_ERROR_SMTP_STOPSERVICE;
                        }
                    }
                }
                if(FAILED(hr))
                {
                    tstring strMessage = StrLoadString(uErrID );
                    tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
                    ::MessageBox( m_hWnd, strMessage.c_str(), strTitle.c_str(), MB_OK | MB_ICONWARNING );
                    m_dwSvcRestart =0;
                    return FALSE;
                }
            }
        }
    }

    m_dwSvcRestart =0;

    return TRUE;
}


LRESULT CServerGeneralPage::OnBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    TCHAR   szPath[MAX_PATH];    
    TCHAR   pBuffer[MAX_PATH];
    
    int     nImage      = 0;
    tstring strTitle    = StrLoadString(IDS_SERVERPROP_BROWSE_TITLE);
    LPITEMIDLIST pList  = NULL;
    CComPtr<IMalloc> spMalloc  = NULL;
    HRESULT hr = SHGetMalloc(&spMalloc);    

    if( SUCCEEDED(hr) )
    {
        BROWSEINFO BrowseInfo;
        BrowseInfo.hwndOwner        = m_hWnd;
        BrowseInfo.pidlRoot         = NULL;
        BrowseInfo.pszDisplayName   = szPath;
        BrowseInfo.lpszTitle        = strTitle.c_str();
        BrowseInfo.ulFlags          = BIF_RETURNONLYFSDIRS;
        BrowseInfo.lpfn             = NULL;
        BrowseInfo.lParam           = NULL;
        BrowseInfo.iImage           = nImage;

        pList = ::SHBrowseForFolder(&BrowseInfo);
    }

    if( pList )
    {
        if( ::SHGetPathFromIDList(pList, pBuffer) )
        {        
            SetDlgItemText( IDC_DIRECTORY, pBuffer );        
        }

        spMalloc->Free( pList );
        pList = NULL;
    }

    return 0;
}

LRESULT CServerGeneralPage::OnHelpMsg( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
{    
    TCHAR szWindowsDir[MAX_PATH+1] = {0};
    LPHELPINFO lpHelpInfo = (LPHELPINFO)lParam;

    UINT nSize = GetSystemWindowsDirectory( szWindowsDir, MAX_PATH );
    if( nSize == 0 || nSize > MAX_PATH )
    {
        return 0;
    }                

    tstring strPath = szWindowsDir;
    strPath += _T("\\Help\\");
    strPath += StrLoadString( IDS_CONTEXTHELPFILE );

    if( lpHelpInfo )
    {
        switch( lpHelpInfo->iCtrlId )
        {
        case IDC_PORT_STATIC:
        case IDC_PORT:
            {                                
                ::WinHelp( m_hWnd, strPath.c_str(), HELP_CONTEXTPOPUP, IDH_POP3_server_prop_servPort);
                break;
            }

        case IDC_DIRECTORY_STATIC:
        case IDC_DIRECTORY:
            {
                ::WinHelp( m_hWnd, strPath.c_str(), HELP_CONTEXTPOPUP, IDH_POP3_server_prop_mailRoot );                
                break;
            }

        case IDC_AUTHENTICATION_STATIC:
        case IDC_AUTHENTICATION:
            {
                ::WinHelp( m_hWnd, strPath.c_str(), HELP_CONTEXTPOPUP, IDH_POP3_server_prop_authMech );                
                break;
            }

        case IDC_LOGGING_STATIC:
        case IDC_LOGGING:
            {
                ::WinHelp( m_hWnd, strPath.c_str(), HELP_CONTEXTPOPUP, IDH_POP3_server_prop_logLvl );                
                break;
            }        

        case IDC_SERVER_CREATEUSER:
            {
                ::WinHelp( m_hWnd, strPath.c_str(), HELP_CONTEXTPOPUP, IDH_POP3_server_prop_createUser );                
                break;
            }

        case IDC_SERVER_SPA_REQ:
            {
                ::WinHelp( m_hWnd, strPath.c_str(), HELP_CONTEXTPOPUP, IDH_POP3_server_prop_spaRequired );                
                break;
            }

        default:
            {
                strPath = szWindowsDir;
                strPath += _T("\\Help\\");
                strPath += StrLoadString( IDS_HELPFILE );
                strPath += _T("::/");                
                strPath += StrLoadString( IDS_HELPTOPIC );

                HtmlHelp( m_hWnd, strPath.c_str(), HH_DISPLAY_TOPIC, NULL );
                break;
            }
        }        
    }
    else
    {
        strPath = szWindowsDir;
        strPath += _T("\\Help\\");
        strPath += StrLoadString( IDS_HELPFILE );
        strPath += _T("::/");
        strPath += StrLoadString( IDS_HELPTOPIC );

        HtmlHelp( m_hWnd, strPath.c_str(), HH_DISPLAY_TOPIC, NULL );
    }

    return 0;
}

BOOL CServerGeneralPage::ValidateControls()
{    
    BOOL bTrans;    

    // Validate the Port
    UINT nPort = GetDlgItemInt( IDC_PORT, &bTrans, FALSE );
    if( !bTrans || ((nPort <= 0) || (nPort > 65535)) )
    {
        // Error Setting the port
        tstring strMessage = StrLoadString( IDS_ERROR_PORTRANGE );
        tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
        ::MessageBox( m_hWnd, strMessage.c_str(), strTitle.c_str(), MB_OK | MB_ICONWARNING );
        ::SetFocus( GetDlgItem(IDC_PORT) );
        return FALSE;
    }    

    return TRUE;  
}



void CServerGeneralPage::OnFinalMessage(HWND hW)
{
    if(m_pParent)
    {
        m_pParent->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\stdafx.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0501 // 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>
#include <dlgs.h>
#include <atldlgs.h>
#include <atlctrls.h>

#include <string>
#include <vector>
#include <list>

// Define tstring
typedef std::basic_string<TCHAR> tstring;
#define TSTRING tstring

#include "resource.h"
#include <mmc.h>
#include <streamio.h>
#include <commctrl.h>

HRESULT LoadImages(IImageList* pImageList);
tstring StrLoadString(UINT uID);
void    StrGetEditText( HWND hWndParent, UINT uID, tstring& strRet );
void    DisplayError(HWND hWnd, LPCTSTR pszMessage, LPCTSTR pszTitle, HRESULT hrErr );
BOOL    Prefix_EnableWindow( HWND hDlg, UINT uCtrlID, BOOL bEnable );
BOOL    IsAdmin();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\stdafx_.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>

HRESULT LoadImages(IImageList* pImageList)
{    
    HRESULT hr = E_FAIL;

    HBITMAP hBitmap16 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_Small) );
    if (hBitmap16 != NULL)
    {
        HBITMAP hBitmap32 = LoadBitmap( _Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_Large) );
        if (hBitmap32 != NULL)
        {
            hr = pImageList->ImageListSetStrip( reinterpret_cast<LONG_PTR*>( hBitmap16 ), reinterpret_cast<LONG_PTR*>( hBitmap32 ), 0, RGB(255, 0, 255));
        }
    }

    return hr;
}

tstring StrLoadString(UINT uID)
{ 
    tstring   strRet = _T("");
    HINSTANCE hInst  = _Module.GetResourceInstance();    
    INT       iSize  = MAX_PATH;
    TCHAR*    psz    = new TCHAR[iSize];
    if( !psz ) return strRet;
    
    while( LoadString(hInst, uID, psz, iSize) == (iSize - 1) )
    {
        iSize += MAX_PATH;
        delete[] psz;
        psz = NULL;
        
        psz = new TCHAR[iSize];
        if( !psz ) return strRet;
    }

    strRet = psz;
    delete[] psz;

    return strRet;
}

void StrGetEditText( HWND hWndParent, UINT uID, tstring& strRet )
{
	if( !hWndParent ||
		!IsWindow(hWndParent) )
	{
		strRet = _T("");
        return;
	}

    INT iLen = SendDlgItemMessage( hWndParent, uID, WM_GETTEXTLENGTH, 0, 0 );
	TCHAR* pszText = new TCHAR[ iLen + 1 ];
    if( !pszText )
    {
        strRet = _T("");
        return;
    }

	GetDlgItemText( hWndParent, uID, pszText, iLen + 1 );

	strRet = pszText;

    SecureZeroMemory( pszText, sizeof(TCHAR)*(iLen + 1) );
	delete[] pszText;	
}

void DisplayError(HWND hWnd, LPCTSTR pszMessage, LPCTSTR pszTitle, HRESULT hrErr )
{
    LPVOID      lpMsgBuf = NULL;
    tstring     strMessage = pszMessage;    

    if ( ::FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                          FORMAT_MESSAGE_FROM_SYSTEM | 
                          FORMAT_MESSAGE_IGNORE_INSERTS, 
                          NULL, 
                          hrErr, 
                          MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                          (LPTSTR)&lpMsgBuf, 
                          0, 
                          NULL ))
    {        
        strMessage += (LPTSTR)lpMsgBuf;
        LocalFree( lpMsgBuf );
    }   
    else
    {        
        tstring strTemp = StrLoadString( IDS_ERROR_UNSPECIFIED );
        strMessage += strTemp;
    }
    
    // Output the Messagebox
    ::MessageBox( hWnd, strMessage.c_str(), pszTitle, MB_OK | MB_ICONWARNING );
}

BOOL Prefix_EnableWindow( HWND hDlg, UINT uCtrlID, BOOL bEnable )
{
	if ((NULL == hDlg) || !IsWindow( hDlg ))
		return FALSE;
		
	HWND h = 0;
	if (uCtrlID)
	{
		h = GetDlgItem( hDlg, uCtrlID );
		if( !h || !::IsWindow(h) )
			return FALSE;
	}
	else
		h = hDlg;
	
	return ::EnableWindow( h, bEnable );
}

BOOL IsAdmin()
{
    // Verify Permissions    
    PSID psid = NULL;
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    BOOL bRet = AllocateAndInitializeSid( &sia,
										  2,
										  SECURITY_BUILTIN_DOMAIN_RID,
										  DOMAIN_ALIAS_RID_ADMINS,
										  0, 0, 0, 0, 0, 0,
										  &psid);
	if( !bRet  )
	{
		return FALSE;
	}
	else if( !psid )
	{
		return FALSE;
	}
	
	if( !CheckTokenMembership(NULL, psid, &bRet) )
	{
		return FALSE;
	}

	FreeSid( psid );
    
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\serverprop.h ===
#ifndef __SERVERGENERALPAGE_H
#define __SERVERGENERALPAGE_H

#include <P3Admin.h>
#include <tmplEdit.h>
#define RESTART_POP3SVC         0x1
#define RESTART_SMTP            0x2

class CServerNode;

class CServerGeneralPage : public CPropertyPageImpl<CServerGeneralPage>
{
public:
    typedef CPropertyPageImpl<CServerGeneralPage> BC;

    CServerGeneralPage::CServerGeneralPage(IP3Config* pServer, LONG_PTR lNotifyHandle, CServerNode* pParent) : 
    m_spServerConfig(pServer), m_lNotifyHandle(lNotifyHandle), m_pParent(pParent) {};
    
    enum { IDD = IDD_SERVER_GENERAL_PAGE };

    BEGIN_MSG_MAP( CServerGeneralPage )            
        CHAIN_MSG_MAP(CPropertyPageImpl<CServerGeneralPage>)        
        
        MESSAGE_HANDLER         ( WM_INITDIALOG, OnInitDialog )
        MESSAGE_HANDLER         ( WM_HELP,       OnHelpMsg    )

        COMMAND_HANDLER         ( IDC_BROWSE,            BN_CLICKED,    OnBrowse )
        COMMAND_HANDLER         ( IDC_SERVER_CREATEUSER, BN_CLICKED,    OnChange )   
        COMMAND_HANDLER         ( IDC_AUTHENTICATION,    CBN_SELCHANGE, OnChange )        
        COMMAND_HANDLER         ( IDC_LOGGING,           CBN_SELCHANGE, OnChange )
        COMMAND_HANDLER         ( IDC_PORT,              EN_CHANGE,     OnChange )
        COMMAND_HANDLER         ( IDC_DIRECTORY,         EN_CHANGE,     OnChange )
        COMMAND_HANDLER         ( IDC_SERVER_SPA_REQ,    BN_CLICKED,    OnChange )
        
    END_MSG_MAP()

    // message handlers
    LRESULT OnInitDialog    ( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );
    LRESULT OnHelpMsg       ( UINT mMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled );

    LRESULT OnBrowse        ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );    
    LRESULT OnChange        ( WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled );    

    // Over-ridden function
    BOOL OnApply();
    void OnFinalMessage(HWND);
    // Helper function
    BOOL ValidateControls();

private:

    CComPtr<IP3Config>  m_spServerConfig;    
    LONG_PTR            m_lNotifyHandle;    
    CServerNode*        m_pParent;    

    CWindowImplNoImm<>  m_wndPort;
    DWORD               m_dwSvcRestart;

};

#endif //__SERVERGENERALPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\streamio.h ===
// stream i/o function header

#ifndef _STREAMIO_H_
#define _STREAMIO_H_

#include <vector>

typedef std::basic_string<BYTE> byte_string;
typedef std::vector<tstring> string_vector;

//
// declare by-value stream operators
//
#define DeclareStreamOperators(type)                    \
    IStream& operator>> (IStream& stm,       type& t);  \
    IStream& operator<< (IStream& stm,       type  t);      
                                                        
DeclareStreamOperators (         bool);
DeclareStreamOperators (         char);
DeclareStreamOperators (unsigned char);
DeclareStreamOperators (         short);
DeclareStreamOperators (unsigned short);
DeclareStreamOperators (         int);
DeclareStreamOperators (unsigned int);
DeclareStreamOperators (         long);
DeclareStreamOperators (unsigned long);

//
// declare by-ref stream operators
//
#define DeclareStreamOperatorsByRef(type)               \
    IStream& operator>> (IStream& stm,       type& t);  \
    IStream& operator<< (IStream& stm, const type& t);

DeclareStreamOperatorsByRef (CLSID);
DeclareStreamOperatorsByRef (FILETIME);
DeclareStreamOperatorsByRef (byte_string);
DeclareStreamOperatorsByRef (tstring);

//
// operators for vector of objects
//
template <class T>
IStream& operator<< (IStream& stm, std::vector<T>& vT)
{
    stm << static_cast<long>(vT.size());

    std::vector<T>::iterator it = vT.begin();
    while (it != vT.end()) 
    {
        stm << *it;
        ++it;
    }

    return stm;
}


template <class T>
IStream& operator>> (IStream& stm, std::vector<T>& vT)
{
    long nItems;
    stm >> nItems;

    vT.reserve(nItems);

    for (long lItem = 0; lItem < nItems; lItem++) 
    {
        T* pt = new T();
        if( pt )
        {
            vT.push_back(*pt);
        }
        
        T& rt = vT.back();
        stm >> rt;
    }

    return stm;
}



#endif //_STREAMIO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\streamio.cpp ===
// stream i/o functions

#include "stdafx.h"
#include <comutil.h>
#include <memory>

// Used Defines
#define THROW_ON_FAILURE(hr)    if (FAILED(hr)) _com_issue_error(hr);
#define THROW_ERROR(hr) _com_issue_error(hr);


/*+-------------------------------------------------------------------------*
 * ReadScalar 
 *
 * Reads a scalar value from a stream.
 *--------------------------------------------------------------------------*/

template<class T>
static IStream& ReadScalar (IStream& stm, T& t)
{
    ULONG cbActuallyRead;
    HRESULT hr = stm.Read (&t, sizeof (t), &cbActuallyRead);
    THROW_ON_FAILURE(hr);

    if (cbActuallyRead != sizeof (t))
        _com_issue_error (E_FAIL);

    return (stm);
}


/*+-------------------------------------------------------------------------*
 * WriteScalar 
 *
 * Writes a scalar value to a stream.
 *--------------------------------------------------------------------------*/

template<class T>
static IStream& WriteScalar (IStream& stm, const T& t)
{
    ULONG cbActuallyWritten;
    HRESULT hr = stm.Write (&t, sizeof (t), &cbActuallyWritten);
    THROW_ON_FAILURE(hr);

    if (cbActuallyWritten != sizeof (t))
        THROW_ERROR(E_FAIL);

    return (stm);
}


//----------------------------------------------------------------
// Define by-value stream operators
//----------------------------------------------------------------
#define DefineScalarStreamOperators(scalar_type)                \
    IStream& operator>> (IStream& stm, scalar_type& t)          \
        { return (ReadScalar (stm, t)); }                       \
    IStream& operator<< (IStream& stm, scalar_type t)           \
        { return (WriteScalar (stm, t)); }          
  
DefineScalarStreamOperators (         bool);
DefineScalarStreamOperators (         char);
DefineScalarStreamOperators (unsigned char);
DefineScalarStreamOperators (         short);
DefineScalarStreamOperators (unsigned short);
DefineScalarStreamOperators (         int);
DefineScalarStreamOperators (unsigned int);
DefineScalarStreamOperators (         long);
DefineScalarStreamOperators (unsigned long);

//----------------------------------------------------------------
// Define by-value stream operators
//----------------------------------------------------------------                                                    
#define DefineScalarStreamOperatorsByRef(scalar_type)           \
    IStream& operator>> (IStream& stm, scalar_type& t)          \
        { return (ReadScalar (stm, t)); }                       \
    IStream& operator<< (IStream& stm, const scalar_type& t)    \
        { return (WriteScalar (stm, t)); }

DefineScalarStreamOperatorsByRef(CLSID);
DefineScalarStreamOperatorsByRef(FILETIME);



/*+-------------------------------------------------------------------------*
 * ReadString 
 *
 * Reads a std::basic_string of char type CH from a stream.  The string should 
 * have been written with a DWORD character count preceding an array of
 * characters that is not NULL-terminated.
 *--------------------------------------------------------------------------*/

template<class CH>
static IStream& ReadString (IStream& stm, std::basic_string<CH>& str)
{
    /*
     * read the length
     */
    DWORD cch;
    stm >> cch;

    /*
     * allocate a buffer for the characters
     */
    std::auto_ptr<CH> spBuffer (new (std::nothrow) CH[cch + 1]);
    CH* pBuffer = spBuffer.get();

    if (pBuffer == NULL)
        THROW_ERROR(E_OUTOFMEMORY);

    /*
     * read the characters
     */
    ULONG cbActuallyRead;
    const ULONG cbToRead = cch * sizeof (CH);
    HRESULT hr = stm.Read (pBuffer, cbToRead, &cbActuallyRead);
    THROW_ON_FAILURE(hr);

    if (cbToRead != cbActuallyRead)
        THROW_ERROR(E_FAIL);

    /*
     * terminate the character array and assign it to the string
     */
    pBuffer[cch] = 0;

    /*
     * assign it to the string (clear the string first to work around
     * the bug described in KB Q172398)
     */
    str.erase();
    str = pBuffer;

    return (stm);
}

/*+-------------------------------------------------------------------------*
 * ReadString for byte_string 
 *
 * Specialization of ReadString for a string of bytes which may contain NULLs.
 * he string should have been written with a DWORD character count preceding 
 * an array of characters that is not NULL-terminated.
 *--------------------------------------------------------------------------*/

static IStream& ReadString (IStream& stm, std::basic_string<BYTE>& str)
{
    /*
     * read the length
     */
    DWORD cch;
    stm >> cch;


    if (cch == 0)
    {
        str.erase(); 
    }
    else
    {
        /*
         * allocate a buffer for the characters
         */
        std::auto_ptr<BYTE> spBuffer (new (std::nothrow) BYTE[cch]);
        BYTE* pBuffer = spBuffer.get();

        if (pBuffer == NULL)
            THROW_ERROR(E_OUTOFMEMORY);

        /*
         * read the characters
         */
        ULONG cbActuallyRead;
        const ULONG cbToRead = cch;
        HRESULT hr = stm.Read (pBuffer, cbToRead, &cbActuallyRead);
        THROW_ON_FAILURE(hr);

        if (cbToRead != cbActuallyRead)
            THROW_ERROR(E_FAIL);

         /*
         * assign it to the string (clear the string first to work around
         * the bug described in KB Q172398)
         */
        str.erase();
        str.assign(pBuffer, cch);
    }

    return (stm);
}



/*+-------------------------------------------------------------------------*
 * WriteString 
 *
 * Writes a std::basic_string of char type CH to a stream.  The string is 
 * written with a DWORD character count preceding an array of characters that 
 * is not NULL-terminated.
 *--------------------------------------------------------------------------*/

template<class CH>
static IStream& WriteString (IStream& stm, const std::basic_string<CH>& str)
{
    /*
     * write the length
     */
    DWORD cch = str.length();
    stm << cch;

    if (cch > 0)
    {
        /*
         * write the characters
         */
        ULONG cbActuallyWritten;
        const ULONG cbToWrite = cch * sizeof (CH);
        HRESULT hr = stm.Write (str.data(), cbToWrite, &cbActuallyWritten);
        THROW_ON_FAILURE(hr);

        if (cbToWrite != cbActuallyWritten)
            THROW_ERROR(E_FAIL);
    }

    return (stm);
}

//-----------------------------------------------------------------
// Define basic string stream operators
//-----------------------------------------------------------------
#define DefineStringStreamOperators(string_type)                \
    IStream& operator>> (IStream& stm, string_type& str)        \
        { return (ReadString (stm, str)); }                     \
    IStream& operator<< (IStream& stm, const string_type& str)  \
        { return (WriteString (stm, str)); }

DefineStringStreamOperators(tstring);
DefineStringStreamOperators(byte_string);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\usernode.cpp ===
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// CUserNode
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

// Access to Snapin
#include "Pop3.h"
#include "Pop3Snap.h"

// Access to nodes we use
#include "UserNode.h"
#include "DomainNode.h"

// Access to dialogs we use
#include "DeleteMailDlg.h"

static const GUID CUserNodeGUID_NODETYPE             = 
{ 0x794b0daf, 0xf2f1, 0x42dc, { 0x9f, 0x84, 0x41, 0xab, 0x1, 0xab, 0xa4, 0x8b } };

const           GUID*    CUserNode::m_NODETYPE       = &CUserNodeGUID_NODETYPE;
const           OLECHAR* CUserNode::m_SZNODETYPE     = OLESTR("794B0DAF-F2F1-42dc-9F84-41AB01ABA48B");
const           OLECHAR* CUserNode::m_SZDISPLAY_NAME = OLESTR("");
const           CLSID*   CUserNode::m_SNAPIN_CLASSID = &CLSID_POP3ServerSnap;

CUserNode::CUserNode(IP3User* pUser, CDomainNode* pParent)
{    
    // Initialize our user
    m_spUser  = pUser;
    m_pParent = pParent;

    // Get the Locked state for the icons below
    HRESULT hr = E_FAIL;
    BOOL bLocked = FALSE;
    if( m_spUser )
    {
        // Get our initial lock state for icon display        
        m_spUser->get_Lock( &bLocked );

        // Get our name
        hr = m_spUser->get_Name( &m_bstrDisplayName );        
    }

    if( FAILED(hr) )
    {
        m_bstrDisplayName = _T("");
    }

    // Initialize our column text
    m_bstrSize        = _T("");
    m_bstrNumMessages = _T("");
    m_bstrState       = _T("");

    // Initialize our Scope item even though we will never use it
    memset( &m_scopeDataItem, 0, sizeof(m_scopeDataItem) );
    m_scopeDataItem.mask        = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_CHILDREN;
    m_scopeDataItem.cChildren   = 0;
    m_scopeDataItem.displayname = MMC_CALLBACK;
    m_scopeDataItem.nImage      = (bLocked ? USERNODE_LOCKED_ICON : USERNODE_ICON);
    m_scopeDataItem.nOpenImage  = (bLocked ? USERNODE_LOCKED_ICON : USERNODE_ICON);
    m_scopeDataItem.lParam      = (LPARAM) this;
    
    // Initialize our result item, which is all we use
    memset( &m_resultDataItem, 0, sizeof(m_resultDataItem) );
    m_resultDataItem.mask   = RDI_STR | RDI_IMAGE | RDI_PARAM;
    m_resultDataItem.str    = MMC_CALLBACK;
    m_resultDataItem.nImage = (bLocked ? USERNODE_LOCKED_ICON : USERNODE_ICON);
    m_resultDataItem.lParam = (LPARAM) this;        
}


HRESULT CUserNode::GetScopePaneInfo(SCOPEDATAITEM *pScopeDataItem)
{
    if( !pScopeDataItem ) return E_INVALIDARG;
    if( !m_spUser ) return E_FAIL;

    BOOL bLocked = FALSE;
    m_spUser->get_Lock( &bLocked );

    if( pScopeDataItem->mask & SDI_STR )
        pScopeDataItem->displayname = m_bstrDisplayName;
    if( pScopeDataItem->mask & SDI_IMAGE )
        pScopeDataItem->nImage = (bLocked ? USERNODE_LOCKED_ICON : USERNODE_ICON);
    if( pScopeDataItem->mask & SDI_OPENIMAGE )
        pScopeDataItem->nOpenImage = (bLocked ? USERNODE_LOCKED_ICON : USERNODE_ICON);
    if( pScopeDataItem->mask & SDI_PARAM )
        pScopeDataItem->lParam = m_scopeDataItem.lParam;
    if( pScopeDataItem->mask & SDI_STATE )
        pScopeDataItem->nState = m_scopeDataItem.nState;
    if( pScopeDataItem->mask & SDI_CHILDREN )
        pScopeDataItem->cChildren = 0;
    
    return S_OK;
}

HRESULT CUserNode::GetResultPaneInfo(RESULTDATAITEM *pResultDataItem)
{
    if( !pResultDataItem ) return E_INVALIDARG;
    if( !m_spUser ) return E_FAIL;

    BOOL bLocked = FALSE;    
    m_spUser->get_Lock( &bLocked );

    if( pResultDataItem->bScopeItem )
    {
        if( pResultDataItem->mask & RDI_STR )
            pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
        if( pResultDataItem->mask & RDI_IMAGE )
            pResultDataItem->nImage = (bLocked ? USERNODE_LOCKED_ICON : USERNODE_ICON);
        if( pResultDataItem->mask & RDI_PARAM )
            pResultDataItem->lParam = m_scopeDataItem.lParam;
        
        return S_OK;
    }
    
    if( pResultDataItem->mask & RDI_STR )
        pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
    if( pResultDataItem->mask & RDI_IMAGE )
        pResultDataItem->nImage = (bLocked ? USERNODE_LOCKED_ICON : USERNODE_ICON);
    if( pResultDataItem->mask & RDI_PARAM )
        pResultDataItem->lParam = m_resultDataItem.lParam;
    if( pResultDataItem->mask & RDI_INDEX )
        pResultDataItem->nIndex = m_resultDataItem.nIndex;
    
    return S_OK;
}



LPOLESTR CUserNode::GetResultPaneColInfo(int nCol)
{
    if( !m_spUser ) return L"";

    switch( nCol )
    {
        case 0:      // Name
        {
            return m_bstrDisplayName;
        }

        case 1:     // Size of Mailbox (KB)
        {   
            // We want our result in Kilobytes
            long    lFactor = 0;
            long    lUsage  = 0;
            HRESULT hr      = m_spUser->get_MessageDiskUsage( &lFactor, &lUsage );
            
            if( FAILED(hr) )
            {
                lUsage = 0;
            }

            // Convert to KiloBytes
            __int64 i64Usage = lFactor * lUsage;            
            i64Usage /= 1024;

            // 1K buffer: Not likely we'll exceed that many digits
            tstring strKiloByte = StrLoadString( IDS_KILOBYTE_EXTENSION );
            TCHAR   szNum[1024] = {0};
            _sntprintf( szNum, 1023, strKiloByte.c_str(), i64Usage );
            
            // Store it in our own buffer
            m_bstrSize = szNum;            
            return m_bstrSize;             
        }

        case 2:     // Message Count
        {   
            long    lCount  = 0;
            HRESULT hr      = m_spUser->get_MessageCount( &lCount );

            if( FAILED(hr) )
            {
                lCount = 0;
            }

            // 1K buffer: Not likely we'll exceed that many digits
            TCHAR szNum[1024];
            _sntprintf( szNum, 1023, _T("%d"), lCount );
            
            m_bstrNumMessages = szNum;
            return m_bstrNumMessages;
        }

        case 3:     // State of Mailbox
        {            
            BOOL     bLocked = FALSE;
            
            m_spUser->get_Lock( &bLocked );
            tstring strTemp = StrLoadString( bLocked ? IDS_STATE_LOCKED : IDS_STATE_UNLOCKED );

            m_bstrState = strTemp.c_str();

            return m_bstrState;
        }
    
        default:
        {
#if DBG
            return L"No Information";
#else
            return L"";
#endif
        }
    }
}

HRESULT CUserNode::Notify( MMC_NOTIFY_TYPE event,
                           LPARAM arg,
                           LPARAM param,
                           IComponentData* pComponentData,
                           IComponent* pComponent,
                           DATA_OBJECT_TYPES type )
{
    if( !m_pParent ) return E_FAIL;

    HRESULT hr = S_FALSE;

    _ASSERTE(pComponentData != NULL || pComponent != NULL);

    CComPtr<IConsole> spConsole;    
    if( pComponentData )
    {
        spConsole = ((CPOP3ServerSnapData*)pComponentData)->m_spConsole;
    }
    else if( pComponent )
    {
        spConsole = ((CPOP3ServerSnapComponent*)pComponent)->m_spConsole;        
    }

    if( !spConsole ) return E_INVALIDARG;

    switch( event )
    {
    case MMCN_SHOW:
        {   
            hr = S_OK;
            break;
        }
    case MMCN_EXPAND:
        {                
            hr = S_OK;
            break;
        }
    case MMCN_ADD_IMAGES:
        {
            IImageList* pImageList = (IImageList*) arg;
            if( !pImageList ) return E_INVALIDARG;

            hr = LoadImages(pImageList);            
            break;
        }    

    case MMCN_VIEW_CHANGE:
    case MMCN_REFRESH:
        {
            CComQIPtr<IResultData> spResultData = spConsole;
            if( !spResultData ) return E_NOINTERFACE;            
            
            HRESULTITEM hrID;
            ZeroMemory( &hrID, sizeof(HRESULTITEM) );
            
            hr = spResultData->FindItemByLParam( (LPARAM)this, &hrID );
            
            if( SUCCEEDED(hr) )
            {
                hr = spResultData->UpdateItem( hrID );
            }
            
            // We also need to update the icon
            if( SUCCEEDED(hr) )
            {
                RESULTDATAITEM rdi;
                ZeroMemory( &rdi, sizeof(RESULTDATAITEM) );

                rdi.mask = RDI_IMAGE;
                rdi.itemID = hrID;
                GetResultPaneInfo( &rdi );
                hr = spResultData->SetItem( &rdi );
            }

            break;
        }

    case MMCN_DELETE:
        {
            hr = S_OK;

            // Pop-up our confirmation dialog
            // Ignoring return from GetAuth and defaulting to False
            BOOL bHash = FALSE;
            m_pParent->GetAuth( &bHash );            
            CDeleteMailboxDlg dlg( bHash );

            if( dlg.DoModal() == IDYES )
            {
                // The parent needs to do the deletion                                
                hr = m_pParent->DeleteUser(this, dlg.m_bCreateUser);                       

                if( SUCCEEDED(hr) )
                {
                    // Update our parent node
                    CComPtr<IDataObject> spDataObject = NULL;
                    hr = m_pParent->GetDataObject( &spDataObject, CCT_SCOPE );
                    if( !spDataObject ) 
                    {
                        hr = E_NOINTERFACE;
                    }
                    else
                    {
                        hr = spConsole->UpdateAllViews( spDataObject, (LPARAM)this, (LONG_PTR)NAV_DELETE );
                    }                    
                }

                if( SUCCEEDED(hr) )
                {
                    delete this;
                }                
                
                if( FAILED(hr) )
                {
                    // Failed to Delete the User                    
                    HWND     hWnd = NULL;    
                    spConsole->GetMainWindow(&hWnd);

                    tstring strMessage = StrLoadString(IDS_ERROR_DELETEUSER);
                    tstring strTitle   = StrLoadString(IDS_SNAPINNAME);
                    DisplayError( hWnd, strMessage.c_str(), strTitle.c_str(), hr );                    
                }
            }

            break;
        }

    case MMCN_SELECT:
        {
            // if selecting node
            if( HIWORD(arg) )
            {
                hr = S_OK;

                // get the verb interface and enable rename
                CComPtr<IConsoleVerb> spConsVerb;
                if( spConsole->QueryConsoleVerb(&spConsVerb) == S_OK )
                {
                    // Enable the Refresh Menu
                    hr = spConsVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE); 
                    if( FAILED(hr) ) return hr;
                    hr = spConsVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
                    if( FAILED(hr) ) return hr;

                    // Enable the Delete Menu
                    hr = spConsVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, TRUE); 
                    if( FAILED(hr) ) return hr;
                    hr = spConsVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
                    if( FAILED(hr) ) return hr;
                }
            }

            break;
        }
    case MMCN_CONTEXTHELP:
        {
            hr                                = S_OK;
            TCHAR    szWindowsDir[MAX_PATH+1] = {0};
            tstring  strHelpFile              = _T("");
            tstring  strHelpFileName          = StrLoadString(IDS_HELPFILE);
            tstring  strHelpTopicName         = StrLoadString(IDS_HELPTOPIC);

            if( strHelpFileName.empty() || strHelpTopicName.empty() )
            {
                return E_FAIL;
            }
            
            // Build path to %systemroot%\help
            UINT nSize = GetSystemWindowsDirectory( szWindowsDir, MAX_PATH );
            if( nSize == 0 || nSize > MAX_PATH )
            {
                return E_FAIL;
            }            
        
            strHelpFile = szWindowsDir;       // D:\windows
            strHelpFile += _T("\\Help\\");    // \help
            strHelpFile += strHelpFileName;   // \filename.chm
            strHelpFile += _T("::/");         // ::/
            strHelpFile += strHelpTopicName;  // index.htm            
        
            // Show the Help topic
            CComQIPtr<IDisplayHelp> spHelp = spConsole;
            if( !spHelp ) return E_NOINTERFACE;

            hr = spHelp->ShowTopic( (LPTSTR)strHelpFile.c_str() );
        
            break;
        }

    }// switch

    return hr;
}



HRESULT CUserNode::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback, long* pInsertionAllowed, DATA_OBJECT_TYPES type )
{
    if( !piCallback || !pInsertionAllowed ) return E_INVALIDARG;
    if( !m_spUser || !m_pParent ) return E_FAIL;

    HRESULT hr      = S_OK;    
    tstring strMenu = _T("");
    tstring strDesc = _T("");

    
    // Insert Result specific items
    if( (type == CCT_RESULT) && (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
    {
        CComQIPtr<IContextMenuCallback2> spContext2 = piCallback;
        if( !spContext2 ) return E_NOINTERFACE;

        CONTEXTMENUITEM2 singleMenuItem;
        ZeroMemory(&singleMenuItem, sizeof(CONTEXTMENUITEM2));

        singleMenuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
        singleMenuItem.fFlags            = m_pParent->IsLocked() ? (MF_DISABLED | MF_GRAYED) : MF_ENABLED;
        singleMenuItem.fSpecialFlags     = 0;

        // Query the state of this User to see which menu to load
        BOOL bLocked = FALSE;
        m_spUser->get_Lock( &bLocked );

        if( bLocked )
        {
            strMenu = StrLoadString(IDS_MENU_USER_UNLOCK);
            strDesc = StrLoadString(IDS_MENU_USER_UNLOCK_DESC);
            singleMenuItem.strName                      = (LPWSTR)strMenu.c_str();
            singleMenuItem.strStatusBarText             = (LPWSTR)strDesc.c_str();
            singleMenuItem.strLanguageIndependentName   = L"USER_UNLOCK";
            singleMenuItem.lCommandID                   = IDM_USER_TOP_UNLOCK;            
        }
        else
        {
            strMenu = StrLoadString(IDS_MENU_USER_LOCK);
            strDesc = StrLoadString(IDS_MENU_USER_LOCK_DESC);
            singleMenuItem.strName                      = (LPWSTR)strMenu.c_str();
            singleMenuItem.strStatusBarText             = (LPWSTR)strDesc.c_str();
            singleMenuItem.strLanguageIndependentName   = L"USER_LOCK";
            singleMenuItem.lCommandID                   = IDM_USER_TOP_LOCK;
        }

        if( !strMenu.empty() )
        {
            hr = spContext2->AddItem( &singleMenuItem );
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

// Lock the User
HRESULT CUserNode::OnUserLock( bool& bHandled, CSnapInObjectRootBase* pObj )
{
    if( !pObj ) return E_INVALIDARG;
    if( !m_spUser ) return E_FAIL;

    bHandled = true;       

    BOOL    bLocked = FALSE;
    HRESULT hr      = S_OK;
    
    // Get the current state
    hr = m_spUser->get_Lock( &bLocked );
    
    // Inverse the state
    bLocked = !bLocked;
    
    // Set the new state
    if( SUCCEEDED(hr) )
    {
        hr = m_spUser->put_Lock( bLocked );
    }

    // Update the icon
    if( SUCCEEDED(hr) )
    {
        // Set our icons here
        m_scopeDataItem.nImage     = (bLocked ? USERNODE_LOCKED_ICON : USERNODE_ICON);
        m_scopeDataItem.nOpenImage = (bLocked ? USERNODE_LOCKED_ICON : USERNODE_ICON);
        m_resultDataItem.nImage    = (bLocked ? USERNODE_LOCKED_ICON : USERNODE_ICON);

        CComPtr<IConsole> spConsole = NULL;
        hr = GetConsole( pObj, &spConsole );
        if( FAILED(hr) || !spConsole ) return E_NOINTERFACE;

        // Update our parent node
        CComPtr<IDataObject> spDataObject = NULL;
        hr = m_pParent->GetDataObject( &spDataObject, CCT_SCOPE );
        if( FAILED(hr) || !spDataObject ) return E_NOINTERFACE;

        spConsole->UpdateAllViews( spDataObject, (LPARAM)this, (LONG_PTR)NAV_REFRESHCHILD );
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\winpop\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	winpop.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\snapin\usernode.h ===
#ifndef UserNode_h
#define UserNode_h

#include "resource.h"
#include ".\atlsnap.h"
#include <objidl.h>

#include "pop3.h"
#include <P3Admin.h>

class CDomainNode;

//////////////////////////////////////////////////////////////////////////////////
//
// CUserNode
//
//////////////////////////////////////////////////////////////////////////////////
class CUserNode : public CSnapInItemImpl<CUserNode>
{
public:
    static const GUID* m_NODETYPE;
    static const OLECHAR* m_SZNODETYPE;
    static const OLECHAR* m_SZDISPLAY_NAME;
    static const CLSID* m_SNAPIN_CLASSID;

    CComPtr<IControlbar> m_spControlBar;
    
    BEGIN_SNAPINCOMMAND_MAP(CUserNode, FALSE)
        SNAPINCOMMAND_ENTRY         ( IDM_USER_TOP_LOCK,   OnUserLock )        
        SNAPINCOMMAND_ENTRY         ( IDM_USER_TOP_UNLOCK, OnUserLock )        
    END_SNAPINCOMMAND_MAP()

    CUserNode(IP3User* pUser, CDomainNode* pParent);

    virtual ~CUserNode()
    {
    }

    STDMETHOD(QueryPagesFor)(DATA_OBJECT_TYPES type)
    {
        if ( type == CCT_RESULT )
        {
            return S_OK;
        }
        return S_FALSE;
    }

    STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem);
    STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem);
    STDMETHOD(Notify)( MMC_NOTIFY_TYPE event,
                       LPARAM arg,
                       LPARAM param,
                       IComponentData* pComponentData,
                       IComponent* pComponent,
                       DATA_OBJECT_TYPES type);


    LPOLESTR GetResultPaneColInfo(int nCol);    
    
    // MenuItem Implementations
    STDMETHOD(AddMenuItems) (LPCONTEXTMENUCALLBACK piCallback, long* pInsertionAllowed, DATA_OBJECT_TYPES type );    
    STDMETHOD(OnUserLock)   (bool& bHandled, CSnapInObjectRootBase* pObj );

private:
       
    // User Information
    CComPtr<IP3User> m_spUser;    

    // Parent Information
    CDomainNode*     m_pParent;

    // Column text needs to be allocated by us, so we'll free them in the destructor
    CComBSTR         m_bstrSize;
    CComBSTR         m_bstrNumMessages;     
    CComBSTR         m_bstrState;     
};

#endif // UserNode_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\winpop\resource2.h ===
#define IDS_WARNING_ADDDOMAIN_FILEALREADYEXISTS 4001
#define IDS_WARNING_DELDOMAIN_PATHNOTFOUND      4002
#define IDS_WARNING_SETMAILROOT                 4003

#define IDS_ERROR_UNKNOWN                       5000
#define IDS_SUCCESS_ADDDOMAIN                   5101
#define IDS_SUCCESS_ADDMAILBOX                  5102
#define IDS_SUCCESS_DELDOMAIN                   5103
#define IDS_SUCCESS_DELMAILBOX                  5104
#define IDS_SUCCESS_LOCKDOMAIN                  5105
#define IDS_SUCCESS_LOCKMAILBOX                 5106
#define IDS_SUCCESS_UNLOCKDOMAIN                5107
#define IDS_SUCCESS_UNLOCKMAILBOX               5108
#define IDS_SUCCESS_CREATEQUOTAFILE             5109
#define IDS_SUCCESS_SETMAILROOT                 5110
#define IDS_SUCCESS_MIGRATETOAD                 5111

#define IDS_ERROR_ADDDOMAIN_FAILED              5501
#define IDS_ERROR_ADDDOMAIN_ALREADYEXISTS       5502
#define IDS_ERROR_ADDMAILBOX_FAILED             5503
#define IDS_ERROR_ADDMAILBOX_ALREADYEXISTS      5504
#define IDS_ERROR_DELDOMAIN_FAILED              5505
#define IDS_ERROR_DELMAILBOX_FAILED             5506
#define IDS_ERROR_LOCKDOMAIN_FAILED             5507
#define IDS_ERROR_LOCKDOMAIN_ALREADYLOCKED      5508
#define IDS_ERROR_LOCKMAILBOX_FAILED            5509
#define IDS_ERROR_LOCKMAILBOX_ALREADYLOCKED     5510
#define IDS_ERROR_UNLOCKDOMAIN_FAILED           5511
#define IDS_ERROR_UNLOCKDOMAIN_ALREADYUNLOCKED  5512
#define IDS_ERROR_UNLOCKMAILBOX_FAILED          5513
#define IDS_ERROR_UNLOCKMAILBOX_ALREADYUNLOCKED 5514
#define IDS_ERROR_SETPASSWORD_FAILED            5515
#define IDS_ERROR_CREATEQUOTAFILE_FAILED        5516
#define IDS_ERROR_SETAUTH_FAILED                5517
#define IDS_ERROR_ADDMAILBOX_SAMNAMETOOLONG     5518
#define IDS_ERROR_MIGRATETOAD                   5519
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\winpop\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by winpop.rc
//
#define IDS_CMD_LISTDOMAINS             100
#define IDS_CMD_LISTDOMAINSEND          101
#define IDS_CMD_LISTUSERS               102
#define IDS_CMD_LISTUSERSEND            103
#define IDS_CMD_STATDOMAINS             104
#define IDS_CMD_STATDOMAINSMAILBOXES    105
#define IDS_CMD_STATDOMAINSDISKUSAGE    106
#define IDS_CMD_STATDOMAINSMESSAGES     107
#define IDS_CMD_STATUSERS               108
#define IDS_CMD_STATUSERSDISKUSAGE      109
#define IDS_CMD_STATUSERSMESSAGES       110
#define IDS_CMD_LOGNONE                 111
#define IDS_CMD_LOGMINIMUM              112
#define IDS_CMD_LOGMEDIUM               113
#define IDS_CMD_LOGMAXIMUM              114
#define IDS_CMD_SPAREQUIRED0            115
#define IDS_CMD_SPAREQUIRED1            116
#define IDS_WINPOP_USAGE1               201
#define IDS_WINPOP_USAGE2               202
#define IDS_WINPOP_USAGE3               203
#define IDS_WINPOP_USAGE4               204
#define IDS_WINPOP_USAGE5               205
#define IDS_WINPOP_USAGE6               206
#define IDS_WINPOP_USAGE7               207
#define IDS_WINPOP_USAGE8               208
#define IDS_WINPOP_USAGE9               209
#define IDS_WINPOP_USAGE10              210
#define IDS_WINPOP_USAGE11              211
#define IDS_WINPOP_USAGE12              212
#define IDS_WINPOP_USAGE13              213
#define IDS_WINPOP_USAGE14              214
#define IDS_WINPOP_USAGE15              215
#define IDS_WINPOP_USAGE16              216
#define IDS_WINPOP_USAGE17              217
#define IDS_WINPOP_USAGE18              218
#define IDS_WINPOP_USAGEEND             219
#define IDS_WINPOP_GETSET1              251
#define IDS_WINPOP_GETSET2              252
#define IDS_WINPOP_GETSET3              253
#define IDS_WINPOP_GETSET4              254
#define IDS_WINPOP_GETSET5              255
#define IDS_WINPOP_GETSET6              256
#define IDS_WINPOP_GETSET7              257
#define IDS_WINPOP_GETSET8              258
#define IDS_WINPOP_GETSET9              259
#define IDS_WINPOP_GETSET10             260
#define IDS_WINPOP_GETSET11             261
#define IDS_WINPOP_GETSET12             262
#define IDS_WINPOP_GETSET13             263
#define IDS_WINPOP_GETSET14             264
#define IDS_WINPOP_GETSET15             265
#define IDS_WINPOP_GETSET16             266
#define IDS_WINPOP_GETSET17             267
#define IDS_WINPOP_GETSET18             268
#define IDS_WINPOP_GETSET19             269
#define IDS_WINPOP_GETSET20             270
#define IDS_WINPOP_GETSET21             271
#define IDS_WINPOP_GETSET22             272
#define IDS_WINPOP_GETSET23             273
#define IDS_WINPOP_GETSET24             274
#define IDS_WINPOP_GETSET25             275
#define IDS_WINPOP_GETSET26             276
#define IDS_WINPOP_GETSET27             277
#define IDS_WINPOP_GETSET28             278
#define IDS_WINPOP_GETSETEND            278
#define IDS_LOCKED                      300
#define IDS_MESSAGE_POP3SVC_RESTART     400
#define IDS_MESSAGE_POP3SVC_STMP_RESTART 401

#define IDS_SERVICESTATUS_DESCRIPTIONS            8000
#define IDS_SERVICESTATUS_STOPPED_NOLOC           8001
#define IDS_SERVICESTATUS_STARTPENDING_NOLOC      8002
#define IDS_SERVICESTATUS_STOPPENDING_NOLOC       8003
#define IDS_SERVICESTATUS_RUNNING_NOLOC           8004
#define IDS_SERVICESTATUS_CONTINUEPENDING_NOLOC   8005
#define IDS_SERVICESTATUS_PAUSEPENDING_NOLOC      8006
#define IDS_SERVICESTATUS_PAUSED_NOLOC            8007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\winpop\winpop3.h ===
// WinPop3.h: interface for the CWinPop3 class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WINPOP3_H__E31CD929_FC30_413D_9944_E6991AFB61DE__INCLUDED_)
#define AFX_WINPOP3_H__E31CD929_FC30_413D_9944_E6991AFB61DE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

struct IP3Config;   //forward declaration

class CWinPop3  
{
public:
    CWinPop3();
    virtual ~CWinPop3();

public: // Implementation
    int Add(int argc, wchar_t *argv[]);
    int AddUserToAD(int argc, wchar_t *argv[]);
    int CreateQuotaFile(int argc, wchar_t *argv[]);
    int Del(int argc, wchar_t *argv[]);
    int Get(int argc, wchar_t *argv[]);
    int Init( int argc, wchar_t* argv[]);
    int List( int argc, wchar_t* argv[]);
    int Lock( int argc, wchar_t* argv[], BOOL bLock);
    int Net(int argc, wchar_t *argv[]);
    int Set(int argc, wchar_t *argv[]);
    int SetPassword(int argc, wchar_t *argv[]);
    int Stat( int argc, wchar_t* argv[]);
    
    void PrintError( int iRC );
    void PrintMessage( LPWSTR psMessage, bool bCRLF = true );
    void PrintMessage( int iID, bool bCRLF = true );
    void PrintUsage();
    void PrintUsageGetSet();

protected:
    void SetMachineName( IP3Config *pIConfig );
    bool StrIsDigit( LPWSTR ps );

// Attributes
protected:
    bool m_bSuppressPrintError;
    
};

#endif // !defined(AFX_WINPOP3_H__E31CD929_FC30_413D_9944_E6991AFB61DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\winpop\winpop.cpp ===
// winpop.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "WinPop3.h"

#include <atlbase.h>
#include <checkuser.h>  //IsUserInGroup
#include <locale.h>
#include <stdio.h>

int _cdecl wmain(int argc, wchar_t* argv[])
{
    HRESULT hr = S_OK;
    CWinPop3 wp3;
    CHAR szConsoleCP[8];

    setlocale( LC_ALL, "" );
    if ( 0 < _snprintf( szConsoleCP, 7, ".%d", GetConsoleOutputCP() ))
        setlocale( LC_CTYPE, szConsoleCP );
    // Command check
    if ( S_OK != IsUserInGroup(DOMAIN_ALIAS_RID_ADMINS)) // Admin check
        hr = E_ACCESSDENIED;
    else if ( 2 > argc )
        hr = -1;
    else if ( 2 < argc )
    {
        for ( int i = 1; i < argc; i++ )
        {
            if (( 0 == _wcsicmp( L"/?", argv[i] )) || ( 0 == _wcsicmp( L"-?", argv[i] )))
            {
                if (( 0 == _wcsicmp( L"GET", argv[1] )) || ( 0 == _wcsicmp( L"SET", argv[1] )))
                    hr = -2;
                else
                    hr = -1;
            }
        }
    }
    if ( S_OK == hr )
    {
        hr = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
        if ( S_OK == hr )
        {
            if ( 0 == _wcsicmp( L"ADD", argv[1] ))
            {   // ADD <domainname | username@domainname>
                hr = wp3.Add( argc, argv );
            }
            else if (( 0 == _wcsicmp( L"DEL", argv[1] )) || ( 0 == _wcsicmp( L"DELETE", argv[1] )))
            {   // DEL <domainname | username@domainname>
                hr = wp3.Del( argc, argv );
            }
            else if ( 0 == _wcsicmp( L"INIT", argv[1] ))
            {   // INIT [0|1]
                hr = wp3.Init( argc, argv );
            }
            else if ( 0 == _wcsicmp( L"LIST", argv[1] ))
            {   // LIST [domainname]
                hr = wp3.List( argc, argv );
            }
            else if ( 0 == _wcsicmp( L"LOCK", argv[1] ))
            {   // ADD <domainname | username@domainname>
                hr = wp3.Lock( argc, argv, TRUE );
            }
            else if ( 0 == _wcsicmp( L"UNLOCK", argv[1] ))
            {   // ADD <domainname | username@domainname>
                hr = wp3.Lock( argc, argv, FALSE );
            }
            else if ( 0 == _wcsicmp( L"STAT", argv[1] ))
            {   // LIST [domainname]
                hr = wp3.Stat( argc, argv );
            }
            else if ( 0 == _wcsicmp( L"GET", argv[1] ))
            {   // GET [setting]
                hr = wp3.Get( argc, argv );
            }
            else if ( 0 == _wcsicmp( L"SET", argv[1] ))
            {   // SET [setting] [value]
                hr = wp3.Set( argc, argv );
            }
            else if ( 0 == _wcsicmp( L"CHANGEPWD", argv[1] ))
            {   // SET [setting] [value]
                hr = wp3.SetPassword( argc, argv );
            }
            else if ( 0 == _wcsicmp( L"CREATEQUOTAFILE", argv[1] ))
            {   // CREATEQUOTAFILE username@domainname [/MACHINE:machinename] [/USER:username]
                hr = wp3.CreateQuotaFile( argc, argv );
            }
            else if ( 0 == _wcsicmp( L"MIGRATETOAD", argv[1] ))
            {   // MIGRATETOAD username@domainname
                hr = wp3.AddUserToAD( argc, argv );
            }
            else if ( 0 == _wcsicmp( L"NET", argv[1] ))
            {   // SET [setting] [value]
                hr = wp3.Net( argc, argv );
            }
            else
                hr = -1;
            CoUninitialize();
        }
    }

    if ( -1 == hr )
    {
        wp3.PrintUsage();
    }
    else if ( -2 == hr )
    {
        wp3.PrintUsageGetSet();
    }
    else if ( 0 != hr )
    {
        wp3.PrintError( hr );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\winpop\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__1F9875FD_4BBB_4DAC_B762_24FB8A5718E1__INCLUDED_)
#define AFX_STDAFX_H__1F9875FD_4BBB_4DAC_B762_24FB8A5718E1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400	// DKB
#endif
#include <windows.h>

#include <assert.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1F9875FD_4BBB_4DAC_B762_24FB8A5718E1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\admin\winpop\winpop3.cpp ===
// WinPop3.cpp: implementation of the CWinPop3 class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "WinPop3.h"
#include "resource.h"
#include "resource2.h"
#include <P3Admin.h>

#include <atlbase.h>
#include <comdef.h>
#include <tchar.h>
#include <POP3Server.h>
#include <AuthID.h>
#include <AuthUtil.h>
#include <inetinfo.h>
#include <smtpinet.h>
#include <stdio.h>
#include <ras.h>    // For PWLEN

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWinPop3::CWinPop3() :
    m_bSuppressPrintError( false )
{

}

CWinPop3::~CWinPop3()
{

}

//////////////////////////////////////////////////////////////////////
// Implementation : public
//////////////////////////////////////////////////////////////////////

int CWinPop3::Add(int argc, wchar_t *argv[])
{
    HRESULT hr;
    bool    bAddUser = false;
    _bstr_t _bstrDomainName;
    _bstr_t _bstrUserName;
    _bstr_t _bstrPassword;
    WCHAR   sBuffer[MAX_PATH*2];
    WCHAR   sPassword[PWLEN];
    CComPtr<IP3Config> spIConfig;
    CComPtr<IP3Domains> spDomains;
    CComPtr<IP3Domain> spDomain;
    CComPtr<IP3Users> spUsers;

    if ( (3 != argc) && (5 != argc ))
        return -1;
    if ( (5 == argc) && !(( 0 == _wcsicmp( L"/CREATEUSER", argv[3] )||( 0 == _wcsicmp( L"-CREATEUSER", argv[3] )))))
        return -1;
    if ( (sizeof(sBuffer)/sizeof(WCHAR)) < (wcslen( argv[2] ) + 1) )
        return E_INVALIDARG;
    if ( ( 5 == argc ) && (sizeof(sPassword)/sizeof(WCHAR)) < (wcslen( argv[4] ) + 1) )
        return E_INVALIDARG;

    sBuffer[(sizeof(sBuffer)/sizeof(WCHAR))-1] = 0;
    wcsncpy( sBuffer, argv[2], (sizeof(sBuffer)/sizeof(WCHAR))-1 );
    WCHAR *ps = wcsrchr( sBuffer, L'@' );
    if ( NULL == ps )
    {
        _bstrDomainName = sBuffer;
    }
    else
    {
        *ps = 0x0;
        _bstrUserName = sBuffer;
        if ( 0 == _bstrUserName.length() )
            return E_INVALIDARG;
        ps++;
        if ( NULL != *ps )
            _bstrDomainName = ps;
        else
            return E_INVALIDARG;
    }
    if ( 5 == argc )
    {
        if ( 0 == _bstrUserName.length() )
            return -1;
        // Check password for DBCS characters
        WCHAR   *ps = argv[4];
        BOOL    bDBCS = false;
        
        while ( !bDBCS && 0x0 != *ps )
        {
            bDBCS = (256 < *ps);
            ps++;
        }
        if ( bDBCS )
            return E_INVALIDARG;
        _bstrPassword = argv[4];
        bAddUser = true;
    }
    
    hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
    if ( S_OK == hr )
    {
        SetMachineName( spIConfig );
        hr = spIConfig->get_Domains( &spDomains );
    }
    if ( S_OK == hr )
    {
        if ( 0 == _bstrUserName.length() )
        {   // Add a domain
            hr = spDomains->Add( _bstrDomainName );
            if ( S_OK == hr || ERROR_FILE_EXISTS == hr )
            {
                PrintMessage( IDS_SUCCESS_ADDDOMAIN );
                if ( ERROR_FILE_EXISTS == hr )
                {
                    PrintMessage( IDS_WARNING_ADDDOMAIN_FILEALREADYEXISTS );    
                    m_bSuppressPrintError = true;
                }
            }
            else
            {
                if ( HRESULT_FROM_WIN32( ERROR_DOMAIN_EXISTS ) == hr )
                {
                    PrintMessage( IDS_ERROR_ADDDOMAIN_ALREADYEXISTS );
                    m_bSuppressPrintError = true;
                }
                else 
                    PrintMessage( IDS_ERROR_ADDDOMAIN_FAILED );
            }
        }
        else
        {   // Add a user
            _variant_t _v( _bstrDomainName );
            CComPtr<IP3User> spUser;
            
            hr = spDomains->get_Item( _v, &spDomain );
            if ( S_OK == hr )
                hr = spDomain->get_Users( &spUsers );
            if ( S_OK == hr )
            {
                if ( !bAddUser )
                    hr = spUsers->Add( _bstrUserName );
                else
                    hr = spUsers->AddEx( _bstrUserName, _bstrPassword );
            }
            if ( S_OK == hr )
            {
                BOOL    bConfirm;
                
                PrintMessage( IDS_SUCCESS_ADDMAILBOX );
                // Do we need confirmation text?
                hr = spIConfig->get_ConfirmAddUser( &bConfirm );
                if ( S_OK == hr )
                {
                    _v = _bstrUserName;
                    hr = spUsers->get_Item( _v, &spUser );
                }
                if ( S_OK == hr && !bConfirm )
                {
                    BSTR bstrSAMName = NULL;
                    
                    hr = spUser->get_SAMName( &bstrSAMName );
                    if ( S_OK == hr )
                    {
                        if ( 0 != _wcsicmp( bstrSAMName, _bstrUserName ))
                            bConfirm = TRUE;
                        SysFreeString( bstrSAMName );
                    }
                    else if ( HRESULT_FROM_WIN32( ERROR_DS_INAPPROPRIATE_AUTH ) == hr )
                        hr = S_OK;
                }
                if ( S_OK == hr && bConfirm )
                {   // Get confirmation text
                    BSTR    bstrConfirm;
                    
                    hr = spUser->get_ClientConfigDesc( &bstrConfirm );
                    if ( S_OK == hr )
                    {
                        PrintMessage( bstrConfirm );
                        SysFreeString( bstrConfirm );
                    }
                }
            }
            else
            {
                if ( HRESULT_FROM_WIN32( ERROR_FILE_EXISTS ) == hr )
                {
                    PrintMessage( IDS_ERROR_ADDMAILBOX_ALREADYEXISTS );
                    m_bSuppressPrintError = true;
                }
                else if ( HRESULT_FROM_WIN32( WSAENAMETOOLONG ) == hr )
                {
                    PrintMessage( IDS_ERROR_ADDMAILBOX_FAILED );
                    PrintMessage( IDS_ERROR_ADDMAILBOX_SAMNAMETOOLONG );
                    m_bSuppressPrintError = true;
                }
                else if ( HRESULT_FROM_WIN32( ERROR_NONE_MAPPED ) == hr )
                {
                    PrintMessage( IDS_SUCCESS_ADDMAILBOX );
                    PrintMessage( IDS_ERROR_CREATEQUOTAFILE_FAILED );
                }
                else 
                    PrintMessage( IDS_ERROR_ADDMAILBOX_FAILED );
            }
        }
    }
    return hr;
}

int CWinPop3::AddUserToAD(int argc, wchar_t *argv[])
{
    HRESULT hr;
    _bstr_t _bstrDomainName;
    _bstr_t _bstrUserName;
    _bstr_t _bstrPassword;
    WCHAR   sBuffer[MAX_PATH*2];
    CComPtr<IP3Config> spIConfig;
    CComPtr<IP3Domains> spDomains;
    CComPtr<IP3Domain> spDomain;
    CComPtr<IP3Users> spUsers;
    CComPtr<IP3User> spUser;

    if ( 3 != argc )
        return -1;
    if ( (sizeof(sBuffer)/sizeof(WCHAR)) < (wcslen( argv[2] ) + 1) )
        return E_INVALIDARG;

    sBuffer[(sizeof(sBuffer)/sizeof(WCHAR))-1] = 0;
    wcsncpy( sBuffer, argv[2], (sizeof(sBuffer)/sizeof(WCHAR))-1 );
    WCHAR *ps = wcsrchr( sBuffer, L'@' );
    if ( NULL == ps )
    {
        return E_INVALIDARG;
    }
    else
    {
        *ps = 0x0;
        _bstrUserName = sBuffer;
        if ( 0 == _bstrUserName.length() )
            return E_INVALIDARG;
        ps++;
        if ( NULL != *ps )
            _bstrDomainName = ps;
        else
            return E_INVALIDARG;
    }
    
    hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
    if ( S_OK == hr )
    {
        SetMachineName( spIConfig );
        hr = spIConfig->get_Domains( &spDomains );
    }
    if ( S_OK == hr )
    {   // migrate user
        _variant_t _v( _bstrDomainName );
        hr = spDomains->get_Item( _v, &spDomain );
        if ( S_OK == hr )
            hr = spDomain->get_Users( &spUsers );
        if ( S_OK == hr )
        {
            _v = _bstrUserName;
            hr = spUsers->get_Item( _v, &spUser );
        }
        if ( S_OK == hr )
        {
            BSTR bstrAccount;
            char chPassword[MAX_PATH];
            _variant_t _vPassword;
            CComPtr<IAuthMethod> spIAuthMethod;
            
            if ( S_OK == hr )
            {   // Only valid for MD5 Auth
                CComPtr<IAuthMethods> spIAuthMethods;
                BSTR    bstrID;
                _variant_t _v;
                long     lValue;
                WCHAR   sBuffer[MAX_PATH];

                hr = spIConfig->get_Authentication( &spIAuthMethods );
                if ( S_OK == hr )
                    hr = spIAuthMethods->get_CurrentAuthMethod( &_v );
                if ( S_OK == hr )
                    hr = spIAuthMethods->get_Item( _v, &spIAuthMethod );
                if ( S_OK == hr )
                    hr = spIAuthMethod->get_ID( &bstrID );
                if ( S_OK == hr )
                {
                    if ( 0 != _wcsicmp( bstrID, SZ_AUTH_ID_MD5_HASH ))
                        hr = HRESULT_FROM_WIN32( ERROR_DS_INAPPROPRIATE_AUTH );
                    SysFreeString( bstrID );
                }
                if ( S_OK == hr )   // Get the AD AuthMethod
                {
                    bool    bFound = false;
                    long    lCount;
                    
                    hr = spIAuthMethods->get_Count( &lCount );
                    for ( V_I4( &_v ) = 1; (S_OK == hr) && !bFound && (V_I4( &_v ) <= lCount); V_I4( &_v )++ )
                    {
                        hr = spIAuthMethods->get_Item( _v, &spIAuthMethod );
                        if ( S_OK == hr )
                        {
                            hr = spIAuthMethod->get_ID( &bstrID );
                            if ( S_OK == hr )
                            {
                                if ( 0 == _wcsicmp( bstrID, SZ_AUTH_ID_DOMAIN_AD ))
                                    bFound = true;
                                else
                                    spIAuthMethod.Release();
                                SysFreeString( bstrID );
                            }
                        }
                    }
                    if ( !bFound && S_OK == hr )
                        hr = HRESULT_FROM_WIN32( ERROR_DS_DS_REQUIRED );
                }
            }
            if ( S_OK == hr )
                hr = spUser->get_EmailName( &bstrAccount );
            if ( S_OK == hr )
            {
                hr = GetMD5Password( bstrAccount, chPassword );
                if ( S_OK == hr )
                {
                    _vPassword = chPassword;
                    hr = spIAuthMethod->CreateUser( bstrAccount, _vPassword );
                }
                SysFreeString( bstrAccount );
            }
        }
        if ( S_OK == hr )
            PrintMessage( IDS_SUCCESS_MIGRATETOAD );
        else
            PrintMessage( IDS_ERROR_MIGRATETOAD );
    }
    
    return hr;
}

int CWinPop3::CreateQuotaFile(int argc, wchar_t *argv[])
{
    HRESULT hr;
    bool    bAddUser = false;
    _bstr_t _bstrDomainName;
    _bstr_t _bstrUserName;
    _bstr_t _bstrMachineName, _bstrNTUserName;
    WCHAR   sBuffer[MAX_PATH*2];
    CComPtr<IP3Config> spIConfig;
    CComPtr<IP3Domains> spDomains;
    CComPtr<IP3Domain> spDomain;
    CComPtr<IP3Users> spUsers;
    CComPtr<IP3User> spUser;
    LPWSTR  psMachine = NULL;
    LPWSTR  psUser = NULL;

    if ( (3 != argc) && (4 != argc ) && (5 != argc ))
        return -1;
    if ( 4 == argc || 5 == argc )
    {
        if ( ( 0 == _wcsnicmp( L"/MACHINE:", argv[3], 9 )||( 0 == _wcsnicmp( L"-MACHINE:", argv[3], 9 ))) && 9 < wcslen( argv[3] ))
        {
            psMachine = argv[3];
            psMachine += 9;
        }
        if ( ( 0 == _wcsnicmp( L"/USER:", argv[3], 6 )||( 0 == _wcsnicmp( L"-USER:", argv[3], 6 ))) && 6 < wcslen( argv[3] ))
        {
            psUser = argv[3];
            psUser += 6;
        }
        if ( NULL == psMachine && NULL == psUser )
            return -1;
    }   
    if ( 5 == argc )
    {
        if ( ( 0 == _wcsnicmp( L"/MACHINE:", argv[4], 9 )||( 0 == _wcsnicmp( L"-MACHINE:", argv[4], 9 ))) && 9 < wcslen( argv[4] ))
        {
            psMachine = argv[4];
            psMachine += 9;
        }
        if ( ( 0 == _wcsnicmp( L"/USER:", argv[4], 6 )||( 0 == _wcsnicmp( L"-USER:", argv[4], 6 ))) && 6 < wcslen( argv[4] ))
        {
            psUser = argv[4];
            psUser += 6;
        }
        if ( NULL == psMachine || NULL == psUser )
            return -1;
    }   
    if ( (sizeof(sBuffer)/sizeof(WCHAR)) < (wcslen( argv[2] ) + 1) )
        return E_INVALIDARG;
 
    _bstrMachineName = psMachine;
    _bstrNTUserName = psUser;
    
    sBuffer[(sizeof(sBuffer)/sizeof(WCHAR))-1] = 0;
    wcsncpy( sBuffer, argv[2], (sizeof(sBuffer)/sizeof(WCHAR))-1 );
    WCHAR *ps = wcsrchr( sBuffer, L'@' );
    if ( NULL == ps )
         return -1;
    else
    {
        *ps = 0x0;
        _bstrUserName = sBuffer;
        if ( 0 == _bstrUserName.length() )
            return E_INVALIDARG;
        ps++;
        if ( NULL != *ps )
            _bstrDomainName = ps;
        else
            return E_INVALIDARG;
    }
    
    hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
    if ( S_OK == hr )
    {
        SetMachineName( spIConfig );
        hr = spIConfig->get_Domains( &spDomains );
    }
    if ( S_OK == hr )
    {
        _variant_t _v( _bstrDomainName );
        hr = spDomains->get_Item( _v, &spDomain );
        if ( S_OK == hr )
            hr = spDomain->get_Users( &spUsers );
        _v.Detach();
        _v = _bstrUserName;
        if ( S_OK == hr )
            hr = spUsers->get_Item( _v, &spUser );
        _v.Detach();
        if ( S_OK == hr )
            hr = spUser->CreateQuotaFile( _bstrMachineName, _bstrNTUserName );
        if ( S_OK == hr )
            PrintMessage( IDS_SUCCESS_CREATEQUOTAFILE );
        else
            PrintMessage( IDS_ERROR_CREATEQUOTAFILE_FAILED );
    }
    return hr;
}

int CWinPop3::Del(int argc, wchar_t *argv[])
{
    HRESULT hr = S_OK;
    bool    bConfirm = true;
    bool    bDeleteUser = false;
    _bstr_t _bstrDomainName;
    _bstr_t _bstrUserName;
    WCHAR   sBuffer[MAX_PATH*2];

    if (( 3 > argc ) || ( 5 < argc ))
        return -1;
    if ( (sizeof(sBuffer)/sizeof(WCHAR)) < (wcslen( argv[2] ) + 1) )
        return E_INVALIDARG;
    
    sBuffer[(sizeof(sBuffer)/sizeof(WCHAR))-1] = 0;
    wcsncpy( sBuffer, argv[2], (sizeof(sBuffer)/sizeof(WCHAR))-1 );
    WCHAR *ps = wcsrchr( sBuffer, L'@' );
    if ( NULL == ps )
    {
        _bstrDomainName = sBuffer;
    }
    else
    {
        *ps = 0x0;
        _bstrUserName = sBuffer;
        if ( 0 == _bstrUserName.length() )
            return E_INVALIDARG;
        ps++;
        if ( NULL != *ps )
            _bstrDomainName = ps;
        else
            return E_INVALIDARG;
    }
    for ( int i = 3; S_OK == hr && i < argc; i++ )
    {
        if ( (0 == _wcsicmp( L"/Y", argv[i] )) || (0 == _wcsicmp( L"-Y", argv[i] )) )
        {
            if ( bConfirm )
                bConfirm = false;
            else
                hr = -1;
        }
        else if ( ( 0 == _wcsicmp( L"/DELETEUSER", argv[i] )) || ( 0 == _wcsicmp( L"-DELETEUSER", argv[i] )))
        {
            if ( !bDeleteUser )
                bDeleteUser = true;
            else
                hr = -1;
        }
        else
            hr = -1;
    }    
    if ( S_OK == hr )
    {
        CComPtr<IP3Config> spIConfig;
        CComPtr<IP3Domains> spDomains;
        CComPtr<IP3Domain> spDomain;
        CComPtr<IP3Users> spUsers;

        hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
        if ( S_OK == hr )
        {
            SetMachineName( spIConfig );
            hr = spIConfig->get_Domains( &spDomains );
        }
        if ( S_OK == hr )
        {
            if ( 0 == _bstrUserName.length() )
            {   // Delete a domain
                hr = spDomains->Remove( _bstrDomainName );
                if ( S_OK == hr || ERROR_PATH_NOT_FOUND == hr )
                {
                    PrintMessage( IDS_SUCCESS_DELDOMAIN );
                    if ( ERROR_PATH_NOT_FOUND == hr )
                    {
                        PrintMessage( IDS_WARNING_DELDOMAIN_PATHNOTFOUND );
                        m_bSuppressPrintError = true;
                    }
                }
                else
                    PrintMessage( IDS_ERROR_DELDOMAIN_FAILED );
            }
            else
            {   // Delete a user
                variant_t _v(_bstrDomainName);
                hr = spDomains->get_Item( _v, &spDomain );
                if ( S_OK == hr )
                    hr = spDomain->get_Users( &spUsers );
                if ( S_OK == hr )
                {
                    if ( !bDeleteUser )
                        hr = spUsers->Remove( _bstrUserName );
                    else
                        hr = spUsers->RemoveEx( _bstrUserName );
                }
                if ( S_OK == hr )
                    PrintMessage( IDS_SUCCESS_DELMAILBOX );
                else
                    PrintMessage( IDS_ERROR_DELMAILBOX_FAILED );
            }
        }
    }
    
    return hr;
}

int CWinPop3::Get(int argc, wchar_t *argv[])
{
    HRESULT hr;
    long    lValue;
    bool    bPrintValue = true;
    CComPtr<IP3Config> spIConfig;
    CComPtr<IP3Service> spIService;

    if ( 3 != argc )
        return -2;
 
    hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
    if ( S_OK == hr )
    {
        SetMachineName( spIConfig );
        hr = spIConfig->get_Service( &spIService );
    }
    if ( S_OK == hr )
    {
        if ( 0 == _wcsicmp( L"PORT", argv[2] ))
            hr = spIService->get_Port( &lValue );
        else if ( 0 == _wcsicmp( L"LOGGING", argv[2] ))
        {
            hr = spIConfig->get_LoggingLevel( &lValue );
            if ( S_OK == hr )
            {
                WCHAR   sBuffer[MAX_PATH], sBuffer2[MAX_PATH];
                
                bPrintValue = false;
                // 0 None
                if ( !LoadString( NULL, IDS_CMD_LOGNONE, sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR) ))
                    sBuffer2[0] = 0;
                if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L" 0 %s %s", ( 0 == lValue )?L"*":L" ", sBuffer2 ))
                    sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                PrintMessage( sBuffer );
                // 1 Minimum
                if ( !LoadString( NULL, IDS_CMD_LOGMINIMUM, sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR) ))
                    sBuffer2[0] = 0;
                if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L" 1 %s %s", ( 1 == lValue )?L"*":L" ", sBuffer2 ))
                    sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                PrintMessage( sBuffer );
                // 2 Medium
                if ( !LoadString( NULL, IDS_CMD_LOGMEDIUM, sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR) ))
                    sBuffer2[0] = 0;
                if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L" 2 %s %s", ( 2 == lValue )?L"*":L" ", sBuffer2 ))
                    sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                PrintMessage( sBuffer );
                // 3 IDS_CMD_LOGMAXIMUM
                if ( !LoadString( NULL, IDS_CMD_LOGMAXIMUM, sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR) ))
                    sBuffer2[0] = 0;
                if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L" 3 %s %s", ( 2 < lValue )?L"*":L" ", sBuffer2 ))
                    sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                PrintMessage( sBuffer );
            }
        }
        else if ( 0 == _wcsicmp( L"MAILROOT", argv[2] ))
        {
            BSTR bstrMailRoot;
            
            hr = spIConfig->get_MailRoot( &bstrMailRoot );
            if ( S_OK == hr )
            {
                PrintMessage( bstrMailRoot );
                SysFreeString( bstrMailRoot );
            }
            bPrintValue = false;
        }
        else if ( 0 == _wcsicmp( L"SOCKET", argv[2] ))
        {
            argv[2] = L"SOCKETBACKLOG";
            hr = Get( 3, argv );
            argv[2] = L"SOCKETMAX";
            hr = Get( 3, argv );
            argv[2] = L"SOCKETMIN";
            hr = Get( 3, argv );
            hr = spIService->get_SocketsThreshold( &lValue );
        }
        else if ( 0 == _wcsicmp( L"SOCKETMIN", argv[2] ))
            hr = spIService->get_SocketsMin( &lValue );
        else if ( 0 == _wcsicmp( L"SOCKETMAX", argv[2] ))
            hr = spIService->get_SocketsMax( &lValue );
        else if ( 0 == _wcsicmp( L"SOCKETTHRESHOLD", argv[2] ))
            hr = spIService->get_SocketsThreshold( &lValue );
        else if ( 0 == _wcsicmp( L"SOCKETBACKLOG", argv[2] ))
            hr = spIService->get_SocketsBacklog( &lValue );
        else if ( 0 == _wcsicmp( L"SPAREQUIRED", argv[2] ))
        {
            WCHAR   sBuffer[MAX_PATH], sBuffer2[MAX_PATH];
            
            hr = spIService->get_SPARequired( reinterpret_cast<PBOOL>( &lValue ));
            if ( S_OK == hr )
            {
                bPrintValue = false;
                // 0 value
                if ( !LoadString( NULL, IDS_CMD_SPAREQUIRED0, sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR) ))
                    sBuffer2[0] = 0;
                if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L" 0 %s %s", ( 0 == lValue )?L"*":L" ", sBuffer2 ))
                    sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                PrintMessage( sBuffer );
                // 1 value
                if ( !LoadString( NULL, IDS_CMD_SPAREQUIRED1, sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR) ))
                    sBuffer2[0] = 0;
                if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L" 1 %s %s", ( 0 != lValue )?L"*":L" ", sBuffer2 ))
                    sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                PrintMessage( sBuffer );
            }
        }
        else if ( 0 == _wcsicmp( L"THREADCOUNT", argv[2] ))
            hr = spIService->get_ThreadCountPerCPU( &lValue );
        else if (( 0 == _wcsicmp( L"AUTHENTICATION", argv[2] )) || ( 0 == _wcsicmp( L"AUTH", argv[2] )))
        {
            CComPtr<IAuthMethods> spIAuthMethods;
            CComPtr<IAuthMethod> spIAuthMethod;
            BSTR    bstrName;
            _variant_t _v;
            long    lCount;
            WCHAR   sBuffer[MAX_PATH];

            hr = spIConfig->get_Authentication( &spIAuthMethods );
            if ( S_OK == hr )
                hr = spIAuthMethods->get_Count( &lCount );
            if ( S_OK == hr )
                hr = spIAuthMethods->get_CurrentAuthMethod( &_v );
            if ( S_OK == hr )
            {
                lValue = V_I4( &_v );
            }
            else if ( HRESULT_FROM_WIN32(ERROR_DS_AUTH_METHOD_NOT_SUPPORTED) == hr )
            {
                lValue = 0;
                _v = lValue;    // Set the variant type
                hr = S_OK;
            }
            for ( V_I4( &_v ) = 1; (S_OK == hr) && (V_I4( &_v ) <= lCount); V_I4( &_v )++ )
            {
                hr = spIAuthMethods->get_Item( _v, &spIAuthMethod );
                if ( S_OK == hr )
                {
                    hr = spIAuthMethod->get_Name( &bstrName );
                    if ( S_OK == hr )
                    {
                        if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L"%2d %s %s", V_I4( &_v ), ( V_I4( &_v ) == lValue )?L"*":L" ", bstrName ))
                            sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                        PrintMessage( sBuffer );
                        SysFreeString( bstrName );
                    }
                    spIAuthMethod.Release();
                }
            }
            bPrintValue = false;
        }
        else
        {
            hr = -2;
            bPrintValue = false;
        }
    }
    if ( S_OK == hr && bPrintValue )
    {
        WCHAR sBuffer[MAX_PATH];
        
        _itow( lValue, sBuffer, 10 );
        PrintMessage( sBuffer );
    }

    return hr;
}

int CWinPop3::Init(int argc, wchar_t *argv[])
{
    HRESULT hr;
    BOOL    bRegister = TRUE;
    CComPtr<IP3Config> spIConfig;

    if ( 2 != argc && 3 != argc )
        return -1;
    if ( 3 == argc )
    {
        if ( 0 == wcscmp( L"0", argv[2] ))
            bRegister = FALSE;
        else if ( 0 != wcscmp( L"1", argv[2] ))
            return -1;
    }

    hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
    // Set the IIS Meta base settings
    if SUCCEEDED( hr )
        hr = spIConfig->IISConfig( bRegister );

    return hr;
}

int CWinPop3::List(int argc, wchar_t *argv[])
{
    HRESULT hr;
    VARIANT v;
    BSTR    bstrName;
    _bstr_t _bstrDomainName;
    CComPtr<IP3Config> spIConfig;
    CComPtr<IP3Domains> spIDomains;
    CComPtr<IP3Domain> spIDomain = NULL;
    CComPtr<IEnumVARIANT> spIEnumVARIANT;

    if ( 3 != argc && 2 != argc )
        return -1;
    if ( 3 == argc )
        _bstrDomainName = argv[2];
    
    VariantInit( &v );
    hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
    if ( S_OK == hr )
    {
        SetMachineName( spIConfig );
        hr = spIConfig->get_Domains( &spIDomains );
    }
    if ( S_OK == hr )
    {
        if ( 0 == _bstrDomainName.length() )
        {   // List domains
            hr = spIDomains->get__NewEnum( &spIEnumVARIANT );
            if ( S_OK == hr )
            {
                PrintMessage( IDS_CMD_LISTDOMAINS );
                hr = spIEnumVARIANT->Next( 1, &v, NULL );
            }
            while ( S_OK == hr )
            {
                if ( VT_DISPATCH != V_VT( &v ))
                    hr = E_UNEXPECTED;
                else
                {
                    if ( NULL != spIDomain.p )
                        spIDomain.Release();
                    hr = V_DISPATCH( &v )->QueryInterface( __uuidof( IP3Domain ), reinterpret_cast<void**>( &spIDomain ));
                }
                if ( S_OK == hr )
                {
                    hr = spIDomain->get_Name( &bstrName );
                    if ( S_OK == hr )
                    {
                        PrintMessage( bstrName );
                        SysFreeString( bstrName );
                    }
                }
                VariantClear( &v );
                if ( S_OK == hr )
                {
                    hr = spIEnumVARIANT->Next( 1, &v, NULL );
                }
            }
            if ( S_FALSE == hr )
                hr = S_OK;  // Reached end of enumeration
            if ( S_OK == hr )
            {
                long lCount;
                WCHAR sBuffer[MAX_PATH], sBuffer2[MAX_PATH];
                
                hr = spIDomains->get_Count( &lCount );
                if ( S_OK == hr && LoadString( NULL, IDS_CMD_LISTDOMAINSEND, sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR) ))
                {
                    if ( 0 < _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), sBuffer2, lCount ))
                        PrintMessage( sBuffer );
                }
            }
        }
        else
        {   // List users
            CComPtr<IP3Users> spIUsers;
            CComPtr<IP3User> spIUser = NULL;
            _variant_t _v( _bstrDomainName );
            
            hr = spIDomains->get_Item( _v, &spIDomain );
            if ( S_OK == hr )
            {
                hr = spIDomain->get_Users( &spIUsers );
                if ( S_OK == hr )
                {   // List users
                    hr = spIUsers->get__NewEnum( &spIEnumVARIANT );
                    if ( S_OK == hr )
                    {
                        PrintMessage( IDS_CMD_LISTUSERS, false );
                        PrintMessage( _bstrDomainName );
                        PrintMessage( L" " );
                        hr = spIEnumVARIANT->Next( 1, &v, NULL );
                    }
                    while ( S_OK == hr )
                    {
                        if ( VT_DISPATCH != V_VT( &v ))
                            hr = E_UNEXPECTED;
                        else
                        {
                            if ( NULL != spIUser.p )
                                spIUser.Release();
                            hr = V_DISPATCH( &v )->QueryInterface( __uuidof( IP3User ), reinterpret_cast<void**>( &spIUser ));
                        }
                        if ( S_OK == hr )
                        {
                            hr = spIUser->get_Name( &bstrName );
                            if ( S_OK == hr )
                            {
                                PrintMessage( bstrName );
                                SysFreeString( bstrName );
                            }
                        }
                        VariantClear( &v );
                        if ( S_OK == hr )
                        {
                            hr = spIEnumVARIANT->Next( 1, &v, NULL );
                        }
                    }
                    if ( S_FALSE == hr )
                        hr = S_OK;  // Reached end of enumeration
                    if ( S_OK == hr )
                    {
                        long lCount;
                        WCHAR sBuffer[MAX_PATH], sBuffer2[MAX_PATH];
                        
                        hr = spIUsers->get_Count( &lCount );
                        if ( S_OK == hr && LoadString( NULL, IDS_CMD_LISTUSERSEND, sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR) ))
                        {
                            if ( 0 < _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), sBuffer2, lCount ))
                                PrintMessage( sBuffer );
                        }
                    }
                }
            }
        }
    }

    return hr;
}

int CWinPop3::Lock(int argc, wchar_t *argv[], BOOL bLock)
{
    HRESULT hr;
    _bstr_t _bstrDomainName;
    _bstr_t _bstrUserName;
    WCHAR   sBuffer[MAX_PATH*2];
    CComPtr<IP3Config> spIConfig;
    CComPtr<IP3Domains> spIDomains;
    CComPtr<IP3Domain> spIDomain;
    CComPtr<IEnumVARIANT> spIEnumVARIANT;

    if ( 3 != argc )
        return -1;
    if ( (sizeof(sBuffer)/sizeof(WCHAR)) < (wcslen( argv[2] ) + 1) )
        return E_INVALIDARG;

    sBuffer[(sizeof(sBuffer)/sizeof(WCHAR))-1] = 0;
    wcsncpy( sBuffer, argv[2], (sizeof(sBuffer)/sizeof(WCHAR))-1 );
    WCHAR *ps = wcsrchr( sBuffer, L'@' );
    if ( NULL == ps )
    {
        _bstrDomainName = sBuffer;
    }
    else
    {
        *ps = 0x0;
        _bstrUserName = sBuffer;
        if ( 0 == _bstrUserName.length() )
            return E_INVALIDARG;
        ps++;
        if ( NULL != *ps )
            _bstrDomainName = ps;
        else
            return E_INVALIDARG;
    }
    
    hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
    if ( S_OK == hr )
    {
        SetMachineName( spIConfig );
        hr = spIConfig->get_Domains( &spIDomains );
    }
    if ( S_OK == hr )
    {
        _variant_t _v( _bstrDomainName );
        
        hr = spIDomains->get_Item( _v, &spIDomain );
        if ( S_OK == hr )
        {
            if ( 0 == _bstrUserName.length() )
            {
                hr = spIDomain->put_Lock( bLock );   // Lock the domain
                if ( S_OK == hr )
                {
                    if ( bLock )
                        PrintMessage( IDS_SUCCESS_LOCKDOMAIN );
                    else
                        PrintMessage( IDS_SUCCESS_UNLOCKDOMAIN );
                }
                else
                {
                    if ( bLock )
                    {
                        if ( HRESULT_FROM_WIN32( ERROR_LOCKED ) == hr )
                        {
                            PrintMessage( IDS_ERROR_LOCKDOMAIN_ALREADYLOCKED );
                            m_bSuppressPrintError = true;
                        }
                        else 
                            PrintMessage( IDS_ERROR_LOCKDOMAIN_FAILED );
                    }
                    else
                    {
                        if ( HRESULT_FROM_WIN32( ERROR_NOT_LOCKED ) == hr )
                        {
                            PrintMessage( IDS_ERROR_UNLOCKDOMAIN_ALREADYUNLOCKED );
                            m_bSuppressPrintError = true;
                        }
                        else 
                            PrintMessage( IDS_ERROR_UNLOCKDOMAIN_FAILED );
                    }                        
                }
            }
            else
            {   // Lock user
                CComPtr<IP3Users> spIUsers;
                CComPtr<IP3User> spIUser;
                
                hr = spIDomain->get_Users( &spIUsers );
                if ( S_OK == hr )
                {   // List users
                    _v = _bstrUserName;
                    hr = spIUsers->get_Item( _v, &spIUser );
                    if ( S_OK == hr )
                        hr = spIUser->put_Lock( bLock );
                }
                if ( S_OK == hr )
                {
                    if ( bLock )
                        PrintMessage( IDS_SUCCESS_LOCKMAILBOX );
                    else
                        PrintMessage( IDS_SUCCESS_UNLOCKMAILBOX );
                }
                else
                {
                    if ( bLock )
                    {
                        if ( HRESULT_FROM_WIN32( ERROR_LOCKED ) == hr )
                        {
                            PrintMessage( IDS_ERROR_LOCKMAILBOX_ALREADYLOCKED );
                            m_bSuppressPrintError = true;
                        }
                        else 
                            PrintMessage( IDS_ERROR_LOCKMAILBOX_FAILED );
                    }
                    else
                    {
                        if ( HRESULT_FROM_WIN32( ERROR_NOT_LOCKED ) == hr )
                        {
                            PrintMessage( IDS_ERROR_UNLOCKMAILBOX_ALREADYUNLOCKED );
                            m_bSuppressPrintError = true;
                        }
                        else 
                            PrintMessage( IDS_ERROR_UNLOCKMAILBOX_FAILED );
                    }                        
                }
            }
        }
    }

    return hr;
}

int CWinPop3::Net(int argc, wchar_t *argv[])
{
    HRESULT hr;
    CComPtr<IP3Config> spIConfig;
    CComPtr<IP3Service> spIService;

    if ( (4 != argc) )
        return -1;
    
    hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_INPROC_SERVER, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
    if ( S_OK == hr )
    {
        SetMachineName( spIConfig );        
        hr = spIConfig->get_Service( &spIService );
    }
    if ( S_OK == hr )
    {
        if ( 0 == _wcsicmp( L"START", argv[2] ))
        {
            if ( 0 == _wcsicmp( IISADMIN_SERVICE_NAME, argv[3] ))
                hr = spIService->StartIISAdminService();
            else if ( 0 == _wcsicmp( POP3_SERVICE_NAME, argv[3] ))
                hr = spIService->StartPOP3Service();
            else if ( 0 == _wcsicmp( SMTP_SERVICE_NAME, argv[3] ))
                hr = spIService->StartSMTPService();
            else if ( 0 == _wcsicmp( W3_SERVICE_NAME, argv[3] ))
                hr = spIService->StartW3Service();
            else
                hr = -1;
        }
        else if ( 0 == _wcsicmp( L"STOP", argv[2] ))
        {
            if ( 0 == _wcsicmp( IISADMIN_SERVICE_NAME, argv[3] ))
                hr = spIService->StopIISAdminService();
            else if ( 0 == _wcsicmp( POP3_SERVICE_NAME, argv[3] ))
                hr = spIService->StopPOP3Service();
            else if ( 0 == _wcsicmp( SMTP_SERVICE_NAME, argv[3] ))
                hr = spIService->StopSMTPService();
            else if ( 0 == _wcsicmp( W3_SERVICE_NAME, argv[3] ))
                hr = spIService->StopW3Service();
            else
                hr = -1;
        }
        else if ( 0 == _wcsicmp( L"STATUS", argv[2] ))
        {
            long lStatus;
            
            if ( 0 == _wcsicmp( IISADMIN_SERVICE_NAME, argv[3] ))
                hr = spIService->get_IISAdminServiceStatus( &lStatus );
            else if ( 0 == _wcsicmp( POP3_SERVICE_NAME, argv[3] ))
                hr = spIService->get_POP3ServiceStatus( &lStatus );
            else if ( 0 == _wcsicmp( SMTP_SERVICE_NAME, argv[3] ))
                hr = spIService->get_SMTPServiceStatus( &lStatus );
            else if ( 0 == _wcsicmp( W3_SERVICE_NAME, argv[3] ))
                hr = spIService->get_W3ServiceStatus( &lStatus );
            else
                hr = -1;
            if ( S_OK == hr )
                PrintMessage( IDS_SERVICESTATUS_DESCRIPTIONS + lStatus );
        }
        else if ( 0 == _wcsicmp( L"PAUSE", argv[2] ))
        {
            if ( 0 == _wcsicmp( IISADMIN_SERVICE_NAME, argv[3] ))
                hr = spIService->PauseIISAdminService();
            else if ( 0 == _wcsicmp( POP3_SERVICE_NAME, argv[3] ))
                hr = spIService->PausePOP3Service();
            else if ( 0 == _wcsicmp( SMTP_SERVICE_NAME, argv[3] ))
                hr = spIService->PauseSMTPService();
            else if ( 0 == _wcsicmp( W3_SERVICE_NAME, argv[3] ))
                hr = spIService->PauseW3Service();
            else
                hr = -1;
        }
        else if ( 0 == _wcsicmp( L"RESUME", argv[2] ))
        {
            if ( 0 == _wcsicmp( IISADMIN_SERVICE_NAME, argv[3] ))
                hr = spIService->ResumeIISAdminService();
            else if ( 0 == _wcsicmp( POP3_SERVICE_NAME, argv[3] ))
                hr = spIService->ResumePOP3Service();
            else if ( 0 == _wcsicmp( SMTP_SERVICE_NAME, argv[3] ))
                hr = spIService->ResumeSMTPService();
            else if ( 0 == _wcsicmp( W3_SERVICE_NAME, argv[3] ))
                hr = spIService->ResumeW3Service();
            else
                hr = -1;
        }
        else
            hr = -1;
    }

    return hr;
}

#define RESTART_POP3SVC         1
#define RESTART_POP3SVC_SMTP    2

int CWinPop3::Set(int argc, wchar_t *argv[])
{
    HRESULT hr;
    long    lValue;
    int     iServiceRestart = 0;
    CComPtr<IP3Config> spIConfig;
    CComPtr<IP3Service> spIService;

    if ( (4 != argc) && (7 != argc ))
        return -2;
    if ( 0 == _wcsicmp( L"SOCKET", argv[2] ))
    {
        if ( 7 != argc ) return -2;
        if ( ! ( StrIsDigit( argv[3] ) && StrIsDigit( argv[4] ) && StrIsDigit( argv[5] ) && StrIsDigit( argv[6] )))
            return E_INVALIDARG;
    }

    if ( 0 != _wcsicmp( L"MAILROOT", argv[2] ) && !StrIsDigit( argv[3] ))
        return E_INVALIDARG;
    
    lValue = _wtol( argv[3] );
    hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_INPROC_SERVER, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
    if ( S_OK == hr )
    {
        SetMachineName( spIConfig );
        hr = spIConfig->get_Service( &spIService );
    }
    if ( S_OK == hr )
    {
        if ( 0 == _wcsicmp( L"PORT", argv[2] ))
        {
            hr = spIService->put_Port( lValue );
            iServiceRestart = RESTART_POP3SVC;
        }
        else if ( 0 == _wcsicmp( L"LOGGING", argv[2] ))
        {
            hr = spIConfig->put_LoggingLevel( lValue );
            iServiceRestart = RESTART_POP3SVC_SMTP;
        }
        else if ( 0 == _wcsicmp( L"MAILROOT", argv[2] ))
        {
            _bstr_t _bstrMailRoot = argv[3];
            
            HRESULT hr2;
            long    lCount;
            CComPtr<IP3Domains> spIDomains;
            
            hr2 = spIConfig->get_Domains( &spIDomains );
            if ( S_OK == hr2 )
                hr2 = spIDomains->get_Count( &lCount );
            
            hr = spIConfig->put_MailRoot( _bstrMailRoot );
            if ( S_OK == hr )
            {
                PrintMessage( IDS_SUCCESS_SETMAILROOT );
                PrintMessage( IDS_MESSAGE_POP3SVC_STMP_RESTART );
                if ( S_OK == hr2 && 0 < lCount )
                {
                    PrintMessage( IDS_WARNING_SETMAILROOT );
                }
            }
        }
        else if ( 0 == _wcsicmp( L"SOCKET", argv[2] ) && (7 == argc) )
        {
            long lBacklog, lMax, lMin, lThreshold;

            lBacklog = lValue;
            lMax = _wtol( argv[4] );
            lMin = _wtol( argv[5] );
            lThreshold = _wtol( argv[6] );
            hr = spIService->SetSockets( lMax, lMin, lThreshold, lBacklog);
            iServiceRestart = RESTART_POP3SVC;
        }
        else if ( 0 == _wcsnicmp( L"SOCKET", argv[2], 6 ))
        {
            long lBacklog, lMax, lMin, lThreshold;
            
            hr = spIService->get_SocketsMin( &lMin );
            if ( S_OK == hr )
                hr = spIService->get_SocketsMax( &lMax );
            if ( S_OK == hr )
                hr = spIService->get_SocketsThreshold( &lThreshold );
            if ( S_OK == hr )
                hr = spIService->get_SocketsBacklog( &lBacklog );
            if ( S_OK == hr )
            {
                if ( 0 == _wcsicmp( L"SOCKETMIN", argv[2] ))
                    hr = spIService->SetSockets( lMax, lValue, lThreshold, lBacklog );
                else if ( 0 == _wcsicmp( L"SOCKETMAX", argv[2] ))
                    hr = spIService->SetSockets( lValue, lMin, lThreshold, lBacklog );
                else if ( 0 == _wcsicmp( L"SOCKETTHRESHOLD", argv[2] ))
                    hr = spIService->SetSockets( lMax, lMin, lValue, lBacklog );
                else if ( 0 == _wcsicmp( L"SOCKETBACKLOG", argv[2] ))
                    hr = spIService->SetSockets( lMax, lMin, lThreshold, lValue );
                else
                    hr = -2;
            }
            iServiceRestart = RESTART_POP3SVC;
        }
        else if ( 0 == _wcsicmp( L"SPAREQUIRED", argv[2] ))
        {
            hr = spIService->put_SPARequired( lValue );
            iServiceRestart = RESTART_POP3SVC;
        }
        else if ( 0 == _wcsicmp( L"THREADCOUNT", argv[2] ))
        {
            hr = spIService->put_ThreadCountPerCPU( lValue );
            iServiceRestart = RESTART_POP3SVC;
        }
        else if (( 0 == _wcsicmp( L"AUTHENTICATION", argv[2] )) || ( 0 == _wcsicmp( L"AUTH", argv[2] )))
        {
            CComPtr<IAuthMethods> spIAuthMethods;
            CComPtr<IAuthMethod> spIAuthMethod;
            BSTR    bstrName;
            _variant_t _v;
            WCHAR   sBuffer[MAX_PATH];

            V_VT( &_v ) = VT_I4;
            V_I4( &_v ) = lValue;
            hr = spIConfig->get_Authentication( &spIAuthMethods );
            if ( S_OK == hr )
            {
                hr = spIAuthMethods->put_CurrentAuthMethod( _v );
                if ( STG_E_ACCESSDENIED == hr )
                {
                    PrintMessage( IDS_ERROR_SETAUTH_FAILED );
                    m_bSuppressPrintError = true;
                }
            }
            if ( S_OK == hr )
                hr = spIAuthMethods->Save();
            if ( S_OK == hr )
            {
                _v.Clear();
                hr = spIAuthMethods->get_CurrentAuthMethod( &_v );
            }
            if ( S_OK == hr )
                hr = spIAuthMethods->get_Item( _v, &spIAuthMethod );
            if ( S_OK == hr )
            {
                hr = spIAuthMethod->get_Name( &bstrName );
                if ( S_OK == hr )
                {
                    if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L"%2d %s %s", V_I4( &_v ), ( V_I4( &_v ) == lValue )?L"*":L" ", bstrName ))
                        sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                    PrintMessage( sBuffer );
                    SysFreeString( bstrName );
                }
            }
        }
        else
            hr = -2;
    }
    if ( S_OK == hr )
    {
        if ( RESTART_POP3SVC == iServiceRestart )
            PrintMessage( IDS_MESSAGE_POP3SVC_RESTART );
        if ( RESTART_POP3SVC_SMTP == iServiceRestart )
            PrintMessage( IDS_MESSAGE_POP3SVC_STMP_RESTART );
    }

    return hr;
}

int CWinPop3::SetPassword(int argc, wchar_t *argv[])
{
    HRESULT hr;
    _bstr_t _bstrAccount;
    _variant_t _vNewPassword, _vOldPassword;
    CComPtr<IP3Config> spIConfig;
    CComPtr<IP3Service> spIService;

    if ( 4 != argc )
        return -1;

    _bstrAccount = argv[2];
    hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_INPROC_SERVER, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
    // Validate this mailbox before we do anything else
    if ( S_OK == hr )
    {
        _bstr_t _bstrDomainName;
        _bstr_t _bstrUserName;
        WCHAR   sBuffer[MAX_PATH*2];
        CComPtr<IP3Domains> spDomains;
        CComPtr<IP3Domain> spDomain;
        CComPtr<IP3Users> spUsers;
        CComPtr<IP3User> spUser;

        sBuffer[(sizeof(sBuffer)/sizeof(WCHAR))-1] = 0;
        wcsncpy( sBuffer, argv[2], (sizeof(sBuffer)/sizeof(WCHAR))-1 );
        WCHAR *ps = wcsrchr( sBuffer, L'@' );
        if ( NULL == ps )
            hr = E_INVALIDARG;
        else
        {
            *ps = 0x0;
            _bstrUserName = sBuffer;
            if ( 0 == _bstrUserName.length() )
                return E_INVALIDARG;
            ps++;
            if ( NULL != *ps )
                _bstrDomainName = ps;
            else
                return E_INVALIDARG;
        }
        if ( S_OK == hr )
        {   // Check password for DBCS characters
            WCHAR   *ps = argv[3];
            BOOL    bDBCS = false;
            
            while ( !bDBCS && 0x0 != *ps )
            {
                bDBCS = (256 < *ps);
                ps++;
            }
            if ( bDBCS )
                hr = E_INVALIDARG;
        }
        if ( S_OK == hr )
        {
            hr = spIConfig->get_Domains( &spDomains );
            if ( S_OK == hr )
            {
                _variant_t _v( _bstrDomainName );
                hr = spDomains->get_Item( _v, &spDomain );
                if ( S_OK == hr )
                    hr = spDomain->get_Users( &spUsers );
                if ( S_OK == hr )
                {
                    _v = _bstrUserName;
                    hr = spUsers->get_Item( _v, &spUser );
                }
            }
        }
    }
    
    _vNewPassword = argv[3];
    V_VT( &_vOldPassword ) = VT_BSTR;
    V_BSTR( &_vOldPassword ) = NULL;
    if ( S_OK == hr )
    {
        CComPtr<IAuthMethods> spIAuthMethods;
        CComPtr<IAuthMethod> spIAuthMethod;
        _variant_t _v;

        hr = spIConfig->get_Authentication( &spIAuthMethods );
        if ( S_OK == hr )
            hr = spIAuthMethods->get_CurrentAuthMethod( &_v );
        if ( S_OK == hr )
            hr = spIAuthMethods->get_Item( _v, &spIAuthMethod );
        if ( S_OK == hr )
            hr = spIAuthMethod->ChangePassword( _bstrAccount, _vNewPassword, _vOldPassword );
    }
    if ( S_OK != hr )
        PrintMessage( IDS_ERROR_SETPASSWORD_FAILED );
    
    return hr;
}

int CWinPop3::Stat(int argc, wchar_t *argv[])
{
    HRESULT hr;
    _bstr_t _bstrDomainName;
    CComPtr<IP3Config> spIConfig;
    CComPtr<IP3Domains> spIDomains;
    CComPtr<IP3Domain> spIDomain = NULL;
    CComPtr<IP3Users> spIUsers;
    CComPtr<IEnumVARIANT> spIEnumVARIANT;
    VARIANT v;
    BOOL    bIsLocked;
    BSTR    bstrName;
    WCHAR   sBuffer[MAX_PATH*2];
    WCHAR   sLocked[MAX_PATH];
    long    lCount, lDiskUsage, lFactor, lMailboxes;
    __int64 i64DiskUsage, i64Factor, i64Mailboxes, i64Messages;

    if ( 3 != argc && 2 != argc )
        return -1;
    if ( 3 == argc )
        _bstrDomainName = argv[2];
    

    i64DiskUsage = i64Factor = i64Mailboxes = i64Messages = 0;
    if ( 0 == LoadString( NULL, IDS_LOCKED, sLocked, sizeof( sLocked )/sizeof(WCHAR) ))
        wcscpy( sLocked, L"L" );
    VariantInit( &v );
    hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
    if ( S_OK == hr )
    {
        SetMachineName( spIConfig );
        hr = spIConfig->get_Domains( &spIDomains );
    }
    if ( S_OK == hr )
    {
        if ( 0 == _bstrDomainName.length() )
        {   // List domains
            hr = spIDomains->get__NewEnum( &spIEnumVARIANT );
            if ( S_OK == hr )
            {   // Headings
                WCHAR sBuffer2[128], sBuffer3[128], sBuffer4[128], sBuffer5[128];
                
                if ( LoadString( NULL, IDS_CMD_STATDOMAINSMAILBOXES, sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR) ) &&
                     LoadString( NULL, IDS_CMD_STATDOMAINSDISKUSAGE, sBuffer3, sizeof( sBuffer3 )/sizeof(WCHAR) ) &&
                     LoadString( NULL, IDS_CMD_STATDOMAINSMESSAGES, sBuffer4, sizeof( sBuffer4 )/sizeof(WCHAR) ) &&
                     LoadString( NULL, IDS_CMD_STATDOMAINS, sBuffer5, sizeof( sBuffer5 )/sizeof(WCHAR) )
                   )
                {
                    if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L"\n %s\n\n%10s %10s %10s", sBuffer5, sBuffer2, sBuffer3, sBuffer4 ))
                        sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                    PrintMessage( sBuffer );
                }
                else
                    PrintMessage( IDS_CMD_STATDOMAINS );
                hr = spIEnumVARIANT->Next( 1, &v, NULL );
            }
            while ( S_OK == hr )
            {
                if ( VT_DISPATCH != V_VT( &v ))
                    hr = E_UNEXPECTED;
                else
                {
                    if ( NULL != spIDomain.p )
                        spIDomain.Release();
                    hr = V_DISPATCH( &v )->QueryInterface( __uuidof( IP3Domain ), reinterpret_cast<void**>( &spIDomain ));
                }
                VariantClear( &v );
                if ( S_OK == hr )
                {   // Name
                    hr = spIDomain->get_Name( &bstrName );
                    if ( S_OK == hr )
                    {   // Mailboxes
                        hr = spIDomain->get_Users( &spIUsers );
                        if ( S_OK == hr )
                            hr = spIUsers->get_Count( &lMailboxes );
                        // Lock Status
                        if ( S_OK == hr )
                            hr = spIDomain->get_Lock( &bIsLocked );
                        // MessageDiskUsage
                        if ( S_OK == hr )
                            hr = spIDomain->get_MessageDiskUsage( &lFactor, &lDiskUsage );
                        // MessageCount
                        if ( S_OK == hr )
                            hr = spIDomain->get_MessageCount( &lCount );
                        if ( S_OK == hr )
                        {   // Got everything
                            i64Mailboxes += lMailboxes;
                            i64DiskUsage += lFactor * lDiskUsage;
                            i64Messages += lCount;
                            if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L"%10d %10d %10d %15s %s", lMailboxes, lFactor * lDiskUsage, lCount, (bIsLocked)?sLocked:L" ", bstrName ))
                                sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                            PrintMessage( sBuffer );
                        }
                        else
                        {   // Got the domain name, had problem somewhere else, let's just list the domain name
                            if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L"%10s %10s %10s %15s %s", L" ", L" ", L" ", L" ", bstrName ))
                                sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                            PrintMessage( sBuffer );
                            hr = S_OK;
                        }
                        SysFreeString( bstrName );
                    }
                }
                if ( S_OK == hr )
                    hr = spIEnumVARIANT->Next( 1, &v, NULL );
            }
            if ( S_FALSE == hr )
                hr = S_OK;  // Reached end of enumeration
            if ( S_OK == hr )
            {
                long lCount;
                WCHAR sBuffer2[MAX_PATH];
                
                hr = spIDomains->get_Count( &lCount );
                if ( S_OK == hr && LoadString( NULL, IDS_CMD_LISTDOMAINSEND, sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR) ))
                {
                    if ( 0 < _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), sBuffer2 + 1, lCount ))
                    {
                        wcsncpy( sBuffer2, sBuffer, sizeof( sBuffer2 )/sizeof(WCHAR) );
                        sBuffer2[(sizeof(sBuffer2)/sizeof(WCHAR))-1] = 0;
                        if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L"\n%10I64d %10I64d %10I64d %14s %s ", i64Mailboxes, i64DiskUsage, i64Messages, L" ", sBuffer2 ))
                            sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                        PrintMessage( sBuffer );
                    }
                }
            }
        }
        else
        {   // List users
            CComPtr<IP3Users> spIUsers;
            CComPtr<IP3User> spIUser = NULL;
            _variant_t _v( _bstrDomainName );
            
            hr = spIDomains->get_Item( _v, &spIDomain );
            if ( S_OK == hr )
            {
                hr = spIDomain->get_Users( &spIUsers );
                if ( S_OK == hr )
                {   // List users
                    hr = spIUsers->get__NewEnum( &spIEnumVARIANT );
                    if ( S_OK == hr )
                    {   // Headings
                        WCHAR sBuffer2[128], sBuffer3[128], sBuffer4[128];
                        
                        if ( LoadString( NULL, IDS_CMD_STATUSERSDISKUSAGE, sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR) ) &&
                             LoadString( NULL, IDS_CMD_STATUSERSMESSAGES, sBuffer3, sizeof( sBuffer3 )/sizeof(WCHAR) ) &&
                             LoadString( NULL, IDS_CMD_STATUSERS, sBuffer4, sizeof( sBuffer4 )/sizeof(WCHAR) )
                           )
                        {
                            if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L"\n %s%s\n\n %10s %10s", sBuffer4, static_cast<LPWSTR>( _bstrDomainName ), sBuffer2, sBuffer3 ))
                                sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                            PrintMessage( sBuffer );
                        }
                        else
                            PrintMessage( IDS_CMD_STATUSERS );
                        hr = spIEnumVARIANT->Next( 1, &v, NULL );
                    }
                    while ( S_OK == hr )
                    {
                        if ( VT_DISPATCH != V_VT( &v ))
                            hr = E_UNEXPECTED;
                        else
                        {
                            if ( NULL != spIUser.p )
                                spIUser.Release();
                            hr = V_DISPATCH( &v )->QueryInterface( __uuidof( IP3User ), reinterpret_cast<void**>( &spIUser ));
                        }
                        if ( S_OK == hr )
                        {
                            hr = spIUser->get_Name( &bstrName );
                            if ( S_OK == hr )
                            {   // Lock Status
                                hr = spIUser->get_Lock( &bIsLocked );
                                // MessageDiskUsage
                                if ( S_OK == hr )
                                    hr = spIUser->get_MessageDiskUsage( &lFactor, &lDiskUsage );
                                // MessageCount
                                if ( S_OK == hr )
                                    hr = spIUser->get_MessageCount( &lCount );
                                if ( S_OK == hr )
                                {   // Got everything
                                    i64DiskUsage += lFactor * lDiskUsage;
                                    i64Messages += lCount;
                                    if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L"%10d %10d %15s %s", lFactor * lDiskUsage, lCount, (bIsLocked)?sLocked:L" ", bstrName ))
                                        sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                                    PrintMessage( sBuffer );
                                }
                                else
                                {   // Got the domain name, had problem somewhere else, let's just list the domain name
                                    if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L"%10s %10s %15s %s", L" ", L" ", L" ", bstrName ))
                                        sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                                    PrintMessage( sBuffer );
                                    hr = S_OK;
                                }
                                SysFreeString( bstrName );
                            }
                        }
                        VariantClear( &v );
                        if ( S_OK == hr )
                            hr = spIEnumVARIANT->Next( 1, &v, NULL );
                    }
                    if ( S_FALSE == hr )
                        hr = S_OK;  // Reached end of enumeration
                    if ( S_OK == hr )
                    {
                        long lCount;
                        WCHAR sBuffer2[MAX_PATH];
                        
                        hr = spIUsers->get_Count( &lCount );
                        if ( S_OK == hr && LoadString( NULL, IDS_CMD_LISTUSERSEND, sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR) ))
                        {
                            if ( 0 < _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), sBuffer2 + 1, lCount ))
                            {
                                wcsncpy( sBuffer2, sBuffer, sizeof( sBuffer2 )/sizeof(WCHAR) );
                                sBuffer2[(sizeof(sBuffer2)/sizeof(WCHAR))-1] = 0;
                                if ( 0 > _snwprintf( sBuffer, sizeof( sBuffer )/sizeof(WCHAR), L"\n%10I64d %10I64d %14s %s ", i64DiskUsage, i64Messages, L" ", sBuffer2 ))
                                    sBuffer[(sizeof( sBuffer )/sizeof(WCHAR))-1] = 0;
                                PrintMessage( sBuffer );
                            }
                        }
                    }
                }
            }
        }
    }

    return hr;
}

void CWinPop3::PrintError( int iRC )
{
    if ( m_bSuppressPrintError || (E_FAIL == iRC) )
    {
        m_bSuppressPrintError = false;
        return;
    }
    LPVOID lpMsgBuf;

    if ( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, iRC, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), reinterpret_cast<LPWSTR>( &lpMsgBuf ), 0, NULL ))
    {
        wprintf( reinterpret_cast<LPWSTR>( lpMsgBuf ) ); 
        LocalFree( lpMsgBuf );
    }
    else
    {
        WCHAR sBuffer[32];
        
        PrintMessage( IDS_ERROR_UNKNOWN );
        wsprintf( sBuffer, L"%x", iRC );
        PrintMessage( sBuffer );
    }
}
void CWinPop3::PrintMessage( LPWSTR psMessage, bool bCRLF /*= true*/ )
{
    wprintf( psMessage ); 
    if ( bCRLF )
        wprintf( L"\r\n" ); 
}

void CWinPop3::PrintMessage( int iID, bool bCRLF /*= true*/ )
{
    WCHAR sBuffer[512];
    
    if ( LoadString( NULL, iID, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) ))
        PrintMessage( sBuffer, bCRLF );
    else
        assert( false );
}
    
void CWinPop3::PrintUsage()
{
    WCHAR sBuffer[512];

    for ( int i = IDS_WINPOP_USAGE1; i < IDS_WINPOP_USAGEEND; i++ )
    {
        if ( LoadString( NULL, i, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) ))
        {
            if ( IDS_WINPOP_USAGE2 == i )
            {
                WCHAR sBuffer2[512];
                
                if ( 0 > _snwprintf( sBuffer2, sizeof( sBuffer2 )/sizeof(WCHAR), sBuffer, POP3_SERVER_NAME_L ))
                    sBuffer2[(sizeof( sBuffer2 )/sizeof(WCHAR))-1] = 0;
                wcscpy( sBuffer, sBuffer2 );
            }
            wprintf( sBuffer );
        }
    }
}

void CWinPop3::PrintUsageGetSet()
{
    WCHAR sBuffer[512];

    for ( int i = IDS_WINPOP_GETSET1; i < IDS_WINPOP_GETSETEND; i++ )
    {
        if ( LoadString( NULL, i, sBuffer, sizeof( sBuffer )/sizeof(WCHAR) ))
        {
            wprintf( sBuffer );
        }
    }
}

//////////////////////////////////////////////////////////////////////
// Implementation : protected
//////////////////////////////////////////////////////////////////////

void CWinPop3::SetMachineName( IP3Config *pIConfig )
{
    if ( NULL == pIConfig )
        return;

    HRESULT hr;    
    HKEY    hKey;
    DWORD   dwType = REG_SZ;
    long    lRC;
    WCHAR   sBuffer[MAX_PATH];
    DWORD   dwSize = MAX_PATH;
    _bstr_t _bstrMachineName;

    lRC = RegOpenKeyEx( HKEY_LOCAL_MACHINE, POP3SERVER_SOFTWARE_SUBKEY, 0, KEY_QUERY_VALUE, &hKey );
    if ( ERROR_SUCCESS == lRC )
    {
        lRC = RegQueryValueEx( hKey, L"WinpopRemoteAdmin", 0, &dwType, reinterpret_cast<LPBYTE>( sBuffer ), &dwSize );
        RegCloseKey( hKey );
    }
    if ( ERROR_SUCCESS == lRC )
    {
        _bstrMachineName = sBuffer;
        hr = pIConfig->put_MachineName( _bstrMachineName );
    }
}

bool CWinPop3::StrIsDigit( LPWSTR ps )
{
    if ( NULL == ps )
        return false;

    bool bRC = true;
    
    while ( bRC && 0 != *ps )
    {
        bRC = iswdigit( *ps ) ? true : false;
        ps++;
    }
    
    return bRC;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\inc\checkuser.h ===
//-----------------------------------------------------------------------------
// checkuser.h
//-----------------------------------------------------------------------------

#ifndef _CHECKUSER_H
#define _CHECKUSER_H


HRESULT _CheckSIDInProcess( SID* pSID )
{
	if( !pSID )
	{
		return E_POINTER;
	}

	BOOL bRet = FALSE;
	if( !CheckTokenMembership(NULL, pSID, &bRet) )
	{
		return HRESULT_FROM_WIN32( GetLastError() );
	}

	return bRet ? S_OK : S_FALSE;
}

HRESULT IsUserInGroup( DWORD dwRID )
{
    PSID psid = NULL;
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    BOOL bRet = AllocateAndInitializeSid( &sia,
										  2,
										  SECURITY_BUILTIN_DOMAIN_RID,
										  dwRID,
										  0, 0, 0, 0, 0, 0,
										  &psid);
	if( !bRet  )
	{
		return HRESULT_FROM_WIN32( GetLastError() );
	}
	else if( !psid )
	{
		return E_FAIL;
	}
	
	HRESULT hr = _CheckSIDInProcess( (SID*)psid );
	FreeSid( psid );
	return hr;
}

HRESULT IsUserInGroup( const TCHAR* pszGroup )
{
	if( !pszGroup )
	{
		return E_POINTER;
	}

	HRESULT hr = S_FALSE;
	DWORD dwSize = 0;
	DWORD dwDomainSize = 0;
	SID_NAME_USE snu;
	if( !LookupAccountName(NULL, pszGroup, NULL, &dwSize, NULL, &dwDomainSize, &snu) &&
		GetLastError() == ERROR_INSUFFICIENT_BUFFER )
	{
		SID* psid = (SID*)new BYTE[dwSize];
		if( !psid )
		{
			return E_OUTOFMEMORY;
		}

		TCHAR* pszDomain = new TCHAR[dwDomainSize];
		if( !pszDomain )
		{
			delete[] psid;
			return E_OUTOFMEMORY;
		}

		if( LookupAccountName(NULL, pszGroup, psid, &dwSize, pszDomain, &dwDomainSize, &snu) )
		{
			hr = _CheckSIDInProcess( psid );
		}
		else
		{
			hr = HRESULT_FROM_WIN32( GetLastError() );
		}

		delete[] psid;
		delete[] pszDomain;
	}
	else
	{
		return E_FAIL;
	}

	return hr;
}


#endif	// _CHECKUSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\inc\imfutil.h ===
// CIMFUtil.h : Declaration of the CIMFUtil class

#ifndef __CIMFUTIL_H_
#define __CIMFUTIL_H_

class CIMFUtil
{

public:
    /************************************************************************************************
    Member:         CIMFUtil::SystemTimeToIMFDate, protected
    Synopsis:       Converts a SYSTEMTIME to a string conforming to the IMF format (RFC 822).
                    Used by the AddReceivedHeader function.
    Arguments:      [in] pst - SYSTEMTIME to be analyzed.
                    [out] lpszIMFDate - string that will receive the date in the IMF-required format.
    Notes:          1. Adapted from the original POP3 code by Virtual Motion (general.cpp).
                    2. Result stays ANSI (single byte). The IMF date is a 7-bit string for header.
    History:        03/08/2001 - created, Luciano Passuello (lucianop).
    ************************************************************************************************/
    static void SystemTimeToIMFDate(SYSTEMTIME* pst, LPSTR lpszIMFDate)
    {
        static const LPCSTR rgszMonthsOfTheYear[] =
        {
            "Jan", "Feb", "Mar", "Apr", "May", "Jun",
            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", 
            NULL
        };

        static const LPCSTR rgszDaysOfTheWeek[] =
        {
            "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", NULL
        };

        TIME_ZONE_INFORMATION tzi;
        long ltzBias = 0;
        DWORD dwTimeZoneId = GetTimeZoneInformation (&tzi);
    
        switch (dwTimeZoneId)
        {
            case TIME_ZONE_ID_DAYLIGHT:
                ltzBias = tzi.Bias + tzi.DaylightBias;
                break;
            case TIME_ZONE_ID_STANDARD:
            case TIME_ZONE_ID_UNKNOWN:
            default:
                ltzBias = tzi.Bias + tzi.StandardBias;
                break;
        }
    
        long ltzHour = ltzBias / 60;
        long ltzMinute = ltzBias % 60;
        char cDiff = (ltzHour < 0) ? '+' : '-';
        assert((pst->wMonth - 1) >= 0);
    
        // puts everything together
        sprintf(lpszIMFDate,
                 "%3s, %d %3s %4d %02d:%02d:%02d %c%02d%02d",  // "ddd, dd mmm yyyy hh:mm:ss +/- hhmm\0"
                 rgszDaysOfTheWeek[pst->wDayOfWeek],           // "ddd"
                 pst->wDay,                                    // "dd"
                 rgszMonthsOfTheYear[pst->wMonth - 1],         // "mmm"
                 pst->wYear,                                   // "yyyy"
                 pst->wHour,                                   // "hh"
                 pst->wMinute,                                 // "mm"
                 pst->wSecond,                                 // "ss"
                 cDiff,                                        // "+" / "-"
                 abs(ltzHour),                                 // "hh"
                 abs(ltzMinute));                              // "mm"
    }
};

#endif //__CIMFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\inc\isexchng.h ===
#ifndef _ISEXCHNG_H
#define _ISEXCHNG_H

inline BOOL _IsExchangeInstalled()  // cloned in/from icw.cpp
{   // according to Chandramouli Venkatesh:
/*
look for a non-empty string pointing to a valid install dir under
\HKLM\Software\Microsoft\Exchange\Setup\Services

to distinguish PT from 5.5, look under
\HKLM\Software\Microsoft\Exchange\Setup\newestBuildKey
this has the build #.
*/
    BOOL b = FALSE;

    HKEY hk;
    HRESULT hr = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                               L"Software\\Microsoft\\Exchange\\Setup",
                               0, KEY_READ, &hk);
    if (hr == S_OK) {
        WCHAR szPath[MAX_PATH];
        szPath[0] = 0;
        DWORD dwType, dwSize = sizeof(szPath);
        hr = RegQueryValueEx (hk,               // key
                              L"Services",
                              NULL,             // reserved
                              &dwType,          // address of type
                              (LPBYTE)szPath,   // address of buffer
                              &dwSize);         // address of size

        // check if path is valid
        DWORD dwFlags = GetFileAttributes (szPath);
        if (dwFlags != (DWORD)-1)
            if (dwFlags & FILE_ATTRIBUTE_DIRECTORY)
                b = TRUE;

        if (b == TRUE) {
            // could be 5.5:  let's check
            DWORD dwBuildNumber = 0;
            DWORD dwType, dwSize = sizeof(dwBuildNumber);
            hr = RegQueryValueEx (hk,               // key
                                  L"NewestBuild",
                                  NULL,             // reserved
                                  &dwType,          // address of type
                                  (LPBYTE)&dwBuildNumber,   // address of buffer
                                  &dwSize);         // address of size
            if (hr == S_OK) {
                if (dwBuildNumber < 4047) // PT beta 1 build
                    b = FALSE;
            }
        }
        RegCloseKey (hk);
    }
    return b;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\inc\authid.h ===
/************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

File Name:      AuthID.h
Abstract:       Defines the GUIDs for Authentication methods
Notes:          
History:        01/15/2002 Created by Hao Yu (haoyu)

************************************************************************************************/

#ifndef __POP3_SERVER_AUTH_ID_H__
#define __POP3_SERVER_AUTH_ID_H__


#define SZ_AUTH_ID_DOMAIN_AD _T("ef9d811e-36c5-497f-ade7-2b36df172824")
#define SZ_AUTH_ID_LOCAL_SAM _T("14f1665c-e3d3-46aa-884f-ed4cf19d7ad5")
#define SZ_AUTH_ID_MD5_HASH _T("c395e20c-2236-4af7-b736-54fad07dc526")


#endif // __POP3_SERVER_AUTH_ID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\inc\metabaseutil.h ===
/************************************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:    MetabaseUtil.h
Notes:          
History:        
************************************************************************************************/

#ifndef __METABASEUTIL_H_
#define __METABASEUTIL_H_

#include <comdef.h>
#include <Iads.h>
#include <Adshlp.h>

HRESULT GetDefaultMailRoot( LPWSTR psMailRoot, DWORD dwSize )
{
    if ( NULL == psMailRoot ) 
        return E_INVALIDARG;
    if ( 0 == dwSize ) 
        return TYPE_E_BUFFERTOOSMALL;

    HRESULT hr;
    WCHAR   sBuffer[MAX_PATH];
    _variant_t _v;
    CComPtr<IADs> spIADs;

    wcscpy( sBuffer, L"IIS://localhost/SMTPSVC/1" );
    hr = ADsGetObject( sBuffer, IID_IADs, reinterpret_cast<LPVOID*>( &spIADs ));
    if ( SUCCEEDED( hr ))
    {
        hr = spIADs->Get( L"PickupDirectory", &_v );
		if SUCCEEDED( hr )
		{
			if ( VT_BSTR == V_VT( &_v ))
			{
				if ( wcslen( V_BSTR( &_v )) + 9 < sizeof( sBuffer ) / sizeof( WCHAR ))
				{
					wcscpy( sBuffer, V_BSTR( &_v ));
					WCHAR *ps = wcsrchr( sBuffer, L'\\' );
					if ( NULL != ps )
					{
						*ps = 0x0;
						wcscat( sBuffer, L"\\Mailbox" );
                        if ( wcslen( sBuffer ) < dwSize )
                            wcscpy( psMailRoot, sBuffer );
                        else
                            hr = TYPE_E_BUFFERTOOSMALL;
					}
					else
						hr = E_UNEXPECTED;
				}
				else
					hr = DISP_E_BUFFERTOOSMALL;
			}
		}
    }

    return hr;
}

#endif //__METABASEUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\inc\pop3server.h ===
/************************************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:    POP3Server.h
Notes:          
History:        
************************************************************************************************/

#ifndef __POP3SERVER_H_
#define __POP3SERVER_H_

#include <POP3RegKeys.h>

#define POP3_SERVER_NAME                _T("POP3 Service")   // Use for Event Viewer and other places
#define POP3_SERVER_NAME_L              L"POP3 Service"      

#define IISADMIN_SERVICE_NAME           _T( "IISADMIN" )
#define WMI_SERVICE_NAME                _T( "WINMGMT" )
//#define W3_SERVICE_NAME               _T( "W3SVC" )       // Definted in iis/inc/inetinfo.h
//#define SMTP_SERVICE_NAME             _T( "SMTPSVC" )     // Defined in iis/staxinc/export/smtpinet.h

#define POP3_SERVICE_NAME               _T("POP3SVC")
#define POP3_SERVICE_DISPLAY_NAME       _T("Microsoft POP3 Service")

#define POP3_MAX_PATH                   MAX_PATH*2
#define POP3_MAX_MAILROOT_LENGTH        MAX_PATH
#define POP3_MAX_ADDRESS_LENGTH         POP3_MAX_MAILBOX_LENGTH + POP3_MAX_DOMAIN_LENGTH
#define POP3_MAX_MAILBOX_LENGTH         65  // 64 + NULL
#define POP3_MAX_DOMAIN_LENGTH          256 // 255 + NULL

#endif //__POP3SERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\inc\sbs6base.h ===
//-----------------------------------------------------------------------------
// base.h basis for all common headers
//-----------------------------------------------------------------------------
#ifndef _SBS6BASE_H
#define _SBS6BASE_H

#include "windows.h"

//-----------------------------------------------------------------------------
// various std namespace classes
//-----------------------------------------------------------------------------
#include <string>
#include <list>
#include <map>
#include <vector>
#include <stdexcept>
#include <algorithm>
#include <stack>
#include <tchar.h>
#include <stdarg.h>

using namespace std;

// Make sure our unicode defines are in order
#ifdef _UNICODE
#ifndef UNICODE
#error UNICODE must be defined if _UNICODE is defined.
#endif
#ifdef _MBCS
#error You cannot define both _MBCS and _UNICODE in the same image.
#endif
#endif

#ifdef UNICODE
#ifndef _UNICODE
#error _UNICODE must be defined if UNICODE is defined.
#endif
#ifdef _MBCS
#error You cannot define both _MBCS and UNICODE in the same image.
#endif
#endif

// Make sure our debug defines are in order
#ifdef DEBUG
#ifndef DBG
#error DBG must be defined to 1 if DEBUG is defined.
#elif DBG == 0
#error DBG must be defined to 1 if DEBUG is defined.
#endif
#endif

#ifdef _DEBUG
#ifndef DBG
#error DBG must be defined to 1 if _DEBUG is defined.
#elif DBG == 0
#error DBG must be defined to 1 if _DEBUG is defined.
#endif
#endif


// Define TSTRING
#ifdef UNICODE
    typedef std::wstring TSTRING;
#else
    typedef std::string TSTRING;
#endif

// Define tstring
#ifdef UNICODE
    typedef std::wstring tstring;
#else
    typedef std::string tstring;
#endif

// define WSTRING and ASTRING
typedef std::wstring WSTRING;
typedef std::string ASTRING;

//#include <sbsassert.h>
//#include <paths.h>

// generic list/map typedefs
typedef list<TSTRING> StringList;
typedef map<TSTRING, TSTRING> StringMap;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3perf\pop3pi.h ===
/*
 -	wnpi.h
 -
 *	Purpose:
 *		Contains the complete list of PerfMon counter indexes for Pop3Svc.  These
 *		indexes must start at zero and increase in multiples of two.  These
 *		represent the object or counter name; the odd numbered counters (or
 *		a given counter index plus 1) represents the counter help.
 *
 *	Copyright (C) 2001-2002 Microsoft Corporation
 *
 */

#define POP3SVC_OBJECT						0
#define POP3SVC_TOTAL_CONNECTION		   	2
#define POP3SVC_CONNECTION_RATE 	   		4
#define POP3SVC_TOTAL_MESSAGE_DOWNLOADED    6
#define POP3SVC_MESSAGE_DOWNLOAD_RATE		8
#define POP3SVC_FREE_THREAD_COUNT           10
#define POP3SVC_CONNECTED_SOCKET_COUNT      12
#define POP3SVC_BYTES_RECEIVED    	        14
#define POP3SVC_BYTES_RECEIVED_RATE         16
#define POP3SVC_BYTES_TRANSMITTED           18
#define POP3SVC_BYTES_TRANSMITTED_RATE      20
#define POP3SVC_FAILED_LOGON_COUNT          22
#define POP3SVC_AUTH_STATE_COUNT            24
#define POP3SVC_TRAND_STATE_COUNT           26

/*Define the instance counters if needed*/
/*#define POP3SVC_INST_OBJECT					28 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3perf\pop3perf.cpp ===
/*
 -  Pop3perf.cpp
 -
 *  Purpose:
 *
 *  Copyright:
 *
 *  History:
 *
 */


#include <StdAfx.h>
#include <winperf.h>
#define PERF_DLL_ONCE
#include <Pop3SvcPerf.h>
#include <perfdll.h>

#define SZ_POP3_SERVICE_NAME L"Pop3Svc"
// Debugging registry key constant

BOOL WINAPI DllMain(
  HINSTANCE hinstDLL,  // handle to the DLL module
  DWORD fdwReason,     // reason for calling function
  LPVOID lpvReserved)   // reserved
{
    if (DLL_PROCESS_ATTACH == fdwReason)
    {
        PERF_DATA_INFO  pdi;

        // Configure Perfmon Counters
        // PERF_DATA_INFO have buffers of MAX_PATH characters
        pdi.cGlobalCounters         = cntrMaxGlobalCntrs;
        pdi.rgdwGlobalCounterTypes  = g_rgdwGlobalCntrType;
        pdi.rgdwGlobalCntrScale     = g_rgdwGlobalCntrScale;
        wcsncpy(pdi.wszSvcName, SZ_POP3_SERVICE_NAME, MAX_PATH-1);
        wcsncpy(pdi.wszGlobalSMName, szPOP3PerfMem, MAX_PATH-1);
        pdi.wszSvcName[MAX_PATH-1]=0;
        pdi.wszGlobalSMName[MAX_PATH-1]=0;
        // NOTE: If your service does not require Instance
        // counters, you MUST set cInstCounters to zero!
        pdi.cInstCounters           = cntrMaxInstCntrs;
        wcsncpy(pdi.wszInstSMName,    szPOP3InstPerfMem, MAX_PATH-1);
        wcsncpy(pdi.wszInstMutexName, szPOP3InstPerfMutex, MAX_PATH-1);
        pdi.wszInstSMName[MAX_PATH-1]=0;
        pdi.wszInstMutexName[MAX_PATH-1]=0;        
        pdi.rgdwInstCounterTypes    = g_rgdwInstCntrType;

        if (FAILED(HrInitPerf(&pdi)))
            return FALSE;

    }

    if (DLL_PROCESS_DETACH == fdwReason)
    {
        HrShutdownPerf();
    }

    return TRUE;
}

// Must have wrapper functions, otherwise the lib functions don't get
// pulled into the executable (smart linking "saves us" again...)

DWORD APIENTRY
Pop3SvcOpenPerfProc(LPWSTR sz)
{
    return OpenPerformanceData(sz);
}

DWORD APIENTRY
Pop3SvcCollectPerfProc(LPWSTR sz, LPVOID *ppv, LPDWORD pdw1, LPDWORD pdw2)
{
    return CollectPerformanceData(sz, ppv, pdw1, pdw2);
}

DWORD APIENTRY
Pop3SvcClosePerfProc(void)
{
    return ClosePerformanceData();
}

HRESULT _stdcall  DllRegisterServer(void)
{
    return RegisterPerfDll( SZ_POP3_SERVICE_NAME,
                     L"Pop3SvcOpenPerfProc",
                     L"Pop3SvcCollectPerfProc",
                     L"Pop3SvcClosePerfProc"
                     ) ;
}

HRESULT _stdcall  DllUnregisterServer(void)
{
    return HrUninstallPerfDll( SZ_POP3_SERVICE_NAME );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3perf\pop3svcperf.h ===
/**************************************************************************
 * Copyright  2001  Microsoft Corporation.  All Rights Reserved.
 *
 *    File Name: Pop3SvcPerf.h
 *
 *    Purpose:
 *      Define those constants and enums required by pfappdll.h and pfMndll.h
 *      ITEMS WHICH MUST BE DEFINED:
 *          typedef enum GLOBAL_CNTR
 *          typedef enum INST_CNTR
 *          Array of PERF_COUNTER types (in sync with GLOBAL_CNTR)
 *          Array of PERF_COUNTER types (in sync with INST_CNTR)
 *
 *
 *
 *************************************************************************/

//
// These are the names of the shared memory regions used by the single instance
// PerfMon counter and the Per Instance  PerfMon counters respectively.

const LPTSTR    szPOP3PerfMem        = TEXT("POP3_PERF_MEM");         // GLOBAL
const LPTSTR    szPOP3InstPerfMem    = TEXT("POP3_INST_PERF_MEM");    // INSTANCE
const LPTSTR    szPOP3InstPerfMutex  = TEXT("POP3_INST_PERF_MUTEX");  // Mutex


#define PERF_COUNTER_RAWCOUNT_NO_DISPLAY       \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
            PERF_DISPLAY_NOSHOW)

//
// Global Counters -- Enum's and associated config data

enum GLOBAL_CNTR
{
    e_gcTotConnection = 0, // Total connections since the service starts
    e_gcConnectionRate,    // Connections per second
    e_gcTotMsgDnldCnt,     // Total number of messages downloaded
    e_gcMsgDnldRate,       // Messages downloaded per second
    e_gcFreeThreadCnt,     // Free Thread Count  
    e_gcConnectedSocketCnt,// Number of currently connected socket 
    e_gcBytesReceived,     // Total bytes received 
    e_gcBytesReceiveRate,  // Bytes received per second
    e_gcBytesTransmitted,  // Bytes downloaded
    e_gcBytesTransmitRate, // Bytes downloaded per second
    e_gcFailedLogonCnt,    // Number of failed logons
    e_gcAuthStateCnt,      // Auth State Count
    e_gcTransStateCnt,     // Trans State Count
    // Add new counters above this line, at end of enum.

    // cntrMaxGlobalCntrs *must* be last element
    cntrMaxGlobalCntrs

};

#ifdef PERF_DLL_ONCE

// Type for each Global Counter
// NOTE: g_rgdwGlobalCntrType *must* be kept in sync with GLOBAL_CNTR

DWORD g_rgdwGlobalCntrType[] =
{
    PERF_COUNTER_RAWCOUNT,                      // e_gcTotConnection
    PERF_COUNTER_COUNTER,                       // e_gcConnectionRate
    PERF_COUNTER_RAWCOUNT,                      //e_gcTotMsgDnldCnt,     
    PERF_COUNTER_COUNTER,                       //e_gcMsgDnldRate,       
    PERF_COUNTER_RAWCOUNT,                      //e_gcFreeThreadCnt,     
    PERF_COUNTER_RAWCOUNT,                      //e_gcConnectedSocketCnt,
    PERF_COUNTER_RAWCOUNT,                      //e_gcBytesReceived,     
    PERF_COUNTER_COUNTER,                       //e_gcBytesReceiveRate,  
    PERF_COUNTER_RAWCOUNT,                      //e_gcBytesTransmitted,  
    PERF_COUNTER_COUNTER,                       //e_gcBytesTransmitRate, 
    PERF_COUNTER_RAWCOUNT,                      //e_gcFailedLogonCnt,    
    PERF_COUNTER_RAWCOUNT,                      //e_gcAuthStateCnt,      
    PERF_COUNTER_RAWCOUNT,                      //e_gcTransStateCnt,     

    // Add new counter types above this line, at end of array.

};


DWORD g_rgdwGlobalCntrScale[] =
{
    -3,                      //e_gcTotConnection
    0,                      //e_gcConnectionRate
    -4,                      //e_gcTotMsgDnldCnt,     
    0,                      //e_gcMsgDnldRate,       
    0,                      //e_gcFreeThreadCnt,     
    0,                      //e_gcConnectedSocketCnt,
    -6,                      //e_gcBytesReceived,     
    -4,                      //e_gcBytesReceiveRate,  
    -6,                      //e_gcBytesTransmitted,  
    -4,                      //e_gcBytesTransmitRate, 
    0,                      //e_gcFailedLogonCnt,    
    0,                      //e_gcAuthStateCnt,      
    0,                      //e_gcTransStateCnt,     
    // Add new counter scales above this line, at end of array.

};



#endif // PERF_DLL_ONCE

//
// Instance Counters -- Enum's and associated config data

enum INST_CNTR
{
    // Add new Instance counters above this line, at end of enum.

    // cntrMaxInstCntrs *must* be last element
    cntrMaxInstCntrs=0,

} ;

#ifdef PERF_DLL_ONCE

// Type for each Instance Counter
// NOTE: must be kept in sync with E_INST_CNTR

DWORD g_rgdwInstCntrType[] =
{

    // Add new counter types above this line, at end of array.
    PERF_COUNTER_COUNTER,
};

#endif // PERF_DLL_ONCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\inc\tmpledit.h ===
#ifndef __tmplEdit_h
#define __tmplEdit_h

#include <imm.h>

/////////////////////////////////////////////////////////////////////////////
// CWindowImplNoImm 
// Purpose - Meant to prevent entry of DBCS characters into an edit box by 
//           disabling IME 
//
// Usage   - CWindowImplNoImm<> m_NoImmEditWindow1;
//           CDialog::OnInitDialog(..) 
//           {
//              ...
//              m_NoImmEditWindow1.SubClassWindow( GetDlgItem( IDC_NOIMMEDITWINDOW1 ));
//              ...
//           }

template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplNoImm : public CWindowImpl< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoImm)
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
		BOOL bRC = CWindowImpl< T, TBase, TWinTraits >::SubclassWindow( hWnd );
		if ( bRC )
			ImmAssociateContext( hWnd, NULL );
        return bRC;
	}

    void LTrim()
    {
        LPTSTR  psBuffer;
        unsigned int i = 0;
        DWORD   dwSize;
        
        dwSize = ::GetWindowTextLength( m_hWnd );
        if ( 0 < dwSize )
        {
            dwSize++;
            psBuffer = new TCHAR[dwSize];
            ::GetWindowText( m_hWnd , psBuffer, dwSize );
            while ( i < dwSize && 32 == psBuffer[i] )
                i++;
            if ( 0 < i )
                ::SetWindowText( m_hWnd, psBuffer + i );
            delete [] psBuffer;
        }
    }
    void RTrim()
    {
        LPTSTR  psBuffer;
        unsigned int i = 0;
        DWORD   dwSize;
        
        dwSize = ::GetWindowTextLength( m_hWnd );
        if ( 0 < dwSize )
        {
            i = dwSize;
            dwSize++;
            psBuffer = new TCHAR[dwSize];
            ::GetWindowText( m_hWnd , psBuffer, dwSize );
            while ( 0 < i && ( 32 == psBuffer[i] || 0 == psBuffer[i] ))
            {
                psBuffer[i] = 0;
                i--;
            }
            if ( i < dwSize - 1 )
                ::SetWindowText( m_hWnd, psBuffer );
            delete [] psBuffer;
        }
    }
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplNoPaste 
// Purpose - Meant to prevent entry of DBCS characters into an edit box by 
//           disabling IME and not allowing any pasting of charaters
//
// Usage   - CWindowImplNoPaste<> m_NoPasteEditWindow1;
//           CDialog::OnInitDialog(..) 
//           {
//              ...
//              m_NoPasteEditWindow1.SubClassWindow( GetDlgItem( IDC_NOPASTEEDITWINDOW1 ));
//              ...
//           }

template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplNoPaste : public CWindowImpl< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoPaste)
        MESSAGE_HANDLER( WM_PASTE, OnPaste )
    END_MSG_MAP()

	LRESULT OnPaste( UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/ )
	{
		MessageBeep( MB_ICONEXCLAMATION );
		return 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplNoCopy 
// Purpose - Meant to prevent entry of DBCS characters into an edit box by 
//           disabling IME and not allowing any pasting of charaters
//
// Usage   - CWindowImplNoCopy<> m_NoCopyEditWindow1;
//           CDialog::OnInitDialog(..) 
//           {
//              ...
//              m_NoCopyEditWindow1.SubClassWindow( GetDlgItem( IDC_NOCOPYEDITWINDOW1 ));
//              ...
//           }

template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplNoCopy : public CWindowImpl< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoCopy)
        MESSAGE_HANDLER( WM_COPY, OnCopy )
    END_MSG_MAP()

	LRESULT OnCopy( UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/ )
	{
		MessageBeep( MB_ICONEXCLAMATION );
		return 0;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplPhoneNumber 
// Purpose - Meant to allow entry of only telephone number related characters
//
// Usage   - CWindowImplPhoneNumber<> m_PhoneNumberEditWindow1;
//           CDialog::OnInitDialog(..) 
//           {
//              ...
//              m_PhoneNumberEditWindow1.SubClassWindow( GetDlgItem( IDC_PHONENOEDITWINDOW1 ));
//              ...
//           }

template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplPhoneNumber : public CWindowImpl< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplPhoneNumber)
        MESSAGE_HANDLER( WM_CHAR, OnChar )
    END_MSG_MAP()

	LRESULT OnChar( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled )
	{
        int i = GetKeyState( VK_CONTROL );

        if ( !(( _T( '0' ) <= wParam &&  _T( '9' ) >= wParam ) || _T( ' ' ) == wParam || _T( '-' ) == wParam || _T( ',' ) == wParam
              || VK_BACK == wParam || VK_SPACE == wParam || VK_DELETE == wParam || VK_INSERT == wParam )
              && 0 == HIWORD( i ))
        {
            MessageBeep( static_cast<unsigned int>(-1) );
            return TRUE;
        }

        bHandled = FALSE;
		return FALSE;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplFileChar 
// Purpose - Meant to allow entry of any characters except those specifically disallowed for files
//
// Usage   - CWindowImplFileChar<> m_FileNameEditWindow1;
//           CDialog::OnInitDialog(..) 
//           {
//              ...
//              m_FileNameEditWindow1.SubClassWindow( GetDlgItem( IDC_FILENAMEEDITWINDOW1 ));
//              ...
//           }

template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplFileChar : public CWindowImpl< T, TBase, TWinTraits >
{
public:

    CWindowImplFileChar() : m_isWildCardsAllowed( false ),
                            m_isFullPathAllowed( false )
    {}

    BEGIN_MSG_MAP(CWindowImplFileChar)
        MESSAGE_HANDLER( WM_CHAR, OnChar )
    END_MSG_MAP()

	LRESULT OnChar( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled )
	{
        TCHAR sCharList[] = { _T('/'), _T('"'), _T('<'), _T('>'), _T('|'), 0, 0, 0, 0, 0};

        if (! m_isWildCardsAllowed)
        {
            sCharList[_tcslen(sCharList)] = _T('*');
            sCharList[_tcslen(sCharList)] = _T('?');
        }

        if (! m_isFullPathAllowed)
        {
            sCharList[_tcslen(sCharList)] = _T('\\');
            sCharList[_tcslen(sCharList)] = _T(':');
        }

        int i = GetKeyState( VK_CONTROL );

        if ( (NULL != _tcschr(sCharList, static_cast<TCHAR>(wParam))) && (0 == HIWORD(i)) )
        {
            MessageBeep( static_cast<unsigned int>(-1) );
            return TRUE;
        }

        bHandled = FALSE;
		return FALSE;
	}

public:
// Attributes:
    bool m_isWildCardsAllowed;
    bool m_isFullPathAllowed;
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplASCII 
// Purpose - Meant to allow entry of only ASCII characters (a-z, A-Z, 0-9, space)
//
// Usage   - CWindowImplASCII<> m_ASCIIEditWindow1;
//           CDialog::OnInitDialog(..) 
//           {
//              ...
//              m_ASCIIEditWindow1.SubClassWindow( GetDlgItem( IDC_ASCIIEDITWINDOW1 ));
//              ...
//           }

template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplASCII : public CWindowImpl< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplASCII)
        MESSAGE_HANDLER( WM_CHAR, OnChar )
    END_MSG_MAP()

	LRESULT OnChar( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled )
	{
        int i = GetKeyState( VK_CONTROL );

        if ( !(( 32 <= wParam && 126 >= wParam )
              || VK_BACK == wParam )
              && 0 == HIWORD( i ))
        {
            MessageBeep( static_cast<unsigned int>(-1) );
            return TRUE;
        }

        bHandled = FALSE;
		return FALSE;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplNoImmPaste = CWindowImplNoImm + CWindowImplNoPaste 
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplNoImmPaste : public CWindowImplNoImm< T, TBase, TWinTraits >, public CWindowImplNoPaste< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoPaste)
		if(CWindowImplNoPaste< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplNoImmPN = CWindowImplNoImm + CWindowImplPhoneNumber
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplNoImmPN : public CWindowImplNoImm< T, TBase, TWinTraits >, public CWindowImplPhoneNumber< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoImmPastePN)
		if(CWindowImplPhoneNumber< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplNoImmPasteASCII = CWindowImplNoImm + CWindowImplNoPaste + CWindowImplASCII
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplNoImmPasteASCII : public CWindowImplNoImm< T, TBase, TWinTraits >, public CWindowImplNoPaste< T, TBase, TWinTraits >, public CWindowImplASCII< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoPasteASCII)
		if(CWindowImplNoPaste< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
		if(CWindowImplASCII< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }
};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplNoImmASCII = CWindowImplNoImm + CWindowImplASCII
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplNoImmASCII : public CWindowImplNoImm< T, TBase, TWinTraits >, public CWindowImplASCII< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoPasteASCII)
		if(CWindowImplASCII< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }
};

//-----------------------------------------------------------------------------
// CWindowImplComputerName = CWindowImplNoImm + CWindowImplNoPaste + computer name
//	character checking
//-----------------------------------------------------------------------------
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplComputerName : public CWindowImplNoImm< T, TBase, TWinTraits >,
								public CWindowImplNoPaste< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoPaste)
		MESSAGE_HANDLER(WM_CHAR, OnChar)
		MESSAGE_HANDLER(WM_GETDLGCODE, OnDlgCode)
		if(CWindowImplNoPaste< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	CWindowImplComputerName() :
		m_hWndButton(NULL),
		m_hWndEdit(NULL)
	{
	}

	VOID SetHandles( HWND hWndButton, HWND hWndEdit )
	{
		m_hWndButton = hWndButton;
		m_hWndEdit = hWndEdit;
	}

	BOOL SubclassWindow(HWND hWnd)
	{
        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }

	LRESULT OnChar( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled )
	{
		if( (wParam >= _T('a') && wParam <= _T('z')) ||
			(wParam >= _T('A') && wParam <= _T('Z')) ||
			(wParam >= _T('0') && wParam <= _T('9')) ||
			(wParam == _T('-')) ||
			(wParam == VK_BACK) )
		{
		}
		else if( wParam == VK_RETURN )
		{
			::SendMessage( m_hWndButton, BM_CLICK, 0, 0 );
			bHandled = TRUE;
			return FALSE;
		}
		else
		{
            MessageBeep( static_cast<unsigned int>(-1) );
            return TRUE;
        }

        bHandled = FALSE;
		return FALSE;
	}

	LRESULT OnDlgCode( UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled )
	{
		if( m_hWndEdit )
		{
			MSG* pMsg = (MSG*)lParam;
			if( pMsg )
			{
				if( (pMsg->message == WM_KEYDOWN) &&
					(LOWORD(pMsg->wParam) == VK_RETURN) )
				{
					// only take it if we have text
					if( ::SendMessage(m_hWndEdit, WM_GETTEXTLENGTH, 0, 0) )
					{
						bHandled = TRUE;
						return DLGC_WANTALLKEYS;
					}
				}
			}
		}

		bHandled = FALSE;
		return 0;
	}

	HWND	m_hWndButton;
	HWND	m_hWndEdit;

};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplAlias = CWindowImplNoImm + Alias ASCII checking 
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplAlias : public CWindowImplNoImm< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplAlias)
		MESSAGE_HANDLER(WM_CHAR, OnChar)		
    END_MSG_MAP()	

	LRESULT OnChar( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled )
	{
		if ( (wParam >= 35  && wParam <= 39)  ||
             (wParam >= 42  && wParam <= 43)  ||
             (wParam >= 45  && wParam <= 57)  ||
             (wParam >= 63  && wParam <= 90)  ||
             (wParam >= 94  && wParam <= 126) ||
             (wParam == 33)                   ||
             (wParam == 61)                   ||
             (wParam == 92)                   ||
             (wParam == VK_BACK)              || // Backspace!             
             (wParam == VK_INSERT)            || // Insert!             
             (wParam == 0x18)                 || // Allow Cutting! 
             (wParam == 0x1A)                 || // Allow Undoing! 
             (wParam == 0x03)                 || // Allow Copying! 
             (wParam == 0x16))                   // Allow Pasting! 
        {
        }
        else
		{
            MessageBeep( static_cast<unsigned int>(-1) );
            return TRUE;
        }

        bHandled = FALSE;
		return FALSE;
	}

};

/////////////////////////////////////////////////////////////////////////////
// CWindowImplPassword = CWindowImplNoImm + CWindowImplNoCopy + CWindowImplASCII
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplPassword : public CWindowImplNoImm< T, TBase, TWinTraits >, public CWindowImplNoCopy< T, TBase, TWinTraits >, public CWindowImplASCII< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplPassword)
		if(CWindowImplNoCopy< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
		if(CWindowImplASCII< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }
};


//-----------------------------------------------------------------------------
// CWindowImplDiskSpace = CWindowImplNoImm + CWindowImplNoPaste + disk space
//	character checking
//-----------------------------------------------------------------------------
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplDiskSpace : public CWindowImplNoImm< T, TBase, TWinTraits >,
								public CWindowImplNoPaste< T, TBase, TWinTraits >
{
public:

    BEGIN_MSG_MAP(CWindowImplNoPaste)
		MESSAGE_HANDLER(WM_CHAR, OnChar)
		if(CWindowImplNoPaste< T, TBase, TWinTraits >::ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult)) 
			return TRUE; 
    END_MSG_MAP()

	BOOL SubclassWindow(HWND hWnd)
	{
        return CWindowImplNoImm< T, TBase, TWinTraits >::SubclassWindow(hWnd);
    }

	LRESULT OnChar( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled )
	{
		if( !_istdigit((INT)wParam) &&
			(wParam != _T('.')) &&
			(wParam != VK_BACK) )
		{
            MessageBeep( static_cast<unsigned int>(-1) );
            return TRUE;
		}

        bHandled = FALSE;
		return FALSE;
	}

};

//-----------------------------------------------------------------------------
// CWindowImplComputerName = CWindowImplNoImm + domain name character checking
//-----------------------------------------------------------------------------
template <class T = CWindow, class TBase = CWindow, class TWinTraits = CControlWinTraits>
class CWindowImplDomainName : public CWindowImplNoImm< T, TBase, TWinTraits >							  
{
public:

    BEGIN_MSG_MAP(CWindowImplDomainName)
		MESSAGE_HANDLER(WM_CHAR, OnChar)		
    END_MSG_MAP()	

	LRESULT OnChar( UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled )
	{
		if( (wParam >= _T('a') && wParam <= _T('z')) ||
			(wParam >= _T('A') && wParam <= _T('Z')) ||
			(wParam >= _T('0') && wParam <= _T('9')) ||
			(wParam == _T('-')) ||
            (wParam == _T('.')) ||
			(wParam == VK_BACK) ||
            (wParam == VK_DELETE) ||
            (wParam == VK_INSERT) || 
            (wParam == 0x18)      || // Allow Cutting! 
            (wParam == 0x1A)      || // Allow Undoing! 
            (wParam == 0x03)      || // Allow Copying! 
            (wParam == 0x16))        // Allow Pasting! 
		{
		}		
		else
		{
            MessageBeep( static_cast<unsigned int>(-1) );
            return TRUE;
        }

        bHandled = FALSE;
		return FALSE;
	}
};



#endif // #ifndef __tmplEdit.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\inc\servutil.h ===
#ifndef _SERVUTIL_H_
#define _SERVUTIL_H_

// forward reference
HRESULT _StopService (LPTSTR szServiceName, BOOL bIncludeDependentServices = FALSE, LPTSTR szMachineName = NULL );

inline HRESULT _ChangeServiceStartType (LPTSTR szServiceName, DWORD dwServiceStartType)
{
    HRESULT hr = S_OK;
    SC_HANDLE hManager = OpenSCManager(NULL, NULL, STANDARD_RIGHTS_REQUIRED);
    if (hManager == NULL)
        hr = GetLastError();
    else {
        // stop service if it's running
        SC_HANDLE hService = OpenService (hManager, szServiceName, SERVICE_ALL_ACCESS);
        if (!hService)
            hr = GetLastError();
        else {
            if (!ChangeServiceConfig (hService,
                                      SERVICE_NO_CHANGE,    // service type
                                      dwServiceStartType,   // start type
                                      SERVICE_NO_CHANGE,    // error control
                                      NULL, NULL, NULL, NULL, NULL, NULL, NULL))
                hr = GetLastError();
            CloseServiceHandle (hService);
        }
        CloseServiceHandle (hManager);
    }
    return HRESULT_FROM_WIN32(hr);
}

inline DWORD _GetServiceStatus (LPTSTR szServiceName, LPTSTR szMachineName = NULL)
{
    DWORD dwStatus = 0;
    SC_HANDLE hSCManager = OpenSCManager (szMachineName,           
                                          NULL,                    // ServicesActive database 
                                          SC_MANAGER_ALL_ACCESS);  // full access rights
    if (hSCManager != NULL) {
        SC_HANDLE hService = OpenService (hSCManager, 
                                          szServiceName,
                                          SERVICE_QUERY_STATUS);
        if (hService) {
            SERVICE_STATUS ss = {0};
            if (QueryServiceStatus (hService, &ss))
               dwStatus = ss.dwCurrentState;
            CloseServiceHandle (hService);
        }
        CloseServiceHandle (hSCManager);
    }
    return dwStatus;
}

inline BOOL _IsServiceStartType (LPTSTR szServiceName, DWORD dwServiceStartType)
{
    BOOL b = FALSE;
    SC_HANDLE hSCManager = OpenSCManager (NULL,                    // local machine 
                                          NULL,                    // ServicesActive database 
                                          SC_MANAGER_ALL_ACCESS);  // full access rights
    if (hSCManager != NULL) {
        SC_HANDLE hService = OpenService (hSCManager, 
                                          szServiceName,
                                          SERVICE_ALL_ACCESS);
        if (hService) {
            DWORD dwSize = 0;
            if (0 == QueryServiceConfig (hService, NULL, dwSize, &dwSize))
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                QUERY_SERVICE_CONFIG* pQSC = (QUERY_SERVICE_CONFIG*)malloc (dwSize);
                if (pQSC) {
                    if (QueryServiceConfig (hService, pQSC, dwSize, &dwSize)) {
                        if (pQSC->dwStartType == dwServiceStartType)
                            b = TRUE;
                    }
                    free (pQSC);
                }
            }
            CloseServiceHandle (hService);
        }
        CloseServiceHandle (hSCManager);
    }
    return b;
}

inline BOOL _IsServiceStatus (LPTSTR szServiceName, DWORD dwServiceStatus)
{
    BOOL b = FALSE;
    SC_HANDLE hSCManager = OpenSCManager (NULL,                    // local machine 
                                          NULL,                    // ServicesActive database 
                                          SC_MANAGER_ALL_ACCESS);  // full access rights
    if (hSCManager != NULL) {
        SC_HANDLE hService = OpenService (hSCManager, 
                                          szServiceName,
                                          SERVICE_QUERY_STATUS);
        if (hService) {
            SERVICE_STATUS ss = {0};
            if (QueryServiceStatus (hService, &ss))
               if (ss.dwCurrentState == dwServiceStatus)
                  b = TRUE;
            CloseServiceHandle (hService);
        }
        CloseServiceHandle (hSCManager);
    }
    return b;
}

inline BOOL _IsServiceRunning (LPTSTR szServiceName)
{
   return _IsServiceStatus (szServiceName, SERVICE_RUNNING);
}

inline BOOL _IsServiceInstalled (LPTSTR szServiceName)
{
    BOOL b = FALSE;
    SC_HANDLE hSCManager = OpenSCManager (NULL,                    // local machine 
                                          NULL,                    // ServicesActive database 
                                          SC_MANAGER_ALL_ACCESS);  // full access rights
    if (hSCManager != NULL) {
        SC_HANDLE hService = OpenService (hSCManager, 
                                          szServiceName,
                                          SERVICE_QUERY_STATUS);
        if (hService) {
            b = TRUE;
            CloseServiceHandle (hService);
        }
        CloseServiceHandle (hSCManager);
    }
    return b;
}

// private inline
inline long __WaitForServiceStatus (SC_HANDLE hService, DWORD dwStatus)
{
    SetLastError (0);
    int iIOPendingErrors = 0;

    SERVICE_STATUS ssStatus;
    if (!QueryServiceStatus (hService, &ssStatus))
        return GetLastError();
    if (dwStatus == SERVICE_STOPPED) {
        if (!(ssStatus.dwControlsAccepted & SERVICE_ACCEPT_STOP)) {
            // service doesn't accept stop!
            // return appropriate error
            if (ssStatus.dwCurrentState == dwStatus)
                return S_OK;
            if (ssStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR) {
                if (ssStatus.dwServiceSpecificExitCode == 0)
                    return ERROR_INVALID_SERVICE_CONTROL;
                return ssStatus.dwServiceSpecificExitCode;
            }
            if (ssStatus.dwWin32ExitCode != 0)
                return ssStatus.dwWin32ExitCode;
            return ERROR_INVALID_SERVICE_CONTROL;
        }
    }

    DWORD dwOldCheckPoint, dwOldCurrentState;
    while (ssStatus.dwCurrentState != dwStatus) {
        // Save the current checkpoint.
        dwOldCheckPoint   = ssStatus.dwCheckPoint;
        dwOldCurrentState = ssStatus.dwCurrentState;

        // Wait for the specified interval.
        int iSleep = ssStatus.dwWaitHint;
        if (iSleep > 2500)
            iSleep = 2500;
        if (iSleep == 0)
            iSleep = 100;
        Sleep (iSleep);

        // Check the status again.
        SetLastError (0);
        if (!QueryServiceStatus (hService, &ssStatus))
            return GetLastError();

        // Break if the checkpoint has not been incremented.
        if (dwOldCheckPoint == ssStatus.dwCheckPoint)
        if (dwOldCurrentState == ssStatus.dwCurrentState) {
            // ok:  at this point, we're supposed to be done, or there's an error
            if (ssStatus.dwCurrentState == dwStatus)
                break;
            if (ssStatus.dwWin32ExitCode != 0)
                break;

            // some kinda screw up:  we're not done and no error!
            // so, give 'em one last chance....
            Sleep (1000);
            SetLastError (0);
            if (!QueryServiceStatus (hService, &ssStatus))
                return GetLastError();

            if (dwOldCheckPoint == ssStatus.dwCheckPoint)
            if (dwOldCurrentState == ssStatus.dwCurrentState) {
                // empirical:  I keep getting this when actually everything is ok
                if (GetLastError() == ERROR_IO_PENDING)
                    if (iIOPendingErrors++ < 60)
                        continue;
                break;
            }
            // if we get here, either the checkpoint or status changed, and we can keep going
        }
    }
    if (ssStatus.dwCurrentState == dwStatus)
        return S_OK;

    if (ssStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR) {
        if (ssStatus.dwServiceSpecificExitCode == 0)
            return E_FAIL;
        return ssStatus.dwServiceSpecificExitCode;
    }
    if (ssStatus.dwWin32ExitCode != 0)
        return ssStatus.dwWin32ExitCode;

    // we should never get here
    HRESULT hr = GetLastError();
    return ERROR_SERVICE_REQUEST_TIMEOUT;

#ifdef BONE_HEADED_WAY
    SERVICE_STATUS ssStatus; 

    // wait for at most 3 minutes
    for (int i=0; i<180; i++) {
        if (!QueryServiceStatus (hService, &ssStatus))
            return HR (GetLastError());   // bad service handle?

        if (ssStatus.dwCurrentState == dwStatus)
            return S_OK;   // all is well

        Sleep(1000);    // wait a second
    }
    return HRESULT_FROM_WIN32(ERROR_SERVICE_REQUEST_TIMEOUT);
#endif
}

inline HRESULT _RecursiveStop (SC_HANDLE hService)
{
    HRESULT hr = S_OK;

    DWORD dwBufSize = 1, dwNumServices = 0;
    if (!EnumDependentServices (hService,
                                SERVICE_ACTIVE,
                                (LPENUM_SERVICE_STATUS)&dwBufSize,
                                dwBufSize,
                                &dwBufSize,
                                &dwNumServices)) {
        // this should fail with ERROR_MORE_DATA, unless there are no dependent services
        hr = GetLastError ();
        if (hr == ERROR_MORE_DATA) {
            hr = S_OK;
            ENUM_SERVICE_STATUS * pBuffer = (ENUM_SERVICE_STATUS *)malloc (dwBufSize);
            if (!pBuffer)
                hr = E_OUTOFMEMORY;
            else {
                if (!EnumDependentServices (hService,
                                            SERVICE_ACTIVE,
                                            pBuffer,
                                            dwBufSize,
                                            &dwBufSize,
                                            &dwNumServices))
                    hr = GetLastError();  // shouldn't happen!!!
                else {
                    _ASSERT (dwNumServices > 0);
                    for (DWORD i=0; i<dwNumServices && S_OK == hr; i++) {
                        hr = _StopService (pBuffer[i].lpServiceName, FALSE);
                    }
                }
                free (pBuffer);
            }
        }
    }
    return HRESULT_FROM_WIN32(hr); 
}

inline HRESULT _ControlService (LPTSTR szServiceName, DWORD dwControl, LPTSTR szMachineName = NULL )
{
    if ( NULL == szServiceName ) return E_INVALIDARG;
    if (( SERVICE_CONTROL_PAUSE != dwControl ) && ( SERVICE_CONTROL_CONTINUE != dwControl )) return E_INVALIDARG;
    
    HRESULT hr = S_OK;
    SC_HANDLE hManager;
    LPTSTR psMachineName = szMachineName;
    SERVICE_STATUS  ss;

    if ( NULL != psMachineName )
    {
        psMachineName = new TCHAR[ _tcslen( szMachineName ) + 3];
        if ( NULL == psMachineName )
            return E_OUTOFMEMORY;
        _tcscpy( psMachineName, _T( "\\\\" ));
        _tcscat( psMachineName, szMachineName );
    }
    hManager = OpenSCManager(psMachineName, NULL, STANDARD_RIGHTS_REQUIRED);
    if ( NULL != psMachineName )
        delete [] psMachineName;
    if (hManager == NULL)
        hr = GetLastError();
    else {
        SC_HANDLE hService = OpenService (hManager, szServiceName, SERVICE_ALL_ACCESS);
        if (hService == NULL)
            hr = GetLastError();
        else {
            if (!ControlService( hService, dwControl, &ss ))
                hr = GetLastError();
            else
            {
                if ( SERVICE_CONTROL_PAUSE == dwControl )
                    hr = __WaitForServiceStatus(hService, SERVICE_PAUSED);
                if ( SERVICE_CONTROL_CONTINUE == dwControl )
                    hr = __WaitForServiceStatus(hService, SERVICE_RUNNING);
            }
            CloseServiceHandle (hService);
        }
        CloseServiceHandle (hManager);
    }
    return HRESULT_FROM_WIN32(hr);
}

inline HRESULT _StopService (LPTSTR szServiceName, BOOL bIncludeDependentServices, LPTSTR szMachineName /*= NULL*/ )
{
    HRESULT hr = S_OK;
    SC_HANDLE hManager;
    LPTSTR psMachineName = szMachineName;

    if ( NULL != psMachineName )
    {
        psMachineName = new TCHAR[ _tcslen( szMachineName ) + 3];
        if ( NULL == psMachineName )
            return E_OUTOFMEMORY;
        _tcscpy( psMachineName, _T( "\\\\" ));
        _tcscat( psMachineName, szMachineName );
    }
    hManager = OpenSCManager(psMachineName, NULL, STANDARD_RIGHTS_REQUIRED);
    if ( NULL != psMachineName )
        delete [] psMachineName;
    if (hManager == NULL)
        hr = GetLastError();
    else {
        // stop service if it's running
        SC_HANDLE hService = OpenService (hManager, szServiceName, SERVICE_ALL_ACCESS);
        if (!hService)
            hr = GetLastError();
        else {
LETS_TRY_AGAIN:
            SERVICE_STATUS st;
            if (!ControlService (hService, SERVICE_CONTROL_STOP, &st)) {
                hr = GetLastError();   // for instance, not running
                if (hr == ERROR_DEPENDENT_SERVICES_RUNNING) {
                    if (bIncludeDependentServices == TRUE) {
                        hr = _RecursiveStop (hService);
                        if (hr == S_OK)
                            goto LETS_TRY_AGAIN;  // need to stop this service yet
                    }
                }
            } else
                hr = __WaitForServiceStatus (hService, SERVICE_STOPPED);
            CloseServiceHandle (hService);
        }
        CloseServiceHandle (hManager);
    }
    return HRESULT_FROM_WIN32(hr);
}

inline HRESULT _StartService (LPTSTR szServiceName, LPTSTR szMachineName = NULL )
{
    HRESULT hr = S_OK;
    SC_HANDLE hManager;
    LPTSTR psMachineName = szMachineName;

    if ( NULL != psMachineName )
    {
        psMachineName = new TCHAR[ _tcslen( szMachineName ) + 3];
        if ( NULL == psMachineName )
            return E_OUTOFMEMORY;
        _tcscpy( psMachineName, _T( "\\\\" ));
        _tcscat( psMachineName, szMachineName );
    }
    hManager = OpenSCManager(psMachineName, NULL, STANDARD_RIGHTS_REQUIRED);
    if ( NULL != psMachineName )
        delete [] psMachineName;
    if (hManager == NULL)
        hr = GetLastError();
    else {
        SC_HANDLE hService = OpenService (hManager, szServiceName, SERVICE_ALL_ACCESS);
        if (hService == NULL)
            hr = GetLastError();
        else {
            if (!StartService(hService, 0, NULL))
                hr = GetLastError();
            else
                hr = __WaitForServiceStatus(hService, SERVICE_RUNNING);
            CloseServiceHandle (hService);
        }
        CloseServiceHandle (hManager);
    }
    return HRESULT_FROM_WIN32(hr);
}

inline HRESULT _RestartService (LPTSTR szServiceName, BOOL bIncludeDependentServices = FALSE)
{
    // easy on first
    if (bIncludeDependentServices == FALSE) {
        _StopService (szServiceName, FALSE);
        return _StartService (szServiceName);
    }

    // get array of dependent services;
    DWORD dwNumServices = 0;
    ENUM_SERVICE_STATUS * pBuffer = NULL;
    HRESULT hr = S_OK, hr1 = S_OK;
    SC_HANDLE hManager = OpenSCManager(NULL, NULL, STANDARD_RIGHTS_REQUIRED);
    if (hManager == NULL)
        hr = GetLastError();
    else {
        // stop service if it's running
        SC_HANDLE hService = OpenService (hManager, szServiceName, SERVICE_ALL_ACCESS);
        if (!hService)
            hr = GetLastError();
        else {
            DWORD dwBufSize = 1;
            // this should fail with ERROR_MORE_DATA, unless there are no dependent services
            if (!EnumDependentServices (hService,
                                       SERVICE_ACTIVE,
                                       (LPENUM_SERVICE_STATUS)&dwBufSize,
                                       dwBufSize,
                                       &dwBufSize,
                                       &dwNumServices)) {
                hr = GetLastError ();
                if (hr == ERROR_MORE_DATA) {
                    hr = S_OK;
                    pBuffer = (ENUM_SERVICE_STATUS *)malloc (dwBufSize);
                    if (!pBuffer)
                        hr = E_OUTOFMEMORY;
                    else {
                        if (!EnumDependentServices (hService,
                                                    SERVICE_ACTIVE,
                                                    pBuffer,
                                                    dwBufSize,
                                                    &dwBufSize,
                                                    &dwNumServices))
                            hr = GetLastError();  // shouldn't happen!!!
                    }
                }
            }
            CloseServiceHandle (hService);
        }
        CloseServiceHandle (hManager);
    }

    if (hr == S_OK) {
        // stop dependent services
        if (pBuffer && dwNumServices) {
            for (DWORD i=0; i<dwNumServices && S_OK == hr; i++) {
                hr = _StopService (pBuffer[i].lpServiceName, FALSE);
            }
        }
        if (hr == S_OK) {
            // stop this service
            hr1 = _RestartService (szServiceName, FALSE);

            // always start dependent services
            if (pBuffer && dwNumServices) {
                for (int i=(int)dwNumServices-1; i>=0 && S_OK == hr; i--) {
                    hr = _StartService (pBuffer[i].lpServiceName);
                }
            }
        }
    }
    if (pBuffer != NULL)
        free (pBuffer);
    if FAILED(hr1)
        hr = hr1;
    return HRESULT_FROM_WIN32(hr); 
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3perf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Pop3Svc.rc
//
#define IDC_MYICON                      2
#define IDS_PROJNAME                    100
#define IDS_DISPLAYNAME                 101
#define IDS_DESCRIPTION                 102


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3perf\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <..\..\..\public\sdk\inc\atl30\statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\global.cxx ===
/************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

File Name:      Global.cxx
Abstract:       Defines global varibles 
Notes:          
History:        08/01/2001 Created by Hao Yu (haoyu)

************************************************************************************************/

#include <stdafx.h>
#include <ThdPool.hxx>
#include <SockPool.hxx>

#ifdef ROCKALL3
FAST_HEAP g_RockallHeap;
#endif

HANDLE g_hShutDown;
HANDLE g_hDoSEvent;

char g_szMailRoot[POP3_MAX_MAILROOT_LENGTH];

WCHAR g_wszGreeting[MAX_PATH];

WCHAR g_wszComputerName[MAX_PATH];

DWORD g_dwRequireSPA;
DWORD g_dwIPVersion;
DWORD g_dwMaxMsgPerDnld;
DWORD g_dwServerStatus;
DWORD g_dwAuthMethod;

CIOList g_BusyList;

CIOList g_FreeList;

CThreadPool g_ThreadPool;

CSocketPool g_SocketPool;

GLOBCNTR g_PerfCounters;

CEventLogger g_EventLogger;

IAuthMethod *g_pAuthMethod=NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3perf\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__122FFAC7_F1D2_429A_9F62_8DDE9547E3DA__INCLUDED_)
#define AFX_STDAFX_H__122FFAC7_F1D2_429A_9F62_8DDE9547E3DA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED

#include <windows.h>
#include <atlbase.h>
#include <lm.h>



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__122FFAC7_F1D2_429A_9F62_8DDE9547E3DA__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\globaldef.h ===
/************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

File Name:      GlobalDef.h
Abstract:       Defines global varibles and constants
Notes:          
History:        08/01/2001 Created by Hao Yu (haoyu)

************************************************************************************************/


#ifndef __POP3_GLOBAL_DEF__
#define __POP3_GLOBAL_DEF__

#include <pop3server.h>
// Global constants/definitions 


// Need to figure out what a real limit should be
#define MAX_THREAD_PER_PROCESSOR 32
#define MIN_SOCKADDR_SIZE (sizeof(struct sockaddr_storage) + 16)
#define SHUTDOWN_WAIT_TIME 30000 //30 seconds
#define DEFAULT_MAX_MSG_PER_DNLD 0 //by default, no limit 

#define UnicodeToAnsi(A, cA, U, cU) WideCharToMultiByte(CP_ACP,0,(U),(cU),(A),(cA),NULL,NULL)
#define AnsiToUnicode(A, cA, U, cU) MultiByteToWideChar(CP_ACP,0,(A),(cA),(U),(cU))

#ifdef ROCKALL3
extern FAST_HEAP g_RockallHeap;
#endif

// Global varibles and objects
extern DWORD g_dwRequireSPA;

extern DWORD g_dwIPVersion;

extern DWORD g_dwServerStatus;

extern DWORD g_dwMaxMsgPerDnld;

extern DWORD g_dwAuthMethod;

extern CThreadPool g_ThreadPool;

extern CSocketPool g_SocketPool;

extern GLOBCNTR g_PerfCounters;

extern CEventLogger g_EventLogger;

extern CIOList g_BusyList;

extern CIOList g_FreeList;

extern IAuthMethod *g_pAuthMethod;

extern char g_szMailRoot[POP3_MAX_MAILROOT_LENGTH];

extern WCHAR g_wszComputerName[MAX_PATH];

extern WCHAR g_wszGreeting[MAX_PATH];

extern HANDLE g_hShutDown;

extern HANDLE g_hDoSEvent;







#endif //__POP3_GLOBAL_DEF__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\iocontext.h ===
/************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

File Name:      IOContext.hxx
Abstract:       Defines the IO_CONTEXT Structure
Notes:          
History:        08/01/2001 Created by Hao Yu (haoyu)

************************************************************************************************/


#ifndef __POP3_IO_CONTEXT__
#define __POP3_IO_CONTEXT__

#include <windows.h>
#include <winsock2.h>
#include <mswsock.h>
#include <winnt.h>

class POP3_CONTEXT;
typedef POP3_CONTEXT *PPOP3_CONTEXT;

#ifndef CONTAINING_RECORD
//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//
#define CONTAINING_RECORD(address, type, field) \
            ((type *)((PCHAR)(address) - (ULONG_PTR)(&((type *)0)->field)))
#endif // CONTAINING_RECORD

#define HANDLE_TO_SOCKET(h) ((SOCKET)(h))
#define SOCKET_TO_HANDLE(s) ((HANDLE)(s))

#define POP3_REQUEST_BUF_SIZE 1042 // No single POP3 request should exceed this size
#define POP3_RESPONSE_BUF_SIZE 1042 // including NTLM requests/responses 
#define DEFAULT_TIME_OUT       600000 //600 seconds or 10 minutes
#define SHORTENED_TIMEOUT       10000 //10 seconds
#define UNLOCKED                    0
#define LOCKED_TO_PROCESS_POP3_CMD  1
#define LOCKED_FOR_TIMEOUT          2


typedef void (*CALLBACKFUNC) (PULONG_PTR pCompletionKey ,LPOVERLAPPED pOverlapped, DWORD dwBytesRcvd);



enum IO_TYPE
{
    LISTEN_SOCKET,
    CONNECTION_SOCKET,
    FILE_IO,
    DELETE_PENDING,
    TOTAL_IO_TYPE
};


// Data structure associated with each async socket or file IO 
// for the IO completion port.

struct IO_CONTEXT
{
    SOCKET          m_hAsyncIO;
    OVERLAPPED      m_Overlapped;
    LIST_ENTRY      m_ListEntry;
    IO_TYPE         m_ConType;
    PPOP3_CONTEXT   m_pPop3Context;
    DWORD           m_dwLastIOTime;
    DWORD           m_dwConnectionTime;
    LONG            m_lLock;
    CALLBACKFUNC    m_pCallBack;
    char            m_Buffer[POP3_REQUEST_BUF_SIZE];
}; 


typedef IO_CONTEXT *PIO_CONTEXT;



#endif //__POP3_IO_CONTEXT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\iolists.h ===
/************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

File Name:      IOLists.cpp
Abstract:       Declare the CLists class, a double linked list.
Notes:          
History:        08/01/2001 Created by Hao Yu (haoyu)

************************************************************************************************/

#ifndef __POP3_IOLIST__
#define __POP3_IOLIST__

#include <IOContext.h>


class CIOList
{
private:
    LIST_ENTRY          m_ListHead;
    PLIST_ENTRY         m_pCursor;
    DWORD               m_dwListCount;
    CRITICAL_SECTION    m_csListGuard;
public:
    CIOList();
    ~CIOList();
    void AppendToList(PLIST_ENTRY pListEntry);
    DWORD RemoveFromList(PLIST_ENTRY pListEntry);
    DWORD CheckTimeOut(DWORD dwTimeOutInterval, BOOL *pbIsAnyOneTimedOut=NULL);
    void Cleanup();
};

#endif //__POP3_IOLIST__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\ntauth.cpp ===
/************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

File Name:      NTAuth.cpp
Abstract:       Implementation of CAuthServer class to do NTLM/Kerberos authentication
Notes:          
History:        10/10/2001 Created by Hao Yu (haoyu)

************************************************************************************************/

#include "stdafx.h"
#include "NTAuth.h"
#include "uuencode.h"
#include <atlbase.h>


//Initialize static members
long CAuthServer::m_glInit=0;
PSecurityFunctionTable CAuthServer::m_gpFuncs=NULL;
HINSTANCE CAuthServer::m_ghLib=NULL;
IP3Config *CAuthServer::m_gpIConfig=NULL;

//Static fuction to load SSPI Provider function table
HRESULT CAuthServer::GlobalInit()
{
    HRESULT hr=S_OK;
    FARPROC pInit=NULL;
    PSecPkgInfo pPkgInfo;
    if( 0==InterlockedCompareExchange(&m_glInit, 2, 0))
    {
        //Initialization needed
        TCHAR tszWinDir[MAX_PATH+sizeof(NT_SEC_DLL_NAME)+1]; 
        if(0!=GetWindowsDirectory(tszWinDir, MAX_PATH+1))
        {
            tszWinDir[MAX_PATH]=0;
            _tcscat(tszWinDir, NT_SEC_DLL_NAME );           
            m_ghLib=LoadLibrary(tszWinDir);
            if(NULL == m_ghLib)
            {
                hr=HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            hr=E_FAIL;
        }
        if(S_OK==hr)
        {
            pInit=GetProcAddress(m_ghLib, SECURITY_ENTRYPOINT_ANSI);
            if(NULL == pInit)
            {
                hr=HRESULT_FROM_WIN32(GetLastError());
            }
        }

        if(S_OK==hr)
        {
            m_gpFuncs = (PSecurityFunctionTable) pInit();
            if(NULL == m_gpFuncs)
            {
                hr=HRESULT_FROM_WIN32(GetLastError());
            }
        }
        
        if(S_OK==hr)
        {
            //Make sure the security package is available
            if(SEC_SUCCESS(m_gpFuncs->QuerySecurityPackageInfo(NTLM_PACKAGE, 
                                                                       &pPkgInfo)))
            {
                m_gpFuncs->FreeContextBuffer(pPkgInfo);
            }
            else
            {
                hr=E_FAIL;
            }
        }
        if(S_OK==hr)
        {
            //To circumvent the ADsGetObject leak
            hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &m_gpIConfig ));
        }

        if(S_OK==hr)
        {
            //Set the flag to be 1
            InterlockedExchange(&m_glInit, 1);
        }
        else
        {
            //Cleanup
            m_gpFuncs=NULL;
            if(NULL != m_ghLib)
            {
                FreeLibrary(m_ghLib);
                m_ghLib=NULL;
            }
            //Set the falg to be 0
            InterlockedExchange(&m_glInit, 0);
        }

    }
    else
    {
        while(1!=m_glInit)
        {
            Sleep(50); //Wait for the initialization to be done
        }
    }

    return hr;
    
}    

void CAuthServer::GlobalUninit()
{

    long lRet=InterlockedCompareExchange(&m_glInit, -1, 1);
    switch (lRet)
    {
    case 2:while(1!=m_glInit)
           {
               Sleep(50);
           }
    case 1:m_gpFuncs=NULL;
           if(NULL != m_ghLib)
           {
               FreeLibrary(m_ghLib);
               m_ghLib=NULL;
           }
           if(m_gpIConfig!=NULL)
           {
               m_gpIConfig->Release();
               m_gpIConfig=NULL;
           }
           break;
    case 0://Nothing needed to be done
    default: break;
    };
}



CAuthServer::CAuthServer()
{

    m_bInit=FALSE;
    m_bHaveSecContext=FALSE;
    m_bFirstCall=TRUE;

}


CAuthServer::~CAuthServer()
{
    Cleanup();    
}

void CAuthServer::Cleanup()
{
    if(NULL != m_gpFuncs)
    {

        if(m_bInit)
        {
            m_bInit=FALSE;
			m_bFirstCall=TRUE;
            m_gpFuncs->FreeCredentialHandle(&m_hCredHandle);
            if(m_bHaveSecContext)
            {
                m_bHaveSecContext=FALSE;
                m_gpFuncs->DeleteSecurityContext(&m_hSecContext);
            }    
        }
    }
    else
    {
        //This should never happen!
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               EVENT_POP3_UNEXPECTED_ERROR);
    }
}


HRESULT CAuthServer::InitCredential()
{
    HRESULT hr=S_OK;
    SECURITY_STATUS status;
    TimeStamp tsExpire;
    if(!m_bInit)
    {
        if(m_glInit!=1)
        {
            hr=GlobalInit();
        }
        if(S_OK == hr )
        {
            if(!m_bInit)
            {
                status = m_gpFuncs->AcquireCredentialsHandle(
                                NULL,
                                NTLM_PACKAGE,
                                SECPKG_CRED_INBOUND, 
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                &m_hCredHandle,
                                &tsExpire);
                if(SEC_E_OK != status)
                {
                    hr=E_FAIL;
                }
                else
                {
                    m_bInit=TRUE;
                }
            }
        }
    }
    return hr;
}



HRESULT CAuthServer::HandShake(LPBYTE pInBuf, 
                             DWORD cbInBufSize,
                             LPBYTE pOutBuf,
                             PDWORD pcbOutBufSize)
{
    HRESULT hr=S_OK;
    SECURITY_STATUS status;
    TimeStamp tsExpire;
    ULONG ulContextAttributes;
    BUFFER uuBuf;
    DWORD cbDecoded=0;
    BYTE pBuf[AUTH_BUF_SIZE];
    SecBufferDesc OutBuffDesc; 
    SecBuffer OutSecBuff; 
    SecBufferDesc InBuffDesc; 
    SecBuffer InSecBuff; 
    if( (NULL == pInBuf)  ||
        (NULL == pOutBuf) ||
        (NULL == pcbOutBufSize) )
    {
        return E_INVALIDARG;
    }
    if(!m_bInit)
    {
        hr = InitCredential();
    }

    uuBuf.pBuf=pBuf;
    uuBuf.cLen=AUTH_BUF_SIZE;
    if( !uudecode((char *)pInBuf, &uuBuf, &cbDecoded))
    {
        hr=E_FAIL;
    }

    if( S_OK == hr )
    {

        OutBuffDesc.ulVersion = 0; 
        OutBuffDesc.cBuffers = 1; 
        OutBuffDesc.pBuffers = &OutSecBuff;  

        OutSecBuff.cbBuffer = *pcbOutBufSize;
        OutSecBuff.BufferType = SECBUFFER_TOKEN;
        OutSecBuff.pvBuffer = pOutBuf; 

        InBuffDesc.ulVersion = 0; 
        InBuffDesc.cBuffers = 1; 
        InBuffDesc.pBuffers = &InSecBuff; 

        InSecBuff.cbBuffer = cbDecoded;//cbInBufSize; 
        InSecBuff.BufferType = SECBUFFER_TOKEN; 
        InSecBuff.pvBuffer = pBuf;//pInBuf; 

        status = m_gpFuncs->AcceptSecurityContext (
                        &m_hCredHandle,       
                        m_bFirstCall? NULL:&m_hSecContext,
                        &InBuffDesc, 
                        0,
                        SECURITY_NETWORK_DREP, 
                        &m_hSecContext, 
                        &OutBuffDesc, 
                        &ulContextAttributes, 
                        &tsExpire ); 
        if( !SEC_SUCCESS(status) )
        {
            hr=E_FAIL;
        }
        else
        {
            m_bHaveSecContext=TRUE;
            m_bFirstCall=FALSE;
        }

        

        switch(status)
        {
        
        case SEC_E_OK:hr=S_OK;
                      break;
        case SEC_I_CONTINUE_NEEDED:hr=S_FALSE;
                                   break;
        case SEC_I_COMPLETE_AND_CONTINUE:hr=S_FALSE; 
                                         //Continue to do the following
        case SEC_I_COMPLETE_NEEDED:if(m_gpFuncs->CompleteAuthToken)
                                   {
                                       status=m_gpFuncs->CompleteAuthToken(
                                               &m_hSecContext,
                                               &OutBuffDesc);
                                       if( !(SEC_SUCCESS(status)) )
                                       {
                                           hr=E_FAIL;
                                       }
                                   }
                                   else
                                   {
                                       hr=E_FAIL;
                                   }
                                   break;            
        default: hr=E_FAIL;
        }
        
    }

    if(SUCCEEDED(hr))
    {
        uuBuf.cLen=AUTH_BUF_SIZE;
        if(OutSecBuff.cbBuffer > (AUTH_BUF_SIZE-5)*2/3) 
        {
            //This is the case where the buffer is not big 
            // enough
            hr=E_OUTOFMEMORY;
        }
        else
        {
            if(uuencode(pOutBuf, OutSecBuff.cbBuffer, &uuBuf))
            {
                pOutBuf[AUTH_BUF_SIZE-1]=0;
                if( 0>_snprintf((char *)pOutBuf,
                                AUTH_BUF_SIZE-1,
                                "+ %s\r\n", 
                                (char *)(uuBuf.pBuf)) )
                {
                    hr=E_FAIL;
                }
                else
                {
                    *pcbOutBufSize=strlen((char *)pOutBuf);
                }
            }
            else
            {
                hr=E_FAIL;
            }
        }
    }
    if(FAILED(hr))
    {
        if(m_bHaveSecContext)
        {
            m_gpFuncs->DeleteSecurityContext(&m_hSecContext);
            m_bHaveSecContext=FALSE;
            m_bFirstCall=TRUE;
        }
    }

    return hr;
}
        
HRESULT CAuthServer::GetUserName(WCHAR *wszUserName)
{
    SecPkgContext_Names SecUserName;
    SECURITY_STATUS status;
    WCHAR *pUserName=NULL;
    WCHAR *pAt=NULL;
    VARIANT var;
    VariantInit(&var);
    HRESULT hr=S_OK;
    if(NULL==wszUserName)
    {
        return E_POINTER;
    }
    if(!m_bHaveSecContext)
    {
        return E_FAIL;
    }

    
    status=QueryContextAttributes( &m_hSecContext,
                                   SECPKG_ATTR_NAMES,
                                   &SecUserName);
    if(SEC_E_OK != status)
    {
        return E_FAIL;
    }
    else
    {
        if(AUTH_AD==g_dwAuthMethod)
        {

            var.vt=VT_BSTR;
            var.bstrVal=SysAllocString(SecUserName.sUserName);
            if(NULL == var.bstrVal)
            {
                var.vt=VT_EMPTY;
                hr=E_OUTOFMEMORY;
            }
            else
            {
                hr=g_pAuthMethod->Get(SZ_EMAILADDR, &var);
                if(SUCCEEDED(hr))
                {
                   if(wcslen(var.bstrVal) < POP3_MAX_ADDRESS_LENGTH)
                   {
                       wcscpy(wszUserName, var.bstrVal);
                   }
                   else
                   {
                       hr=E_FAIL;
                   }
                }
            }
            
        }
        else //SAM case
        {

            pAt=wcschr(SecUserName.sUserName, L'\\');
            if(NULL == pAt)
            {
                pUserName=SecUserName.sUserName;
            }
            else
            {
                pUserName=pAt+1;
            }
            CComPtr<IP3Config> spIConfig;
            CComPtr<IP3Domains> spIDomains;
            hr = CoCreateInstance( __uuidof( P3Config ), NULL, CLSCTX_ALL, __uuidof( IP3Config ),reinterpret_cast<LPVOID *>( &spIConfig ));
            if( S_OK == hr )
            {
                if( S_OK== hr)
                {
                    hr = spIConfig->get_Domains( &spIDomains );
                }
            }
            if( S_OK == hr )
            {
                BSTR bstrDomainName=NULL;
                CComBSTR bstrUserName(pUserName);
                hr = spIDomains->SearchForMailbox(bstrUserName, &bstrDomainName);
                if ( S_OK == hr )
                {
                    if(0> _snwprintf(wszUserName, POP3_MAX_ADDRESS_LENGTH-1, L"%s@%s", pUserName, bstrDomainName) )
                    {
                        hr=E_FAIL;
                    }
                    wszUserName[POP3_MAX_ADDRESS_LENGTH-1]=L'\0';
                    SysFreeString(bstrDomainName);
                }
            }
        }

        m_gpFuncs->FreeContextBuffer(SecUserName.sUserName);
        VariantClear(&var);
        return hr;
    }

        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\iolists.cpp ===
/************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

File Name:      SocketPool.cpp
Abstract:       Implementation of the socket pool (CSocketPool class)
                and the callback function for IO Context. 
Notes:          
History:        08/01/2001 Created by Hao Yu (haoyu)

************************************************************************************************/

#include "stdafx.h"
#include <IOLists.h>
#include "POP3Context.h"

CIOList::CIOList()
{
    InitializeCriticalSection(&m_csListGuard);
    m_dwListCount=0;
    m_ListHead.Flink=&m_ListHead;
    m_ListHead.Blink=&m_ListHead;
    m_pCursor=&m_ListHead;
}

CIOList::~CIOList()
{
    DeleteCriticalSection(&m_csListGuard);
}


void CIOList::AppendToList(PLIST_ENTRY pListEntry)
{
    ASSERT(NULL != pListEntry);
    EnterCriticalSection(&m_csListGuard);
    pListEntry->Flink=&m_ListHead;
    pListEntry->Blink=m_ListHead.Blink;
    m_ListHead.Blink->Flink=pListEntry;
    m_ListHead.Blink=pListEntry;
    m_dwListCount++;
    LeaveCriticalSection(&m_csListGuard);
}

DWORD CIOList::RemoveFromList(PLIST_ENTRY pListEntry)
{
    if( (NULL == pListEntry) ||
        (NULL == pListEntry->Flink) ||
        (NULL == pListEntry->Blink) ||
        (m_dwListCount ==0) )
    {
        return ERROR_INVALID_DATA;
    }
    EnterCriticalSection(&m_csListGuard);
    pListEntry->Flink->Blink=pListEntry->Blink;
    pListEntry->Blink->Flink=pListEntry->Flink;
    m_dwListCount--;
    //In case the Timeout checking is on going.
    if(m_pCursor == pListEntry)
    {
        m_pCursor = pListEntry->Flink;
    }
    pListEntry->Flink=NULL;
    pListEntry->Blink=NULL;
    LeaveCriticalSection(&m_csListGuard);

    return ERROR_SUCCESS;
}



// Returns the waiting time of the socket that waited the longest
// but not yet timed out. 
DWORD CIOList::CheckTimeOut(DWORD dwTimeOutInterval,BOOL *pbIsAnyOneTimedOut)
{
    DWORD dwTime;
    DWORD dwNextTimeOut=0;  
    DWORD dwTimeOut=0;
    PIO_CONTEXT pIoContext;
    m_pCursor=m_ListHead.Flink;
    
    while(m_pCursor!=&m_ListHead)
    {
        EnterCriticalSection(&m_csListGuard);
        if(m_pCursor==&m_ListHead)
        {
            LeaveCriticalSection(&m_csListGuard);
            break;
        }           
        pIoContext=CONTAINING_RECORD(m_pCursor, IO_CONTEXT, m_ListEntry);
        ASSERT(NULL != pIoContext);

        if( UNLOCKED==InterlockedCompareExchange(&(pIoContext->m_lLock),LOCKED_FOR_TIMEOUT, UNLOCKED) )
        {            
            if(DELETE_PENDING!=pIoContext->m_ConType)
            {
                dwTime=GetTickCount();
                if(dwTime > pIoContext->m_dwLastIOTime )
                {
                    dwTimeOut=dwTime - pIoContext->m_dwLastIOTime;
                }
                else
                {
                    dwTimeOut=0;
                }

                if( ( dwTimeOut >= DEFAULT_TIME_OUT) ||  // Normal time out
                    ( ( dwTimeOut >= dwTimeOutInterval) &&  // DoS Time out
                      ( dwTimeOutInterval == SHORTENED_TIMEOUT) && 
                      ( pIoContext->m_pPop3Context->Unauthenticated()) ) )
                {                    
                    //This IO timed out 
                    ASSERT(NULL != pIoContext->m_pPop3Context);
                    m_pCursor=m_pCursor->Flink;
                    pIoContext->m_pPop3Context->TimeOut(pIoContext);
                    if(pbIsAnyOneTimedOut)
                        *pbIsAnyOneTimedOut=TRUE;
                }
                else
                {
                    if(dwNextTimeOut<dwTimeOut)
                    {
                        dwNextTimeOut=dwTimeOut;
                    }
                    m_pCursor=m_pCursor->Flink;
                }
            }
            else
            {
                m_pCursor=m_pCursor->Flink;
            }
            InterlockedExchange(&(pIoContext->m_lLock),UNLOCKED);
        }
        else 
        {
            m_pCursor=m_pCursor->Flink;
        }
        //Leave Critical Section so that other 
        //threads will get a chance to run.
        LeaveCriticalSection(&m_csListGuard);
    }
    return dwNextTimeOut;
}
        
void CIOList::Cleanup()
{
    PLIST_ENTRY pCursor=m_ListHead.Flink;
    PIO_CONTEXT pIoContext;
    EnterCriticalSection(&m_csListGuard);
    while(pCursor!=&m_ListHead)
    {
        pIoContext=CONTAINING_RECORD(pCursor, IO_CONTEXT, m_ListEntry);
        ASSERT(NULL != pIoContext);
        ASSERT(NULL != pIoContext->m_pPop3Context);
        pIoContext->m_pPop3Context->TimeOut(pIoContext);
        pCursor->Flink->Blink=pCursor->Blink;
        pCursor->Blink->Flink=pCursor->Flink;
        pCursor=pCursor->Flink;
        ASSERT(m_dwListCount >= 1);
        m_dwListCount--;
        //Delete the IO Context
        delete(pIoContext->m_pPop3Context);
        delete(pIoContext);        
    }
    
    m_pCursor=&m_ListHead;
    LeaveCriticalSection(&m_csListGuard);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\pop3svc.cpp ===
/************************************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:    POP3Svc.hxx.
Abstract:       Implement the CPop3Svc class. 
Notes:          
History:        
************************************************************************************************/
#include "stdafx.h"

#include <POP3Regkeys.h>
#include <isexchng.h>
#include <AuthID.h>
#include "pop3Auth_i.c"

// CService-derived class, must have this, as described in POP3Svc.hxx and Service.h
IMPLEMENT_SERVICE(CPop3Svc, POP3SVC)

BOOL CheckValidGreeting(WCHAR *wszGreeting)
{
    if(NULL==wszGreeting)
    {
        return TRUE;
    }
    while(L'\0'!= *wszGreeting)
    {
        if(!iswprint(*wszGreeting) || 
            (L'<'== (*wszGreeting))||
            (L'>'== (*wszGreeting)) )
        {
            return FALSE;
        }
        wszGreeting++;
    }
    return TRUE;
}



CPop3Svc::CPop3Svc(LPCTSTR szName, LPCTSTR szDisplay, DWORD dwType):
        CService(szName, szDisplay, dwType)
{
    // CService-derived class, must have this, as described in Service.h
    IMPLEMENT_STATIC_REFERENCE();
}

void CPop3Svc::Run()
{
    // Main service, do the timeout checking here
    DWORD dwTimeToWait=DEFAULT_TIME_OUT;
    DWORD dwWaitResult;
    HANDLE pHdArray[2]={m_hServiceEvent[STOP], g_hDoSEvent};
    BOOL bIsAnyTimedOut;
    while(1)
    {
        dwWaitResult=WaitForMultipleObjects(2, pHdArray,FALSE,dwTimeToWait);
        
        if(WAIT_TIMEOUT == dwWaitResult)
        {
            dwTimeToWait=DEFAULT_TIME_OUT - 
                         g_BusyList.CheckTimeOut(DEFAULT_TIME_OUT);
        }
        else if( WAIT_OBJECT_0 + 1 == dwWaitResult ) // g_hDoSEvent
        {
            ResetEvent(g_hDoSEvent);
            bIsAnyTimedOut=FALSE;
            DWORD dwRunCount=3; //Run this 3 times at most 
            while( (!bIsAnyTimedOut) && 
                g_SocketPool.IsMaxSocketUsed()
                && dwRunCount>0) //Extra check needed for the last connection
            {
                dwTimeToWait=DEFAULT_TIME_OUT-
                         g_BusyList.CheckTimeOut(SHORTENED_TIMEOUT, &bIsAnyTimedOut);
                dwRunCount--;
                Sleep(SHORTENED_TIMEOUT);
            }

        }
        else if( WAIT_OBJECT_0 == dwWaitResult ) //Shutdown
        {
            break;
        }
        else 
        {
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                                   EVENT_POP3_UNEXPECTED_ERROR);
            AbortService();
            break;
        }
    }

}


void CPop3Svc::OnStop(DWORD dwErrorCode)
{
    if(0 == dwErrorCode)
    {
        g_EventLogger.LogEvent(LOGTYPE_INFORMATION,
                           EVENT_POP3_SERVER_STOPPED);
    }
    else
    {
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                           EVENT_POP3_SERVER_STOP_ERROR, dwErrorCode);
    }
    g_dwServerStatus=SERVICE_STOPPED;
    SetStatus(SERVICE_STOPPED);
}

void CPop3Svc::OnAfterStart()
{
    //More operation should be added here
    SetStatus(SERVICE_RUNNING, 
              0, 
              0, 
              SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE);
    g_dwServerStatus=SERVICE_RUNNING;
    g_EventLogger.LogEvent(LOGTYPE_INFORMATION,
                           EVENT_POP3_SERVER_STARTED);
                           
}

void CPop3Svc::OnStopRequest()
{
    g_dwServerStatus=SERVICE_STOP_PENDING;
    SetStatus(SERVICE_STOP_PENDING, 1, 30000);
}


void CPop3Svc::PreInit()
{
   
    CService::PreInit();
    WCHAR wszMailRoot[POP3_MAX_MAILROOT_LENGTH];
    HKEY  hPop3Key;
    DWORD dwType=REG_DWORD;
    DWORD cbSize=sizeof(DWORD);
    DWORD dwThreadPerCPU=0;
    DWORD dwMaxSockets=0;
    DWORD dwMinSockets=0;
    DWORD dwPort=0;
    DWORD dwThreshold=0;
    DWORD dwBacklog=0;
    DWORD dwLoggingLevel=LOGGING_LEVEL_3;
    LONG  lErr;
    IAuthMethods *pAuthMethods=NULL;
    HRESULT hr=S_OK;
    VARIANT vCurAuth;
    VariantInit(&vCurAuth);
    DWORD dwSize=MAX_PATH;

    g_dwServerStatus=SERVICE_START_PENDING;
    if ( 0 == RegQueryLoggingLevel(dwLoggingLevel) )
    {
        if(dwLoggingLevel > LOGGING_LEVEL_3 )
        {
            dwLoggingLevel = LOGGING_LEVEL_3;
        }
    }
    
    if ( 0 != g_EventLogger.InitEventLog(POP3_SERVICE_NAME ,0, (LOGLEVEL)dwLoggingLevel) )
    {
       AbortService();
    }
    
    if (_IsExchangeInstalled())
    {
        //We can not start if Exchange is installed
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               POP3SVR_START_FAILED_EXCHANGE);

        AbortService();

    }
    //Init the PerfMon Conters

    hr= g_PerfCounters.HrInit(cntrMaxGlobalCntrs, 
                              szPOP3PerfMem,
                              POP3_SERVICE_NAME);

    if( S_OK != hr )
    {

        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               EVENT_POP3_NO_CONFIG_DATA);

        AbortService();

    }
    
    g_hShutDown=CreateEvent(NULL, TRUE, FALSE, NULL);
    if( NULL == g_hShutDown )
    {
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               POP3SVR_INIT_CREATE_EVENT_FAILED,
                               GetLastError());
        
        AbortService();
    }

    g_hDoSEvent=CreateEvent(NULL, TRUE, FALSE, NULL);
    if( NULL == g_hDoSEvent )
    {
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               POP3SVR_INIT_CREATE_EVENT_FAILED,
                               GetLastError());
        
        AbortService();
    }
    


    if( ERROR_SUCCESS== RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           POP3SERVICE_SERVICES_SUBKEY,
                           0,
                           KEY_READ,
                           &hPop3Key) )
    {
        lErr = RegQueryValueEx( hPop3Key, 
                                VALUENAME_THREADCOUNT,
                                NULL,
                                &dwType,
                                (LPBYTE)&dwThreadPerCPU,
                                &cbSize);
        if(ERROR_SUCCESS==lErr)
        {
            lErr = RegQueryValueEx( hPop3Key, 
                                    VALUENAME_MAX,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwMaxSockets,
                                    &cbSize);
        }
        if(ERROR_SUCCESS==lErr)
        {
            lErr = RegQueryValueEx( hPop3Key, 
                                    VALUENAME_MIN,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwMinSockets,
                                    &cbSize);
        }
        if(ERROR_SUCCESS==lErr)
        {
            lErr = RegQueryValueEx( hPop3Key, 
                                    VALUENAME_THRESHOLD,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwThreshold,
                                    &cbSize);
        }
        if(ERROR_SUCCESS==lErr)
        {
            lErr = RegQueryValueEx( hPop3Key, 
                                    VALUENAME_BACKLOG,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwBacklog,
                                    &cbSize);
        }
        if(ERROR_SUCCESS==lErr)
        {
            lErr = RegQueryValueEx( hPop3Key, 
                                    VALUENAME_PORT,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&dwPort,
                                    &cbSize);
            if (ERROR_SUCCESS!=lErr)
            {
                dwPort=110;
                lErr=ERROR_SUCCESS;
            }
            lErr = RegQueryValueEx( hPop3Key,
                                    VALUENAME_SOCK_VERSION,
                                    NULL,
                                    &dwType,
                                    (LPBYTE)&g_dwIPVersion,
                                    &cbSize);
            if (ERROR_SUCCESS!=lErr)
            {
                g_dwIPVersion=4;
                lErr=ERROR_SUCCESS;
            }

            lErr = RegQueryValueEx( hPop3Key,
                                  VALUENAME_MAXMSG_PERDOWNLOAD,
                                  NULL,
                                  &dwType,
                                  (LPBYTE) &g_dwMaxMsgPerDnld,
                                  &cbSize);
            if (ERROR_SUCCESS!=lErr)
            {
                g_dwMaxMsgPerDnld=DEFAULT_MAX_MSG_PER_DNLD;
                lErr=ERROR_SUCCESS;
            }
                                  
        }
        
        

        RegCloseKey(hPop3Key);

    }
    
    if( ERROR_SUCCESS == lErr )
    {
        lErr= RegQueryMailRoot( wszMailRoot, sizeof( wszMailRoot )/sizeof( WCHAR));
    }    
    
    if( ERROR_SUCCESS == lErr )
    {
        lErr= RegQueryGreeting( g_wszGreeting, sizeof(g_wszGreeting));
        if(ERROR_SUCCESS == lErr)
        {
            //All characters in the greetings must be valid
            if(!CheckValidGreeting(g_wszGreeting))
            {
                g_wszGreeting[0]=0;
            }
        }
        else
        {
            g_wszGreeting[0]=0;
        }
        lErr= RegQuerySPARequired(g_dwRequireSPA);
        if(ERROR_SUCCESS != lErr)
        {
            g_dwRequireSPA=0;
            lErr=ERROR_SUCCESS;
        }
    }

    if( ERROR_SUCCESS!=lErr )      
    {
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               EVENT_POP3_NO_CONFIG_DATA);

        AbortService();
    }

    if(0==UnicodeToAnsi(g_szMailRoot, sizeof(g_szMailRoot)/sizeof(char), wszMailRoot, -1))
    {
        //We limit the mailroot to be less than POP3_MAX_MAILROOT_LENGTH characters
        //in all languages.
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               EVENT_POP3_NO_CONFIG_DATA);
        AbortService();
    }
    if( !CMailBox::SetMailRoot(wszMailRoot) )
	{
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               EVENT_POP3_NO_CONFIG_DATA);
		AbortService();
	}
	dwSize=sizeof(g_wszComputerName)/sizeof(WCHAR);
    if( !GetComputerNameExW(ComputerNameDnsFullyQualified, 
                            g_wszComputerName,                    
                            &dwSize))
    {
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               EVENT_POP3_NO_CONFIG_DATA);
        AbortService();
    }

    if( FAILED(CoInitializeEx(NULL, COINIT_MULTITHREADED)) )
    {
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               EVENT_POP3_COM_INIT_FAIL);
        AbortService();
    }

    hr=CoCreateInstance(CLSID_AuthMethods,
                        NULL,
                        CLSCTX_INPROC_SERVER,
                        IID_IAuthMethods,
                        (LPVOID *)&pAuthMethods);
    if(SUCCEEDED(hr))
    {
        hr=pAuthMethods->get_CurrentAuthMethod(&vCurAuth);
        if(SUCCEEDED(hr))
        {
            hr=pAuthMethods->get_Item(vCurAuth, &g_pAuthMethod);                    
            if(FAILED(hr) || NULL == g_pAuthMethod)
            {
                g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                                       POP3SVR_INIT_AUTH_METHOD_FAILED);

                AbortService();
            }

        }
        else
        {
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                                   POP3SVR_AUTH_METHOD_INVALID);

            AbortService();
        }

        BSTR bstrAuthMethod=NULL;
        hr=g_pAuthMethod->get_ID(&bstrAuthMethod);
        if(SUCCEEDED(hr))
        {
            if(0==wcscmp(bstrAuthMethod,SZ_AUTH_ID_LOCAL_SAM))
            {
                g_dwAuthMethod=AUTH_LOCAL_SAM;
            }
            else if(0==wcscmp(bstrAuthMethod,SZ_AUTH_ID_DOMAIN_AD))
            {
                g_dwAuthMethod=AUTH_AD;
            }
            else
            {
                g_dwAuthMethod=AUTH_OTHER;
            }
            SysFreeString(bstrAuthMethod);
        }
        pAuthMethods->Release();
    }
    else //CoCreate Failed
    {
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                                   POP3SVR_INIT_AUTH_METHOD_FAILED);
        AbortService();        
    }
    //Some Auth methods may not need these
    //Ignore return values.
    VARIANT vMailRoot;
    vMailRoot.vt=VT_BSTR;
    vMailRoot.bstrVal=SysAllocString(wszMailRoot);
    
    if(NULL == vMailRoot.bstrVal) 
    {
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL, 
                               POP3SVR_NOT_ENOUGH_MEMORY);
        AbortService();
    }

    g_pAuthMethod->Put(SZ_PROPNAME_MAIL_ROOT, vMailRoot);
    VariantClear(&vMailRoot);

    //Initialize the NTLM\Kerberos
    hr=CAuthServer::GlobalInit();
    if(S_OK!=hr)
    {
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               POP3SVR_NO_SECURITY_INIT_FAIL,hr);
        AbortService();
    }


    if( !g_ThreadPool.Initialize(dwThreadPerCPU) )
    {
        //Eventlogging is done in the thread pool code
        AbortService();
    }
    if( !g_SocketPool.Initialize(dwMaxSockets,
                                 dwMinSockets,
                                 dwThreshold,
                                 dwPort,
                                 dwBacklog) )
    {
        AbortService();
    }

}

void CPop3Svc::DeInit()
{
     g_ThreadPool.Uninitialize();
     g_SocketPool.Uninitialize();
     g_BusyList.Cleanup();
     g_FreeList.Cleanup();

     //The following must be called after all
     //Pop3Context are released
     CAuthServer::GlobalUninit();
     if(NULL != g_pAuthMethod)
     {
         g_pAuthMethod->Release();
         g_pAuthMethod=NULL;
     }
     //Shutdown perf conters
     g_PerfCounters.Shutdown();
     CoUninitialize();

     //Signal the watch thread to stop
     SetEvent(g_hShutDown);

     
     CService::DeInit();
     CloseHandle(g_hShutDown);
     CloseHandle(g_hDoSEvent);
     OnStop(ERROR_SUCCESS);
}

void CPop3Svc::OnPause()
{
    g_dwServerStatus=SERVICE_PAUSED;
    SetStatus(SERVICE_PAUSED);
}

void CPop3Svc::OnContinueRequest()
{
    g_dwServerStatus=SERVICE_RUNNING;
    SetStatus(SERVICE_RUNNING);
    //Since no new sockets are created when service is paused,
    //We need to check in new sockets are needed
    if( g_SocketPool.IsMoreSocketsNeeded() )
    {
        if(!g_SocketPool.AddSockets())
        {
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,POP3SVR_CREATE_ADDITIONAL_SOCKET_FAILED);
        }                
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\pop3context.h ===
/************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

File Name:      IOContext.hxx
Abstract:       Declare the POP3_CONTEXT Class
Notes:          
History:        08/01/2001 Created by Hao Yu (haoyu)

************************************************************************************************/


#ifndef __POP3_CONTEXT_H__
#define __POP3_CONTEXT_H__
#include <IOContext.h>
#include "Mailbox.h"
#include <NTAuth.h>

#define INIT_STATE  0   
#define AUTH_STATE  1
#define TRANS_STATE 2
#define UPDATE_STATE 3
#define MD5_HASH_SIZE 32
#define MAX_INT_LEN 9
#define SZ_NTLM "NTLM"

#define RESP_INVALID_MAIL_NUMBER    "-ERR No such message\r\n"
#define RESP_SERVER_NOT_AVAILABLE   "-ERR Service is not available\r\n"
#define RESP_UNKNOWN_COMMAND        "-ERR Unacceptable command\r\n"
#define RESP_OK                     "+OK\r\n"
#define RESP_SERVER_ERROR           "-ERR server error\r\n"
#define RESP_SERVER_READY           "+OK %S %S ready.\r\n"
#define RESP_SERVER_QUIT	        "+OK %S %S signing off.\r\n"
#define RESP_ACCOUNT_ERROR          "-ERR Logon Failure\r\n"
#define RESP_END_OF_MULTILINE       "\r\n.\r\n"
#define RESP_END_OF_LIST            ".\r\n"
#define RESP_MSG_MARKED_DELETED     "+OK Message marked as deleted\r\n"
#define RESP_AUTH_DONE              "+OK User successfully logged on\r\n"
#define RESP_AUTH_METHODS           "+OK\r\n" SZ_NTLM RESP_END_OF_MULTILINE
#define RESP_CMD_NOT_VALID          "-ERR Command not valid\r\n"
#define RESP_CMD_NOT_SUPPORTED      "-ERR Command is not valid in this state\r\n"
#define RESP_INVALID_LENGTH         "-ERR Invalid message Length\r\n"
#define RESP_RESET                  "+OK Messages unmarked as deleted\r\n"
#define RESP_NO_USER_NAME           "-ERR No username\r\n"
#define RESP_SPA_REQUIRED           "-ERR SPA Required, use AUTH or APOP\r\n"
#define RESP_SERVER_GREETING        L"Microsoft Windows POP3 Service Version 1.0"

#define ERR_NO_SUCH_MSG             0xf0000001
#define ERR_MSG_ALREADY_DELETED     0xf0000002
#define ERR_CAN_NOT_OPEN_FILE       0xf0000003
#define ERR_CAN_NOT_SET_FILE_CURSOR 0xf0000004

#define AUTH_OTHER 0
#define AUTH_AD 1
#define AUTH_LOCAL_SAM 2
#define MAX_FAILED_AUTH 3
#define COMMAND_SIZE 4
const int ciCommandSize[]={4,4,4,4,4,4,4,4,4,4,4,3,4};

const char cszCommands[][5]={"STAT",
                             "LIST",
                             "RETR",
                             "DELE",
                             "NOOP",
                             "RSET",
                             "QUIT",
                             "USER",
                             "PASS",
                             "UIDL",
                             "APOP",
                             "TOP",
                             "AUTH"};

typedef enum enumCommand
{
    CMD_STAT=0,
    CMD_LIST=1,
    CMD_RETR=2,
    CMD_DELE=3,
    CMD_NOOP=4,
    CMD_RSET=5,
    CMD_QUIT=6,
    CMD_USER=7,
    CMD_PASS=8,
    CMD_UIDL=9,
    CMD_APOP=10,
    CMD_TOP=11,
    CMD_AUTH=12,
    CMD_UNKNOWN
}POP3_CMD;





class POP3_CONTEXT
{
    DWORD m_dwCurrentState;
    BOOL  m_bFileTransmitPending;
    BOOL  m_bCommandComplete;
    DWORD m_dwCommandSize;
    char  m_szCommandBuffer[POP3_REQUEST_BUF_SIZE];
    WCHAR m_wszUserName[POP3_MAX_ADDRESS_LENGTH];
    char  m_szDomainName[POP3_MAX_DOMAIN_LENGTH];
    char  m_szPassword[MAX_PATH];
    WCHAR m_wszGreeting[MAX_PATH + 64];
    int   m_cPswdSize;
    CMailBox m_MailBox;
    IO_CONTEXT *m_pIoContext;
    CAuthServer m_AuthServer;
    DWORD m_dwAuthStatus;
    DWORD m_dwFailedAuthCount;
public:

    POP3_CONTEXT();
    ~POP3_CONTEXT();
    void TimeOut(IO_CONTEXT *pIoContext);
    void ProcessRequest(IO_CONTEXT *pIOContext,
                        OVERLAPPED *pOverlapped,
                        DWORD dwBytesRcvd);
    void WaitForCommand();
    void SendResponse(char *szBuf);
    void SendResponse(DWORD dwResult, char *szBuf);
    void Reset();
    BOOL Unauthenticated();
private:
    POP3_CMD ParseCommand();
    BOOL ProcessAuthStateCommands(POP3_CMD CurrentCmd,
                                  DWORD dwBytesRcvd);
    BOOL ProcessTransStateCommands(POP3_CMD CurrentCmd,
                                  DWORD dwBytesRcvd);
    void TerminateConnection(PIO_CONTEXT pIoContext); 
    BOOL GetNextStringParameter(char *szInput, char *szOutput, DWORD dwOutputSize);
    BOOL GetNextNumParameter(char **pszInput, int *piOutout);
    BOOL IsEndOfCommand(char *szInput);

};

typedef POP3_CONTEXT * PPOP3_CONTEXT;    


#endif //__POP3_CONTEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\pop3svcmain.cpp ===
/************************************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name: Pop3SvcMain.cpp
Abstract:    Defines the entry-point for the Pop3Svc Service.
Author:      Luciano Passuello (lucianop), 01/25/2001  
             Modified from original code from IMB Service

************************************************************************************************/

#include "stdafx.h"
#include "ServiceSetup.h"
#include "Resource.h"

// What is the executable being run for?
enum ServiceMode {SERVICE_RUN, SERVICE_INSTALL, SERVICE_REMOVE};

// prototypes
ServiceMode GetServiceMode();
void RunService(LPCTSTR tszServiceName, LPCTSTR tszDisplayName);
void InstallService(LPCTSTR tszServiceName, LPCTSTR tszDisplayName, LPCTSTR tszDescription);
void RemoveService(LPCTSTR tszServiceName, LPCTSTR tszDisplayName);


/************************************************************************************************
Function:       WinMain, global
Description:    Entry-point for the application.
Arguments:      See WinMain documentation.
History:        01/26/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE /*hPrevInstance*/, LPSTR /*lpCmdLine*/, int /*nCmdShow*/)
{
    // load necessary data about the service
    TCHAR tszDescription[nMaxServiceDescLen+1];
    TCHAR tszDisplayName[nMaxServiceDescLen+1];
    if(0 == LoadString(hInstance, IDS_DESCRIPTION, tszDescription, nMaxServiceDescLen))
    {
        return 1;
    }
    if(0 == LoadString(hInstance, IDS_DISPLAYNAME, tszDisplayName, nMaxServiceDescLen))
    {
        return 1;
    }
    
    // parse the command line and identify what action to perform
    ServiceMode sm = GetServiceMode();

    switch(sm)
    {
    case SERVICE_RUN:
        RunService(POP3_SERVICE_NAME, tszDisplayName);
        break;
    case SERVICE_INSTALL:
        InstallService(POP3_SERVICE_NAME, tszDisplayName, tszDescription);
        break;
    case SERVICE_REMOVE:
        RemoveService(POP3_SERVICE_NAME, tszDisplayName);
        break;
    }

    return 0;
}


/************************************************************************************************
Function:       GetServiceMode, global
Synopsis:       Parses the command line and returns the running mode for the service.
Notes:          
History:        01/26/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
ServiceMode GetServiceMode()
{
    // gets the command line, parses it and returns what is to be done
    TCHAR *tszCommandLine = GetCommandLine();
    CharLowerBuff(tszCommandLine, _tcslen(tszCommandLine));

    if(_tcsstr(tszCommandLine, _T("-install")))
    {
        return SERVICE_INSTALL;
    }
    else if(_tcsstr(tszCommandLine, _T("-remove")))
    {
        return SERVICE_REMOVE;
    }
    else
    {
        // unrecognized command line parameters translate to "RUN", too.
        return SERVICE_RUN;
    }
}

/************************************************************************************************
Function:       RunService, global
Description:    Main processing when the service is being executed in running mode.
Arguments:      [tszServiceName] - unique short name of the service 
                [tszDisplayName] - service name as it will appear to users in the SCM.
Notes:
History:        01/26/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void RunService(LPCTSTR tszServiceName, LPCTSTR tszDisplayName)
{
    ASSERT(!(NULL == tszServiceName));
    ASSERT(!(NULL == tszDisplayName));
    
    // creates the service-wrapper class
    CPop3Svc POP3SVC(tszServiceName, tszDisplayName, SERVICE_WIN32_SHARE_PROCESS );

    // initializes the control handlers with the SCM and starts the processing threads
    // See CService design
    BEGIN_SERVICE_MAP
        SERVICE_MAP_ENTRY(CPop3Svc, POP3SVC)
    END_SERVICE_MAP

}



/************************************************************************************************
Function:       InstallService, global
Description:    Main processing when the service is running in install mode.
Arguments:      [tszServiceName] - unique short name of the service 
                [tszDisplayName] - service name as it will appear to users in the SCM.
                [tszDescription] - long description of the service (available in the SCM)
Notes:          
History:        01/26/2001  Luciano Passuello (lucianop)        Created.
************************************************************************************************/
void InstallService(LPCTSTR tszServiceName, LPCTSTR tszDisplayName, LPCTSTR tszDescription)
{
    CServiceSetup cs(tszServiceName, tszDisplayName);
    cs.Install(tszDescription);
}


/************************************************************************************************
Function:       WinMain, global
Description:    Main processing when the service is running in remove mode.
Arguments:      [tszServiceName] - unique short name of the service 
                [tszDisplayName] - service name as it will appear to users in the SCM.
Notes:          
History:        01/26/2001  Luciano Passuello (lucianop)        Created.
************************************************************************************************/
void RemoveService(LPCTSTR tszServiceName, LPCTSTR tszDisplayName)
{
    CServiceSetup cs(tszServiceName, tszDisplayName);

    if(cs.IsInstalled())
    {
        cs.Remove(true);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\ntauth.h ===
/************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

File Name:      NTAuth.h
Abstract:       Defines the class to do NTLM authentication
Notes:          
History:        10/10/2001 Created by Hao Yu (haoyu)

************************************************************************************************/


#ifndef _POP3_NTAUTH_
#define _POP3_NTAUTH_


#define SECURITY_WIN32 
#include <security.h>
#define SEC_SUCCESS(Status) ((Status) >= 0)
#include <p3admin.h>

#define AUTH_BUF_SIZE 4096
#define NT_SEC_DLL_NAME _T("\\System32\\Secur32.dll")
#define NTLM_PACKAGE _T("NTLM")
class CAuthServer
{



public:

    CAuthServer();
    ~CAuthServer();
    HRESULT InitCredential();
    HRESULT HandShake(LPBYTE pInBuf, 
                    DWORD cbInBufSize,
                    LPBYTE pOutBuf,
                    PDWORD pcbOutBufSize);
    HRESULT GetUserName(WCHAR *wszUserName);
    void Cleanup();
    static HRESULT GlobalInit();
    static void GlobalUninit();
private:

    static long m_glInit;
    static PSecurityFunctionTable m_gpFuncs;
    static HINSTANCE m_ghLib;
    static IP3Config *m_gpIConfig;
    bool m_bInit;
    bool m_bFirstCall;
    bool m_bHaveSecContext;
    CredHandle m_hCredHandle;
    CtxtHandle m_hSecContext;

};


#endif //_POP3_NTAUTH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\pop3context.cpp ===
/************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

File Name:      Pop3Context.cpp
Abstract:       Implementation of the POP3_CONTEXT Class 
Notes:          
History:        08/01/2001 Created by Hao Yu (haoyu)

************************************************************************************************/

#include <stdafx.h>
#include <ThdPool.hxx>
#include <SockPool.hxx>
#include <POP3Context.h>

#ifdef ROCKALL3
void * __cdecl
operator new(size_t cb)
{
    void *const pv = g_RockallHeap.New(cb);
    return pv;
}


void __cdecl
operator delete(void *pv)
{
    g_RockallHeap.Delete(pv);
}
#endif

POP3_CONTEXT::POP3_CONTEXT()
{
    Reset();
}



POP3_CONTEXT::~POP3_CONTEXT()
{


}

void POP3_CONTEXT::Reset()
{
    m_dwCurrentState=INIT_STATE;
    m_bFileTransmitPending=FALSE;
    m_bCommandComplete=TRUE;
    m_dwCommandSize=0;
    m_wszUserName[0]=0;
    m_szPassword[0]=0;
    m_szDomainName[0]=0;
    m_szCommandBuffer[0]=0;
    m_cPswdSize=0;
    m_dwAuthStatus=0;
    m_dwFailedAuthCount=0;
    m_AuthServer.Cleanup();
}

void POP3_CONTEXT::TimeOut(IO_CONTEXT *pIoContext)
{
    TerminateConnection(pIoContext);
}

void POP3_CONTEXT::ProcessRequest(IO_CONTEXT *pIoContext,OVERLAPPED *pOverlapped,DWORD dwBytesRcvd)
{
     POP3_CMD CurrentCmd=CMD_UNKNOWN;
     char     szGreetingBuffer[MAX_PATH*2];
     LONG     lTotalMsgSize, lMsgCnt;
     char *pEndOfCmd=NULL;

     if( ( NULL == pIoContext) ||
         ( NULL == pIoContext->m_hAsyncIO) )
     {
         //This is a rare shutdown case.
         //IO completion received after socket is shut down.
         if(NULL!=pIoContext)
         {
            //Signal that the IO Context should be deleted/reused
            pIoContext->m_ConType = DELETE_PENDING;
         }
         return;
     }
     ASSERT( LOCKED_TO_PROCESS_POP3_CMD == pIoContext->m_lLock);
     m_pIoContext=pIoContext;

     //  BLaPorte - I moved transmit completion handling here to avoid confusion.

     // Check if this should be signal of TransmitFile completion
     if(m_bFileTransmitPending)
     {
         m_bFileTransmitPending=FALSE;
         //Here we calculate the perf on message size downloaded
         g_PerfCounters.AddPerfCntr(e_gcBytesTransmitted, dwBytesRcvd);
         g_PerfCounters.AddPerfCntr(e_gcBytesTransmitRate, dwBytesRcvd);

         WaitForCommand();
         return;
     }

     if(INIT_STATE == m_dwCurrentState)
     {
         if(SERVICE_RUNNING!=g_dwServerStatus)
         {
             //Reject the connection
             SendResponse(RESP_SERVER_NOT_AVAILABLE);
             TerminateConnection(pIoContext);
             return;
         }
         
         if( 0 > _snwprintf(m_wszGreeting,
                            sizeof(m_wszGreeting)/sizeof(WCHAR),
                            L"<%u@%s>", 
                            GetTickCount(), 
                            g_wszComputerName))
         {
             //Make sure length of <TimeStamp@Machine> is less than MAX_PATH
             m_wszGreeting[sizeof(m_wszGreeting)/sizeof(WCHAR)-1]=0;
             m_wszGreeting[sizeof(m_wszGreeting)/sizeof(WCHAR)-2]=L'>';
         }
         if(L'\0'!=g_wszGreeting[0])
         {
             _snprintf(szGreetingBuffer,
                       sizeof(szGreetingBuffer)/sizeof(char), 
                       RESP_SERVER_READY, 
                       g_wszGreeting, 
                       m_wszGreeting);
         }
         else
         {
             _snprintf(szGreetingBuffer, 
                       sizeof(szGreetingBuffer)/sizeof(char),
                       RESP_SERVER_READY,
                       RESP_SERVER_GREETING,
                       m_wszGreeting);
         }
         //Make sure the NULL is there
         szGreetingBuffer[sizeof(szGreetingBuffer)/sizeof(char)-1]=0;
         m_dwCurrentState=AUTH_STATE;
         g_PerfCounters.IncPerfCntr(e_gcAuthStateCnt);
         SendResponse(szGreetingBuffer);
         if(0==dwBytesRcvd)
         {
             WaitForCommand();
             return;
         }
     }

     //  BLaPorte - oversized/undersized data should be rejected immediately.

     if(dwBytesRcvd >= POP3_REQUEST_BUF_SIZE ||
        dwBytesRcvd == 0)
     {
         //Error this command is too big or is nil
         //Consider this is an attack or
         // termination of a connection unexpectedly.
         TerminateConnection(pIoContext);
         return;
     }

     if( g_SocketPool.IsMaxSocketUsed() ) //Possible DoS Attack situation
     {
         DWORD dwTime=GetTickCount();
         if(AUTH_STATE==m_dwCurrentState)
         {
             //The connection is not authenticated for twice the shorted timeout
             if(dwTime>m_pIoContext->m_dwConnectionTime+SHORTENED_TIMEOUT) //The connection is not authenticated   
             {
                 TerminateConnection(pIoContext);
                 return; //The connection will be terminated
             }
         }
     }


     // BLaPorte - moved the counter increment here since we do it in either case.

     g_PerfCounters.AddPerfCntr(e_gcBytesReceived, dwBytesRcvd);
     g_PerfCounters.AddPerfCntr(e_gcBytesReceiveRate, dwBytesRcvd);

     if(m_bCommandComplete)
     {

         m_dwCommandSize=dwBytesRcvd;
         memcpy(m_szCommandBuffer, m_pIoContext->m_Buffer,dwBytesRcvd);
     }
     else
     {
         if(m_dwCommandSize+dwBytesRcvd >= POP3_REQUEST_BUF_SIZE)
         {
             //Error this command is too big!
             //Consider this is an attack.
             TerminateConnection(pIoContext);
             return;
         }
         memcpy(m_szCommandBuffer+m_dwCommandSize, m_pIoContext->m_Buffer,dwBytesRcvd);
         m_dwCommandSize+=dwBytesRcvd;
     }
     m_szCommandBuffer[m_dwCommandSize]='\0';
     pEndOfCmd=strstr(m_szCommandBuffer,"\r\n");
     if(NULL == pEndOfCmd)
     {
         m_bCommandComplete=FALSE;
         WaitForCommand();
         return;
     }
     else
     {
         m_bCommandComplete=TRUE;
         *pEndOfCmd='\0'; //Cut the \r\n
         m_dwCommandSize-=2;
     }
     
     if(m_dwAuthStatus!=1)
     {
          CurrentCmd=ParseCommand();
     
         if(CMD_UNKNOWN == CurrentCmd)
         {
             // Count the bad commands?
             SendResponse(RESP_UNKNOWN_COMMAND);
             if(!g_SocketPool.IsMaxSocketUsed() )         
             {
                WaitForCommand();
             }
             else
             {
                TerminateConnection(pIoContext);
             }
             return;
         }
     }
     else
     {
         CurrentCmd=CMD_AUTH;
     }
     
     
     
     if(AUTH_STATE == m_dwCurrentState)
     {
         if(!ProcessAuthStateCommands(CurrentCmd,m_dwCommandSize))
         {
             TerminateConnection(pIoContext);
         }

     }
     else // TRANS_STATE == m_dwCurrentState
     {
         if(dwBytesRcvd == 0)
         {
             //Connection terminated
             TerminateConnection(pIoContext);
         }

         
 
         if(!ProcessTransStateCommands(CurrentCmd, m_dwCommandSize))
         {
             TerminateConnection(pIoContext);
         }
         
     }
    

}



void POP3_CONTEXT::WaitForCommand()
{
    int iRet;
    DWORD cbRevd=0;
    DWORD Flags=0;
    ASSERT( NULL != m_pIoContext);
    ASSERT( NULL != m_pIoContext->m_hAsyncIO);
    if(NULL == m_pIoContext->m_hAsyncIO)
    {
        TerminateConnection(m_pIoContext);
        return;
    }

    WSABUF wsaBuf={POP3_REQUEST_BUF_SIZE, m_pIoContext->m_Buffer};
    iRet=WSARecv(m_pIoContext->m_hAsyncIO,
                &wsaBuf,
                1,
                &cbRevd,
                &Flags,
                &(m_pIoContext->m_Overlapped),
                NULL);

    if(SOCKET_ERROR == iRet )
    {
        iRet=WSAGetLastError();
        if(iRet != ERROR_IO_PENDING )
        {
            //Problem with this connection
            //We terminate the connection
            TerminateConnection(m_pIoContext);
        }
    }
}


void POP3_CONTEXT::TerminateConnection(PIO_CONTEXT pIoContext)
{
    SOCKET hSocket;
    if(NULL!=pIoContext)
    {
        if(pIoContext->m_ConType != DELETE_PENDING)
        {
            m_MailBox.QuitAndClose();
            hSocket=(SOCKET)InterlockedExchange((LPLONG)( &(pIoContext->m_hAsyncIO)), NULL);
            if(NULL != hSocket )
            {
                closesocket(hSocket);
                g_SocketPool.DecrementTotalSocketCount();
                switch (m_dwCurrentState)
                {
                case UPDATE_STATE: 
                    break;
                case TRANS_STATE:
                    g_PerfCounters.DecPerfCntr(e_gcTransStateCnt);
                    break;
                case AUTH_STATE:
                    g_PerfCounters.DecPerfCntr(e_gcAuthStateCnt);
                    break;
                }
                g_PerfCounters.DecPerfCntr(e_gcConnectedSocketCnt);
            }
            if(!m_bFileTransmitPending)
            {
                pIoContext->m_ConType = DELETE_PENDING;
            }

        }
    }
}



POP3_CMD POP3_CONTEXT::ParseCommand()
{
    int i=0;
    if(strlen(m_szCommandBuffer) < COMMAND_SIZE-1)
    {
        return CMD_UNKNOWN;
    }
    //Check if any invalid characters
    for(i=0; i< m_dwCommandSize; i++)
    {
        if(!isprint(m_szCommandBuffer[i]))
        {
            return CMD_UNKNOWN;
        }
    }
    for(i=0; i< CMD_UNKNOWN; i++)
    {
        if( 0 == _strnicmp(m_szCommandBuffer, cszCommands[i], ciCommandSize[i]) )
        {
            return (POP3_CMD)i;
        }
    }
    return CMD_UNKNOWN;
}


BOOL POP3_CONTEXT::ProcessAuthStateCommands(POP3_CMD CurrentCmd,
                                            DWORD dwBytesRcvd)
{
     BOOL bRetVal=FALSE;
     char szBuf[POP3_RESPONSE_BUF_SIZE];
     char szUserName[POP3_MAX_ADDRESS_LENGTH];
     BSTR bstrUserName=NULL;
     szBuf[POP3_RESPONSE_BUF_SIZE-1]='\0';
     //  BLaPorte - wszPassword could potentially be used to concatenate 2 strings of length MAX_PATH + change.

     WCHAR wszPassword[2*MAX_PATH+32];
     HRESULT hr=E_FAIL;

     VARIANT vPassword;
     VariantInit(&vPassword);
     switch (CurrentCmd)
     {
     case CMD_USER: if( (m_szCommandBuffer[COMMAND_SIZE]!=' ') &&
                        (m_szCommandBuffer[COMMAND_SIZE]!='\0') )
                    {
                        SendResponse(RESP_UNKNOWN_COMMAND);
                    }
                    else if(g_dwRequireSPA)
                    {
                        SendResponse(RESP_SPA_REQUIRED);
                        bRetVal=TRUE;
                    }
                    else if(m_wszUserName[0] != 0 )
                    {
                        SendResponse(RESP_CMD_NOT_SUPPORTED);
                    }
                    else
                    {    
                        if(GetNextStringParameter(
                               &(m_szCommandBuffer[COMMAND_SIZE]),
                               szUserName,
                               sizeof(szUserName)/sizeof(char)))
                        {

                            AnsiToUnicode(szUserName, -1, m_wszUserName, sizeof(m_wszUserName)/sizeof(WCHAR));
                            SendResponse(RESP_OK);
                            bRetVal=TRUE;
                        }
                        else
                        {
                            SendResponse(RESP_CMD_NOT_VALID);
                        }
                    }
                    if(! g_SocketPool.IsMaxSocketUsed() )         
                    {
                        bRetVal=TRUE;
                    }                
                    break;
     case CMD_PASS:
                    //
                    // BLaPorte - make sure the password is cleared from the receive buffer.
                    //
                    SecureZeroMemory(m_pIoContext->m_Buffer,sizeof(m_pIoContext->m_Buffer));

                    if(m_wszUserName[0] == 0)
                    {
                        SendResponse(RESP_CMD_NOT_SUPPORTED);
                        if(! g_SocketPool.IsMaxSocketUsed() )         
                        {
                            bRetVal=TRUE;
                        }
                        break;
                    }
                    else //USER command alread issued
                    {
						if( (m_dwCommandSize == COMMAND_SIZE ) ||
                            ((m_dwCommandSize == COMMAND_SIZE +1) &&
                             (' '==m_szCommandBuffer[COMMAND_SIZE] )) )
						{
							//No password
							m_cPswdSize=0;
						}
						else
						{
							m_cPswdSize=m_dwCommandSize-COMMAND_SIZE-1;
                            if( (m_cPswdSize >= sizeof(m_szPassword)/sizeof(char)) ||
                                (' '!=m_szCommandBuffer[COMMAND_SIZE]) )
                            {
                                SendResponse(RESP_CMD_NOT_VALID);
                                m_wszUserName[0] = 0;
                                //
                                //  BLaPorte - Zero out command buffer so cleartext password isn't
                                //     lying around in memory.
                                //
                                SecureZeroMemory(m_szCommandBuffer,m_dwCommandSize);
                                if(! g_SocketPool.IsMaxSocketUsed() )         
                                {
                                    bRetVal=TRUE; 
                                }
                                break;
                            }
                            strncpy(m_szPassword, &(m_szCommandBuffer[COMMAND_SIZE+1]), sizeof(m_szPassword)/sizeof(char)-1); 
							m_szPassword[sizeof(m_szPassword)/sizeof(char)-1]=0;
                            SecureZeroMemory(m_szCommandBuffer,m_dwCommandSize);
                        }
                    }

                    //Do Authentication here
                    bstrUserName=SysAllocString(m_wszUserName);
                    AnsiToUnicode(m_szPassword, -1, wszPassword, sizeof(wszPassword)/sizeof(WCHAR));
                    //
                    //  BLaPorte - clear the password.
                    //
                    SecureZeroMemory(m_szPassword,sizeof(m_szPassword));

                    vPassword.vt=VT_BSTR;                        
                    if(0==m_cPswdSize)
                    {
                        vPassword.bstrVal=NULL;
                    }
                    else
                    {
                        vPassword.bstrVal=SysAllocString(wszPassword);
                        SecureZeroMemory(wszPassword,sizeof(wszPassword));
                    }
                    if(NULL != bstrUserName)
                    {
                        if(S_OK == ( hr= g_pAuthMethod->Authenticate(bstrUserName, vPassword)))
                        {
                            bRetVal=TRUE;
                        }
                        else if(E_ACCESSDENIED == hr )
                        {
                            g_EventLogger.LogEvent(LOGTYPE_ERR_WARNING,
                                   POP3SVR_MAILROOT_ACCESS_DENIED,
                                   m_wszUserName,
                                   1);
                        }

                    }
                    SysFreeString(bstrUserName);
                    if(NULL != vPassword.bstrVal)
                    {
                        SecureZeroMemory(vPassword.bstrVal,SysStringByteLen(vPassword.bstrVal));
                        SysFreeString(vPassword.bstrVal);
                    }
                    
                    //Open the mailbox
                    if(bRetVal)
                    {
                        bRetVal=m_MailBox.OpenMailBox(m_wszUserName);
                    }
                    if (bRetVal)
                    {
                        bRetVal=m_MailBox.LockMailBox();
                        if(bRetVal)
                        {
                            bRetVal=m_MailBox.EnumerateMailBox(g_dwMaxMsgPerDnld);
                            if(!bRetVal)
                            {
                                m_MailBox.UnlockMailBox();
                            }

                        }
                    }
                    else
                    {
                        //Open mailbox failed
                        if(ERROR_ACCESS_DENIED==GetLastError())
                        { //Log the event 
                            g_EventLogger.LogEvent(LOGTYPE_ERR_WARNING,
                                   POP3SVR_MAILROOT_ACCESS_DENIED, 
                                   m_wszUserName,
                                   1);
                        }
                    }
                            
                        
                    if (!bRetVal)
                    {
                        g_PerfCounters.IncPerfCntr(e_gcFailedLogonCnt);
                        m_dwFailedAuthCount++;
                        if( MAX_FAILED_AUTH<=m_dwFailedAuthCount )
                        {   
                            g_EventLogger.LogEvent(LOGTYPE_ERR_WARNING,
                                   POP3SVR_MAX_LOGON_FAILURES,
                                   m_wszUserName,
                                   1);
                        }
                        else
                        {
                            if(! g_SocketPool.IsMaxSocketUsed() )
                            {
                                bRetVal=TRUE; //Don't disconnect
                            }
                        }
                        SendResponse(RESP_ACCOUNT_ERROR);
                        m_wszUserName[0] = 0;
                    }
                    else
                    {                       
                        m_dwCurrentState=TRANS_STATE;
                        g_PerfCounters.DecPerfCntr(e_gcAuthStateCnt);
                        g_PerfCounters.IncPerfCntr(e_gcTransStateCnt);
                        SendResponse(RESP_AUTH_DONE);
                    }
                    break;
     case CMD_APOP: char *pPswd;

                    //
                    //  BLaPorte - Clear the receive buffer.
                    //
                    SecureZeroMemory(m_pIoContext->m_Buffer,sizeof(m_pIoContext->m_Buffer));

                    pPswd=strchr( &(m_szCommandBuffer[COMMAND_SIZE+1]), ' ');
                    if(NULL == pPswd)
                    {
                        SecureZeroMemory(m_szCommandBuffer,m_dwCommandSize);
                        SendResponse(RESP_ACCOUNT_ERROR);
                        if(! g_SocketPool.IsMaxSocketUsed() )         
                        {
                            bRetVal=TRUE;
                        }
                        break;
                    }
                    *pPswd='\0';

                    strncpy(szUserName, &(m_szCommandBuffer[COMMAND_SIZE+1]), sizeof(szUserName)/sizeof(char)-1);
					szUserName[sizeof(szUserName)/sizeof(char)-1]=0;
                    pPswd++;
                    strncpy(m_szPassword, pPswd, sizeof(m_szPassword)/sizeof(char)-1);
					m_szPassword[sizeof(m_szPassword)/sizeof(char)-1]=0;
                    SecureZeroMemory(m_szCommandBuffer,m_dwCommandSize);
                    if(strlen(m_szPassword) != MD5_HASH_SIZE )
                    {
                        SecureZeroMemory(m_szPassword,sizeof(m_szPassword));
                        SendResponse(RESP_ACCOUNT_ERROR);
                        if(! g_SocketPool.IsMaxSocketUsed() )         
                        {
                            bRetVal=TRUE;
                        }
                        break;
                    }

                    //Do the authentication 
                    AnsiToUnicode(szUserName, -1,m_wszUserName, sizeof(m_wszUserName)/sizeof(WCHAR));
                    bstrUserName=SysAllocString(m_wszUserName);
                    
                    AnsiToUnicode(m_szPassword, -1, wszPassword, sizeof(wszPassword)/sizeof(WCHAR));
                    SecureZeroMemory(m_szPassword,sizeof(m_szPassword));
                    wcscat(wszPassword, m_wszGreeting); 
                    vPassword.vt=VT_BSTR;                        
                    vPassword.bstrVal=SysAllocString(wszPassword);
                    SecureZeroMemory(wszPassword,sizeof(wszPassword));
                    if(NULL != bstrUserName &&
                       NULL != vPassword.bstrVal)
                    {
                        if(S_OK == (hr= g_pAuthMethod->Authenticate(bstrUserName, vPassword)))
                        {
                            bRetVal=TRUE;
                        }
                        else if(E_ACCESSDENIED == hr )
                        {
                            g_EventLogger.LogEvent(LOGTYPE_ERR_WARNING,
                                   POP3SVR_MAILROOT_ACCESS_DENIED,
                                   m_wszUserName,
                                   1);
                        }
 
                    }
                    SysFreeString(bstrUserName);
                    SecureZeroMemory(vPassword.bstrVal,SysStringByteLen(vPassword.bstrVal));
                    SysFreeString(vPassword.bstrVal);

                    //Open the mailbox
                    if(bRetVal)
                    {
                        bRetVal=m_MailBox.OpenMailBox(m_wszUserName);
                    }
                    if (bRetVal)
                    {
                        bRetVal=m_MailBox.LockMailBox();
                        if(bRetVal)
                        {
                            bRetVal=m_MailBox.EnumerateMailBox(g_dwMaxMsgPerDnld);
                            if(!bRetVal)
                            {
                                m_MailBox.UnlockMailBox();
                            }
                        }
                    }
                    else
                    {
                        //Open mailbox failed
                        if(ERROR_ACCESS_DENIED==GetLastError())
                        { //Log the event 
                            g_EventLogger.LogEvent(LOGTYPE_ERR_WARNING,
                                   POP3SVR_MAILROOT_ACCESS_DENIED,
                                   m_wszUserName,
                                   1);
                        }
                    }
                    if (!bRetVal)
                    {
                        g_PerfCounters.IncPerfCntr(e_gcFailedLogonCnt);
                        m_dwFailedAuthCount++;
                        if( MAX_FAILED_AUTH<=m_dwFailedAuthCount )
                        {
                            
                            g_EventLogger.LogEvent(LOGTYPE_ERR_WARNING,
                                   POP3SVR_MAX_LOGON_FAILURES,
                                   m_wszUserName,
                                   1);
                        }
                        else
                        {
                            if(! g_SocketPool.IsMaxSocketUsed() )
                            {
                                bRetVal=TRUE; //Don't disconnect
                            }
                        }
                        SendResponse(RESP_ACCOUNT_ERROR);
                    }
                    else
                    {
                        
                        m_dwCurrentState=TRANS_STATE;
                        g_PerfCounters.DecPerfCntr(e_gcAuthStateCnt);
                        g_PerfCounters.IncPerfCntr(e_gcTransStateCnt);
                        SendResponse(RESP_AUTH_DONE);

                    }
                    break;
     case CMD_AUTH: if(0==m_dwAuthStatus)
                    {
                        //First time AUTH command
                        //Only when AD/Local SAM Auth is used,
                        //we support NTLM 
                        if(AUTH_OTHER==g_dwAuthMethod)
                        {
                            SendResponse(RESP_CMD_NOT_SUPPORTED);
                            bRetVal=TRUE;
                        }
                        else
                        {
                            if(IsEndOfCommand(&(m_szCommandBuffer[COMMAND_SIZE])))
                            {
                                SendResponse(RESP_AUTH_METHODS);
                                bRetVal=TRUE;
                            }
                            else
                            {
                                szBuf[0]='\0';
                                if((GetNextStringParameter( &(m_szCommandBuffer[COMMAND_SIZE]),
                                                            szBuf,
                                                            POP3_RESPONSE_BUF_SIZE) ) &&
                                   (0==_stricmp(szBuf, SZ_NTLM)) )
                                {
                                    SendResponse(RESP_OK);
                                    m_dwAuthStatus=1;
                                    bRetVal=TRUE;
                                }
                                else
                                {
                                    SendResponse(RESP_CMD_NOT_VALID);
                                }
                            }
                        }
                        
                    }
                    else // This is specific to auth protocol
                    {
                        char OutBuf[AUTH_BUF_SIZE];
                        DWORD dwOutBufSize=AUTH_BUF_SIZE;
                        SecureZeroMemory(OutBuf, AUTH_BUF_SIZE);
                        hr=m_AuthServer.HandShake((LPBYTE)m_szCommandBuffer,
                                              dwBytesRcvd,
                                              (LPBYTE)OutBuf,
                                              &dwOutBufSize);
                        if(S_FALSE==hr)
                        {
                            SendResponse(OutBuf);
                            bRetVal=TRUE;
                        }
                        else if(S_OK==hr)
                        {
                            m_dwAuthStatus=0;
                            //Authentication Done!
                            if(S_OK==m_AuthServer.GetUserName(m_wszUserName))
                            {
                                bRetVal=TRUE;
                            }
                            else
                            {
                                bRetVal=FALSE;
                            }
                            //Now open the mailbox
                            if(bRetVal)
                            {
                                bRetVal=m_MailBox.OpenMailBox(m_wszUserName);
                            }
                            if (bRetVal)
                            {
                                bRetVal=m_MailBox.LockMailBox();
                                if(bRetVal)
                                {
                                    bRetVal=m_MailBox.EnumerateMailBox(g_dwMaxMsgPerDnld);
                                    if(!bRetVal)
                                    {
                                        m_MailBox.UnlockMailBox();
                                    }
                                }
                            }
                            else
                            {
                                //Open mailbox failed
                                if(ERROR_ACCESS_DENIED==GetLastError())
                                { //Log the event 
                                    g_EventLogger.LogEvent(LOGTYPE_ERR_WARNING,
                                           POP3SVR_MAILROOT_ACCESS_DENIED,
                                           m_wszUserName,
                                           1);
                                }
                            }
                            if (!bRetVal)
                            {
								m_dwAuthStatus=0;
								m_AuthServer.Cleanup();
                                g_PerfCounters.IncPerfCntr(e_gcFailedLogonCnt);
                                m_dwFailedAuthCount++;
                                SendResponse(RESP_ACCOUNT_ERROR);
                                if( (MAX_FAILED_AUTH>m_dwFailedAuthCount) &&
                                    (! g_SocketPool.IsMaxSocketUsed() ) )
                                {
                                    bRetVal=TRUE; //Don't disconnect
                                }
                            }
                            else
                            {                        
                                m_dwCurrentState=TRANS_STATE;
                                g_PerfCounters.DecPerfCntr(e_gcAuthStateCnt);
                                g_PerfCounters.IncPerfCntr(e_gcTransStateCnt);
                                SendResponse(RESP_AUTH_DONE);
                                bRetVal=TRUE;

                            }
                        }
                        else // Failed Auth
                        {
                            m_dwAuthStatus=0;
                            m_AuthServer.Cleanup();
                            g_PerfCounters.IncPerfCntr(e_gcFailedLogonCnt);
                            m_dwFailedAuthCount++;
                            SendResponse(RESP_CMD_NOT_VALID);
                            if( (MAX_FAILED_AUTH>m_dwFailedAuthCount) &&
                                (! g_SocketPool.IsMaxSocketUsed() ) )
                            {
                                bRetVal=TRUE; //Don't disconnect
                            }
                        }
                    }
                    break;
     case CMD_QUIT: if(IsEndOfCommand(&(m_szCommandBuffer[COMMAND_SIZE])))
                    {
                        g_PerfCounters.DecPerfCntr(e_gcAuthStateCnt);
                        m_dwCurrentState=UPDATE_STATE;
                        if(L'\0'!=g_wszGreeting[0])
                        {
                            _snprintf(szBuf, 
                                      POP3_RESPONSE_BUF_SIZE-1,
                                      RESP_SERVER_QUIT,
                                      g_wszGreeting,
                                      m_wszGreeting);
                        }
                        else
                        {
                            _snprintf(szBuf, 
                                      POP3_RESPONSE_BUF_SIZE-1,
                                      RESP_SERVER_QUIT,
                                      RESP_SERVER_GREETING,
                                      m_wszGreeting);
                        }
                        szBuf[POP3_RESPONSE_BUF_SIZE-1]=0;
                        SendResponse(szBuf);
                    }
                    else
                    {
                        SendResponse(RESP_CMD_NOT_VALID);
                        if(! g_SocketPool.IsMaxSocketUsed() )         
                        {
                            bRetVal=TRUE;
                        }
                    }
                    break;
    
     case CMD_STAT:
     case CMD_LIST:
     case CMD_RETR:
     case CMD_DELE:
     case CMD_UIDL:
     case CMD_RSET:
     case CMD_TOP: SendResponse(RESP_CMD_NOT_SUPPORTED);
                   if(! g_SocketPool.IsMaxSocketUsed() )         
                   {
                       bRetVal=TRUE;
                   }
                   break;
                    
     default:         //CountUnknownCommand?
                   SendResponse(RESP_UNKNOWN_COMMAND);
                   if(! g_SocketPool.IsMaxSocketUsed() )         
                   {
                       bRetVal=TRUE;// Still allow client to send another command
                   }
     }
     
     if(bRetVal)
     {
         WaitForCommand();
     }
     return bRetVal;
}



BOOL POP3_CONTEXT::ProcessTransStateCommands(POP3_CMD CurrentCmd,
                                             DWORD dwBytesRcvd)
{
    char szReBuf[POP3_RESPONSE_BUF_SIZE];
    char szReHelpBuf[POP3_RESPONSE_BUF_SIZE];
    DWORD dwLen=0;
    DWORD dwCurLen;
    BOOL bRetVal=TRUE;
    int iArg=-1;
    int iArg2=-1;
    int iMailCount=0;
    DWORD dwResult;
    char *pCur=NULL;
    //The buffer will always be NULL terminated
    szReBuf[POP3_RESPONSE_BUF_SIZE-1]='\0'; 
    switch (CurrentCmd)
    {
        case CMD_STAT:if(!IsEndOfCommand(&(m_szCommandBuffer[COMMAND_SIZE])))
                      {
                          SendResponse(RESP_CMD_NOT_VALID);
                      }
                      else if(0 >_snprintf(szReBuf,
                                      POP3_RESPONSE_BUF_SIZE-1,
                                      "+OK %d %d\r\n",
                                      m_MailBox.GetCurrentMailCount(),
                                      m_MailBox.GetTotalSize())) 
                      {
                          //This should not happen
                          //EventLog??
                          SendResponse(RESP_SERVER_ERROR);
                      }
                      else
                      {
                          szReBuf[POP3_RESPONSE_BUF_SIZE-1]=0;
                          SendResponse(szReBuf);
                      }
                      WaitForCommand();
                      break;
        case CMD_LIST:pCur=&(m_szCommandBuffer[COMMAND_SIZE]);
                      if(!IsEndOfCommand(pCur))
                      { 
                            
                          if( (GetNextNumParameter(&pCur, &iArg)) &&
                              (IsEndOfCommand(pCur)) )
                          {
                              dwResult=m_MailBox.ListMail(iArg-1, szReBuf, sizeof(szReBuf)/sizeof(char));
                              SendResponse(dwResult, szReBuf);
                          }
                          else
                          {
                              SendResponse(RESP_CMD_NOT_VALID);
                          }
                      }                       
                      else
                      {
                          if(0> _snprintf(szReBuf,
                                          POP3_RESPONSE_BUF_SIZE-1,
                                          "+OK %d messages (%d octets)\r\n",
                                          m_MailBox.GetCurrentMailCount(),
                                          m_MailBox.GetTotalSize()))
                          {
                              //This should not happen
                              //EventLog??
                              SendResponse(RESP_SERVER_ERROR);
                          }
                          else
                          {
                              
                              iMailCount=m_MailBox.GetMailCount();
                              dwLen=strlen(szReBuf);
                              for(iArg=0; iArg<iMailCount; iArg++)
                              {
                                  if(ERROR_SUCCESS==m_MailBox.ListMail(iArg, 
                                                                       szReHelpBuf,
																	   sizeof(szReHelpBuf)/sizeof(char)))
                                  {
                                      dwCurLen=strlen(szReHelpBuf);
                                      if(dwLen+dwCurLen< POP3_RESPONSE_BUF_SIZE )
                                      {
                                          strcat(szReBuf, szReHelpBuf);
                                          dwLen+=dwCurLen;
                                      }
                                      else
                                      {
                                          SendResponse(szReBuf);
                                          strcpy(szReBuf, szReHelpBuf);
                                          dwLen=dwCurLen;
                                      }
                                  }
                              }

                              if(dwLen+sizeof(RESP_END_OF_LIST)<POP3_RESPONSE_BUF_SIZE)
                              {
                                  strcat(szReBuf, RESP_END_OF_LIST);
                                  SendResponse(szReBuf);
                              }
                              else
                              {
                                  if(dwLen)
                                  {
                                      SendResponse(szReBuf);
                                  }
                                  SendResponse(RESP_END_OF_LIST);
                              }
                          }
                      }
                      WaitForCommand();  
                      break;
        case CMD_UIDL:pCur=&(m_szCommandBuffer[COMMAND_SIZE]);
                      if(!IsEndOfCommand(pCur))
                      { 
                            
                          if( (GetNextNumParameter(&pCur, &iArg)) &&
                              (IsEndOfCommand(pCur)) )
                          {
                              dwResult=m_MailBox.UidlMail(iArg-1, szReBuf, sizeof(szReBuf)/sizeof(char));
                              SendResponse(dwResult, szReBuf);
                          }
                          else
                          {
                              SendResponse(RESP_CMD_NOT_VALID);
                          }
                      }                       
                      else
                      {
                          if(0> _snprintf(szReBuf,
                                          POP3_RESPONSE_BUF_SIZE-1,
                                          "+OK %d messages (%d octets)\r\n",
                                          m_MailBox.GetCurrentMailCount(),
                                          m_MailBox.GetTotalSize()))
                          {
                              //This should not happen
                              //EventLog??
                              SendResponse(RESP_SERVER_ERROR);
                          }
                          else
                          {
                              iMailCount=m_MailBox.GetMailCount();
                              dwLen=strlen(szReBuf);
                          
                              for(iArg=0; iArg<iMailCount; iArg++)
                              {
                                  if(ERROR_SUCCESS==m_MailBox.UidlMail(iArg, 
                                                                       szReHelpBuf,
																	   sizeof(szReBuf)/sizeof(char)))
                                  {
                                      dwCurLen=strlen(szReHelpBuf);
                                      if(dwLen+dwCurLen< POP3_RESPONSE_BUF_SIZE )
                                      {
                                          strcat(szReBuf, szReHelpBuf);
                                          dwLen+=dwCurLen;
                                      }
                                      else
                                      {
                                          SendResponse(szReBuf);
                                          strcpy(szReBuf, szReHelpBuf);
                                          dwLen=dwCurLen;
                                      }
                                  }
                              }
                              if(dwLen+sizeof(RESP_END_OF_LIST)<POP3_RESPONSE_BUF_SIZE)
                              {
                                  strcat(szReBuf, RESP_END_OF_LIST);
                                  SendResponse(szReBuf);
                              }
                              else
                              {
                                  if(dwLen)
                                  {
                                      SendResponse(szReBuf);
                                  }
                                  SendResponse(RESP_END_OF_LIST);
                              }
                          }
                      }
                      WaitForCommand();  
                      break;
                     
        
        case CMD_RETR://RETR must hava one argument
                      pCur=&(m_szCommandBuffer[COMMAND_SIZE]);
                      if( (GetNextNumParameter(&pCur, &iArg)) &&
                              (IsEndOfCommand(pCur)) )
                      {
                          m_bFileTransmitPending=TRUE;
                          dwResult=m_MailBox.TransmitMail(m_pIoContext, iArg-1);
                          if(ERROR_SUCCESS != dwResult)
                          {

                              m_bFileTransmitPending=FALSE;
                              SendResponse(RESP_INVALID_MAIL_NUMBER);
                              WaitForCommand();
                          }
                          else
                          {
                              g_PerfCounters.IncPerfCntr(e_gcTotMsgDnldCnt);
                              g_PerfCounters.IncPerfCntr(e_gcMsgDnldRate);
                          }
                      }
                      else
                      {
                          SendResponse(RESP_CMD_NOT_VALID);
                          WaitForCommand();
                      }
                      break;
        case CMD_TOP: //TOP must have two parameters
                      pCur=&(m_szCommandBuffer[COMMAND_SIZE-1]);
                      if( IsEndOfCommand(pCur) )
                      {
                          SendResponse(RESP_CMD_NOT_VALID);
                      }
                      else
                      {
                          if( (GetNextNumParameter(&pCur, &iArg)) && 
                                !(IsEndOfCommand(pCur)) )
                          { 
                              if((GetNextNumParameter(&pCur, &iArg2)) && 
                                 (IsEndOfCommand(pCur)) )
                              {
                                  m_bFileTransmitPending=TRUE;
                                  dwResult=m_MailBox.TransmitMail(m_pIoContext, iArg-1, iArg2);
                                  if(ERROR_SUCCESS !=dwResult)
                                  {
                                      m_bFileTransmitPending=FALSE;
                                      SendResponse(RESP_INVALID_MAIL_NUMBER);
                                  }
                                  else
                                  {
                                      g_PerfCounters.IncPerfCntr(e_gcTotMsgDnldCnt);
                                      g_PerfCounters.IncPerfCntr(e_gcMsgDnldRate);

                                      //
                                      //  BLaPorte - do not call WaitForCommand in success case.  This
                                      //             avoids the situation where we have two pending async
                                      //             completions.
                                      //

                                      break;
                                  }

                              }
                              else
                              {
                                    SendResponse(RESP_CMD_NOT_VALID);
                              }
                          }
                          else
                          {
                               SendResponse(RESP_CMD_NOT_VALID);
                          }
                      }
                      WaitForCommand();
                      break;

        case CMD_DELE://DELE must have one argument
                      pCur=&(m_szCommandBuffer[COMMAND_SIZE]);
                      
                      if( (GetNextNumParameter(&pCur, &iArg)) &&
                              (IsEndOfCommand(pCur)) )
                      {
                          dwResult=m_MailBox.DeleteMail(iArg-1);
                          if(ERROR_SUCCESS == dwResult)
                          {
                              SendResponse(RESP_MSG_MARKED_DELETED);
                          }
                          else
                          {
                              SendResponse(RESP_INVALID_MAIL_NUMBER);
                          }
                      }
                      else
                      {
                          SendResponse(RESP_CMD_NOT_VALID);
                      }
                      WaitForCommand();
                      break;
        case CMD_NOOP://NOOP has no argument
                      if(!IsEndOfCommand(&(m_szCommandBuffer[COMMAND_SIZE])))
                      {
                          SendResponse(RESP_CMD_NOT_VALID);
                      }
                      else
                      {
                          SendResponse(RESP_OK);
                      }
                      WaitForCommand();  
                      break;
        case CMD_RSET://RSET has no argument
                      if(!IsEndOfCommand(&(m_szCommandBuffer[COMMAND_SIZE])))
                      {
                          SendResponse(RESP_CMD_NOT_VALID);
                      }
                      else
                      {
                          m_MailBox.Reset();
                          SendResponse(RESP_RESET);
                      }
                      WaitForCommand();  
                      break;
        case CMD_QUIT://QUIT has no argument
                      //Commit all changes to the mailbox and close the connection
                      if( m_MailBox.CommitAndClose())
                      {
                           g_PerfCounters.DecPerfCntr(e_gcTransStateCnt);
                           m_dwCurrentState=UPDATE_STATE;
                           if(L'\0'!=g_wszGreeting[0])
                           {
                               _snprintf(szReBuf, 
                                         POP3_RESPONSE_BUF_SIZE-1,
                                         RESP_SERVER_QUIT,
                                         g_wszGreeting,
                                         m_wszGreeting);
                           }
                           else
                           {
                               _snprintf(szReBuf, 
                                         POP3_RESPONSE_BUF_SIZE-1,
                                         RESP_SERVER_QUIT,
                                         RESP_SERVER_GREETING,
                                         m_wszGreeting);
                           }
                           szReBuf[POP3_RESPONSE_BUF_SIZE-1]=0;
                           SendResponse(szReBuf); 
                           bRetVal=FALSE;
                      }
                      else
                      {
                          SendResponse(RESP_SERVER_ERROR);
                          bRetVal=FALSE; // In this case terminate the connection
                      }
                      break;
        case CMD_USER:
        case CMD_APOP:
        case CMD_AUTH:
        case CMD_PASS:SendResponse(RESP_CMD_NOT_SUPPORTED);
                      WaitForCommand();
                      break;
        default:
                      SendResponse(RESP_UNKNOWN_COMMAND);
                      WaitForCommand();  
                        
     }


     return bRetVal;
}


void POP3_CONTEXT::SendResponse(char *szBuf)
{
    int iErr;
    ASSERT(m_pIoContext!=NULL);
    ASSERT(m_pIoContext->m_hAsyncIO!=NULL);
    if(SOCKET_ERROR == send(m_pIoContext->m_hAsyncIO, 
                            szBuf, 
                            strlen(szBuf), 
                            0))
    {
        iErr=WSAGetLastError();
        //Can not send through the socket
        //The connection will be terminated later
        //in the WaitForCommand call.
    }
}

void POP3_CONTEXT::SendResponse(DWORD dwResult, char *szBuf)
{
    char szResp[POP3_RESPONSE_BUF_SIZE];

    if(ERROR_SUCCESS == dwResult)
    {
        if( 0 > _snprintf(szResp,
                          POP3_RESPONSE_BUF_SIZE-1, 
                          "+OK %s", 
                          szBuf))
        {
            SendResponse(RESP_SERVER_ERROR);            
        }
        else
        {
            szResp[POP3_RESPONSE_BUF_SIZE-1]=0;
            SendResponse(szResp);
        }
    }
    else
    {
        SendResponse(RESP_INVALID_MAIL_NUMBER);
    }
}

BOOL POP3_CONTEXT::GetNextStringParameter(char *szInput, char *szOutput, DWORD dwOutputSize)
{
    ASSERT(szInput!=NULL);
    ASSERT(szOutput!=NULL);
    
    //Must have at lease one space
    if(!isspace(*szInput))
    {
        return FALSE;
    }
    do
    {
        szInput++;
    }while(isspace(*szInput));

    if('\0'==*szInput)
    {
        return FALSE;
    }

    //
    //  BLaPorte - added output size parameter to prevent buffer overflow.
    //
    if (strlen(szInput) >= dwOutputSize) {
       return FALSE;
    }

    strcpy(szOutput,szInput);
    return TRUE;
}


BOOL POP3_CONTEXT::GetNextNumParameter(char **pszInput, int *piOutput)
{
    ASSERT(pszInput!=NULL);
    ASSERT(*pszInput!=NULL);

    char *szInput=*pszInput;
    char *szEndInput=NULL;
    if(!isspace(*szInput))
    {
        return FALSE;
    }
    do
    {
        szInput++;
    }while(isspace(*szInput));
    szEndInput=szInput;
    if(!isdigit(*szEndInput))
    {
        return FALSE;
    }
    do
    {
        szEndInput++;
    }while(isdigit(*szEndInput));
    if((szEndInput-szInput) > MAX_INT_LEN )
    {
        return FALSE;
    }
    *piOutput=atoi(szInput);
    *pszInput=szEndInput;
    return TRUE;
}

BOOL POP3_CONTEXT::IsEndOfCommand(char *szInput)
{
    ASSERT(szInput!=NULL);
    while(isspace(*szInput))
    {
        szInput++;
    }
    if('\0'==*szInput)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

}

BOOL POP3_CONTEXT::Unauthenticated()
{
   return ( m_dwCurrentState==AUTH_STATE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Pop3Svc.rc
//
#define IDC_MYICON                      2
#define IDS_SERVICENAME                 100
#define IDS_DISPLAYNAME                 101
#define IDS_DESCRIPTION                 102


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\servicesetup.h ===
/************************************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:    ServiceSetup.h
Abstract:       Defines the CServiceSetup class. See description below.
Notes:          
History:        01/24/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/

#pragma once
#define TSZ_NETWORK_SERVICE_ACCOUNT_NAME TEXT("NT AUTHORITY\\NetworkService")
#define TSZ_DEPENDENCIES TEXT("IISADMIN\0")
/************************************************************************************************
Class:          CServiceSetup
Purpose:        Encapsulates the logic for service installation, removal and configuration.
Notes:          Class design based on the CService class described in the book: 
                Professional NT Services, by Kevin Miller.
History:        01/24/2001 - created, Luciano Passuello (lucianop)
************************************************************************************************/
class CServiceSetup
{
public:
    CServiceSetup(LPCTSTR szServiceName, LPCTSTR szDisplay);

    void Install(LPCTSTR szDescription = NULL, DWORD dwType = SERVICE_WIN32_OWN_PROCESS, 
        DWORD dwStart = SERVICE_DEMAND_START, LPCTSTR lpDepends = TSZ_DEPENDENCIES, LPCTSTR lpName = TSZ_NETWORK_SERVICE_ACCOUNT_NAME, 
        LPCTSTR lpPassword = NULL);
    void Remove(bool bForce = false);
    bool IsInstalled();
    DWORD ErrorPrinter(LPCTSTR pszFcn, DWORD dwErr = GetLastError());
private:
    TCHAR m_szServiceName[_MAX_PATH];
    TCHAR m_szDisplayName[_MAX_PATH];
};

// End of file ServiceSetup.h.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

// End of file stdafx.cpp.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\stdafx.h ===
/************************************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:    stdafx.h.
Abstract:       Include files normally used by all pop3 service code                
Notes:          
History:        08/01/2001 - Hao Yu
************************************************************************************************/

#pragma once

#ifdef DBG
#undef NDEBUG
#endif

// includes
#include <windows.h>
#include <assert.h>
#include <tchar.h>
#include <process.h>
#include <stdlib.h>
#include <stdio.h>
#include <objbase.h>


#ifdef ROCKALL3
#define COMPILING_ROCKALL_DLL
#include <FastHeap.hpp>
#endif

#define ASSERT assert
#define POP3_SERVICE_NAME               _T("POP3SVC")


#include <Pop3Auth.h>
#include <IOContext.h>
#include <pop3events.h>
#include "Mailbox.h"
#include "EventLogger.h"
#include "service.h"
#include "Pop3Svc.hxx"
#include "IOLists.h"
#include <ThdPool.hxx>
#include <sockpool.hxx>
#include "Pop3Context.h"
#include "NTAuth.h"
#include "PerfApp.h"
#include "Pop3SvcPerf.h"
#include <GlobalDef.h>

// End of file stdafx.h.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\service.h ===
/************************************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:    Service.h
Abstract:       Defines the CService class and related macros. See description below.
Notes:          
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/

#pragma once

// global constants
const int nMaxServiceLen = 256;
const int nMaxServiceDescLen = 1024;

/************************************************************************************************
Class:          CService
Purpose:        Abstract class that implements the service-related code, such as
                threads creating, SCM registering, status retrieval, etc..
Notes:      (1) Class design based on the CService class described in the book: 
                Professional NT Services, by Kevin Miller.
            (2) Each derived class must be instantiated one and only time.
History:        01/25/2001 - created, Luciano Passuello (lucianop)
************************************************************************************************/
class CService
{
protected:
    // actions that services respond to
    const static DWORD dwStateNoChange;
    
    enum SERVICE_NUMBER_EVENTS { nNumServiceEvents = 4 };
    enum SERVICE_EVENTS {STOP, PAUSE, CONTINUE, SHUTDOWN};

    DWORD m_dwDefaultEventID;
    WORD m_wDefaultCategory;
    
public:
    CService(LPCTSTR szName, LPCTSTR szDisplay, DWORD dwType);
    virtual ~CService();

    DWORD GetStatus() { return m_dwState; }
    DWORD GetControls() { return m_dwControlsAccepted; }
    LPCTSTR GetName() { return m_szName; }
    LPCTSTR GetDisplayName() { return m_szDisplay; }
protected:
    void ServiceMainMember(DWORD argc, LPTSTR* argv, LPHANDLER_FUNCTION pf, LPTHREAD_START_ROUTINE pfnWTP);
    void HandlerMember(DWORD dwControl);
    virtual void LaunchWatcherThread(LPTHREAD_START_ROUTINE pfnWTP);
    virtual DWORD WatcherThreadMemberProc();

    bool SetupHandlerInside(LPHANDLER_FUNCTION lpHandlerProc);

    void SetStatus(DWORD dwNewState, DWORD dwNewCheckpoint = dwStateNoChange, DWORD dwNewHint = dwStateNoChange, 
        DWORD dwNewControls = dwStateNoChange, DWORD dwExitCode = NO_ERROR, DWORD dwSpecificExit = 0);

    void AbortService(DWORD dwErrorNum = GetLastError());
// Overrideables
protected:
    virtual void PreInit(); // if you override, call the base class version
    virtual void Init();
    virtual void DeInit();  // If you override, call the base class version
    virtual void ParseArgs(DWORD argc, LPTSTR* argv);
    virtual void OnPause();
    virtual void OnContinue();
    virtual void OnShutdown();
    virtual void HandleUserDefined(DWORD dwControl);

    // service events handling
    virtual void OnStopRequest();
    virtual void OnPauseRequest();
    virtual void OnContinueRequest();
    virtual void OnShutdownRequest();

    virtual void OnBeforeStart();
    virtual void OnAfterStart();

    virtual void Run() = 0;
    virtual void OnStop(DWORD dwErrorCode) = 0;

// Attributes
protected:
    CRITICAL_SECTION m_cs;

    // Status info
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    DWORD m_dwState;
    DWORD m_dwControlsAccepted;
    DWORD m_dwCheckpoint;
    DWORD m_dwWaitHint;

    // Tracks state currently being worked on in Handler
    DWORD m_dwRequestedControl;

    // Control Events
    HANDLE m_hServiceEvent[nNumServiceEvents];
    HANDLE m_hWatcherThread;

    TCHAR m_szName[nMaxServiceLen + 1];
    TCHAR m_szDisplay[nMaxServiceLen + 1];
    DWORD m_dwType;
};


/************************************************************************************************
Macro:          DECLARE_SERVICE
Synopsis:       declares the static functions that will be used as thread-entry points.
Effects:        These functions need to be static because they will be used as thread 
                entry-points. Since static functions don't have access to the this pointer, it 
                have to be explicitly passed to them (m_pThis). That's why this code need to be 
                put in derived classes, otherwise we could have just one CService around at a 
                time. We can only have one specific CService-derived class at a time.
Arguments:      [class_name] - the name of the CService-derived class.
                [service_name] - the SCM short service name.
Notes:          to be used in CService-derived class declaration.
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
#define DECLARE_SERVICE(class_name, service_name) \
public: \
    static class_name##* m_pThis; \
    static void WINAPI service_name##Main(DWORD argc, LPTSTR* argv); \
    static void WINAPI service_name##Handler(DWORD dwControl); \
    static DWORD WINAPI service_name##WatcherThreadProc(LPVOID lpParameter);


/************************************************************************************************
Macro:          IMPLEMENT_SERVICE
Synopsis:       implements the static functions that will be used as thread-entry points.
Effects:        Using the explicit "this" pointer, it just delegates the work to the member
                functions.
Arguments:      [class_name] - the name of the CService-derived class.
                [service_name] - the SCM short service name.
Notes:          to be used in CService-derived class implementation.
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
#define IMPLEMENT_SERVICE(class_name, service_name) \
class_name##* class_name::m_pThis = NULL; \
void WINAPI class_name::service_name##Main(DWORD argc, LPTSTR* argv) \
{ \
    m_pThis->ServiceMainMember(argc, argv, (LPHANDLER_FUNCTION)service_name##Handler, \
      (LPTHREAD_START_ROUTINE)service_name##WatcherThreadProc); \
} \
void WINAPI class_name::service_name##Handler(DWORD dwControl) \
{ \
    m_pThis->HandlerMember(dwControl); \
} \
DWORD WINAPI class_name::service_name##WatcherThreadProc(LPVOID /*lpParameter*/) \
{ \
    return m_pThis->WatcherThreadMemberProc(); \
}


/************************************************************************************************
Macro:          BEGIN_SERVICE_MAP, SERVICE_MAP_ENTRY, END_SERVICE_MAP
Synopsis:       creates the service map and registers it with the SCM.
Effects:        Using the explicit "this" pointer, it just delegates the work to the member
                functions.
Arguments:      [class_name] - the name of the CService-derived class.
                [service_name] - the SCM short service name.
Notes:          to be used in the entry-point where the CService-derived class is used.
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
#define BEGIN_SERVICE_MAP \
SERVICE_TABLE_ENTRY svcTable[] = {

#define SERVICE_MAP_ENTRY(class_name, service_name) \
{_T(#service_name), (LPSERVICE_MAIN_FUNCTION)class_name::service_name##Main},

#define END_SERVICE_MAP \
{NULL, NULL}}; \
StartServiceCtrlDispatcher(svcTable);


/************************************************************************************************
Macro:          IMPLEMENT_STATIC_REFERENCE()
Synopsis:       assigns the "this" pointer to an explicit m_pThis member.
Effects:        makes the static member functions know explicitly about the data in the class,
                since static functions don't have access to the "this" pointer.
Notes:          to be used in CService-derived constructors.
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
#define IMPLEMENT_STATIC_REFERENCE()  m_pThis = this


// End of file Service.h.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\service.cpp ===
/************************************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:    Service.cpp.
Abstract:       Implements the CService class. See Service.h for details.
Notes:          
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/

#include "stdafx.h"
#include "Service.h"

// static variables initialization
const DWORD CService::dwStateNoChange = 0xFFFFFFFF;


/************************************************************************************************
Member:         CService::CService, constructor, public.
Synopsis:       Initializes internal variables, such as event logging defaults.
Effects:        
Arguments:      [szName] - the SCM short name for the service.
                [szDisplay] - the SCM display name for the service.
                [dwType] - see CreateService for further documentation.
Notes:
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
CService::CService(LPCTSTR szName, LPCTSTR szDisplay, DWORD dwType) : 
    m_dwType(dwType)
{
    ASSERT(!(NULL == szName));
    ASSERT(!(NULL == szDisplay));
        
    m_hServiceStatus = NULL;
    m_dwRequestedControl = 0;

    // Control Events
    m_hWatcherThread = NULL;

    m_dwState = 0;
    m_dwControlsAccepted = 0;
    m_dwCheckpoint = 0;
    m_dwWaitHint = 0;

    // Initialize event handles to NULL
    for(int i = 0; i < nNumServiceEvents; i++)
        m_hServiceEvent[i] = NULL;

    // Copy string names
    _tcsncpy(m_szName, szName, nMaxServiceLen);
    _tcsncpy(m_szDisplay, szDisplay, nMaxServiceLen);


    // Set up class critical section
    InitializeCriticalSection(&m_cs);
}


/************************************************************************************************
Member:         CService::~CService, destructor, public.
Synopsis:       Deinitializes internal variables.
Notes:
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
CService::~CService()
{
    DeleteCriticalSection(&m_cs);
}


/************************************************************************************************
Member:         CService::PreInit, destructor, public.
Synopsis:       Initialialization of variables. This is performed before launching the watcher 
                thread and notifying status to the SCM.
Notes:          (*) If you override this, call the base class version in the beginning!!
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::PreInit()
{
    // Initialize Events
    for(int i = 0; i < nNumServiceEvents; i++)
    {
        m_hServiceEvent[i] = CreateEvent(NULL, TRUE, FALSE, NULL);
        if(!m_hServiceEvent[i])
        {
            AbortService();
        }
    }
}


/************************************************************************************************
Member:         CService::PreInit, destructor, public.
Synopsis:       Initialialization of variables. This is performed before launching the watcher 
                thread and notifying status to the SCM.
Notes:          (*) If you override this, call the base class version in the beginning!!
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::DeInit()
{
    // Wait for the watcher thread to terminate
    if(m_hWatcherThread)
    {
        // Wait a reasonable amount of time
        WaitForSingleObject(m_hWatcherThread, 10000);
        CloseHandle(m_hWatcherThread);
    }

    // Uninitialize any resources created in Init()
    for(int i = 0 ; i < nNumServiceEvents ; i++)
    {
        if(m_hServiceEvent[i])
            CloseHandle(m_hServiceEvent[i]);
    }
}


/************************************************************************************************
Member:         CService::ServiceMainMember, protected
Synopsis:       does the main service thread processing. (ServiceMain() equivalent)
Notes:          This is delegated from the static thread entry-point.
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::ServiceMainMember(DWORD argc, LPTSTR* argv, LPHANDLER_FUNCTION pf, 
    LPTHREAD_START_ROUTINE pfnWTP)
{
    OnBeforeStart();
    PreInit();
    SetupHandlerInside(pf);
    ParseArgs(argc, argv);
    LaunchWatcherThread(pfnWTP);
    Init();
    OnAfterStart();
    Run();    
    DeInit();
}


/************************************************************************************************
Member:         CService::SetupHandlerInside, protected
Synopsis:       Register the control handler for the service.
Arguments:      [lpHandlerProc] - pointer to the function implementing the SCM event handling.
Notes:          
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
bool CService::SetupHandlerInside(LPHANDLER_FUNCTION lpHandlerProc)
{
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szName, lpHandlerProc);
    if(!m_hServiceStatus)
    {
        AbortService();
    }

    SetStatus(SERVICE_START_PENDING, 1, 5000);
    return true;
}




/************************************************************************************************
Member:         CService::HandlerMember, protected
Synopsis:       Handles service start, stop, etc. requests from the SCM
Arguments:      [dwControl] - event request code.
Notes:          
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::HandlerMember(DWORD dwControl)
{
    // Keep an additional control request of the same type
    // from coming in when you're already handling it
    if(m_dwRequestedControl == dwControl)
        return;

    switch(dwControl)
    {
    case SERVICE_CONTROL_STOP:
        m_dwRequestedControl = dwControl;

        // Notify the service to stop...
        OnStopRequest();
        SetEvent(m_hServiceEvent[STOP]);
        break;

    case SERVICE_CONTROL_PAUSE:
        m_dwRequestedControl = dwControl;

        // Notify the service to pause...
        OnPauseRequest();
        SetEvent(m_hServiceEvent[PAUSE]);
        break;

    case SERVICE_CONTROL_CONTINUE:
        if(GetStatus() != SERVICE_RUNNING)
        {
            m_dwRequestedControl = dwControl;

            // Notify the service to continue...
            OnContinueRequest();
            SetEvent(m_hServiceEvent[CONTINUE]);
        }
        break;

    case SERVICE_CONTROL_SHUTDOWN:
        m_dwRequestedControl = dwControl;

        OnShutdownRequest();
        SetEvent(m_hServiceEvent[SHUTDOWN]);
        break;

    case SERVICE_CONTROL_INTERROGATE:
        // Return current status on interrogation
        SetStatus(GetStatus());
        break;

    default: // User Defined
        m_dwRequestedControl = dwControl;
        HandleUserDefined(dwControl);
    }
}



void CService::LaunchWatcherThread(LPTHREAD_START_ROUTINE pfnWTP)
{
    if(NULL != pfnWTP)
    {
        m_hWatcherThread = (HANDLE)_beginthreadex(0, 0, (unsigned (WINAPI*)(void*))pfnWTP, 0, 0, NULL);
    }
    if(!m_hWatcherThread)
    {
        AbortService();
    }
}



DWORD CService::WatcherThreadMemberProc()
{
    DWORD dwWait = 0;
    bool bControlWait = true;

    // Wait for any events to signal
    while(bControlWait)
    {
        dwWait = WaitForMultipleObjects(nNumServiceEvents, m_hServiceEvent, FALSE, INFINITE);

        switch(dwWait - WAIT_OBJECT_0)
        {
        case STOP:
            bControlWait = false;
            break;

        case PAUSE:
            OnPause();
            ResetEvent(m_hServiceEvent[PAUSE]);
            break;

        case CONTINUE:
            OnContinue();
            ResetEvent(m_hServiceEvent[CONTINUE]);
            break;

        case SHUTDOWN:
            OnShutdown();
            bControlWait = false;
            break;
        }
    }
    //Wait for the global shutdown event
    while(1)
    {
        dwWait = WaitForSingleObject(g_hShutDown, 5000);
        if(WAIT_OBJECT_0==dwWait || WAIT_ABANDONED == dwWait)
        {
            break;
        }
        else if(WAIT_TIMEOUT == dwWait)
        {
            SetStatus(SERVICE_STOP_PENDING, 1, 10000);
        }
    }
    
    return 0;
}



void CService::SetStatus(DWORD dwNewState, DWORD dwNewCheckpoint, DWORD dwNewHint,  DWORD dwNewControls, 
    DWORD dwExitCode, DWORD dwSpecificExit)
{
    // The only state that can set Exit Codes is STOPPED
    // Fix if necessary, just in case not set properly.
    if(dwNewState != SERVICE_STOPPED)
    {
        dwExitCode = S_OK;
        dwSpecificExit = 0;
    }

    // Only pending states can set checkpoints or wait hints,
    //  and pending states *must* set wait hints
    if((SERVICE_STOPPED == dwNewState) || (SERVICE_PAUSED == dwNewState) || (SERVICE_RUNNING == dwNewState))
    {
        // Requires hint and checkpoint == 0
        // Fix it so that NO_CHANGE from previous state doesn't cause nonzero
        dwNewHint = 0;
        dwNewCheckpoint = 0;
    }
    else
    {
        // Requires hint and checkpoint != 0
        if(dwNewHint <= 0 || dwNewCheckpoint <=0)
        {
            AbortService();
        }
    }

    // Function can be called by multiple threads - protect member data
    EnterCriticalSection(&m_cs);

    // Alter states if changing
    m_dwState = dwNewState;

    if(dwNewCheckpoint != dwStateNoChange)
    {
        m_dwCheckpoint = dwNewCheckpoint;
    }

    if(dwNewHint != dwStateNoChange)
    {
        m_dwWaitHint = dwNewHint;
    }

    if(dwNewControls != dwStateNoChange)
    {
        m_dwControlsAccepted = dwNewControls;
    }

    SERVICE_STATUS ss = {m_dwType, m_dwState, m_dwControlsAccepted, dwExitCode, dwSpecificExit, m_dwCheckpoint, m_dwWaitHint};

    LeaveCriticalSection(&m_cs);

    SetServiceStatus(m_hServiceStatus, &ss);  
}


/************************************************************************************************
Member:         CService::AbortService, protected
Synopsis:       Generic error handler, call this when you fall in to a critical error and
                must abort the service.
Arguments:      [dwErrorNum] - Error code reported back to SCM.
Notes:          
History:        01/31/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::AbortService(DWORD dwErrorNum /*= GetLastError()*/)
{
    // clean up service and stop service notifying error to the SCM
    OnStopRequest();
    DeInit();
    OnStop(dwErrorNum);
    ExitProcess(dwErrorNum);
}


/************************************************************************************************
Member:         CService::Init, overridable, public.
Synopsis:       Override this to implement initialization code for your specific service.
Notes:          
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::Init()
{}


/************************************************************************************************
Member:         CService::HandleUserDefined, overridable, public.
Synopsis:       Override this to implement custom SCM requests to your service.
Notes:          
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::HandleUserDefined(DWORD /*dwControl*/)
{}


/************************************************************************************************
Member:         CService::OnPause, overridable, public.
Synopsis:       Override this to implement code that runs when the service pauses.
Notes:          
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::OnPause()
{}


/************************************************************************************************
Member:         CService::OnContinue, overridable, public.
Synopsis:       Override this to implement code that runs when the service resumes from a pause.
Notes:          
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::OnContinue()
{}


/************************************************************************************************
Member:         CService::OnShutdown, overridable, public.
Synopsis:       Override this to implement code that runs when service is stopped by a shutdown.
Notes:          
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::OnShutdown()
{}


/************************************************************************************************
Member:         CService::ParseArgs, overridable, public.
Synopsis:       Override this to implement parsing of service command line parameters.
Notes:          
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::ParseArgs(DWORD /*argc*/, LPTSTR* /*argv*/)
{}


/************************************************************************************************
Member:         CService::OnBeforeStart, overridable, public.
Synopsis:       Override this to add code that's run before trying to start the service.
Notes:          A common use would be to log that the service will try to start.
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::OnBeforeStart()
{}    


/************************************************************************************************
Member:         CService::OnAfterStart, overridable, public.
Synopsis:       Override this to add code that's run just after the service was started.
Notes:          A common use would be to log that the service was successfully started.
History:        01/25/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::OnAfterStart()
{}


/************************************************************************************************
Member:         CService::OnStopRequest, overridable, public.
Synopsis:       Override this to add code that's run when the service receives a stop request.
Notes:          A common use is to log that the service received the stop request.
                This function DOESN'T run in the main thread. Protect resources if needed.
History:        02/05/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::OnStopRequest()
{}


/************************************************************************************************
Member:         CService::OnPauseRequest, overridable, public.
Synopsis:       Override this to add code that's run when the service receives a pause request.
Notes:          A common use is to log that the service received the pause request.
                This function DOESN'T run in the main thread. Protect resources if needed.
History:        02/05/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::OnPauseRequest()
{}


/************************************************************************************************
Member:         CService::OnContinueRequest, overridable, public.
Synopsis:       Override this to add code that's run when the service receives a continue request.
Notes:          A common use is to log that the service received the continue request.
                This function DOESN'T run in the main thread. Protect resources if needed.
History:        02/05/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::OnContinueRequest()
{}


/************************************************************************************************
Member:         CService::OnShutdownRequest, overridable, public.
Synopsis:       Override this to add code that's run when the service receives a shutdown request.
Notes:          A common use is to log that the service received the shutdown request.
                This function DOESN'T run in the main thread. Protect resources if needed.
History:        02/05/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CService::OnShutdownRequest()
{}



// End of file Service.cpp.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\socketpool.cpp ===
/************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

File Name:      SocketPool.cpp
Abstract:       Implementation of the socket pool (CSocketPool class)
                and the callback function for IO Context. 
Notes:          
History:        08/01/2001 Created by Hao Yu (haoyu)

************************************************************************************************/

#include <stdafx.h>
#include <ThdPool.hxx>
#include <SockPool.hxx>
#include <GlobalDef.h>

typedef int (*FUNCGETADDRINFO)(const char *, const char *, const struct addrinfo *, struct addrinfo **);
typedef void (*FUNCFREEADDRINFO)(struct addrinfo *);

//The call back function for IO Context
VOID IOCallBack(PULONG_PTR pCompletionKey ,LPOVERLAPPED pOverlapped, DWORD dwBytesRcvd)
{
    ASSERT( NULL != pCompletionKey );
    char szBuffer[MAX_PATH]="+OK Server Ready";
    WSABUF wszBuf={MAX_PATH, szBuffer};
    DWORD dwNumSent=0;
    DWORD dwFlag=0;
    long lLockValue;
    PIO_CONTEXT pIoContext=(PIO_CONTEXT)pCompletionKey;

    
    if(pIoContext->m_ConType == LISTEN_SOCKET)
    {
        ASSERT(pOverlapped != NULL);
        //This is a new connection
        g_PerfCounters.IncPerfCntr(e_gcTotConnection);
        g_PerfCounters.IncPerfCntr(e_gcConnectionRate);
        g_PerfCounters.IncPerfCntr(e_gcConnectedSocketCnt);

        pIoContext=CONTAINING_RECORD(pOverlapped, IO_CONTEXT, m_Overlapped);
        pIoContext->m_dwLastIOTime=GetTickCount();
        pIoContext->m_dwConnectionTime=pIoContext->m_dwLastIOTime;
        pIoContext->m_lLock=LOCKED_TO_PROCESS_POP3_CMD;
        if(ERROR_SUCCESS!=g_FreeList.RemoveFromList( &(pIoContext->m_ListEntry) ))
        {
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,POP3SVR_SOCKET_REQUEST_BEFORE_INIT);
            
        }
        g_BusyList.AppendToList( &(pIoContext->m_ListEntry) );
        g_SocketPool.DecrementFreeSocketCount();
        pIoContext->m_pPop3Context->Reset();
        pIoContext->m_pPop3Context->ProcessRequest(pIoContext, pOverlapped, dwBytesRcvd);
        if(DELETE_PENDING == pIoContext->m_ConType)
        {
            g_BusyList.RemoveFromList(&(pIoContext->m_ListEntry));
            if(g_SocketPool.IsMoreSocketsNeeded())
            {
                if(g_SocketPool.ReuseIOContext(pIoContext))
                {
                    return;
                }
            }
            delete(pIoContext->m_pPop3Context);
            delete(pIoContext);
        }
        else
        {
            InterlockedExchange(&(pIoContext->m_lLock), UNLOCKED);
        }
        if( g_SocketPool.IsMoreSocketsNeeded() )
        {
            if(!g_SocketPool.AddSockets())
            {
                g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,POP3SVR_CREATE_ADDITIONAL_SOCKET_FAILED);
            }                
        }
        if( g_SocketPool.IsMaxSocketUsed())
        {
            SetEvent(g_hDoSEvent);
        }

    }
    else
    {
        lLockValue = InterlockedCompareExchange(&(pIoContext->m_lLock), LOCKED_TO_PROCESS_POP3_CMD, UNLOCKED);        
        while(UNLOCKED!=lLockValue)
        {
            //This thread have to wait for the previous command to finish
            //Or the timeout thread to mark it as timed out
            Sleep(10);
            lLockValue = InterlockedCompareExchange(&(pIoContext->m_lLock), LOCKED_TO_PROCESS_POP3_CMD, UNLOCKED);
        }            

        
        if(CONNECTION_SOCKET == pIoContext->m_ConType )
        {
            pIoContext->m_pPop3Context->ProcessRequest(pIoContext, pOverlapped, dwBytesRcvd);
        }
        if(DELETE_PENDING == pIoContext->m_ConType)
        {
            g_BusyList.RemoveFromList(&(pIoContext->m_ListEntry));
            if(g_SocketPool.IsMoreSocketsNeeded())
            {
                if(g_SocketPool.ReuseIOContext(pIoContext))
                {
                    return;
                }
            }
            delete(pIoContext->m_pPop3Context);
            delete(pIoContext);

        }
        else
        {   
            pIoContext->m_dwLastIOTime=GetTickCount();
            InterlockedExchange(&(pIoContext->m_lLock), UNLOCKED);
        }
    }

}


CSocketPool::CSocketPool()
{
    InitializeCriticalSection(&m_csInitGuard);
    m_sMainSocket       = INVALID_SOCKET;
    m_lMaxSocketCount   = 0;
    m_lMinSocketCount   = 0;
    m_lThreshold        = 0;
    m_lTotalSocketCount = 0;
    m_lFreeSocketCount  = 0;
    m_bInit             = FALSE;
    m_lAddThreadToken   = 1l;
    m_iSocketFamily     = 0;
    m_iSocketType       = 0;
    m_iSocketProtocol   = 0;
}

CSocketPool::~CSocketPool()
{
    if(m_bInit)
    {
        Uninitialize();
    }
    DeleteCriticalSection(&m_csInitGuard);
}



BOOL CSocketPool::CreateMainSocket(u_short usPort)
{
    BOOL bRetVal = TRUE;
    PSOCKADDR addr;
    SOCKADDR_IN inAddr;
    INT addrLength;
    OSVERSIONINFOEX osVersion;
    HMODULE hMd=NULL;
    FUNCGETADDRINFO fgetaddrinfo=NULL;
    FUNCFREEADDRINFO ffreeaddrinfo=NULL;

    char szPort[33]; //max bytes of buffer for _ultoa      
    addrinfo aiHints,*paiList=NULL, *paiIndex=NULL; 
    int iRet;  
    
    osVersion.dwOSVersionInfoSize=sizeof(OSVERSIONINFOEX);
    if( !GetVersionEx((LPOSVERSIONINFO)(&osVersion)) )
    {
        // This should never happen
        return FALSE;
    }
    
    if( (osVersion.dwMajorVersion>=5) //Only work with XP
        &&
        (osVersion.dwMinorVersion >1) 
        &&
        ( (osVersion.wProductType == VER_NT_SERVER ) ||
          (osVersion.wProductType == VER_NT_DOMAIN_CONTROLLER) )
        && 
        (! 
         ((osVersion.wSuiteMask & VER_SUITE_SMALLBUSINESS ) ||
          (osVersion.wSuiteMask & VER_SUITE_SMALLBUSINESS_RESTRICTED ) ||
          (osVersion.wSuiteMask & VER_SUITE_PERSONAL   ) )   ) )
    {
        //These are the SKUs we support
    }
    else
    {
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               POP3SVR_UNSUPPORTED_OS);
        return FALSE;
    }



    if(osVersion.dwMinorVersion > 0 ) //XP
    {
        hMd=GetModuleHandle(_T("WS2_32.dll"));
        if(NULL == hMd)
        {
            return FALSE;
        }
        fgetaddrinfo=(FUNCGETADDRINFO)GetProcAddress(hMd, "getaddrinfo");
        ffreeaddrinfo=(FUNCFREEADDRINFO)GetProcAddress(hMd, "freeaddrinfo");
        if( (NULL == fgetaddrinfo) ||
            (NULL == ffreeaddrinfo))
        {
            return FALSE;
        }

        _ultoa(usPort, szPort, 10);
        memset(&aiHints, 0, sizeof(aiHints));
        aiHints.ai_socktype = SOCK_STREAM;
        aiHints.ai_flags = AI_PASSIVE;
        iRet=fgetaddrinfo(NULL, szPort, &aiHints, &paiList);
        if(iRet!=0)
        {
            //Error case
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                                   POP3SVR_FAILED_TO_CREATE_SOCKET, 
                                   WSAGetLastError());
            bRetVal=FALSE;
            goto EXIT;

        }
        for(paiIndex=paiList; paiIndex!=NULL; paiIndex=paiIndex->ai_next)
        {
            if( ( (paiIndex->ai_family == PF_INET ) && (g_dwIPVersion != 6 ) ) || 
                ( (g_dwIPVersion==6) && (paiIndex->ai_family == PF_INET6 ) ) )
            {
                //Find the first (usually the only) addrinfo 
                m_iSocketFamily=paiIndex->ai_family; //For create AcceptEx socket
                m_iSocketType=paiIndex->ai_socktype;
                m_iSocketProtocol=paiIndex->ai_protocol;
                m_sMainSocket = WSASocket(
                                 m_iSocketFamily,
                                 m_iSocketType,
                                 m_iSocketProtocol,
                                 NULL,  // protocol info
                                 0,     // Group ID = 0 => no constraints
                                 WSA_FLAG_OVERLAPPED // completion port notifications
                                 );
                if(INVALID_SOCKET == m_sMainSocket)
                {
                    //This is not the socket family supported by the machine.
                    continue;
                }
                break;
            }
        }
        if(INVALID_SOCKET==m_sMainSocket)
        {
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                                   POP3SVR_FAILED_TO_CREATE_SOCKET, 
                                   WSAGetLastError());
            bRetVal=FALSE;
            goto EXIT;
        }
        if ( bind( m_sMainSocket, paiIndex->ai_addr, paiIndex->ai_addrlen) != 0) 
        {
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                                   POP3SVR_FAILED_TO_BIND_MAIN_SOCKET, 
                                   WSAGetLastError()); 
            bRetVal=FALSE;
            goto EXIT;
        }

    }
    else //Win2k
    {
        m_iSocketFamily=PF_INET;
        m_iSocketType=SOCK_STREAM;
        m_iSocketProtocol=IPPROTO_TCP;
        m_sMainSocket = WSASocket(
                         m_iSocketFamily,
                         m_iSocketType,
                         m_iSocketProtocol,
                         NULL,  // protocol info
                         0,     // Group ID = 0 => no constraints
                         WSA_FLAG_OVERLAPPED // completion port notifications
                         );
        if(INVALID_SOCKET == m_sMainSocket)
        {
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                                   POP3SVR_FAILED_TO_CREATE_SOCKET, 
                                   WSAGetLastError());
            bRetVal=FALSE;
            goto EXIT;
        }

        addr = (PSOCKADDR)&inAddr;
        addrLength = sizeof(inAddr);
        ZeroMemory(addr, addrLength);

        inAddr.sin_family = AF_INET;
        inAddr.sin_port = htons(usPort);
        inAddr.sin_addr.s_addr = INADDR_ANY;

        
        if ( bind( m_sMainSocket, addr, addrLength) != 0) 
        {
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                                   POP3SVR_FAILED_TO_BIND_MAIN_SOCKET, 
                                   WSAGetLastError()); 
            bRetVal=FALSE;
            goto EXIT;
        }
    }


    if ( listen( m_sMainSocket, m_iBackLog) != 0) 
    {

        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               POP3SVR_FAILED_TO_LISTEN_ON_MAIN_SOCKET, 
                               WSAGetLastError());       
        bRetVal=FALSE;
        goto EXIT;
    }
    
    m_stMainIOContext.m_hAsyncIO     = m_sMainSocket;
    m_stMainIOContext.m_ConType      = LISTEN_SOCKET;
    m_stMainIOContext.m_pCallBack    = IOCallBack;
    m_stMainIOContext.m_pPop3Context = NULL;
    m_stMainIOContext.m_dwLastIOTime = 0; //No Timeout on this socket
    m_stMainIOContext.m_lLock        = UNLOCKED;
    // Associate the main socket to the completion port
    bRetVal = g_ThreadPool.AssociateContext(&m_stMainIOContext);
     
EXIT:
    if(!bRetVal)
    {
        //Clean up the main listening socket
        if( INVALID_SOCKET != m_sMainSocket )
        {
            closesocket(m_sMainSocket);
            m_sMainSocket=INVALID_SOCKET;
        }
    }
    if(NULL != paiList)
    {
        ffreeaddrinfo(paiList);
    }
    return bRetVal;

}



BOOL CSocketPool::Initialize(DWORD dwMax, DWORD dwMin, DWORD dwThreshold, u_short usPort, int iBackLog)
{
    
    BOOL bRetVal=FALSE;
    

    EnterCriticalSection(&m_csInitGuard);

    ASSERT( ( dwMax >= dwMin + dwThreshold ) &&
            ( dwMin > 0  ) );
    if( !(  (dwMax >= dwMin + dwThreshold ) &&
            ( dwMin > 0  ) ) )
    {
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               EVENT_POP3_NO_CONFIG_DATA);
        goto EXIT;
    }
    if(!m_bInit)
    {
        WSADATA   wsaData;
        INT       iErr;

        iErr = WSAStartup( MAKEWORD( 2, 0), &wsaData);
        if( iErr != 0 ) 
        {
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                                   POP3SVR_WINSOCK_FAILED_TO_INIT,
                                   iErr);
            bRetVal=FALSE;
            goto EXIT;
        }
        m_lMaxSocketCount  = dwMax;
        m_lMinSocketCount  = dwMin;
        m_lThreshold       = dwThreshold;
        m_lFreeSocketCount = 0;
        m_lTotalSocketCount= 0;
        m_iBackLog         = iBackLog;
        //First Create the Main socket
        if( bRetVal = CreateMainSocket(usPort) )
        {            
           //Now create the initial pool of AcceptEx sockets
           bRetVal = AddSocketsP(m_lMinSocketCount);
        }
        m_bInit=bRetVal;
    }
EXIT:
    LeaveCriticalSection(&m_csInitGuard);
    return bRetVal;
}


// Called after    
BOOL CSocketPool::IsMoreSocketsNeeded()
{
    if ( (g_dwServerStatus != SERVICE_RUNNING ) &&
         (g_dwServerStatus != SERVICE_PAUSED ) )
    {
        return FALSE;
    }
    if ( ( m_lTotalSocketCount < m_lMinSocketCount) ||
        (( m_lFreeSocketCount < m_lThreshold ) &&
         ( m_lTotalSocketCount <m_lMaxSocketCount ))  )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL CSocketPool::MaintainSocketCount()
{
    if ( g_dwServerStatus != SERVICE_RUNNING )
    {
        return FALSE;
    }
    if(  
        ( ( m_lFreeSocketCount < m_lThreshold ) &&
          ( m_lTotalSocketCount+m_lThreshold >= m_lMaxSocketCount ) )
        ||
        ( m_lTotalSocketCount <= m_lMinSocketCount )
       )
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

BOOL CSocketPool::Uninitialize()
{
    BOOL bRetVal=TRUE;
    EnterCriticalSection(&m_csInitGuard);
    if(m_bInit)
    {   
        // Close the main socket here
        closesocket(m_sMainSocket);
        m_sMainSocket=INVALID_SOCKET;
        //AcceptEx Sockes should already have been cleaned with IO Context,
        if(WSACleanup () )
        {
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                                   POP3SVR_WINSOCK_FAILED_TO_CLEANUP,
                                   WSAGetLastError());
            return FALSE;
        }
        m_bInit=FALSE;
    }  
    LeaveCriticalSection(&m_csInitGuard);
    return bRetVal;
}

// For working threading to call when a new connection was established
BOOL CSocketPool::AddSockets()
{
    BOOL bRetVal=TRUE;
    if( g_dwServerStatus != SERVICE_RUNNING )
    {
        return TRUE;
    }
    ASSERT(TRUE == m_bInit);

    // Make sure only one thread get to add the socket
    if( InterlockedExchange(&m_lAddThreadToken,0) )
    {           
        bRetVal = AddSocketsP(m_lThreshold);
        InterlockedExchange(&m_lAddThreadToken,1);
    }
    return bRetVal;
}   
 

BOOL CSocketPool::AddSocketsP(DWORD dwNumOfSocket)
{
    int i;
    BOOL bRetVal=TRUE;
    PIO_CONTEXT pIoContext=NULL;
    
    for(i=0; i<dwNumOfSocket; i++)
    {
        
        if( (g_dwServerStatus != SERVICE_RUNNING ) && 
            (g_dwServerStatus != SERVICE_START_PENDING) )
        {
            return TRUE;
        }
        if(m_lMaxSocketCount < InterlockedIncrement(&m_lTotalSocketCount) )
        {
            InterlockedDecrement(&m_lTotalSocketCount);
            return TRUE;
        }
        
        pIoContext=new (IO_CONTEXT);
        if(NULL==pIoContext)
        {
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL, 
                                   POP3SVR_NOT_ENOUGH_MEMORY);
            bRetVal=FALSE;
            break;
        }
        pIoContext->m_pPop3Context=new(POP3_CONTEXT);
        pIoContext->m_pCallBack = IOCallBack;
        if(NULL == pIoContext->m_pPop3Context )
        {
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL, 
                                   POP3SVR_NOT_ENOUGH_MEMORY);
            bRetVal=FALSE;
            delete(pIoContext);
            break;
        }
 
        bRetVal=CreateAcceptSocket(pIoContext);
        if(!bRetVal)
        {
            delete(pIoContext->m_pPop3Context);
            delete(pIoContext);
            break;
        }
        InterlockedIncrement(&m_lFreeSocketCount);
        if(m_lTotalSocketCount >= m_lMaxSocketCount)
        {
            break;
        }
    }
    if(!bRetVal)
    {
            InterlockedDecrement(&m_lTotalSocketCount);
    }
    return bRetVal;
}

//Called when a new connection is establised
//and a AcceptEx socket is used
void CSocketPool::DecrementFreeSocketCount()
{
    if(0==InterlockedDecrement(&m_lFreeSocketCount))
    {
        AddSockets();
    }
    
}

//Called when a socket is closed
void CSocketPool::DecrementTotalSocketCount()
{
    if(0==InterlockedDecrement(&m_lTotalSocketCount))
    {
        //Some socket must be created to avoid
        //this denial of service problem.
        AddSockets();
    }
}

//Called when a socked is closed, however, the a new 
// AcceptEx socket should be created to maintain
// total socket count, but keep the IOContext 
// to re-use
BOOL CSocketPool::ReuseIOContext(PIO_CONTEXT pIoContext) 
{
    ASSERT( NULL != pIoContext);
    if(InterlockedIncrement(&m_lTotalSocketCount) > m_lMaxSocketCount)
    {
        InterlockedDecrement(&m_lTotalSocketCount);
        return FALSE;
    }
    pIoContext->m_pPop3Context->Reset();
    if( CreateAcceptSocket(pIoContext) )
    {
        InterlockedIncrement(&m_lFreeSocketCount);
        return TRUE;
    }
    else
    {
        InterlockedDecrement(&m_lTotalSocketCount);
        return FALSE;
    }
}




BOOL CSocketPool::CreateAcceptSocket(PIO_CONTEXT pIoContext)
{
    ASSERT(NULL != pIoContext);
    SOCKET sNew;
    DWORD dwRcvd;
    int iErr;
    BOOL bRetVal=FALSE;
    BOOL bAddToList=FALSE;

    sNew=WSASocket(m_iSocketFamily,
                  m_iSocketType,
                  m_iSocketProtocol,
                  NULL,  // protocol info
                  0,     // Group ID = 0 => no constraints
                  WSA_FLAG_OVERLAPPED // completion port notifications
                  );
    if(INVALID_SOCKET == sNew)
    {
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               POP3SVR_FAILED_TO_CREATE_SOCKET, 
                               WSAGetLastError());
        goto EXIT;
    }

    pIoContext->m_hAsyncIO=sNew;
    pIoContext->m_ConType=CONNECTION_SOCKET;
    pIoContext->m_lLock=UNLOCKED;
    
    ZeroMemory(&(pIoContext->m_Overlapped), sizeof(OVERLAPPED));
    
    g_FreeList.AppendToList( &(pIoContext->m_ListEntry) );
    bAddToList=TRUE;
    // Now add the new Context to the Completion Port
    if( bRetVal = g_ThreadPool.AssociateContext(pIoContext))
    {
        bRetVal=AcceptEx(m_sMainSocket,
                        sNew,
                        (LPVOID)(pIoContext->m_Buffer),
                        0,
                        MIN_SOCKADDR_SIZE,
                        MIN_SOCKADDR_SIZE,
                        &dwRcvd, 
                        &(pIoContext->m_Overlapped));
        if(!bRetVal)
        {
            iErr= WSAGetLastError();
            if(ERROR_IO_PENDING!=iErr) 
            {
                g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                                       POP3SVR_CALL_ACCEPTEX_FAILED, 
                                       iErr);
            }
            else
            {
                bRetVal=TRUE;
            }
        }                
    }
    
        
EXIT:
    if(!bRetVal) 
    {
        if(INVALID_SOCKET != sNew) 
        {
            closesocket(sNew);
        }
        if(bAddToList)
        {
            g_FreeList.RemoveFromList(&(pIoContext->m_ListEntry));
        }
    }

    
    return bRetVal;

}

BOOL CSocketPool::IsMaxSocketUsed()
{
    return ( (m_lTotalSocketCount==m_lMaxSocketCount) &&
             (m_lFreeSocketCount == 0 ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\servicesetup.cpp ===
/************************************************************************************************
Copyright (c) 2001 Microsoft Corporation

Module Name:    ServiceSetup.cpp.
Abstract:       Implements the CServiceSetup class. See ServiceSetup.h for details.
Notes:          
History:        01/24/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/

#include "stdafx.h"
#include "ServiceSetup.h"

/************************************************************************************************
Member:         CServiceSetup::CServiceSetup, constructor, public.
Synopsis:       Copies initialization data to member variables.
Arguments:      [szServiceName] - the SCM short name for the service.
                This will identify uniquely each service in the system.
                [szDisplayName] - the name that's displayed for the users in the SCM.
Notes:          The display name would only be necessary in the install case. May change that
                later.
History:        01/24/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
CServiceSetup::CServiceSetup(LPCTSTR szServiceName, LPCTSTR szDisplay)
{
    ASSERT(!(NULL == szServiceName));
	ASSERT(!(NULL == szDisplay));
	
	_tcsncpy(m_szServiceName, szServiceName, _MAX_PATH-1);
    _tcsncpy(m_szDisplayName, szDisplay,_MAX_PATH-1);
    m_szServiceName[_MAX_PATH-1]=0;
    m_szDisplayName[_MAX_PATH-1]=0;

}


/************************************************************************************************
Member:         CServiceSetup::Install, public.
Synopsis:       Install service in the SCM.
Arguments:      [szDescription] - the service description as it will appear in the SCM.
                [dwType, dwStart, lpDepends, lpName, lpPassword] - see CreateService API call
                documentation.
Notes:          If the service is already installed, Install() does nothing. It must be
                removed first to be reinstalled.
History:        01/24/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CServiceSetup::Install(LPCTSTR szDescription, DWORD dwType, DWORD dwStart, 
    LPCTSTR lpDepends, LPCTSTR lpName, LPCTSTR lpPassword)
{
	SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;

    if(IsInstalled())
	{
        return;
	}

    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
    if(!hSCM)
    {
        ErrorPrinter(_T("OpenSCManager"));
        goto cleanup;
    }

    // get the service executable path (this executable)
    TCHAR szFilePath[_MAX_PATH+1];
    szFilePath[_MAX_PATH]=0;
    if(0==::GetModuleFileName(NULL, szFilePath, _MAX_PATH))
    {
        goto cleanup;
    }
    

    hService = CreateService(hSCM, m_szServiceName, m_szDisplayName, SERVICE_ALL_ACCESS, dwType, dwStart, SERVICE_ERROR_NORMAL, 
    	szFilePath,	NULL, NULL, lpDepends, lpName, lpPassword);

    if (!hService) 
    {
        ErrorPrinter(_T("CreateService"));
        goto cleanup;
    }
    else
    {
        _tprintf(_T("%s Created\n"), m_szServiceName);
    }

    // change service description
    SERVICE_DESCRIPTION sd;
    sd.lpDescription = const_cast<LPTSTR>(szDescription);
    ChangeServiceConfig2(hService, SERVICE_CONFIG_DESCRIPTION, static_cast<LPVOID>(&sd));
    
    SERVICE_FAILURE_ACTIONS sfa;
    SC_ACTION saArray[3];
    saArray[0].Type=SC_ACTION_RESTART;
    saArray[0].Delay=60000;//One minute in milliseconds
    saArray[1].Type=SC_ACTION_RESTART;
    saArray[1].Delay=60000;//One minute in milliseconds
    saArray[2].Type=SC_ACTION_NONE;
    saArray[2].Delay=0;

    sfa.dwResetPeriod=24*60*60;//One day in seconds
    sfa.lpRebootMsg=NULL;
    sfa.lpCommand=NULL;
    sfa.cActions=3;
    sfa.lpsaActions=saArray;


    ChangeServiceConfig2(hService, SERVICE_CONFIG_FAILURE_ACTIONS,  &sfa);

cleanup:
    if (hService) 
	{
        CloseServiceHandle(hService);
	}

    if (hSCM) 
	{
        CloseServiceHandle(hSCM);
	}

    return;
}



/************************************************************************************************
Member:         CServiceSetup::Remove, public.
Synopsis:       Unregisters the service in the SCM.
Arguments:      [bForce] - if the service is running, force it to stop and then remove.
Notes:          
History:        01/24/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
void CServiceSetup::Remove(bool bForce)
{
    SC_HANDLE hSCM = NULL;
    SC_HANDLE hService = NULL;
    BOOL bSuccess = FALSE;

    hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (!hSCM)
    {
        ErrorPrinter(_T("OpenSCManager"));
        return;
    }

    hService = ::OpenService(hSCM, m_szServiceName, DELETE | SERVICE_STOP);
    if (!hService) 
    {
        ErrorPrinter(_T("OpenService"));
        goto cleanup;
    }

    // force the service to stop
    if(TRUE == bForce) 
    {
        SERVICE_STATUS status;
        ::ControlService(hService, SERVICE_CONTROL_STOP, &status);
        _tprintf(_T("%s stopped\n"), m_szServiceName);
        Sleep(2000);
    }

    bSuccess = ::DeleteService(hService);

    if(bSuccess)
    {
        _tprintf(_T("%s removed\n"), m_szServiceName); 
    }
    else
    {
        ErrorPrinter(_T("DeleteService"));
    }

cleanup:
    if (hService) 
    {
        CloseServiceHandle(hService);
    }
    
    
    if(hSCM)
    {
        CloseServiceHandle(hSCM);
    }

    return;
}


/************************************************************************************************
Member:         CServiceSetup::IsInstalled, public.
Synopsis:       Checks for the existence of the service in the system.
Notes:          
History:        01/24/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
bool CServiceSetup::IsInstalled()
{
    bool bInstalled = false;
    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if(NULL != hSCM)
    {
        // try to open the service for configuration, if it succeeds, then the service exists
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if(NULL != hService)
        {
            bInstalled = true;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    
	return bInstalled;
}



/************************************************************************************************
Member:         CServiceSetup::ErrorPrinter, public.
Synopsis:       Message printing for class error handling.
Arguments:      [bForce] - if the service is running, force it to stop and then remove.
Notes:          ISSUE: Standarlize all error printing and handling among classes.
History:        01/24/2001 - created, Luciano Passuello (lucianop).
************************************************************************************************/
DWORD CServiceSetup::ErrorPrinter(LPCTSTR psz, DWORD dwErr)
{
    LPVOID lpvMsgBuf=NULL;
    if(!FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER, 0, dwErr, 
        MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&lpvMsgBuf, 0, 0))
    {
        _tprintf(_T("%s failed: Unknown error %x\n"), psz, dwErr);
    }
    else
    {
        _tprintf(_T("%s failed: %s\n"), psz, (LPTSTR)lpvMsgBuf);
    }

    LocalFree(lpvMsgBuf);
    return dwErr;
}

// End of file ServiceSetup.cpp.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\pop3\service\pop3svc\thdpool.cpp ===
/************************************************************************************************

  Copyright (c) 2001 Microsoft Corporation

File Name:      ThdPool.cpp
Abstract:       Implementation of the thread pool (CThreadPool class)
Notes:          
History:        08/01/2001 Created by Hao Yu (haoyu)

************************************************************************************************/

#include <stdafx.h>

#include <ThdPool.hxx>
#include <SockPool.hxx>
#include <GlobalDef.h>


// The common thread in the thread pool
DWORD WINAPI ThreadProc(LPVOID lpParameter)
{    
    ASSERT(NULL != lpParameter);
    DWORD dwBytesRcvd=0;
    DWORD Flags=0;
    PIO_CONTEXT pIoContext=NULL;
    LPOVERLAPPED pOverlapped=NULL;
    HANDLE hCompPort=lpParameter;
    HRESULT hr=CoInitializeEx(NULL, COINIT_MULTITHREADED); 
    if(FAILED(hr))
    {
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                       EVENT_POP3_COM_INIT_FAIL);
        ExitProcess(hr);
    }
    while(1)
    {

        GetQueuedCompletionStatus(hCompPort,
                                  &dwBytesRcvd,
                                   (PULONG_PTR)(&pIoContext),  
                                  &pOverlapped,
                                  INFINITE);    
        //We don't care about return value
        //since we use the failure case to clean up the IO Context
        if(NULL == pIoContext || SERVICE_STOP_PENDING == g_dwServerStatus)
        { 
            // This is a shutdown signal
            break;
        }
        g_PerfCounters.DecPerfCntr(e_gcFreeThreadCnt);
        pIoContext->m_pCallBack((PULONG_PTR)pIoContext, pOverlapped, dwBytesRcvd);
        g_PerfCounters.IncPerfCntr(e_gcFreeThreadCnt);
        
    } 
    
    g_PerfCounters.DecPerfCntr(e_gcFreeThreadCnt);
    CoUninitialize();
    return 0;

}



CThreadPool::CThreadPool()
{
    InitializeCriticalSection(&m_csInitGuard);
    m_hIOCompPort = NULL;
    m_phTdArray   = NULL;
    m_dwTdCount   = 0;
    m_bInit       = FALSE;
}


CThreadPool::~CThreadPool()
{
   if(m_bInit)
   {
       Uninitialize();
   }
   DeleteCriticalSection(&m_csInitGuard);
}

// Job done in this function:
// 1) Calculate the number of threads need to be created,
//    dwThreadPerProcessor * number of processors of the machine
// 2) Create the IO Completion port
// 3) Create threads  
BOOL CThreadPool::Initialize(DWORD dwThreadPerProcessor)
{
    int i;
    BOOL bRtVal=TRUE;
    SYSTEM_INFO SystemInfo;

    EnterCriticalSection(&m_csInitGuard);
    if(!m_bInit)
    {
        //Get the number of processors of the machine
        GetSystemInfo(&SystemInfo);
    

        if( dwThreadPerProcessor == 0  ||
            dwThreadPerProcessor > MAX_THREAD_PER_PROCESSOR )
        {
            dwThreadPerProcessor = 1;
        }

        m_dwTdCount = SystemInfo.dwNumberOfProcessors * dwThreadPerProcessor;
    

        // Create the IO Completion Port
        m_hIOCompPort = CreateIoCompletionPort  (
                        INVALID_HANDLE_VALUE,
                        NULL,
                        NULL,
                        m_dwTdCount);
        if (NULL == m_hIOCompPort)
        {
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                                   POP3SVR_FAIL_TO_CREATE_IO_COMP_PORT, 
                                   GetLastError());
            goto EXIT;
        }

        m_phTdArray=new HANDLE[m_dwTdCount];

        if( NULL == m_phTdArray)
        {
            
            g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                                   POP3SVR_NOT_ENOUGH_MEMORY);
            goto EXIT;
        }

        // Create the threads
        for (i=0;i<m_dwTdCount; i++)
        {
            m_phTdArray[i] = CreateThread(
                            NULL,
                            0,
                            ThreadProc,
                            m_hIOCompPort,
                            0,
                            NULL);
            if(NULL == m_phTdArray[i])
            {
                g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL, 
                                       POP3SVR_FAILED_TO_CREATE_THREAD, 
                                       GetLastError());
                goto EXIT;
            }        
        }
        m_bInit=TRUE;
    }
    //Set the total free thread count
    g_PerfCounters.SetPerfCntr(e_gcFreeThreadCnt, m_dwTdCount);
    LeaveCriticalSection(&m_csInitGuard);
    return TRUE;

EXIT:

    //In case of error, cleanup and exit
    if(NULL != m_phTdArray)
    {
        for(i=0; i<m_dwTdCount && m_phTdArray[i]; i++ )
        {
            if(m_phTdArray[i]!=NULL)
            {
                TerminateThread(m_phTdArray[i], -1);
                CloseHandle(m_phTdArray[i]);
            }
        }
        delete[](m_phTdArray);
        m_phTdArray=NULL;
    }
    
    if(m_hIOCompPort)
    {
        CloseHandle(m_hIOCompPort);
        m_hIOCompPort=NULL;
    }
    LeaveCriticalSection(&m_csInitGuard);
    return FALSE;
}

// Terminate all threads and delete the completion port.
void CThreadPool::Uninitialize()
{
    int i;
    BOOL bFailedExit=FALSE;
    DWORD dwRt;
    DWORD dwStatus=0;
    EnterCriticalSection(&m_csInitGuard);
    if(m_bInit)
    {
        if(NULL != m_phTdArray)
        {
            for(i=0; i<m_dwTdCount; i++ )
            {
                PostQueuedCompletionStatus(m_hIOCompPort, 0, NULL, NULL);
            }
            dwRt=WaitForMultipleObjects(m_dwTdCount, 
                                        m_phTdArray,
                                        TRUE,
                                        SHUTDOWN_WAIT_TIME);

            if( (WAIT_TIMEOUT == dwRt) ||
                (WAIT_FAILED  == dwRt) )
            {
                for(i=0; i<m_dwTdCount; i++ )
                {
                    //In case some thread did not exit after the wait time
                    //terminate threads by force
                    if(NULL!= m_phTdArray[i])
                    {
                        if( !GetExitCodeThread(m_phTdArray[i], &dwStatus) ||
                            (STILL_ACTIVE==dwStatus))
                        {
                            // This is a bad case, however we can not wait 
                            // forever, cleanup won't be complete in this case.
                            TerminateThread(m_phTdArray[i],0);
                            bFailedExit=TRUE;
                        }
                        CloseHandle(m_phTdArray[i]);
                    }
                }
            }
            else
            {
                for(i=0; i<m_dwTdCount; i++ )
                {
                    if(NULL!= m_phTdArray[i])
                    {
                        CloseHandle(m_phTdArray[i]);
                    }
                }
            }
            delete[](m_phTdArray);
            m_phTdArray=NULL;
        }
    
        if(m_hIOCompPort)
        {
            CloseHandle(m_hIOCompPort);
            m_hIOCompPort=NULL;
        }
        m_bInit=FALSE;
    }
    LeaveCriticalSection(&m_csInitGuard);
    if(bFailedExit)
    {
        g_EventLogger.LogEvent(LOGTYPE_ERR_CRITICAL,
                               EVENT_POP3_SERVER_STOP_ERROR, 
                               E_UNEXPECTED);

        ExitProcess(E_UNEXPECTED);
    }
}

// Associate an IO Context and the IO handle contained 
// with the IO Completion port
BOOL CThreadPool::AssociateContext(PIO_CONTEXT pIoContext)
{
  