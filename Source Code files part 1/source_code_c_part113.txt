- Number of elements in the arrays.

Return Value:

    Returns an NTSTATUS code.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT   i;

    //
    // For each string passed in, allocate a UNICODE_STRING buffer
    // and set it to the UNICODE equivalent of the string passed in.
    //
    for (i = 0; i < NumStrings; i++)
    {
        if (Strings[i])
        {
            Status = VerifyAnsiString(Strings[i]);

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "ConvertStringArrayToUnicode: String %d is not "
                             "a valid Ansi string %#x\n",
                         i,
                         Status);

                break;
            }

            pUStringArray[i] = ElfpAllocateBuffer(sizeof(UNICODE_STRING));

            if (pUStringArray[i])
            {
                pUStringArray[i]->Buffer = NULL;
                Status = RtlAnsiStringToUnicodeString(pUStringArray[i],
                                                      (PANSI_STRING) Strings[i],
                                                      TRUE);
                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG2(ERROR,
                             "ConvertStringArrayToUnicode: Conversion of Ansi string "
                                 "%s to Unicode failed %#x\n",
                             Strings[i]->Buffer,
                             Status);
                }
            }
            else
            {
                ELF_LOG2(ERROR,
                         "ConvertStringArrayToUnicode: Unable to allocate memory for "
                             "Unicode string %d (Ansi string %s)\n",
                         i,
                         Strings[i]->Buffer);

                Status = STATUS_NO_MEMORY;
            }
        }
        else
        {
            pUStringArray[i] = NULL;
        }

        if (!NT_SUCCESS(Status))
        {
            break;                  // Jump out of loop and return status
        }
    }

    //
    // Free any allocations on failure.
    //

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ConvertStringArrayToUnicode: Function failed %#x\n",
                 Status);

        FreePUStringArray(pUStringArray, (USHORT)(i + 1));
    }

    return Status;
}



VOID
FreePUStringArray (
    PUNICODE_STRING  *pUStringArray,
    USHORT          NumStrings
    )
/*++

Routine Description:

  This routine takes the PUNICODE_STRING array that was filled in by
  ConvertStringArrayToUnicode and frees the buffer portion of
  each unicode string and then the UNICODE structure itseld. It handles
  the case where the array may not have been filled completely due
  to insufficient memory.

Arguments:

    pUStringArray   - Array of PUNICODE_STRINGs.
    NumStrings      - Number of elements in the array.

Return Value:

    NONE.

--*/
{
    USHORT      i;

    for (i = 0; i < NumStrings; i++)
    {
        if (pUStringArray[i])
        {
            if (pUStringArray[i]->Buffer)
            {
                //
                // Free the string buffer
                //
                RtlFreeUnicodeString(pUStringArray[i]);
            }

            //
            // Free the UNICODE_STRING itself -- this may be allocated
            // even if the string buffer isn't (if RtlAnsiStringToUnicodeString
            // failed in the ConvertStringArrayToUnicode call)
            //
            ElfpFreeBuffer(pUStringArray[i]);
            pUStringArray[i] = NULL;
        }
    }
}



NTSTATUS
ElfrReportEventA (
    IN      IELF_HANDLE         LogHandle,
    IN      ULONG               Time,
    IN      USHORT              EventType,
    IN      USHORT              EventCategory OPTIONAL,
    IN      ULONG               EventID,
    IN      USHORT              NumStrings,
    IN      ULONG               DataSize,
    IN      PRPC_STRING         ComputerName,
    IN      PRPC_SID            UserSid,
    IN      PRPC_STRING         Strings[],
    IN      PBYTE               Data,
    IN      USHORT              Flags,
    IN OUT  PULONG              RecordNumber OPTIONAL,
    IN OUT  PULONG              TimeWritten OPTIONAL
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrReportEventA API.

Arguments:


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS            Status;
    UNICODE_STRING      ComputerNameU;
    PUNICODE_STRING     *pUStringArray = NULL;

    //
    // Check the handle before proceeding.
    //
    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrReportEventA: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Ensure the caller has write access.
    //
    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_WRITE))
    {
        ELF_LOG0(ERROR,
                 "ElfrReportEventA: Handle doesn't have write access\n");

        return STATUS_ACCESS_DENIED;
    }
    
    //
    // Verify additional arguments.
    //
    Status = VerifyAnsiString((PANSI_STRING) ComputerName);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrReportEventA: ComputerName is not a valid Ansi string %#x\n",
                 Status);

        return Status;
    }

    if (Strings == NULL && NumStrings != 0)
    {
        ELF_LOG1(ERROR,
                 "ElfrReportEventA: Strings is NULL and NumStrings is non-zero (%d)\n",
                 NumStrings);

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Convert the ComputerName to a UNICODE STRING and call the
    // UNICODE API.
    //
    Status = RtlAnsiStringToUnicodeString((PUNICODE_STRING) &ComputerNameU,
                                          (PANSI_STRING) ComputerName,
                                          TRUE);

    if (NT_SUCCESS(Status))
    {
        if (NumStrings)
        {
            pUStringArray = ElfpAllocateBuffer(NumStrings * sizeof(PUNICODE_STRING));

            if (pUStringArray)
            {
                //
                // Convert the array of STRINGs to an array of UNICODE-STRINGs
                // before calling the unicode API.
                // We can just use the array of Strings passed in since we
                // don't need to use it anywhere else.
                //
                Status = ConvertStringArrayToUnicode(pUStringArray,
                                                     (PANSI_STRING *) Strings,
                                                     NumStrings);
            }
            else
            {
                ELF_LOG0(ERROR,
                         "ElfrReportEventA: Unable to allocate pUStringArray\n");

                Status = STATUS_NO_MEMORY;
            }
        }

        if (NT_SUCCESS(Status))
        {
            Status = ElfrReportEventW(LogHandle,
                                      Time,
                                      EventType,
                                      EventCategory,
                                      EventID,
                                      NumStrings,
                                      DataSize,
                                      (PRPC_UNICODE_STRING) &ComputerNameU,
                                      UserSid,
                                      (PRPC_UNICODE_STRING*) pUStringArray,
                                      Data,
                                      Flags,        // Flags        | paired event
                                      RecordNumber, // RecordNumber | support. not in
                                      TimeWritten); // TimeWritten  | product 1

            FreePUStringArray(pUStringArray, NumStrings);
        }

        RtlFreeUnicodeString(&ComputerNameU);
    }
    else
    {
        ELF_LOG2(ERROR,
                 "ElfrReportEventA: Conversion of Ansi string %s to Unicode failed %#X\n",
                 ComputerName->Buffer,
                 Status);
    }

    ElfpFreeBuffer(pUStringArray);

    return Status;
}


NTSTATUS
VerifyElfHandle(
    IN IELF_HANDLE LogHandle
    )

/*++

Routine Description:

    Verify the handle via its DWORD signature.

Arguments:

    LogHandle   - Handle to verify.

Return Value:

    STATUS_SUCCESS          - Presumably valid handle.
    STATUS_INVALID_HANDLE   - Invalid handle.

--*/
{
    NTSTATUS Status;

    if (LogHandle != NULL)
    {
        try
        {
            if (LogHandle->Signature == ELF_CONTEXTHANDLE_SIGN)
            {
                Status = STATUS_SUCCESS;
            }
            else
            {
                ELF_LOG2(ERROR,
                         "VerifyElfHandle: Incorrect LogHandle signature %#x "
                             "(should be %#x)\n",
                         LogHandle->Signature,
                         ELF_CONTEXTHANDLE_SIGN);

                Status = STATUS_INVALID_HANDLE;
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            ELF_LOG1(ERROR,
                     "VerifyElfHandle: Exception %#x caught while probing LogHandle\n",
                     GetExceptionCode());

            Status = STATUS_INVALID_HANDLE;
        }
    }
    else
    {
        ELF_LOG0(ERROR,
                 "VerifyElfHandle: LogHandle is NULL\n");

        Status = STATUS_INVALID_HANDLE;
    }

    return Status;
}


ULONG
Safewcslen(
    UNALIGNED WCHAR *p,
    LONG            MaxLength
    )
/*++

    Safewcslen - Strlen that won't exceed MaxLength

Routine Description:

    This routine is called to determine the size of a UNICODE_STRING

Arguments:
    p         - The string to count.
    MaxLength - The maximum length to look at.


Return Value:

    Number of bytes in the string (or MaxLength)

--*/
{
    ULONG Count = 0;

    if (MaxLength && p)
    {
        while (MaxLength > 1 && *p++ != UNICODE_NULL)
        {
            MaxLength -= sizeof(WCHAR);
            Count     += sizeof(WCHAR);
        }
    }

    return Count;
}


ULONG
Safestrlen(
    UNALIGNED char *p,
    LONG           MaxLength
    )
/*++

    Safestrlen - Strlen that won't exceed MaxLength

Routine Description:

    This routine is called to determine the length of an ANSI_STRING

Arguments:
    p         - The string to count.
    MaxLength - The maximum length to look at.


Return Value:

    Number of chars in the string (or MaxLength)

--*/
{
    ULONG Count = 0;

    if (p)
    {
        while (MaxLength > 0 && *p++ != '\0')
        {
            MaxLength--;
            Count++;
        }
    }

    return Count;
}



NTSTATUS
VerifyUnicodeString(
    IN PUNICODE_STRING pUString
    )

/*++

Routine Description:

    Verify the unicode string. The string is invalid if:
        The UNICODE_STRING structure ptr is NULL.
        The MaximumLength field is invalid (too small).
        The Length field is incorrect.

Arguments:

    pUString    - String to verify.

Return Value:

    STATUS_SUCCESS              - Valid string.
    STATUS_INVALID_PARAMETER    - I wonder.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Check validity of structure fields and actual string
    // length vs. length value supplied
    //
    if (!pUString ||
        pUString->MaximumLength < pUString->Length ||
        pUString->MaximumLength == 1 ||
        pUString->Length != Safewcslen(pUString->Buffer,
                                       pUString->MaximumLength))
    {
        ELF_LOG1(ERROR,
                 "VerifyUnicodeString: String is invalid because %ws\n",
                 (!pUString ?
                     L"it's NULL" :
                     (pUString->MaximumLength < pUString->Length ? L"MaximumLength < Length" :
                                                                   L"Length is incorrect")));

        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}



NTSTATUS
VerifyAnsiString(
    IN PANSI_STRING pAString
    )

/*++

Routine Description:

    Verify the ansi string. The string is invalid if:
        The ANSI_STRING structure ptr is NULL.
        The MaximumLength field is invalid (too small).
        The Length field is incorrect.

Arguments:

    pAString    - String to verify.

Return Value:

    STATUS_SUCCESS              - Valid string.
    STATUS_INVALID_PARAMETER    - I wonder.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (!pAString ||
        pAString->MaximumLength < pAString->Length ||
        pAString->Length != Safestrlen(pAString->Buffer,
                                       pAString->MaximumLength))
    {
        ELF_LOG1(ERROR,
                 "VerifyAnsiString: String is invalid because %ws\n",
                 (!pAString ?
                     L"it's NULL" :
                     (pAString->MaximumLength < pAString->Length ? L"MaximumLength < Length" :
                                                                   L"Length is incorrect")));

        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}



//SS:changes made to enable cluster wide event logging
/****
@func       NTSTATUS | ElfrRegisterClusterSvc|  This is the server entrypoint
            for ElfRegisterClusterSvc.  The cluster service registers
            itself with the event log service to enable propagation of events
            across the cluster.  The binding handle to the cluster service for
            propagation of events is obtained.

@parm       IN  EVENTLOG_HANDLE_W | UNCServerName | This parameter is ignored. It
            is retained for correspondence with other elf apis.

@parm       OUT PULONG | pulSize | A pointer to a long where the size of the
            packed event information structure is returned.

@parm       OUT PBYTE | *ppPackedEventInfo| A pointer to the packed event information
            structure for propagation is returned via this parameter.

@comm       The cluster service propagates events contained in this structure
            and deletes the memory after it has done so.  Once the cluster service has
            registered with the eventlog service, the eventlog service passes up
            logged events to the cluster service for propagation.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f ElfRegisterClusterSvc> <f ElfrDeregisterClusterSvc>
****/
NTSTATUS
ElfrRegisterClusterSvc(
    IN  EVENTLOG_HANDLE_W UNCServerName,
    OUT PULONG            pulSize,
    OUT PBYTE             *ppPackedEventInfo)
{
    ULONG               ulTotalSize       = 0;
    ULONG               ulTotalEventsSize = 0;
    ULONG               ulNumLogFiles     = 0;
    PPROPLOGFILEINFO    pPropLogFileInfo  = NULL;
    NTSTATUS            Status;
    PPACKEDEVENTINFO    pPackedEventInfo  = NULL;
    UINT                i;
    PEVENTSFORLOGFILE   pEventsForLogFile;
    WCHAR               *pBinding         = NULL;
    HANDLE              hClusSvcNode      = NULL;
    UNICODE_STRING      RootRegistryNode;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    BOOL                bAcquired = FALSE;
    BOOL                bInitedCritSec    = FALSE;

    ELF_LOG0(CLUSTER,
             "ElfRegisterClusterSvc: Entry\n");

    //
    //  Check if access can be allowed. Return on failure.
    //
    Status = ElfpClusterRpcAccessCheck ();

    if ( !NT_SUCCESS( Status ) )
    {
        ELF_LOG1(ERROR, "ElfRegisterClusterSvc: Access check failed with status %#x\n", Status);
        return ( Status );
    }

    //
    // Initialize the OUT parameters
    //
    *pulSize = 0;
    *ppPackedEventInfo = NULL;

    //
    // Check to see if the cluster service is installed.
    //
    RtlInitUnicodeString(&RootRegistryNode, REG_CLUSSVC_NODE_PATH);
    InitializeObjectAttributes(&ObjectAttributes,
                               &RootRegistryNode,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&hClusSvcNode, KEY_READ | KEY_NOTIFY, &ObjectAttributes);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ElfRegisterClusterSvc: NtOpenKey of %ws failed %#x\n",
                 REG_CLUSSVC_NODE_PATH,
                 Status);

        goto FnExit;
    }

    NtClose(hClusSvcNode);

    Status = STATUS_SUCCESS;

    //
    // If the cluster service dies and restarts again in the same session
    // then it will try to register again.
    // We dont reinitialize these globals again to prevent leaks
    //
    RtlEnterCriticalSection(&gClPropCritSec);

    if (!gbClustering)
    {
        ELF_LOG0(CLUSTER,
                 "ElfRegisterClusterSvc: gbClustering is FALSE\n");

        //
        // Load the cluster support dll
        //
        ghClusDll = LoadLibraryW(L"CLUSSPRT.DLL");

        if (!ghClusDll)
        {
            RtlLeaveCriticalSection(&gClPropCritSec);
            Status = STATUS_DLL_NOT_FOUND;
            goto FnExit;
        }
    }
    //
    // Get the function entry points
    //
    gpfnPropagateEvents   = (PROPAGATEEVENTSPROC) GetProcAddress(ghClusDll,
                                                                 "PropagateEvents");

    gpfnBindToCluster     = (BINDTOCLUSTERPROC) GetProcAddress(ghClusDll,
                                                               "BindToClusterSvc");

    gpfnUnbindFromCluster = (UNBINDFROMCLUSTERPROC) GetProcAddress(ghClusDll,
                                                                   "UnbindFromClusterSvc");


    if (!gpfnPropagateEvents || !gpfnBindToCluster || !gpfnUnbindFromCluster)
    {
        ELF_LOG1(ERROR,
                 "ElfRegisterClusterSvc: GetProcAddress for %ws in clussprt.dll failed\n",
                 (!gpfnPropagateEvents ? L"PropagateEvents" :
                                         (!gpfnBindToCluster ? L"BindToClusterSvc" :
                                                               L"UnbindFromClusterSvc")));

        RtlLeaveCriticalSection(&gClPropCritSec);
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto FnExit;
    }

    //
    // If we had bound to the cluster service previously, unbind and then rebind
    //
    if (ghCluster)
    {
        (*gpfnUnbindFromCluster)(ghCluster);
    }
    //
    // Bind to the cluster service
    //
    ghCluster = (*gpfnBindToCluster)(NULL);

    if (!ghCluster)
    {
        ELF_LOG1(ERROR,
                 "ElfRegisterClusterSvc: BindToCluster failed %d\n",
                 GetLastError());

        RtlLeaveCriticalSection(&gClPropCritSec);
        Status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

    RtlLeaveCriticalSection(&gClPropCritSec);

    //
    // Since we are going to read the logs, make sure the service is running
    //
    while((GetElState() == RUNNING) && (!bAcquired))
    {

        bAcquired = RtlAcquireResourceShared(&GlobalElfResource,
                                             FALSE);             // Don't wait

        if (!bAcquired)
        {
            ELF_LOG0(CLUSTER,
                     "ElfRegisterClusterSvc: Sleep waiting for global resource\n");

            Sleep(ELF_GLOBAL_RESOURCE_WAIT);
        }
    }

    //
    // If the resource was not available and the status of the service
    // changed to one of the "non-working" states, then we just return
    // unsuccesful.  Rpc should not allow this to happen.
    //
    if (!bAcquired)
    {
        ELF_LOG0(ERROR,
                 "ElfRegisterClusterSvc: Global resource not acquired\n");

        Status = STATUS_UNSUCCESSFUL;
        goto FnExit;
    }

    //
    // Determine the size of and acquire read locks on all files.
    // FindSizeofEventsSinceStart acquires the per-log locks if
    // there are events in that log to propagate.
    //
    Status = FindSizeofEventsSinceStart(&ulTotalEventsSize,
                                        &ulNumLogFiles,
                                        &pPropLogFileInfo);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfRegisterClusterSvc: FindSizeofEventsSinceStart failed %#x\n",
                 Status);

        goto FnExit;
    }

    //
    // If there are any events to propagate
    //
    if (ulNumLogFiles && ulTotalEventsSize && pPropLogFileInfo)
    {
        ulTotalSize = sizeof(PACKEDEVENTINFO)                          // header
                          + (sizeof(ULONG) * ulNumLogFiles)            // offsets
                          + (sizeof(EVENTSFORLOGFILE) * ulNumLogFiles) // info per log
                          + ulTotalEventsSize;

        //
        // Allocate memory
        //
        *ppPackedEventInfo = (PBYTE) ElfpAllocateBuffer(ulTotalSize);

        if (!(*ppPackedEventInfo))
        {
            ELF_LOG1(ERROR,
                     "ElfRegisterClusterSvc: Unable to allocate %d bytes for pPackedEventInfo\n",
                     ulTotalSize);

            //
            // Free the read locks acquired in FindSizeofEventsSinceStart
            //
            for (i=0;i<ulNumLogFiles;i++)
            {
                RtlReleaseResource(&(pPropLogFileInfo[i].pLogFile->Resource));
            }

            Status = STATUS_NO_MEMORY;
            goto FnExit;
        }

        pPackedEventInfo = (PPACKEDEVENTINFO)(*ppPackedEventInfo);

        ELF_LOG2(CLUSTER,
                 "ElfRegisterClusterSvc: Allocated %d bytes, pPackedEventInfo is %#x\n",
                 ulTotalSize,
                 pPackedEventInfo);

        pPackedEventInfo->ulNumEventsForLogFile = ulNumLogFiles;

        for (i = 0;i < ulNumLogFiles; i++)
        {
            //
            // Set the offsets to the EVENTSFORLOGFILE structures
            //
            pPackedEventInfo->ulOffsets[i] =
                ((i == 0) ? (sizeof(PACKEDEVENTINFO) + ulNumLogFiles * sizeof(ULONG)) :
                            (pPackedEventInfo->ulOffsets[i - 1]
                                 + (pPropLogFileInfo[i - 1].ulTotalEventSize
                                 + sizeof(EVENTSFORLOGFILE))));

            ELF_LOG2(CLUSTER,
                     "ElfRegisterClusterSvc: pPackedEventInfo->ulOffsets[%d] = %d\n",
                     i,
                     pPackedEventInfo->ulOffsets[i]);

            pEventsForLogFile = (PEVENTSFORLOGFILE) ((PBYTE) pPackedEventInfo
                                                         + pPackedEventInfo->ulOffsets[i]);

            //
            // Set the size of the ith EVENTSFORLOGFILE structure
            //
            pEventsForLogFile->ulSize = sizeof(EVENTSFORLOGFILE)
                                            + pPropLogFileInfo[i].ulTotalEventSize;

            //
            // Copy the file name (or should we get the module name?). StringCchCopy will NULL
            // terminate the destination buffer in all cases.
            //
            StringCchCopy( pEventsForLogFile->szLogicalLogFile,
                           MAXLOGICALLOGNAMESIZE,
                           pPropLogFileInfo[i].pLogFile->LogModuleName->Buffer );

            //
            // Set the number of events
            //
            pEventsForLogFile->ulNumRecords = pPropLogFileInfo[i].ulNumRecords;

            ELF_LOG3(CLUSTER,
                     "ElfRegisterClusterSvc: pEventsForLogFile struct -- ulSize = %d, "
                         "Logical file = %ws, ulNumRecords = %d\n",
                     pEventsForLogFile->ulSize,
                     pEventsForLogFile->szLogicalLogFile,
                     pEventsForLogFile->ulNumRecords);

            //
            // Get the events
            //
            Status = GetEventsToProp((PEVENTLOGRECORD) ((PBYTE) pEventsForLogFile
                                                            + sizeof(EVENTSFORLOGFILE)),
                                                        pPropLogFileInfo + i);

            //
            // If that fails, set the ulNumRecords to 0 so tha
            // on a write this data is discarded.
            //
            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "ElfRegisterClusterSvc: GetEventsToProp for %ws log failed %#x\n",
                         pPropLogFileInfo[i].pLogFile->LogModuleName->Buffer,
                         Status);

                pEventsForLogFile->ulNumRecords=0;

                //
                // Reset the error -- we will go to the next file
                //
                Status = STATUS_SUCCESS;
            }

            //
            // Advance the startpointer for all the files so if the cluster service
            // dies and is restarted, these events won't be propagated again
            //
            pPropLogFileInfo[i].pLogFile->SessionStartRecordNumber =
                pPropLogFileInfo[i].pLogFile->CurrentRecordNumber;

            ELF_LOG1(CLUSTER,
                     "ElfRegisterClusterSvc: Done processing %ws log\n",
                     pPropLogFileInfo[i].pLogFile->LogModuleName->Buffer);

            RtlReleaseResource (&(pPropLogFileInfo[i].pLogFile->Resource));
        }

        //
        // Set the total size
        //
        pPackedEventInfo->ulSize = pPackedEventInfo->ulOffsets[ulNumLogFiles - 1]
                                       + pPropLogFileInfo[ulNumLogFiles - 1].ulTotalEventSize
                                       + sizeof(EVENTSFORLOGFILE);

        *pulSize = pPackedEventInfo->ulSize;
    }

    RtlEnterCriticalSection (&gClPropCritSec);

    //
    // Set the flag to true so that propagation is now on.
    //
    gbClustering = TRUE;

    //
    //  Initialize the support for batching events and propagating them to clussvc.
    //
    Status = ElfpInitializeBatchingSupport();

    RtlLeaveCriticalSection (&gClPropCritSec);

FnExit:

    if (!NT_SUCCESS(Status))
    {
        //
        // Something went wrong
        //
        ELF_LOG1(ERROR,
                 "ElfRegisterClusterSvc: Exiting with error %#x\n",
                 Status);

        RtlEnterCriticalSection(&gClPropCritSec);

        gbClustering = FALSE;

        if (ghCluster && gpfnUnbindFromCluster)
        {
            (*gpfnUnbindFromCluster)(ghCluster);
            ghCluster = NULL;
        }

        if (ghClusDll)
        {
            FreeLibrary(ghClusDll);
            ghClusDll = NULL;
        }

        RtlLeaveCriticalSection(&gClPropCritSec);
    }

    //
    // Free the pPropLogFileInfo stucture
    //
    ElfpFreeBuffer(pPropLogFileInfo);

    if (bAcquired)
    {
        ReleaseGlobalResource();
    }

    ELF_LOG1(CLUSTER,
             "ElfRegisterClusterSvc: Returning status %#x\n",
             Status);

    ELF_LOG2(CLUSTER,
             "ElfRegisterClusterSvc: *pulSize = %d, *ppPackedEventInfo = %#x\n",
             *pulSize,
             *ppPackedEventInfo);

    return Status;
}



/****
@func       NTSTATUS | ElfrDeregisterClusterSvc| This is the server entry point
            for ElfDeregisterClusterSvc().  Before shutdown the cluster
            service deregisters itself for propagation of events from the
            eventlog service.

@comm       Note that events logged after the cluster service goes down
            are not propagated.  Binding handle is freed.

@rdesc      Returns a result code. ERROR_SUCCESS on success.

@xref       <f ElfrRegisterClusterSvc>
****/
NTSTATUS
ElfrDeregisterClusterSvc(
    IN EVENTLOG_HANDLE_W UNCServerName
    )
{
    NTSTATUS    Status;
    
    ELF_LOG0(CLUSTER,
             "ElfDeregisterClusterSvc: ElfrDeregisterClusterSvc: Entry\n");

    //
    //  Check if access can be allowed. Return on failure.
    //
    Status = ElfpClusterRpcAccessCheck ();

    if ( !NT_SUCCESS( Status ) )
    {
        ELF_LOG1(ERROR, "ElfDeregisterClusterSvc: Access check failed with status %#x\n", Status);
        return ( Status );
    }

    RtlEnterCriticalSection (&gClPropCritSec);

    if (gbClustering)
    {
        gbClustering = FALSE;

        //
        // Unload the cluster support dll
        //
        if (ghCluster && gpfnUnbindFromCluster)
        {
            (*gpfnUnbindFromCluster)(ghCluster);
            ghCluster = NULL;
        }

        if (ghClusDll)
        {
            FreeLibrary(ghClusDll);
            ghClusDll = NULL;
        }
    }

    RtlLeaveCriticalSection (&gClPropCritSec);

    ELF_LOG0(CLUSTER,
             "ElfDeregisterClusterSvc: Exit\n");

    return STATUS_SUCCESS;
}



/****
@func   NTSTATUS | ElfrWriteClusterEvents| The cluster service calls this
        api to log events reported at other nodes of the cluster in the event log files.

@parm   IN EVENTLOG_HANDLE_W | UNCServerName | Not used.

@parm   IN ULONG | ulSize | The size of the    packed event information structure.

@parm   IN PBYTE | pPackedEventInfo| A pointer to the packed event information
        structure for propagation.

@comm   The pPackedEventInfo is delinearized into eventlogbuffers for different event
        log files and the events are recorded in the appropriate eventlog file.  Multiple
        events per log file are supported.

@rdesc  Returns a result code. ERROR_SUCCESS on success.

@xref
****/
NTSTATUS
ElfrWriteClusterEvents(
    IN EVENTLOG_HANDLE_W UNCServerName,
    IN ULONG             ulSize,
    IN BYTE              *pBuffer
    )
{
    UINT                i,j;
    PEVENTSFORLOGFILE   pEventsForLogFile;
    UNICODE_STRING      ModuleName;
    PLOGMODULE          pLogModule;
    PEVENTLOGRECORD     pEventLogRecord;
    ELF_REQUEST_RECORD  Request;
    PPACKEDEVENTINFO    pPackedEventInfo;
    NTSTATUS            Status = STATUS_SUCCESS;
    WRITE_PKT           WritePkt;

    //
    //  Check if access can be allowed. Return on failure.
    //
    Status = ElfpClusterRpcAccessCheck ();

    if ( !NT_SUCCESS( Status ) )
    {
        ELF_LOG1(ERROR, "ElfrWriteClusterEvents: Access check failed with status %#x\n", Status);
        return ( Status );
    }

    //
    // We want to put this in a try/except block because we're
    // probing potentially bad user-supplied data.
    //
    try
    {
        pPackedEventInfo = (PPACKEDEVENTINFO)pBuffer;

        
        //
        // Validate input parameters and check that clustering is on
        //
        if (!pPackedEventInfo
             ||
            !ulSize
             ||
            (((PBYTE)pPackedEventInfo + sizeof(PACKEDEVENTINFO)) > (PBYTE)(pBuffer + ulSize))
             ||
             ((PBYTE)pPackedEventInfo + ulSize <= pBuffer)   //if ulSize is large to cause overflow 
             ||
            (pPackedEventInfo->ulSize != ulSize)
             ||
            (!gbClustering))
        {
            ELF_LOG1(ERROR,
                     "ElfrWriteClusterEvents: Invalid parameter passed in -- %ws\n",
                     (!pPackedEventInfo ?
                          L"pPackedEventInfo is NULL" :
                          (!ulSize ?
                               L"ulSize is 0" :
                               (!gbClustering ?
                                    L"gbClustering is FALSE" :
                                    (pPackedEventInfo->ulSize != ulSize ?
                                         L"ulSize mismatch" :
                                         L"pBuffer too small or ulSize too large")))));

            Status = STATUS_INVALID_PARAMETER;
            goto FnExit;
        }

        ELF_LOG2(CLUSTER,
                 "ElfrWriteClusterEvents: ulSize = %d, ulNumEventsForLogFile = %d\n",
                 ulSize,
                 pPackedEventInfo->ulNumEventsForLogFile);


        if ((((PBYTE)pPackedEventInfo + sizeof(PACKEDEVENTINFO) + 
            (sizeof(DWORD) * (pPackedEventInfo->ulNumEventsForLogFile))) < 
            (PBYTE)(pBuffer)) ||
            (((PBYTE)pPackedEventInfo + sizeof(PACKEDEVENTINFO) + 
            (sizeof(DWORD) * (pPackedEventInfo->ulNumEventsForLogFile))) < 
            (PBYTE)(pBuffer + sizeof(PACKEDEVENTINFO))))                 
        {
            ELF_LOG0(ERROR,
                     "ElfrWriteClusterEvents: Buffer/values passed in caused overflow\n");
            Status = STATUS_INVALID_PARAMETER;                     
            goto FnExit;
        }

        //check to see whether we have valid offsets for each eventlog file in the buffer
        //first check to see the buffer passed in is big enough to contain the offsets
        if (((PBYTE)pPackedEventInfo + sizeof(PACKEDEVENTINFO) + 
            (sizeof(DWORD) * (pPackedEventInfo->ulNumEventsForLogFile))) > 
            (PBYTE)(pBuffer + ulSize))
        {
            ELF_LOG0(ERROR,
                     "ElfrWriteClusterEvents: Buffer passed in doesnt contain offsets for all the eventlogfiles\n");
            Status = STATUS_INVALID_PARAMETER;
            goto FnExit;
        }
        //
        // Setup the request packet
        //
        Request.Pkt.WritePkt = &WritePkt;   // Set up write packet in request packet
        Request.Flags = 0;

        //
        // For each log
        //
        for (i = 0; i < pPackedEventInfo->ulNumEventsForLogFile; i++)
        {
            pEventsForLogFile = (PEVENTSFORLOGFILE) ((PBYTE)pPackedEventInfo +
                                                         pPackedEventInfo->ulOffsets[i]);

            //
            // Check for overflow or pointer past end of buffer
            //
            if (((PBYTE) pEventsForLogFile < pBuffer)
                   ||
                (((PBYTE) pEventsForLogFile + sizeof(EVENTSFORLOGFILE)) >
                       (PBYTE) (pBuffer + ulSize)))
            {
                ELF_LOG2(ERROR,
                         "ElfrWriteClusterEvents: Bad offset for log %d -- %ws\n",
                         i,
                         ((PBYTE) pEventsForLogFile < pBuffer ? L"offset caused overflow" :
                                                                L"offset past end of buffer"));

                Status = STATUS_INVALID_PARAMETER;
                goto FnExit;
            }

            ELF_LOG2(CLUSTER,
                     "ElfrWriteClusterEvents: szLogicalFile = %ws, ulNumRecords = %d\n",
                     pEventsForLogFile->szLogicalLogFile,
                     pEventsForLogFile->ulNumRecords);

            //
            // Find the module -- since we dont trust this string, force null termination
            //
            pEventsForLogFile->szLogicalLogFile[MAXLOGICALLOGNAMESIZE - 1] = L'\0';

            RtlInitUnicodeString(&ModuleName, pEventsForLogFile->szLogicalLogFile);
            pLogModule = GetModuleStruc(&ModuleName);

            if (!pLogModule)
            {
                ELF_LOG1(ERROR,
                     "ElfrWriteClusterEvents: Bogus ModuleName %ws passed in\n",
                     pEventsForLogFile->szLogicalLogFile);
                //skip this log file and go to the next one                     
                continue;                                     
            }
            

            //
            // GetModuleStruc always returns something non-NULL -- if the
            // given module name is bogus, we'll use the Application log.
            //
            ELF_LOG2(CLUSTER,
                     "ElfrWriteClusterEvents: Processing records for %ws module (%ws log)\n",
                     pLogModule->ModuleName,
                     pLogModule->LogFile->LogModuleName->Buffer);

            Request.Module  = pLogModule;
            Request.LogFile = Request.Module->LogFile;
            Request.Command = ELF_COMMAND_WRITE;
            pEventLogRecord = (PEVENTLOGRECORD) (pEventsForLogFile->pEventLogRecords);

            for (j = 0;
                 j < pEventsForLogFile->ulNumRecords &&
                     pEventLogRecord->Reserved == ELF_LOG_FILE_SIGNATURE;
                 j++)
            {
                //
                // Check for pointer past end of buffer
                //
                if (((PBYTE) pEventLogRecord + pEventLogRecord->Length) >
                        (PBYTE) (pBuffer + ulSize))
                {
                    ELF_LOG3(ERROR,
                             "ElfrWriteClusterEvents: Record %d for %ws module "
                                 "(%ws log) too long\n",
                             j,
                             pLogModule->ModuleName,
                             pLogModule->LogFile->LogModuleName->Buffer);

                    Status = STATUS_INVALID_PARAMETER;
                    goto FnExit;
                }

                //
                // Fill in a request packet for the current record
                //
                Request.Pkt.WritePkt->Buffer   = pEventLogRecord;
                Request.Pkt.WritePkt->Datasize = pEventLogRecord->Length;

                //
                // SS: Should we get exclusive access to the log so that
                //     the current record number is not incremented
                //     for an event that needs to be propagated
                //     before the session start record number is set here?
                //
                ElfPerformRequest(&Request);

                //
                // Advance the session start record number, so that
                // we don't propagate an event propagated to us
                //
                pLogModule->LogFile->SessionStartRecordNumber =
                    pLogModule->LogFile->CurrentRecordNumber;

                //
                // Extract status of operation from the request packet
                //
                Status = Request.Status;

                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG3(ERROR,
                             "ElfrWriteClusterEvents: Failed to write record %d to "
                                 "%ws log %#x\n",
                             j,
                             pLogModule->LogFile->LogModuleName->Buffer,
                             Status);
                }

                pEventLogRecord = (PEVENTLOGRECORD) ((PBYTE) pEventLogRecord +
                                                          pEventLogRecord->Length);
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG1(ERROR,
                 "ElfrWriteClusterEvents: Exception %#x caught probing passed-in buffer\n",
                 GetExceptionCode());

        Status = STATUS_INVALID_PARAMETER;
    }

FnExit:
    return Status;
}

/****
@func   NTSTATUS | ElfpInitializeBatchingSupport | Initialize the batching support structures.

@comm   This initializes the global structures and threads necessary for batching support.

@parm   None.

@rdesc  STATUS_SUCCESS on success, an NT status error otherwise.

@xref
****/
NTSTATUS
ElfpInitializeBatchingSupport(
    VOID
    )
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    BOOL        fCritSecInitialized = TRUE;
        
    if ( g_fBatchingSupportInitialized ) goto FnExit;

    //
    // Initialize a CritSec for clustering support
    //
    ntStatus = ElfpInitCriticalSection( &g_CSBatchQueue );

    if ( !NT_SUCCESS( ntStatus ) )
    {
        ELF_LOG1(ERROR,
                 "ElfpInitializeBatchingSupport: Unable to init g_CSBatchQueue, status %#x\n",
                 ntStatus);
        fCritSecInitialized = FALSE;
        goto FnExit;
    }

    //
    //  Initialize the timer that supports batched event propagation into cluster service
    //
    g_hBatchingSupportTimerQueue = CreateTimerQueue();

    if ( g_hBatchingSupportTimerQueue == NULL )
    {
        ntStatus = STATUS_UNSUCCESSFUL;
        ELF_LOG1(ERROR, "ElfpInitializeBatchingSupport: Unable to create timer queue, Status=%d\n", 
                GetLastError());
        goto FnExit;
    }

    //
    //  Allocate memory for all structures here. Memory for these structures is not freed and it is
    //  a one-time only allocation.
    //
    g_pBatchQueueElement = ElfpAllocateBuffer ( sizeof ( BATCH_QUEUE_ELEMENT ) * MAX_BATCH_QUEUE_ELEMENTS );

    if ( g_pBatchQueueElement == NULL )
    {
        ntStatus = STATUS_NO_MEMORY;
        ELF_LOG1(ERROR, "ElfpInitializeBatchingSupport: Memalloc for batch queue elements failed, Status=%d\n", 
                GetLastError());
        goto FnExit;
    }

    g_pcbRecordsOfSameType = ElfpAllocateBuffer ( sizeof ( DWORD ) * MAX_BATCH_QUEUE_ELEMENTS );

    if ( g_pcbRecordsOfSameType == NULL )
    {
        ntStatus = STATUS_NO_MEMORY;
        ELF_LOG1(ERROR, "ElfpInitializeBatchingSupport: Memalloc for records of same type array failed, Status=%d\n", 
                GetLastError());
        goto FnExit;
    }

    g_pdwRecordType = ElfpAllocateBuffer ( sizeof ( DWORD ) * MAX_BATCH_QUEUE_ELEMENTS );

    if ( g_pdwRecordType == NULL )
    {
        ntStatus = STATUS_NO_MEMORY;
        ELF_LOG1(ERROR, "ElfpInitializeBatchingSupport: Memalloc for records type array failed, Status=%d\n", 
                GetLastError());
        goto FnExit;
    }

    g_pPropagatedInfo = ElfpAllocateBuffer ( sizeof ( PROPINFO ) * MAX_BATCH_QUEUE_ELEMENTS );

    if ( g_pPropagatedInfo == NULL )
    {
        ntStatus = STATUS_NO_MEMORY;
        ELF_LOG1(ERROR, "ElfpInitializeBatchingSupport: Memalloc for propinfo array failed, Status=%d\n", 
                GetLastError());
        goto FnExit;
    }
        
    g_fBatchingSupportInitialized = TRUE;

FnExit:
    if ( ntStatus != STATUS_SUCCESS )
    {
        //
        //  Free allocated resources on failure
        //
        if ( fCritSecInitialized )
        {
            DeleteCriticalSection ( &g_CSBatchQueue );
        }
        if ( g_hBatchingSupportTimerQueue )
        {
            DeleteTimerQueueEx ( g_hBatchingSupportTimerQueue, NULL );
            g_hBatchingSupportTimerQueue = NULL;
        }

        ElfpFreeBuffer ( g_pdwRecordType );
        g_pdwRecordType = NULL;

        ElfpFreeBuffer ( g_pPropagatedInfo );
        g_pPropagatedInfo = NULL;

        ElfpFreeBuffer ( g_pBatchQueueElement );
        g_pBatchQueueElement = NULL;

        ElfpFreeBuffer ( g_pcbRecordsOfSameType );
        g_pcbRecordsOfSameType = NULL;
    }
    
    return ( ntStatus );
}// ElfpInitializeBatchingSupport

/****
@func   NTSTATUS | ElfpSaveEventBuffer | Save the module name and a pointer to the event buffer.

@parm   IN PLOGMODULE | pModule | A pointer to a module for the eventlog file.

@parm   IN PVOID | pEventBuffer | A pointer to the event buffer.

@parm   IN DWORD | dwRecordLength | The length of the event buffer in bytes.

@comm   This saves a pointer to the supplied eventlog buffer so that it can be batch sent to the cluster service
        for replication.

@rdesc  Returns a result code. STATUS_SUCCESS on success.

@xref
****/
NTSTATUS
ElfpSaveEventBuffer(
    IN PLOGMODULE   pModule,
    IN PVOID        pEventBuffer,
    IN DWORD        dwRecordLength
    )
{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    LPWSTR      lpszLogFileName = NULL;
    LPWSTR      lpszLogicalLogFile = NULL;
    DWORD       cchLogFileName, cchLogicalLogFile;

    //
    //  If the batching support system is not initialized or if you don't detect cluster service as having
    //  registered with the eventlog service, just return. Note that you cannot afford to get the 
    //  gClPropCritSec here since that could hang the ElfReportEvent API if we are hung in the propagate to the 
    //  cluster service.
    //
    if ( ( g_fBatchingSupportInitialized == FALSE ) ||
          ( gbClustering == FALSE ) )
    {
        ElfpFreeBuffer( pEventBuffer );
        return ( ntStatus );
    }

    //
    //  To conserve resources, let us limit the max size of records we accept.
    //
    if ( dwRecordLength >= MAXSIZE_OF_EVENTSTOPROP )
    {
        ntStatus = STATUS_BUFFER_OVERFLOW;
        ELF_LOG1(ERROR, "ElfpSaveEventBuffer: Eventlog record size %d is bigger than supported size\n",
                 dwRecordLength);
        ElfpFreeBuffer( pEventBuffer );
        return( ntStatus );
    }

    //
    //  This is a hack to prevent replication of the time blob delta events generated by the 
    //  cluster service.
    //
    if ( ( ( ( PEVENTLOGRECORD ) pEventBuffer )->EventID == CLUSSPRT_EVENT_TIME_DELTA_INFORMATION ) &&
         ( !lstrcmpW( ( LPWSTR ) ( ( PBYTE ) pEventBuffer + sizeof( EVENTLOGRECORD ) ), L"ClusSvc" ) ) )
    {
        ElfpFreeBuffer( pEventBuffer );
        return( ntStatus );
    }
    
    RtlEnterCriticalSection ( &g_CSBatchQueue );

    //
    // If the batch queue is full, you would just drop stuff on the floor. 
    //
    if ( g_dwFirstFreeIndex == MAX_BATCH_QUEUE_ELEMENTS )
    {
        ELF_LOG2(ERROR, "ElfpSaveEventBuffer: Batch queue full, dropped event of length %d in log file %ws\n",
                 dwRecordLength,
                 pModule->LogFile->LogModuleName->Buffer);
        ntStatus = STATUS_BUFFER_OVERFLOW;
        goto FnExit;
    }

    //
    //  Save the log file name, event buffer pointer and record length. Memory for this will be freed
    //  at batching time by ElfpBatchEventsAndPropagate.
    //
    cchLogicalLogFile = lstrlen ( pModule->LogFile->LogModuleName->Buffer ) + 1;

    lpszLogicalLogFile = ElfpAllocateBuffer ( cchLogicalLogFile * sizeof ( WCHAR ) );

    if ( lpszLogicalLogFile == NULL )
    {
        ntStatus = STATUS_NO_MEMORY;
        ELF_LOG0(ERROR, "ElfpSaveEventBuffer: Unable to alloc memory for logical log file name\n");
        goto FnExit;
    }

    //
    //  Save the log file name and the current record number. This information will be used
    //  to update the session start record number in the log file after the event is
    //  is successfully sent to the cluster service. Memory for this will be freed at batching
    //  time by ElfpBatchEventsAndPropagate..
    //
    cchLogFileName = lstrlen ( pModule->LogFile->LogFileName->Buffer ) + 1;
    
    lpszLogFileName = ElfpAllocateBuffer ( cchLogFileName * sizeof ( WCHAR ) );

    if ( lpszLogFileName == NULL )
    {
        ntStatus = STATUS_NO_MEMORY;
        ELF_LOG0(ERROR, "ElfpSaveEventBuffer: Unable to alloc memory for log file name\n");
        goto FnExit;
    }

    g_pBatchQueueElement[g_dwFirstFreeIndex].lpszLogicalLogFile = lpszLogicalLogFile;

    //
    // StringCchCopy will NULL terminate the string in the destination buffer. Save the log module
    // name.
    //
    StringCchCopy ( g_pBatchQueueElement[g_dwFirstFreeIndex].lpszLogicalLogFile, 
                    cchLogicalLogFile,
                    pModule->LogFile->LogModuleName->Buffer );

    //
    //  Just save the pointer to the event buffer. Memory will be freed at batching time by 
    //  ElfpBatchEventsAndPropagate.
    //
    g_pBatchQueueElement[g_dwFirstFreeIndex].pEventBuffer = pEventBuffer;
    g_pBatchQueueElement[g_dwFirstFreeIndex].dwRecordLength = dwRecordLength;

    //
    // StringCchCopy will NULL terminate the string in the destination buffer. Save the log file name.
    //
    StringCchCopy ( lpszLogFileName, cchLogFileName, pModule->LogFile->LogFileName->Buffer );
    
    RtlInitUnicodeString ( &g_pBatchQueueElement[g_dwFirstFreeIndex].PropagatedInfo.LogFileName, lpszLogFileName );
    g_pBatchQueueElement[g_dwFirstFreeIndex].PropagatedInfo.dwCurrentRecordNum = pModule->LogFile->CurrentRecordNumber;
    
    if ( g_hBatchingSupportTimer == NULL )
    {
        //
        //  Insert a timer action into the timer queue.
        //
        if ( !CreateTimerQueueTimer( &g_hBatchingSupportTimer,                          // Timer handle
                                     g_hBatchingSupportTimerQueue,                      // Timer queue handle
                                     ElfpBatchEventsAndPropagate,                       // Callback
                                     NULL,                                              // Context
                                     BATCHING_SUPPORT_TIMER_DUE_TIME,                   // Due time in msec
                                     0,                                                 // Period (fire once)
                                     WT_EXECUTELONGFUNCTION ) )                         // Long func exec
        {
            ELF_LOG1(ERROR, "ElfpInitializeBatchingSupport: Unable to create timer, Status=%d\n", 
                    GetLastError());
            ntStatus = STATUS_UNSUCCESSFUL;
            goto FnExit;
        }
    }

    g_dwFirstFreeIndex ++;

FnExit:    
    RtlLeaveCriticalSection ( &g_CSBatchQueue );

    if ( ntStatus != STATUS_SUCCESS )
    {
        ElfpFreeBuffer( pEventBuffer );
        ElfpFreeBuffer ( lpszLogFileName );
        ElfpFreeBuffer ( lpszLogicalLogFile );
    }

    return ( ntStatus );
}// ElfpSaveEventBuffer

/****
@func   NTSTATUS | ElfpBatchEventsAndPropagate | Read eventlog records, batch them and ship them.

@comm   This reads the eventlog records saved in the batch queue, packs them in one structure and ships
        them off to the cluster service.

@parm   None used.

@rdesc  None.

@xref
****/
VOID CALLBACK
ElfpBatchEventsAndPropagate(
    IN PVOID    pContext,
    IN BOOLEAN  fTimerFired
    )
{
    DWORD               i, j, k, dwRecordIndex, dwTypeNumber = 1;
    ULONG               ulTotalSize = 0, ulTotalLogFiles = 0;
    PPACKEDEVENTINFO    pPackedEventInfo = NULL;
    PEVENTSFORLOGFILE   pEventsForLogFile = NULL;
    DWORD               cbMostRecentTotalRecordLength = 0;
    LPBYTE              pDest;
    DWORD               dwStatus = ERROR_INVALID_PARAMETER;
    DWORD               dwFirstFreeIndex = 0;

    UNREFERENCED_PARAMETER( pContext );
    UNREFERENCED_PARAMETER( fTimerFired );
        
    RtlEnterCriticalSection ( &g_CSBatchQueue );

    //
    //  You should never have 0 elements in the batch queue
    //
    ASSERT ( g_dwFirstFreeIndex != 0 );

    dwFirstFreeIndex = g_dwFirstFreeIndex;
        
    //
    //  g_pcbRecordsOfSameType[i] - Total count of bytes of eventlog records of the same type. Only the first element
    //  of each type has this field set, for subsequent ones of the same type, this field will be 0
    //
    //  g_pdwRecordType[i] - Type number for record i. Type number explained below. All elements will have this
    //  field set correctly.
    //
    ZeroMemory( g_pcbRecordsOfSameType, sizeof ( *g_pcbRecordsOfSameType ) * MAX_BATCH_QUEUE_ELEMENTS );
    ZeroMemory( g_pdwRecordType, sizeof ( *g_pdwRecordType ) * MAX_BATCH_QUEUE_ELEMENTS );
    
    //
    //  Estimate how much contiguous memory is needed. In the process, mark a type number for each record. The type
    //  number will be same for records of the same type.
    //
    for ( i=0; i<g_dwFirstFreeIndex; i++ )
    {
        //
        //  Check if this event record has been parsed already.
        //
        if ( g_pdwRecordType[i] != 0 ) continue;

        //
        //  This record has not been categorized yet. So, compare this record with other records
        //  downstream and categorize all like ones into the same type.
        //
        for ( j=i; j<g_dwFirstFreeIndex; j++ )
        {
            if ( ( g_pdwRecordType[j] == 0 ) && 
                  ( ( j == i ) ||
                     ( lstrcmp( g_pBatchQueueElement[i].lpszLogicalLogFile, 
                                    g_pBatchQueueElement[j].lpszLogicalLogFile ) == 0 ) ) )
            {
                g_pcbRecordsOfSameType[i] += g_pBatchQueueElement[j].dwRecordLength;
                g_pdwRecordType[j] = dwTypeNumber;
            }
        } // for
        //
        //  Bump up the type number
        //
        dwTypeNumber += 1;
    } // for

    //
    //  Calculate the total size needed for the packed eventlog info. Total size = Size of all eventlog
    //  records + size of headers prepended to each record + size of header for the overall package
    //
    for ( i=0; i<g_dwFirstFreeIndex; i++ )
    {
        if ( g_pcbRecordsOfSameType[i] != 0 )
        {
            ulTotalSize += sizeof( EVENTSFORLOGFILE ) + g_pcbRecordsOfSameType[i];
            ulTotalLogFiles += 1;
        }
        //
        //  Initialize the propagation information
        //
        g_pPropagatedInfo[i].dwCurrentRecordNum = 0;
        RtlInitUnicodeString ( &g_pPropagatedInfo[i].LogFileName, NULL );
    } // for

    ulTotalSize += sizeof( PACKEDEVENTINFO ) + ulTotalLogFiles * sizeof ( ULONG );

    //
    //  Allocate the packed info struct. Packed event info consists of:
    //
    //      1. PACKEDEVENTINFO structure
    //      2. Offsets into the start of EVENTSFORLOGFILE (total number of offsets equals ulTotalLogFiles)
    //          from the beginning of the packed info structure.
    //      3. A series of 4 and 5, one set for each log file.
    //          4. EVENTSFORLOGFILE structure
    //          5. A series of eventlog records
    //
    pPackedEventInfo = ( PPACKEDEVENTINFO ) ElfpAllocateBuffer( ulTotalSize );

    if ( !pPackedEventInfo )
    {
        ELF_LOG1(ERROR, "ElfpBatchEventsAndPropagate: Unable to allocate %d bytes for PackedEventInfo\n",
                 ulTotalSize);
        goto CleanupTimerAndExit;
    }

    //
    //  First of, initialize the header and in a loop initialize the offset fields in the 
    //  header
    //
    pPackedEventInfo->ulNumEventsForLogFile = ulTotalLogFiles;
    pPackedEventInfo->ulSize = ulTotalSize;

    j = 0;
    for ( i=0; i<g_dwFirstFreeIndex; i++ )
    {
        if ( g_pcbRecordsOfSameType[i] != 0 )
        {
            //
            //  You are now looking at the first element of one type. Calculate the offset at which
            //  you need to start copying the eventlog info.
            //
            pPackedEventInfo->ulOffsets[j] = ( j== 0 ) ?
                                             ( sizeof ( PACKEDEVENTINFO ) + ulTotalLogFiles * sizeof ( ULONG ) ) :
                                             ( pPackedEventInfo->ulOffsets[j-1] + sizeof ( EVENTSFORLOGFILE ) +
                                                cbMostRecentTotalRecordLength );

            pEventsForLogFile = ( PEVENTSFORLOGFILE ) ( ( LPBYTE ) pPackedEventInfo + pPackedEventInfo->ulOffsets[j] );
            pEventsForLogFile->ulSize = g_pcbRecordsOfSameType[i] + sizeof ( EVENTSFORLOGFILE );

            //
            //  StringCchCopy will NULL terminate the buffer.
            //
            StringCchCopy ( pEventsForLogFile->szLogicalLogFile, 
                            MAXLOGICALLOGNAMESIZE,
                            g_pBatchQueueElement[i].lpszLogicalLogFile );
                            
            ElfpFreeBuffer ( g_pBatchQueueElement[i].lpszLogicalLogFile );
            g_pBatchQueueElement[i].lpszLogicalLogFile = NULL;

            pEventsForLogFile->ulNumRecords = 0;
            pDest = ( LPBYTE ) pEventsForLogFile->pEventLogRecords;
            
            for ( k=i; k<g_dwFirstFreeIndex; k++ )
            {   
                if ( g_pdwRecordType[k] == g_pdwRecordType[i] )
                {
                    //
                    //  We are looking at two records of the same type. Copy the eventlog record into the
                    //  buffer. Increment the number of log records.
                    //
                    CopyMemory( pDest,
                                g_pBatchQueueElement[k].pEventBuffer,
                                g_pBatchQueueElement[k].dwRecordLength );
                    pEventsForLogFile->ulNumRecords ++;
                    pDest += g_pBatchQueueElement[k].dwRecordLength;
                    ElfpFreeBuffer ( g_pBatchQueueElement[k].pEventBuffer );
                    ElfpFreeBuffer ( g_pBatchQueueElement[k].lpszLogicalLogFile );
                }
            } // for
            cbMostRecentTotalRecordLength = g_pcbRecordsOfSameType[i];
            j++;
        }// if

        //
        //  Save the propagation info right here so it can be used after the events are
        //  propagated. Note that we cannot rely on the g_pBatchQueueElement after the batch
        //  queue lock is released.
        //
        g_pPropagatedInfo[i].dwCurrentRecordNum = g_pBatchQueueElement[i].PropagatedInfo.dwCurrentRecordNum;
        g_pPropagatedInfo[i].LogFileName = g_pBatchQueueElement[i].PropagatedInfo.LogFileName;
    } // for

CleanupTimerAndExit:
    //
    //  Mark that the batch queue is empty. But, save the value first for later use.
    //
    g_dwFirstFreeIndex = 0;

    //
    //  Delete the timer. Don't NULL out the handle until you got a chance to propagate the event.
    //
    if ( !DeleteTimerQueueTimer( g_hBatchingSupportTimerQueue,          // Timer queue handle
                                 g_hBatchingSupportTimer,               // Timer handle
                                 NULL ) )                               // No blocking
    {
        //
        //  ERROR_IO_PENDING is legitimate since we delete the timer from within a callback and 
        //  that callback is not finished yet.
        //
        if ( GetLastError() != ERROR_IO_PENDING )
        {
           ELF_LOG1(ERROR, "ElfpBatchEventsAndPropagate: Delete timer returns status=%d...\n",
                    GetLastError());    
        }
    }
   
    RtlLeaveCriticalSection ( &g_CSBatchQueue );

    //
    // Acquire the critical section for this global propagation area. The assumption is that this call
    // may take a long time. E.g., cluster service is in the debugger.
    //
    RtlEnterCriticalSection ( &gClPropCritSec );

    if ( gbClustering && pPackedEventInfo )
    {
        dwStatus = ( *gpfnPropagateEvents )( ghCluster,
                                             pPackedEventInfo->ulSize,
                                             ( PUCHAR ) pPackedEventInfo );
    
        if ( dwStatus != ERROR_SUCCESS )
        {
            ELF_LOG1( ERROR, "ElfpBatchEventsAndPropagate: Propagate events failed with error %d\n",
                      dwStatus );
        } 
    }

    RtlLeaveCriticalSection ( &gClPropCritSec );

    //
    //  If the events were successfully propagated, then make sure the session start record
    //  number information in the log file structure is advanced so a new ElfrRegisterClusterSvc
    //  will not pick up events already propagated. If the events were not successfully propagated,
    //  then not advancing the session number will force ElfrRegisterClusterSvc to batch
    //  all events not propagated into one shot as an output parameter.
    //       
    for ( i=0; i<dwFirstFreeIndex; i++ )
    {
        if ( dwStatus == ERROR_SUCCESS )
        {
            PLOGFILE    pLogFile;

            pLogFile = FindLogFileFromName ( &g_pPropagatedInfo[i].LogFileName );

            if ( pLogFile )
            {
                pLogFile->SessionStartRecordNumber = g_pPropagatedInfo[i].dwCurrentRecordNum;
            }
        }
        ElfpFreeBuffer ( g_pPropagatedInfo[i].LogFileName.Buffer );
    } // for

    //
    //  Free the blob
    //
    ElfpFreeBuffer ( pPackedEventInfo );

    //
    //  NULL out the global timer handle. This will trigger the producer of events (ElfpSaveEventBuffer) to
    //  create a new timer.
    //
    RtlEnterCriticalSection ( &g_CSBatchQueue );
    g_hBatchingSupportTimer = NULL;
    RtlLeaveCriticalSection ( &g_CSBatchQueue );
}// ElfpBatchEventsAndPropagate


//SS:end of changes made to enable cluster wide event logging


NTSTATUS
ElfrFlushEL (
    IN IELF_HANDLE    LogHandle
    )

/*++

Routine Description:

  This is the RPC server entry point for the ElfrFlushEL API.

Arguments:


Return Value:

    Returns an NTSTATUS code.


--*/
{
    NTSTATUS Status;

    // Only LSASS should be able to do this!
    
    if(gElfSecurityHandle != LogHandle)
        return STATUS_ACCESS_DENIED;
    
    //
    // Check the handle before proceeding.
    //
    if (LogHandle == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfrFlushEL: LogHandle is NULL\n");

        return STATUS_INVALID_PARAMETER;
    }

    Status = VerifyElfHandle(LogHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfrFlushEL: VerifyElfHandle failed %#x\n",
                 Status);

        return Status;
    }

    //
    // Ensure the caller has write access.
    //

    if (!(LogHandle->GrantedAccess & ELF_LOGFILE_WRITE))
    {
        ELF_LOG0(ERROR,
                 "ElfrFlushEL: LogHandle does not have write access\n");

        return STATUS_ACCESS_DENIED;
    }

    ElfpFlushFiles(FALSE);

    return STATUS_SUCCESS;
}

/****
@func   NTSTATUS | ElfpClusterAccessCheck | Check whether the caller has rights to invoke RPCs for cluster support. 

@parm   None.

@comm   Check if the caller is in the admin group, allow access if so.

@rdesc  Returns a result code. STATUS_SUCCESS on success.

@xref
****/
NTSTATUS
ElfpClusterRpcAccessCheck(
    VOID
    )
{
    NTSTATUS            Status = STATUS_SUCCESS, revertStatus;
    HANDLE              hClientToken = NULL;
    BOOL                fCheckMember;
    
    //
    // Impersonate to figure if the caller is in the admin group. The cluster service must run 
    // in an account that has local admin privileges.
    //
    Status = I_RpcMapWin32Status( RpcImpersonateClient( NULL ) );

    if ( !NT_SUCCESS( Status ) )
    {
        ELF_LOG1(ERROR, "ElfpClusterAccessCheck: RpcImpersonateClient failed %#x\n", Status);
        return ( Status );
    }

    if ( !OpenThreadToken( GetCurrentThread(), TOKEN_READ, TRUE, &hClientToken ) )
    {
        ELF_LOG1(ERROR, "ElfpClusterAccessCheck: OpenThreadToken failed %d\n", GetLastError());
        Status = STATUS_ACCESS_DENIED;
        goto FnExit;
    }

    if ( !CheckTokenMembership( hClientToken,
                                ElfGlobalData->AliasAdminsSid,
                                &fCheckMember ) )
    {
        ELF_LOG1(ERROR, "ElfpClusterAccessCheck: CheckTokenMembership failed %d\n", GetLastError());
        Status = STATUS_ACCESS_DENIED;
        goto FnExit;
    }

    if ( !fCheckMember )
    {
        ELF_LOG0(ERROR, "ElfpClusterAccessCheck: Caller is not an Admin\n");
        Status = STATUS_ACCESS_DENIED;
        goto FnExit;
    }

FnExit:
    //
    // Stop impersonating
    //
    revertStatus = I_RpcMapWin32Status( RpcRevertToSelf() );

    if ( !NT_SUCCESS( revertStatus ) )
    {
        ELF_LOG1(ERROR, "ElfpClusterAccessCheck: RpcRevertToSelf failed %#x\n", revertStatus);
        if ( NT_SUCCESS ( Status ) ) Status = revertStatus;
    }

    if ( hClientToken )
    {
        CloseHandle( hClientToken );
    }

    return ( Status );
}// ElfpClusterAccessCheck
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\elfextrn.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    elfextrn.h

Abstract:

    This file contains all the externs for the global variables.

Author:

    Rajen Shah (rajens) 10-Jul-1991

Revision History:

--*/

#include <clussprt.h>

//
// DEFINITIONS
//

#define   EVENTLOG_SVC_NAMEW   L"EVENTLOG"


#if DBG

extern      DWORD  ElfDebugLevel;

#endif  // DBG


extern      HANDLE ElfConnectionPortHandle;
extern      HANDLE ElfCommunicationPortHandle;

extern      PWSTR Computername;

extern      LIST_ENTRY  LogFilesHead;       // Log files
extern      LIST_ENTRY  LogModuleHead;      // Modules registered for logging
extern      LIST_ENTRY  LogHandleListHead;  // Context-handles for log handles
extern      LIST_ENTRY  QueuedEventListHead; // Deferred events
extern      LIST_ENTRY  QueuedMessageListHead; //Deferred Messagebox

extern      RTL_CRITICAL_SECTION    LogFileCritSec;
extern      RTL_CRITICAL_SECTION    LogModuleCritSec;
extern      RTL_CRITICAL_SECTION    LogHandleCritSec;
extern      RTL_CRITICAL_SECTION    QueuedEventCritSec;
extern      RTL_CRITICAL_SECTION    QueuedMessageCritSec;

extern      SERVICE_STATUS ElfServiceStatus;
extern      SERVICE_STATUS_HANDLE ElfServiceStatusHandle;

extern      RTL_RESOURCE        GlobalElfResource;

extern      PVOID       ElfBackupPointer;
extern      HANDLE      ElfBackupEvent;

extern      HANDLE      LPCThreadHandle;

extern      HANDLE      MBThreadHandle;

extern      HANDLE      RegistryThreadHandle;
extern      DWORD       RegistryThreadId;

extern      ULONG       EventFlags;

extern      ELF_EOF_RECORD  EOFRecord;

extern      PLOGMODULE ElfDefaultLogModule;

extern      PLOGMODULE ElfModule;

extern      PLOGMODULE ElfSecModule;

extern      HANDLE      hEventLogNode;

extern      HANDLE      hComputerNameNode;

extern      DWORD       BackupModuleNumber;

extern      PSVCS_GLOBAL_DATA   ElfGlobalData;    // WellKnownSids

extern      BOOL EventlogShutdown;

extern      HANDLE ElfGlobalSvcRefHandle;

extern      LPWSTR  GlobalMessageBoxTitle;

extern      BOOL bGlobalMessageBoxTitleNeedFree;

extern      HANDLE  g_hTimestampEvent;

//changes to support clustering
extern      BOOL                    gbClustering; 
extern      RTL_CRITICAL_SECTION    gClPropCritSec;     
extern      HMODULE                 ghClusDll;
extern      PROPAGATEEVENTSPROC     gpfnPropagateEvents;
extern      BINDTOCLUSTERPROC       gpfnBindToCluster;
extern      UNBINDFROMCLUSTERPROC   gpfnUnbindFromCluster;
extern      HANDLE                  ghCluster;

// changes to support various auditing dcrs

extern      int giWarningLevel;        // level at which the warning is to be given                                                    
extern  IELF_HANDLE    gElfSecurityHandle;

extern DWORD g_dwLastDelayTickCount;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\elfdata.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    DATA.C

Abstract:

    This file contains all the global data elements of the eventlog service.

Author:

    Rajen Shah  (rajens)    10-Jul-1991

[Environment:]

    User Mode - Win32, except for NTSTATUS returned by some functions.

Revision History:

    10-Jul-1991     RajenS
        created

--*/

//
// INCLUDES
//

#include <eventp.h>
#include <elfcfg.h>


#if DBG

//
// Always write errors to the debugger on checked builds
//
DWORD ElfDebugLevel = DEBUG_ERROR;

#endif  // DBG


//
// Handles used for the LPC port.
//
HANDLE ElfConnectionPortHandle;
HANDLE ElfCommunicationPortHandle;

// The heads of various linked lists
//
LIST_ENTRY      LogFilesHead;               // Log files

RTL_CRITICAL_SECTION    LogFileCritSec;     // Accessing log files

LIST_ENTRY      LogModuleHead;              // Modules registered for logging

RTL_CRITICAL_SECTION    LogModuleCritSec;   // Accessing log files

LIST_ENTRY      LogHandleListHead;          // Context-handles for log handles

RTL_CRITICAL_SECTION    LogHandleCritSec;   // Accessing log handles

LIST_ENTRY      QueuedEventListHead;        // Deferred events to write

RTL_CRITICAL_SECTION QueuedEventCritSec;    // Accessing the deferred events

LIST_ENTRY      QueuedMessageListHead;      // Deferred messagebox

RTL_CRITICAL_SECTION QueuedMessageCritSec;  // Accessing the deferred mb's

//
// Service-related global data
//

SERVICE_STATUS_HANDLE ElfServiceStatusHandle;

//
// The following resource is used to serialize access to the resources
// of the Eventlog service at the highest level. It is used to make sure
// that the threads that write/read/clear the log file(s) do not step over
// the threads that monitor the registry and deal with service control
// operations.
//
// The threads that operate on the log file(s) have Shared access to the
// resource, since they are further serialized on the file that they are
// working on.
//
// The threads that will modify the internal data structures, or the state
// of the service, need Exclusive access to the resource so that we can
// control access to the data structures and log files.
//

RTL_RESOURCE        GlobalElfResource;

//
// This is used by the Backup API to signify which 4K block of the log it's
// currently reading.  This is used to prevent a writer from overwriting this
// block while it is reading it.  The event is used to let a writer block if
// it was going to overwrite the current backup block, and get pulsed when
// the backup thread moves to the next block.

PVOID               ElfBackupPointer;
HANDLE              ElfBackupEvent;

//
// Handle for the LPC thread
//
HANDLE      LPCThreadHandle;

//
// Handle for the MessageBox thread
//
HANDLE      MBThreadHandle;

//
// Handle and ID for the registry monitor thread
//
HANDLE      RegistryThreadHandle;
DWORD       RegistryThreadId;

//
// Bitmask of things that have been allocated and/or started by the
// service. When the service terminates, this is what needs to be
// cleaned.
//
ULONG       EventFlags;     // Keep track of what is allocated

//
// Record used to indicate the end of the event records in the file.
//
ELF_EOF_RECORD  EOFRecord = {  ELFEOFRECORDSIZE,
                               0x11111111,
                               0x22222222,
                               0x33333333,
                               0x44444444,
                               FILEHEADERBUFSIZE,
                               FILEHEADERBUFSIZE,
                               1,
                               1,
                               ELFEOFRECORDSIZE
                            };

//
// Default module to use if no match is found, APPLICATION
//

PLOGMODULE ElfDefaultLogModule;

//
// Module for the eventlog service itself
//

PLOGMODULE ElfModule;

//
// Module for security
//

PLOGMODULE ElfSecModule;

//
// Handle (key) to the event log node in the registry.
// This is set up by the service main function.
//

HANDLE      hEventLogNode;

//
// Handle (key) to the ComputerName node in the registry.
// This is set up by the service main function.
//

HANDLE      hComputerNameNode;

//
// Used to create a unigue module name for backup logs
//

DWORD BackupModuleNumber;

//
// NT well-known SIDs
//
PSVCS_GLOBAL_DATA       ElfGlobalData;

//
// Shutdown Flag
//
BOOL    EventlogShutdown;

HANDLE  ElfGlobalSvcRefHandle;

//
// This is the string used as the title of the log full message box.
// GlobalMessageBoxTitle will either point to the default string or
// to the string allocated in the format Message function.
//
LPWSTR  GlobalMessageBoxTitle;
BOOL bGlobalMessageBoxTitleNeedFree = FALSE;

//SS:start of changes for clustering
BOOL                    gbClustering=FALSE; //the cluster service has registered for replication of events
RTL_CRITICAL_SECTION    gClPropCritSec;     // for using the global glClPackedEventInfo structure
HMODULE                 ghClusDll=NULL;
PROPAGATEEVENTSPROC     gpfnPropagateEvents=NULL;
BINDTOCLUSTERPROC       gpfnBindToCluster=NULL;
UNBINDFROMCLUSTERPROC   gpfnUnbindFromCluster=NULL;
HANDLE                  ghCluster=NULL;
//SS: end of changes for clustering

// changes to support various auditing dcrs

int giWarningLevel = 0;        // level at which the warning is to be given     

 IELF_HANDLE    gElfSecurityHandle = 0;

// When reading through the registry during an update, it is possible that a key may
// be only partially written due to a race condition.  If an attempt to read fails, then 
// the read will be retried after a delay.  This variable is intended to prevent multiple
// delays

DWORD g_dwLastDelayTickCount = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\elflpc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    elflpc.c

Abstract:

    This file contains the routines that deal with the LPC port in the
    eventlog service.

Author:

    Rajen Shah  (rajens)    10-Jul-1991

Revision History:



--*/

//
// INCLUDES
//

#include <eventp.h>
#include <ntiolog.h>    // For IO_ERROR_LOG_[MESSAGE/PACKET]
#include <ntiologc.h>   // QUOTA error codes
#include <elfkrnl.h>
#include <stdlib.h>
#include <memory.h>
#include <elfextrn.h>   // Computername

#include <nt.h>         // DbgPrint prototype
#include <ntrtl.h>      // DbgPrint prototype
#include <ntdef.h>
#include <ntstatus.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <lmcons.h>
#include <string.h>
#include <lmerr.h>
#include <elfmsg.h>

//
//  Global value for the "system" module
//

PLOGMODULE SystemModule = NULL;

NTSTATUS
SetUpLPCPort(
    VOID
    )

/*++

Routine Description:

    This routine sets up the LPC port for the service.

Arguments:

    None

Return Value:

--*/
{
    NTSTATUS status;
    UNICODE_STRING SystemString;
    UNICODE_STRING unicodePortName;
    OBJECT_ATTRIBUTES objectAttributes;
    PORT_MESSAGE connectionRequest;

    ELF_LOG0(LPC,
             "SetUpLPCPort: Enter\n");

    //
    // We're going to need this every time, so just get it once
    //
    ASSERT(SystemModule == NULL);

    //
    // Get the system module to log driver events
    //
    RtlInitUnicodeString(&SystemString, ELF_SYSTEM_MODULE_NAME);
    SystemModule = GetModuleStruc(&SystemString);

    //
    // The System log and its default module should have been created by now.
    //
    ASSERT(_wcsicmp(SystemModule->ModuleName, ELF_SYSTEM_MODULE_NAME) == 0);

    //
    // Initialize the handles to zero so that we can determine what to do
    // if we need to clean up.
    //
    ElfConnectionPortHandle = NULL;
    ElfCommunicationPortHandle = NULL;

    //
    // Create the LPC port.
    //
    RtlInitUnicodeString( &unicodePortName, ELF_PORT_NAME_U );

    InitializeObjectAttributes(
            &objectAttributes,
            &unicodePortName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    status = NtCreatePort(&ElfConnectionPortHandle,
                          &objectAttributes,
                          0,
                          ELF_PORT_MAX_MESSAGE_LENGTH,
                          ELF_PORT_MAX_MESSAGE_LENGTH * 32);

    if (!NT_SUCCESS(status))
    {
        ELF_LOG2(ERROR,
                 "SetUpLPCPort: Error creating LPC port %ws %#x\n",
                 ELF_PORT_NAME_U,
                 status);
    }

    ELF_LOG1(LPC,
             "SetUpLPCPort: Exiting with status %#x\n",
             status);

    return status;
}



LPWSTR
ElfpCopyString(
    LPWSTR Destination,
    LPWSTR Source,
    ULONG Length
    )

/*++

Routine Description:

    Copies a string to the destination.  Correctly NUL terminates
    the string.


Arguments:

    Destination - place where string is to be copied
    
    Source - string that may or may not be NUL terminated
    
    Length - length in bytes of string being copied.  May include NUL

Return Value:

    LPWSTR to first WCHAR past NUL

--*/
{
    //
    //  Copy the data
    //
    RtlMoveMemory(Destination, Source, Length);

    //
    //  Make sure it's NULL terminated
    //
    if (Length != 0)
    {
        Destination += Length / sizeof(WCHAR) - 1;

        if (*Destination != L'\0')
        {
            Destination++;
            *Destination = L'\0';
        }
    }
    else
    {
        *Destination = L'0';
    }

    return Destination + 1;
}


NTSTATUS
ElfProcessIoLPCPacket( 
    ULONG                 PacketLength,
    PIO_ERROR_LOG_MESSAGE pIoErrorLogMessage
    )

/*++

Routine Description:

    This routine takes the packet received from the LPC port and processes it.
    The logfile will be system, the module name will be the driver that 
    generated the packet, the SID will always be NULL and
    there will always be one string, which will be the device name.

    It extracts the information from the LPC packet, and then calls the
    common routine to do the work of formatting the data into
    an event record and writing it out to the log file.


Arguments:

    pIoErrorLogMessage - Pointer to the data portion of the packet just
                         received through the LPC port.


Return Value:

    Status of this operation.

--*/

{
    NTSTATUS status;
    ELF_REQUEST_RECORD  Request;
    WRITE_PKT WritePkt;

    ULONG RecordLength;
    PEVENTLOGRECORD EventLogRecord;
    LPWSTR DestinationString, SourceString;
    PBYTE BinaryData;
    ULONG PadSize;
    LARGE_INTEGER Time;
    ULONG TimeWritten;
    PULONG pEndLength;
    ULONG i = 0;
    PWCHAR pwch;
    PWCHAR pwStart;
    PWCHAR pwEnd;
    ULONG StringLength;
	WCHAR LocalComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	ULONG  ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
	BOOL bOK;
    PacketLength = min(pIoErrorLogMessage->Size, PacketLength);

    try
    {
        // Get the computer name

    	bOK = GetComputerNameW(LocalComputerName, &ComputerNameLength);
		if(bOK == FALSE)
		{
            ELF_LOG1(ERROR,
                 "ElfProcessIoLPCPacket: failed calling GetComputerNameW, last error 0x%x\n",
                  GetLastError());
            return STATUS_UNSUCCESSFUL;    
		}
    	ComputerNameLength = (ComputerNameLength+1)*sizeof(WCHAR); // account for the NULL
    	
        //
        // Validate the packet, First make sure there are the correct
        // number of NULL terminated strings, and remember the
        // total number of bytes to copy
        //
        pwStart = pwch = (PWCHAR) ((PBYTE) pIoErrorLogMessage +
                                       pIoErrorLogMessage->EntryData.StringOffset);

        pwEnd = (PWCHAR) ((PBYTE) pIoErrorLogMessage + PacketLength);

        while (pwch < pwEnd
                &&
               i < pIoErrorLogMessage->EntryData.NumberOfStrings)
        {
                if (*pwch == L'\0')
                {
                    i++;
                }

                pwch++;
        }

        StringLength = (ULONG) (pwch - pwStart) * sizeof(WCHAR);

        //
        // Now make sure everything in the packet is true
        //

        if ((i != pIoErrorLogMessage->EntryData.NumberOfStrings)
              ||
            (pIoErrorLogMessage->DriverNameOffset 
                 + pIoErrorLogMessage->DriverNameLength >= PacketLength)
              ||
            (pIoErrorLogMessage->EntryData.StringOffset >= PacketLength)
              ||
            (FIELD_OFFSET(IO_ERROR_LOG_MESSAGE, EntryData) 
                 + FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) 
                 + (ULONG) pIoErrorLogMessage->EntryData.DumpDataSize >= PacketLength))
        {    
            //
            // It's a bad packet, log it and return
            //
            ELF_LOG0(ERROR,
                     "ElfProcessIoLPCPacket: Bad LPC packet -- dumping it to System log\n");

            ElfpCreateElfEvent(EVENT_BadDriverPacket,
                               EVENTLOG_ERROR_TYPE,
                               0,                    // EventCategory
                               0,                    // NumberOfStrings
                               NULL,                 // Strings
                               pIoErrorLogMessage,   // Data
                               PacketLength,         // Datalength
                               0,                    // flags
                               FALSE);               // for security file    

            return STATUS_UNSUCCESSFUL;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // It's a bad packet, log it and return
        //
        ELF_LOG1(ERROR,
                 "ElfProcessIoLPCPacket: Exception %#x caught processing I/O LPC packet\n",
                 GetExceptionCode());

        ElfpCreateElfEvent(EVENT_BadDriverPacket,
                           EVENTLOG_ERROR_TYPE,
                           0,                    // EventCategory
                           0,                    // NumberOfStrings
                           NULL,                 // Strings
                           NULL,                 // Data
                           0,                    // Datalength
                           0,                    // flags
                           FALSE);               // for security file    

        return STATUS_UNSUCCESSFUL;
    }

    //
    // The packet should be an IO_ERROR_LOG_MESSAGE
    //
    ASSERT(pIoErrorLogMessage->Type == IO_TYPE_ERROR_MESSAGE);

    //
    // Set up write packet in request packet
    //
    Request.Pkt.WritePkt = &WritePkt;
    Request.Flags = 0;

    //
    // Generate any additional information needed in the record.
    //

    //
    // TIMEWRITTEN
    // We need to generate a time when the log is written. This
    // gets written in the log so that we can use it to test the
    // retention period when wrapping the file.
    //
    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(
                        &Time,
                        &TimeWritten
                        );

    //
    // Determine how big a buffer is needed for the eventlog record.
    //
    RecordLength = sizeof(EVENTLOGRECORD)
                       + ComputerNameLength                   // computer name
                       + 2 * sizeof(WCHAR)                    // terminating NULLs
                       + PacketLength
                       - FIELD_OFFSET(IO_ERROR_LOG_MESSAGE, EntryData)
                       + sizeof(RecordLength);                // final len

    //
    // Determine how many pad bytes are needed to align to a DWORD
    // boundary.
    //
    PadSize = sizeof(ULONG) - (RecordLength % sizeof(ULONG));

    RecordLength += PadSize;    // True size needed

    //
    // Allocate the buffer for the Eventlog record
    //
    EventLogRecord = (PEVENTLOGRECORD) ElfpAllocateBuffer(RecordLength);

    if (EventLogRecord != (PEVENTLOGRECORD) NULL)
    {
        //
        // Fill up the event record
        //
        EventLogRecord->Length = RecordLength;

        RtlTimeToSecondsSince1970(&pIoErrorLogMessage->TimeStamp,
                                  &EventLogRecord->TimeGenerated);

        EventLogRecord->Reserved    = ELF_LOG_FILE_SIGNATURE;
        EventLogRecord->TimeWritten = TimeWritten;
        EventLogRecord->EventID     = pIoErrorLogMessage->EntryData.ErrorCode;

        //
        // Set EventType based on the high order nibble of
        // pIoErrorLogMessage->EntryData.ErrorCode
        //
        if (NT_INFORMATION(pIoErrorLogMessage->EntryData.ErrorCode))
        {
            EventLogRecord->EventType = EVENTLOG_INFORMATION_TYPE;
        }
        else if (NT_WARNING(pIoErrorLogMessage->EntryData.ErrorCode))
        {
            EventLogRecord->EventType = EVENTLOG_WARNING_TYPE;
        }
        else if (NT_ERROR(pIoErrorLogMessage->EntryData.ErrorCode))
        {
            EventLogRecord->EventType = EVENTLOG_ERROR_TYPE;
        }
        else
        {
            //
            // Unknown, set to error
            //
            ELF_LOG1(LPC,
                     "ElfProcessIoLPCPacket: Unknown EventType (high nibble of ID %#x)\n",
                     EventLogRecord->EventID);

            EventLogRecord->EventType = EVENTLOG_ERROR_TYPE;
        }

        EventLogRecord->NumStrings    = pIoErrorLogMessage->EntryData.NumberOfStrings;
        EventLogRecord->EventCategory = pIoErrorLogMessage->EntryData.EventCategory;
        EventLogRecord->StringOffset  = sizeof(EVENTLOGRECORD)
                                            + pIoErrorLogMessage->DriverNameLength
                                            + ComputerNameLength;

        EventLogRecord->DataLength    = FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData)
                                            + pIoErrorLogMessage->EntryData.DumpDataSize;

        EventLogRecord->DataOffset    = EventLogRecord->StringOffset + StringLength;

        //
        // Quota events contain a SID.
        //
        if (pIoErrorLogMessage->EntryData.ErrorCode == IO_FILE_QUOTA_LIMIT
             ||
            pIoErrorLogMessage->EntryData.ErrorCode == IO_FILE_QUOTA_THRESHOLD)
        {
            PFILE_QUOTA_INFORMATION pFileQuotaInformation =
                (PFILE_QUOTA_INFORMATION) pIoErrorLogMessage->EntryData.DumpData;

            ELF_LOG0(LPC,
                     "ElfProcessIoLPCPacket: Event is a Quota event\n");

            EventLogRecord->UserSidLength = pFileQuotaInformation->SidLength;
            EventLogRecord->UserSidOffset = EventLogRecord->DataOffset
                                                + FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData)
                                                + FIELD_OFFSET(FILE_QUOTA_INFORMATION, Sid);

            EventLogRecord->DataLength    = EventLogRecord->UserSidOffset -
                                                EventLogRecord->DataOffset;
        }
        else
        {
            EventLogRecord->UserSidLength = 0;
            EventLogRecord->UserSidOffset = 0;
        }

        //
        // Fill in the variable-length fields
        //

        //
        // MODULENAME
        //
        // Use the driver name as the module name, since its location is
        // described by an offset from the start of the IO_ERROR_LOG_MESSAGE
        // turn it into a pointer
        //
        DestinationString = (LPWSTR) ((LPBYTE) EventLogRecord + sizeof(EVENTLOGRECORD));
        SourceString = (LPWSTR) ((LPBYTE) pIoErrorLogMessage
                                      + pIoErrorLogMessage->DriverNameOffset);

        DestinationString = ElfpCopyString(DestinationString,
                                           SourceString,
                                           pIoErrorLogMessage->DriverNameLength);

        //
        // COMPUTERNAME
        //
        DestinationString = ElfpCopyString(DestinationString,
                                           LocalComputerName,
                                           ComputerNameLength);

        //
        // STRINGS
        //
        DestinationString = ElfpCopyString(DestinationString, pwStart, StringLength);

        //
        // BINARY DATA
        //
        BinaryData = (LPBYTE) DestinationString;

        RtlMoveMemory(BinaryData, 
                      &pIoErrorLogMessage->EntryData,
                      FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData) 
                          + pIoErrorLogMessage->EntryData.DumpDataSize);

        //
        // LENGTH at end of record
        //
        pEndLength = (PULONG) ((LPBYTE) EventLogRecord + RecordLength - sizeof(ULONG));
        *pEndLength = RecordLength;

        //
        // Set up request packet.
        // Link event log record into the request structure.
        //
        Request.Module  = SystemModule;
        Request.LogFile = Request.Module->LogFile;
        Request.Command = ELF_COMMAND_WRITE;

        Request.Pkt.WritePkt->Buffer   = (PVOID) EventLogRecord;
        Request.Pkt.WritePkt->Datasize = RecordLength;

        //
        // Perform the operation
        //
        ElfPerformRequest( &Request );

        //
        // Replicate the event if part of a cluster
        //
        ElfpSaveEventBuffer(SystemModule, EventLogRecord, RecordLength);

        status = Request.Status;                // Set status of WRITE
    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfProcessIoLPCPacket: Unable to allocate memory for EventLogRecord\n");

        status = STATUS_NO_MEMORY;
    }

    return status;
}



NTSTATUS
ElfProcessSmLPCPacket(
    ULONG PacketLength,
    PSM_ERROR_LOG_MESSAGE SmErrorLogMessage
    )

/*++

Routine Description:

    This routine takes the packet received from the LPC port and processes it.
    The packet is an SM_ERROR_LOG_MESSAGE.  The logfile will be system, the 
    module name will be SMSS, the SID will always be NULL and
    there will always be one string, which will be the filename

    It extracts the information from the LPC packet, and then calls the
    common routine to do the work of formatting the data into
    an event record and writing it out to the log file.


Arguments:

    SmErrorLogMessage - Pointer to the data portion of the packet just
                        received through the LPC port.


Return Value:

    Status of this operation.

--*/

{
    NTSTATUS status;
    ELF_REQUEST_RECORD  Request;
    WRITE_PKT WritePkt;

    ULONG RecordLength;
    PEVENTLOGRECORD EventLogRecord;
    LPWSTR DestinationString, SourceString;
    PBYTE BinaryData;
    ULONG PadSize;
    LARGE_INTEGER Time;
    ULONG TimeWritten;
    PULONG pEndLength;
	WCHAR LocalComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	ULONG  ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
	BOOL bOK;

    try
    {
    	// Get the computer name

		bOK = GetComputerNameW(LocalComputerName, &ComputerNameLength);
		if(bOK == FALSE)
		{
        	ELF_LOG1(ERROR,
                 "ElfProcessIoLPCPacket: failed calling GetComputerNameW, last error 0x%x\n",
                  GetLastError());
            return STATUS_UNSUCCESSFUL;    
		}
    	ComputerNameLength = (ComputerNameLength+1)*sizeof(WCHAR);
        //
        //  Validate the packet.  
        //
        if (PacketLength < sizeof(SM_ERROR_LOG_MESSAGE) 

                ||
            
            // 
            //  Offset begins before header
            //
             
            SmErrorLogMessage->StringOffset < sizeof(*SmErrorLogMessage)
                
                ||

            //
            //  Offset begins after packet
            //

            SmErrorLogMessage->StringOffset >= PacketLength

                ||

            //
            //  Length of string longer than packet
            //

            SmErrorLogMessage->StringLength > PacketLength

                ||

            //
            //  String end after end of packet
            //

            SmErrorLogMessage->StringOffset
                + SmErrorLogMessage->StringLength > PacketLength

             )
        {
            RtlRaiseStatus(STATUS_UNSUCCESSFUL);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // It's a bad packet, log it and return
        //
        ELF_LOG1(ERROR,
                 "ElfProcessSmLPCPacket: Exception %#x caught processing SMSS LPC packet\n",
                 GetExceptionCode());

        ELF_LOG3(ERROR,
                 "SmErrorLogMessage->StringOffset %#x\n"
                     "\tPacketLength %#x\n"
                     "\tSmErrorLogMessage->StringLength %#x\n",
                 SmErrorLogMessage->StringOffset,
                 PacketLength,
                 SmErrorLogMessage->StringLength);

        ElfpCreateElfEvent(EVENT_BadDriverPacket,
                           EVENTLOG_ERROR_TYPE,
                           0,                    // EventCategory
                           0,                    // NumberOfStrings
                           NULL,                 // Strings
                           NULL,                 // Data
                           0,                    // Datalength
                           0,                    // flags
                           FALSE);               // for security file    

        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set up write packet in request packet
    //
    Request.Pkt.WritePkt = &WritePkt;
    Request.Flags = 0;

    //
    // Generate any additional information needed in the record.
    //

    //
    //  Determine how big a buffer is needed for the eventlog record.  
    //  We overestimate string lengths rather than probing for 
    //  terminating NUL's
    //
    RecordLength = sizeof(EVENTLOGRECORD)
                       + sizeof(L"system")
                       + ComputerNameLength + sizeof(WCHAR)
                       + SmErrorLogMessage->StringLength + sizeof(WCHAR)
                       + sizeof(RecordLength);

    //
    //  Since the RecordLength at the end must be ULONG aligned, we round 
    //  up the total size to be ULONG aligned.
    //
    RecordLength += sizeof(ULONG) - (RecordLength % sizeof(ULONG));

    //
    // Allocate the buffer for the Eventlog record
    //
    EventLogRecord = (PEVENTLOGRECORD) ElfpAllocateBuffer(RecordLength);

    if (EventLogRecord == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfProcessSmLPCPacket: Unable to allocate memory for EventLogRecord\n");

        return STATUS_NO_MEMORY;
    }

    //
    // Fill up the event record
    //
    EventLogRecord->Length   = RecordLength;
    EventLogRecord->Reserved = ELF_LOG_FILE_SIGNATURE;

    RtlTimeToSecondsSince1970(&SmErrorLogMessage->TimeStamp,
                              &EventLogRecord->TimeGenerated);

    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(&Time, &EventLogRecord->TimeWritten);
    EventLogRecord->EventID = SmErrorLogMessage->Status;

    //
    // set EventType based on the high order nibble of
    // the eventID
    //
    if (NT_INFORMATION(EventLogRecord->EventID))
    {
        EventLogRecord->EventType =  EVENTLOG_INFORMATION_TYPE;
    }
    else if (NT_WARNING(EventLogRecord->EventID))
    {
        EventLogRecord->EventType =  EVENTLOG_WARNING_TYPE;
    }
    else if (NT_ERROR(EventLogRecord->EventID))
    {
        EventLogRecord->EventType = EVENTLOG_ERROR_TYPE;
    }
    else
    {
        //
        // Unknown, set to error
        //
        ELF_LOG1(LPC,
                 "ElfProcessSmLPCPacket: Unknown EventType (high nibble of ID %#x)\n",
                 EventLogRecord->EventID);

        EventLogRecord->EventType = EVENTLOG_ERROR_TYPE;
    }

    //
    //  There is a single string;  it is the name of the file being 
    //  replaced
    //
    EventLogRecord->NumStrings    = 1;
    EventLogRecord->EventCategory = ELF_CATEGORY_SYSTEM_EVENT;

    //
    //  Nothing for ReservedFlags
    //  Nothing for ClosingRecordNumber
    //
    EventLogRecord->StringOffset = sizeof(EVENTLOGRECORD) 
                                       + sizeof( L"system" )
                                       + ComputerNameLength;

    //
    //  No SID's present
    //
    EventLogRecord->UserSidLength = 0;
    EventLogRecord->UserSidOffset = 0;
    EventLogRecord->DataLength    = 0;
    EventLogRecord->DataOffset    = 0;

    //
    // Fill in the variable-length fields
    //
    // MODULENAME
    //
    // SMSS
    //
    DestinationString = (LPWSTR) ((LPBYTE) EventLogRecord + sizeof(EVENTLOGRECORD));

    DestinationString = ElfpCopyString(DestinationString, 
                                       L"system", 
                                       sizeof(L"system"));

    //
    // COMPUTERNAME
    //
    DestinationString = ElfpCopyString(DestinationString,
                                       LocalComputerName,
                                       ComputerNameLength);

    //
    // STRING
    //
    SourceString = (LPWSTR) ((LPBYTE) SmErrorLogMessage + SmErrorLogMessage->StringOffset);

    ELF_LOG2(LPC,
             "ElfProcessSmLPCPacket: String is '%*ws'\n",
             SmErrorLogMessage->StringLength,
             SourceString);

    DestinationString = ElfpCopyString(DestinationString,
                                       SourceString,
                                       SmErrorLogMessage->StringLength);

    //
    // LENGTH at end of record
    //
    pEndLength = (PULONG) ((LPBYTE) EventLogRecord + RecordLength - sizeof(ULONG));
    *pEndLength = RecordLength;

    //
    // Set up request packet.
    // Link event log record into the request structure.
    //
    Request.Module  = SystemModule;
    Request.LogFile = Request.Module->LogFile;
    Request.Command = ELF_COMMAND_WRITE;

    Request.Pkt.WritePkt->Buffer   = (PVOID) EventLogRecord;
    Request.Pkt.WritePkt->Datasize = RecordLength;

    //
    // Perform the operation
    //
    ElfPerformRequest( &Request );


    //
    // Replicate the event if part of a cluster
    //
    ElfpSaveEventBuffer(SystemModule, EventLogRecord, RecordLength);

    return Request.Status;
}



void
LeaveLPCThread(VOID)
{
     ELF_LOG0(TRACE, "Elf: LPC thread got a terminate message\n");
     ExitThread(0);
}


NTSTATUS
ElfProcessLPCCalls(
    VOID
    )

/*++

Routine Description:

    This routine waits for messages to come through the LPC port to
    the system thread. When one does, it calls the appropriate routine to
    handle the API, then replies to the system thread indicating that the
    call has completed if the message was a request, if it was a datagram,
    it just waits for the next message.

Arguments:


Return Value:

--*/

{
    NTSTATUS status;

    BOOL SendReply = FALSE;

    ELF_REPLY_MESSAGE   replyMessage;
    PELF_PORT_MSG       receiveMessage;
    PHANDLE             PortConnectionHandle;

    //
    // Loop dispatching API requests.
    //
    receiveMessage = ElfpAllocateBuffer(ELF_PORT_MAX_MESSAGE_LENGTH + sizeof(PORT_MESSAGE));

    if (!receiveMessage)
    {
        ELF_LOG0(ERROR,
                 "ElfProcessLPCCalls: Unable to allocate memory for receiveMessage\n");

        return STATUS_NO_MEMORY;
    }

    while (TRUE)
    {
        //
        // On the first call to NtReplyWaitReceivePort, don't send a
        // reply since there's nobody to whom to reply.  However, on
        // subsequent calls send a reply to the message from the prior
        // time if that message wasn't an LPC_DATAGRAM.
        //
        status = NtReplyWaitReceivePort(
                                       ElfConnectionPortHandle,
                     (PVOID)           &PortConnectionHandle,
                     (PPORT_MESSAGE)   (SendReply ? &replyMessage : NULL),
                     (PPORT_MESSAGE)   receiveMessage
                 );

        if (!NT_SUCCESS(status))
        {
            ELF_LOG1(ERROR,
                     "ElfProcessLPCCalls: NtReplyWaitReceivePort failed %#x\n",
                     status);

            return status;
        }

        ELF_LOG0(LPC,
                 "ElfProcessLPCCalls: Received message\n");

        if (EventlogShutdown)
            LeaveLPCThread();
        
        //
        // Take the record received and perform the operation.  Strip off
        // the PortMessage and just send the packet.
        //

        //
        // Set up the response message to be sent on the next call to
        // NtReplyWaitReceivePort if this wasn't a datagram.
        // 'status' contains the status to return from this call.
        // Only process messages that are LPC_REQUEST or LPC_DATAGRAM
        //
        if (receiveMessage->PortMessage.u2.s2.Type == LPC_REQUEST
             ||
            receiveMessage->PortMessage.u2.s2.Type == LPC_DATAGRAM)
        {
            ELF_LOG1(LPC,
                     "ElfProcessLPCCalls: LPC message type = %ws\n",
                     (receiveMessage->PortMessage.u2.s2.Type == LPC_REQUEST ? "LPC_REQUEST" :
                                                                              "LPC_DATAGRAM"));

            if (receiveMessage->MessageType == IO_ERROR_LOG)
            {
                ELF_LOG0(LPC,
                         "ElfProcessLPCCalls: SM_IO_LOG\n");

                status =  ElfProcessIoLPCPacket(receiveMessage->PortMessage.u1.s1.DataLength, 
                                                &receiveMessage->u.IoErrorLogMessage);
            }
            else if (receiveMessage->MessageType == SM_ERROR_LOG)
            {
                ELF_LOG0(LPC,
                         "ElfProcessLPCCalls: SM_ERROR_LOG\n");

                status = ElfProcessSmLPCPacket(receiveMessage->PortMessage.u1.s1.DataLength, 
                                               &receiveMessage->u.SmErrorLogMessage);
            }
            else
            {
                ELF_LOG1(ERROR,
                         "ElfProcessLPCCalls: Unknown MessageType %#x\n",
                         receiveMessage->MessageType);
                status = STATUS_UNSUCCESSFUL;
            }

            if (receiveMessage->PortMessage.u2.s2.Type == LPC_REQUEST)
            {
                replyMessage.PortMessage.u1.s1.DataLength  = sizeof(replyMessage)
                                                                 - sizeof(PORT_MESSAGE);

                replyMessage.PortMessage.u1.s1.TotalLength = sizeof(replyMessage);
                replyMessage.PortMessage.u2.ZeroInit       = 0;

                replyMessage.PortMessage.ClientId 
                    = receiveMessage->PortMessage.ClientId;

                replyMessage.PortMessage.MessageId 
                    = receiveMessage->PortMessage.MessageId;

                replyMessage.Status = status;
    
                SendReply = TRUE;
            }
            else
            {
                SendReply = FALSE;
            }
        }
        else if (receiveMessage->PortMessage.u2.s2.Type == LPC_CONNECTION_REQUEST)
        {
            PHANDLE pSavedHandle = NULL;
            BOOLEAN Accept       = TRUE;

            ELF_LOG0(LPC,
                     "ElfProcessLPCCalls: Processing connection request\n");

            pSavedHandle = ElfpAllocateBuffer(sizeof (HANDLE));

            if (pSavedHandle)
            {
                status = NtAcceptConnectPort(pSavedHandle,
                                             pSavedHandle,
                                             &receiveMessage->PortMessage,
                                             Accept,
                                             NULL,
                                             NULL);
            } else {

               ELF_LOG0(ERROR, "ElfProcessLPCCalls: Unable to allocate LPC handle\n");
               status = STATUS_NO_MEMORY;

            }

            if (!Accept)
            {
                if(pSavedHandle)
                {
                  ElfpFreeBuffer(pSavedHandle);
                  pSavedHandle = NULL;
                }

                continue;
            }

            if (NT_SUCCESS(status))
            {
                status = NtCompleteConnectPort(*pSavedHandle);

                if (!NT_SUCCESS(status))
                {
                    ELF_LOG1(ERROR,
                             "ElfProcessLPCCalls: NtAcceptConnectPort failed %#x\n",
                             status);

                    NtClose(*pSavedHandle);
                }
            }

            if (!NT_SUCCESS(status))
            {
                ELF_LOG1(ERROR,
                         "ElfProcessLPCCalls: Cleaning up failed connect\n", status);

                if(pSavedHandle)
                {
                  ElfpFreeBuffer(pSavedHandle);
                  pSavedHandle = NULL;
                }
            }
        }
        else if (receiveMessage->PortMessage.u2.s2.Type == LPC_PORT_CLOSED)
        {
            ELF_LOG0(LPC,
                     "ElfProcessLPCCalls: Processing port closed\n");

            ASSERT(PortConnectionHandle != NULL);

            NtClose(*PortConnectionHandle);
            ElfpFreeBuffer(PortConnectionHandle);


        }
        else
        {
            //
            // We received a message type we didn't expect, probably due to
            // error.
            //
            ELF_LOG1(ERROR,
                     "ElfProcessLPCCalls: Unknown message type %#x received on LPC port\n",
                     receiveMessage->PortMessage.u2.s2.Type);
        }
    }

} // ElfProcessLPCCalls



DWORD
MainLPCThread(
    LPVOID      LPCThreadParm
    )

/*++

Routine Description:

    This is the main thread that monitors the LPC port from the I/O system.
    It takes care of creating the LPC port, and waiting for input, which
    it then transforms into the right operation on the event log.


Arguments:

    NONE

Return Value:

    NONE

--*/

{
    NTSTATUS    Status;

    ELF_LOG0(LPC,
             "MainLPCThread: Inside LPC thread\n");

    Status = SetUpLPCPort();

    if (NT_SUCCESS(Status))
    {
        //
        // Loop forever. This thread will be killed when the service terminates.
        //
        while (TRUE)
        {
            Status = ElfProcessLPCCalls ();
        }
    }

    ELF_LOG1(ERROR,
             "MainLPCThread: SetUpLPCPort failed %#x\n",
             Status);

    return Status;

    UNREFERENCED_PARAMETER(LPCThreadParm);
}



BOOL
StartLPCThread(
    VOID
    )

/*++

Routine Description:

    This routine starts up the thread that monitors the LPC port.

Arguments:

    NONE

Return Value:

    TRUE if thread creation succeeded, FALSE otherwise.

Note:


--*/
{
    DWORD       error;
    DWORD       ThreadId;

    ELF_LOG0(LPC,
             "StartLPCThread: Start up the LPC thread\n");

    //
    // Start up the actual thread.
    //
    LPCThreadHandle = CreateThread(NULL,               // lpThreadAttributes
                                   0,               // dwStackSize
                                   MainLPCThread,      // lpStartAddress
                                   NULL,               // lpParameter
                                   0L,                 // dwCreationFlags
                                   &ThreadId);         // lpThreadId

    if (LPCThreadHandle == NULL)
    {
        error = GetLastError();

        ELF_LOG1(ERROR,
                 "MainLPCThread: CreateThread failed %d\n",
                 error);

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\elfrpc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ELFRPC.C

Abstract:

    This file contains the routines that handle the RPC calls to the
    Eventlog service via the Elf APIs.

Author:

    Rajen Shah  (rajens)    16-Jul-1991

Revision History:

    15-Feb-1995     MarkBl
        Unlink the ElfHandle *prior* to unlinking the module. Otherwise,
        if another thread happens to coincidentally be in the routine
        FindModuleStrucFromAtom, it's not going to get a hit for the
        module atom.

    18-May-1994     Danl
        IELF_HANDLE_rundown:  If the eventlog has been shutdown, then
        we want to skip the code in this routine because most of the
        resources will have been free'd.

    31-Jan-1994     Danl
        IELF_HANDLE_rundown: Notifiee structure was being free'd and then
        referenced when it's handle was removed from the list.  Now this
        is fixed so it advances to the next Notifiee in the list BEFORE the
        buffer is free'd.

--*/

//
// INCLUDES
//

#include <eventp.h>

extern DWORD  ElState;


VOID
IELF_HANDLE_rundown(
    IELF_HANDLE    ElfHandle
    )

/*++

Routine Description:

    This routine is called by the server RPC runtime to run down a
    Context Handle and to free any allocated data.  It also does all
    the work for ElfrCloseEL.

    It has to undo whatever was done in ElfrOpenEventLog in terms of
    allocating memory.

Arguments:

    None.

Return Value:

--*/

{
    PLOGMODULE pModule;
    NTSTATUS Status;
    PNOTIFIEE Notifiee;
    PNOTIFIEE NotifieeToDelete;

    //
    // Generate an Audit if neccessary
    //
    ElfpCloseAudit(L"EventLog", ElfHandle);

    //
    // If the eventlog service is stopped or in the process of
    // stopping, then we just want to ignore this rundown and return.
    //
    // Note, we don't bother calling GetElState() because that uses
    // a critical section which may not exist anymore as the
    // eventlog service has been shutdown.
    //
    // The eventlog isn't designed to be shutdown (except when the
    // system is shutdown), so it isn't real good at cleaning up
    // its resources.
    //
    if (ElState == STOPPING || ElState == STOPPED)
    {
        ELF_LOG1(HANDLE,
                 "IELF_HANDLE_rundown: Skipping rundown since ElState is %ws\n",
                 (ElState == STOPPING ? L"STOPPING" :
                                        L"STOPPED"));

        return;
    }

    ELF_LOG1(HANDLE,
             "IELF_HANDLE_rundown: Run down context handle %#x\n",
             ElfHandle);
    ASSERT(ElfHandle != gElfSecurityHandle);
    if (ElfHandle->Signature != ELF_CONTEXTHANDLE_SIGN)
    {
        ELF_LOG0(ERROR,
                 "IELF_HANDLE_rundown: Invalid context handle in rundown routine\n");

        return;
    }

    pModule = FindModuleStrucFromAtom(ElfHandle->Atom);

    //
    // This shouldn't ever happen.  It means that a handle got created
    // and its module went away without the handle getting closed.
    //
    if (!pModule)
    {
        ELF_LOG1(ERROR,
                 "IELF_HANDLE_rundown: Could not find module for atom %d on close\n",
                 ElfHandle->Atom);

        return;
    }

    UnlinkContextHandle(ElfHandle);    // Unlink it from the linked list

    //
    // If this handle was for a backup module, then we need to
    // close the file and clean up the data structures.  The standard logs
    // (Application, Security, and System) are never freed.
    //
    if (ElfHandle->Flags & ELF_LOG_HANDLE_BACKUP_LOG)
    {
        ELF_LOG0(HANDLE,
                 "IELF_HANDLE_rundown: Handle was for a backup log\n");

        Status = ElfpCloseLogFile(pModule->LogFile, ELF_LOG_CLOSE_BACKUP, TRUE);

        UnlinkLogModule(pModule);
        DeleteAtom(pModule->ModuleAtom);
        ElfpFreeBuffer(pModule->ModuleName);

        ElfpFreeBuffer(pModule);
    }
    else
    {
        ELF_LOG0(HANDLE,
                 "IELF_HANDLE_rundown: Handle was not for a backup log\n");

        //
        // See if this handle had an ElfChangeNotify outstanding and if so,
        // remove it from the list.  ElfChangeNotify can't be called with a
        // handle to a backup file.
        //

        //
        // Get exclusive access to the log file. This will ensure no one
        // else is accessing the file.
        //
        RtlAcquireResourceExclusive(&pModule->LogFile->Resource,
                                    TRUE);                  // Wait until available

        //
        // Walk the linked list and remove any entries for this handle
        //
        Notifiee = CONTAINING_RECORD(pModule->LogFile->Notifiees.Flink,
                                     struct _NOTIFIEE,
                                     Next);

        while (Notifiee->Next.Flink != pModule->LogFile->Notifiees.Flink)
        {
            //
            // If it's for this handle, remove it from the list
            //
            if (Notifiee->Handle == ElfHandle)
            {
                ELF_LOG0(HANDLE,
                         "IELF_HANDLE_rundown: Deleting a ChangeNotify request for handle\n");

                RemoveEntryList(&Notifiee->Next);
                NtClose(Notifiee->Event);
                NotifieeToDelete = Notifiee;

                Notifiee = CONTAINING_RECORD(Notifiee->Next.Flink,
                                             struct _NOTIFIEE,
                                             Next);

                ElfpFreeBuffer(NotifieeToDelete);
            }
            else
            {
                Notifiee = CONTAINING_RECORD(Notifiee->Next.Flink,
                                             struct _NOTIFIEE,
                                             Next);
            }
        }

        //
        // Free the resource
        //
        RtlReleaseResource ( &pModule->LogFile->Resource );
    }

    ElfpFreeBuffer(ElfHandle);    // Free the context-handle structure

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\elfproto.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    elfproto.h

Abstract:

    This file contains the prototypes for the Eventlog service.

Author:

    Rajen Shah (rajens) 12-Aug-1991

Revision History:

--*/

#ifndef _ELFPROTO_
#define _ELFPROTO

//
// Other prototypes
//
VOID
ElfpCreateHeap(
    VOID
    );

PVOID
ElfpAllocateBuffer(
    ULONG size
    );

BOOLEAN
ElfpFreeBuffer(
    PVOID BufPtr
    );

VOID
ElfPerformRequest( 
    PELF_REQUEST_RECORD Request
    );


PLOGMODULE
GetModuleStruc (
    PUNICODE_STRING ModuleName
    );

PLOGMODULE
FindModuleStrucFromAtom (
    ATOM Atom 
    );

VOID
ElfControlResponse(
    DWORD
    );

VOID
IELF_HANDLE_rundown(
    IELF_HANDLE    ElfHandle
    );

VOID
LinkContextHandle(
    IELF_HANDLE     LogHandle
    );

VOID
UnlinkContextHandle (
    IELF_HANDLE     LogHandle
    );

VOID
LinkLogModule (
    PLOGMODULE   pLogModule,
    ANSI_STRING * pModuleNameA
    );

VOID
UnlinkLogModule (
    PLOGMODULE pLogModule
    );

VOID
LinkLogFile (
    PLOGFILE   pLogFile
    );

VOID
UnlinkLogFile (
    PLOGFILE pLogFile
    );

VOID
GetGlobalResource (
    DWORD Type
    );

VOID
ReleaseGlobalResource(
    VOID
    );

NTSTATUS
SetUpDataStruct (
    PUNICODE_STRING     LogFileName,
    ULONG               MaxFileSize,
    ULONG               Retention,
    PUNICODE_STRING     ModuleName,
    HANDLE              hLogFile,
    ELF_LOG_TYPE        LogType,
    LOGPOPUP            logpLogPopup,
    DWORD               dwAutoBackup
    );

NTSTATUS
SetUpModules (
    HANDLE              hLogFile,
    PLOGFILE            pLogFile,
    BOOLEAN             bAllowDupes
    );

BOOL
StartLPCThread (
    VOID
    );

VOID
StopLPCThread (
    VOID
    );

BOOL
ElfStartRegistryMonitor (
    VOID
    );

VOID
StopRegistryMonitor (
    VOID
    );

NTSTATUS
ReadRegistryInfo (
    HANDLE          hLogFiles,
    PUNICODE_STRING SubKeyName,
    PLOG_FILE_INFO  LogFileInfo
    );

NTSTATUS
ElfOpenLogFile (
    PLOGFILE pLogFile,
    ELF_LOG_TYPE LogType
    );

NTSTATUS
ElfpCloseLogFile (
    PLOGFILE    pLogFile,
    DWORD       Flags,
    BOOL bFreeResources
    );

BOOL
ValidFilePos (
    PVOID Position,
    PVOID BeginningRecord,
    PVOID EndingRecord,
    PVOID PhysicalEOF,
    PVOID BaseAddress,
    BOOL  fCheckBeginEndRange
    );

VOID
ElfpCleanUp (
    ULONG EventFlags
    );

NTSTATUS
ElfpCopyFile (
    IN HANDLE SourceHandle,
    IN PUNICODE_STRING TargetFileName
    );

VOID
FreeModuleAndLogFileStructs (VOID);

NTSTATUS
ElfpFlushFiles (BOOL bShutdown);


VOID
InvalidateContextHandlesForLogFile (
    PLOGFILE    pLogFile
    );

VOID
FixContextHandlesForRecord (
    DWORD RecordOffset,
    DWORD NewRecordOffset,
    PLOGFILE pLogFile
    );

PLOGFILE
FindLogFileFromName (
    PUNICODE_STRING LogFileName
    );

BOOL
SendAdminAlert (
    ULONG   MessageID,
    ULONG   NumStrings,
    UNICODE_STRING  *pStrings
    );

PVOID
NextRecordPosition (
    ULONG   ReadFlags,
    PVOID   CurrPosition,
    ULONG   CurrRecordLength,
    PVOID   BeginRecord,
    PVOID   EndRecord,
    PVOID   PhysicalEOF,
    PVOID   PhysStart
    );

VOID
NotifyChange (
    PLOGFILE pLogFile
    );

VOID
WriteQueuedEvents (
    VOID
    );

VOID
FlushQueuedEvents (
    VOID
    );

VOID
PerformWriteRequest (
    PELF_REQUEST_RECORD Request
    );

NTSTATUS
ElfpCreateLogFileObject(
    PLOGFILE LogFile,
    DWORD Type,
    HANDLE hLogRegKey,
    BOOL bFirstTime,
    BOOL * pbSDChanged
    );

VOID
ElfpCloseAudit(
    IN  LPWSTR      SubsystemName,
    IN  IELF_HANDLE ContextHandle
    );

NTSTATUS
ElfpAccessCheckAndAudit(
    IN     LPWSTR SubsystemName,
    IN     LPWSTR ObjectTypeName,
    IN     LPWSTR ObjectName,
    IN OUT IELF_HANDLE ContextHandle,
    IN     PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN     ACCESS_MASK DesiredAccess,
    IN     PGENERIC_MAPPING GenericMapping,
    IN     BOOL ForSecurityLog
    );

NTSTATUS
ElfCreateWellKnownSids(
    VOID
    );

VOID
ElfFreeWellKnownSids(
    VOID
    );

NTSTATUS
ElfCreateAndSetSD(
    IN  PRTL_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid OPTIONAL,
    IN  PSID GroupSid OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

NTSTATUS
ElfCreateUserSecurityObject(
    IN  PRTL_ACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  BOOLEAN IsDirectoryObject,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );

VOID
ElfpCreateElfEvent(
    IN ULONG EventId,
    IN USHORT EventType,
    IN USHORT EventCategory,
    IN USHORT NumStrings,
    IN LPWSTR * Strings,
    IN LPVOID Data,
    IN ULONG DataSize,
    IN USHORT Flags,
    IN BOOL ForSecurity
    );


VOID
ElfpCreateQueuedAlert(
    DWORD MessageId,
    DWORD NumberOfStrings,
    LPWSTR Strings[]
    );

VOID
ElfpCreateQueuedMessage(
    DWORD MessageId,
    DWORD NumberOfStrings,
    LPWSTR Strings[]
    );

NTSTATUS
ElfpInitCriticalSection(
    PRTL_CRITICAL_SECTION  pCritsec
    );

NTSTATUS
ElfpInitResource(
    PRTL_RESOURCE  pResource
    );

DWORD
ElfStatusUpdate(
    IN DWORD    NewState
    );

DWORD
GetElState (
    VOID
    );

VOID
ElfpGenerateLogClearedEvent(
    IELF_HANDLE    LogHandle,
    LPWSTR pwsClientSidString,
    LPWSTR  pwsComputerName,
    PTOKEN_USER pToken 
    );

NTSTATUS
ElfpInitStatus(
    VOID
    );

VOID
ElCleanupStatus(
    VOID
    );

DWORD
ElfBeginForcedShutdown(
    IN BOOL     PendingCode,
    IN DWORD    ExitCode,
    IN DWORD    ServiceSpecificCode
    );

NTSTATUS
ElfpTestClientPrivilege(
    IN ULONG  ulPrivilege,
    IN HANDLE hThreadToken     OPTIONAL
    );

//SS: added to extend clustering support
NTSTATUS
FindSizeofEventsSinceStart (
    OUT PULONG               pulTotalEventSize,
    IN PULONG                pulNumLogFiles,
    OUT PPROPLOGFILEINFO     *ppPropLogFileInfo
    );    
    
NTSTATUS
GetEventsToProp(
    IN PEVENTLOGRECORD       pEventLogRecords,
    IN PPROPLOGFILEINFO      pPropLogFileInfo
    );

NTSTATUS
ElfCheckForComputerNameChange(
    );

NTSTATUS
ElfpInitializeBatchingSupport(
    VOID
    );

NTSTATUS
ElfpSaveEventBuffer(
    IN PLOGMODULE   pModule,
    IN PVOID        pEventBuffer,
    IN DWORD        dwRecordLength
    );

VOID CALLBACK
ElfpBatchEventsAndPropagate(
    IN PVOID    pContext,
    IN BOOLEAN  fTimerFired
    );

NTSTATUS
ElfpClusterRpcAccessCheck(
    VOID
    );

//SS: end of changes for clustering

VOID
ElfWriteTimeStamp(
    TIMESTAMPEVENT  EventType,
    BOOLEAN         Append
    );

VOID CALLBACK
ElfWriteLastAliveTimeStamp(
    UINT    uID,
    UINT    uMsg,
    DWORD   dwUser,
    DWORD   dw1,
    DWORD   dw2
    );

DWORD EstimateEventSize(
    DWORD dwStringEst,
    DWORD dwDataEst,
    LPWSTR pwsModuleName
    );

//
// NoonEvent related Functions.
// 
ULONG
GetNoonEventSystemUptime(
    );

ULONG   GetNextNoonEventDelay(
    );

DWORD   GetNoonEventHotFixInfo(
    LPWSTR*     ppszHotFixes
    );

VOID  BuildNoonEventPData(
    );

ULONG   GetNoonEventTimeStamp(
    );

NTSTATUS
VerifyUnicodeString(
    IN PUNICODE_STRING pUString
    );

LPWSTR
ElfpGetComputerName(
    VOID
    );

NTSTATUS
ElfpGetClientSidString(
    LPWSTR * ppwsClientSidString,
    PTOKEN_USER * ppToken
    );

NTSTATUS
VerifyFileIsFile (
    IN PUNICODE_STRING pUFileName
    );

DWORD 
GetModuleType(LPWSTR pwsModuleName);

PLOGFILE FindLogFileByModName(LPWSTR pwsLogDefModName);

NTSTATUS
FlushLogFile(
    PLOGFILE    pLogFile
    );

#endif // ifndef _ELFPROTO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\eventp.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    eventp.h

Abstract:

    Private include file for eventlog service

Author:

    Rajen Shah (rajens) 12-Jul-1991

Revision History:

--*/

#define UNICODE             // This service uses unicode APIs

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntelfapi.h>
#include <netevent.h>       // Manifest constants for Events

#include <windows.h>
#include <winsvc.h>

#include <lmcons.h>
#include <lmerr.h>
#include <rpc.h>
#include <svcsp.h>          // SVCS_ENTRY_POINT, PSVCS_GLOBAL_DATA
#include <regstr.h>

#include <elf.h>

#include <elfdef.h>
#include <elfcommn.h>
#include <elfproto.h>
#include <elfextrn.h>

#include <elfdbg.h>
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\elfsec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    elfsec.c


Author:

    Dan Hinsley (danhi)     28-Mar-1992

Environment:

    Calls NT native APIs.

Revision History:

    27-Oct-1993     danl
        Make Eventlog service a DLL and attach it to services.exe.
        Removed functions that create well-known SIDs.  This information
        is now passed into the Elfmain as a Global data structure containing
        all well-known SIDs.

    28-Mar-1992     danhi
        created - based on scsec.c in svcctrl by ritaw

    03-Mar-1995     markbl
        Added guest & anonymous logon log access restriction feature.

    18-Mar-2001     a-jyotig
        Added clean up code to ElfpAccessCheckAndAudit to reset the 
		g_lNumSecurityWriters to 0 in case of any error 
--*/

#include <eventp.h>
#include <elfcfg.h>
#include <Psapi.h>
#include <Sddl.h>
#include <strsafe.h>
#define PRIVILEGE_BUF_SIZE  512

extern long    g_lNumSecurityWriters;
BOOL g_bGetClientProc = FALSE;

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

NTSTATUS
ElfpGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    );

NTSTATUS
ElfpReleasePrivilege(
    VOID
    );

//-------------------------------------------------------------------//
//                                                                   //
// Structure that describes the mapping of generic access rights to  //
// object specific access rights for a LogFile object.               //
//                                                                   //
//-------------------------------------------------------------------//

static GENERIC_MAPPING LogFileObjectMapping = {

    STANDARD_RIGHTS_READ           |       // Generic read
        ELF_LOGFILE_READ,

    STANDARD_RIGHTS_WRITE          |       // Generic write
        ELF_LOGFILE_WRITE | ELF_LOGFILE_CLEAR,

    STANDARD_RIGHTS_EXECUTE        |       // Generic execute
        0,

    ELF_LOGFILE_ALL_ACCESS                 // Generic all
    };


LPWSTR 
GetCustomSDString(
    HANDLE hLogRegKey, BOOL *pbCustomSDAlreadyExists)
/*++

Routine Description:

    This function reads the SDDL security descriptor from the key.  Note that it may
    or may not be there.

Arguments:

    hLogFile - Handle to registry key for the log

Return Value:

    If NULL, then the key wasnt there.  Otherwise, it is a string that should be deleted
    via ElfpFreeBuffer 

--*/
{

    // read in the optional SD

    DWORD dwStatus, dwType, dwSize;

    *pbCustomSDAlreadyExists = FALSE;
    if(hLogRegKey == NULL)
        return NULL;
    dwStatus = RegQueryValueExW(hLogRegKey, VALUE_CUSTOM_SD, 0, &dwType,
                                0, &dwSize);
    if (dwStatus == 0 && dwType == REG_SZ)
    {
        LPWSTR wNew;
        *pbCustomSDAlreadyExists = TRUE;
        dwSize += sizeof(WCHAR);
        wNew = (LPWSTR)ElfpAllocateBuffer(dwSize);
        if(wNew)
        {
            dwStatus = RegQueryValueEx(hLogRegKey, VALUE_CUSTOM_SD, 0, &dwType,
                                (BYTE *)wNew, &dwSize);
            if (dwStatus != 0 ||dwType != REG_SZ)
            {
                ElfpFreeBuffer(wNew);
            }
            else
                return wNew;
        }
    }
    return NULL;    
}

//  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

// note for access rights, 1 = read, 2 = write, 4 = clear

LPWSTR pOwnerAndGroup = L"O:BAG:SYD:";

LPWSTR pDenyList = 
                L"(D;;0xf0007;;;AN)"                // Anonymous logon
                L"(D;;0xf0007;;;BG)";               // Guests

LPWSTR pSecurityList = 
                L"(A;;0xf0005;;;SY)"                // local system
                L"(A;;0x5;;;BA)";                   // built in admins

LPWSTR pSystemList = 
                L"(A;;0xf0007;;;SY)"                // local system
                L"(A;;0x7;;;BA)"                    // built in admins
                L"(A;;0x5;;;SO)"                    // server operators
                L"(A;;0x1;;;IU)"                    // INTERACTIVE LOGON
                L"(A;;0x1;;;SU)"                   // SERVICES LOGON
                L"(A;;0x1;;;S-1-5-3)"             // BATCH LOGON
                L"(A;;0x2;;;LS)"                    // local service
                L"(A;;0x2;;;NS)";                   // network service

LPWSTR pApplicationList = 
                L"(A;;0xf0007;;;SY)"                // local system
                L"(A;;0x7;;;BA)"                    // built in admins
                L"(A;;0x7;;;SO)"                    // server operators
                L"(A;;0x3;;;IU)"                    // INTERACTIVE LOGON
                L"(A;;0x3;;;SU)"                   // SERVICES LOGON
                L"(A;;0x3;;;S-1-5-3)";             // BATCH LOGON



//                L"(A;;0X3;;;S-1-5-3)";              // BATCH LOGON
//  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


LPWSTR GetDefaultSDDL(
    DWORD Type,
    HANDLE hLogRegKey
    )
/*++

Routine Description:

    This function is used when a log file does not have a custom security descriptor.
    This returns the string which should be freed by the caller via ElfpFreeBuffer.

Arguments:

    LogFile - pointer the the LOGFILE structure for this logfile

Return Value:


--*/
{

    LPWSTR pAllowList = NULL;    
    int iLenInWCHAR = 0;
    LPWSTR pwszTempSDDLString = NULL;
    BOOL bUseDenyList;
    DWORD dwRestrictGuestAccess;
    DWORD dwSize, dwType;
    long lRet;
    
    // Determine the Allow list

    if(Type == ELF_LOGFILE_SECURITY)
        pAllowList = pSecurityList;
    else if(Type == ELF_LOGFILE_SYSTEM)
        pAllowList = pSystemList;
    else
        pAllowList = pApplicationList;

    // determine if the deny list is applicable.
    
    bUseDenyList = TRUE;

    // if the RestrictGuestAccess is actually set and it is 0, then dont
    // restrict guests.
    
    dwSize = sizeof( DWORD );
    if(hLogRegKey)
    {
        lRet = RegQueryValueEx( hLogRegKey, VALUE_RESTRICT_GUEST_ACCESS, NULL,
                                                    &dwType, (LPBYTE)&dwRestrictGuestAccess, &dwSize);
        if(lRet ==  ERROR_SUCCESS && dwType == REG_DWORD && dwRestrictGuestAccess == 0)
            bUseDenyList = FALSE;
    }
    
    // Calculate the total length and allocate the buffer
    
    iLenInWCHAR = wcslen(pOwnerAndGroup) + 1;            // one for the eventual null as well as owner
    if (bUseDenyList)
        iLenInWCHAR += wcslen(pDenyList);
    iLenInWCHAR += wcslen(pAllowList);

    pwszTempSDDLString = ElfpAllocateBuffer(iLenInWCHAR * sizeof(WCHAR));
    if(pwszTempSDDLString == NULL)
    {
        return NULL;
    }

    // build the strings

    StringCchCopy(pwszTempSDDLString, iLenInWCHAR , pOwnerAndGroup);
    if (bUseDenyList)
      StringCchCat(pwszTempSDDLString, iLenInWCHAR , pDenyList);
    StringCchCat(pwszTempSDDLString, iLenInWCHAR , pAllowList);
    return pwszTempSDDLString;
    
}

NTSTATUS ChangeStringSD(
    PLOGFILE LogFile,
    LPWSTR pwsCustomSDDL)
{
    NTSTATUS Status;
    BOOL bRet;
    PSECURITY_DESCRIPTOR pSD;
    bRet = ConvertStringSecurityDescriptorToSecurityDescriptorW(
                pwsCustomSDDL,          // security descriptor string
                1,                    // revision level
                &pSD,  // SD
                NULL
                );
    if(!bRet)
    {
        ELF_LOG2(ERROR,
                     "ChangeStringSD: ConvertStringSDToSDW %#x\n, str = %ws\n", 
                     GetLastError(), pwsCustomSDDL);

        return STATUS_ACCESS_DENIED;
    }
    bRet = IsValidSecurityDescriptor(pSD);
    if(!bRet)
    {
        LocalFree(pSD);
        ELF_LOG2(ERROR,
                     "ChangeStringSD: IsValidSecurityDescriptor %#x\n, str = %ws", 
                     GetLastError(), pwsCustomSDDL);
        return STATUS_ACCESS_DENIED;
    }
    // copy this into a normal Rtl allocation since we dont want to keep
    // track of when the SD can be freed by LocalAlloc

    Status  = RtlCopySecurityDescriptor(
                        pSD,
                        &LogFile->Sd
                        );
    LocalFree(pSD);
    if(!NT_SUCCESS(Status))
        ELF_LOG1(ERROR,
                     "ChangeStringSD: RtlCopySecurityDescriptor %#x\n", Status); 
    return Status;
}

NTSTATUS
ElfpCreateLogFileObject(
    PLOGFILE LogFile,
    DWORD Type,
    HANDLE hLogRegKey,
    BOOL bFirstTime,
    BOOL * pbSDChanged
   )

/*++

Routine Description:

    This function creates the security descriptor which represents
    an active log file.

Arguments:

    LogFile - pointer the the LOGFILE structure for this logfile

Return Value:


--*/
{
    NTSTATUS Status;
    BOOL bRet; 
    BOOL bCustomSDAlreadExists = FALSE;
    long lRet;
    PSECURITY_DESCRIPTOR pSD;
    LPWSTR pwsCustomSDDL = NULL;
    *pbSDChanged = TRUE;        // SET TO FALSE iff current sd is unchanged
    
    // read the custom  SDDL descriptor

    pwsCustomSDDL = GetCustomSDString(hLogRegKey, &bCustomSDAlreadExists);

    if(!bFirstTime)
    {
        // in the case of rescanning the registry, the value probably has not changed and in 
        // that case we should return.

        if(pwsCustomSDDL == NULL && LogFile->pwsCurrCustomSD == NULL)
        {
            *pbSDChanged = FALSE;
            return STATUS_SUCCESS;        
        }
        if(pwsCustomSDDL && LogFile->pwsCurrCustomSD &&
            _wcsicmp(pwsCustomSDDL, LogFile->pwsCurrCustomSD) == 0)
        {
            ElfpFreeBuffer(pwsCustomSDDL);
            *pbSDChanged = FALSE;
            return STATUS_SUCCESS;        
        }
    }
    
    if(pwsCustomSDDL)
    {
        Status = ChangeStringSD(LogFile, pwsCustomSDDL);
        if(NT_SUCCESS(Status))
        {
           LogFile->pwsCurrCustomSD = pwsCustomSDDL;    // take ownership
           return Status;
        }
        ElfpFreeBuffer(pwsCustomSDDL);
        ELF_LOG1(ERROR,
                     "ElfpCreateLogFileObject: Failed trying to convert SDDL from registry %#x\n", Status);
        // we failed trying to create a custom SD.  Warn the user and revert to using
        // the equivalent of the system log.

        Type = ELF_LOGFILE_SYSTEM;

        ElfpCreateElfEvent(EVENT_LOG_BAD_CUSTOM_SD,
                                       EVENTLOG_ERROR_TYPE,
                                       0,                      // EventCategory
                                       1,                      // NumberOfStrings
                                       &LogFile->LogModuleName->Buffer,
                                       NULL,                   // Data
                                       0,                      // Datalength
                                       ELF_FORCE_OVERWRITE,    // Overwrite if necc.
                                       FALSE);                 // for security file    
    }

    // we failed because either there wasnt a string sd, or because there was
    // one and it was invalid (bNewCustomSD = FALSE)
    
    pwsCustomSDDL = GetDefaultSDDL(Type, hLogRegKey);
    if(pwsCustomSDDL == NULL)
        return STATUS_NO_MEMORY;
    Status = ChangeStringSD(LogFile, pwsCustomSDDL);
    
    if(NT_SUCCESS(Status))
    {
        LogFile->pwsCurrCustomSD = pwsCustomSDDL;    // take ownership
        if(bCustomSDAlreadExists == FALSE && hLogRegKey)
        {
            lRet = RegSetValueExW( 
                            hLogRegKey, 
                            VALUE_CUSTOM_SD, 
                            0, 
                            REG_SZ, 
                            (BYTE *)pwsCustomSDDL, 
                            2*(wcslen(pwsCustomSDDL) + 1));
            if(lRet != ERROR_SUCCESS )
                ELF_LOG1(ERROR,
                         "WriteDefaultSDDL: RegSetValueExW failed %#x\n", lRet);
        }
    }
    else 
    {
        ELF_LOG1(ERROR,
                     "ElfpCreateLogFileObject: failed trying to convert default SDDL %#x\n", Status);
        ElfpFreeBuffer(pwsCustomSDDL);
    }
    return Status;
}


NTSTATUS
ElfpVerifyThatCallerIsLSASS(HANDLE ClientToken
    )
/*++

Routine Description:

    This is called if the someone is trying to register themselves as an
    event source for the security log.  Only local copy of lsass.exe is 
    allowed to do that.

Return Value:

    NT status mapped to Win32 errors.

--*/
{
    UINT            LocalFlag;
    long            lCnt;
    ULONG           pid;
    HANDLE          hProcess;
    DWORD           dwNumChar;
    WCHAR           wModulePath[MAX_PATH + 1];
    WCHAR           wLsassPath[MAX_PATH + 1];
    RPC_STATUS      RpcStatus;
    BOOL Result;
    BYTE Buffer[SECURITY_MAX_SID_SIZE + sizeof(TOKEN_USER)];
    DWORD dwRequired;
    TOKEN_USER * pTokenUser = (TOKEN_USER *)Buffer;
    // first of all, only local calls are valid

    RpcStatus = I_RpcBindingIsClientLocal(
                    0,    // Active RPC call we are servicing
                    &LocalFlag
                    );

    if( RpcStatus != RPC_S_OK ) 
    {
        ELF_LOG1(ERROR,
                 "ElfpVerifyThatCallerIsLSASS: I_RpcBindingIsClientLocal failed %d\n",
                 RpcStatus);
        return I_RpcMapWin32Status(RpcStatus);
    }
    if(LocalFlag == 0)
    {
        ELF_LOG1(ERROR,
                 "ElfpVerifyThatCallerIsLSASS: Non local connect tried to get write access to security %d\n", 5);
        return STATUS_ACCESS_DENIED;             // access denied
    }

    // Get the process id

    RpcStatus = I_RpcBindingInqLocalClientPID(NULL, &pid );
    if( RpcStatus != RPC_S_OK ) 
    {
        ELF_LOG1(ERROR,
                 "ElfpVerifyThatCallerIsLSASS: I_RpcBindingInqLocalClientPID failed %d\n",
                 RpcStatus);
        return I_RpcMapWin32Status(RpcStatus);
    }

    // Get the process

    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, pid);
    if(hProcess == NULL)
        return STATUS_ACCESS_DENIED;

    // Get the module name of whoever is calling us.

    dwNumChar = GetModuleFileNameExW(hProcess, NULL, wModulePath, MAX_PATH);
    CloseHandle(hProcess);
    if(dwNumChar == 0)
        return STATUS_ACCESS_DENIED;

    dwNumChar = GetWindowsDirectoryW(wLsassPath, MAX_PATH);
    if(dwNumChar == 0)
        return GetLastError();
    if(dwNumChar > MAX_PATH - 19)
        return STATUS_ACCESS_DENIED;                   // should never happen

    StringCchCatW(wLsassPath, MAX_PATH + 1 , L"\\system32\\lsass.exe");
    if(lstrcmpiW(wLsassPath, wModulePath))
    {
        ELF_LOG1(ERROR,
                 "ElfpVerifyThatCallerIsLSASS: Non lsass process connect tried to get write access to security, returning %d\n", 5);
        return STATUS_ACCESS_DENIED;             // access denied
    }

    // make sure that the caller is running as local system account.


    Result = GetTokenInformation(ClientToken,
                                         TokenUser,
                                         Buffer,
                                         SECURITY_MAX_SID_SIZE + sizeof(TOKEN_USER),
                                         &dwRequired);

    if (!Result)
    {
        ELF_LOG1(ERROR,
                 "ElfpVerifyThatCallerIsLSASS: could not get user sid, error=%d\n", GetLastError());
        return STATUS_ACCESS_DENIED;             // access denied
    }

    Result = IsWellKnownSid(pTokenUser->User.Sid, WinLocalSystemSid);
    if (!Result)
    {
        ELF_LOG0(ERROR,
                 "ElfpVerifyThatCallerIsLSASS: sid does not match local system\n");
        return STATUS_ACCESS_DENIED;             // access denied
    }

    // One last check is to make sure that this access is granted only once

    lCnt = InterlockedIncrement(&g_lNumSecurityWriters);
    if(lCnt == 1)
        return 0;               // all is well!
    else
    {
        InterlockedDecrement(&g_lNumSecurityWriters);
        ELF_LOG1(ERROR,
                 "ElfpVerifyThatCallerIsLSASS: tried to get a second security write handle, returnin %d\n", 5);
        return STATUS_ACCESS_DENIED;             // access denied

    }
}

void DumpClientProc()
/*++

Routine Description:

    This dumps the client's process id and is used for debugging purposes.

--*/
{
    ULONG           pid;
    RPC_STATUS      RpcStatus;

    // Get the process id

    RpcStatus = I_RpcBindingInqLocalClientPID(NULL, &pid );
    if( RpcStatus != RPC_S_OK ) 
    {
        ELF_LOG1(ERROR,
                 "DumpClientProc: I_RpcBindingInqLocalClientPID failed %d\n",
                 RpcStatus);
        return;
    }
    else
        ELF_LOG1(TRACE, "DumpClientProc: The client proc is %d\n", pid);
    return;
}

NTSTATUS
ElfpAccessCheckAndAudit(
    IN     LPWSTR SubsystemName,
    IN     LPWSTR ObjectTypeName,
    IN     LPWSTR ObjectName,
    IN OUT IELF_HANDLE ContextHandle,
    IN     PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN     ACCESS_MASK DesiredAccess,
    IN     PGENERIC_MAPPING GenericMapping,
    IN     BOOL ForSecurityLog
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using NtAccessCheckAndAuditAlarm; and reverts back to
    itself before returning.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling this routine.

    ObjectTypeName - Supplies the name of the type of the object being
        accessed.

    ObjectName - Supplies the name of the object being accessed.

    ContextHandle - Supplies the context handle to the object.  On return, the
        granted access is written to the AccessGranted field of this structure
        if this call succeeds.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

    ForSecurityLog - TRUE if the access check is for the security log.
        This is a special case that may require a privilege check.

Return Value:

    NT status mapped to Win32 errors.

--*/
{
    NTSTATUS   Status;
    RPC_STATUS RpcStatus;

    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING Object;
    DWORD OrigDesiredAccess;
    BOOLEAN         GenerateOnClose = FALSE;
    NTSTATUS        AccessStatus;
    ACCESS_MASK     GrantedAccess = 0;
    HANDLE          ClientToken = NULL;
    PRIVILEGE_SET   PrivilegeSet;
    ULONG           PrivilegeSetLength = sizeof(PRIVILEGE_SET);
    ULONG           privileges[1];
    OrigDesiredAccess = DesiredAccess;

    GenericMapping = &LogFileObjectMapping;

    RtlInitUnicodeString(&Subsystem, SubsystemName);
    RtlInitUnicodeString(&ObjectType, ObjectTypeName);
    RtlInitUnicodeString(&Object, ObjectName);

    RpcStatus = RpcImpersonateClient(NULL);

    if (RpcStatus != RPC_S_OK)
    {
        ELF_LOG1(ERROR,
                 "ElfpAccessCheckAndAudit: RpcImpersonateClient failed %d\n",
                 RpcStatus);

        return I_RpcMapWin32Status(RpcStatus);
    }

    //
    // Get a token handle for the client
    //
    Status = NtOpenThreadToken(NtCurrentThread(),
                               TOKEN_QUERY,        // DesiredAccess
                               TRUE,               // OpenAsSelf
                               &ClientToken);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfpAccessCheckAndAudit: NtOpenThreadToken failed %#x\n",
                 Status);

        goto CleanExit;
    }

    // if the client is asking to write to the security log, make sure it is lsass.exe and no one
    // else.

    if(ForSecurityLog && (DesiredAccess & ELF_LOGFILE_WRITE))
    {
        Status = ElfpVerifyThatCallerIsLSASS(ClientToken);
        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "ElfpVerifyThatCallerIsLSASS failed %#x\n",
                     Status);
            goto CleanExit;
        }
        gElfSecurityHandle = ContextHandle;
        ContextHandle->GrantedAccess = ELF_LOGFILE_ALL_ACCESS;
        Status = STATUS_SUCCESS;
        goto CleanExit;
    }
    else if(g_bGetClientProc)
        DumpClientProc();


    //
    // We want to see if we can get the desired access, and if we do
    // then we also want all our other accesses granted.
    // MAXIMUM_ALLOWED gives us this.
    //
    DesiredAccess |= MAXIMUM_ALLOWED;

    Status = NtAccessCheck(SecurityDescriptor,
                           ClientToken,
                           DesiredAccess,
                           GenericMapping,
                           &PrivilegeSet,
                           &PrivilegeSetLength,
                           &GrantedAccess,
                           &AccessStatus);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfpAccessCheckAndAudit: NtAccessCheck failed %#x\n",
                 Status);

        goto CleanExit;
    }

    if (AccessStatus != STATUS_SUCCESS)
    {
        ELF_LOG1(TRACE,
                 "ElfpAccessCheckAndAudit: NtAccessCheck refused access -- status is %#x\n",
                 AccessStatus);

        //
        // If the access check failed, then some access can be granted based
        // on privileges.
        //
        if ((AccessStatus == STATUS_ACCESS_DENIED       || 
             AccessStatus == STATUS_PRIVILEGE_NOT_HELD)
           )
        {
            //
            // MarkBl 1/30/95 :  First, evalutate the existing code (performed
            //                   for read or clear access), since its
            //                   privilege check is more rigorous than mine.
            //
            Status = STATUS_ACCESS_DENIED;

            if (!(DesiredAccess & ELF_LOGFILE_WRITE) && ForSecurityLog)
            {
                //
                // If read or clear access to the security log is desired,
                // then we will see if this user passes the privilege check.
                //
                //
                // Do Privilege Check for SeSecurityPrivilege
                // (SE_SECURITY_NAME).
                //
                Status = ElfpTestClientPrivilege(SE_SECURITY_PRIVILEGE,
                                                 ClientToken);

                if (NT_SUCCESS(Status))
                {
                    GrantedAccess |= (ELF_LOGFILE_READ | ELF_LOGFILE_CLEAR);

                    ELF_LOG0(TRACE,
                             "ElfpAccessCheckAndAudit: ElfpTestClientPrivilege for "
                                 "SE_SECURITY_PRIVILEGE succeeded\n");
                }
                else
                {
                    ELF_LOG1(TRACE,
                             "ElfpAccessCheckAndAudit: ElfpTestClientPrivilege for "
                                 "SE_SECURITY_PRIVILEGE failed %#x\n",
                             Status);
                }
            }

            //
            // If the backup privilege is held and access still has not been granted, give
            // them a very limited form of access. 
            //
            if (!NT_SUCCESS(Status))
            {
                Status = ElfpTestClientPrivilege(SE_BACKUP_PRIVILEGE,
                                                 ClientToken);

                if (NT_SUCCESS(Status))
                {
                    ELF_LOG0(TRACE,
                             "ElfpAccessCheckAndAudit: ElfpTestClientPrivilege for "
                                 "SE_BACKUP_PRIVILEGE succeeded\n");

                    GrantedAccess |= ELF_LOGFILE_BACKUP;
                }
                else
                {
                    ELF_LOG1(ERROR,
                             "ElfpAccessCheckAndAudit: ElfpTestClientPrivilege for "
                                 "SE_BACKUP_PRIVILEGE failed %#x\n",
                             Status);

                    // special "fix" for wmi eventlog provider which is hard coded
                    // to look for a specific error code
                    
                    if(AccessStatus == STATUS_PRIVILEGE_NOT_HELD)
                        Status = AccessStatus;

                    goto CleanExit;
                }
            }

            // special "fix" for wmi eventlog provider which is hard coded
            // to look for a specific error code
            
            if(!NT_SUCCESS(Status) && ForSecurityLog)
                Status = STATUS_PRIVILEGE_NOT_HELD;
        }
        else
        {
            Status = AccessStatus;
        }
    }


    //
    // Revert to Self
    //
    RpcStatus = RpcRevertToSelf();

    if (RpcStatus != RPC_S_OK)
    {
        ELF_LOG1(ERROR,
                 "ElfpAccessCheckAndAudit: RpcRevertToSelf failed %d\n",
                 RpcStatus);

        //
        // We don't return the error status here because we don't want
        // to write over the other status that is being returned.
        //
    }

    //
    // Get SeAuditPrivilege so I can call NtOpenObjectAuditAlarm.
    // If any of this stuff fails, I don't want the status to overwrite the
    // status that I got back from the access and privilege checks.
    //
    privileges[0] = SE_AUDIT_PRIVILEGE;
    AccessStatus  = ElfpGetPrivilege(1, privileges);

    if (!NT_SUCCESS(AccessStatus))
    {
       ELF_LOG1(ERROR,
                "ElfpAccessCheckAndAudit: ElfpGetPrivilege (SE_AUDIT_PRIVILEGE) failed %#x\n",
                AccessStatus);
    }

    //
    // Call the Audit Alarm function.
    //
    AccessStatus = NtOpenObjectAuditAlarm(
                        &Subsystem,
                        (PVOID) &ContextHandle,
                        &ObjectType,
                        &Object,
                        SecurityDescriptor,
                        ClientToken,            // Handle ClientToken
                        DesiredAccess,
                        GrantedAccess,
                        &PrivilegeSet,          // PPRIVLEGE_SET
                        FALSE,                  // BOOLEAN ObjectCreation,
                        TRUE,                   // BOOLEAN AccessGranted,
                        &GenerateOnClose);

    if (!NT_SUCCESS(AccessStatus))
    {
        ELF_LOG1(ERROR,
                 "ElfpAccessCheckAndAudit: NtOpenObjectAuditAlarm failed %#x\n",
                 AccessStatus);
    }
    else
    {
        if (GenerateOnClose)
        {
            ContextHandle->Flags |= ELF_LOG_HANDLE_GENERATE_ON_CLOSE;
        }
    }

    //
    // Update the GrantedAccess in the context handle.
    //
    ContextHandle->GrantedAccess = GrantedAccess;

    if(ForSecurityLog)
        ContextHandle->GrantedAccess &= (~ELF_LOGFILE_WRITE);
        
    NtClose(ClientToken);

    ElfpReleasePrivilege();

    return Status;

CleanExit:

    //
    // Revert to Self
    //
    RpcStatus = RpcRevertToSelf();

    if (RpcStatus != RPC_S_OK)
    {
        ELF_LOG1(ERROR,
                 "ElfpAccessCheckAndAudit: RpcRevertToSelf (CleanExit) failed %d\n",
                 RpcStatus);

        //
        // We don't return the error status here because we don't want
        // to write over the other status that is being returned.
        //
    }

    if (ClientToken != NULL)
    {
        NtClose(ClientToken);
    }

    return Status;
}


VOID
ElfpCloseAudit(
    IN  LPWSTR      SubsystemName,
    IN  IELF_HANDLE ContextHandle
    )

/*++

Routine Description:

    If the GenerateOnClose flag in the ContextHandle is set, then this function
    calls NtCloseAuditAlarm in order to generate a close audit for this handle.

Arguments:

    ContextHandle - This is a pointer to an ELF_HANDLE structure.  This is the
        handle that is being closed.

Return Value:

    none.

--*/
{
    UNICODE_STRING  Subsystem;
    NTSTATUS        Status;
    NTSTATUS        AccessStatus;
    ULONG           privileges[1];

    RtlInitUnicodeString(&Subsystem, SubsystemName);

    if (ContextHandle->Flags & ELF_LOG_HANDLE_GENERATE_ON_CLOSE)
    {
        BOOLEAN     WasEnabled = FALSE;

        //
        // Get Audit Privilege
        //
        privileges[0] = SE_AUDIT_PRIVILEGE;
        AccessStatus = ElfpGetPrivilege(1, privileges);

        if (!NT_SUCCESS(AccessStatus))
        {
            ELF_LOG1(ERROR,
                     "ElfpCloseAudit: ElfpGetPrivilege (SE_AUDIT_PRIVILEGE) failed %#x\n",
                     AccessStatus);
        }

        //
        // Generate the Audit.
        //
        Status = NtCloseObjectAuditAlarm(&Subsystem,
                                         ContextHandle,
                                         TRUE);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "ElfpCloseAudit: NtCloseObjectAuditAlarm failed %#x\n",
                     Status);
        }

        ContextHandle->Flags &= (~ELF_LOG_HANDLE_GENERATE_ON_CLOSE);

        ElfpReleasePrivilege();
    }

    return;
}


NTSTATUS
ElfpGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    )

/*++

Routine Description:

    This function alters the privilege level for the current thread.

    It does this by duplicating the token for the current thread, and then
    applying the new privileges to that new token, then the current thread
    impersonates with that new token.

    Privileges can be relinquished by calling ElfpReleasePrivilege().

Arguments:

    numPrivileges - This is a count of the number of privileges in the
        array of privileges.

    pulPrivileges - This is a pointer to the array of privileges that are
        desired.  This is an array of ULONGs.

Return Value:

    NO_ERROR - If the operation was completely successful.

    Otherwise, it returns mapped return codes from the various NT 
	functions that are called.

--*/
{
    NTSTATUS                    ntStatus;
    HANDLE                      ourToken;
    HANDLE                      newToken;
    OBJECT_ATTRIBUTES           Obja;
    SECURITY_QUALITY_OF_SERVICE SecurityQofS;
    ULONG                       returnLen;
    PTOKEN_PRIVILEGES           pTokenPrivilege = NULL;
    DWORD                       i;

    //
    // Initialize the Privileges Structure
    //
    pTokenPrivilege =
        (PTOKEN_PRIVILEGES) ElfpAllocateBuffer(sizeof(TOKEN_PRIVILEGES)
                                                   + (sizeof(LUID_AND_ATTRIBUTES) *
                                                          numPrivileges));

    if (pTokenPrivilege == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfpGetPrivilege: Unable to allocate memory for pTokenPrivilege\n");

        return STATUS_NO_MEMORY;
    }

    pTokenPrivilege->PrivilegeCount = numPrivileges;

    for (i = 0; i < numPrivileges; i++)
    {
        pTokenPrivilege->Privileges[i].Luid = RtlConvertLongToLuid(pulPrivileges[i]);
        pTokenPrivilege->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;
    }

    //
    // Initialize Object Attribute Structure.
    //
    InitializeObjectAttributes(&Obja, NULL, 0L, NULL, NULL);

    //
    // Initialize Security Quality Of Service Structure
    //
    SecurityQofS.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQofS.ImpersonationLevel = SecurityImpersonation;
    SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
    SecurityQofS.EffectiveOnly = FALSE;

    Obja.SecurityQualityOfService = &SecurityQofS;

    //
    // Open our own Token
    //
    ntStatus = NtOpenProcessToken(NtCurrentProcess(),
                                  TOKEN_DUPLICATE,
                                  &ourToken);

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "ElfpGetPrivilege: NtOpenProcessToken failed %#x\n",
                 ntStatus);

        ElfpFreeBuffer(pTokenPrivilege);
        return ntStatus;
    }

    //
    // Duplicate that Token
    //
    ntStatus = NtDuplicateToken(
                ourToken,
                TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                &Obja,
                FALSE,                  // Duplicate the entire token
                TokenImpersonation,     // TokenType
                &newToken);             // Duplicate token

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "ElfpGetPrivilege: NtDuplicateToken failed %#x\n",
                 ntStatus);

        ElfpFreeBuffer(pTokenPrivilege);
        NtClose(ourToken);
        return ntStatus;
    }

    //
    // Add new privileges
    //
    ntStatus = NtAdjustPrivilegesToken(
                newToken,                   // TokenHandle
                FALSE,                      // DisableAllPrivileges
                pTokenPrivilege,            // NewState
                0,                          // size of previous state buffer
                NULL,                       // no previous state info
                &returnLen);                // numBytes required for buffer.

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "ElfpGetPrivilege: NtAdjustPrivilegesToken failed %#x\n",
                 ntStatus);

        ElfpFreeBuffer(pTokenPrivilege);
        NtClose(ourToken);
        NtClose(newToken);
        return ntStatus;
    }

    //
    // Begin impersonating with the new token
    //
    ntStatus = NtSetInformationThread(NtCurrentThread(),
                                      ThreadImpersonationToken,
                                      (PVOID) &newToken,
                                      (ULONG) sizeof(HANDLE));

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "ElfpGetPrivilege: NtAdjustPrivilegeToken failed %#x\n",
                 ntStatus);

        ElfpFreeBuffer(pTokenPrivilege);
        NtClose(ourToken);
        NtClose(newToken);
        return ntStatus;
    }

    ElfpFreeBuffer(pTokenPrivilege);
    NtClose(ourToken);
    NtClose(newToken);

    return STATUS_SUCCESS;
}



NTSTATUS
ElfpReleasePrivilege(
    VOID
    )

/*++

Routine Description:

    This function relinquishes privileges obtained by calling ElfpGetPrivilege().

Arguments:

    none

Return Value:

    STATUS_SUCCESS - If the operation was completely successful.

    Otherwise, it returns the error that occurred.

--*/
{
    NTSTATUS    ntStatus;
    HANDLE      NewToken;


    //
    // Revert To Self.
    //
    NewToken = NULL;

    ntStatus = NtSetInformationThread(NtCurrentThread(),
                                      ThreadImpersonationToken,
                                      &NewToken,
                                      (ULONG) sizeof(HANDLE));

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "ElfpReleasePrivilege: NtSetInformation thread failed %#x\n",
                 ntStatus);

        return ntStatus;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ElfpTestClientPrivilege(
    IN ULONG  ulPrivilege,
    IN HANDLE hThreadToken     OPTIONAL
    )

/*++

Routine Description:

    Checks if the client has the supplied privilege.

Arguments:

    None

Return Value:

    STATUS_SUCCESS - if the client has the appropriate privilege.

    STATUS_ACCESS_DENIED - client does not have the required privilege

--*/
{
    NTSTATUS      Status;
    PRIVILEGE_SET PrivilegeSet;
    BOOLEAN       Privileged;
    HANDLE        Token;
    RPC_STATUS    RpcStatus;

    UNICODE_STRING SubSystemName;
    RtlInitUnicodeString(&SubSystemName, L"Eventlog");

    if (hThreadToken != NULL)
    {
        Token = hThreadToken;
    }
    else
    {
        RpcStatus = RpcImpersonateClient(NULL);

        if (RpcStatus != RPC_S_OK)
        {
            ELF_LOG1(ERROR,
                     "ElfpTestClientPrivilege: RpcImpersonateClient failed %d\n",
                     RpcStatus);

            return I_RpcMapWin32Status(RpcStatus);
        }

        Status = NtOpenThreadToken(NtCurrentThread(),
                                   TOKEN_QUERY,
                                   TRUE,
                                   &Token);

        if (!NT_SUCCESS(Status))
        {
            //
            // Forget it.
            //
            ELF_LOG1(ERROR,
                     "ElfpTestClientPrivilege: NtOpenThreadToken failed %#x\n",
                     Status);

            RpcRevertToSelf();

            return Status;
        }
    }

    //
    // See if the client has the required privilege
    //
    PrivilegeSet.PrivilegeCount          = 1;
    PrivilegeSet.Control                 = PRIVILEGE_SET_ALL_NECESSARY;
    PrivilegeSet.Privilege[0].Luid       = RtlConvertLongToLuid(ulPrivilege);
    PrivilegeSet.Privilege[0].Attributes = SE_PRIVILEGE_ENABLED;

    Status = NtPrivilegeCheck(Token,
                              &PrivilegeSet,
                              &Privileged);

    if (NT_SUCCESS(Status) || (Status == STATUS_PRIVILEGE_NOT_HELD))
    {
        Status = NtPrivilegeObjectAuditAlarm(
                                    &SubSystemName,
                                    NULL,
                                    Token,
                                    0,
                                    &PrivilegeSet,
                                    Privileged);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "ElfpTestClientPrivilege: NtPrivilegeObjectAuditAlarm failed %#x\n",
                     Status);
        }
    }
    else
    {
        ELF_LOG1(ERROR,
                 "ElfpTestClientPrivilege: NtPrivilegeCheck failed %#x\n",
                 Status);
    }

    if (hThreadToken == NULL )
    {
        //
        // We impersonated inside of this function
        //
        NtClose(Token);
        RpcRevertToSelf();
    }

    //
    // Handle unexpected errors
    //

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "ElfpTestClientPrivilege: Failed %#x\n",
                 Status);

        return Status;
    }

    //
    // If they failed the privilege check, return an error
    //

    if (!Privileged)
    {
        ELF_LOG0(ERROR,
                 "ElfpTestClientPrivilege: Client failed privilege check\n");

        return STATUS_ACCESS_DENIED;
    }

    //
    // They passed muster
    //
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\file.c ===
/*

Copyright (c) 1990  Microsoft Corporation

Module Name:

    FILE.C

Abstract:

    This file contains the routines that deal with file-related operations.

Author:

    Rajen Shah  (rajens)    07-Aug-1991

Revision History:

    29-Aug-1994     Danl
        We no longer grow log files in place.  So there is no need to
        reserve the MaxConfigSize block of memory.

    18-Apr-2001     Danl
        Modified the function RevalidateLogHeader to change an ASSERT to a check 
		in order to return a proper error code if the condition is TRUE
--*/

//
// INCLUDES
//

#include <eventp.h>
#include <alertmsg.h>  // ALERT_ELF manifests
#include "elfcfg.h"
//
// Macros
//

#define IS_EOF(Ptr, Size) \
    ((Ptr)->Length == ELFEOFRECORDSIZE && \
        RtlCompareMemory (Ptr, &EOFRecord, Size) == Size)

#ifdef CORRUPTED


BOOLEAN
VerifyLogIntegrity(
    PLOGFILE pLogFile
    )

/*++

Routine Description:

    This routine walks the log file to verify that it isn't corrupt


Arguments:

    A pointer to the LOGFILE structure for the log to validate.

Return Value:

    TRUE if log OK
    FALSE if it is corrupt

Note:


--*/
{

    PEVENTLOGRECORD pEventLogRecord;
    PEVENTLOGRECORD pNextRecord;
    PVOID PhysicalStart;
    PVOID PhysicalEOF;
    PVOID BeginRecord;
    PVOID EndRecord;

    pEventLogRecord =
        (PEVENTLOGRECORD)((PBYTE) pLogFile->BaseAddress + pLogFile->BeginRecord);

    PhysicalStart =
        (PVOID) ((PBYTE) pLogFile->BaseAddress + FILEHEADERBUFSIZE);

    PhysicalEOF =
        (PVOID) ((PBYTE) pLogFile->BaseAddress + pLogFile->ViewSize);

    BeginRecord = (PVOID)((PBYTE) pLogFile->BaseAddress + pLogFile->BeginRecord);
    EndRecord   = (PVOID)((PBYTE) pLogFile->BaseAddress + pLogFile->EndRecord);

    while(pEventLogRecord->Length != ELFEOFRECORDSIZE)
    {
        pNextRecord =
            (PEVENTLOGRECORD) NextRecordPosition(EVENTLOG_FORWARDS_READ,
                                                 (PVOID) pEventLogRecord,
                                                 pEventLogRecord->Length,
                                                 BeginRecord,
                                                 EndRecord,
                                                 PhysicalEOF,
                                                 PhysicalStart);

        if (!pNextRecord || pNextRecord->Length == 0)
        {
            ELF_LOG2(ERROR,
                     "VerifyLogIntegrity: The %ws logfile is corrupt near %p\n",
                     pLogFile->LogModuleName->Buffer,
                     pEventLogRecord);

            return FALSE;
        }

        pEventlogRecord = pNextRecord;
    }

    return TRUE;
}

#endif // CORRUPTED


NTSTATUS
FlushLogFile(
    PLOGFILE    pLogFile
    )

/*++

Routine Description:

    This routine flushes the file specified. It updates the file header,
    and then flushes the virtual memory which causes the data to get
    written to disk.

Arguments:

    pLogFile points to the log file structure.

Return Value:

    NONE

Note:


--*/
{
    NTSTATUS    Status;
    IO_STATUS_BLOCK IoStatusBlock;
    PVOID       BaseAddress;
    SIZE_T      RegionSize;
    PELF_LOGFILE_HEADER pLogFileHeader;

    //
    // If the dirty bit is set, update the file header before flushing it.
    //
    if (pLogFile->Flags & ELF_LOGFILE_HEADER_DIRTY)
    {
        ELF_LOG1(FILES,
                 "FlushLogFile: %ws log is dirty -- updating header before flushing\n",
                 pLogFile->LogModuleName->Buffer);

        pLogFileHeader = (PELF_LOGFILE_HEADER) pLogFile->BaseAddress;

        pLogFile->Flags &= ~ELF_LOGFILE_HEADER_DIRTY; // Remove dirty bit

        pLogFileHeader->Flags               = pLogFile->Flags;
        pLogFileHeader->StartOffset         = pLogFile->BeginRecord;
        pLogFileHeader->EndOffset           = pLogFile->EndRecord;
        pLogFileHeader->CurrentRecordNumber = pLogFile->CurrentRecordNumber;
        pLogFileHeader->OldestRecordNumber  = pLogFile->OldestRecordNumber;
    }

    //
    // Flush the memory in the section that is mapped to the file.
    //
    BaseAddress = pLogFile->BaseAddress;
    RegionSize  = pLogFile->ViewSize;

    Status = NtFlushVirtualMemory(NtCurrentProcess(),
                                  &BaseAddress,
                                  &RegionSize,
                                  &IoStatusBlock);

    return Status;
}



NTSTATUS
ElfpFlushFiles(
    BOOL bShutdown
    )

/*++

Routine Description:

    This routine flushes all the log files and forces them on disk.
    It is usually called in preparation for a shutdown or a pause.

Arguments:

   bShutdown    - true if being called from shut down.  In that case, the code
                  doesnt bother locking the resources

Return Value:

    NONE

Note:


--*/

{

    PLOGFILE    pLogFile;
    NTSTATUS    Status = STATUS_SUCCESS;

    //
    // Make sure that there's at least one file to flush
    //

    if (IsListEmpty(&LogFilesHead))
    {
        ELF_LOG0(FILES,
                 "ElfpFlushFiles: No log files -- returning success\n");

        return STATUS_SUCCESS;
    }

    pLogFile = (PLOGFILE) CONTAINING_RECORD(LogFilesHead.Flink, LOGFILE, FileList);

    //
    // Go through this loop at least once. This ensures that the termination
    // condition will work correctly.
    //
    do
    {
        if(bShutdown)
            Status = FlushLogFile(pLogFile);
        else
        {
            RtlAcquireResourceExclusive (&pLogFile->Resource, TRUE);                  // Wait until available
            Status = FlushLogFile(pLogFile);
            RtlReleaseResource(&pLogFile->Resource);
        }
        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "ElfpFlushFiles: FlushLogFile on %ws log failed %#x\n",
                     pLogFile->LogModuleName->Buffer,
                     Status);
        }

        //
        // Get the next one
        //
        pLogFile = (PLOGFILE) CONTAINING_RECORD(pLogFile->FileList.Flink, LOGFILE, FileList);
    }
    while ((pLogFile->FileList.Flink != LogFilesHead.Flink) && (NT_SUCCESS(Status)));

    return Status;
}

void FreeStuff(PLOGFILE    pLogFile)
{
    UnlinkLogFile(pLogFile); // Unlink the structure
    RtlDeleteResource ( &pLogFile->Resource );
    RtlDeleteSecurityObject(&pLogFile->Sd);
    ElfpFreeBuffer (pLogFile->LogFileName);
    ElfpFreeBuffer (pLogFile->LogModuleName);
    ElfpFreeBuffer (pLogFile->pwsCurrCustomSD);
    ElfpFreeBuffer (pLogFile);
}

NTSTATUS
ElfpCloseLogFile(
    PLOGFILE    pLogFile,
    DWORD       Flags,
    BOOL bFreeResources
    )

/*++

Routine Description:

    This routine undoes whatever is done in ElfOpenLogFile.

Arguments:

    pLogFile points to the log file structure.

Return Value:

    NTSTATUS.

Note:


--*/
{
    LARGE_INTEGER NewSize;
    IO_STATUS_BLOCK IoStatusBlock;
    PELF_LOGFILE_HEADER pLogFileHeader;
    PVOID               BaseAddress;
    ULONG               Size;
    long lRef;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusCloseSection = STATUS_SUCCESS;
    ELF_LOG2(FILES,
             "ElfpCloseLogfile: Closing and unmapping file %ws (%ws log)\n",
             pLogFile->LogFileName->Buffer,
             pLogFile->LogModuleName->Buffer);


#ifdef CORRUPTED

    //
    // Just for debugging a log corruption problem
    //

    if (!VerifyLogIntegrity(pLogFile))
    {
        ELF_LOG1(FILES,
                 "ElfpCloseLogfile: Integrity check failed for file %ws\n",
                 pLogFile->LogFileName->Buffer);
    }

#endif // CORRUPTED


    //
    // If the dirty bit is set, update the file header before closing it.
    // Check to be sure it's not a backup file that just had the dirty
    // bit set when it was copied.
    //

    if (pLogFile->Flags & ELF_LOGFILE_HEADER_DIRTY
         &&
        !(Flags & ELF_LOG_CLOSE_BACKUP))
    {
        pLogFile->Flags &= ~(ELF_LOGFILE_HEADER_DIRTY |
                             ELF_LOGFILE_ARCHIVE_SET  );   // Remove dirty &
                                                            // archive bits
        if(pLogFile->BaseAddress)
        {
            pLogFileHeader = (PELF_LOGFILE_HEADER) pLogFile->BaseAddress;

            pLogFileHeader->StartOffset         = pLogFile->BeginRecord;
            pLogFileHeader->EndOffset           = pLogFile->EndRecord;
            pLogFileHeader->CurrentRecordNumber = pLogFile->CurrentRecordNumber;
            pLogFileHeader->OldestRecordNumber  = pLogFile->OldestRecordNumber;
            pLogFileHeader->Flags               = pLogFile->Flags;
        }
    }

    RtlEnterCriticalSection(&LogFileCritSec);

    //
    // Decrement the reference count, and if it goes to zero, unmap the file
    // and close the handle. Also force the close if fForceClosed is TRUE.
    // Note that the ref counting is done while the resource is held.  This 
    // prevents getting a false 0 due to a simultaneous clear

    RtlAcquireResourceExclusive (&pLogFile->Resource,
                                 TRUE);                  // Wait until available
    lRef = InterlockedDecrement(&pLogFile->RefCount);
    RtlReleaseResource(&pLogFile->Resource);
    
    if ((lRef == 0) || (Flags & ELF_LOG_CLOSE_FORCE))
    {
        //
        // Last user has gone.
        // Close all the views and the file and section handles.  Free up
        // any extra memory we had reserved, and unlink any structures
        //
        if (pLogFile->BaseAddress)     // Unmap it if it was allocated
        {
            Status = NtUnmapViewOfSection(NtCurrentProcess(),
                                 pLogFile->BaseAddress);
            if (!NT_SUCCESS(Status))
            {
                DbgPrint("[ELF] %lx: ElfpCloseLogFile: Failed calling NtUnmapViewOfSection, Status = %#x\n",
                        GetCurrentThreadId(),Status); 
                if(bFreeResources)
                    FreeStuff(pLogFile);
                RtlLeaveCriticalSection(&LogFileCritSec);
                return Status;
            }
            pLogFile->BaseAddress = NULL;
        }

        if (pLogFile->SectionHandle)
        {
            StatusCloseSection = NtClose(pLogFile->SectionHandle);
            if (!NT_SUCCESS(StatusCloseSection))
            {
                DbgPrint("[ELF] %lx: ElfpCloseLogFile: Failed calling NtClose of the SectionHandle, Status = %#x\n",
                        GetCurrentThreadId(),StatusCloseSection); 
            }
            pLogFile->SectionHandle = NULL;
        }

        if (pLogFile->FileHandle)
        {
            if(pLogFile->bFailedExpansion)
            {
                NewSize = RtlConvertUlongToLargeInteger(pLogFile->ActualMaxFileSize);

                //
                // Set the size back to what it was
                //
                Status = NtSetInformationFile(pLogFile->FileHandle,
                                              &IoStatusBlock,
                                              &NewSize,
                                              sizeof(NewSize),
                                              FileEndOfFileInformation);
                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG2(ERROR,
                         "ElfpCloseLogFile: NtSetInformationFile for %ws log failed %#x\n",
                         pLogFile->LogModuleName->Buffer,
                         Status);
                }

            }
            Status = NtClose(pLogFile->FileHandle);
            if (!NT_SUCCESS(Status))
            {
                DbgPrint("[ELF] %lx: ElfpCloseLogFile: Failed calling NtClose of the FileHandle, Status = %#x\n",
                        GetCurrentThreadId(),Status); 
            }
            pLogFile->FileHandle = NULL;
        }
        if(bFreeResources)
            FreeStuff(pLogFile);
    }

    RtlLeaveCriticalSection(&LogFileCritSec);
    if (!NT_SUCCESS(Status))
        return Status;
    else if (!NT_SUCCESS(StatusCloseSection))
        return StatusCloseSection;
    else return STATUS_SUCCESS;

} // ElfpCloseLogFile



NTSTATUS
RevalidateLogHeader(
    PELF_LOGFILE_HEADER pLogFileHeader,
    PLOGFILE pLogFile
    )

/*++

Routine Description:

    This routine is called if we encounter a "dirty" log file. The
    routine walks through the file until it finds a signature for a valid log
    record.  Then it walks backwards from the first record it found until it 
    finds the EOF record from the other direction.  It then walks forward thru 
	the file until it finds the EOF record, or an invalid record.
    It then rebuilds the header and writes it back to the log.  If it can't
    find any valid records, it rebuilds the header to reflect an empty log
    file.  If it finds a trashed file, it writes 256 bytes of the log out in
    an event to the system log.

Arguments:

    pLogFileHeader points to the header of the log file.
    pLogFile points to the log file structure.

Return Value:

    NTSTATUS.

Note:

    This is an expensive routine since it scans the entire file.

    It assumes that the records are on DWORD boundaries.

--*/
{
    PVOID Start, End;
    PDWORD pSignature;
    PEVENTLOGRECORD pEvent;
    PEVENTLOGRECORD FirstRecord;
    PEVENTLOGRECORD FirstPhysicalRecord;
    PEVENTLOGRECORD pLastGoodRecord = NULL;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER ByteOffset;
    SIZE_T Size;
    int iNumWrap = 0;

    ELF_LOG1(FILES,
             "RevalidateLogHeader: %ws log had dirty bit set -- revalidating\n",
             pLogFile->LogModuleName->Buffer);

    //
    // BUGBUG: This function is full of return statements from inside the
    //         try-except block.  They need to go away.
    //

    try
    {
        //
        // Physical start and end of log file (skipping header)
        //
        Start = (PVOID) ((PBYTE) pLogFile->BaseAddress + FILEHEADERBUFSIZE);
        End = (PVOID) ((PBYTE) pLogFile->BaseAddress + pLogFile->ActualMaxFileSize);

        //
        // First see if the log has wrapped.  The EOFRECORDSIZE is for the one
        // case where the EOF record wraps so that its final length just replaces
        // the next record's starting length
        //
        pEvent = (PEVENTLOGRECORD) Start;

        if (pEvent->Reserved != ELF_LOG_FILE_SIGNATURE
             ||
            pEvent->RecordNumber != 1
             ||
            pEvent->Length == ELFEOFRECORDSIZE)
        {
            ELF_LOG1(FILES,
                     "RevalidateLogHeader: %ws log has wrapped -- looking for "
                         "first valid record\n",
                     pLogFile->LogModuleName->Buffer);

            //
            // Log has already wrapped, go looking for the first valid record
            //
            for (pSignature = (PDWORD) Start;
                 (PVOID) pSignature < End;
                 pSignature++)
            {
                if (*pSignature == ELF_LOG_FILE_SIGNATURE)
                {
                    //
                    // Make sure it's really a record
                    //
                    pEvent = CONTAINING_RECORD(pSignature, EVENTLOGRECORD, Reserved);

                    if (!ValidFilePos(pEvent, Start, End, End, pLogFileHeader, TRUE))
                    {
                        //
                        // Nope, not really, keep trying
                        //
                        continue;
                    }

                    //
                    // This is a valid record, Remember this so you can use
                    // it later
                    //
                    FirstPhysicalRecord = pEvent;

                    ELF_LOG1(FILES,
                             "RevalidateLogHeader: First physical record in %ws log "
                                 "found at %p\n",
                             FirstPhysicalRecord);

                    //
                    // Walk backwards from here (wrapping if necessary) until
                    // you hit the EOF record or an invalid record.
                    //
                    while (pEvent
                            &&
                           ValidFilePos(pEvent, Start, End, End, pLogFileHeader, TRUE))
                    {
                        //
                        // See if it's the EOF record
                        //

                        //
                        // BUGBUG:  If (End - pEvent) is less than ELFEOFUNIQUEPART,
                        //          we never validate what should be the remainder of
                        //          the EOF record at the start of the logfile
                        //
                        if (IS_EOF(pEvent,
                                   min(ELFEOFUNIQUEPART,
                                       (ULONG_PTR) ((PBYTE) End - (PBYTE) pEvent))))
                        {
                            ELF_LOG2(FILES,
                                     "RevalidateLogHeader: Found EOF record (backwards "
                                         "scan) for log %ws at %p\n",
                                     pLogFile->LogModuleName->Buffer,
                                     pEvent);

                            break;
                        }

                        pLastGoodRecord = pEvent;

                        pEvent = NextRecordPosition (
                                     EVENTLOG_SEQUENTIAL_READ |
                                         EVENTLOG_BACKWARDS_READ,
                                     pEvent,
                                     pEvent->Length,
                                     0,
                                     0,
                                     End,
                                     Start);

                        if(pLastGoodRecord < pEvent)
                            iNumWrap++;

                        //
                        // Make sure we're not in an infinite loop
                        //
                        if (pEvent == FirstPhysicalRecord || iNumWrap > 4)
                        {
                            ELF_LOG1(FILES,
                                     "RevalidateLogHeader: Infinite loop (backwards scan) "
                                         "in %ws log -- no EOF or invalid record found\n",
                                     pLogFile->LogModuleName->Buffer);

                            return STATUS_UNSUCCESSFUL;
                        }
                    }

                    //
                    // Found the first record, now go look for the last
                    //
                    ELF_LOG2(FILES,
                             "RevalidateLogHeader: First valid record in %ws "
                                 "log is at %p\n",
                             pLogFile->LogModuleName->Buffer,
                             pLastGoodRecord);

                    FirstRecord = pLastGoodRecord;
                    break;
                }
            }

            if (pSignature == End || pLastGoodRecord == NULL)
            {
                //
                // Either there were no valid records in the file or
                // the only valid record was the EOF record (which
                // means the log is trashed anyhow).  Give up
                // and we'll set it to an empty log file.
                //
                ELF_LOG1(FILES,
                         "RevalidateLogHeader: No valid records found in %ws log\n",
                         pLogFile->LogModuleName->Buffer);

                return STATUS_UNSUCCESSFUL;
            }
        }
        else
        {
            ELF_LOG1(FILES,
                     "RevalidateLogHeader: %ws log has not wrapped -- "
                         "first record is at %p\n",
                     pLogFile->LogModuleName->Buffer);

            //
            // We haven't wrapped yet
            //
            FirstPhysicalRecord = FirstRecord = Start;
        }

        //
        // Now read forward looking for the last good record
        //
        pEvent = FirstPhysicalRecord;

        while (pEvent
                &&
               ValidFilePos(pEvent, Start, End, End, pLogFileHeader, TRUE))
        {
            //
            // See if it's the EOF record
            //
            if (IS_EOF(pEvent,
                       min(ELFEOFUNIQUEPART,
                           (ULONG_PTR) ((PBYTE) End - (PBYTE) pEvent))))
            {
                ELF_LOG2(FILES,
                         "RevalidateLogHeader: Found EOF record (forwards scan) "
                             "for log %ws at %p\n",
                         pLogFile->LogModuleName->Buffer,
                         pEvent);

                break;
            }

            pLastGoodRecord = pEvent;

            pEvent = NextRecordPosition(EVENTLOG_SEQUENTIAL_READ |
                                          EVENTLOG_FORWARDS_READ,
                                        pEvent,
                                        pEvent->Length,
                                        0,
                                        0,
                                        End,
                                        Start);

            if(pLastGoodRecord > pEvent)
                iNumWrap++;

            //
            // Make sure we're not in an infinite loop
            //
            if (pEvent == FirstPhysicalRecord || iNumWrap > 4)
            {
                ELF_LOG1(FILES,
                         "RevalidateLogHeader: Infinite loop (forwards scan) "
                             "in %ws log -- no EOF or invalid record found\n",
                         pLogFile->LogModuleName->Buffer);


                return(STATUS_UNSUCCESSFUL);
            }
        }

        //
        // Now we know the first record (FirstRecord) and the last record
        // (pLastGoodRecord) so we can create the header an EOF record and
        // write them out (EOF record gets written at pEvent)
        //
        // First the EOF record
        //
        //
        // If the EOF record was wrapped, we can't write out the entire record at
        // once.  Instead, we'll write out as much as we can and then write the
        // rest out at the beginning of the log
        //
        Size = min((PBYTE) End - (PBYTE) pEvent, ELFEOFRECORDSIZE);

        if (Size != ELFEOFRECORDSIZE)
        {
            // Make absolutely sure we have enough room to write the remainder of
            // the EOF record.  Note that this should always be the case since the
            // record was wrapped around to begin with.  To do this, make sure
            // that the number of bytes we're writing after the header is <= the
            // offset of the first record from the end of the header
            //
			
			//Refer to bug# 359188. This scenario should never happen but because of 
			//unknown reasons, it happened to occur in one of the log files. so the 
			//following check which was ASSERT in the earlier version was changed to 
			//return STATUS_UNSUCCESSFUL

            if((ELFEOFRECORDSIZE - Size) <= (ULONG)((PBYTE) FirstRecord
                                       - (PBYTE) pLogFileHeader
                                       - FILEHEADERBUFSIZE))

			{
                ELF_LOG1(FILES,
                         "RevalidateLogHeader: Overlapping EOF record "
                             "in %ws log -- No space for writing remainder of EOF record between file header and first record \n",
                         pLogFile->LogModuleName->Buffer);
				return(STATUS_UNSUCCESSFUL);        
			}

		}


		EOFRecord.BeginRecord = (ULONG) ((PBYTE) FirstRecord - (PBYTE) pLogFileHeader);
        EOFRecord.EndRecord = (ULONG) ((PBYTE) pEvent - (PBYTE) pLogFileHeader);

        EOFRecord.CurrentRecordNumber = pLastGoodRecord->RecordNumber + 1;
        EOFRecord.OldestRecordNumber  = FirstRecord->RecordNumber;

        ByteOffset = RtlConvertUlongToLargeInteger((ULONG) ((PBYTE) pEvent
                                                       - (PBYTE) pLogFileHeader));

        Status = NtWriteFile(
                    pLogFile->FileHandle,   // Filehandle
                    NULL,                   // Event
                    NULL,                   // APC routine
                    NULL,                   // APC context
                    &IoStatusBlock,         // IO_STATUS_BLOCK
                    &EOFRecord,             // Buffer
                    (ULONG) Size,           // Length
                    &ByteOffset,            // Byteoffset
                    NULL);                  // Key

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "RevalidateLogHeader: EOF record write for %ws log failed %#x\n",
                     pLogFile->LogModuleName->Buffer,
                     Status);

            return Status;
        }

        if (Size != ELFEOFRECORDSIZE)
        {
            PBYTE   pBuff;

            pBuff = (PBYTE) &EOFRecord + Size;
            Size = ELFEOFRECORDSIZE - Size;
            ByteOffset = RtlConvertUlongToLargeInteger(FILEHEADERBUFSIZE);

			// We have already made sure we have enough room to write the remainder of
            // the EOF record. 

            //ASSERT(Size <= (ULONG)((PBYTE) FirstRecord
            //                           - (PBYTE) pLogFileHeader
            //                           - FILEHEADERBUFSIZE));

            Status = NtWriteFile(
                        pLogFile->FileHandle,   // Filehandle
                        NULL,                   // Event
                        NULL,                   // APC routine
                        NULL,                   // APC context
                        &IoStatusBlock,         // IO_STATUS_BLOCK
                        pBuff,                  // Buffer
                        (ULONG) Size,           // Length
                        &ByteOffset,            // Byteoffset
                        NULL);                  // Key

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "RevalidateLogHeader: EOF record write (part 2) for "
                             "%ws log failed %#x\n",
                         pLogFile->LogModuleName->Buffer,
                         Status);

                return Status;
            }
        }

        //
        // Now the header
        //

        pLogFileHeader->StartOffset = (ULONG) ((PBYTE) FirstRecord - (PBYTE) pLogFileHeader);
        pLogFileHeader->EndOffset   = (ULONG) ((PBYTE) pEvent- (PBYTE) pLogFileHeader);

        pLogFileHeader->CurrentRecordNumber = pLastGoodRecord->RecordNumber + 1;
        pLogFileHeader->OldestRecordNumber  = FirstRecord->RecordNumber;

        pLogFileHeader->HeaderSize = pLogFileHeader->EndHeaderSize = FILEHEADERBUFSIZE;
        pLogFileHeader->Signature  = ELF_LOG_FILE_SIGNATURE;
        pLogFileHeader->Flags      = 0;

        if (pLogFileHeader->StartOffset != FILEHEADERBUFSIZE)
        {
            pLogFileHeader->Flags |= ELF_LOGFILE_HEADER_WRAP;
        }

        pLogFileHeader->MaxSize      = pLogFile->ActualMaxFileSize;
        pLogFileHeader->Retention    = pLogFile->Retention;
        pLogFileHeader->MajorVersion = ELF_VERSION_MAJOR;
        pLogFileHeader->MinorVersion = ELF_VERSION_MINOR;

        //
        // Now flush this to disk to commit it
        //
        Start = pLogFile->BaseAddress;
        Size  = FILEHEADERBUFSIZE;

        Status = NtFlushVirtualMemory(NtCurrentProcess(),
                                      &Start,
                                      &Size,
                                      &IoStatusBlock);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "RevalidateLogHeader: NtFlushVirtualMemory for %ws log "
                         "header failed %#x\n",
                     pLogFile->LogModuleName->Buffer,
                     Status);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}


NTSTATUS
ElfOpenLogFile (
    PLOGFILE    pLogFile,
    ELF_LOG_TYPE LogType
    )

/*++

Routine Description:

    Open the log file, create it if it does not exist.
    Create a section and map a view into the log file.
    Write out the header to the file, if it is newly created.
    If "dirty", update the "start" and "end" pointers by scanning
    the file.  Set AUTOWRAP if the "start" does not start right after
    the file header.

Arguments:

    pLogFile -- pointer to the log file structure, with the relevant data
                filled in.

    CreateOptions -- options to be passed to NtCreateFile that indicate
                     whether to open an existing file, or to create it
                     if it does not exist.

Return Value:

    NTSTATUS.

Note:

    It is up to the caller to set the RefCount in the Logfile structure.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    LARGE_INTEGER MaximumSizeOfSection;
    LARGE_INTEGER ByteOffset;
    PELF_LOGFILE_HEADER pLogFileHeader;
    FILE_STANDARD_INFORMATION FileStandardInfo;
    ULONG IoStatusInformation;
    ULONG FileDesiredAccess;
    ULONG SectionDesiredAccess;
    ULONG SectionPageProtection;
    ULONG CreateOptions;
    ULONG CreateDisposition;
    SIZE_T ViewSize;
    ELF_LOGFILE_HEADER localHeaderCopy;

    //
    // File header in a new file has the "Start" and "End" pointers the
    // same since there are no records in the file.
    //
    static ELF_LOGFILE_HEADER FileHeaderBuf = { FILEHEADERBUFSIZE, // Size
                                                ELF_LOG_FILE_SIGNATURE,
                                                ELF_VERSION_MAJOR,
                                                ELF_VERSION_MINOR,
                                                FILEHEADERBUFSIZE, // Start offset
                                                FILEHEADERBUFSIZE, // End offset
                                                1,                 // Next record #
                                                0,                 // Oldest record #
                                                0,                 // Maxsize
                                                0,                 // Flags
                                                0,                 // Retention
                                                FILEHEADERBUFSIZE  // Size
                                              };

    //
    // Set the file open and section create options based on the type of log
    // file this is.
    //
    switch (LogType)
    {
        case ElfNormalLog:

            ELF_LOG0(FILES,
                     "ElfpOpenLogfile: Opening ElfNormalLog\n");

            CreateDisposition = FILE_OPEN_IF;
            FileDesiredAccess = GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE;

            SectionDesiredAccess = SECTION_MAP_READ | SECTION_MAP_WRITE
                                       | SECTION_QUERY | SECTION_EXTEND_SIZE;

            SectionPageProtection = PAGE_READWRITE;
            CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT;
            break;

        case ElfSecurityLog:

            ELF_LOG0(FILES,
                     "ElfpOpenLogfile: Opening ElfSecurityLog\n");

            CreateDisposition = FILE_OPEN_IF;
            FileDesiredAccess = GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE;

            SectionDesiredAccess = SECTION_MAP_READ | SECTION_MAP_WRITE
                                       | SECTION_QUERY | SECTION_EXTEND_SIZE;

            SectionPageProtection = PAGE_READWRITE;
            CreateOptions = FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT;
            break;

        case ElfBackupLog:

            ELF_LOG0(FILES,
                     "ElfpOpenLogfile: Opening ElfBackupLog\n");

            CreateDisposition = FILE_OPEN;
            FileDesiredAccess = GENERIC_READ | SYNCHRONIZE;
            SectionDesiredAccess = SECTION_MAP_READ | SECTION_QUERY;
            SectionPageProtection = PAGE_READONLY;
            CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT;
            break;
    }

    ELF_LOG1(FILES,
             "ElfpOpenLogfile: Opening and mapping %ws\n",
             pLogFile->LogFileName->Buffer);

    if (pLogFile->FileHandle != NULL)
    {
        //
        // The log file is already in use. Do not reopen or remap it.
        //
        ELF_LOG0(FILES,
                 "ElfpOpenLogfile: Log file already in use by another module\n");
    }
    else
    {
        //
        // Initialize the logfile structure so that it is easier to clean
        // up.
        //
        pLogFile->ActualMaxFileSize = ELF_DEFAULT_LOG_SIZE;
        pLogFile->Flags = 0;
        pLogFile->BaseAddress = NULL;
        pLogFile->SectionHandle = NULL;

        //
        // Set up the object attributes structure for the Log File
        //
        InitializeObjectAttributes(&ObjectAttributes,
                                   pLogFile->LogFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        //
        // Open the Log File. Create it if it does not exist and it's not
        // being opened as a backup file.  If creating, create a file of
        // the maximum size configured.
        //
        MaximumSizeOfSection = RtlConvertUlongToLargeInteger(ELF_DEFAULT_LOG_SIZE);

        Status = NtCreateFile(&pLogFile->FileHandle,
                              FileDesiredAccess,
                              &ObjectAttributes,
                              &IoStatusBlock,
                              &MaximumSizeOfSection,
                              FILE_ATTRIBUTE_NORMAL,
                              FILE_SHARE_READ,
                              CreateDisposition,
                              CreateOptions,
                              NULL,
                              0);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "ElfpOpenLogfile: Open of %ws log failed %#x\n",
                     pLogFile->LogModuleName->Buffer,
                     Status);

            goto cleanup;
        }

        //
        // If the file already existed, get its size and use that as the
        // actual size of the file.
        //
        IoStatusInformation = (ULONG) IoStatusBlock.Information;

        if (!( IoStatusInformation & FILE_CREATED ))
        {
            ELF_LOG1(FILES,
                     "ElfpOpenLogfile: File %ws already exists\n",
                     pLogFile->LogFileName->Buffer);

            Status = NtQueryInformationFile(pLogFile->FileHandle,
                                            &IoStatusBlock,
                                            &FileStandardInfo,
                                            sizeof (FileStandardInfo),
                                            FileStandardInformation);

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "ElfpOpenLogfile: NtQueryInformationFile for %ws failed %#x\n",
                         pLogFile->LogFileName->Buffer,
                         Status);

                goto cleanup;
            }
            else
            {
                ELF_LOG3(FILES,
                         "ElfpOpenLogfile: Use existing size for %ws log: %#x:%#x\n",
                         pLogFile->LogModuleName->Buffer,
                         FileStandardInfo.EndOfFile.HighPart,
                         FileStandardInfo.EndOfFile.LowPart);

                MaximumSizeOfSection.LowPart  = FileStandardInfo.EndOfFile.LowPart;
                MaximumSizeOfSection.HighPart = FileStandardInfo.EndOfFile.HighPart;

                //
                // Make sure that the high DWORD of the file size is ZERO.
                //
                // BUGBUG:  Is this OK for 64-bit machines?
                //
                ASSERT(MaximumSizeOfSection.HighPart == 0);

                //
                // If the filesize if 0, set it to the minimum size
                //
                if (MaximumSizeOfSection.LowPart == 0)
                {
                    ELF_LOG1(FILES,
                             "ElfpOpenLogfile: File was size 0 -- setting it to %#x\n",
                             ELF_DEFAULT_LOG_SIZE);

                    MaximumSizeOfSection.LowPart = ELF_DEFAULT_LOG_SIZE;
                }

                //
                // Set actual size of file
                //
                pLogFile->ActualMaxFileSize = MaximumSizeOfSection.LowPart;

                //
                // If the size of the log file is reduced, a clear must
                // happen for this to take effect
                //
                if (pLogFile->ActualMaxFileSize > pLogFile->ConfigMaxFileSize)
                {
                    pLogFile->ConfigMaxFileSize = pLogFile->ActualMaxFileSize;
                }
            }
        }

        //
        // Create a section mapped to the Log File just opened
        //
        Status = NtCreateSection(
                    &pLogFile->SectionHandle,
                    SectionDesiredAccess,
                    NULL,
                    &MaximumSizeOfSection,
                    SectionPageProtection,
                    SEC_COMMIT,
                    pLogFile->FileHandle);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "ElfpOpenLogfile: NtCreateSection for %ws failed %#x\n",
                     pLogFile->LogFileName->Buffer,
                     Status);

            goto cleanup;
        }

        //
        // Map a view of the Section into the eventlog address space
        //
        ViewSize = 0;

        Status = NtMapViewOfSection(
                        pLogFile->SectionHandle,
                        NtCurrentProcess(),
                        &pLogFile->BaseAddress,
                        0,
                        0,
                        NULL,
                        &ViewSize,
                        ViewUnmap,
                        0,
                        SectionPageProtection);

        pLogFile->ViewSize = (ULONG) ViewSize;

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "ElfpOpenLogfile: NtMapViewOfSection for %ws failed %#x\n",
                     pLogFile->LogFileName->Buffer,
                     Status);

            goto cleanup;
        }

        // file is ready to use.
        
        pLogFile->bHosedByClear = FALSE;
        pLogFile->LastStatus = 0;
        pLogFile->bFullAlertDone = FALSE;

        //
        // If the file was just created, write out the file header.
        //
        if (IoStatusInformation & FILE_CREATED)
        {
            ELF_LOG1(FILES,
                     "ElfpOpenLogfile: Created file %ws\n",
                     pLogFile->LogFileName->Buffer);

JustCreated:

            FileHeaderBuf.MaxSize   = pLogFile->ActualMaxFileSize;
            FileHeaderBuf.Flags     = 0;
            FileHeaderBuf.Retention = pLogFile->Retention;

            //
            // Copy the header into the file
            //
            ByteOffset = RtlConvertUlongToLargeInteger(0);

            Status = NtWriteFile(
                        pLogFile->FileHandle,   // Filehandle
                        NULL,                   // Event
                        NULL,                   // APC routine
                        NULL,                   // APC context
                        &IoStatusBlock,         // IO_STATUS_BLOCK
                        &FileHeaderBuf,         // Buffer
                        FILEHEADERBUFSIZE,      // Length
                        &ByteOffset,            // Byteoffset
                        NULL);                  // Key

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "ElfpOpenLogfile: File header write for %ws failed %#x\n",
                         pLogFile->LogFileName->Buffer,
                         Status);

                goto cleanup;
            }

            //
            // Copy the "EOF" record right after the header
            //
            ByteOffset = RtlConvertUlongToLargeInteger(FILEHEADERBUFSIZE);

            Status = NtWriteFile(
                        pLogFile->FileHandle,   // Filehandle
                        NULL,                   // Event
                        NULL,                   // APC routine
                        NULL,                   // APC context
                        &IoStatusBlock,         // IO_STATUS_BLOCK
                        &EOFRecord,             // Buffer
                        ELFEOFRECORDSIZE,       // Length
                        &ByteOffset,            // Byteoffset
                        NULL);                  // Key

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "ElfpOpenLogfile: EOF record write for %ws failed %#x\n",
                         pLogFile->LogFileName->Buffer,
                         Status);

                goto cleanup;
            }
        }

        //
        // Check to ensure that this is a valid log file. We look at the
        // size of the header and the signature to see if they match, as
        // well as checking the version number.
        //

        pLogFileHeader = &localHeaderCopy;
        try
        {
            memcpy(pLogFileHeader, pLogFile->BaseAddress, sizeof(ELF_LOGFILE_HEADER));
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            Status = STATUS_UNSUCCESSFUL;
            goto cleanup;
        }
        
        if ((pLogFileHeader->HeaderSize != FILEHEADERBUFSIZE)
              ||
            (pLogFileHeader->EndHeaderSize != FILEHEADERBUFSIZE)
              ||
            (pLogFileHeader->Signature  != ELF_LOG_FILE_SIGNATURE)
              ||
            (pLogFileHeader->MajorVersion != ELF_VERSION_MAJOR)
              ||
            (pLogFileHeader->MinorVersion != ELF_VERSION_MINOR))
        {
            //
            // This file is corrupt -- reset it to an empty log unless
            // it's being opened as a backup file.  If it is, fail the
            // open
            //
            ELF_LOG1(FILES,
                     "ElfpOpenLogfile: Invalid file header in %ws\n",
                     pLogFile->LogFileName->Buffer);

            if (LogType == ElfBackupLog)
            {
               Status = STATUS_EVENTLOG_FILE_CORRUPT;
               goto cleanup;
            }
            else
            {
                ElfpCreateQueuedAlert(ALERT_ELF_LogFileCorrupt,
                                      1,
                                      &pLogFile->LogModuleName->Buffer);
                //
                // Treat it like it was just created
                //
                goto JustCreated;
            }
        }
        else
        {
            //
            // If the "dirty" bit is set in the file header, then we need to
            // revalidate the BeginRecord and EndRecord fields since we did not
            // get a chance to write them out before the system was rebooted.
            // If the dirty bit is set and it's a backup file, just fail the
            // open.
            //
            if (pLogFileHeader->Flags & ELF_LOGFILE_HEADER_DIRTY)
            {
                ELF_LOG1(FILES,
                         "ElfpOpenLogfile: File %ws has dirty header\n",
                         pLogFile->LogFileName->Buffer);

                if (LogType == ElfBackupLog)
                {
                   Status = STATUS_EVENTLOG_FILE_CORRUPT;
                   goto cleanup;
                }
                else
                {
                   Status = RevalidateLogHeader((PELF_LOGFILE_HEADER)pLogFile->BaseAddress, pLogFile);

                   if (NT_SUCCESS(Status))
                   {
                       try
                       {
                           memcpy(pLogFileHeader, pLogFile->BaseAddress, sizeof(ELF_LOGFILE_HEADER));
                       }
                       except (EXCEPTION_EXECUTE_HANDLER)
                       {
                           Status = STATUS_UNSUCCESSFUL;
                           goto cleanup;
                       }
                   }   
                }
            }

            if (NT_SUCCESS(Status))
            {
                //
                // Set the beginning and end record positions in our
                // data structure as well as the wrap flag if appropriate.
                //
                pLogFile->EndRecord   = pLogFileHeader->EndOffset;
                pLogFile->BeginRecord = pLogFileHeader->StartOffset;

                if (pLogFileHeader->Flags & ELF_LOGFILE_HEADER_WRAP)
                {
                    pLogFile->Flags |= ELF_LOGFILE_HEADER_WRAP;
                }

                ELF_LOG3(FILES,
                         "ElfpOpenLogfile: %ws log -- BeginRecord: %#x, EndRecord: %#x\n",
                         pLogFile->LogModuleName->Buffer,
                         pLogFile->BeginRecord,
                         pLogFile->EndRecord);
            }
            else
            {
                //
                // Couldn't validate the file, treat it like it was just
                // created (turn it into an empty file)
                //
                goto JustCreated;
            }

#ifdef CORRUPTED

            //
            // Just for debugging a log corruption problem
            //

            if (!VerifyLogIntegrity(pLogFile))
            {
                ELF_LOG1(ERROR,
                         "ElfpOpenLogfile: Integrity check failed for %ws\n",
                         pLogFile->LogFileName->Buffer);
            }

#endif // CORRUPTED

        }

        //
        // Fill in the first and last record number values in the LogFile
        // data structure.
        //
        // SS: Save the record number of the first record in this session
        // so that if the cluster service starts after the eventlog service
        // it will be able to forward the pending records for replication
        // when the cluster service registers
        //
        pLogFile->SessionStartRecordNumber = pLogFileHeader->CurrentRecordNumber;
        pLogFile->CurrentRecordNumber      = pLogFileHeader->CurrentRecordNumber;
        pLogFile->OldestRecordNumber       = pLogFileHeader->OldestRecordNumber;
    }

    return Status;

cleanup:

    //
    // Clean up anything that got allocated
    //
    if (pLogFile->ViewSize)
    {
        NtUnmapViewOfSection(NtCurrentProcess(), pLogFile->BaseAddress);
        pLogFile->BaseAddress = NULL;
    }

    if (pLogFile->SectionHandle)
    {
        NtClose(pLogFile->SectionHandle);
        pLogFile->SectionHandle = NULL;
    }

    if (pLogFile->FileHandle)
    {
        NtClose (pLogFile->FileHandle);
        pLogFile->FileHandle = NULL;
    }

    return Status;
}

BOOL LooksLikePipe(PUNICODE_STRING pUFileName)
{
    if(pUFileName->Length < 18)
        return FALSE;
    if(_wcsnicmp( pUFileName->Buffer, L"\\??\\pipe\\", 9))
        return FALSE;
    else
        return TRUE;
}

NTSTATUS
VerifyFileIsFile (
    IN PUNICODE_STRING pUFileName
    )

/*++

Routine Description:

    Checks a file name to make sure it isnt pointing to something
    bogus like a com port.

Arguments:

    pUFileName -- File name.
Return Value:

    NTSTATUS.

--*/
{

    OBJECT_ATTRIBUTES   ObjectAttributes;

    DWORD dwMask;
    FILE_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;

    if(LooksLikePipe(pUFileName))
        return STATUS_INVALID_PARAMETER;

    InitializeObjectAttributes(&ObjectAttributes,
                                       pUFileName,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);
    Status = NtQueryAttributesFile(
                 &ObjectAttributes,
                 &BasicInfo
                 );

    if(Status == STATUS_OBJECT_NAME_NOT_FOUND)
        return STATUS_SUCCESS;
    if(Status == STATUS_OBJECT_PATH_NOT_FOUND)
        return STATUS_SUCCESS;
    if (!NT_SUCCESS(Status))
        return Status;

    // The file already exists -- create mask of the attributes that would make an existing file invalid for use

    dwMask =     FILE_ATTRIBUTE_DEVICE |
                        FILE_ATTRIBUTE_DIRECTORY |
                        FILE_ATTRIBUTE_OFFLINE |
                        FILE_ATTRIBUTE_READONLY |
                        FILE_ATTRIBUTE_REPARSE_POINT |
                        FILE_ATTRIBUTE_SPARSE_FILE |
                        FILE_ATTRIBUTE_SYSTEM |
                        FILE_ATTRIBUTE_TEMPORARY;

    if (BasicInfo.FileAttributes & dwMask)
        return STATUS_INVALID_PARAMETER;
    else
        return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\elfutil.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ELFUTIL.C

Abstract:

    This file contains all the utility routines for the Eventlog service.

Author:

    Rajen Shah  (rajens)    16-Jul-1991


Revision History:
    01-May-2001     a-jyotig
		CurrentTime is initialized to 0 in function WriteQueuedEvents. 
		Refer to prefix bug# 318163
--*/

//
// INCLUDES
//

#include <eventp.h>
#include <elfcfg.h>
#include <lmalert.h>
#include <string.h>
#include <stdlib.h>
#include <tstr.h>

extern DWORD  ElState;

PLOGMODULE
FindModuleStrucFromAtom(
    ATOM Atom
    )

/*++

Routine Description:

    This routine scans the list of module structures and finds the one
    that matches the module atom.

Arguments:

    Atom contains the atom matching the module name.

Return Value:

    A pointer to the log module structure is returned.
    NULL if no matching atom is found.

Note:

--*/
{
    PLOGMODULE  ModuleStruc;

    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogModuleCritSec);

    ModuleStruc = CONTAINING_RECORD(LogModuleHead.Flink,
                                    LOGMODULE,
                                    ModuleList);

    while ((ModuleStruc->ModuleList.Flink != &LogModuleHead)
             &&
           (ModuleStruc->ModuleAtom != Atom))
    {
        ModuleStruc = CONTAINING_RECORD(ModuleStruc->ModuleList.Flink,
                                        LOGMODULE,
                                        ModuleList);
    }

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogModuleCritSec);

    return (ModuleStruc->ModuleAtom == Atom ? ModuleStruc : NULL);
}



PLOGMODULE
GetModuleStruc(
    PUNICODE_STRING ModuleName
    )

/*++

Routine Description:

    This routine returns a pointer to the log module structure for the
    module specified in ModuleName. If none exists, the default structure
    for application is returned.

Arguments:

    ModuleName contains the name of the module.

Return Value:

    A pointer to the log module structure is returned.

Note:


--*/
{
    NTSTATUS    Status;
    ATOM        ModuleAtom;
    ANSI_STRING ModuleNameA;
    PLOGMODULE  pModule;

    Status = RtlUnicodeStringToAnsiString(&ModuleNameA,
                                          ModuleName,
                                          TRUE);

    if (!NT_SUCCESS(Status))
    {
        //
        // Not much else we can do here...
        //
        ELF_LOG2(ERROR,
                 "GetModuleStruc: Unable to convert Unicode string %ws to Ansi %#x\n",
                 ModuleName->Buffer,
                 Status);

        return ElfDefaultLogModule;
    }

    //
    // Guarantee that it's NULL terminated
    //
    ModuleNameA.Buffer[ModuleNameA.Length] = '\0';

    ModuleAtom = FindAtomA(ModuleNameA.Buffer);

    RtlFreeAnsiString(&ModuleNameA);

    if (ModuleAtom == (ATOM)0)
    {
        ELF_LOG1(TRACE,
                 "GetModuleStruc: No atom found for module %ws -- defaulting to Application\n",
                 ModuleName->Buffer);

        return ElfDefaultLogModule;
    }
     
    pModule = FindModuleStrucFromAtom(ModuleAtom);

    return (pModule != NULL ? pModule : ElfDefaultLogModule);
}



VOID
UnlinkContextHandle(
    IELF_HANDLE     LogHandle
    )

/*++

Routine Description:

    This routine unlinks the LogHandle specified from the linked list of
    context handles.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    LogHandle points to a context handle structure.

Return Value:

    NONE

Note:


--*/
{
    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogHandleCritSec);

    //
    // Remove this entry
    //
    RemoveEntryList(&LogHandle->Next);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogHandleCritSec);
}


VOID
LinkContextHandle(
    IELF_HANDLE    LogHandle
    )

/*++

Routine Description:

    This routine links the LogHandle specified into the linked list of
    context handles.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    LogHandle points to a context handle structure.

Return Value:

    NONE

Note:


--*/
{
    ASSERT(LogHandle->Signature == ELF_CONTEXTHANDLE_SIGN);

    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogHandleCritSec);

    //
    // Place structure at the beginning of the list.
    //
    InsertHeadList(&LogHandleListHead, &LogHandle->Next);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogHandleCritSec);
}


VOID
UnlinkQueuedEvent(
    PELF_QUEUED_EVENT QueuedEvent
    )

/*++

Routine Description:

    This routine unlinks the QueuedEvent specified from the linked list of
    QueuedEvents.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    QueuedEvent - The request to remove from the linked list

Return Value:

    NONE

Note:


--*/
{
    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&QueuedEventCritSec);

    //
    // Remove this entry
    //
    RemoveEntryList(&QueuedEvent->Next);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&QueuedEventCritSec);
}



VOID
LinkQueuedEvent(
    PELF_QUEUED_EVENT QueuedEvent
    )

/*++

Routine Description:

    This routine links the QueuedEvent specified into the linked list of
    QueuedEvents.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    QueuedEvent - The request to add from the linked list

Return Value:

    NONE

Note:


--*/
{
    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&QueuedEventCritSec);

    //
    // Place structure at the beginning of the list.
    //
    InsertHeadList(&QueuedEventListHead, &QueuedEvent->Next);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&QueuedEventCritSec);
}


DWORD
WINAPI
ElfpSendMessage(
    LPVOID UnUsed
    )

/*++

Routine Description:

    This routines just uses MessageBox to pop up a message.

    This is it's own routine so we can spin a thread to do this, in case the
    user doesn't hit the OK button for a while.

Arguments:

    NONE

Return Value:

    NONE

Note:

--*/
{
    PVOID MessageBuffer;
    HANDLE hLibrary;
    LPWSTR * StringPointers;
    DWORD i;
    PELF_QUEUED_EVENT QueuedEvent;
    PELF_QUEUED_EVENT FlushEvent;

    //
    // If we are shutting down, we need to return
    // and allow resources to be freed
    //
    if (ElState == STOPPING || ElState == STOPPED)
    {
        ELF_LOG1(TRACE,
                 "ElfpSendMessage: Skipping SendMessage since ElState is %ws\n",
                 (ElState == STOPPING ? L"STOPPING" :
                                        L"STOPPED"));

        return 0;
    }

    RtlEnterCriticalSection(&QueuedMessageCritSec);

    //
    // First get a handle to the message file used for the message text
    //
    hLibrary = LoadLibraryEx(L"NETMSG.DLL",
                             NULL,
                             LOAD_LIBRARY_AS_DATAFILE);

    if (hLibrary != NULL)
    {
        //
        // Walk the linked list and process each element
        //

        QueuedEvent = CONTAINING_RECORD(QueuedMessageListHead.Flink,
                                        struct _ELF_QUEUED_EVENT,
                                        Next);

        while (QueuedEvent->Next.Flink != QueuedMessageListHead.Flink)
        {
            ASSERT(QueuedEvent->Type == Message);

            //
            // Unlock the linked list -- normally not a safe thing since we're
            // about to play with a pointer to an element in it, but:
            //
            //     a. This is the only routine where a list item can be removed/deleted
            //
            //     b. We don't touch the only potentially-volatile structure member
            //            (QueuedEvent->Next) until we're in the critsec again below
            //
            //     c. Only one thread at a time executes this code (enforced by
            //            MBThreadHandle, which is only read/written inside the critsec)
            //
            RtlLeaveCriticalSection(&QueuedMessageCritSec);

            //
            // Build the array of pointers to the insertion strings
            //
            StringPointers =
                (LPWSTR *) ElfpAllocateBuffer(QueuedEvent->Event.Message.NumberOfStrings
                                                  * sizeof(LPWSTR));

            if (StringPointers)
            {
                //
                // Build the array of pointers to the insertion string(s)
                //
                if (QueuedEvent->Event.Message.NumberOfStrings)
                {
                    StringPointers[0] = (LPWSTR) ((PBYTE) &QueuedEvent->Event.Message +
                                                       sizeof(ELF_MESSAGE_RECORD));

                    for (i = 1;
                         i < QueuedEvent->Event.Message.NumberOfStrings;
                         i++)
                    {
                        StringPointers[i] = StringPointers[i-1]
                                                + wcslen(StringPointers[i - 1])
                                                + 1;
                    }
                }

                //
                // Call FormatMessage to build the message
                //
                if (FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                     FORMAT_MESSAGE_ARGUMENT_ARRAY |
                                     FORMAT_MESSAGE_FROM_HMODULE,
                                   hLibrary,
                                   QueuedEvent->Event.Message.MessageId,
                                   0,                       // Default language ID
                                   (LPWSTR) &MessageBuffer,
                                   0,                       // Min # of bytes to allocate
                                   (va_list *) StringPointers))
                {
                    //
                    // Now actually display it
                    //
                    MessageBoxW(NULL,
                                (LPWSTR) MessageBuffer,
                                GlobalMessageBoxTitle,
                                MB_OK |
                                  MB_SETFOREGROUND |
                                  MB_ICONEXCLAMATION |
                                  MB_SERVICE_NOTIFICATION);

                    LocalFree(MessageBuffer);
                }
                else
                {
                    ELF_LOG1(ERROR,
                             "ElfpSendMessage: FormatMessage failed %d\n",
                             GetLastError());
                }

                ElfpFreeBuffer(StringPointers);
            }

            //
            // If we are shutting down, we need to break out of this loop
            // and allow resources to be freed
            //
            if (ElState == STOPPING || ElState == STOPPED)
            {
                ELF_LOG1(TRACE,
                         "ElfpSendMessage: Aborting SendMessage since ElState is %ws\n",
                         (ElState == STOPPING ? L"STOPPING" :
                                                L"STOPPED"));

                FreeLibrary(hLibrary);
                MBThreadHandle = NULL;
                return 0;
            }

            RtlEnterCriticalSection (&QueuedMessageCritSec);

            //
            // Move to the next one, saving this one to delete it
            //
            FlushEvent = QueuedEvent;

            QueuedEvent = CONTAINING_RECORD(QueuedEvent->Next.Flink,
                                            struct _ELF_QUEUED_EVENT,
                                            Next);

            //
            // Now remove this from the queue and free it if we successfully
            // processed it
            //
            RemoveEntryList (&FlushEvent->Next);
        }

        FreeLibrary(hLibrary);
    }
    else
    {
        //
        // We couldn't load the message DLL -- leave the queued event
        // on the list and try it the next time this thread spins up.
        //
        ELF_LOG1(ERROR,
                 "ElfpSendMessage: LoadLibraryEx of netmsg.dll failed %d\n",
                 GetLastError());
    }

    MBThreadHandle = NULL;

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection (&QueuedMessageCritSec);

    ELF_LOG0(TRACE, "ElfpSendMessage: MessageBox thread exiting\n");

    return 0;
}


VOID
LinkQueuedMessage (
    PELF_QUEUED_EVENT QueuedEvent
    )

/*++

Routine Description:

    This routine links the QueuedEvent specified into the linked list of
    QueuedMessages.  If there's not already a messagebox thread running,
    it starts one.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    QueuedEvent - The request to add from the linked list

Return Value:

    NONE

Note:


--*/
{
    DWORD ThreadId;

    // Lock the linked list

    RtlEnterCriticalSection(&QueuedMessageCritSec);


    // Place structure at the end of the list.

    InsertTailList(&QueuedMessageListHead, &QueuedEvent->Next);

    if (!MBThreadHandle)
    {
        ELF_LOG0(TRACE,
                 "LinkQueuedMessage: Spinning up a MessageBox thread\n");

        //
        // Since the user can just let this sit on their screen,
        // spin a thread for this
        //
        MBThreadHandle = CreateThread(NULL,               // lpThreadAttributes
                                      0,               // dwStackSize
                                      ElfpSendMessage,    // lpStartAddress
                                      NULL,               // lpParameter
                                      0L,                 // dwCreationFlags
                                      &ThreadId);         // lpThreadId
    }

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&QueuedMessageCritSec);
}



VOID
NotifyChange(
    PLOGFILE pLogFile
    )

/*++

Routine Description:

    This routine runs the list of events that are registered with
    ElfChangeNotify to be notified when a log has changed, and pulses
    the event.

    In order to protect against multiple thread/process access to the
    list at the same time, we use an exclusive resource.

Arguments:

    LogHandle points to a context handle structure.

Return Value:

    NONE

Note:

--*/
{

    //
    // How frequently will I try to pulse the events?  How about every
    // 5 seconds
    //

#define MINIMUM_PULSE_TIME 5

    PNOTIFIEE Notifiee;
    LARGE_INTEGER Time;
    ULONG CurrentTime = 0;
    NTSTATUS Status;

    //
    // Get exclusive access to the log file. This will ensure no one
    // else is accessing the file.
    //

    RtlAcquireResourceExclusive(&pLogFile->Resource,
                                TRUE);                  // Wait until available

    //
    // See if we've done this in the last MINIMUM_PULSE_TIME seconds
    //
    Status = NtQuerySystemTime(&Time);

    if (NT_SUCCESS(Status))
    {
        RtlTimeToSecondsSince1970(&Time, &CurrentTime);

        if (CurrentTime > pLogFile->ulLastPulseTime + MINIMUM_PULSE_TIME)
        {
            ELF_LOG1(TRACE,
                     "NotifyChange: Pulsing ChangeNotify events -- current time is %ul\n",
                     CurrentTime);

            //
            // Remember that we pulsed
            //
            pLogFile->ulLastPulseTime = CurrentTime;

            //
            // Walk the linked list and and pulse any events
            //
            Notifiee = CONTAINING_RECORD(pLogFile->Notifiees.Flink,
                                         struct _NOTIFIEE,
                                         Next);

            while (Notifiee->Next.Flink != pLogFile->Notifiees.Flink)
            {
                //
                // Pulse each event as we get to it.
                //
                NtPulseEvent(Notifiee->Event,NULL);

                Notifiee = CONTAINING_RECORD(Notifiee->Next.Flink,
                                             struct _NOTIFIEE,
                                             Next);
            }
        }
    }
    else
    {
        ELF_LOG1(ERROR,
                 "NotifyChange: NtQuerySystemTime failed %#x\n",
                 Status);
    }

    //
    // Free the resource
    //
    RtlReleaseResource ( &pLogFile->Resource );
}



VOID
WriteQueuedEvents(
    VOID
    )

/*++

Routine Description:

    This routine runs the list of queued events and writes them.

    In order to protect against multiple thread/process access to the
    list at the same time, we use an exclusive resource.

Arguments:

    NONE

Return Value:

    NONE

Note:

--*/
{
    PELF_QUEUED_EVENT QueuedEvent;
    PELF_QUEUED_EVENT FlushEvent;
    BOOLEAN           bFlushEvent;
    LARGE_INTEGER     Time;
    ULONG             CurrentTime = 0;

    static ULONG      LastAlertTried  = 0;
    static BOOLEAN    LastAlertFailed = FALSE;

    // Lock the linked list, you must get the System Log File Resource
    // first, it is the higher level lock

    RtlAcquireResourceExclusive(&ElfModule->LogFile->Resource,
                                TRUE);                  // Wait until available
    RtlAcquireResourceExclusive(&ElfSecModule->LogFile->Resource,
                                TRUE);                  // Wait until available

    RtlEnterCriticalSection(&QueuedEventCritSec);

    //
    // Walk the linked list and process each element
    //
    QueuedEvent = CONTAINING_RECORD(QueuedEventListHead.Flink,
                                    struct _ELF_QUEUED_EVENT,
                                    Next);

    while (QueuedEvent->Next.Flink != QueuedEventListHead.Flink)
    {
        //
        // Default is to flush the event after processing
        //
        bFlushEvent = TRUE;

        // on occasion, an event is writting before the ElfModule is even intialized.  In that
        // case, set the value here.
        
        if(QueuedEvent->Event.Request.Module == NULL)
                QueuedEvent->Event.Request.Module = ElfModule;

        if(QueuedEvent->Event.Request.LogFile == NULL && ElfModule)
                QueuedEvent->Event.Request.LogFile = ElfModule->LogFile;

        //
        // Do the appropriate thing
        //
        if (QueuedEvent->Type == Event)
        {
            PerformWriteRequest(&QueuedEvent->Event.Request);
        }
        else if (QueuedEvent->Type == Alert)
        {
            //
            // Don't even try to send failed alerts quicker than once a minute
            //
            NtQuerySystemTime(&Time);
            RtlTimeToSecondsSince1970(&Time, &CurrentTime);

            if (!LastAlertFailed || CurrentTime > LastAlertTried + 60)
            {
                ELF_LOG1(TRACE,
                         "WriteQueuedEvents: Sending alert -- current time is %ul\n",
                         CurrentTime);

                LastAlertFailed = 
                    
                    !SendAdminAlert(QueuedEvent->Event.Alert.MessageId,
                                    QueuedEvent->Event.Alert.NumberOfStrings,
                                    (PUNICODE_STRING) ((PBYTE) QueuedEvent
                                                          + FIELD_OFFSET(ELF_QUEUED_EVENT, Event)
                                                          + sizeof(ELF_ALERT_RECORD)));

                LastAlertTried = CurrentTime;
            }

            //
            // Only try to write it for 5 minutes, then give up (the
            // alerter service may not be configured to run)
            //
            if (LastAlertFailed
                 &&
                QueuedEvent->Event.Alert.TimeOut > CurrentTime)
            {
                ELF_LOG1(TRACE,
                         "WriteQueuedEvents: Alert failed -- will retry until timeout at %ul\n",
                         QueuedEvent->Event.Alert.TimeOut);

                bFlushEvent = FALSE;
            }
        }

        //
        // Move to the next one, saving this one to delete it
        //
        FlushEvent = QueuedEvent;

        QueuedEvent = CONTAINING_RECORD(QueuedEvent->Next.Flink,
                                        struct _ELF_QUEUED_EVENT,
                                        Next);

        //
        // Now remove this from the queue and free it if we successfully
        // processed it
        //
        if (bFlushEvent)
        {
            UnlinkQueuedEvent(FlushEvent);
            ElfpFreeBuffer(FlushEvent);
        }
    }

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&QueuedEventCritSec);
    RtlReleaseResource(&ElfSecModule->LogFile->Resource);
    RtlReleaseResource(&ElfModule->LogFile->Resource);
}



VOID
FlushQueuedEvents(
    VOID
    )

/*++

Routine Description:

    This routine runs the list of queued events and frees them.

    In order to protect against multiple thread/process access to the
    list at the same time, we use an exclusive resource.

Arguments:

    NONE

Return Value:

    NONE

Note:

--*/
{

    PELF_QUEUED_EVENT QueuedEvent;
    PELF_QUEUED_EVENT FlushEvent;

    // Lock the linked list

    RtlEnterCriticalSection(&QueuedEventCritSec);

    //
    // Walk the linked list and and free the memory for any events
    //
    QueuedEvent = CONTAINING_RECORD(QueuedEventListHead.Flink,
                                    struct _ELF_QUEUED_EVENT,
                                    Next);

    while (QueuedEvent->Next.Flink != QueuedEventListHead.Flink)
    {
        //
        // Free each event as we get to it.
        //
        FlushEvent = QueuedEvent;

        QueuedEvent = CONTAINING_RECORD(QueuedEvent->Next.Flink,
                                        struct _ELF_QUEUED_EVENT,
                                        Next);

        ElfpFreeBuffer(FlushEvent);
    }

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&QueuedEventCritSec);
}



VOID
UnlinkLogModule(
    PLOGMODULE LogModule
    )

/*++

Routine Description:

    This routine unlinks the LogModule specified from the linked list.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    LogModule points to a context handle structure.

Return Value:

    NONE

Note:


--*/
{
    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogModuleCritSec);

    //
    // Remove this entry
    //
    RemoveEntryList(&LogModule->ModuleList);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogModuleCritSec);
}



VOID
LinkLogModule (
    PLOGMODULE    LogModule,
    ANSI_STRING * pModuleNameA
    )

/*++

Routine Description:

    This routine links the LogModule specified into the linked list.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    LogModule points to a context handle structure.
    ANSI LogModule name.

Return Value:

    NONE

Note:


--*/
{
    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogModuleCritSec);

    //
    // Add the atom for this module.
    //
    LogModule->ModuleAtom = AddAtomA(pModuleNameA->Buffer);

    //
    // Place structure at the beginning of the list.
    //
    InsertHeadList(&LogModuleHead, &LogModule->ModuleList);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogModuleCritSec);
}


VOID
UnlinkLogFile(
    PLOGFILE pLogFile
    )

/*++

Routine Description:

    This routine unlinks the LogFile structure specified from the linked
    list of log files;
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    pLogFile points to a log file structure.

Return Value:

    NONE

Note:


--*/
{
    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogFileCritSec);

    //
    // Remove this entry
    //
    RemoveEntryList(&pLogFile->FileList);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogFileCritSec);
}



VOID
LinkLogFile (
    PLOGFILE   pLogFile
    )

/*++

Routine Description:

    This routine links the LogFile specified into the linked list of
    log files.
    In order to protect against multiple thread/process access to the
    list at the same time, we use a critical section.

Arguments:

    pLogFile points to a context handle structure.

Return Value:

    NONE

Note:


--*/
{
    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogFileCritSec);

    //
    // Place structure at the beginning of the list.
    //
    InsertHeadList(&LogFilesHead, &pLogFile->FileList);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogFileCritSec);
}



VOID
GetGlobalResource (
    DWORD Type
    )

/*++

Routine Description:

    This routine takes the global resource either for shared access or
    exclusive access depending on the value of Type. It waits forever for
    the resource to become available.

Arguments:

    Type is one of ELF_GLOBAL_SHARED or ELF_GLOBAL_EXCLUSIVE.

Return Value:

    NONE

Note:


--*/
{
    BOOL    Acquired;

    if (Type & ELF_GLOBAL_SHARED)
    {
        Acquired = RtlAcquireResourceShared(&GlobalElfResource,
                                            TRUE);              // Wait forever
    }
    else
    {
        //
        // Assume EXCLUSIVE
        //
        Acquired = RtlAcquireResourceExclusive(&GlobalElfResource,
                                               TRUE);           // Wait forever
    }
 
    ASSERT(Acquired);      // This must always be TRUE.
}


VOID
ReleaseGlobalResource(
    VOID
    )

/*++

Routine Description:

    This routine releases the global resource.

Arguments:

    NONE

Return Value:

    NONE

Note:


--*/
{
    RtlReleaseResource(&GlobalElfResource);
}


VOID
InvalidateContextHandlesForLogFile(
    PLOGFILE    pLogFile
    )

/*++

Routine Description:

    This routine walks through the context handles and marks the ones
    that point to the LogFile passed in as "invalid for read".

Arguments:

    Pointer to log file structure.

Return Value:

    NONE.

Note:


--*/
{
    IELF_HANDLE LogHandle;
    PLOGMODULE  pLogModule;

    //
    // Lock the context handle list
    //
    RtlEnterCriticalSection(&LogHandleCritSec);

    //
    // Walk the linked list and mark any matching context handles as
    // invalid.
    //
    LogHandle = CONTAINING_RECORD(LogHandleListHead.Flink,
                                  struct _IELF_HANDLE,
                                  Next);


    while (LogHandle->Next.Flink != LogHandleListHead.Flink)
    {
        pLogModule = FindModuleStrucFromAtom(LogHandle->Atom);

        ASSERT(pLogModule);

        if (pLogModule && (pLogFile == pLogModule->LogFile))
        {
            LogHandle->Flags |= ELF_LOG_HANDLE_INVALID_FOR_READ;
        }

        LogHandle = CONTAINING_RECORD(LogHandle->Next.Flink,
                                      struct _IELF_HANDLE,
                                      Next);
    }

    //
    // Unlock the context handle list
    //
    RtlLeaveCriticalSection(&LogHandleCritSec);
}



VOID
FixContextHandlesForRecord(
    DWORD RecordOffset,
    DWORD NewRecordOffset,
    PLOGFILE pLogFile
    )

/*++

Routine Description:

    This routine makes sure that the record starting at RecordOffset isn't
    the current record for any open handle.  If it is, the handle is adjusted
    to point to the next record.

Arguments:

    RecordOffset - The byte offset in the log of the record that is about
                   to be overwritten.
    NewStartingRecord - The new location to point the handle to (this is the
                        new first record)

Return Value:

    NONE.

Note:


--*/
{
    IELF_HANDLE LogHandle;
    PLOGMODULE          Module;

    //
    // Lock the context handle list
    //
    RtlEnterCriticalSection(&LogHandleCritSec);

    //
    // Walk the linked list and fix any matching context handles
    //
    LogHandle = CONTAINING_RECORD(LogHandleListHead.Flink,
                                  struct _IELF_HANDLE,
                                  Next);

    while (LogHandle->Next.Flink != LogHandleListHead.Flink)
    {
        if (LogHandle->SeekBytePos == RecordOffset)
        {
            Module = FindModuleStrucFromAtom (LogHandle->Atom);
            if(Module && Module->LogFile == pLogFile)
            {
                LogHandle->SeekBytePos = NewRecordOffset;
            }
        }

        LogHandle = CONTAINING_RECORD(LogHandle->Next.Flink,
                                      struct _IELF_HANDLE,
                                      Next);
    }

    //
    // Unlock the context handle list
    //
    RtlLeaveCriticalSection(&LogHandleCritSec);
}


PLOGFILE
FindLogFileFromName(
    PUNICODE_STRING pFileName
    )

/*++

Routine Description:

    This routine looks at all the log files to find one that matches
    the name passed in.

Arguments:

    Pointer to name of file.

Return Value:

    Matching LOGFILE structure if file in use.

Note:


--*/
{
    PLOGFILE pLogFile;

    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogFileCritSec);

    pLogFile = CONTAINING_RECORD(LogFilesHead.Flink,
                                 LOGFILE,
                                 FileList);

    while (pLogFile->FileList.Flink != LogFilesHead.Flink)
    {
        //
        // BUGBUG: This should probably be _wcsicmp() since the log module
        //         names are assumed to be case insensitive (so the log
        //         file names should be as well else we can get weirdness
        //         with overlapping module names if somebody creates a log
        //         named something like "application" or "system")
        //
        if (wcscmp(pLogFile->LogFileName->Buffer, pFileName->Buffer) == 0)
            break;

        pLogFile = CONTAINING_RECORD(pLogFile->FileList.Flink,
                                     LOGFILE,
                                     FileList);
    }

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogFileCritSec);

    return (pLogFile->FileList.Flink == LogFilesHead.Flink ? NULL : pLogFile);
}

PLOGFILE
FindLogFileByModName(
    LPWSTR pwsLogDefModName)
/*++

Routine Description:

    This routine looks at all the log files to find one that has the
    same default module name

Arguments:

    Pointer to name of file.

Return Value:

    Matching LOGFILE structure if file in use.

Note:


--*/
{
    PLOGFILE pLogFile;

    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogFileCritSec);

    pLogFile = CONTAINING_RECORD(LogFilesHead.Flink,
                                 LOGFILE,
                                 FileList);

    while (pLogFile->FileList.Flink != LogFilesHead.Flink)
    {
        if (_wcsicmp(pLogFile->LogModuleName->Buffer, pwsLogDefModName) == 0)
            break;

        pLogFile = CONTAINING_RECORD(pLogFile->FileList.Flink,
                                     LOGFILE,
                                     FileList);
    }

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogFileCritSec);

    return (pLogFile->FileList.Flink == LogFilesHead.Flink ? NULL : pLogFile);
}


#define ELF_MODULE_NAME   L"EventLog"
#define ELFSEC_MODULE_NAME   L"SECURITY"
    
VOID
ElfpCreateElfEvent(
    IN ULONG  EventId,
    IN USHORT EventType,
    IN USHORT EventCategory,
    IN USHORT NumStrings,
    IN LPWSTR * Strings,
    IN LPVOID Data,
    IN ULONG  DataSize,
    IN USHORT Flags,
    IN BOOL ForSecurity
    )

/*++

Routine Description:

    This creates an request packet to write an event on behalf of the event
    log service itself.  It then queues this packet to a linked list for
    writing later.

Arguments:

    The fields to use to create the event record


Return Value:

    None

Note:


--*/
{
    PELF_QUEUED_EVENT QueuedEvent;
    PWRITE_PKT WritePkt;
    PEVENTLOGRECORD EventLogRecord;
    PBYTE BinaryData;
    ULONG RecordLength;
    ULONG StringOffset, DataOffset;
    USHORT StringsSize = 0;
    USHORT i;
    ULONG PadSize;
    ULONG ModuleNameLen; // Length in bytes
    ULONG zero = 0;      // For pad bytes
    LARGE_INTEGER    Time;
    ULONG LogTimeWritten;
    PWSTR ReplaceStrings;
    WCHAR LocalComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    ULONG  ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    BOOL bOK;
    LPWSTR pwcModule;
    LPWSTR pwFirstString;

    if(ForSecurity)
        pwcModule = ELFSEC_MODULE_NAME;
    else
        pwcModule = ELF_MODULE_NAME;

	// Get the computer name

	bOK = GetComputerNameW(LocalComputerName, &ComputerNameLength);
	if(bOK == FALSE)
	{
    	ELF_LOG1(ERROR,
             "ElfpCreateElfEvent: failed calling GetComputerNameW, last error 0x%x\n",
              GetLastError());
        return;    
	}
    ComputerNameLength = (ComputerNameLength+1)*sizeof(WCHAR);


    ELF_LOG1(TRACE,
             "ElfpCreateElfEvent: Logging event ID %d\n",
             EventId);

    //
    // LogTimeWritten
    // We need to generate a time when the log is written. This
    // gets written in the log so that we can use it to test the
    // retention period when wrapping the file.
    //
    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(&Time,
                              &LogTimeWritten);

    //
    // Figure out how big a buffer to allocate
    //
    ModuleNameLen = (wcslen(pwcModule) + 1) * sizeof (WCHAR);

    ELF_LOG1(TRACE,
             "ElfpCreateElfEvent: Length of module name is %d\n",
             ModuleNameLen);

    StringOffset = sizeof(EVENTLOGRECORD)
                     + ModuleNameLen
                     + ComputerNameLength;

    //
    // Calculate the length of strings so that we can see how
    // much space is needed for that.
    //
    for (i = 0; i < NumStrings; i++)
    {
        StringsSize += wcslen(Strings[i]) + 1;

        ELF_LOG2(TRACE,
                 "ElfpCreateElfEvent: Length of string %d (including NULL) is %d\n",
                 i,
                 wcslen(Strings[i]) + 1);
    }

    //
    // DATA OFFSET:
    //
    DataOffset = StringOffset + StringsSize * sizeof(WCHAR);

    //
    // Determine how big a buffer is needed for the queued event record.
    //
    RecordLength = sizeof(ELF_QUEUED_EVENT)
                     + sizeof(WRITE_PKT)
                     + DataOffset
                     + DataSize
                     + sizeof(RecordLength); // Size excluding pad bytes

    ELF_LOG1(TRACE,
             "ElfpCreateElfEvent: RecordLength (no pad bytes) is %d\n",
             RecordLength);

    //
    // Determine how many pad bytes are needed to align to a DWORD
    // boundary.
    //
    PadSize = sizeof(ULONG) - (RecordLength % sizeof(ULONG));

    RecordLength += PadSize;    // True size needed

    ELF_LOG2(TRACE,
             "ElfpCreateElfEvent: RecordLength (with %d pad bytes) is %d\n",
             PadSize,
             RecordLength);

    //
    // Allocate the buffer for the Eventlog record
    //
    QueuedEvent = (PELF_QUEUED_EVENT) ElfpAllocateBuffer(RecordLength);

    WritePkt = (PWRITE_PKT) (QueuedEvent + 1);

    if (QueuedEvent != NULL)
    {
        //
        // Fill up the event record
        //
        RecordLength  -= (sizeof(ELF_QUEUED_EVENT) + sizeof(WRITE_PKT));
        EventLogRecord = (PEVENTLOGRECORD) (WritePkt + 1);

        EventLogRecord->Length              = RecordLength;
        EventLogRecord->TimeGenerated       = LogTimeWritten;
        EventLogRecord->Reserved            = ELF_LOG_FILE_SIGNATURE;
        EventLogRecord->TimeWritten         = LogTimeWritten;
        EventLogRecord->EventID             = EventId;
        EventLogRecord->EventType           = EventType;
        EventLogRecord->EventCategory       = EventCategory;
        EventLogRecord->ReservedFlags       = 0;
        EventLogRecord->ClosingRecordNumber = 0;
        EventLogRecord->NumStrings          = NumStrings;
        EventLogRecord->StringOffset        = StringOffset;
        EventLogRecord->DataLength          = DataSize;
        EventLogRecord->DataOffset          = DataOffset;
        EventLogRecord->UserSidLength       = 0;
        EventLogRecord->UserSidOffset       = StringOffset;

        //
        // Fill in the variable-length fields
        //

        //
        // STRINGS
        //
        ReplaceStrings = (PWSTR) ((PBYTE) EventLogRecord
                                       + StringOffset);
        pwFirstString = ReplaceStrings;
        
        for (i = 0; i < NumStrings; i++)
        {
            ELF_LOG2(TRACE,
                     "ElfpCreateElfEvent: Copying string %d (%ws) into record\n",
                     i,
                     Strings[i]);

            StringCchCopyW(ReplaceStrings, StringsSize - (ReplaceStrings - pwFirstString), Strings[i]);
            ReplaceStrings += wcslen(Strings[i]) + 1;
        }

        //
        // MODULENAME
        //
        BinaryData = (PBYTE) EventLogRecord + sizeof(EVENTLOGRECORD);

        RtlCopyMemory(BinaryData,
                      pwcModule,
                      ModuleNameLen);

        //
        // COMPUTERNAME
        //
        BinaryData += ModuleNameLen; // Now point to computername

        RtlCopyMemory(BinaryData,
                      LocalComputerName,
                      ComputerNameLength);

        //
        // BINARY DATA
        //
        BinaryData = (PBYTE) ((PBYTE) EventLogRecord + DataOffset);
        RtlCopyMemory(BinaryData, Data, DataSize);

        //
        // PAD  - Fill with zeros
        //
        BinaryData += DataSize;
        RtlCopyMemory(BinaryData, &zero, PadSize);

        //
        // LENGTH at end of record
        //
        BinaryData += PadSize;  // Point after pad bytes
        ((PULONG) BinaryData)[0] = RecordLength;

        //
        // Build the QueuedEvent Packet
        //
        QueuedEvent->Type = Event;

        QueuedEvent->Event.Request.Pkt.WritePkt           = WritePkt;
        if(ForSecurity)
        {
            QueuedEvent->Event.Request.Module                 = ElfSecModule;
            QueuedEvent->Event.Request.LogFile                = ElfSecModule->LogFile;
        }
        else
        {
            if(ElfModule)
            {
                QueuedEvent->Event.Request.Module                 = ElfModule;
                QueuedEvent->Event.Request.LogFile                = ElfModule->LogFile;
            }
            else
            {
                QueuedEvent->Event.Request.Module                 = NULL;
                QueuedEvent->Event.Request.LogFile                = NULL;
            }
        }
        QueuedEvent->Event.Request.Flags                  = Flags;
        QueuedEvent->Event.Request.Command                = ELF_COMMAND_WRITE;
        QueuedEvent->Event.Request.Pkt.WritePkt->Buffer   = EventLogRecord;
        QueuedEvent->Event.Request.Pkt.WritePkt->Datasize = RecordLength;

        //
        // Now Queue it on the linked list
        //
        LinkQueuedEvent(QueuedEvent);
    }
    else
    {
        ELF_LOG0(ERROR,
                 "ElfpCreateElfEvent: Unable to allocate memory for QueuedEvent\n");
    }
}


VOID
ElfpCreateQueuedAlert(
    DWORD MessageId,
    DWORD NumberOfStrings,
    LPWSTR Strings[]
    )
{
    DWORD i;
    DWORD RecordLength;
    PELF_QUEUED_EVENT QueuedEvent;
    PUNICODE_STRING UnicodeStrings;
    LPWSTR pString;
    PBYTE ptr;
    LARGE_INTEGER Time;
    ULONG CurrentTime;

    ELF_LOG1(TRACE,
             "ElfpCreateQueuedAlert: Creating alert for message ID %d\n",
             MessageId);

    //
    // Turn the input strings into UNICODE_STRINGS and figure out how
    // big to make the buffer to allocate
    //
    RecordLength   = sizeof(UNICODE_STRING) * NumberOfStrings;
    UnicodeStrings = ElfpAllocateBuffer(RecordLength);

    if (!UnicodeStrings)
    {
        ELF_LOG0(TRACE,
                 "ElfpCreateQueuedAlert: Unable to allocate memory for UnicodeStrings\n");

        return;
    }

    RecordLength += FIELD_OFFSET(ELF_QUEUED_EVENT, Event) + 
                        sizeof(ELF_ALERT_RECORD);

    for (i = 0; i < NumberOfStrings; i++)
    {
        RtlInitUnicodeString(&UnicodeStrings[i], Strings[i]);
        RecordLength += UnicodeStrings[i].MaximumLength;

        ELF_LOG2(TRACE,
                 "ElfpCreateQueuedAlert: Length of string %d is %d\n",
                 i,
                 UnicodeStrings[i].MaximumLength);
    }

    //
    // Now allocate what will be the real queued event
    //

    QueuedEvent = ElfpAllocateBuffer(RecordLength);

    if (!QueuedEvent)
    {
        ELF_LOG0(ERROR,
                 "ElfpCreateQueuedAlert: Unable to allocate memory for QueuedEvent\n");

        ElfpFreeBuffer(UnicodeStrings);
        return;
    }

    QueuedEvent->Type = Alert;

    QueuedEvent->Event.Alert.MessageId       = MessageId;
    QueuedEvent->Event.Alert.NumberOfStrings = NumberOfStrings;

    //
    // If we can't send the alert in 5 minutes, give up
    //
    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(&Time, &CurrentTime);

    QueuedEvent->Event.Alert.TimeOut = CurrentTime + 300;

    //
    // Move the array of UNICODE_STRINGS into the queued event and
    // point UnicodeStrings at it.  Then fix up the Buffer pointers.
    //
    ptr = (PBYTE) QueuedEvent
               + FIELD_OFFSET(ELF_QUEUED_EVENT, Event)
               + sizeof(ELF_ALERT_RECORD);

    RtlCopyMemory(ptr,
                  UnicodeStrings,
                  sizeof(UNICODE_STRING) * NumberOfStrings);

    ElfpFreeBuffer(UnicodeStrings);
    UnicodeStrings = (PUNICODE_STRING) ptr;

    pString = (LPWSTR) (ptr + sizeof(UNICODE_STRING) * NumberOfStrings);

    for (i = 0; i < NumberOfStrings; i++)
    {
        ELF_LOG3(TRACE,
                 "ElfpCreateQueuedAlert: Copying string %d (%*ws) into QueuedEvent record\n",
                 i,
                 UnicodeStrings[i].MaximumLength / sizeof(WCHAR),
                 UnicodeStrings[i].Buffer);

        RtlCopyMemory(pString,
                      UnicodeStrings[i].Buffer,
                      UnicodeStrings[i].MaximumLength);

        UnicodeStrings[i].Buffer = pString;

        pString = (LPWSTR) ((PBYTE) pString + UnicodeStrings[i].MaximumLength);
    }

    LinkQueuedEvent(QueuedEvent);
}



VOID
ElfpCreateQueuedMessage(
    DWORD MessageId,
    DWORD NumberOfStrings,
    LPWSTR Strings[]
    )
{
    DWORD i;
    DWORD RecordLength = 0;
    PELF_QUEUED_EVENT QueuedEvent;
    LPWSTR pString;
    DWORD StringsSize = 0;
    LPWSTR pwFirstString;

    ELF_LOG1(TRACE,
             "ElfpCreateQueuedMessage: Creating message for message ID %d\n",
             MessageId);

    //
    // Figure out how big to make the buffer to allocate
    //
    RecordLength = sizeof(ELF_QUEUED_EVENT);

    for (i = 0; i < NumberOfStrings; i++)
    {
        StringsSize += (wcslen(Strings[i]) + 1) * sizeof(WCHAR);

        ELF_LOG2(TRACE,
                 "ElfpCreateQueuedMessage: Length of string %d (including NULL) is %d\n",
                 i,
                 wcslen(Strings[i]) + 1);
    }
    RecordLength += StringsSize;

    //
    // Now allocate what will be the real queued event
    //
    QueuedEvent = ElfpAllocateBuffer(RecordLength);

    if (!QueuedEvent)
    {
        ELF_LOG0(ERROR,
                 "ElfpCreateQueuedMessage: Unable to allocate memory for QueuedEvent\n");

        return;
    }

    QueuedEvent->Type = Message;

    QueuedEvent->Event.Message.MessageId       = MessageId;
    QueuedEvent->Event.Message.NumberOfStrings = NumberOfStrings;

    //
    // Move the array of UNICODE strings into the queued event
    //

    pString = (LPWSTR) ((PBYTE) QueuedEvent
                             + FIELD_OFFSET(ELF_QUEUED_EVENT, Event)
                             + sizeof(ELF_MESSAGE_RECORD));

    pwFirstString = pString;
    for (i = 0; i < NumberOfStrings; i++)
    {
        StringCchCopyW(pString, StringsSize - (pString - pwFirstString) ,Strings[i]);
        pString += wcslen(Strings[i]) + 1;

        ELF_LOG2(TRACE,
                 "ElfpCreateQueuedMessage: Copying string %d (%ws) into QueuedEvent buffer\n",
                 i,
                 Strings[i]);
    }

    LinkQueuedMessage(QueuedEvent);
}


NTSTATUS
ElfpInitCriticalSection(
    PRTL_CRITICAL_SECTION  pCritsec
    )
{
    NTSTATUS  ntStatus;

    //
    // RtlInitializeCriticalSection will raise an exception
    // if it runs out of resources
    //

    try
    {
        ntStatus = RtlInitializeCriticalSection(pCritsec);

        if (!NT_SUCCESS(ntStatus))
        {
            ELF_LOG1(ERROR,
                     "ElfpInitCriticalSection: RtlInitializeCriticalSection failed %#x\n",
                     ntStatus);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG1(ERROR,
                 "ElfpInitCriticalSection: Exception %#x caught initializing critsec\n",
                 GetExceptionCode());

        ntStatus = STATUS_NO_MEMORY;
    }

    return ntStatus;
}


NTSTATUS
ElfpInitResource(
    PRTL_RESOURCE  pResource
    )
{
    NTSTATUS  ntStatus = STATUS_SUCCESS;

    //
    // RtlInitializeResource will raise an exception
    // if it runs out of resources
    //

    try
    {
        RtlInitializeResource(pResource);
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG1(ERROR,
                 "ElfpInitResource: Exception %#x caught initializing resource\n",
                 GetExceptionCode());

        ntStatus = STATUS_NO_MEMORY;
    }

    return ntStatus;
}

DWORD EstimateEventSize(
    DWORD dwStringEst, 
    DWORD dwDataEst,
    LPWSTR pwsModuleName
    )
/*++

Routine Description:

    This estimates the number of bytes needed to hold an event..

Arguments:

    dwStringEst - Callers estimate of the amount of space to be needed for strings
    dwDataEst - Callers estimate of the amount of space to be needed for data
    ModuleName - Module name


Return Value:

    Estimated size

Note:


--*/
{
    WCHAR LocalComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    BOOL bOK;
    ULONG  ComputerNameLength = MAX_COMPUTERNAME_LENGTH + 1;
    DWORD dwPadSize;
    DWORD dwSize = 0;
    static long lNameSize = 0;
    dwSize += sizeof(EVENTLOGRECORD);
    if(pwsModuleName)
    {
        dwSize += sizeof(WCHAR) * (wcslen(pwsModuleName) + 1);
    }

    if(lNameSize == 0)
    {
        bOK = GetComputerNameW(LocalComputerName, &ComputerNameLength);
        if(bOK)
            lNameSize = sizeof(WCHAR) * (ComputerNameLength + 1);
        else
            lNameSize = sizeof(WCHAR) * (MAX_COMPUTERNAME_LENGTH + 1);
    }

    dwSize += lNameSize;
    ALIGN_UP_64(dwSize, sizeof(PVOID));

    // assume worst case sid.   Max of 15 sub authorities, so size is 1+1+6+15*sizeof(DWORD)

    dwSize += 68;

    dwSize += dwStringEst;
    dwSize += dwDataEst;

    // finally add in the terminating length and padding
    dwSize += sizeof(DWORD);
    dwPadSize = sizeof(DWORD) - (dwSize % sizeof(DWORD));
    dwSize += dwPadSize;
    return dwSize;
    
}


ULONG
GetNoonEventSystemUptime(
    )
/*++

Routine Description:

    This routine called NtQuerySystemInformation to get the system uptime.

Arguments:
    
      NONE
    
Return Value:

    Uptime in seconds.

Note:


--*/
{
    NTSTATUS                        status;
    SYSTEM_TIMEOFDAY_INFORMATION    TimeOfDayInfo;
    ULONG                           ulBootTime;
    ULONG                           ulCurrentTime;
    ULONG                           ulUptime    = 0;

    //
    //  Get system uptime.
    //
    status = NtQuerySystemInformation(  SystemTimeOfDayInformation,
                                        &TimeOfDayInfo,
                                        sizeof(SYSTEM_TIMEOFDAY_INFORMATION),
                                        NULL);
    if ( NT_SUCCESS(status) )
    {
        RtlTimeToSecondsSince1980( &TimeOfDayInfo.CurrentTime, &ulCurrentTime);
        RtlTimeToSecondsSince1980( &TimeOfDayInfo.BootTime, &ulBootTime);

        ulUptime = ulCurrentTime - ulBootTime;
    }

    return ulUptime;
}

ULONG   GetNextNoonEventDelay(
    )
/*++

Routine Description:

    This routine calculate how long the thread need to wait before the next noon.

Arguments:
    
    
Return Value:

    Time in Seconds.

Note:


--*/
{
    SYSTEMTIME  localTime;
    DWORD       dwWaitSecs;

#define NOON_EVENT_HOUR         12

    GetLocalTime( &localTime );
    
    if ( localTime.wHour >= NOON_EVENT_HOUR )
    {
        dwWaitSecs = ( (24 + NOON_EVENT_HOUR) - localTime.wHour - 1) * 60;
    }
    else
    {
        dwWaitSecs = (NOON_EVENT_HOUR - localTime.wHour - 1) * 60;
    }

    dwWaitSecs = (dwWaitSecs + (60 - localTime.wMinute) - 1) * 60 + (60 - localTime.wSecond);

#undef NOON_EVENTHOUR

    ELF_LOG1(TRACE,
             "NextNoonEvent Delay: %d seconds\n",
             dwWaitSecs );

    return dwWaitSecs;
}

ULONG   GetNoonEventTimeStamp(
    )
/*++

Routine Description:

    This routine retrieves the timestamp interval information from the registry.
    It will first check the policy key, if the TimeStampInterval is not set or not
    configured, we will check our private TimeStamp key.

Arguments:

    NONE
    
Return Value:

    time stamp interval in seconds.

Note:


--*/
{
    const WCHAR RELIABILITY_TIMESTAMP[]  = L"TimeStampInterval";
    const WCHAR RELIABILITY_TIMESTAMP_ENABLED[] = L"TimeStampEnabled";

    const ULONG MAX_ALLOWED_TIME_STAMP_INTERVAL = 86400; //24 hours.

    HKEY  hPolicyKey;
    HKEY  hPrivateKey;

    DWORD dwResult          = 0;
    DWORD dwNewInterval     = 0;
    DWORD dwPolicyEnabled   = 0;
    DWORD cbData            = 0;

    //
    //  POLICY
    //
    if ( !(dwResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    REGSTR_PATH_RELIABILITY_POLICY,  
                                    0,
                                    KEY_READ,
                                    &hPolicyKey ) ) )
    {
        //
        //  1. check if the policy is enabled or not. (by accessing key: 
        //      RELIABLITY_TIMESTAMP_ENABLED )
        //  2. if policy is enabled, read the RELIABLITY_TIMESTAMP key
        //      for time stamp interval.
        //  3. if policy is disable, return 0.
        //  4. if policy is not configured, read the private key.
        //
        cbData = sizeof( DWORD );
        if ( !(dwResult = RegQueryValueEx(hPolicyKey,
                                          RELIABILITY_TIMESTAMP_ENABLED,
                                          0,
                                          NULL,
                                          (LPBYTE)&dwPolicyEnabled,
                                          &cbData) ) )
        {
            if ( !dwPolicyEnabled )
            {
                //
                //  Policy is disabled.
                //
                RegCloseKey( hPolicyKey );
                return dwNewInterval;
            }
        
            cbData = sizeof( DWORD );
            dwResult = RegQueryValueEx( hPolicyKey,
                                         RELIABILITY_TIMESTAMP,
                                         0,
                                         NULL,
                                         (LPBYTE)&dwNewInterval,
                                         &cbData );
        
            if ( dwNewInterval > MAX_ALLOWED_TIME_STAMP_INTERVAL )
            {
                dwResult        = ERROR_INVALID_PARAMETER;
                dwNewInterval   = 0;
            }
        }
        else
        {
            //
            //  the key is not there (Policy Not Configured)
            //
        }

        RegCloseKey( hPolicyKey );
    }

    //
    //  PRIVATE KEY
    //
    if ( dwResult && 
         !(dwResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                    REGSTR_PATH_RELIABILITY,  
                                    0,
                                    KEY_READ,
                                    &hPrivateKey ) ) )
    {
        cbData = sizeof( DWORD );

        if ( !RegQueryValueEx( hPrivateKey,
                              REGSTR_VAL_LASTALIVEINTERVAL,
                              0,
                              NULL,
                              (LPBYTE) &dwNewInterval,
                              &cbData ) )
        {
            //
            //  Note: this private interval is in MINUTEs, while the policy
            //  controlled interval is in SECONDS.
            //
            dwNewInterval *= 60;

            if ( dwNewInterval > MAX_ALLOWED_TIME_STAMP_INTERVAL )
                dwNewInterval = 0;
        }

        RegCloseKey( hPrivateKey );
    }

    return dwNewInterval;
}

DWORD 
GetModuleType(LPWSTR pwsModuleName)
{
    if (!_wcsicmp(pwsModuleName, ELF_SYSTEM_MODULE_NAME))
    {
        return ELF_LOGFILE_SYSTEM;
    }
    else if (!_wcsicmp(pwsModuleName, ELF_SECURITY_MODULE_NAME))
    {
        return ELF_LOGFILE_SECURITY;
    }
    else  if (!_wcsicmp(pwsModuleName, ELF_APPLICATION_MODULE_NAME))
    {
        return ELF_LOGFILE_APPLICATION;
    }
    else
    {
        return ELF_LOGFILE_CUSTOM;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\eventlog.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    eventlog.c

Abstract:

    This file contains the main routines for the NT Event Logging Service.

Author:

    Rajen Shah  (rajens)    1-Jul-1991

Revision History:

    02-Mar-01           drbeck
        Modified ElfWriteProductInfoEvent to utilize GetVersionEx for OS major
        and minor version numbers as well as for the build number. The
        value CurrentBuild under the HKLM/SOFTWARE/Microsoft/Windows NT/CurrentVersion 
        registry is obsolete.
        
    26-Jan-1994     Danl
        SetUpModules:  Fixed memory leak where the buffers for the enumerated
        key names were never free'd.  Also fixed problem where the size of
        the MULTI_SZ buffer used for the "Sources" key was calculated by
        using the names in the registry, while the copying was done
        using the names in the module list.  When registry keys are deleted,
        the module list entry is retained until the next boot.  Since the
        module list is larger, it would overwrite the MULTI_SZ buffer.

    1-Nov-1993      Danl
        Make Eventlog service a DLL and attach it to services.exe.
        Pass in GlobalData to Elfmain.  This GlobalData structure contains
        all well-known SIDs and pointers to the Rpc Server (Start & Stop)
        routines.  Get rid of the service process main function.

    1-Jul-1991      RajenS
        created

--*/

//
// INCLUDES
//

#include <eventp.h>
#include <ntrpcp.h>
#include <elfcfg.h>
#include <string.h>
#include <tstr.h>     // WCSSIZE
#include <alertmsg.h> // ALERT_ELF manifests


//
// Bit Flags used for Progress Reporting in SetupDataStruct().
//
#define LOGFILE_OPENED  0x00000001
#define MODULE_LINKED   0x00000002
#define LOGFILE_LINKED  0x00000004

HANDLE  g_hTimestampWorkitem;
HANDLE  g_hNoonEventWorkitem;
HANDLE  g_hTimestampEvent;
ULONG   g_PreviousInterval = DEFAULT_INTERVAL;

ULONG   g_TimeStampEnabled = 0;
#define TIME_STAMP_ENABLED      0x1
#define TIME_STAMP_DISABLED     0x0

long    g_lNumSecurityWriters = 0;

//
//  Noon Event PData Constant and Data Structure
//

#define MAX_OS_INFO_LENGTH              64
#define MAX_HARDWARE_INFO_LENGTH        128
#define NUM_OF_CHAR( x )         (sizeof( x ) / sizeof( *x ))
#define VERSION_ID_SIZE 5
typedef struct _Noon_Event_Data
{
    WCHAR               szVersionId[ VERSION_ID_SIZE ];                           // 1.0 or 1.1 or 1.11
    LONG                lBootMode;
    WCHAR               szOSName[ MAX_OS_INFO_LENGTH ];
    WCHAR               szOSVersion[ MAX_OS_INFO_LENGTH + 128 ];    // + 128 for the szCSDVersion
    WCHAR               szOSBuildType[ MAX_OS_INFO_LENGTH ];
    WCHAR               szOSBuildString[ MAX_OS_INFO_LENGTH ];
    ULONG               ulOriginalInstallDate;
    LPWSTR              szHotFixes;
    WCHAR               szSystemManufacturer[ MAX_HARDWARE_INFO_LENGTH ];
    WCHAR               szSystemModel[ MAX_HARDWARE_INFO_LENGTH ];
    ULONG               ulSystemType;
    ULONG               ulProcessorNum;
    ULONG               ulPhysicalMemory;
    ULONG               ulSystemLangID;
    WCHAR               szFQDN[ MAX_PATH ];
}Noon_Event_Data, * PNoon_Event_Data; 

//
//  if added any new number field to the noon event structure, change this as well.
//
#define TOTAL_NUM_IN_NOON_EVENT         7
#define TOTAL_FIELD_IN_NOON_EVENT       17
#define NUM_OF_CHAR_IN_ULONG            12

//
//  if we couldn't get some of the system information, we will use "UNKONW_STRING"
//  instead. (since the string is in PDATA(binary data), I think we don't need
//  localize it.
//
const   WCHAR           UNKNOWN_STRING[]  =   L"Not Available";

//
//  pData contains all the constant information about the system. (those information
//  won't change until next reboot.) 
//
typedef struct _Noon_Event_Info
{
    LPWSTR              pData;
    DWORD               dwNumOfWChar;
} Noon_Event_Info, *PNoon_Event_Info;

Noon_Event_Info g_NoonEventInfo = {0};

//
// Local Function Prorotypes
//
VOID
ElfInitMessageBoxTitle(
    VOID
    );



NTSTATUS
SetUpDataStruct (
    PUNICODE_STRING     LogFileName,
    ULONG               MaxFileSize,
    ULONG               Retention,
    PUNICODE_STRING     ModuleName,
    HANDLE              hLogFile,
    ELF_LOG_TYPE        LogType,
    LOGPOPUP            logpLogPopup,
    DWORD               dwAutoBackup
)

/*++

Routine Description:

    This routine sets up the information for one module. It is called from
    ElfSetUpConfigDataStructs for each module to be configured.

    Module information is passed into this routine and a LOGMODULE structure
    is created for it.  If the logfile associated with this module doesn't
    exist, a LOGFILE structure is created for it, and added to the linked
    list of LOGFILE structures.  The LOGMODULE is associated with the LOGFILE,
    and it is added to the linked list of LOGMODULE structures.  The logfile
    is opened and mapped to memory.

    Finally, at the end, this function calls SetUpModules, which looks at
    all the subkeys in the registry under this logfile, and adds any new ones
    to the linked list, and updates the Sources MULTI_SZ for the event viewer.

Arguments:

    LogFileName - Name of log file for this module.  If this routine needs
        a copy of this name it will make one, so that the caller can free
        the name afterwards if that is desired.

    MaxFileSize - Max size of the log file.
    Retention   - Max retention for the file.
    ModuleName  - Name of module that this file is associated with.
    RegistryHandle - Handle to the root node for this LogFile's info
                     in the registry.  This is used to enumerate all the
                     modules under this key.

Return Value:

    Pointer to Module structure that is allocated in this routine.
    NTSTATUS

Note:


--*/
{
    NTSTATUS        Status   = STATUS_SUCCESS;
    PLOGFILE        pLogFile = NULL;
    PLOGMODULE      pModule  = NULL;
    ANSI_STRING     ModuleNameA;
    DWORD           Type;
    BOOL            bAllocatedLogInfo   = FALSE;
    PUNICODE_STRING SavedBackupFileName = NULL;
    DWORD           StringLength;
    PLOGMODULE      OldDefaultLogModule = NULL;
    DWORD           Progress = 0L;
    BOOL            bNeedToReleaseResource = FALSE;
    BOOL bNoChange;
    
    //
    // Argument check.
    //

    if ((LogFileName == NULL)         ||
        (LogFileName->Buffer == NULL) ||
        (ModuleName == NULL))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    Status = VerifyUnicodeString(ModuleName);
    if (!NT_SUCCESS(Status))
    {
        return(STATUS_INVALID_PARAMETER);
    }
    

    // If the default log file for a module is also being used by another
    // module, then we just link that same file structure with the other
    // module.
    //
    // Truncate the maximum size of the log file to a 4K boundary.
    // This is to allow for page granularity.
    //

    pModule  = ElfpAllocateBuffer (sizeof (LOGMODULE) );

    if (pModule == NULL)
    {
        return(STATUS_NO_MEMORY);
    }

    RtlEnterCriticalSection(&LogFileCritSec);
    pLogFile = FindLogFileFromName (LogFileName);

    if (pLogFile == NULL)
    {
        //
        //--------------------------------------
        // CREATE A NEW LOGFILE !!
        //--------------------------------------
        // A logfile by this name doesn't exist yet.  So we will create
        // one so that we can add the module to it.
        //

        ELF_LOG1(TRACE,
                "SetupDataStruct: Create new struct for %ws log\n",
                LogFileName->Buffer);

        pLogFile = ElfpAllocateBuffer(sizeof(LOGFILE));

        if (pLogFile == NULL)
        {
            ELF_LOG1(ERROR,
                     "SetupDataStruct: Unable to allocate struct for %ws log\n",
                     LogFileName->Buffer);

            ElfpFreeBuffer(pModule);
            RtlLeaveCriticalSection(&LogFileCritSec);
            return STATUS_NO_MEMORY;
        }

        //
        // Allocate a new LogFileName that can be attached to the
        // new pLogFile structure.
        //
        StringLength = LogFileName->Length + sizeof(WCHAR);
        SavedBackupFileName = (PUNICODE_STRING) ElfpAllocateBuffer(
            sizeof(UNICODE_STRING) + StringLength);

        if (SavedBackupFileName == NULL)
        {
            ELF_LOG1(ERROR,
                     "SetupDataStruct: Unable to allocate backup name for %ws log\n",
                     LogFileName->Buffer);

            ElfpFreeBuffer(pModule);
            ElfpFreeBuffer(pLogFile);
            RtlLeaveCriticalSection(&LogFileCritSec);
            return STATUS_NO_MEMORY;
        }

        SavedBackupFileName->Buffer = (LPWSTR)((LPBYTE) SavedBackupFileName +
            sizeof(UNICODE_STRING));

        SavedBackupFileName->Length = LogFileName->Length;
        SavedBackupFileName->MaximumLength = (USHORT) StringLength;
        RtlMoveMemory(SavedBackupFileName->Buffer, LogFileName->Buffer,
            LogFileName->Length);
        SavedBackupFileName->Buffer[SavedBackupFileName->Length / sizeof(WCHAR)] =
            L'\0';

        //
        // This is the first user - RefCount gets incrememted below
        //
        pLogFile->RefCount          = 0;
        pLogFile->FileHandle        = NULL;
        pLogFile->LogFileName       = SavedBackupFileName;
        pLogFile->ConfigMaxFileSize = ELFFILESIZE(MaxFileSize);
        pLogFile->Retention         = Retention;
        pLogFile->ulLastPulseTime   = 0;
        pLogFile->logpLogPopup      = logpLogPopup;
        pLogFile->bHosedByClear = FALSE;
        pLogFile->LastStatus = 0;
        pLogFile->bFullAlertDone = FALSE;
        pLogFile->AutoBackupLogFiles = 0;
        pLogFile->pwsCurrCustomSD = 0;
        pLogFile->AutoBackupLogFiles = dwAutoBackup;
        pLogFile->ViewSize = 0;
        pLogFile->SectionHandle = NULL;
        pLogFile->bFailedExpansion = FALSE;
        
        //
        // Save away the default module name for this file
        //
        pLogFile->LogModuleName = ElfpAllocateBuffer(
            sizeof(UNICODE_STRING) + ModuleName->MaximumLength);

        //
        // This flag can be set since pLogfile->LogModuleName
        // will be initialized after this point
        //
        bAllocatedLogInfo = TRUE;

        if (pLogFile->LogModuleName == NULL)
        {
            ELF_LOG1(ERROR,
                     "SetupDataStruct: Unable to allocate module name for %ws log\n",
                     LogFileName->Buffer);

            Status = STATUS_NO_MEMORY;
            goto ErrorExit;
        }

        pLogFile->LogModuleName->MaximumLength = ModuleName->MaximumLength;
        pLogFile->LogModuleName->Buffer =
            (LPWSTR)(pLogFile->LogModuleName + 1);
        RtlCopyUnicodeString(pLogFile->LogModuleName, ModuleName);

        InitializeListHead (&pLogFile->Notifiees);

        pLogFile->NextClearMaxFileSize = pLogFile->ConfigMaxFileSize;

        Status = ElfpInitResource(&pLogFile->Resource);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "SetupDataStruct: Unable to init resource for %ws log\n",
                     LogFileName->Buffer);

            goto ErrorExit;
        }

        LinkLogFile ( pLogFile );   // Link it in

        Progress |= LOGFILE_LINKED;

    } // endif (pLogfile == NULL)
    else
    {
        bNeedToReleaseResource = TRUE;
        RtlAcquireResourceExclusive (&pLogFile->Resource,
                                                                      TRUE);                  // Wait until available
    }
    //--------------------------------------
    // ADD THE MODULE TO THE LOG MODULE LIST
    //--------------------------------------
    // Set up the module data structure for the default (which is
    // the same as the logfile keyname).
    //

    pLogFile->RefCount++;
    pModule->LogFile = pLogFile;
    pModule->ModuleName = (LPWSTR) ModuleName->Buffer;

    Status = RtlUnicodeStringToAnsiString (
                    &ModuleNameA,
                    ModuleName,
                    TRUE);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "SetupDataStruct: Unable to convert module name %ws to Ansi %#x\n",
                 ModuleName->Buffer,
                 Status);

        pLogFile->RefCount--;
        goto ErrorExit;
    }

    //
    // Link the new module in.
    //

    LinkLogModule(pModule, &ModuleNameA);

    RtlFreeAnsiString (&ModuleNameA);

    Progress |= MODULE_LINKED;

    //
    // Open up the file and map it to memory.  Impersonate the
    // caller so we can use UNC names
    //

    if (LogType == ElfBackupLog)
    {
        Status = I_RpcMapWin32Status(RpcImpersonateClient(NULL));

        if (NT_SUCCESS(Status))
        {
            Status = VerifyFileIsFile(pLogFile->LogFileName);
            if (!NT_SUCCESS(Status))
            {
                ELF_LOG1(ERROR,
                     "SetupDataStruct: VerifyFileIsFile failed %#x\n",
                     Status);
            }
            else
                Status = ElfOpenLogFile (pLogFile, LogType);
            RpcRevertToSelf();
        }
        else
        {
            ELF_LOG1(ERROR,
                     "SetupDataStruct: RpcImpersonateClient failed %#x\n",
                     Status);
        }
    }
    else
    {
        Status = ElfOpenLogFile (pLogFile, LogType);
    }

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG3(ERROR,
                 "SetupDataStruct: Couldn't open %ws for module %ws %#x\n",
                 LogFileName->Buffer,
                 ModuleName->Buffer,
                 Status);

        if (LogType != ElfBackupLog)
        {
            ElfpCreateQueuedAlert(ALERT_ELF_LogFileNotOpened,
                                  1,
                                  &(ModuleName->Buffer));
        }

        pLogFile->RefCount--;
        goto ErrorExit;
    }

    Progress |= LOGFILE_OPENED;

    //
    // If this is the application module, remember the pointer
    // to use if a module doesn't have an entry in the registry
    //

    if (!_wcsicmp(ModuleName->Buffer, ELF_DEFAULT_MODULE_NAME))
    {
        OldDefaultLogModule = ElfDefaultLogModule;
        ElfDefaultLogModule = pModule;
    }

    //
    // Create the security descriptor for this logfile.  Only
    // the system and security modules are secured against
    // reads and writes by interactive.  Also, make sure we never
    // pop up a "log full" message for the Security log -- this
    // would be a C2 violation.
    //

    Type = GetModuleType(ModuleName->Buffer);

    if (Type == ELF_LOGFILE_SECURITY)
        pLogFile->logpLogPopup = LOGPOPUP_NEVER_SHOW;

    //
    // Create a Security Descriptor for this Logfile
    //   (RtlDeleteSecurityObject() can be used to free
    //    pLogFile->Sd).
    //
    Status = ElfpCreateLogFileObject(pLogFile, Type, hLogFile, TRUE, &bNoChange);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "SetupDataStruct: Unable to create SD for log %ws %#x\n",
                 ModuleName->Buffer,
                 Status);

        //  Dont decrease the ref count here.  The progress has the LOGFILE_OPENED
        //  bit set and so ElfpCloseLogFile will be called which decrements.
        
        goto ErrorExit;
    }

    //
    // Now that we've added the default module name, see if there are any
    // modules configured to log to this file, and if so, create the module
    // structures for them.
    //

    SetUpModules(hLogFile, pLogFile, FALSE);

    if(bNeedToReleaseResource)
        RtlReleaseResource(&pLogFile->Resource);
    RtlLeaveCriticalSection(&LogFileCritSec);
    return STATUS_SUCCESS;

ErrorExit:

    if (Progress & LOGFILE_OPENED)
    {
        ElfpCloseLogFile(pLogFile, ELF_LOG_CLOSE_BACKUP, FALSE);
    }

    if (Progress & MODULE_LINKED)
    {
        UnlinkLogModule(pModule);
        DeleteAtom(pModule->ModuleAtom);
    }

    if (bAllocatedLogInfo)
    {
        if (Progress & LOGFILE_LINKED)
        {
            UnlinkLogFile(pLogFile);
            RtlDeleteResource (&pLogFile->Resource);
            ELF_LOG1(TRACE,
                 "SetupDataStruct: is unlinking log file 0x%x\n",pLogFile);
        }

        ElfpFreeBuffer(pLogFile->LogModuleName);
        ElfpFreeBuffer(SavedBackupFileName);
        ElfpFreeBuffer(pLogFile);
    }

    ElfpFreeBuffer(pModule);

    if (OldDefaultLogModule != NULL)
    {
        ElfDefaultLogModule = OldDefaultLogModule;
    }
    if(bNeedToReleaseResource)
        RtlReleaseResource(&pLogFile->Resource);
    RtlLeaveCriticalSection(&LogFileCritSec);
    return Status;
}


NTSTATUS
SetUpModules(
    HANDLE      hLogFile,
    PLOGFILE    pLogFile,
    BOOLEAN     bAllowDupes
    )
/*++

Routine Description:

    This routine sets up the information for all modules for a logfile.

    The subkeys under a logfile in the eventlog portion of the registry
    are enumerated.  For each unique subkey, a LOGMODULE structure is
    created.  Each new structures is added to a linked list
    of modules for that logfile.

    If there was one or more unique subkeys, meaning the list has changed
    since we last looked, then we go through the entire linked list of
    log modules, and create a MULTI_SZ list of all the modules.  This list
    is stored in the Sources value for that logfile for the event viewer
    to use.

    NOTE:  A module is never un-linked from the linked list of log modules
    even if the registry subkey for it is removed.  This should probably
    be done sometime.  It would make the eventlog more robust.

Arguments:

    hLogFile    - Registry key for the Log File node
    pLogFile    - pointer to the log file structure
    bAllowDupes - If true, it's ok to already have a module with the same
                  name (used when processing change notify of registry)

Return Value:

    NTSTATUS - If unsuccessful, it is not a fatal error.

        Even if this status is unsuccessful, me may have been able
        to store some of the new subkeys in the LogModule list.  Also, we
        may have been able to update the Sources MULTI_SZ list.

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    BYTE        Buffer[ELF_MAX_REG_KEY_INFO_SIZE];
    PKEY_NODE_INFORMATION KeyBuffer = (PKEY_NODE_INFORMATION) Buffer;
    ULONG       ActualSize;
    PWCHAR      SubKeyString;
    UNICODE_STRING NewModule;
    ANSI_STRING ModuleNameA;
    PLOGMODULE  pModule;
    ULONG       Index = 0;
    ATOM        Atom;
    PWCHAR      pList;
    PWCHAR      pListStart;
    DWORD       dwListNumByte = 0;
    DWORD       ListLength = 0;
    DWORD       dwBytes = 0;
    UNICODE_STRING ListName;
    BOOLEAN     ListChanged = FALSE;
    PLIST_ENTRY pListEntry;

    //
    // Create the module structures for all modules under this logfile.  We
    // don't actually need to open the key, since we don't use any information
    // stored there, it's existence is all we care about here.  Any data is
    // used by the Event Viewer (or any viewing app).  If this is used to
    // setup a backup file, hLogFile is NULL since there aren't any other
    // modules to map to this file.
    //

    while (NT_SUCCESS(Status) && hLogFile)
    {
        Status = NtEnumerateKey(hLogFile,
                                Index++,
                                KeyNodeInformation,
                                KeyBuffer,
                                ELF_MAX_REG_KEY_INFO_SIZE,
                                &ActualSize);

        if (NT_SUCCESS(Status))
        {
            //
            // It turns out the Name isn't null terminated, so we need
            // to copy it somewhere and null terminate it before we use it
            //

            SubKeyString = ElfpAllocateBuffer(KeyBuffer->NameLength + sizeof(WCHAR));

            if (!SubKeyString)
            {
                return STATUS_NO_MEMORY;
            }

            memcpy(SubKeyString, KeyBuffer->Name, KeyBuffer->NameLength);
            SubKeyString[KeyBuffer->NameLength / sizeof(WCHAR)] = L'\0' ;

            //
            // Add the atom for this module name
            //

            RtlInitUnicodeString(&NewModule, SubKeyString);

            Status = RtlUnicodeStringToAnsiString (
                            &ModuleNameA,
                            &NewModule,
                            TRUE);

            if (!NT_SUCCESS(Status))
            {
                //
                // We can't continue, so we will leave the modules
                // we've linked so far, and move on in an attempt to
                // create the Sources MULTI_SZ list.
                //
                ELF_LOG1(TRACE,
                         "SetUpModules: Unable to convert name for module %ws\n",
                         SubKeyString);

                ElfpFreeBuffer(SubKeyString);
                break;
            }

            Atom = FindAtomA(ModuleNameA.Buffer);

            //
            // Make sure we've not already added one by this name
            //

            if (FindModuleStrucFromAtom(Atom))
            {
                //
                // We've already encountered a module by this name.  If
                // this is init time, it's a configuration error.  Report
                // it and move on.  If we're processing a change notify
                // from the registry, this is ok (it means we're rescanning
                // an existing Event Source for an existing log).
                //
                if (!bAllowDupes)
                {
                    ELF_LOG1(ERROR,
                             "SetUpModules: Module %ws exists in two log files.\n",
                             SubKeyString);
                }

                RtlFreeAnsiString(&ModuleNameA);
                ElfpFreeBuffer(SubKeyString);
                continue;
            }

            ListChanged = TRUE;

            pModule  = ElfpAllocateBuffer (sizeof (LOGMODULE) );

            if (!pModule)
            {
                ELF_LOG1(ERROR,
                         "SetUpModules: Unable to allocate structure for module %ws\n",
                         SubKeyString);

                RtlFreeAnsiString (&ModuleNameA);
                ElfpFreeBuffer(SubKeyString);
                return(STATUS_NO_MEMORY);
            }

            //
            // Set up a module data structure for this module
            //

            pModule->LogFile = pLogFile;
            pModule->ModuleName = SubKeyString;

            //
            // Link the new module in.
            //

            LinkLogModule(pModule, &ModuleNameA);

            ELF_LOG1(TRACE,
                     "SetUpModules: Module %ws successfully created/linked\n",
                     SubKeyString);

            RtlFreeAnsiString (&ModuleNameA);
        }
    }

    if (Status == STATUS_NO_MORE_ENTRIES)
    {
        //
        // It's not required that there are configured modules for a log
        // file.
        //

        Status = STATUS_SUCCESS;
    }

    //
    // If the list has changed, or if we've been called during init, and not
    // as the result of a changenotify on the registry (bAllowDupes == FALSE)
    // then create the sources key
    //

    if (hLogFile && (ListChanged || !bAllowDupes))
    {
        //
        // Now create a MULTI_SZ entry with all the module names for eventvwr
        //
        // STEP 1: Calculate amount of storage needed by running thru the
        //         module list, finding any module that uses this log file.
        //
        pListEntry = LogModuleHead.Flink;

        while (pListEntry != &LogModuleHead)
        {
            pModule = CONTAINING_RECORD (pListEntry, LOGMODULE, ModuleList);

            if (pModule->LogFile == pLogFile)
            {
                //
                // This one is for the log we're working on, get the
                // size of its name.
                //
                ListLength += WCSSIZE(pModule->ModuleName);

                ELF_LOG2(MODULES,
                         "SetUpModules: Adding module %ws to list for %ws log\n",
                         pModule->ModuleName,
                         pLogFile->LogFileName->Buffer);
            }

            pListEntry = pModule->ModuleList.Flink;
        }

        //
        // STEP 2:  Allocate storage for the MULTI_SZ.
        //
        if(ListLength > 0)
        {
            dwListNumByte = ListLength + sizeof(WCHAR);
            pList = ElfpAllocateBuffer(dwListNumByte);
            pListStart = pList;
            
            //
            // If I can't allocate the list, just press on
            //

            if (pList)
            {
                //
                // STEP 3: Copy all the module names for this logfile into
                //         the MULTI_SZ string.
                //
                SubKeyString = pList; // Save this away

                pListEntry = LogModuleHead.Flink;

                while (pListEntry != &LogModuleHead)
                {
                    pModule = CONTAINING_RECORD(pListEntry,
                                                LOGMODULE,
                                                ModuleList);

                    if (pModule->LogFile == pLogFile)
                    {
                        //
                        // This one is for the log we're working on, put it in the list
                        //

                        dwBytes = dwListNumByte/sizeof(WCHAR) - (pList-pListStart);
                        StringCchCopyW(pList, dwBytes, pModule->ModuleName);
                        pList += wcslen(pModule->ModuleName);
                        pList++;
                    }

                    pListEntry = pModule->ModuleList.Flink;
                }

                *pList = L'\0'; // The terminating NULL

                RtlInitUnicodeString(&ListName, L"Sources");

                Status = NtSetValueKey(hLogFile,
                                       &ListName,
                                       0,
                                       REG_MULTI_SZ,
                                       SubKeyString,
                                       ListLength + sizeof(WCHAR));

                ElfpFreeBuffer(SubKeyString);
            }
            else
            {
                ELF_LOG1(ERROR,
                         "SetUpModules: Unable to allocate list for %ws log\n",
                         pLogFile->LogFileName->Buffer);
            }
        }
    }

    return Status;
}


NTSTATUS
CreateDefaultDataStruct(
    LPWSTR pwsLogFileName,
    LPWSTR pwsDefModuleName,
    LOGPOPUP  logpLogPopup
    )

/*++

Routine Description:

    This routine creates a default module.  This is used in the case where some
    essential log, such a security is not present in the registry.

Arguments:

    pwsLogFileName           Log file name
    pwsDefModuleName         Default module name
    logpLogPopup              What to do when log is full

Return Value:

    Status

Note:

    IF SUCCESSFUL, THE MODULE NAME IS NOT DELETED HERE, BUT IS DELETED WHEN
    THE DATA STRUCT IS RELEASED!!!

--*/
{
    NTSTATUS Status;
    PUNICODE_STRING pModuleName = NULL;
    UNICODE_STRING usUnexpanded, usExpandedName;
    WCHAR wExpandedPath[MAX_PATH+1];
    DWORD NumberOfBytes;
    UNICODE_STRING  NTFormatName;
    NumberOfBytes = sizeof(wExpandedPath);
    NTFormatName.Buffer = NULL;

    if(pwsLogFileName == NULL || pwsDefModuleName == NULL)
        return STATUS_INVALID_PARAMETER;

    // First take the default string, that has environment variables in it,
    // and expand it.
    
    RtlInitUnicodeString(&usUnexpanded, pwsLogFileName);
    usExpandedName.Length = usExpandedName.MaximumLength = (USHORT)NumberOfBytes;
    usExpandedName.Buffer = (LPWSTR) wExpandedPath;

    Status = RtlExpandEnvironmentStrings_U(NULL,
                                                   &usUnexpanded,
                                                   &usExpandedName,
                                                   &NumberOfBytes);
    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "CreateDefaultDataStruct: RtlExpandEnvironmentStrings_U failed, status=0x%x\n",
                 Status);
        return Status;
    }

    // Convert the expanded string into nt file format

        if (!RtlDosPathNameToNtPathName_U(usExpandedName.Buffer,
                                          &NTFormatName,
                                          NULL,
                                          NULL))
        {
            ELF_LOG0(ERROR,
                     "CreateDefaultDataStruct: RtlDosPathNameToNtPathName_U failed\n");
           return STATUS_UNSUCCESSFUL;
        }
    
    pModuleName =  ElfpAllocateBuffer(sizeof(UNICODE_STRING));

    if (pModuleName == NULL)
    {
        RtlFreeHeap(RtlProcessHeap(), 0, NTFormatName.Buffer);
        return STATUS_NO_MEMORY;
    }

    RtlInitUnicodeString(pModuleName,  pwsDefModuleName);

    //
    // On success, don't free pModuleName as the pointer to it
    // is stored away in the LogFile struct
    //
    Status = SetUpDataStruct(&NTFormatName,
                             ELF_DEFAULT_MAX_FILE_SIZE,
                             ELF_DEFAULT_RETENTION_PERIOD,
                             pModuleName,
                             NULL,
                             ElfNormalLog,
                             logpLogPopup, 
                             ELF_DEFAULT_AUTOBACKUP);

    RtlFreeHeap(RtlProcessHeap(), 0, NTFormatName.Buffer);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "CreateDefaultDataStruct: Unable to set up %ws log\n",
                 pwsLogFileName);

        ElfpFreeBuffer(pModuleName);
        pModuleName = NULL;
    }
    return Status;
}

NTSTATUS
ElfSetUpConfigDataStructs(
    VOID
    )

/*++

Routine Description:

    This routine sets up all the necessary data structures for the eventlog
    service.  It enumerates the keys in the Logfiles registry node to
    determine what to setup.

Arguments:

    NONE

Return Value:

    NONE

Note:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    HANDLE hLogFile;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING SubKeyName;
    UNICODE_STRING uTestString;
    LOGPOPUP  logpLogPopup;
    UNICODE_STRING EventlogModuleName;
    UNICODE_STRING EventlogSecModuleName;
    ULONG Index = 0;
    BYTE Buffer[ELF_MAX_REG_KEY_INFO_SIZE];
    PKEY_NODE_INFORMATION KeyBuffer = (PKEY_NODE_INFORMATION) Buffer;
    ULONG ActualSize;
    LOG_FILE_INFO LogFileInfo;
    PWCHAR SubKeyString;
    LPWSTR ModuleName;

    ELF_LOG0(TRACE,
             "ElfSetUpConfigDataStructs: Entering\n");

    //
    // Initialize the Atom table whose size is the maximum number of
    // module structures possible, i.e. ELF_MAX_LOG_MODULES.
    //
    if (!InitAtomTable(ELF_MAX_LOG_MODULES))
    {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Get a handle to the Logfiles subkey.  If it doesn't exist, just use
    // the hard-coded defaults.
    //

    if (hEventLogNode)
    {
        //
        // Loop thru the subkeys under Eventlog and set up each logfile
        //

        while (NT_SUCCESS(Status))
        {
            Status = NtEnumerateKey(hEventLogNode,
                                    Index++,
                                    KeyNodeInformation,
                                    KeyBuffer,
                                    ELF_MAX_REG_KEY_INFO_SIZE,
                                    &ActualSize);

            if (NT_SUCCESS(Status))
            {
                //
                // It turns out the Name isn't null terminated, so we need
                // to copy it somewhere and null terminate it before we use it
                //

                SubKeyString = ElfpAllocateBuffer(KeyBuffer->NameLength + sizeof(WCHAR));

                if (!SubKeyString)
                {
                    return STATUS_NO_MEMORY;
                }

                memcpy(SubKeyString, KeyBuffer->Name, KeyBuffer->NameLength);
                SubKeyString[KeyBuffer->NameLength / sizeof(WCHAR)] = L'\0';

                //
                // Open the node for this logfile and extract the information
                // required by SetupDataStruct, and then call it.
                //

                RtlInitUnicodeString(&SubKeyName, SubKeyString);

                InitializeObjectAttributes(&ObjectAttributes,
                                           &SubKeyName,
                                           OBJ_CASE_INSENSITIVE,
                                           hEventLogNode,
                                           NULL);

                Status = NtOpenKey(&hLogFile,
                                   KEY_READ | KEY_SET_VALUE,
                                   &ObjectAttributes);

                if (!NT_SUCCESS(Status))
                {
                    //
                    // Unclear how this could happen since I just enum'ed
                    // it, but if I can't open it, I just pretend like it
                    // wasn't there to begin with.
                    //
                    ELF_LOG1(TRACE,
                             "ElfSetUpConfigDataStructs: Unable to open key for %ws log\n",
                             SubKeyName);

                    ElfpFreeBuffer(SubKeyString);
                    Status = STATUS_SUCCESS; // so we don't terminate the loop
                    continue;
                }

                //
                // Get the information from the registry.  Note that we have to
                // initialize the "log full" popup policy before doing so since
                // ReadRegistryInfo will compare the value found in the registry
                // (if there is one) to the current value.
                //

                LogFileInfo.logpLogPopup = IS_WORKSTATION() ? LOGPOPUP_NEVER_SHOW :
                                                              LOGPOPUP_CLEARED;

                Status = ReadRegistryInfo(hLogFile,
                                          &SubKeyName,
                                          &LogFileInfo);

                if (NT_SUCCESS(Status))
                {
                    //
                    // Now set up the actual data structures.  Failures are
                    // dealt with in the routine.  Note that the check for
                    // the security log (i.e., for LOGPOPUP_NEVER_SHOW) is
                    // made in SetUpDataStruct
                    //

                    SetUpDataStruct(LogFileInfo.LogFileName,
                                    LogFileInfo.MaxFileSize,
                                    LogFileInfo.Retention,
                                    &SubKeyName,
                                    hLogFile,
                                    ElfNormalLog,
                                    LogFileInfo.logpLogPopup,
                                    LogFileInfo.dwAutoBackup);
                    NtClose(hLogFile);

                }
                else
                {
                    ELF_LOG1(ERROR,
                             "ElfSetUpConfigdataStructs: ReadRegistryInfo failed %#x\n",
                             Status);
                }
            }
        }
    } // if (hEventLogNode)
    else
    {
        logpLogPopup = IS_WORKSTATION() ? LOGPOPUP_NEVER_SHOW :
                                                    LOGPOPUP_CLEARED;
        Status = STATUS_SUCCESS;
    }

    //
    // If we just ran out of keys, that's OK (unless there weren't any at all)
    //
    if (Status == STATUS_NO_MORE_ENTRIES && Index != 1)
    {
        Status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status))
    {
        //
        // Make sure we created the Application log file, since it is the
        // default.  

        if (!ElfDefaultLogModule)
        {
            ELF_LOG0(ERROR,
                     "ElfSetUpConfigDatastructs: No Application module -- creating default\n");

            Status = CreateDefaultDataStruct(
                                ELF_APPLICATION_DEFAULT_LOG_FILE,  
                                ELF_DEFAULT_MODULE_NAME, logpLogPopup);
            if (!NT_SUCCESS(Status))
            {
                ELF_LOG0(ERROR,
                         "ElfSetUpConfigDatastructs: Could not create the application log -- exiting\n");

                return STATUS_EVENTLOG_CANT_START;
            }
        }

        // Make sure we created the Security log file.  

        if (NULL == FindLogFileByModName(ELF_SECURITY_MODULE_NAME))
        {

            ELF_LOG0(ERROR,
                     "ElfSetUpConfigDatastructs: No Security module -- creating default\n");

            Status = CreateDefaultDataStruct(
                                ELF_SECURITY_DEFAULT_LOG_FILE,  
                                ELF_SECURITY_MODULE_NAME, logpLogPopup);
            if (!NT_SUCCESS(Status))
            {
                ELF_LOG0(ERROR,
                         "ElfSetUpConfigDatastructs:  Could not create the security log -- exiting\n");

                return STATUS_EVENTLOG_CANT_START;
            }
        }
        
        // Make sure we created the System log file.  

        if (NULL == FindLogFileByModName(ELF_SYSTEM_MODULE_NAME))
        {
            ELF_LOG0(ERROR,
                     "ElfSetUpConfigDatastructs: No System module -- creating default\n");

            Status = CreateDefaultDataStruct(
                                ELF_SYSTEM_DEFAULT_LOG_FILE,  
                                ELF_SYSTEM_MODULE_NAME, logpLogPopup);
            if (!NT_SUCCESS(Status))
            {
                // not good, but carry on anyway
                
                ELF_LOG0(ERROR,
                         "ElfSetUpConfigDatastructs:  Could not create the system log\n");
            }
        }

        //
        // Now get the Module for the Eventlog service to use.  GetModuleStruc
        // always succeeds, returning the default log if the requested one
        // isn't configured.
        //

        RtlInitUnicodeString(&EventlogModuleName, L"eventlog");
        ElfModule = GetModuleStruc(&EventlogModuleName);
        RtlInitUnicodeString(&EventlogSecModuleName, L"SECURITY");
        ElfSecModule = GetModuleStruc(&EventlogSecModuleName);
    }

    return Status;
}

VOID
ElfWriteNoonEvent(
    TIMESTAMPEVENT  EventType,
    ULONG           ulTimeStampInterval
    )
/*++

Routine Description:

    This routine writes a Noon/Start/Stop event to the event log. The NoonEvent contains the system
    Uptime, TimeStampInterval, TimeZone. information.
    The NoonEvent PData contains system version information, such as: OSVersion, OSBuildType,
    HotFixes, System Manufacturer, System Model, System Type, BIOS Version, BIOS Date, 
    ProcessorNumber, PhysicalMemory Size, LangID and FQDN

Arguments:
    
      EventType             -   type of the Event, could be start/stop/noonEvent
      ulTimeStampInterval   -   interval of the time stamp
                                if interval equals 0, only the version information/PDATA
                                will not write to the event.
    
Return Value:

    NONE

Note:


--*/
{
    TIME_ZONE_INFORMATION           timeZoneInfo;
#define NUM_OF_NOON_EVENT_STRINGS   7

    LPWSTR                          NoonEventStrings[ NUM_OF_NOON_EVENT_STRINGS ];
    LPWSTR                          UptimeString    = NULL;
    LPWSTR                          TimeStampString = NULL;
    LPWSTR                          TimeZoneString  = NULL;
    WCHAR                           NullString[2];
    HRESULT                         hr;
    ULONG                           ulTemp  = 0;

    //
    //  As defined in the spec:
    //  the first 4 string will be empty strings.
    //        5th string will be Uptime.
    //        6th string will be TimeStampInterval in seconds.
    //        7th string will be TimeZone information
    //

    *NullString = 0;
    for ( ulTemp = 0; ulTemp < NUM_OF_NOON_EVENT_STRINGS; ulTemp++ )
        NoonEventStrings[ ulTemp ] = NullString;

    UptimeString    = (LPWSTR)ElfpAllocateBuffer( NUM_OF_CHAR_IN_ULONG * sizeof(WCHAR) );
    TimeStampString = (LPWSTR)ElfpAllocateBuffer( NUM_OF_CHAR_IN_ULONG * sizeof(WCHAR) );
    TimeZoneString  = (LPWSTR)ElfpAllocateBuffer( sizeof( TIME_ZONE_INFORMATION ) );

    if ( !UptimeString || !TimeStampString || !TimeZoneString )
    {
        goto cleanup;
    }

    //
    //  Time Zone
    //
    if ( TIME_ZONE_ID_INVALID != GetTimeZoneInformation( &timeZoneInfo ) )
    {
        hr = StringCchPrintfW(TimeZoneString, sizeof(TIME_ZONE_INFORMATION)/sizeof(WCHAR), 
                    L"%d %s",
                    timeZoneInfo.Bias,
                    timeZoneInfo.StandardName );

        NoonEventStrings[ 6 ] = TimeZoneString;
    }

    //
    //  Get system uptime.
    //

    hr = StringCchPrintfW(UptimeString, NUM_OF_CHAR_IN_ULONG, 
                    L"%d", GetNoonEventSystemUptime());
    NoonEventStrings[ 4 ] = UptimeString;

    hr = StringCchPrintfW(TimeStampString, NUM_OF_CHAR_IN_ULONG, 
                    L"%d", ulTimeStampInterval);
    NoonEventStrings[ 5 ] = TimeStampString;

    ElfpCreateElfEvent(
                    EventType,
                    EVENTLOG_INFORMATION_TYPE,
                    0,                          // EventCategory
                    NUM_OF_NOON_EVENT_STRINGS,  // NumberOfStrings
                    NoonEventStrings,           // Strings
                    ( (ulTimeStampInterval == 0 )? NULL: g_NoonEventInfo.pData),                        // Version Info
                    ( (ulTimeStampInterval == 0 )? 0 : g_NoonEventInfo.dwNumOfWChar * sizeof(WCHAR)),   // Datalength
                    0,                          // flags
                    FALSE);                     // Security file

cleanup:

    ElfpFreeBuffer( UptimeString );
    ElfpFreeBuffer( TimeStampString );
    ElfpFreeBuffer( TimeZoneString );

#undef NUM_OF_NOON_EVENT_STRINGS
    return;
}

VOID
ElfWriteTimeStamp(
    TIMESTAMPEVENT  EventType,
    BOOLEAN         CheckPreviousStamp
    )
/*++

Routine Description:

    This routine writes a time stamp in the form of a systemtime structure
    to the registry which is then used to extract reliability data.

Arguments:

    EventType          - Indicates what type of event we are logging
    CheckPreviousStamp - Whether we should check for the existance of a previous
                         time stamp which indicates a prior system crash.
Return Value:

    NONE

Note:


--*/
{
#define NUM_OF_EVENT_STRINGS    7   
    SYSTEMTIME  stCurrentUTCTime;
    SYSTEMTIME  stPreviousUTCTime;
    SYSTEMTIME  stPreviousLocalTime;
    ULONG       ulUptime = 0;
    DWORD       dwDirtyFlag = 1;

    HKEY        hKey;
    LONG        rc;
    DWORD       ValueSize;
    ULONG       Interval = DEFAULT_INTERVAL;
    ULONG       wchars;
    LPWSTR      DateTimeBuffer[NUM_OF_EVENT_STRINGS];
    WCHAR       NullString[ 1 ];

    rc = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                        REGSTR_PATH_RELIABILITY,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKey,
                        NULL);

    if (rc != ERROR_SUCCESS)
    {
        return;
    }

    if (EventType == EVENT_NormalShutdown)
    {
        //
        // Delete the time stamp registry value, this is how we indicate a clean shutdown
        //
        RegDeleteValue(hKey, REGSTR_VAL_LASTALIVESTAMP);
        RegFlushKey(hKey);
        RegCloseKey(hKey);
        return;
    }

    //
    // Get the current UTC time
    //

    GetSystemTime(&stCurrentUTCTime);

    if (CheckPreviousStamp)
    {
        ValueSize = sizeof(SYSTEMTIME);

        rc = RegQueryValueEx(hKey,
                             REGSTR_VAL_LASTALIVESTAMP,
                             0,
                             NULL,
                             (PUCHAR) &stPreviousUTCTime,
                             &ValueSize);

        //
        // If we can successfully read a systemtime structure it indicates
        // that the previous shutdown was abnormal, i.e. we didn't execute
        // or normal shutdown cleanup code.
        //

        //
        // Format the time and date of the crash time stamp
        // appropriately for the locale and log a #6008 event
        //


        if ((rc == ERROR_SUCCESS) && (ValueSize == sizeof(SYSTEMTIME)))
        {
            SYSTEMTIME  lpData[2];          // Data for the event
            WCHAR       TimeStampString[ NUM_OF_CHAR_IN_ULONG ];
            ULONG       ulIndex = 0;

            //
            //  init the evnet strings.
            //
            *NullString = 0;
            for ( ulIndex = 0; ulIndex < NUM_OF_EVENT_STRINGS; ulIndex ++ )
                DateTimeBuffer[ ulIndex ] = NullString;

            //
            // now let's get the previous uptime.
            //
            ValueSize = sizeof(ULONG);
            if (!RegQueryValueEx(hKey,
                            REGSTR_VAL_LASTALIVEUPTIME,
                            0,
                            NULL,
                            (PUCHAR)&ulUptime,
                            &ValueSize ) )
            {
                StringCchPrintfW(TimeStampString, NUM_OF_CHAR_IN_ULONG, 
                     L"%d", ulUptime);
                DateTimeBuffer[ 4 ] = TimeStampString;
            }
            
            if (!SystemTimeToTzSpecificLocalTime(NULL,
                                                 &stPreviousUTCTime,
                                                 &stPreviousLocalTime))
            {
                //
                // Couldn't convert to the active time zone -- use UTC
                //
                stPreviousLocalTime = stPreviousUTCTime;
            }

            //
            // Write the local time and the UTC time for the "last alive"
            // timestamp since NT4SP5 shipped with only the local time
            // as the event data.  This allows tools that work on NT4SP5
            // to continue working on NT5.
            //
            lpData[0] = stPreviousLocalTime;
            lpData[1] = stPreviousUTCTime;

            wchars = GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                                   0,
                                   &stPreviousLocalTime,
                                   NULL,
                                   NULL,
                                   0);

            DateTimeBuffer[0] = ElfpAllocateBuffer(wchars * sizeof(WCHAR));

            if (DateTimeBuffer[0])
            {
                GetTimeFormat(LOCALE_SYSTEM_DEFAULT,
                              0,
                              &stPreviousLocalTime,
                              NULL,
                              DateTimeBuffer[0],
                              wchars);

                wchars = GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                       0,
                                       &stPreviousLocalTime,
                                       NULL,
                                       NULL,
                                       0);

                DateTimeBuffer[1] = ElfpAllocateBuffer(wchars * sizeof(WCHAR));

                if (DateTimeBuffer[1])
                {
                    GetDateFormat(LOCALE_SYSTEM_DEFAULT,
                                  0,
                                  &stPreviousLocalTime,
                                  NULL,
                                  DateTimeBuffer[1],
                                  wchars);

                    ElfpCreateElfEvent(
                        EVENT_EventlogAbnormalShutdown,
                        EVENTLOG_ERROR_TYPE,
                        0,                        // EventCategory
                        NUM_OF_EVENT_STRINGS,     // NumberOfStrings
                        DateTimeBuffer,           // Strings
                        lpData,                   // "Last alive" times
                        2 * sizeof(SYSTEMTIME),   // Datalength
                        0,                        // flags
                        FALSE);                   // for security file    

                    ElfpFreeBuffer(DateTimeBuffer[1]);
			        RegSetValueEx(hKey,
                     L"DirtyShutDown",
                     0,
                     REG_DWORD,
                     (PUCHAR) &dwDirtyFlag,
                     sizeof(DWORD));
                }

                ElfpFreeBuffer(DateTimeBuffer[0]);

            }
        }
    }

    //
    // Set the current time stamp
    //
    RegSetValueEx(hKey,
                  REGSTR_VAL_LASTALIVESTAMP,
                  0,
                  REG_BINARY,
                  (PUCHAR) &stCurrentUTCTime,
                  sizeof(SYSTEMTIME));

    //
    // Set the current UpTime
    //
    ulUptime = GetNoonEventSystemUptime();
    RegSetValueEx(hKey,
                  REGSTR_VAL_LASTALIVEUPTIME,
                  0,
                  REG_DWORD,
                  (PUCHAR)&ulUptime,
                  sizeof(ULONG));
    
    // Following flush is commented out to avoid a deadlock for VolSnap 702130 
    //RegFlushKey (hKey);
    RegCloseKey (hKey);

#undef NUM_OF_EVENT_STRINGS
}


VOID
ElfWriteProductInfoEvent (
    VOID
    )
/*++

Routine Description:

    This function writes an event #6009 which includes the OS version, build #,
    service pack level, MP/UP, and Free/Checked.

Arguments:

    NONE

Return Value:

    NONE

Note:


--*/

{

#define NUM_INFO_VALUES     4  //EVENT_EventLogProductInfo requires 4 parameters

    DWORD dwNumStrChr = 0;
    NTSTATUS        Status      = STATUS_SUCCESS;
    HKEY            hKey        = NULL;
    ULONG           ValueSize   = 0;
    LPWSTR          NullString  = L"";

    LPWSTR          StringBuffers[NUM_INFO_VALUES] = {NULL, NULL, NULL, NULL};
    
    OSVERSIONINFOEX OsVersion;
    WCHAR           wszTemp[NUM_OF_CHAR_IN_ULONG];
    UINT            i;


    OsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if( !GetVersionEx( (LPOSVERSIONINFO)&OsVersion ) )
    {
        return;
    }
    
    //Allocate storage

    //Buffer 0 holds the version number in the format of 5.xx.

    dwNumStrChr = 2*NUM_OF_CHAR_IN_ULONG + 2;
    StringBuffers[0] = ElfpAllocateBuffer( dwNumStrChr * sizeof(WCHAR) );

    //Buffer 1 holds the build number
    StringBuffers[1] = ElfpAllocateBuffer( (NUM_OF_CHAR_IN_ULONG)  * sizeof(WCHAR) );

    //Buffer 2 holds the service pack
    StringBuffers[2] = ElfpAllocateBuffer( sizeof(OsVersion.szCSDVersion)           );

    if( StringBuffers[0] == NULL || 
        StringBuffers[1] == NULL || 
        StringBuffers[2] == NULL )
    {
        goto ErrorExit;
    }

    //
    //Add major version
    //
    _ltow (
        OsVersion.dwMajorVersion,
        wszTemp,
        10
    );

    StringCchCopyW(StringBuffers[0],  dwNumStrChr, wszTemp);
    StringCchCatW(StringBuffers[0], dwNumStrChr, L"." );
 
    //
    //Add minor version
    //
    _ltow (
        OsVersion.dwMinorVersion,
        wszTemp,
        10
    );

    if( OsVersion.dwMinorVersion < 10 )
    {
        StringCchCatW(StringBuffers[0], dwNumStrChr, L"0" );
    }

    StringCchCatW(StringBuffers[0], dwNumStrChr, wszTemp );
    StringCchCatW(StringBuffers[0], dwNumStrChr, L"."    );

    //
    //Get build number
    //
    _ltow (
        OsVersion.dwBuildNumber,
        wszTemp,
        10
    );

    StringCchCopyW( StringBuffers[1], NUM_OF_CHAR_IN_ULONG, wszTemp );

    //Get service pack info
    StringCchCopyW( StringBuffers[2], sizeof(OsVersion.szCSDVersion)/sizeof(WCHAR),
                                    OsVersion.szCSDVersion );

    //
    // Get OS type (uniprocessor or multiprocessor chk or free)
    // Open HKLM\Software\Microsoft\Windows NT\CurrentVersion
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_NT_CURRENTVERSION,
                     0,
                     KEY_ALL_ACCESS,
                     &hKey)

        != ERROR_SUCCESS)
    {
        goto ErrorExit;
    }

    //
    // For each of the registry values, query for the string size, allocate storage,
    // and query the actual value
    //
    if ((RegQueryValueEx (hKey,
                          REGSTR_VAL_CURRENT_TYPE,
                          0,
                          NULL,
                          NULL,
                          &ValueSize)
         == ERROR_SUCCESS)

         &&

         ValueSize != 0)
    {
        StringBuffers[3] = ElfpAllocateBuffer(ValueSize);

        if (StringBuffers[3] != NULL) 
            {

                RegQueryValueEx(hKey,
                                REGSTR_VAL_CURRENT_TYPE,
                                0,
                                NULL,
                                (PUCHAR) StringBuffers[3],
                                &ValueSize);
    
                ValueSize = 0;
            }
    }
    else
    {
        StringBuffers[3] = NullString;
    }

    ElfpCreateElfEvent(
        EVENT_EventLogProductInfo,
        EVENTLOG_INFORMATION_TYPE,
        0,                            // EventCategory
        NUM_INFO_VALUES,              // NumberOfStrings
        StringBuffers,                // Strings
        NULL,                         // EventData
        0,                            // Datalength
        0,                            // flags
        FALSE);                       // for security file    

    
ErrorExit:

    for (i = 0; i < NUM_INFO_VALUES; i++)
    {
        if (StringBuffers[i] != NULL && StringBuffers[i] != NullString)
        {
            ElfpFreeBuffer(StringBuffers[i]);
        }
    }

    if( hKey != NULL )
    {
        RegCloseKey (hKey);
    }

#undef NUM_INFO_VALUES

}


VOID
TimeStampProc(
    PVOID   Interval,
    BOOLEAN fWaitStatus
    )
{
    NTSTATUS ntStatus;
    HANDLE   hWaitHandle;
    ULONG    ValueSize;
    HKEY     hKey;
    ULONG    NewInterval;
    ULONG    rc;

    //
    // Deregister the wait (note that we must do this even
    // if the WT_EXECUTEONLYONCE flag is set)
    //
    ntStatus = RtlDeregisterWait(g_hTimestampWorkitem);

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "TimeStampProc: RtlDeregister wait failed %#x\n",
                  ntStatus);
    }

    if (fWaitStatus == FALSE)
    {
        //
        // The event log service is stopping
        //
        return;
    }

    //
    // Note:  NewInterval is specified in seconds
    //
    NewInterval = (ULONG)((ULONG_PTR)Interval);

    //
    //  The event timed out -- write a timestamp
    //

    ElfWriteTimeStamp (EVENT_AbNormalShutdown, FALSE);

    //
    // recheck the time stamp interval value
    //
    NewInterval = GetNoonEventTimeStamp();
    
    if ( NewInterval != 0 )
    {
        //
        // Reregister the wait
        //

        ntStatus = RtlRegisterWait(&g_hTimestampWorkitem,
                                   g_hTimestampEvent,
                                   TimeStampProc,           // Callback
                                   (PVOID) UlongToPtr(NewInterval),     // Context
                                   NewInterval * 1000, // Timeout, in ms
                                   WT_EXECUTEONLYONCE);
    }
    
    if (!NT_SUCCESS(ntStatus) || NewInterval == 0 )
    {
        InterlockedExchange(&g_TimeStampEnabled, TIME_STAMP_DISABLED);

        ELF_LOG1(ERROR,
                 "TimeStampProc: RtlRegisterWait failed %#x.\n",
                 ntStatus);

    }
}

VOID
NoonEventProc(
    PVOID   pData,
    BOOLEAN fWaitStatus
    )
{
    NTSTATUS ntStatus;
    HANDLE   hWaitHandle;
    ULONG    NewInterval;
    ULONG    TimeStampInterval;

    //
    // Deregister the wait (note that we must do this even
    // if the WT_EXECUTEONLYONCE flag is set)
    //
    ntStatus = RtlDeregisterWait(g_hNoonEventWorkitem);

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "NoonEventProc: RtlDeregister wait failed %#x\n",
                  ntStatus);
    }

    if (fWaitStatus == FALSE)
    {
        //
        // The event log service is stopping
        //
        return;
    }

    //
    // Note:  NewInterval is specified in SECONDS
    //
    NewInterval = GetNextNoonEventDelay();

    //
    //  The event timed out -- write a timestamp
    //
    TimeStampInterval = GetNoonEventTimeStamp();

    //
    //  Note: as we noticed RtlRegisterWait could timeout before timeout value
    //        we specified, so we will only create an event when the NewInterval
    //        value is greater than a certain value. (We don't want two events
    //        shown up in a short time period. (filter out any early timeouts,
    //        if next noon is within 12 hour range, we will not write the noon
    //        event.) 
    //  Remove this if checking when RtlRegisterWait timeout is fixed.
    //
    //
    if (  NewInterval > 60 * 60 * 12 )
    {
        ElfWriteNoonEvent (EVENT_EventlogUptime, TimeStampInterval );
    }
    else
    {
        ELF_LOG1(ERROR,
                 "NoonEventProc: invoked earlier, next noon %d seconds\n",
                 NewInterval );
    }

    //
    //  If timeStamp proc is turned off and TimeStampInterval is > 0.
    //  let's turn on the timeStampProc
    //
    if ( TimeStampInterval > 0 && g_TimeStampEnabled != TIME_STAMP_ENABLED )
    {
        if ( InterlockedCompareExchange( &g_TimeStampEnabled,
                                         TIME_STAMP_ENABLED,
                                         TIME_STAMP_DISABLED )
            == TIME_STAMP_DISABLED )
        {
            ntStatus = RtlRegisterWait(&g_hTimestampWorkitem,
                                       g_hTimestampEvent,
                                       TimeStampProc,           // Callback
                                       (PVOID) UlongToPtr(TimeStampInterval),     // Context
                                       TimeStampInterval * 1000, // Timeout, in ms
                                       WT_EXECUTEONLYONCE);

            if (!NT_SUCCESS(ntStatus))
            {
                ELF_LOG1(ERROR,
                         "TimeStampProc: Rtl-RegisterWait failed %#x\n",
                         ntStatus);

                InterlockedExchange( &g_TimeStampEnabled, TIME_STAMP_DISABLED );
            }
        }
    }
                                         

    //
    // Reregister the wait
    //

    ntStatus = RtlRegisterWait(&g_hNoonEventWorkitem,
                               g_hTimestampEvent,
                               NoonEventProc,       // Callback
                               (PVOID) NULL,        // Context
                               NewInterval * 1000,  // Timeout, in ms
                               WT_EXECUTEONLYONCE);

    if (!NT_SUCCESS(ntStatus))
    {
        ELF_LOG1(ERROR,
                 "NoonEventProc: RtlRegisterWait failed %#x\n",
                 ntStatus);
    }
}

DWORD   NoonEventGetOsVersionInfo(
    Noon_Event_Data* pNoonEvent
    )
/*++

Routine Description:

    This routine gather the OS related information.

Arguments:

    pNoonEvent    -  point to the noon event data. (PDATA - version info)

Return Value:

    if failed, return non zero error code. 

Note:


--*/
{
    LPCWSTR     OsInfoKey = L"Software\\Microsoft\\Windows NT\\CurrentVersion";
    LPCWSTR     ProductName = L"ProductName";
    LPCWSTR     CurrentType = L"CurrentType";
    LPCWSTR     InstallDate = L"InstallDate";
    LPCWSTR     BuildLab    = L"BuildLab";
    DWORD       cbData      = 0;
    
    HKEY        hOsKey;
    DWORD       dwError   = ERROR_SUCCESS;
    DWORD       dwType    = 0;
        
    OSVERSIONINFOEX     osVersionInfoEx = {0};

    osVersionInfoEx.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if ( GetVersionEx( (LPOSVERSIONINFOW) &(osVersionInfoEx) ) )
    {
        //
        //  OsVersion: 5.1.3580 Build 3580
        //
        StringCchPrintfW(pNoonEvent->szOSVersion, 
                        MAX_OS_INFO_LENGTH + 128, 
                    L"%d.%d.%d Build %d %s",
                    osVersionInfoEx.dwMajorVersion,
                    osVersionInfoEx.dwMinorVersion,
                    osVersionInfoEx.dwBuildNumber,
                    osVersionInfoEx.dwBuildNumber,
                    (*(osVersionInfoEx.szCSDVersion))? osVersionInfoEx.szCSDVersion:TEXT(" ")
                     );
        pNoonEvent->szOSVersion[ NUM_OF_CHAR(pNoonEvent->szOSVersion) - 1 ] = 0;
    }
    else
    {
        pNoonEvent->szOSVersion[0] = 0;
    }

    if (  !RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      OsInfoKey,  
                      0,
                      KEY_READ,
                      &hOsKey ) )
    {
        //
        //  OSName: Microsoft Windows XP
        //
        cbData      = sizeof( pNoonEvent->szOSName);
        if ( RegQueryValueEx( hOsKey, ProductName, NULL, &dwType, (LPBYTE)pNoonEvent->szOSName, &cbData) ||
             dwType != REG_SZ )
        {
            pNoonEvent->szOSName[0] = 0;
        }

        //
        //  OsBuildType: Uniprocessor Free
        //
        cbData = sizeof( pNoonEvent->szOSBuildType );
        if ( RegQueryValueEx( hOsKey, CurrentType, NULL, &dwType, (LPBYTE)pNoonEvent->szOSBuildType, &cbData) ||
             dwType != REG_SZ )
        {
            pNoonEvent->szOSBuildType[0] = 0;
        }

        //
        //  Original Install Date: ULONG
        //
        cbData = sizeof( ULONG );
        if ( RegQueryValueEx( hOsKey, InstallDate, NULL, NULL, (LPBYTE)(&pNoonEvent->ulOriginalInstallDate), &cbData) )
        {
            pNoonEvent->ulOriginalInstallDate = 0;
        }

        //
        //  BuildString: 2600.xpclient.010817-1148
        //
        cbData = sizeof( pNoonEvent->szOSBuildString );
        if ( RegQueryValueEx( hOsKey, BuildLab, NULL, &dwType, (LPBYTE)pNoonEvent->szOSBuildString, &cbData) || 
             dwType != REG_SZ )
        {
            pNoonEvent->szOSBuildString[0] = 0;
        }
        
        RegCloseKey( hOsKey );
    }
    else
    {
        //
        //  RegOpenKey failed.
        //
        pNoonEvent->szOSName[0]             = 0;
        pNoonEvent->szOSBuildType[0]        = 0;
        pNoonEvent->ulOriginalInstallDate   = 0;
        pNoonEvent->szOSBuildString[0]      = 0;

    }

    pNoonEvent->ulSystemLangID = (ULONG)GetSystemDefaultLangID();

    return dwError;
}


DWORD   NoonEventGetHardwareInfo(
    Noon_Event_Data* pNoonEvent
    )
/*++

Routine Description:

    This routine gather information about hardware such as: Manufacture, Model, Physical Memory, 
    Processor Number...

Arguments:

    pNoonEvent    -  point to the noon event data. (PDATA - version info)

Return Value:

    if failed, return non zero error code. 

Note:
    
    pNoonEvent->szBiosVersion free by caller
    
--*/
{
    DWORD           dwError = ERROR_SUCCESS;
    
    LPCWSTR         OemInfoKey  = L"Software\\Microsoft\\Windows\\CurrentVersion\\WindowsUpdate\\OemInfo";
    LPCWSTR         WbemOem     = L"WbemOem";
    LPCWSTR         WbemProduct = L"WbemProduct";

    HKEY            hOemKey;
    DWORD           cbData;

    DWORD           dwLength          = 0;
    DWORD           dwType            = 0;

    SYSTEM_INFO     sysInfo;
    MEMORYSTATUSEX  memoryStatus = {0};
    
    //
    //  Dns Fully Qualified. If the host is a node of cluster, the node's name
    //  will be displayed.
    //
    dwLength = NUM_OF_CHAR( pNoonEvent->szFQDN );
    if ( !GetComputerNameEx( ComputerNamePhysicalDnsFullyQualified,
                             pNoonEvent->szFQDN,
                             &dwLength ) )
    {
        ELF_LOG1(ERROR, "GetComputerNameEx failed, error: %u\n", GetLastError());
        *(pNoonEvent->szFQDN) = 0;
    }
    
    GetSystemInfo( &sysInfo );
    pNoonEvent->ulProcessorNum = sysInfo.dwNumberOfProcessors;
    pNoonEvent->ulSystemType   = sysInfo.wProcessorArchitecture;
    
    if ( !RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          OemInfoKey,  
                          0,
                          KEY_READ,
                          &hOemKey ) )
    {
        //
        //  Manufacture: 
        //
        cbData      = sizeof( pNoonEvent->szSystemManufacturer );
        if ( RegQueryValueEx( hOemKey, WbemOem, NULL, &dwType, (LPBYTE)pNoonEvent->szSystemManufacturer, &cbData) ||
             dwType != REG_SZ )
        {
            pNoonEvent->szSystemManufacturer[0] = 0;
        }

        //
        // Model
        //
        cbData      = sizeof( pNoonEvent->szSystemModel );
        if ( RegQueryValueEx( hOemKey, WbemProduct, NULL, &dwType, (LPBYTE)pNoonEvent->szSystemModel, &cbData) ||
             dwType != REG_SZ )
        {
            pNoonEvent->szSystemModel[ 0 ] = 0;
        }

        RegCloseKey( hOemKey );
    }
    else
    {
        pNoonEvent->szSystemManufacturer[0] = 0;
        pNoonEvent->szSystemModel[ 0 ] = 0;
    }
    
    memoryStatus.dwLength = sizeof(MEMORYSTATUSEX);
    if ( GlobalMemoryStatusEx( &memoryStatus ) )
    {
        pNoonEvent->ulPhysicalMemory = (ULONG)(memoryStatus.ullTotalPhys / (1024*1024));
    
        if ( memoryStatus.ullTotalPhys % (1024*1024) != 0 )
            pNoonEvent->ulPhysicalMemory ++;
    }
    else
    {
        pNoonEvent->ulPhysicalMemory = 0;
    }
    
    return dwError;
}

VOID  BuildNoonEventPData()
/*++

Routine Description:

    build up the Noon Event Version Information. (PDATA for the event).

Arguments:

    N/A

Return Value:

    N/A

Note:


--*/
{
    Noon_Event_Data     NoonEventData;
    DWORD               dwLength    = MAX_PATH;
    DWORD               dwTemp      = 0;
    
    RtlZeroMemory( &NoonEventData, sizeof(Noon_Event_Data));

#define NOON_EVENT_VERSION  L"1.1"
    StringCchCopyW( NoonEventData.szVersionId, VERSION_ID_SIZE, NOON_EVENT_VERSION);
#undef  NOON_EVENT_VERSION

    //
    //  Boot Mode:  0 Normal boot
    //              1 Fail-safe boot
    //              2 Fail-safe with network boot
    //
    NoonEventData.lBootMode = GetSystemMetrics( SM_CLEANBOOT );


    //
    //  OS Name, OS Version, OS Build Type, Build Lab String, and 
    //  Original Install Date
    //
    NoonEventGetOsVersionInfo( &NoonEventData );

    //
    //  Hardware Information
    //
    NoonEventGetHardwareInfo( &NoonEventData );
    
    //
    //  The data will be packed as a MULIT_SZ string. (number will be converted to
    //  string as well.) 
    //          sizeof(NoonEventData):  counts all the static buffer size.
    //          two dynamic buffer   :  szBiosVerion + szHotFixes
    //          Total Number Fields
    //          NULL terminate after each field.
    //
    dwLength = sizeof(NoonEventData) 
               + NUM_OF_CHAR_IN_ULONG * TOTAL_NUM_IN_NOON_EVENT
               + TOTAL_FIELD_IN_NOON_EVENT ;

    g_NoonEventInfo.pData = (LPWSTR)GlobalAlloc(GPTR, sizeof(WCHAR) * dwLength);

    if ( g_NoonEventInfo.pData )
    {
        StringCchPrintfW( g_NoonEventInfo.pData,
                    dwLength,
                    L"%s\r%d\r%s\r%s\r%s\r%s\r%x\r%s\r%s\r%d\r%d\r%d\r%x\r%s\r\r",
                    NoonEventData.szVersionId,
                    NoonEventData.lBootMode,
                    (*NoonEventData.szOSName)? NoonEventData.szOSName :UNKNOWN_STRING,
                    (*NoonEventData.szOSVersion)? NoonEventData.szOSVersion : UNKNOWN_STRING,
                    (*NoonEventData.szOSBuildType)? NoonEventData.szOSBuildType : UNKNOWN_STRING,
                    (*NoonEventData.szOSBuildString)? NoonEventData.szOSBuildString : UNKNOWN_STRING,
                    NoonEventData.ulOriginalInstallDate,
                    (*NoonEventData.szSystemManufacturer)? NoonEventData.szSystemManufacturer : UNKNOWN_STRING,
                    (*NoonEventData.szSystemModel)? NoonEventData.szSystemModel : UNKNOWN_STRING,
                    NoonEventData.ulSystemType,
                    NoonEventData.ulProcessorNum,
                    NoonEventData.ulPhysicalMemory,
                    NoonEventData.ulSystemLangID,
                    (*NoonEventData.szFQDN)? NoonEventData.szFQDN : UNKNOWN_STRING
                    );
    
        for ( dwTemp = 0; dwTemp < dwLength - 1; dwTemp ++ )
        {
            if ( g_NoonEventInfo.pData[ dwTemp ] == L'\r' )
            {
                g_NoonEventInfo.pData[ dwTemp ] = 0;
                
                if ( g_NoonEventInfo.pData[ dwTemp + 1 ] == L'\r' )
                {
                    g_NoonEventInfo.pData[ ++ dwTemp ] = 0;
                    g_NoonEventInfo.dwNumOfWChar = (dwTemp + 1);
                    break;
                }
            }
        }
    }
    else
    {
         ELF_LOG0(ERROR, "BuildNoonEventPData failed to allocate PDATA.\n");
         g_NoonEventInfo.dwNumOfWChar = 0;
    }
        
    return;
}


NTSTATUS EnsureComputerName(
	)
/*++

Routine Description:

    This routine ensures that the computer name.

Arguments:

Return Value:

    status value, STATUS_SUCCESS if all is well.

--*/

{
    NTSTATUS           Status;
    UNICODE_STRING     ValueName;
    ULONG              ulActualSize;
	WCHAR wComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD dwComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;
	DWORD dwLen;
	BOOL bRet;
	BYTE            Buffer[ELF_MAX_REG_KEY_INFO_SIZE];
    PKEY_VALUE_PARTIAL_INFORMATION ValueBuffer =
        (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
    RtlInitUnicodeString(&ValueName, VALUE_COMPUTERNAME);

	// Determine if there is a String under the eventlog key that
	// contains the current name.

    Status = NtQueryValueKey(hEventLogNode,
                             &ValueName,
                             KeyValuePartialInformation,
                             ValueBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ulActualSize);
	
    if (NT_SUCCESS(Status))
    {
        if(ValueBuffer->DataLength != 0)
        	return STATUS_SUCCESS;	// all is well, there is already a string
    }

	// Get the computer name and write it

    bRet = GetComputerName(wComputerName, &dwComputerNameLen);
    if(bRet == FALSE)
    {
        ELF_LOG1(ERROR,
                 "EnsureComputerName: GetComputerName failed %#x\n",
                 GetLastError());
		return STATUS_UNSUCCESSFUL;
    }

	// calc size in byte including null

	dwLen = sizeof(WCHAR) * (dwComputerNameLen + 1);
    Status = NtSetValueKey(hEventLogNode,
                                   &ValueName,
                                   0,
                                   REG_SZ,
                                   wComputerName,
                                   dwLen);
	
    if (!NT_SUCCESS(Status))
        ELF_LOG1(ERROR,
                 "EnsureComputerName: NtSetValueKey failed %#x\n",
                 Status);
	return Status;
}

VOID
SvcEntry_Eventlog(
    DWORD               argc,
    LPWSTR              argv[],
    PSVCS_GLOBAL_DATA   SvcsGlobalData,
    HANDLE              SvcRefHandle
    )

/*++

Routine Description:

    This is the main routine for the Event Logging Service.

Arguments:

    Command-line arguments.

Return Value:

    NONE

--*/
{
    NTSTATUS           Status;
    OBJECT_ATTRIBUTES  ObjectAttributes;
    UNICODE_STRING     RootRegistryNode;
    UNICODE_STRING     ComputerNameRegistryNode;
    ULONG              Win32Error = NO_ERROR;
    ELF_REQUEST_RECORD FlushRequest;
    BYTE               Buffer[ELF_MAX_REG_KEY_INFO_SIZE];

    PKEY_VALUE_FULL_INFORMATION ValueBuffer = (PKEY_VALUE_FULL_INFORMATION) Buffer;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    HKEY        hKey;
    ULONG       ValueSize = sizeof(ULONG);

#if DBG

    UNICODE_STRING     ValueName;
    ULONG              ulActualSize;

#endif  // DBG

    g_lNumSecurityWriters = 0;

    //
    // Set up the object that describes the root node for the eventlog service
    //
    RtlInitUnicodeString(&RootRegistryNode, REG_EVENTLOG_NODE_PATH);
    InitializeObjectAttributes(&ObjectAttributes,
                               &RootRegistryNode,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    //
    // If this fails, we'll just use the defaults
    //
    Status = NtOpenKey(&hEventLogNode, KEY_READ | KEY_NOTIFY | KEY_SET_VALUE, &ObjectAttributes);
    if (NT_SUCCESS(Status))
    {
        Status = EnsureComputerName();
	    if (!NT_SUCCESS(Status))
	    {
	        //
	        // Not much we can do here as we don't even have a
	        // SERVICE_STATUS_HANDLE at this point.
	        //
	        return;
	    }
    }


    RtlInitUnicodeString(&ComputerNameRegistryNode, REG_COMPUTERNAME_NODE_PATH);

    InitializeObjectAttributes(&ObjectAttributes,
                               &ComputerNameRegistryNode,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&hComputerNameNode, KEY_READ | KEY_NOTIFY, &ObjectAttributes);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: NtOpenKey for ComputerName failed %#x -- exiting\n",
                 Status);

        //
        // Not much we can do here as we don't even have a
        // SERVICE_STATUS_HANDLE at this point.
        //
        return;
    }

///////////////////////////////////////////////////////

#if DBG

    //
    // See if there's a debug value
    //
    RtlInitUnicodeString(&ValueName, VALUE_DEBUG);

    Status = NtQueryValueKey(hEventLogNode,
                             &ValueName,
                             KeyValuePartialInformation,
                             ValueBuffer,
                             ELF_MAX_REG_KEY_INFO_SIZE,
                             &ulActualSize);

    if (NT_SUCCESS(Status))
    {
        if (((PKEY_VALUE_PARTIAL_INFORMATION) ValueBuffer)->Type == REG_DWORD)
        {
            ElfDebugLevel = *(LPDWORD) (((PKEY_VALUE_PARTIAL_INFORMATION) ValueBuffer)->Data);
        }
    }

    ELF_LOG1(TRACE,
             "SvcEntry_Eventlog: ElfDebugLevel = %#x\n",
             ElfDebugLevel);

#endif  // DBG


    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    ElfGlobalSvcRefHandle = SvcRefHandle;
    ElfGlobalData         = SvcsGlobalData;

    //
    // Initialize the list heads for the modules and log files.
    //
    InitializeListHead(&LogFilesHead);
    InitializeListHead(&LogModuleHead);
    InitializeListHead(&QueuedEventListHead);
    InitializeListHead(&QueuedMessageListHead);

    //
    // Initialize to 0 so that we can clean up before exiting
    //
    EventFlags = 0;

    //
    // Create the Eventlog's private heap if possible.  This must be
    // done before any calls to ElfpAllocateBuffer are made.
    //
    ElfpCreateHeap();

    //
    // Initialize the status data.
    //
    Status = ElfpInitStatus();

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: ElfpInitStatus failed %#x -- exiting\n",
                 Status);

        //
        // Not much we can do here as we don't even have a
        // SERVICE_STATUS_HANDLE at this point.
        //
        return;
    }

    //
    // Set up control handler
    //
    if ((ElfServiceStatusHandle = RegisterServiceCtrlHandler(
                                      EVENTLOG_SVC_NAMEW,
                                      ElfControlResponse)) == 0)
    {
        Win32Error = GetLastError();

        //
        // If we got an error, we need to set status to uninstalled, and end the
        // thread.
        //
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: RegisterServiceCtrlHandler failed %#x\n",
                 Win32Error);

        goto cleanupandexit;
    }

    //
    // Notify the Service Controller for the first time that we are alive
    // and are in a start pending state
    //
    //  *** UPDATE STATUS ***
    ElfStatusUpdate(STARTING);

    //
    // Get the localized title for message box popups.
    //
    ElfInitMessageBoxTitle();

    //
    // Initialize a critical section for use when adding or removing
    // LogFiles or LogModules. This must be done before we process any
    // file information.
    //
    Status = ElfpInitCriticalSection(&LogFileCritSec);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create LogFileCritSec %#x\n",
                 Status);

        goto cleanupandexit;
    }

    EventFlags |= ELF_INIT_LOGFILE_CRIT_SEC;

    Status = ElfpInitCriticalSection(&LogModuleCritSec);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create LogModuleCritSec %#x\n",
                 Status);

        goto cleanupandexit;
    }

    EventFlags |= ELF_INIT_LOGMODULE_CRIT_SEC;

    Status = ElfpInitCriticalSection(&QueuedEventCritSec);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create QueuedEventCritSec %#x\n",
                 Status);

        goto cleanupandexit;
    }

    EventFlags |= ELF_INIT_QUEUED_EVENT_CRIT_SEC;

    Status = ElfpInitCriticalSection(&QueuedMessageCritSec);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create QueuedMessageCritSec %#x\n",
                 Status);

        goto cleanupandexit;
    }

    EventFlags |= ELF_INIT_QUEUED_MESSAGE_CRIT_SEC;


    //
    // Set up the data structures for the Logfiles and Modules.
    //

    Status = ElfSetUpConfigDataStructs();

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: ElfSetUpConfigDataStructs failed %#x\n",
                 Status);

        goto cleanupandexit;
    }

    //
    // Tell service controller that we are making progress
    //
    ElfStatusUpdate(STARTING);

    //
    // Initialize a critical section for use when adding or removing
    // context handles (LogHandles).
    //
    Status = ElfpInitCriticalSection(&LogHandleCritSec);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create LogHandleCritSec %#x\n",
                 Status);

        goto cleanupandexit;
    }

    EventFlags |= ELF_INIT_LOGHANDLE_CRIT_SEC;

    //
    // Initialize the context handle (log handle) list.
    //
    InitializeListHead( &LogHandleListHead );

    //
    // Initialize the Global Resource.
    //
    Status = ElfpInitResource(&GlobalElfResource);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create GlobalElfResource %#x\n",
                 Status);

        goto cleanupandexit;
    }

    EventFlags |= ELF_INIT_GLOBAL_RESOURCE;

    //
    //Initialize a CritSec for clustering support
    //
    Status = ElfpInitCriticalSection(&gClPropCritSec);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: Unable to create gClPropCritSec %#x\n",
                 Status);

        goto cleanupandexit;
    }

    EventFlags |= ELF_INIT_CLUS_CRIT_SEC;

    //
    // Tell service controller that we are making progress
    //
    ElfStatusUpdate(STARTING);

    // Create a thread for watching the LPC port.
    //

    if (!StartLPCThread())
    {
        ELF_LOG0(ERROR,
                 "SvcEntry_Eventlog: StartLPCThread failed\n");

        Status = STATUS_UNSUCCESSFUL;
        goto cleanupandexit;
    }

    EventFlags |= ELF_STARTED_LPC_THREAD;

    //
    // Tell service controller of that we are making progress
    //
    ElfStatusUpdate(STARTING);

    //
    // Create a thread for watching for changes in the registry.
    //
    if (!ElfStartRegistryMonitor())
    {
        ELF_LOG0(ERROR,
                 "SvcEntry_Eventlog: ElfStartRegistryMonitor failed\n");

        Status = STATUS_UNSUCCESSFUL;
        goto cleanupandexit;
    }

    EventFlags |= ELF_STARTED_REGISTRY_MONITOR;

    //
    //  Setup NoonEvent PData
    //
    BuildNoonEventPData();

    //
    // if this is setup, then dont do the periodic timestamp writting
    // Setup has the feature where the last write is ignored and so
    // the code acted as if a dirty shutdown happened.
    //

    if(!SvcsGlobalData->fSetupInProgress)
    {
        //
        // < Not in Setup >
        // Read from the registry to determine the time stamp 
        // interval, default to 5 minutes
        //

        g_PreviousInterval = GetNoonEventTimeStamp();    
    }
    else
    {
        g_PreviousInterval = 0;
    }
    
    //
    //  Tell service controller of that we are making progress
    //
    ElfStatusUpdate(STARTING);

    //
    // Write out an event that says we started
    //
    ElfWriteNoonEvent(EVENT_EventlogStarted,
                      g_PreviousInterval );

    //
    // Write a boot event with version info
    //
    ElfWriteProductInfoEvent();

    // Write a computer name change event if that is applicable

    ElfCheckForComputerNameChange();

    //
    // If this is setup, then dont do the periodic timestamp writting
    // Setup has the feature where the last write is ignored and so
    // the code acted as if a dirty shutdown happened.
    //

    if(SvcsGlobalData->fSetupInProgress)
    {
        ElfWriteTimeStamp(EVENT_NormalShutdown,
                          FALSE);   // clears out the time stamp.
    }

    if (g_PreviousInterval != 0)
    {
        //
        // Write out the first timer based abnormal shutdown time stamp
        //

        ElfWriteTimeStamp (EVENT_AbNormalShutdown, TRUE);
    }

    //
    // Write out any events that were queued up during initialization
    //

    FlushRequest.Command = ELF_COMMAND_WRITE_QUEUED;

    ElfPerformRequest(&FlushRequest);

    //
    // Tell service controller that we are making progress
    //
    ElfStatusUpdate(STARTING);

    //
    // Finish setting up the RPC server
    //
    // NOTE:  Now all RPC servers in services.exe share the same pipe name.
    // However, in order to support communication with version 1.0 of WinNt,
    // it is necessary for the Client Pipe name to remain the same as
    // it was in version 1.0.  Mapping to the new name is performed in
    // the Named Pipe File System code.
    //
    Status = ElfGlobalData->StartRpcServer(
                ElfGlobalData->SvcsRpcPipeName,
                eventlog_ServerIfHandle);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "SvcEntry_Eventlog: StartRpcServer failed %#x\n",
                 Status);

        goto cleanupandexit;
    }

    //
    // Tell service controller that we are making progress
    //
    ElfStatusUpdate(RUNNING);

    EventFlags |= ELF_STARTED_RPC_SERVER;

    if (GetElState() == RUNNING)
    {
        //
        // Create a thread to periodically write
        // a time stamp to the registry.
        //

        g_hTimestampEvent = CreateEvent (NULL, TRUE, FALSE, NULL);

        if (g_hTimestampEvent != NULL)
        {
        
            if ( g_PreviousInterval != 0 )
            {
        
                InterlockedExchange( &g_TimeStampEnabled, TIME_STAMP_ENABLED );

                Status = RtlRegisterWait(&g_hTimestampWorkitem,
                                         g_hTimestampEvent,
                                         TimeStampProc,              // Callback
                                         (PVOID) UlongToPtr(g_PreviousInterval), // Context
                                         0,                          // Timeout
                                         WT_EXECUTEONLYONCE);

                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG1(ERROR,
                             "SvcEntry_Eventlog: RtlRegisterWait failed %#x\n",
                             Status);

                    InterlockedExchange( &g_TimeStampEnabled, TIME_STAMP_DISABLED );
                }

            }

            if(!SvcsGlobalData->fSetupInProgress)
            {
                //
                //  start the NoonEvent Proc if it is not in a setup
                //
                Status = RtlRegisterWait(&g_hNoonEventWorkitem,
                                         g_hTimestampEvent,
                                         NoonEventProc,                     // Callback
                                         (PVOID) NULL,                      // Context
                                         GetNextNoonEventDelay() * 1000,    // Timeout
                                         WT_EXECUTEONLYONCE);

                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG1(ERROR,
                             "SvcEntry_Eventlog: RtlRegisterWait failed %#x\n",
                             Status);
                }
            }
        }
        else
        {
            ELF_LOG1(ERROR,
                     "SvcEntry_Eventlog: CreateEvent for timestamp failed %d\n",
                     GetLastError());
        }

        ELF_LOG0(TRACE,
                 "SvcEntry_Eventlog: Service running -- main thread returning\n");

        return;
    }

cleanupandexit:

    //
    // Come here if there is cleanup necessary.
    //
    ELF_LOG0(ERROR,
             "SvcEntry_Eventlog: Exiting on error\n");

    if (Win32Error == NO_ERROR)
    {
        Win32Error = RtlNtStatusToDosError(Status);
    }

    ElfBeginForcedShutdown(PENDING, Win32Error, Status);

    //
    // If the registry monitor has been initialized, then
    // let it do the shutdown cleanup.  All we need to do
    // here is wake it up.
    // Otherwise, this thread will do the cleanup.
    //
    if (EventFlags & ELF_STARTED_REGISTRY_MONITOR)
    {
        StopRegistryMonitor();
    }
    else
    {
        ElfpCleanUp(EventFlags);
    }

    return;
}


VOID
ElfInitMessageBoxTitle(
    VOID
    )

/*++

Routine Description:

    Obtains the title text for the message box used to display messages.
    If the title is successfully obtained from the message file, then
    that title is pointed to by GlobalAllocatedMsgTitle and
    GlobalMessageBoxTitle.  If unsuccessful, then GlobalMessageBoxTitle
    left pointing to the DefaultMessageBoxTitle.

    NOTE:  If successful, a buffer is allocated by this function.  The
    pointer stored in GlobalAllocatedMsgTitle and it should be freed when
    done with this buffer.

Arguments:

Return Value:

    none

--*/
{
    LPVOID      hModule;
    DWORD       msgSize;

    //
    // This function should be called only once during initialization.  Note
    // that it needs to be called before the Eventlog's RPC server is started
    // or else it's possible for the log to fill up, which will generate a
    // "log full" popup with no title (since GlobalMessageBoxTitle is NULL).
    //
    ASSERT(GlobalMessageBoxTitle == NULL);

    hModule = LoadLibraryEx(L"netevent.dll",
                            NULL,
                            LOAD_LIBRARY_AS_DATAFILE);

    if ( hModule == NULL)
    {
        ELF_LOG1(ERROR,
                 "ElfInitMessageBoxTitle: LoadLibrary of netevent.dll failed %d\n",
                 GetLastError());

        return;
    }

    msgSize = FormatMessageW(
                FORMAT_MESSAGE_FROM_HMODULE |       //  dwFlags
                  FORMAT_MESSAGE_ARGUMENT_ARRAY |
                  FORMAT_MESSAGE_ALLOCATE_BUFFER,
                hModule,
                TITLE_EventlogMessageBox,           //  MessageId
                0,                                  //  dwLanguageId
                (LPWSTR) &GlobalMessageBoxTitle,    //  lpBuffer
                0,                                  //  nSize
                NULL);

    if (msgSize == 0)
    {
        ELF_LOG2(ERROR,
                 "ElfInitMessageBoxTitle: FormatMessage failed %d -- using %ws\n",
                 GetLastError(),
                 ELF_DEFAULT_MESSAGE_BOX_TITLE);

        GlobalMessageBoxTitle = ELF_DEFAULT_MESSAGE_BOX_TITLE;
        bGlobalMessageBoxTitleNeedFree = FALSE;
    }
    else
        bGlobalMessageBoxTitleNeedFree = TRUE;

    FreeLibrary(hModule);
    return;
}


#ifdef EXIT_PROCESS

//
// This code is compiled into the Eventlog to track down a DLL that's loaded
// into services.exe and calls ExitProcess.  Since this DLL should never be
// unloaded, we break into the debugger on DLL_PROCESS_DETACH.  To use this,
// the following need to be added to the sources file:
//
// DLLENTRY=  DllInit
//
// -DEXIT_PROCESS  (to the C_DEFINES line)
//

BOOL
DllInit(
    IN  HINSTANCE   hDll,
    IN  DWORD       dwReason,
    IN  PCONTEXT    pContext OPTIONAL
    )
{
    switch (dwReason) {

        case DLL_PROCESS_ATTACH:

            //
            // No notification of THREAD_ATTACH and THREAD_DETACH
            //
            DisableThreadLibraryCalls(hDll);
            break;

        case DLL_PROCESS_DETACH:

            //
            // This should NEVER happen -- it means services.exe
            // is exiting via an ExitProcess call
            //
            DebugBreak();
            break;
    }

    return TRUE;
}

#endif  // EXIT_PROCESS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\memory.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    MEMORY.C

Abstract:

    This file contains the routines that deal with memory management.

Author:

    Rajen Shah	(rajens)    12-Jul-1991

[Environment:]

    User Mode - Win32, except for NTSTATUS returned by some functions.

Revision History:

    Jonathan Schwartz (jschwart)  10-Dec-1999
        Have the Eventlog use its own heap

--*/

//
// INCLUDES
//
#include <eventp.h>

//
// GLOBALS
//
PVOID g_pElfHeap;


VOID
ElfpCreateHeap(
    VOID
    )
{
    DWORD  dwHeapFlags;

#if DBG

    //
    // Turn on tail and free checking on debug builds.
    //
    dwHeapFlags = HEAP_GROWABLE
                   | HEAP_FREE_CHECKING_ENABLED
                   | HEAP_TAIL_CHECKING_ENABLED;

#else   // ndef DBG

    dwHeapFlags = HEAP_GROWABLE;

#endif  // DBG

    //
    // Create the heap
    //
    g_pElfHeap = RtlCreateHeap(dwHeapFlags,  // Flags
                               NULL,         // HeapBase
                               32 * 1024,    // ReserveSize (32K)
                               4096,         // CommitSize (4K)
                               NULL,         // HeapLock
                               NULL);        // GrowthThreshhold

    if (g_pElfHeap == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfpCreateHeap: RtlCreateHeap failed -- using process heap\n");

        g_pElfHeap = RtlProcessHeap();
    }

    return;
}


PVOID
ElfpAllocateBuffer(
    ULONG Size
    )

/*++

Routine Description:

    Allocate a buffer of the given size


Arguments:

    Number of bytes to allocate

Return Value:

    Pointer to allocated buffer (or NULL).

--*/
{
    return RtlAllocateHeap(g_pElfHeap, 0, Size);
}



BOOLEAN
ElfpFreeBuffer(
    PVOID Address
    )

/*++

Routine Description:

    Frees a buffer previously allocated by ElfpAllocateBuffer.

Arguments:

    Pointer to buffer.

Return Value:

    TRUE if the block was properly freed, FALSE if not

Note:


--*/
{
    //
    // Note that RtlFreeHeap handles NULL
    //
    return RtlFreeHeap(g_pElfHeap, 0, Address);
}


PVOID
MIDL_user_allocate (
    size_t Size
    )
{
    //
    // The server-side RPC calls in the Eventlog expect any
    // UNICODE_STRINGs passed in either to have a length equal
    // to the max length or to be NULL-terminated.  We need to
    // zero the memory here to supply that NULL-termination.
    //
    return RtlAllocateHeap(g_pElfHeap, HEAP_ZERO_MEMORY, Size);
}


VOID
MIDL_user_free (
    PVOID Address
    )
{
    ElfpFreeBuffer(Address);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\operate.c ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation

Module Name:

    operate.c

Abstract:

    This file contains all the routines to perform operations on the
    log files. They are called by the thread that performs requests.

Author:

    Rajen Shah  (rajens)    16-Jul-1991

Revision History:

    04-Apr-1995     MarkBl
        Resets the file archive attribute on log write. The backup caller
        clears it.
    29-Aug-1994     Danl
        We no longer grow log files in place.  Therefore, the ExtendSize
        function will allocate a block that is as large as the old size plus
        the size of the new block that must be added.  If this allocation
        succeeds, then it will free up the old block.  If a failure occurs,
        we continue to use the old block as if we have already grown as much
        as we can.
    22-Jul-1994     Danl
        ValidFilePos:  Changed test for pEndRecordLen > PhysicalEOF
        so that it uses >=.  In the case where pEndRecordLen == PhysicalEOF,
        we want to wrap to find the last DWORD at the beginning of the File
        (after the header).

    08-Jul-1994     Danl
        PerformWriteRequest: Fixed overwrite logic so that in the case where
        a log is set up for always-overwrite, that we never go down the branch
        that indicates the log was full.  Previously, it would go down that
        branch if the current time was less than the log time (ie. someone
        set the clock back).

    18-Apr-2001     a-jyotig
		IsPositionWithinRange function changed to take 2 additional parameters 
		EOF and Base Address (BOF) and check if the position is between EOF
		and BOF
--*/

/****
@doc    EXTERNAL INTERFACES EVTLOG
****/

//
// INCLUDES
//
#include <eventp.h>
#include <alertmsg.h>  // ALERT_ELF manifests
#include <msaudite.h>
#include <stdio.h>
#include "elfmsg.h"


#define OVERWRITE_AS_NEEDED 0x00000000
#define NEVER_OVERWRITE     0xffffffff

//
// Prototypes
//

VOID PerformClearRequest(PELF_REQUEST_RECORD Request);


BOOL
IsPositionWithinRange(
    PVOID Position,
    PVOID BeginningRecord,
    PVOID EndingRecord,
    PVOID PhysEOF,
    PVOID BaseAddress
    );


VOID
ElfExtendFile (
    PLOGFILE pLogFile,
    ULONG    SpaceNeeded,
    PULONG   SpaceAvail
    )

/*++

Routine Description:

    This routine takes an open log file and extends the file and underlying
    section and view if possible.  If it can't be grown, it caps the file
    at this size by setting the ConfigMaxFileSize to the Actual.  It also
    updates the SpaceAvail parm which is used in PerformWriteRequest (the
    caller).

Arguments:

    pLogFile      - pointer to a LOGFILE structure for the open logfile
    ExtendAmount  - How much bigger to make the file/section/view
    SpaceAvail    - Update this with how much space was added to the section

Return Value:

    None - If we can't extend the file, we just cap it at this size for the
           duration of this boot.  We'll try again the next time the eventlog
           is closed and reopened.

Note:

    ExtendAmount should always be granular to 64K.

--*/
{
    LARGE_INTEGER NewSize;
    NTSTATUS Status;
    PVOID BaseAddress;
    SIZE_T Size;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOL bExpanded = FALSE;

    //
    // Calculate how much to grow the file then extend the section by
    // that amount.  Do this in 64K chunks.
    //
    SpaceNeeded = ((SpaceNeeded - *SpaceAvail) & 0xFFFF0000) + 0x10000;

    if (SpaceNeeded > (pLogFile->ConfigMaxFileSize - pLogFile->ActualMaxFileSize))
    {
        //
        // We can't grow it by the full amount we need.  Grow
        // it to the max size and let file wrap take over.
        // If there isn't any room to grow, then return;
        //
        SpaceNeeded = pLogFile->ConfigMaxFileSize - pLogFile->ActualMaxFileSize;

        if (SpaceNeeded == 0)
        {
            return;
        }
    }

    NewSize = RtlConvertUlongToLargeInteger(pLogFile->ActualMaxFileSize + SpaceNeeded);

    //
    // Update the file size information, extend the section, and map the
    // new section
    //
    Status = NtSetInformationFile(pLogFile->FileHandle,
                                  &IoStatusBlock,
                                  &NewSize,
                                  sizeof(NewSize),
                                  FileEndOfFileInformation);


    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ElfExtendFile: NtSetInformationFile for %ws log failed %#x\n",
                 pLogFile->LogModuleName->Buffer,
                 Status);

        goto ErrorExit;
    }
    bExpanded = TRUE;
    Status = NtExtendSection(pLogFile->SectionHandle, &NewSize);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ElfExtendFile: NtExtendSection for %ws log failed %#x\n",
                 pLogFile->LogModuleName->Buffer,
                 Status);

        goto ErrorExit;
    }

    //
    // Now that the section is extended, we need to map the new section.
    //

    //
    // Map a view of the entire section (with the extension).
    // Allow the allocator to tell us where it is located, and
    // what the size is.
    //
    BaseAddress = NULL;
    Size = 0;
    Status = NtMapViewOfSection(pLogFile->SectionHandle,
                                NtCurrentProcess(),
                                &BaseAddress,
                                0,
                                0,
                                NULL,
                                &Size,
                                ViewUnmap,
                                0,
                                PAGE_READWRITE);

    if (!NT_SUCCESS(Status))
    {
        //
        // If this fails, just exit, and we will continue with the
        // view that we have.
        //
        ELF_LOG2(ERROR,
                 "ElfExtendFile: NtMapViewOfSection for %ws log failed %#x\n",
                 pLogFile->LogModuleName->Buffer,
                 Status);

        goto ErrorExit;
    }

    //
    // Unmap the old section.
    //
    Status = NtUnmapViewOfSection(NtCurrentProcess(),
                                  pLogFile->BaseAddress);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ElfExtendFile: NtUnmapeViewOfSection for %ws log failed %#x\n",
                 pLogFile->LogModuleName->Buffer,
                 Status);
    }

    pLogFile->BaseAddress = BaseAddress;

    //
    // We managed to extend the file, update the actual size
    // and space available and press on.
    //
    if (pLogFile->Flags & ELF_LOGFILE_HEADER_WRAP)
    {
        //
        // Since we're wrapped, we want to move the "unwrapped" portion (i.e.,
        // everything from the first record to the end of the old file) down to
        // be at the bottom of the new file
        //
        // The call below moves memory as follows:
        //
        //  1. Destination -- PhysicalEOF - the size of the region
        //  2. Source      -- Address of the start of the first record
        //  3. Size        -- Num. bytes in the old file -
        //                      offset of the first record
        //
        //
        // Note that at this point, we have the following relevant variables
        //
        //  BaseAddress             -- The base address of the mapped section
        //  Size                    -- The size of the enlarged section
        //  pLogFile->ViewSize      -- The size of the old section
        //  pLogfile->BeginRecord   -- The offset of the first log record
        //

        //
        // Calculate the number of bytes to move
        //
        DWORD dwWrapSize = (DWORD)(pLogFile->ViewSize - pLogFile->BeginRecord);

        ELF_LOG1(FILES,
                 "ElfExtendFile: %ws is wrapped\n",
                 pLogFile->LogModuleName->Buffer);

        RtlMoveMemory((LPBYTE)BaseAddress + Size - dwWrapSize,
                      (LPBYTE)BaseAddress + pLogFile->BeginRecord,
                      dwWrapSize);

        //
        // We've moved the BeginRecord -- update the offset
        //
        pLogFile->BeginRecord = (ULONG)(Size - dwWrapSize);
    }

    pLogFile->ViewSize = (ULONG)Size;
    pLogFile->ActualMaxFileSize += SpaceNeeded;
    *SpaceAvail += SpaceNeeded;

    //
    // Now flush this to disk to commit it
    //
    BaseAddress = pLogFile->BaseAddress;
    Size        = FILEHEADERBUFSIZE;

    Status = NtFlushVirtualMemory(NtCurrentProcess(),
                                  &BaseAddress,
                                  &Size,
                                  &IoStatusBlock);

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG2(ERROR,
                 "ElfExtendFile: NtFlushVirtualMemory for %ws log failed %#x\n",
                 pLogFile->LogModuleName->Buffer,
                 Status);
    }

    return;

ErrorExit:

    //
    // Couldn't extend the section for some reason.  Just wrap the file now.
    // Cap the file at this size, so we don't try and extend the section on
    // every write.  The next time the eventlog service is started up it
    // will revert to the configured max again.
    //

    //
    // BUGBUG:  Generate an Alert here
    //
    ELF_LOG1(ERROR,
             "ElfExtendFile: Couldn't extend %ws log\n",
             pLogFile->LogModuleName->Buffer);

    pLogFile->ConfigMaxFileSize = pLogFile->ActualMaxFileSize;

    if(bExpanded)
        pLogFile->bFailedExpansion = TRUE;
    return;
}



NTSTATUS
CopyUnicodeToAnsiRecord (
    OUT PVOID  Dest       OPTIONAL,
    IN  PVOID  Src,
    OUT PVOID  *NewBufPos OPTIONAL,
    OUT PULONG RecordSize
    )

/*++

Routine Description:

    This routine reads from the event log specified in the request packet.

    This routine uses memory mapped I/O to access the log file. This makes
    it much easier to move around the file.

Arguments:

    Dest - Points to destination buffer.  If NULL, calculate and return
           the record length without copying the record.

    Src  - Points to the UNICODE record.

    NewBufPos - Gets offset in Dest buffer after record just transferred.
                If Dest is NULL, this is ignored.

    RecordSize - Gets size of this (ANSI) record.

Return Value:

    STATUS_SUCCESS if no errors occur.  Specific NTSTATUS error otherwise.

Note:

--*/
{
    ANSI_STRING     StringA;
    UNICODE_STRING  StringU;
    PEVENTLOGRECORD SrcRecord, DestRecord;
    PWSTR           pStringU;
    PVOID           TempPtr;
    ULONG           PadSize, i;
    ULONG           zero = 0;
    WCHAR           *SrcStrings, *DestStrings;
    ULONG           RecordLength, *pLength;
    ULONG           ulTempLength;

    NTSTATUS        Status = STATUS_SUCCESS;

    DestRecord = (PEVENTLOGRECORD)Dest;
    SrcRecord  = (PEVENTLOGRECORD)Src;

    if (DestRecord != NULL)
    {
        DestRecord->TimeGenerated = SrcRecord->TimeGenerated;
        DestRecord->Reserved      = SrcRecord->Reserved;
        DestRecord->RecordNumber  = SrcRecord->RecordNumber;
        DestRecord->TimeWritten   = SrcRecord->TimeWritten;
        DestRecord->EventID       = SrcRecord->EventID;
        DestRecord->EventType     = SrcRecord->EventType;
        DestRecord->EventCategory = SrcRecord->EventCategory;
        DestRecord->NumStrings    = SrcRecord->NumStrings;
        DestRecord->UserSidLength = SrcRecord->UserSidLength;
        DestRecord->DataLength    = SrcRecord->DataLength;
    }

    //
    // Convert and copy over modulename
    //
    pStringU = (PWSTR)((ULONG_PTR)SrcRecord + sizeof(EVENTLOGRECORD));

    RtlInitUnicodeString(&StringU, pStringU);

    if (DestRecord != NULL)
    {
        Status = RtlUnicodeStringToAnsiString(&StringA,
                                              &StringU,
                                              TRUE);

        ulTempLength = StringA.MaximumLength;
    }
    else
    {
        ulTempLength = RtlUnicodeStringToAnsiSize(&StringU);
    }

    if (NT_SUCCESS(Status))
    {
        TempPtr = (PVOID)((ULONG_PTR)DestRecord + sizeof(EVENTLOGRECORD));

        if (DestRecord != NULL)
        {
            RtlMoveMemory ( TempPtr, StringA.Buffer, ulTempLength );
            RtlFreeAnsiString(&StringA);
        }

        TempPtr = (PVOID)((ULONG_PTR) TempPtr + ulTempLength);

        //
        // Convert and copy over computername
        //
        // TempPtr points to location in the destination for the computername
        //

        pStringU = (PWSTR)((ULONG_PTR)pStringU + StringU.MaximumLength);

        RtlInitUnicodeString ( &StringU, pStringU );

        if (DestRecord != NULL)
        {
            Status = RtlUnicodeStringToAnsiString (
                                        &StringA,
                                        &StringU,
                                        TRUE
                                        );

            ulTempLength = StringA.MaximumLength;
        }
        else
        {
            ulTempLength = RtlUnicodeStringToAnsiSize(&StringU);
        }

        if (NT_SUCCESS(Status))
        {
            if (DestRecord != NULL)
            {
                RtlMoveMemory ( TempPtr, StringA.Buffer, ulTempLength );
                RtlFreeAnsiString(&StringA);
            }

            TempPtr = (PVOID)((ULONG_PTR) TempPtr + ulTempLength);
        }
    }

    if (NT_SUCCESS(Status))
    {
        // TempPtr points to location after computername - i.e. UserSid.
        // Before we write out the UserSid, we ensure that we pad the
        // bytes so that the UserSid starts on a DWORD boundary.
        //
        PadSize = sizeof(ULONG)
                      - (ULONG)(((ULONG_PTR)TempPtr-(ULONG_PTR)DestRecord) % sizeof(ULONG));

        if (DestRecord != NULL)
        {
            RtlMoveMemory (TempPtr, &zero, PadSize);

            TempPtr = (PVOID)((ULONG_PTR)TempPtr + PadSize);

            //
            // Copy over the UserSid.
            //

            RtlMoveMemory(TempPtr,
                          (PVOID)((ULONG_PTR)SrcRecord + SrcRecord->UserSidOffset),
                          SrcRecord->UserSidLength);

            DestRecord->UserSidOffset = (ULONG)((ULONG_PTR)TempPtr - (ULONG_PTR)DestRecord);
        }
        else
        {
            TempPtr = (PVOID)((ULONG_PTR)TempPtr + PadSize);
        }

        //
        // Copy over the Strings
        //
        TempPtr = (PVOID)((ULONG_PTR)TempPtr + SrcRecord->UserSidLength);
        SrcStrings = (WCHAR *)((ULONG_PTR)SrcRecord + (ULONG)SrcRecord->StringOffset);
        DestStrings = (WCHAR *)TempPtr;

        for (i=0; i < SrcRecord->NumStrings; i++)
        {
            RtlInitUnicodeString (&StringU, SrcStrings);

            if (DestRecord != NULL)
            {
                Status = RtlUnicodeStringToAnsiString(&StringA,
                                                      &StringU,
                                                      TRUE);

                ulTempLength = StringA.MaximumLength;
            }
            else
            {
                ulTempLength = RtlUnicodeStringToAnsiSize(&StringU);
            }

            if (!NT_SUCCESS(Status))
            {
                //
                // Bail out
                //
                return Status;
            }

            if (DestRecord != NULL)
            {
                RtlMoveMemory(DestStrings,
                              StringA.Buffer,
                              ulTempLength);

                RtlFreeAnsiString (&StringA);
            }

            DestStrings = (WCHAR*)((ULONG_PTR)DestStrings + (ULONG)ulTempLength);
            SrcStrings  = (WCHAR*)((ULONG_PTR)SrcStrings + (ULONG)StringU.MaximumLength);
        }

        //
        // DestStrings points to the point after the last string copied.
        //
        if (DestRecord != NULL)
        {
            DestRecord->StringOffset = (ULONG)((ULONG_PTR)TempPtr - (ULONG_PTR)DestRecord);

            TempPtr = (PVOID)DestStrings;

            //
            // Copy over the binary Data
            //
            DestRecord->DataOffset = (ULONG)((ULONG_PTR)TempPtr - (ULONG_PTR)DestRecord);

            RtlMoveMemory(TempPtr,
                          (PVOID)((ULONG_PTR)SrcRecord + SrcRecord->DataOffset),
                          SrcRecord->DataLength);
        }
        else
        {
            TempPtr = (PVOID)DestStrings;
        }

        //
        // Now do the pad bytes.
        //
        TempPtr = (PVOID) ((ULONG_PTR) TempPtr + SrcRecord->DataLength);
        PadSize = sizeof(ULONG)
                      - (ULONG) (((ULONG_PTR) TempPtr - (ULONG_PTR) DestRecord) % sizeof(ULONG));

        RecordLength = (ULONG) ((ULONG_PTR) TempPtr
                                     + PadSize
                                     + sizeof(ULONG)
                                     - (ULONG_PTR)DestRecord);

        if (DestRecord != NULL)
        {
            RtlMoveMemory (TempPtr, &zero, PadSize);
            pLength = (PULONG)((ULONG_PTR)TempPtr + PadSize);
            *pLength = RecordLength;
            DestRecord->Length = RecordLength;

            ASSERT(((ULONG_PTR) DestRecord + RecordLength) ==
                       ((ULONG_PTR) pLength + sizeof(ULONG)));

            *NewBufPos = (PVOID) ((ULONG_PTR) DestRecord + RecordLength);
        }

        *RecordSize = RecordLength;
    }

    return Status;

} // CopyUnicodeToAnsiRecord


BOOL
ValidFilePos (
    PVOID Position,
    PVOID BeginningRecord,
    PVOID EndingRecord,
    PVOID PhysicalEOF,
    PVOID BaseAddress,
    BOOL  fCheckBeginEndRange
    )

/*++

Routine Description:

    This routine determines whether we are pointing to a valid beginning
    of an event record in the event log.  It does this by validating
    the signature then comparing the length at the beginning of the record to
    the length at the end, both of which have to be at least the size of the
    fixed length portion of an eventlog record.

Arguments:

    Position        - Pointer to be verified.
    BeginningRecord - Pointer to the beginning record in the file.
    EndingRecord    - Pointer to the byte after the ending record in the file.
    PhysicalEOF     - Pointer the physical end of the log.
    BaseAddress     - Pointer to the physical beginning of the log.

Return Value:

    TRUE if this position is valid.

Note:

    There is a possibility of error if a record just happens to have the
    ULONG at the current position the same as the value that number of
    bytes further on in the record. However, this is a very slim chance
    as it must have a valid log signature as well.

--*/
{
    PULONG  pEndRecordLength;
    BOOL    fValid = TRUE;

    PEVENTLOGRECORD pEventRecord;

    // catch the 64 bit exception before it occurs!

#ifdef _WIN64
    unsigned __int64 ullPosition = (unsigned __int64)Position;
    if(ullPosition & 3)
    {
        ELF_LOG1(ERROR,
                 "ValidFilePos: Unaligned pointer %#x was passed in\n",
                 Position);
        return FALSE;
    }
#endif

    try
    {
        pEventRecord = (PEVENTLOGRECORD)Position;

        //
        // Verify that the pointer is within the range of BEGINNING->END
        //
        if ( fCheckBeginEndRange )
        {
            fValid = IsPositionWithinRange(Position,
                                           BeginningRecord,
                                           EndingRecord,
										   PhysicalEOF,
										   BaseAddress);
        }

        //
        // If the offset looks OK, then examine the lengths at the beginning
        // and end of the current record. If they don't match, then the position
        // is invalid.
        //
        if (fValid)
        {
            //
            // Make sure the length is a multiple number of DWORDS
            //
            if (pEventRecord->Length & 3)
            {
                fValid = FALSE;
            }
            else
            {
                pEndRecordLength = (PULONG) ((PBYTE) Position + pEventRecord->Length) - 1;

                //
                // If the file is wrapped, adjust the pointer to reflect the
                // portion of the record that is wrapped starting after the
                // header
                //
                if ((PVOID) pEndRecordLength >= PhysicalEOF)
                {
                   pEndRecordLength = (PULONG) ((PBYTE) BaseAddress +
                                                ((PBYTE) pEndRecordLength - (PBYTE) PhysicalEOF) +
                                                FILEHEADERBUFSIZE);
                }

				// Do a sanity check on this pointer before dereferencing.  DAVJ

                if ((PVOID) pEndRecordLength > PhysicalEOF)
				{
					return FALSE;
				}

                if (pEventRecord->Length == *pEndRecordLength
                     &&
                    pEventRecord->Length == ELFEOFRECORDSIZE)
                {
                    ULONG Size;

                    Size = min(ELFEOFUNIQUEPART,
                               (ULONG) ((PBYTE) PhysicalEOF - (PBYTE) pEventRecord));

                    if (RtlCompareMemory(pEventRecord,
                                         &EOFRecord,
                                         Size) == Size)
                    {
                        Size = ELFEOFUNIQUEPART - Size;

                        //
                        // If Size is non-zero, then the unique portion of
                        // the EOF record is wrapped across the end of file.
                        // Continue comparison at file beginning for the
                        // remainder of the record.
                        //
                        if ( Size )
                        {
                            PBYTE pRemainder = (PBYTE) &EOFRecord + ELFEOFUNIQUEPART - Size;

                            fValid = (RtlCompareMemory((PBYTE) BaseAddress + FILEHEADERBUFSIZE,
                                                       pRemainder,
                                                       Size) == Size);
                        }
                    }
                    else
                    {
                        fValid = FALSE;
                    }
                }
                else if ((pEventRecord->Length < sizeof(EVENTLOGRECORD))
                           ||
                         (pEventRecord->Reserved != ELF_LOG_FILE_SIGNATURE)
                           ||
                         (pEventRecord->Length != *pEndRecordLength))
                {
                    fValid = FALSE;
                }
            }
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG2(ERROR,
                 "ValidFilePos: Exception %#x caught validating file position %p\n",
                 GetExceptionCode(),
                 BeginningRecord);

       fValid = FALSE;
    }

    return fValid;
}


BOOL
IsPositionWithinRange(
    PVOID Position,
    PVOID BeginningRecord,
    PVOID EndingRecord,
	PVOID PhysEOF,
	PVOID BaseAddress
    )
{
    //
    // Verify that the pointer is within the range of [Beginning, End]
    //
    
	//This check was introduced to make sure that the position does not 
	//cross the file boundaries. Refer to Bug #370063. If required, one 
	//can change this check to make sure that the position lies between 
	//PhyStart i.e. BaseAddress + FILEHEADERBUFSIZE

	if((Position < BaseAddress) || (Position > PhysEOF))
		return FALSE;

	else if (EndingRecord > BeginningRecord)
    {
        return ((Position >= BeginningRecord) && (Position <= EndingRecord));
    }
    else if (EndingRecord < BeginningRecord)
    {
        return ((Position >= BeginningRecord) || (Position <= EndingRecord));
    }

    //
    // If BeginningRecord and EndingRecord are equal, it means that the only
    // record in the log file is the EOF record.  In that case, return FALSE
    // as Position isn't pointing to a valid (i.e., non-EOF) record.
    //
    return FALSE;
}


PVOID
FindStartOfNextRecord (
    PVOID Position,
    PVOID BeginningRecord,
    PVOID EndingRecord,
    PVOID PhysicalStart,
    PVOID PhysicalEOF,
    PVOID BaseAddress
    )

/*++

Routine Description:

    This routine starts at Position, and finds the beginning of the next
    valid record, wrapping around the physical end of the file if necessary.

Arguments:

    Position        - Pointer at which to start the search.
    BeginningRecord - Pointer to the beginning record in the file.
    EndingRecord    - Pointer to the byte after the ending record in the file.
    PhysicalStart   - Pointer to the start of log information (after header)
    PhysicalEOF     - Pointer to the physical end of the log.
    BaseAddress     - Pointer to the physical beginning of the log.

Return Value:

    A pointer to the start of the next valid record, NULL if there is no
    valid record.

Note:

    There is a possibility of error if a record just happens to have the
    ULONG at the current position the same as the value that number of
    bytes further on in the record. However, this is a very slim chance
    as it must have a valid log signature as well.

--*/
{
    PULONG ptr;
    PULONG EndOfBlock;
    PULONG EndOfFile;
    PVOID  pRecord;
    ULONG  Size;
    BOOL   StillLooking = TRUE;

    //
    // Search for a ULONG which matches a record signature
    //
    ptr = (PULONG) Position;
    EndOfBlock = EndOfFile = (PULONG) PhysicalEOF - 1;

    while (StillLooking)
    {
        //
        // Check to see if it is the EOF record
        //
        if (*ptr == ELFEOFRECORDSIZE)
        {
            //
            // Only scan up to the end of the file.  Just compare up the
            // constant information
            //

            //
            // BUGBUG:  If (End - pEvent) is less than ELFEOFUNIQUEPART,
            //          we never validate what should be the remainder of
            //          the EOF record at the start of the logfile
            //
            Size = min(ELFEOFUNIQUEPART,
                       (ULONG) ((PBYTE) PhysicalEOF - (PBYTE) ptr));

            pRecord = CONTAINING_RECORD(ptr,
                                        ELF_EOF_RECORD,
                                        RecordSizeBeginning);

            if (RtlCompareMemory(pRecord,
                                 &EOFRecord,
                                 Size) == Size)
            {
                ELF_LOG1(FILES,
                         "FindStartOfNextRecord: Found EOF record at %p\n",
                         pRecord);

                //
                // This is the EOF record, back up to the last record
                //
                (PBYTE) pRecord -= *((PULONG) pRecord - 1);

                if (pRecord < PhysicalStart)
                {
                    pRecord = (PBYTE) PhysicalEOF -
                                   ((PBYTE)PhysicalStart - (PBYTE)pRecord);
                }
            }

            if (ValidFilePos(pRecord,
                             BeginningRecord,
                             EndingRecord,
                             PhysicalEOF,
                             BaseAddress,
                             TRUE))
            {
                ELF_LOG1(FILES,
                         "FindStartOfNextRecord: Valid record at %p preceding EOF record\n",
                         pRecord);

                return pRecord;
            }
        }

        //
        // Check to see if it is an event record
        //
        if (*ptr == ELF_LOG_FILE_SIGNATURE)
        {
            //
            // This is a signature, see if the containing record is valid
            //
            pRecord = CONTAINING_RECORD(ptr,
                                        EVENTLOGRECORD,
                                        Reserved);

            if (ValidFilePos(pRecord,
                             BeginningRecord,
                             EndingRecord,
                             PhysicalEOF,
                             BaseAddress,
                             TRUE))
            {
                ELF_LOG1(FILES,
                         "FindStartOfNextRecord: Valid record found at %p\n",
                         pRecord);

                return pRecord;
            }
        }

        //
        // Bump to the next byte and see if we're done.
        //
        ptr++;

        if (ptr >= EndOfBlock)
        {
            //
            // Need the second test on this condition in case Position
            // happens to equal PhysicalEOF - 1 (EndOfBlock initial value);
            // without this, this loop would terminate prematurely.
            //
            if ((EndOfBlock == (PULONG) Position)
                  &&
                ((PULONG) Position != EndOfFile))
            {
                //
                // This was the top half, so we're done
                //
                StillLooking = FALSE;

                ELF_LOG0(FILES,
                         "FindStartOfNextRecord: Unsuccessfully searched "
                             "top half of file\n");
            }
            else
            {
                //
                // This was the bottom half, let's look in the top half
                //
                EndOfBlock = (PULONG) Position;
                ptr = (PULONG) PhysicalStart;

                ELF_LOG0(FILES,
                         "FindStartOfNextRecord: Unsuccessfully searched "
                             "bottom half of file -- searching top half\n");
            }
        }
    }

    //
    // Didn't find a valid record
    //
    return NULL;
}


PVOID
NextRecordPosition (
    ULONG   ReadFlags,
    PVOID   CurrPosition,
    ULONG   CurrRecordLength,
    PVOID   BeginRecord,
    PVOID   EndRecord,
    PVOID   PhysicalEOF,
    PVOID   PhysStart
    )

/*++

Routine Description:

    This routine seeks to the beginning of the next record to be read
    depending on the flags in the request packet.

Arguments:

    ReadFlags        - Read forwards or backwards
    CurrPosition     - Pointer to the current position.
    CurrRecordLength - Length of the record at the last position read.
    BeginRecord      - Logical first record
    EndRecord        - Logical last record (EOF record)
    PhysEOF          - End of file
    PhysStart        - Start of file pointer (following file header).

Return Value:

    New position or NULL if invalid record.

Note:


--*/
{

    PVOID       NewPosition;
    ULONG       Length;
    PDWORD      FillDword;

    if (ReadFlags & EVENTLOG_FORWARDS_READ)
    {
        //
        // If we're pointing at the EOF record, just set the position to
        // the first record
        //
        if (CurrRecordLength == ELFEOFRECORDSIZE)
        {
            ELF_LOG1(FILES,
                     "NextRecordPosition: Pointing to EOF record -- returning "
                         "address of first record (%p)\n",
                     BeginRecord);

            return BeginRecord;
        }

        NewPosition = (PVOID) ((ULONG_PTR) CurrPosition + CurrRecordLength);

        //
        // Take care of wrapping.
        //
        if (NewPosition >= PhysicalEOF)
        {
            NewPosition = (PBYTE)PhysStart
                               + ((PBYTE) NewPosition - (PBYTE) PhysicalEOF);
        }

        //
        // If this is a ELF_SKIP_DWORD, skip to the top of the file
        //
        if (*(PDWORD) NewPosition == ELF_SKIP_DWORD)
        {
           NewPosition = PhysStart;
        }
    }
    else
    {
        //
        // Reading backwards.
        //
        ASSERT (ReadFlags & EVENTLOG_BACKWARDS_READ);

        if (CurrPosition == BeginRecord)
        {
            //
            // This is the "end of file" if we're reading backwards.
            //
            ELF_LOG1(FILES,
                     "NextRecordPosition: Reading backwards and pointing to first "
                         "record -- returning address of last record (%p)\n",
                     EndRecord);

            return EndRecord;
        }
        else if (CurrPosition == PhysStart)
        {
           //
           // Flip to the bottom of the file, but skip and ELF_SKIP_DWORDs
           //
           FillDword = (PDWORD) PhysicalEOF; // last dword
           FillDword--;

           while (*FillDword == ELF_SKIP_DWORD)
           {
              FillDword--;
           }

           CurrPosition = (PVOID) (FillDword + 1);
        }

        Length = *((PULONG) CurrPosition - 1);

        if (Length < ELFEOFRECORDSIZE)
        {
            //
            // Bogus length, must be invalid record
            //
            ELF_LOG1(FILES,
                     "NextRecordPosition: Invalid record length (%d) encountered\n",
                     Length);

            return NULL;
        }

        NewPosition = (PBYTE) CurrPosition - Length;

        //
        // Take care of wrapping
        //

        if (NewPosition < PhysStart)
        {
            NewPosition = (PBYTE) PhysicalEOF
                               - ((PBYTE) PhysStart - (PBYTE) NewPosition);
        }
    }

    return NewPosition;
}



NTSTATUS
SeekToStartingRecord (
    PELF_REQUEST_RECORD Request,
    PVOID   *ReadPosition,
    PVOID   BeginRecord,
    PVOID   EndRecord,
    PVOID   PhysEOF,
    PVOID   PhysStart
    )
/*++

Routine Description:

    This routine seeks to the correct position as indicated in the
    request packet.

Arguments:

    Pointer to the request packet.
    Pointer to a pointer where the final position after the seek is returned.

Return Value:

    NTSTATUS and new position in file.

Note:

    This routine ensures that it is possible to seek to the position
    specified in the request packet. If not, then an error is returned
    which indicates that the file probably changed between the two
    READ operations, or else the record offset specified is beyond the
    end of the file.

--*/
{
    PVOID       Position;
    ULONG       RecordLen;
    ULONG       NumRecordsToSeek;
    ULONG       BytesPerRecord;
    ULONG       NumberOfRecords;
    ULONG       NumberOfBytes;
    ULONG       ReadFlags;

    //
    // If the beginning and the end are the same, then there are no
    // entries in this file.
    //
    if (BeginRecord == EndRecord)
    {
        ELF_LOG1(FILES,
                 "SeekToStartingRecord: %ws log is empty\n",
                 Request->Module->ModuleName);

        return STATUS_END_OF_FILE;
    }

    //
    // Find the last position (or the "beginning" if this is the first READ
    // call for this handle).
    //
    if (Request->Pkt.ReadPkt->ReadFlags & EVENTLOG_SEQUENTIAL_READ)
    {
        if (Request->Pkt.ReadPkt->ReadFlags & EVENTLOG_FORWARDS_READ)
        {
            //
            // If this is the first READ operation, LastSeekPosition will
            // be zero. In that case, we set the position to the first
            // record (in terms of time) in the file.
            //
            if (Request->Pkt.ReadPkt->LastSeekPos == 0)
            {
                ELF_LOG1(FILES,
                         "SeekToStartingRecord: First read (forwards) of %ws log\n",
                         Request->Module->ModuleName);

                Position = BeginRecord;
            }
            else
            {
                Position = (PBYTE) Request->LogFile->BaseAddress
                                + Request->Pkt.ReadPkt->LastSeekPos;

                //
                // If we're changing the direction we're reading, skip
                // forward one record.  This is because we're pointing at
                // the "next" record based on the last read direction
                //
                if (!(Request->Pkt.ReadPkt->Flags & ELF_LAST_READ_FORWARD))
                {
                    Position = NextRecordPosition(Request->Pkt.ReadPkt->ReadFlags,
                                                  Position,
                                                  ((PEVENTLOGRECORD) Position)->Length,
                                                  BeginRecord,
                                                  EndRecord,
                                                  PhysEOF,
                                                  PhysStart);
                }
                else
                {
                    //
                    // This *really* cheesy check exists to handle the case
                    // where Position could be on an ELF_SKIP_DWORD pad
                    // dword at end of the file.
                    //
                    // NB:  Must be prepared to handle an exception since
                    //      a somewhat unknown pointer is dereferenced.
                    //
                    NTSTATUS Status = STATUS_SUCCESS;

                    try
                    {
                        if (IsPositionWithinRange(Position,
                                                  BeginRecord,
                                                  EndRecord,
												  PhysEOF,
                                                  Request->LogFile->BaseAddress))
                        {
                            //
                            // If this is an ELF_SKIP_DWORD, skip to the
                            // top of the file.
                            //
                            if (*(PDWORD) Position == ELF_SKIP_DWORD)
                            {
                                ELF_LOG1(FILES,
                                         "SeekToStartingRecord: Next forward read position "
                                             "in %ws log is on an ELF_SKIP_DWORD\n",
                                         Request->Module->ModuleName);

                                Position = PhysStart;
                            }
                        }
                        else
                        {
                            //
                            // More likely the caller's handle was invalid
                            // if the position was not within range.
                            //
                            ELF_LOG1(ERROR,
                                     "SeekToStartingRecord: Next forward read position "
                                         "in %ws log is out of range -- log is corrupt\n",
                                     Request->Module->ModuleName);

                            Status = STATUS_INVALID_HANDLE;
                        }
                    }
                    except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        ELF_LOG2(ERROR,
                                 "SeekToStartingRecord: Caught exception %#x looking for "
                                     "next forward read position in %ws log\n",
                                 GetExceptionCode(),
                                 Request->Module->ModuleName);

                        Status = STATUS_EVENTLOG_FILE_CORRUPT;
                    }

                    if (!NT_SUCCESS(Status))
                    {
                        *ReadPosition = NULL;
                        return Status;
                    }
                }
            }
        }
        else
        {
            //
            // READ backwards
            //

            // If this is the first READ operation, LastSeekPosition will
            // be zero. In that case, we set the position to the last
            // record (in terms of time) in the file.
            //
            if (Request->Pkt.ReadPkt->LastSeekPos == 0)
            {
                ELF_LOG1(FILES,
                         "SeekToStartingRecord: First read (backwards) of %ws log\n",
                         Request->Module->ModuleName);

                Position = EndRecord;

                //
                // Subtract the length of the last record from the current
                // position to get to the beginning of the record.
                //
                // If that moves beyond the physical beginning of the file,
                // then we need to wrap around to the physical end of the file.
                //
                Position = (PBYTE) Position - *((PULONG) Position - 1);

                if (Position < PhysStart)
                {
                    Position = (PBYTE) PhysEOF - ((PBYTE) PhysStart - (PBYTE) Position);
                }
            }
            else
            {
                Position = (PBYTE) Request->LogFile->BaseAddress
                                + Request->Pkt.ReadPkt->LastSeekPos;

                //
                // If we're changing the direction we're reading, skip
                // forward one record.  This is because we're pointing at
                // the "next" record based on the last read direction
                //
                if (Request->Pkt.ReadPkt->Flags & ELF_LAST_READ_FORWARD)
                {
                    Position = NextRecordPosition(Request->Pkt.ReadPkt->ReadFlags,
                                                  Position,
                                                  0,          // not used if reading backwards
                                                  BeginRecord,
                                                  EndRecord,
                                                  PhysEOF,
                                                  PhysStart);
                }
            }
        }
    }
    else if (Request->Pkt.ReadPkt->ReadFlags & EVENTLOG_SEEK_READ)
    {
        //
        // Make sure the record number passed in is valid
        //
        if (Request->Pkt.ReadPkt->RecordNumber < Request->LogFile->OldestRecordNumber
             ||
            Request->Pkt.ReadPkt->RecordNumber >= Request->LogFile->CurrentRecordNumber)
        {
            ELF_LOG1(ERROR,
                     "SeekToStartingRecord: Invalid record number %d\n",
                     Request->Pkt.ReadPkt->RecordNumber);

            return STATUS_INVALID_PARAMETER;
        }

        //
        // We're seeking to an absolute record number, so use the following
        // algorithm:
        //
        //   1. Calculate the average number of bytes per record
        //
        //   2. Based on this number seek to where the record should start
        //
        //   3. Find the start of the next record in the file
        //
        //   4. Walk (forwards or backwards) from there to the right record
        //

        //
        // 1. Calculate the average number of bytes per record
        //
        NumberOfRecords = Request->LogFile->CurrentRecordNumber
                              - Request->LogFile->OldestRecordNumber;

        NumberOfBytes = Request->LogFile->Flags & ELF_LOGFILE_HEADER_WRAP ?
                            Request->LogFile->ActualMaxFileSize :
                            Request->LogFile->EndRecord;

        NumberOfBytes -= FILEHEADERBUFSIZE;
        BytesPerRecord = NumberOfBytes / NumberOfRecords;

        //
        // 2. Calcuate the first guess as to what the offset of the desired
        //    record should be
        //
        Position = (PBYTE) Request->LogFile->BaseAddress
                        + Request->LogFile->BeginRecord
                        + BytesPerRecord
                            * (Request->Pkt.ReadPkt->RecordNumber
                                   - Request->LogFile->OldestRecordNumber);

        //
        // Align the position to a ULONG bountry.
        //
        Position = (PVOID) (((ULONG_PTR) Position + sizeof(ULONG) - 1) & ~(sizeof(ULONG) - 1));

        //
        // Take care of file wrap
        //
        if (Position >= PhysEOF)
        {
            Position = (PBYTE)PhysStart +
                            ((PBYTE) Position - (PBYTE) PhysEOF);

            if (Position >= PhysEOF)
            {
                //
                // It's possible, in an obscure error case, that Position
                // may still be beyond the EOF. Adjust, if so.
                //
                Position = BeginRecord;
            }
        }

        //
        // Bug fix:
        //
        // 57017 - Event Log Causes Services.Exe to Access Violate therefore
        //         Hanging the Server
        //
        // The calculation above can easily put Position out of range of
        // the begin/end file markers. This is not good. Adjust Position,
        // if necessary.
        //
        if (BeginRecord < EndRecord && Position >= EndRecord)
        {
            Position = BeginRecord;
        }
        else if (BeginRecord > EndRecord && Position >= EndRecord && Position < BeginRecord)
        {
            Position = BeginRecord;
        }
        else
        {
            // Do nothing.
        }

        //
        // 3. Get to the start of the next record after Position
        //
        Position = FindStartOfNextRecord(Position,
                                         BeginRecord,
                                         EndRecord,
                                         PhysStart,
                                         PhysEOF,
                                         Request->LogFile->BaseAddress);

        //
        //   4. Walk (forwards or backwards) from Position to the right record
        //
        if (Position)
        {
            if (Request->Pkt.ReadPkt->RecordNumber >
                    ((PEVENTLOGRECORD) Position)->RecordNumber)
            {
                NumRecordsToSeek = Request->Pkt.ReadPkt->RecordNumber
                                       - ((PEVENTLOGRECORD) Position)->RecordNumber;

                ReadFlags = EVENTLOG_FORWARDS_READ;

                ELF_LOG2(FILES,
                         "SeekToStartingRecord: Walking forward %d records from record %d\n",
                         NumRecordsToSeek,
                         ((PEVENTLOGRECORD) Position)->RecordNumber);
            }
            else
            {
                NumRecordsToSeek = ((PEVENTLOGRECORD) Position)->RecordNumber
                                        - Request->Pkt.ReadPkt->RecordNumber;

                ReadFlags = EVENTLOG_BACKWARDS_READ;

                ELF_LOG2(FILES,
                         "SeekToStartingRecord: Walking backward %d records from record %d\n",
                         NumRecordsToSeek,
                         ((PEVENTLOGRECORD) Position)->RecordNumber);
            }
        }

        while (Position != NULL && NumRecordsToSeek--)
        {
            RecordLen = ((PEVENTLOGRECORD) Position)->Length;

            Position = NextRecordPosition(ReadFlags,
                                          Position,
                                          RecordLen,
                                          BeginRecord,
                                          EndRecord,
                                          PhysEOF,
                                          PhysStart);
        }
    }
    else
    {
        //
        // Flags didn't specify a sequential or seek read
        //
        return STATUS_INVALID_PARAMETER;
    }

    *ReadPosition = Position;       // This is the new seek position

    if (!Position)
    {
        //
        // The record was invalid
        //
        ELF_LOG1(ERROR,
                 "SeekToStartingRecord: Position is NULL -- %ws log is corrupt\n",
                 Request->Module->ModuleName);

        return STATUS_EVENTLOG_FILE_CORRUPT;
    }

    return STATUS_SUCCESS;
}


VOID
CopyRecordToBuffer(
    IN     PBYTE       pReadPosition,
    IN OUT PBYTE       *ppBufferPosition,
    IN     ULONG       ulRecordSize,
    IN     PBYTE       pPhysicalEOF,
    IN     PBYTE       pPhysStart
    )

/*++

Routine Description:

    This routine copies the EVENTLOGRECORD at pReadPosition into
    *ppBufferPosition

Return Value:

    None.

--*/
{
    ULONG       ulBytesToMove;    // Number of bytes to copy

    ASSERT(ppBufferPosition != NULL);

    //
    // If the number of bytes to the end of the file is less than the
    // size of the record, then part of the record has wrapped to the
    // beginning of the file - transfer the bytes piece-meal.
    //
    // Otherwise, transfer the whole record.
    //
    ulBytesToMove = min(ulRecordSize,
                        (ULONG) (pPhysicalEOF - pReadPosition));

    if (ulBytesToMove < ulRecordSize)
    {
        //
        // We need to copy the bytes up to the end of the file,
        // and then wrap around and copy the remaining bytes of
        // this record.
        //
        RtlMoveMemory(*ppBufferPosition, pReadPosition, ulBytesToMove);

        //
        // Advance user buffer pointer, move read position to the
        // beginning of the file (past the file header), and
        // update bytes remaining to be moved for this record.
        //
        *ppBufferPosition += ulBytesToMove;

        pReadPosition = pPhysStart;

        ulBytesToMove = ulRecordSize - ulBytesToMove;     // Remaining bytes
    }

    //
    // Move the remaining bytes of the record OR the full record.
    //
    RtlMoveMemory(*ppBufferPosition, pReadPosition, ulBytesToMove);

    //
    // Update to new read positions
    //
    *ppBufferPosition += ulBytesToMove;
}


NTSTATUS
ReadFromLog(
    PELF_REQUEST_RECORD Request
    )
/*++

Routine Description:

    This routine reads from the event log specified in the request packet.

    This routine uses memory mapped I/O to access the log file. This makes
    it much easier to move around the file.

Arguments:

    Pointer to the request packet.

Return Value:

    NTSTATUS.

Note:

--*/
{
    NTSTATUS    Status;
    PVOID       ReadPosition;           // Current read position in file
    PVOID       BufferPosition;         // Current position in user's buffer
    ULONG       TotalBytesRead;         // Total Bytes transferred
    ULONG       TotalRecordsRead;       // Total records transferred
    ULONG       BytesInBuffer;          // Bytes remaining in buffer
    ULONG       RecordSize;             // Size of event record
    PVOID       PhysicalEOF;            // Physical end of file
    PVOID       PhysStart;              // Physical start of file (after file hdr)
    PVOID       BeginRecord;            // Points to first record
    PVOID       EndRecord;              // Points to byte after last record
    PVOID       TempBuf = NULL, TempBufferPosition;
    ULONG       RecordBytesTransferred;
    PEVENTLOGRECORD pEvent;
    PVOID LastReadPosition;

    //
    // Initialize variables.
    //
    BytesInBuffer    = Request->Pkt.ReadPkt->BufferSize;
    BufferPosition   = Request->Pkt.ReadPkt->Buffer;
    TotalBytesRead   = 0;
    TotalRecordsRead = 0;

    PhysicalEOF = (LPBYTE) Request->LogFile->BaseAddress
                       + Request->LogFile->ViewSize;

    PhysStart   = (LPBYTE) Request->LogFile->BaseAddress
                       + FILEHEADERBUFSIZE;

    BeginRecord = (LPBYTE) Request->LogFile->BaseAddress
                       + Request->LogFile->BeginRecord;   // Start at first record

    EndRecord   = (LPBYTE) Request->LogFile->BaseAddress
                       + Request->LogFile->EndRecord;     // Byte after end of last record

    //
    // "Seek" to the starting record depending on either the last seek
    // position, or the starting record offset passed in.
    //
    Status = SeekToStartingRecord(Request,
                                  &ReadPosition,
                                  BeginRecord,
                                  EndRecord,
                                  PhysicalEOF,
                                  PhysStart);

    if (NT_SUCCESS(Status))
    {
        //
        // Make sure the record is valid
        //

        if (!ValidFilePos(ReadPosition,
                          BeginRecord,
                          EndRecord,
                          PhysicalEOF,
                          Request->LogFile->BaseAddress,
                          TRUE))
        {
            ELF_LOG1(ERROR,
                     "ReadFromLog: Next record (%p) is not valid -- log is corrupt\n",
                     ReadPosition);

            Request->Pkt.ReadPkt->BytesRead = 0;
            Request->Pkt.ReadPkt->RecordsRead = 0;

            return STATUS_INVALID_HANDLE;
        }

        // make sure that if we asked for a specific record, that we got it

        if ((Request->Pkt.ReadPkt->ReadFlags & EVENTLOG_SEEK_READ) &&
            (Request->Pkt.ReadPkt->ReadFlags & EVENTLOG_BACKWARDS_READ))
        {
            pEvent = (PEVENTLOGRECORD)ReadPosition;
            if(pEvent->Length == ELFEOFRECORDSIZE || 
               pEvent->RecordNumber != Request->Pkt.ReadPkt->RecordNumber)
            {
                Request->Pkt.ReadPkt->BytesRead = 0;
                Request->Pkt.ReadPkt->RecordsRead = 0;
                return STATUS_EVENTLOG_FILE_CORRUPT;
            }
        }


        RecordSize = RecordBytesTransferred = *(PULONG) ReadPosition;

        if ((Request->Pkt.ReadPkt->Flags & ELF_IREAD_ANSI)
              &&
            (RecordSize != ELFEOFRECORDSIZE))
        {
            //
            //
            // If we were called by an ANSI API, then we need to read the
            // next record into a temporary buffer, process the data in
            // that record and copy it over to the real buffer as ANSI
            // strings (rather than UNICODE).
            //
            // We need to do this here since we won't be able to
            // appropriately size a record that wraps for an ANSI
            // call otherwise (we'll AV trying to read it past
            // the end of the log).
            //
            TempBuf = ElfpAllocateBuffer(RecordSize);

            if (TempBuf == NULL)
            {
                ELF_LOG0(ERROR,
                         "ReadFromLog: Unable to allocate memory for "
                             "Ansi record (1st call)\n");

                return STATUS_NO_MEMORY;
            }

            TempBufferPosition = BufferPosition;    // Save this away
            BufferPosition     = TempBuf;           // Read into TempBuf

            try
            {
                CopyRecordToBuffer((PBYTE) ReadPosition,
                               (PBYTE *) &BufferPosition,
                               RecordSize,
                               (PBYTE) PhysicalEOF,
                               (PBYTE) PhysStart);
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                Status = STATUS_UNSUCCESSFUL;
                ELF_LOG0(ERROR,
                         "ReadFromLog: CopyRecordToBuffer failed");
                ElfpFreeBuffer(TempBuf);
                return Status;
            }

            //
            // Call CopyUnicodeToAnsiRecord with a NULL destination
            // location in order to get the size of the Ansi record
            //
            Status = CopyUnicodeToAnsiRecord(NULL,
                                             TempBuf,
                                             NULL,
                                             &RecordBytesTransferred);

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG1(ERROR,
                         "ReadFromLog: CopyUnicodeToAnsiRecord failed %#x (1st call)\n",
                         Status);

                ElfpFreeBuffer(TempBuf);
                return Status;
            }
        }

        //
        // While there are records to be read, and more space in the buffer,
        // keep on reading records into the buffer.
        //
        while((RecordBytesTransferred <= BytesInBuffer)
                &&
              (RecordSize != ELFEOFRECORDSIZE))
        {
            //
            // If we were called by an ANSI API, then we need to take the
            // record read into TempBuf and transfer it over to the user's
            // buffer while converting any UNICODE strings to ANSI.
            //
            if (Request->Pkt.ReadPkt->Flags & ELF_IREAD_ANSI)
            {
                Status = CopyUnicodeToAnsiRecord(TempBufferPosition,
                                                 TempBuf,
                                                 &BufferPosition,
                                                 &RecordBytesTransferred);

                //
                // RecordBytesTransferred contains the bytes actually
                // copied into the user's buffer.
                //
                // BufferPosition points to the point in the user's buffer
                // just after this record.
                //
                ElfpFreeBuffer(TempBuf);
                TempBuf = NULL;

                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG1(ERROR,
                             "ReadFromLog: CopyUnicodeToAnsiRecord failed %x "
                                 "(2nd call)\n",
                             Status);

                    //
                    // Stop reading
                    //
                    break;
                }
            }
            else
            {
                //
                // Unicode call -- simply copy the record into the buffer
                //
                CopyRecordToBuffer((PBYTE) ReadPosition,
                                   (PBYTE *) &BufferPosition,
                                   RecordSize,
                                   (PBYTE) PhysicalEOF,
                                   (PBYTE) PhysStart);
            }

            //
            // Update the byte and record counts
            //
            TotalRecordsRead++;
            TotalBytesRead += RecordBytesTransferred;
            BytesInBuffer  -= RecordBytesTransferred;
            LastReadPosition = ReadPosition;
            
            ReadPosition = NextRecordPosition(Request->Pkt.ReadPkt->ReadFlags,
                                              ReadPosition,
                                              RecordSize,
                                              BeginRecord,
                                              EndRecord,
                                              PhysicalEOF,
                                              PhysStart);

            //
            // Make sure the record is valid
            //
            if (ReadPosition == NULL
                 ||
                !ValidFilePos(ReadPosition,
                              BeginRecord,
                              EndRecord,
                              PhysicalEOF,
                              Request->LogFile->BaseAddress,
                              TRUE))
            {
                ELF_LOG0(ERROR,
                         "ReadFromLog: Next record is invalid -- log is corrupt\n");

                return STATUS_EVENTLOG_FILE_CORRUPT;
            }

            RecordSize = RecordBytesTransferred = *(PULONG) ReadPosition;

            if ((Request->Pkt.ReadPkt->Flags & ELF_IREAD_ANSI)
                  &&
                (RecordSize != ELFEOFRECORDSIZE))
            {
                TempBuf = ElfpAllocateBuffer(RecordSize);

                if (TempBuf == NULL)
                {
                    ELF_LOG0(ERROR,
                             "ReadFromLog: Unable to allocate memory for "
                                 "Ansi record (2nd call)\n");

                    return STATUS_NO_MEMORY;
                }

                TempBufferPosition = BufferPosition;    // Save this away
                BufferPosition     = TempBuf;           // Read into TempBuf

                try
                {
                    CopyRecordToBuffer((PBYTE) ReadPosition,
                                   (PBYTE *) &BufferPosition,
                                   RecordSize,
                                   (PBYTE) PhysicalEOF,
                                   (PBYTE) PhysStart);
                }
                except (EXCEPTION_EXECUTE_HANDLER)
                {
                    Status = STATUS_UNSUCCESSFUL;
                    ELF_LOG0(ERROR,
                             "ReadFromLog: CopyRecordToBuffer failed");
                    ElfpFreeBuffer(TempBuf);
                    return Status;
                }

                //
                // Call CopyUnicodeToAnsiRecord with a NULL destination
                // location in order to get the size of the Ansi record
                //
                Status = CopyUnicodeToAnsiRecord(NULL,
                                                 TempBuf,
                                                 NULL,
                                                 &RecordBytesTransferred);

                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG1(ERROR,
                             "ReadFromLog: CopyUnicodeToAnsiRecord failed %#x "
                                 "(1st call)\n",
                             Status);

                    ElfpFreeBuffer(TempBuf);
                    return Status;
                }
            }
        } // while

        ElfpFreeBuffer(TempBuf);
        TempBuf = NULL;

        //
        // If we got to the end and did not read in any records, return
        // an error indicating that the user's buffer is too small if
        // we're not at the EOF record, or end of file if we are.
        //
        if (TotalRecordsRead == 0)
        {
            if (RecordSize == ELFEOFRECORDSIZE)
            {
                ELF_LOG0(FILES,
                         "ReadFromLog: No records read -- pointing at EOF record\n");

                Status = STATUS_END_OF_FILE;
            }
            else
            {
                //
                // We didn't read any records, and we're not at EOF, so
                // the buffer was too small
                //

                Status = STATUS_BUFFER_TOO_SMALL;
                Request->Pkt.ReadPkt->MinimumBytesNeeded = RecordBytesTransferred;
            }
        }

        //
        // Update the current file position.
        //
        Request->Pkt.ReadPkt->LastSeekPos =
                                (ULONG) ((ULONG_PTR) ReadPosition
                                             - (ULONG_PTR) Request->LogFile->BaseAddress);

        Request->Pkt.ReadPkt->LastSeekRecord += TotalRecordsRead;

        ELF_LOG1(FILES,
                 "ReadFromLog: %d records successfully read\n",
                 TotalRecordsRead);
    }
    else
    {
        ELF_LOG1(ERROR,
                 "ReadFromLog: SeekToStartingRecord failed %#x\n",
                 Status);
    }

    //
    // Set the bytes read in the request packet for return to client.
    //
    Request->Pkt.ReadPkt->BytesRead   = TotalBytesRead;
    Request->Pkt.ReadPkt->RecordsRead = TotalRecordsRead;

    return Status;
}




VOID
PerformReadRequest(
    PELF_REQUEST_RECORD Request
    )

/*++

Routine Description:

    This routine performs the READ request.
    It first grabs the log file structure resource and then proceeds
    to read from the file. If the resource is not available, it will
    block until it is.

    This routine impersonates the client in order to ensure that the correct
    access control is uesd. If the client does not have permission to read
    the file, the operation will fail.

Arguments:

    Pointer to the request packet.

Return Value:

    NONE

Note:


--*/
{
    NTSTATUS Status;

    //
    // Get shared access to the log file. This will allow multiple
    // readers to get to the file together.
    //
    RtlAcquireResourceShared(&Request->Module->LogFile->Resource,
                             TRUE);                  // Wait until available
    Request->Pkt.ReadPkt->LastSeekPos = Request->Pkt.ReadPkt->ContextHandle->SeekBytePos;
    Request->Pkt.ReadPkt->LastSeekRecord = Request->Pkt.ReadPkt->ContextHandle->SeekRecordPos;

    if(Request->Module->LogFile->bHosedByClear)
    {
        Status = ElfOpenLogFile(Request->Module->LogFile, ElfNormalLog);
        if(NT_SUCCESS(Status))
           Request->Module->LogFile->bHosedByClear = FALSE;
    }
    if(Request->Module->LogFile->BaseAddress == NULL  ||
        Request->Module->LogFile->bHosedByClear) 
    {
        Request->Status = STATUS_INVALID_HANDLE;
        RtlReleaseResource ( &Request->Module->LogFile->Resource );
        return;
    }

    //
    // Try to read from the log.  Note that a corrupt log is the
    // most likely cause of an exception (garbage pointers, etc).
    // The eventlog corruption error is a bit all-inclusive, but
    // necessary, since log state is pretty much indeterminable
    // in this situation.
    //
    try
    {
        Request->Status = ReadFromLog(Request);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG2(ERROR,
                 "PerformReadRequest: Caught exception %#x reading %ws log\n",
                 GetExceptionCode(),
                 Request->Module->ModuleName);

        Request->Status = STATUS_EVENTLOG_FILE_CORRUPT;
    }

    //
    // Update current seek positions
    //

    Request->Pkt.ReadPkt->ContextHandle->SeekRecordPos = Request->Pkt.ReadPkt->LastSeekRecord;
    Request->Pkt.ReadPkt->ContextHandle->SeekBytePos   = Request->Pkt.ReadPkt->LastSeekPos;


    //
    // Release the resource
    //
    RtlReleaseResource(&Request->Module->LogFile->Resource);
}

//
// BUGBUG: These are only used in WriteToLog and they're not modified.
//         Probably cleaner to make them #define'd constants.
//
WCHAR wszAltDosDevices[] = L"\\DosDevices\\";
WCHAR wszDosDevices[] = L"\\??\\";
#define DOSDEVICES_LEN  ((sizeof(wszDosDevices) / sizeof(WCHAR)) - 1)
#define ALTDOSDEVICES_LEN  ((sizeof(wszAltDosDevices) / sizeof(WCHAR)) - 1)


NTSTATUS
WriteToLog(
    PLOGFILE    pLogFile,
    PVOID       Buffer,
    ULONG       BufSize,
    PULONG      Destination,
    ULONG       PhysEOF,
    ULONG       PhysStart
    )

/*++

Routine Description:

    This routine writes the record into the log file, allowing for wrapping
    around the end of the file.

    It assumes that the caller has serialized access to the file, and has
    ensured that there is enough space in the file for the record.

Arguments:

    Buffer      - Pointer to the buffer containing the event record.
    BufSize     - Size of the record to be written.
    Destination - Pointer to the destination - which is in the log file.
    PhysEOF     - Physical end of file.
    PhysStart   - Physical beginning of file (past the file header).

Return Value:

    NONE.

Note:


--*/
{
    ULONG    BytesToCopy;
    SIZE_T   FlushSize;
    ULONG    NewDestination;
    NTSTATUS Status;
    PVOID    BaseAddress;
    LPWSTR   pwszLogFileName;

    LARGE_INTEGER   ByteOffset;
    IO_STATUS_BLOCK IoStatusBlock;

    BytesToCopy = min(PhysEOF - *Destination, BufSize);

    ByteOffset = RtlConvertUlongToLargeInteger(*Destination);

    Status = NtWriteFile(pLogFile->FileHandle,   // Filehandle
                         NULL,                   // Event
                         NULL,                   // APC routine
                         NULL,                   // APC context
                         &IoStatusBlock,         // IO_STATUS_BLOCK
                         Buffer,                 // Buffer
                         BytesToCopy,            // Length
                         &ByteOffset,            // Byteoffset
                         NULL);                  // Key

    if (!NT_SUCCESS(Status))
    {
        ELF_LOG1(ERROR,
                 "WriteToLog: NtWriteFile (1st call) failed %#x\n",
                 Status);
        return Status;
    }

    NewDestination = *Destination + BytesToCopy;

    if (BytesToCopy != BufSize)
    {
        //
        // Wrap around to the beginning of the file and copy the
        // rest of the data.
        //
        Buffer = (PBYTE) Buffer + BytesToCopy;

        BytesToCopy = BufSize - BytesToCopy;

        ByteOffset = RtlConvertUlongToLargeInteger(PhysStart);

        Status = NtWriteFile(pLogFile->FileHandle,   // Filehandle
                             NULL,                   // Event
                             NULL,                   // APC routine
                             NULL,                   // APC context
                             &IoStatusBlock,         // IO_STATUS_BLOCK
                             Buffer,                 // Buffer
                             BytesToCopy,            // Length
                             &ByteOffset,            // Byteoffset
                             NULL);                  // Key

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "WriteToLog: NtWriteFile (2nd call) failed %#x\n",
                     Status);
            return Status;
        }

        NewDestination = PhysStart + BytesToCopy;

        //
        // Set "wrap" bit in log file structure
        //
        pLogFile->Flags |= ELF_LOGFILE_HEADER_WRAP;

        //
        // Now flush this to disk to commit it
        //
        BaseAddress = pLogFile->BaseAddress;
        FlushSize   = FILEHEADERBUFSIZE;

        Status = NtFlushVirtualMemory(NtCurrentProcess(),
                                      &BaseAddress,
                                      &FlushSize,
                                      &IoStatusBlock);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG1(ERROR,
                     "WriteToLog: NtFlushVirtualMemory failed %#x\n",
                     Status);
            return Status;
        }
    }

    *Destination = NewDestination;          // Return new destination

    //
    // Providing all succeeded above, if not set, set the archive file
    // attribute on this log.
    //

    if (NT_SUCCESS(Status)
         &&
        !(pLogFile->Flags & ELF_LOGFILE_ARCHIVE_SET))
    {
        //
        // Advance past prefix string, '\??\' or '\DosDevices\'
        //
        if ((pLogFile->LogFileName->Length / 2) >= DOSDEVICES_LEN
              &&
            !_wcsnicmp(wszDosDevices, pLogFile->LogFileName->Buffer, DOSDEVICES_LEN))
        {
            pwszLogFileName = pLogFile->LogFileName->Buffer + DOSDEVICES_LEN;
        }
        else if ((pLogFile->LogFileName->Length / 2) >= ALTDOSDEVICES_LEN
                   &&
                  !_wcsnicmp(wszAltDosDevices, pLogFile->LogFileName->Buffer, ALTDOSDEVICES_LEN))
        {
            pwszLogFileName = pLogFile->LogFileName->Buffer + ALTDOSDEVICES_LEN;
        }
        else
        {
            pwszLogFileName = pLogFile->LogFileName->Buffer;
        }

        if (SetFileAttributes(pwszLogFileName, FILE_ATTRIBUTE_ARCHIVE))
        {
            pLogFile->Flags |= ELF_LOGFILE_ARCHIVE_SET;
        }
        else
        {
            ELF_LOG2(ERROR,
                     "WriteToLog: SetFileAttributes on file %ws failed %d\n",
                     pwszLogFileName,
                     GetLastError());
        }
    }
    return STATUS_SUCCESS;
}

void WriteLogFullMessage(PELF_REQUEST_RECORD Request,
                    PLOGFILE pLogFile, BOOL bSecurity, ULONG OverwrittenEOF)

/*++

Routine Description:

    This routine is called when an attempt to write to a full log is made and there is 
    no more room.

Arguments:

    Pointer to the request packet.
Return Value:

    NONE

Note:

--*/

{
    ULONG WritePos;               // Position to write record

    //
    // All records within retention period
    //
    ELF_LOG1(ERROR,
             "PerformWriteRequest: %ws log is full\n",
             pLogFile->LogModuleName->Buffer);

    //
    // Hang an event on the queuedevent list for later writing
    // if we haven't just written a log full event for this log.
    // Don't put up the popup during setup as there's nothing
    // the user can do about it until setup finishes.
    //

    if (pLogFile->logpLogPopup == LOGPOPUP_CLEARED
         &&
        !ElfGlobalData->fSetupInProgress && !bSecurity)
    {
        INT     StringLen, id = -1;
        LPTSTR  lpModuleNameLoc = NULL;
        HMODULE StringsResource;

        //
        //  Get the localized module name from message table
        //
        StringsResource = GetModuleHandle(L"EVENTLOG.DLL");

        ASSERT(StringsResource != NULL);

        if (_wcsicmp(pLogFile->LogModuleName->Buffer,
                     ELF_SYSTEM_MODULE_NAME) == 0)
        {
            id = ELF_MODULE_NAME_LOCALIZE_SYSTEM;
        }
        else if (_wcsicmp(pLogFile->LogModuleName->Buffer,
                          ELF_APPLICATION_MODULE_NAME) == 0)
        {
            id = ELF_MODULE_NAME_LOCALIZE_APPLICATION;
        }

        if (id != -1)
        {
            StringLen = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                      StringsResource,
                                      id,
                                      0,
                                      (LPTSTR) &lpModuleNameLoc,
                                      0,
                                      NULL);

            if ((StringLen > 1) && (lpModuleNameLoc != NULL))
            {
                //
                //  Get rid of cr/lf control code at the end
                //
                *(lpModuleNameLoc + StringLen - 2) = 0;
            }
        }

        //
        // Create the "log full" event -- use the name stored in the
        // log's default module if it's not a well-known log type
        //
        ElfpCreateElfEvent(EVENT_LOG_FULL,
                           EVENTLOG_ERROR_TYPE,
                           0,                      // EventCategory
                           1,                      // NumberOfStrings
                           (lpModuleNameLoc != NULL) ?
                               &lpModuleNameLoc :
                               &Request->LogFile->LogModuleName->Buffer,
                           NULL,                   // Data
                           0,                      // Datalength
                           ELF_FORCE_OVERWRITE,    // Overwrite if necc.
                           FALSE);                 // for security file    

        ElfpCreateQueuedMessage(
                ALERT_ELF_LogOverflow,
                1,
                (lpModuleNameLoc != NULL) ?
                    &lpModuleNameLoc :
                    &Request->Module->LogFile->LogModuleName->Buffer);

        LocalFree(lpModuleNameLoc);
    
        //
        // Don't post the popup again until either the machine is
        // rebooted or the log is cleared
        //
        pLogFile->logpLogPopup = LOGPOPUP_ALREADY_SHOWN;
    }
    else if(bSecurity)
    {
            if(pLogFile->bFullAlertDone == FALSE)
            ElfpCreateQueuedAlert(
                    ALERT_ELF_LogOverflow,
                    1,
                    &Request->Module->LogFile->LogModuleName->Buffer);
            pLogFile->bFullAlertDone = TRUE;
    }

    pLogFile->Flags |= ELF_LOGFILE_LOGFULL_WRITTEN;

    if (OverwrittenEOF)
    {
        //
        // The EOF record was at the end of the physical file,
        // and we overwrote it with ELF_SKIP_DWORDs, so we need
        // to put it back since we're not going to be able to
        // write a record.  We also need to turn the wrap bit
        // back off
        //
        pLogFile->Flags &= ~(ELF_LOGFILE_HEADER_WRAP);
        pLogFile->EndRecord = OverwrittenEOF;
        WritePos = OverwrittenEOF;

        //
        // Write out the EOF record
        //
        WriteToLog(pLogFile,
                   &EOFRecord,
                   ELFEOFRECORDSIZE,
                   &WritePos,
                   pLogFile->ActualMaxFileSize,
                   FILEHEADERBUFSIZE);
    }

}

NTSTATUS FindStartOfNextRecordInFile(PLOGFILE pLogFile, ULONG NextRecord,
                ULONG *   pSpaceAvail)
{
    NTSTATUS Status;
    ULONG SearchStartPos;
    SearchStartPos = pLogFile->BeginRecord;

    // if the record to search next is at eof, then we are done.

    if(SearchStartPos == pLogFile->EndRecord)
    {
        pLogFile->BeginRecord = pLogFile->EndRecord;
        return 0;
    }
    for(;;)
    {
        PVOID Position;

        for ( ;
             NextRecord != SearchStartPos;
             *pSpaceAvail += sizeof(ULONG), NextRecord += sizeof(ULONG))
        {
            if (NextRecord >= pLogFile->ActualMaxFileSize)
            {
                NextRecord = pLogFile->BeginRecord = FILEHEADERBUFSIZE;
            }

            if ( NextRecord == pLogFile->EndRecord)
            {
                pLogFile->BeginRecord = pLogFile->EndRecord;
                return 0;
            }

            if (*(PULONG) ((PBYTE) pLogFile->BaseAddress + NextRecord)
                     == ELF_LOG_FILE_SIGNATURE)
            {
                //
                // Found the next valid record signature
                //
                break;
            }
        }

        Position = (PULONG) ((PBYTE) pLogFile->BaseAddress + NextRecord);

        if (*(PULONG) Position == ELF_LOG_FILE_SIGNATURE)
        {
            //
            // This record is valid so far, perform a final, more
            // rigorous check for record validity.
            //
            if (ValidFilePos(CONTAINING_RECORD(Position,
                                               EVENTLOGRECORD,
                                               Reserved),
                             NULL,
                             NULL,
                             (PBYTE) pLogFile->BaseAddress
                                  + pLogFile->ViewSize,
                             pLogFile->BaseAddress,
                             FALSE))
             {
                //
                // The record is valid. Adjust SpaceAvail to not
                // include a sub-portion of this record in the
                // available space computation.
                //
                *pSpaceAvail -= sizeof(ULONG);
                pLogFile->BeginRecord = NextRecord - sizeof(ULONG);
                break;
            }
            else
            {
                //
                // Continue the search for the next valid record.
                //
                // NB : Not calling FixContextHandlesForRecord
                //      since we have not established a valid
                //      beginning record position yet. Not that
                //      it would do any good - this condition would
                //      be evaluated in cases of corrupt logs.
                //
                ELF_LOG2(FILES,
                         "PerformWriteRequest: Valid record signature with "
                             "invalid record found at offset %d of %ws log\n",
                         NextRecord,
                         pLogFile->LogModuleName->Buffer);

                *pSpaceAvail += sizeof(ULONG);
                NextRecord += sizeof(ULONG);
                continue;
            }
        }
        else
        {
            //
            // Not a single valid record can be found.  This is not
            // good.  Consider the log corrupted and bail the write.
            //
            ELF_LOG1(ERROR,
                     "PerformWriteRequest: No valid records found in %ws log\n",
                     pLogFile->LogModuleName->Buffer);

            Status = STATUS_EVENTLOG_FILE_CORRUPT;
            ASSERT(Status != STATUS_EVENTLOG_FILE_CORRUPT);
            return Status;
        }
    }
    return 0;

}

NTSTATUS
AutoBackupLogFile(PELF_REQUEST_RECORD Request, ULONG OverwrittenEOF)

/*++

Routine Description:

    This routine makes a best attempt to backup the log file.
    It will log an event in the SECURITY log file indicating
    success or failure.

Arguments:

    Pointer to the request packet.

Return Value:

    NTSTATUS

Note:

--*/
{
    UNICODE_STRING BackupFileNameU;
    WCHAR          BackupFileName[64]; // holds the "unique" part of the name (wsprintf)
    PLOGFILE       pLogFile;           // For optimized access to structure
    WCHAR          BackupFileNamePrefix[] = L"Archive-";
    WCHAR*         EventMessage[3];
    WCHAR          Number[20]; // long enough to hold a DWORD represented as a string
    SYSTEMTIME          SystemTime;
    ELF_REQUEST_RECORD  ClearRequest;
    CLEAR_PKT           ClearPkt;
    USHORT              ClearStatus;
    NTSTATUS Status;
    ULONG WritePos;               // Position to write record
    
    pLogFile = Request->LogFile;          // Set local variable

    if (OverwrittenEOF)
    {
        //
        // The EOF record was at the end of the physical file,
        // and we overwrote it with ELF_SKIP_DWORDs, so we need
        // to put it back since we're not going to be able to
        // write a record.  We also need to turn the wrap bit
        // back off
        //
        pLogFile->Flags &= ~(ELF_LOGFILE_HEADER_WRAP);
        pLogFile->EndRecord = OverwrittenEOF;
        WritePos = OverwrittenEOF;

        //
        // Write out the EOF record
        //
        WriteToLog(pLogFile,
                   &EOFRecord,
                   ELFEOFRECORDSIZE,
                   &WritePos,
                   pLogFile->ActualMaxFileSize,
                   FILEHEADERBUFSIZE);

    }
    Status = FlushLogFile(pLogFile);
    if (!NT_SUCCESS(Status))
        return Status;

    //
    // Make BackupFileNameU unique.
    // Allocate enough space for the current LogModuleName, a NULL character, 
    // and BackupFileName bytes.
    // If AutoBackupPath is non-NULL, add space for that too.
    //
    // Rename file in place.
    //
    BackupFileNameU.Length = 0;
    BackupFileNameU.MaximumLength = ((wcslen(pLogFile->LogModuleName->Buffer) +
                                      wcslen(BackupFileNamePrefix) + 1        ) * sizeof(WCHAR)) + 
                                    sizeof(BackupFileName);
    BackupFileNameU.Buffer = ElfpAllocateBuffer(BackupFileNameU.MaximumLength);
    if (BackupFileNameU.Buffer == NULL) 
    {
        ELF_LOG0(ERROR,
             "AutoBackupLogFile:  failed due to lack of memory\n");
        return STATUS_NO_MEMORY;
    }

    StringCbCopy(BackupFileNameU.Buffer, BackupFileNameU.MaximumLength, 
                                BackupFileNamePrefix); 
    StringCbCat(BackupFileNameU.Buffer, BackupFileNameU.MaximumLength, 
                                pLogFile->LogModuleName->Buffer); 
    
    GetSystemTime(&SystemTime);

    StringCchPrintfW(BackupFileName, 64, L"-%u-%02u-%02u-%02u-%02u-%02u-%03u.evt", 
        SystemTime.wYear,
        SystemTime.wMonth,
        SystemTime.wDay,
        SystemTime.wHour,
        SystemTime.wMinute,
        SystemTime.wSecond,
        SystemTime.wMilliseconds);

    StringCbCat(BackupFileNameU.Buffer, BackupFileNameU.MaximumLength,BackupFileName);
    BackupFileNameU.Length = wcslen(BackupFileNameU.Buffer) * sizeof(WCHAR);
    
    //
    // Fill in the request packet
    //

    ClearRequest.Pkt.ClearPkt = &ClearPkt;
    ClearRequest.Flags = 0;
    ClearRequest.Module = Request->Module;
    ClearRequest.LogFile = Request->LogFile;
    ClearRequest.Command = ELF_COMMAND_CLEAR;
    ClearRequest.Status = STATUS_SUCCESS;
    ClearRequest.Pkt.ClearPkt->BackupFileName = &BackupFileNameU;
    
    PerformClearRequest(&ClearRequest);

    //
    // Generate an audit in the Security log.
    //

    StringCchPrintfW(Number, 20, L"0x%x", ClearRequest.Status);

    EventMessage[0] = pLogFile->LogModuleName->Buffer;
    EventMessage[1] = BackupFileNameU.Buffer;
    EventMessage[2] = Number;

    if (NT_SUCCESS(ClearRequest.Status))
    {
        ELF_LOG0(TRACE,
                         "AutoBackupLogFile: auto backup and clear worked\n");
        
        ClearStatus = EVENTLOG_AUDIT_SUCCESS;
    }
    else
    {
        ELF_LOG1(ERROR,
                         "AutoBackupLogFile: failed calling clear/backup, error 0x%x\n",
                         ClearRequest.Status);
        ClearStatus = EVENTLOG_AUDIT_FAILURE;
    }
    
    ElfpCreateElfEvent(
         0x20c,                         // todo, get the #def
        ClearStatus,
        SE_CATEGID_SYSTEM,                      // EventCategory
        3,                      // NumberOfStrings
        EventMessage,           // Strings
        NULL,                   // Data
        0,                      // Datalength
        0,                      // Do not Overwrite if necc.
        TRUE);                  // For the Security Log file
    
    ElfpFreeBuffer(BackupFileNameU.Buffer);

    return ClearRequest.Status;
}


VOID
PerformWriteRequest(
    PELF_REQUEST_RECORD Request
    )

/*++

Routine Description:

    This routine writes the event log entry to the log file specified in
    the request packet.
    There is no need to impersonate the client since we want all clients
    to have access to writing to the log file.

    This routine does not use memory mapped I/O to access the log file. This
    is so the changes can be immediately committed to disk if that was how
    the log file was opened.

Arguments:

    Pointer to the request packet.
Return Value:

    NONE

Note:

--*/
{
    NTSTATUS Status;
    ULONG WritePos;               // Position to write record
    LARGE_INTEGER Time;
    ULONG SpaceNeeded;            // Record size + "buffer" size
    ULONG CurrentTime = 0;
    PEVENTLOGRECORD EventRecord;
    ULONG RecordSize;
    ULONG DeletedRecordOffset;
    ULONG SpaceAvail;
    ULONG EarliestTime;
    PLOGFILE pLogFile;               // For optimized access to structure
    PELF_LOGFILE_HEADER pFileHeader;
    PVOID BaseAddress;
    IO_STATUS_BLOCK IoStatusBlock;
    PEVENTLOGRECORD pEventLogRecord;
    PDWORD FillDword;
    ULONG OverwrittenEOF = 0;
    BOOL bSecurity =  FALSE;
    ULONG TotalSpaceAvailable;      // space available plus amount file can be extened
    int iPercentUsedBefore;             // percent of space used before record is added
    int iPercentUsedAfter;              // percent of space used after record is added
    BOOL fRetryWriteRequest = FALSE;
    BOOL bRecordAfterOverwrttenEOF;

    pLogFile = Request->LogFile;          // Set local variable

    // Set some basic BOOLs

    if(!_wcsicmp(pLogFile->LogModuleName->Buffer, ELF_SECURITY_MODULE_NAME))
        bSecurity = TRUE;
    else
        bSecurity = FALSE;
    
    //
    // Get exclusive access to the log file. This will ensure no one
    // else is accessing the file.
    //
    RtlAcquireResourceExclusive(&pLogFile->Resource,
                                TRUE);                  // Wait until available

    //This condition occurs under stress conditions 
    //and causes an AV further in this function

    if(pLogFile->bHosedByClear)
    {
        Status = ElfOpenLogFile(Request->LogFile, ElfNormalLog);
        if(NT_SUCCESS(Status))
            Request->LogFile->bHosedByClear = FALSE;
    }

    if(pLogFile->BaseAddress == NULL  || pLogFile->bHosedByClear) 
    {
        Request->Status = STATUS_INVALID_HANDLE;
        RtlReleaseResource ( &pLogFile->Resource );
        return;
    }

    try
    {

RetryWriteRequest:

        //
        // Put in the record number
        //
        pEventLogRecord = (PEVENTLOGRECORD) Request->Pkt.WritePkt->Buffer;
        pEventLogRecord->RecordNumber = pLogFile->CurrentRecordNumber;

        //
        // Now, go to the end of the file and look for empty space.
        //
        // If there is enough space to write out the record, just
        // write it out and update the pointers.
        //
        // If there isn't enough space, then we need to check if we can
        // wrap around the file without overwriting any records that are
        // within the time retention period.
        // If we cannot find any room, then we have to return an error
        // that the file is full (and alert the administrator).
        //
        RecordSize  = Request->Pkt.WritePkt->Datasize;
        SpaceNeeded = RecordSize + ELFEOFRECORDSIZE;
        
        EventRecord = Request->Pkt.WritePkt->Buffer;
        if(bSecurity && EventRecord->EventID != SE_AUDITID_UNABLE_TO_LOG_EVENTS)
        {
            SpaceNeeded += EstimateEventSize(
                44,             // assume two 10 wchar error codes 
                0,
                L"Security");
        }

        if (pLogFile->EndRecord > pLogFile->BeginRecord)
        {
            //
            // The current write position is after the position of the first
            // record, then we can write up to the end of the file without
            // worrying about overwriting existing records.
            //
            SpaceAvail = pLogFile->ActualMaxFileSize
                             - (pLogFile->EndRecord - pLogFile->BeginRecord + FILEHEADERBUFSIZE);
        }
        else if (pLogFile->EndRecord == pLogFile->BeginRecord
                  &&
                 !(pLogFile->Flags & ELF_LOGFILE_HEADER_WRAP))
        {
            //
            // If the write position is equal to the position of the first
            // record, and we have't wrapped yet, then the file is "empty"
            // and so we have room to the physical end of the file.
            //
            SpaceAvail = pLogFile->ActualMaxFileSize - FILEHEADERBUFSIZE;
        }
        else
        {
            //
            // If our write position is before the position of the first record, then
            // the file has wrapped and we need to deal with overwriting existing
            // records in the file.
            //
            SpaceAvail = pLogFile->BeginRecord - pLogFile->EndRecord;
        }

        // If this is a security log, and there is no overwrite allowed, determine
        // if we have just exceeded the warning level

        if(bSecurity && giWarningLevel > 0 && giWarningLevel < 100 && 
                        pLogFile->Retention != OVERWRITE_AS_NEEDED)
        {
            TotalSpaceAvailable = SpaceAvail + 
                                                (pLogFile->ConfigMaxFileSize -pLogFile->ActualMaxFileSize);

            iPercentUsedBefore =  100 * (pLogFile->ConfigMaxFileSize - TotalSpaceAvailable) / 
                                                            pLogFile->ConfigMaxFileSize;
            iPercentUsedAfter =  100 * (pLogFile->ConfigMaxFileSize - 
                                                        (TotalSpaceAvailable - SpaceNeeded)) / 
                                                            pLogFile->ConfigMaxFileSize;
            
            if(iPercentUsedBefore < giWarningLevel && iPercentUsedAfter >= giWarningLevel)
            {
                WCHAR wLevel[20];
                LPWSTR pwStr[1];
                pwStr[0] = wLevel;
                StringCchPrintfW(wLevel, 20, L"%d", giWarningLevel);
                ElfpCreateElfEvent(SE_AUDITID_SECURITY_LOG_EXCEEDS_WARNING_LEVEL,
                               EVENTLOG_AUDIT_SUCCESS,
                               SE_CATEGID_SYSTEM,         // EventCategory
                               1,                    // NumberOfStrings
                               pwStr,                 // Strings
                               NULL,      // Data
                               0,        // Datalength
                               0,                    // flags
                               TRUE);               // for security file    
            }
        }

        //
        // We now have the number of bytes available to write the record
        // WITHOUT overwriting any existing records stored in SpaceAvail.
        // If that amount is not sufficient, then we need to create more space
        // by "deleting" existing records that are older than the retention
        // time that was configured for this file.
        //
        // We check the retention time against the time when the log was
        // written since that is consistent at the server. We cannot use the
        // client's time since that may vary if the clients are in different
        // time zones.
        //
        NtQuerySystemTime(&Time);
        RtlTimeToSecondsSince1970(&Time, &CurrentTime);

        EarliestTime = CurrentTime - pLogFile->Retention;

        Status = STATUS_SUCCESS;        // Initialize for return to caller

        //
        // Check to see if the file hasn't reached its maximum allowable
        // size yet, and also hasn't wrapped.  If not, grow it by as much as
        // needed, in 64K chunks.
        //
        if (pLogFile->ActualMaxFileSize < pLogFile->ConfigMaxFileSize
             &&
            SpaceNeeded > SpaceAvail)
        {
            //
            // Extend it.  This call cannot fail.  If it can't extend it, it
            // just caps it at the current size by changing
            // pLogFile->ConfigMaxFileSize
            //
            ElfExtendFile(pLogFile,
                          SpaceNeeded,
                          &SpaceAvail);
        }

        //
        // We don't want to split the fixed portion of a record across the
        // physical end of the file, it makes it difficult when referencing
        // these fields later (you have to check before you touch each one
        // to make sure it's not after the physical EOF).  So, if there's
        // not enough room at the end of the file for the fixed portion,
        // we fill it with a known byte pattern (ELF_SKIP_DWORD) that will
        // be skipped if it's found at the start of a record (as long as
        // it's less than the minimum record size, then we know it's not
        // the start of a valid record).
        //
        if (pLogFile->ActualMaxFileSize - pLogFile->EndRecord < sizeof(EVENTLOGRECORD))
        {
            //
            // Save the EndRecord pointer.  In case we don't have the space
            // to write another record, we'll need to rewrite the EOF where
            // it was
            //
            OverwrittenEOF = pLogFile->EndRecord;

            FillDword = (PDWORD) ((PBYTE) pLogFile->BaseAddress + pLogFile->EndRecord);

            while (FillDword < (PDWORD) ((LPBYTE) pLogFile->BaseAddress +
                                              pLogFile->ActualMaxFileSize))
            {
                   *FillDword = ELF_SKIP_DWORD;
                   FillDword++;
            }

            pLogFile->EndRecord = FILEHEADERBUFSIZE;
            SpaceAvail          = pLogFile->BeginRecord - FILEHEADERBUFSIZE;
            pLogFile->Flags    |= ELF_LOGFILE_HEADER_WRAP;
            bRecordAfterOverwrttenEOF = TRUE;
        }
        else
            bRecordAfterOverwrttenEOF = FALSE;

        EventRecord = (PEVENTLOGRECORD) ((PBYTE) pLogFile->BaseAddress
                                              + pLogFile->BeginRecord);

        while (SpaceNeeded > SpaceAvail && 
                    (pLogFile->BeginRecord != pLogFile->EndRecord || 
                     bRecordAfterOverwrttenEOF) )
        {

            bRecordAfterOverwrttenEOF = FALSE;

            //
            // If this logfile can be overwrite-as-needed, or if it has
            // an overwrite time limit and the time hasn't expired, then
            // allow the new event to overwrite an older event.
            //
            if (pLogFile->Retention == OVERWRITE_AS_NEEDED
                 ||
                (pLogFile->Retention != NEVER_OVERWRITE
                  &&
                 (EventRecord->TimeWritten < EarliestTime
                   ||
                  Request->Flags & ELF_FORCE_OVERWRITE)))
            {
                //
                // OK to overwrite
                //
                ULONG NextRecord;
                BOOL  fBeginningRecordWrap = FALSE;
                BOOL  fInvalidRecordLength = FALSE;

                DeletedRecordOffset = pLogFile->BeginRecord;

                pLogFile->BeginRecord += EventRecord->Length;

                //
                // Ensure BeginRecord offset is DWORD-aligned.
                //
                pLogFile->BeginRecord = (pLogFile->BeginRecord + sizeof(ULONG) - 1)
                                             & ~(sizeof(ULONG) - 1);

                //
                // Check specifically for a record length value of zero.
                // Zero is considered invalid.
                //
                if (EventRecord->Length == 0)
                {
                    ELF_LOG2(ERROR,
                             "PerformWriteRequest: Zero-length record at "
                                 "offset %d in %ws log\n",
                             DeletedRecordOffset,
                             pLogFile->LogModuleName->Buffer);

                    fInvalidRecordLength = TRUE;
                }

                if (pLogFile->BeginRecord >= pLogFile->ActualMaxFileSize)
                {
                    ULONG BeginRecord;

                    //
                    // We're about to wrap around the end of the file. Adjust
                    // BeginRecord accordingly.
                    //
                    fBeginningRecordWrap = TRUE;
                    BeginRecord          = FILEHEADERBUFSIZE
                                               + (pLogFile->BeginRecord
                                                      - pLogFile->ActualMaxFileSize);

                    //
                    // If the record length was bogus (very large), it's possible
                    // the wrap-adjusted computed position is still beyond the
                    // end of file.  In thise case, mark it as bogus.
                    //
                    if (BeginRecord >= pLogFile->ActualMaxFileSize)
                    {
                        ELF_LOG3(ERROR,
                                 "PerformWriteRequest: Too-large record length (%#x) "
                                     "at offset %d in %ws log\n",
                                 EventRecord->Length,
                                 DeletedRecordOffset,
                                 pLogFile->LogModuleName->Buffer);

                        fInvalidRecordLength = TRUE;
                    }
                    else
                    {
                        pLogFile->BeginRecord = BeginRecord;
                    }
                }

                if (fInvalidRecordLength)
                {
                    //
                    // If the record length is considered bogus, adjust
                    // BeginRecord to be just beyond the length and signature of
                    // the previous record to scan for the next valid record.
                    //
                    pLogFile->BeginRecord = DeletedRecordOffset
                                                + (sizeof(ULONG) * 2);
                }

                //
                // Ensure the record referenced is indeed a valid record and that
                // we're not reading into a partially overwritten record. With a
                // circular log, it's possible to partially overwrite existing
                // entries with the EOF record and/or ELF_SKIP_DWORD values.
                //
                // Skip the record size to the record signature since the loop
                // below will search for the next valid signature.  Note that
                // the increment of SpaceAvail is undone when we find a valid
                // record below.
                //
                NextRecord = pLogFile->BeginRecord + sizeof(ULONG);

                if (NextRecord < pLogFile->ActualMaxFileSize)
                {
                    SpaceAvail += min(sizeof(ULONG),
                                      pLogFile->ActualMaxFileSize - NextRecord);
                }

                //
                // Seek to find a record signature.
                //

                Status = FindStartOfNextRecordInFile(pLogFile, NextRecord, &SpaceAvail);

                if (Status == STATUS_EVENTLOG_FILE_CORRUPT)
                {
                    break;
                }

                if (fBeginningRecordWrap)
                {
                    //
                    // Check to see if the file has reached its maximum allowable
                    // size yet.  If not, grow it by as much as needed in 64K
                    // chunks.
                    //
                    if (pLogFile->ActualMaxFileSize < pLogFile->ConfigMaxFileSize)
                    {
                        //
                        // Extend it.  This call cannot fail.  If it can't
                        // extend it, it just caps it at the current size by
                        // changing pLogFile->ConfigMaxFileSize.
                        //
                        ElfExtendFile(pLogFile,
                                      SpaceNeeded,
                                      &SpaceAvail);

                        //
                        // Since extending the file will cause it to be moved, we
                        // need to re-establish the address for the EventRecord.
                        //
                        EventRecord = (PEVENTLOGRECORD) ((PBYTE) pLogFile->BaseAddress
                                                              + DeletedRecordOffset);
                    }
                }

                //
                // Make sure no handle points to the record that we're getting
                // ready to overwrite, it one does, correct it to point to the
                // new first record.
                //
                FixContextHandlesForRecord(DeletedRecordOffset,
                                           pLogFile->BeginRecord, pLogFile);

                if (!fInvalidRecordLength)
                {
                    //
                    // Update SpaceAvail to include the deleted record's size.
                    // That is, if we have a high degree of confidence that
                    // it is valid.
                    //
                    SpaceAvail += EventRecord->Length;
                }

                //
                // Bump to the next record, file wrap was handled above
                //

                //
                // If these are ELF_SKIP_DWORDs, just move past them
                //
                FillDword = (PDWORD) ((PBYTE) pLogFile->BaseAddress
                                           + pLogFile->BeginRecord);

                if (*FillDword == ELF_SKIP_DWORD)
                {
                    SpaceAvail += pLogFile->ActualMaxFileSize - pLogFile->BeginRecord;
                    pLogFile->BeginRecord = FILEHEADERBUFSIZE;
                }

                EventRecord = (PEVENTLOGRECORD) ((PBYTE) pLogFile->BaseAddress
                                                      + pLogFile->BeginRecord);
            }
            else
            {
                break;              // Get out of while loop
            }
        }

        // if we still dont have enough space, pop up message box, write log full event etc
        
        if(NT_SUCCESS(Status) && (SpaceNeeded > SpaceAvail))
        {
                // Do new behavior.
                //
                // Auto backup, clear the log, and log and event that says the file 
                // was backed up and try to log the current event one more time.
                // 
                // If this cannot be done, we made our best attempt, so we will probably
                // crash on audit fail, and not log the event (revert to old behavior).
                //
                
                if ((pLogFile->AutoBackupLogFiles != 0) && (fRetryWriteRequest == FALSE)) 
                {
                    Status = AutoBackupLogFile(Request, OverwrittenEOF);
                    fRetryWriteRequest = TRUE;
                    if(NT_SUCCESS(Status))
                        goto RetryWriteRequest;
                }
            
                WriteLogFullMessage(Request, pLogFile, bSecurity, OverwrittenEOF);
                Status = STATUS_LOG_FILE_FULL;
        }
        if (NT_SUCCESS(Status))
        {
            //
            // We have enough room to write the record and the EOF record.
            //

            //
            // Update OldestRecordNumber to reflect the records that were
            // overwritten amd increment the CurrentRecordNumber
            //
            // Make sure that the log isn't empty, if it is, the oldest
            // record is 1
            //
            if (pLogFile->BeginRecord == pLogFile->EndRecord)
            {
                pLogFile->OldestRecordNumber = 1;
                pEventLogRecord->RecordNumber = 1;
                pLogFile->CurrentRecordNumber = 2;
            }
            else
            {
                pLogFile->OldestRecordNumber = EventRecord->RecordNumber;
                pLogFile->CurrentRecordNumber++;
            }


            //
            // If the dirty bit is not set, then this is the first time that
            // we have written to the file since we started. In that case,
            // set the dirty bit in the file header as well so that we will
            // know that the contents have changed.
            //
            if (!(pLogFile->Flags & ELF_LOGFILE_HEADER_DIRTY))
            {
                SIZE_T HeaderSize;

                pLogFile->Flags |= ELF_LOGFILE_HEADER_DIRTY;

                pFileHeader = (PELF_LOGFILE_HEADER) pLogFile->BaseAddress;
                pFileHeader->Flags |= ELF_LOGFILE_HEADER_DIRTY;

                //
                // Now flush this to disk to commit it
                //
                BaseAddress = pLogFile->BaseAddress;
                HeaderSize = FILEHEADERBUFSIZE;

                Status = NtFlushVirtualMemory(NtCurrentProcess(),
                                              &BaseAddress,
                                              &HeaderSize,
                                              &IoStatusBlock);
                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG1(ERROR,
                             "PerformWriteRequest: NtFlushVirtualMemory to add dirty "
                                 "flag to header failed %#x\n",
                             Status);
                }
            }

            //
            // Write the event to the log
            //
            Status = WriteToLog(pLogFile,
                       Request->Pkt.WritePkt->Buffer,
                       RecordSize,
                       &(pLogFile->EndRecord),
                       pLogFile->ActualMaxFileSize,
                       FILEHEADERBUFSIZE);

            if(NT_SUCCESS(Status))          // event write succeeded
            {
                //
                // write the EOF record
                // Use a separate variable for the position since we don't want
                // it updated.
                //
                WritePos = pLogFile->EndRecord;

                if (WritePos > pLogFile->ActualMaxFileSize)
                {
                    WritePos -= pLogFile->ActualMaxFileSize - FILEHEADERBUFSIZE;
                }

                //
                // Update the EOF record fields
                //
                EOFRecord.BeginRecord         = pLogFile->BeginRecord;
                EOFRecord.EndRecord           = WritePos;
                EOFRecord.CurrentRecordNumber = pLogFile->CurrentRecordNumber;
                EOFRecord.OldestRecordNumber  = pLogFile->OldestRecordNumber;

                //
                // Write out the EOF record
                //
                Status = WriteToLog(pLogFile,
                           &EOFRecord,
                           ELFEOFRECORDSIZE,
                           &WritePos,
                           pLogFile->ActualMaxFileSize,
                           FILEHEADERBUFSIZE);

                //
                // If we had just written a logfull record, turn the bit off.
                // Since we just wrote a record, technically it's not full anymore
                //
                if (!(Request->Flags & ELF_FORCE_OVERWRITE))
                {
                    pLogFile->Flags &= ~(ELF_LOGFILE_LOGFULL_WRITTEN);
                }

                //
                // See if there are any ElfChangeNotify callers to notify, and if
                // there are, pulse their event
                //
                NotifyChange(pLogFile);
            }
        }

        //
        // Set status field in the request packet.
        //
        Request->Status = Status;
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG2(ERROR,
                 "PerformWriteRequest: Caught exception %#x writing to %ws log\n",
                 GetExceptionCode(),
                 pLogFile->LogModuleName->Buffer);

        Request->Status = STATUS_EVENTLOG_FILE_CORRUPT;
    }

    //
    // Release the resource
    //
    RtlReleaseResource ( &pLogFile->Resource );
}


VOID
PerformClearRequest(
    PELF_REQUEST_RECORD Request
    )

/*++

Routine Description:

    This routine will optionally back up the log file specified, and will
    delete it.

Arguments:

    Pointer to the request packet.

Return Value:

    NONE

Note:

    On the exit path, when we do some "cleanup" work, we discard the
    status and instead return the status of the operation that is being
    performed.
    This is necessary since we wish to return any error condition that is
    directly related to the clear operation. For other errors, we will
    fail at a later stage.

--*/
{
    NTSTATUS Status, IStatus;
    PUNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_RENAME_INFORMATION NewName = NULL;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE  ClearHandle = NULL;
    FILE_DISPOSITION_INFORMATION DeleteInfo = {TRUE};
    ULONG FileRefCount;
    BOOLEAN FileRenamed = FALSE;

    //
    // Get exclusive access to the log file. This will ensure no one
    // else is accessing the file.
    //
    RtlAcquireResourceExclusive (&Request->Module->LogFile->Resource,
                                 TRUE);                  // Wait until available

    try
    {
        //
        // We have exclusive access to the file.
        //
        // We force the file to be closed, and store away the ref count
        // so that we can set it back when we reopen the file.
        // This is a little *sleazy* but we have exclusive access to the
        // logfile structure so we can play these games.
        //
        FileRefCount = Request->LogFile->RefCount;  // Store this away

        Status = ElfpCloseLogFile(Request->LogFile, ELF_LOG_CLOSE_FORCE, FALSE);
        if (!NT_SUCCESS(Status))
        {
            DbgPrint("[ELF] %lx: PerformClearRequest: Failed calling ElfpCloseLogFile, Status = %#x\n",
                    GetCurrentThreadId(),Status); 
            RtlReleaseResource(&Request->Module->LogFile->Resource);
        }

        Request->LogFile->FileHandle = NULL;        // For use later

        //
        // Open the file with delete access in order to rename it.
        //
        InitializeObjectAttributes(&ObjectAttributes,
                                   Request->LogFile->LogFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        Status = NtOpenFile(&ClearHandle,
                            GENERIC_READ | DELETE | SYNCHRONIZE,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            FILE_SHARE_DELETE,
                            FILE_SYNCHRONOUS_IO_NONALERT);

        if (NT_SUCCESS(Status))
        {
            //
            // If the backup file name has been specified and is not NULL,
            // then we move the current file to the new file. If that fails,
            // then fail the whole operation.
            //
            if ((Request->Pkt.ClearPkt->BackupFileName != NULL)
                  &&
                (Request->Pkt.ClearPkt->BackupFileName->Length != 0))
            {
                FileName = Request->Pkt.ClearPkt->BackupFileName;

                //
                // Set up the rename information structure with the new name
                //
                NewName = ElfpAllocateBuffer(FileName->Length
                                                 + sizeof(WCHAR) + sizeof(*NewName));

                if (NewName)
                {
                    RtlCopyMemory(NewName->FileName,
                                  FileName->Buffer,
                                  FileName->Length);

                    //
                    // Guarantee that it's NULL terminated
                    //
                    NewName->FileName[FileName->Length / sizeof(WCHAR)] = L'\0';

                    NewName->ReplaceIfExists = FALSE;
                    NewName->RootDirectory   = NULL;
                    NewName->FileNameLength  = FileName->Length;

                    Status = NtSetInformationFile(ClearHandle,
                                                  &IoStatusBlock,
                                                  NewName,
                                                  FileName->Length + sizeof(*NewName),
                                                  FileRenameInformation);

                    if (Status == STATUS_NOT_SAME_DEVICE)
                    {
                        //
                        // They want the backup file to be on a different
                        // device.  We need to copy this one, and then delete
                        // it.
                        //
                        ELF_LOG2(FILES,
                                 "PerformClearRequest: Attempting to copy log file %ws "
                                     "to different device (%ws)\n",
                                 Request->LogFile->LogFileName->Buffer,
                                 NewName->FileName);

                        Status = ElfpCopyFile(ClearHandle, FileName);

                        if (NT_SUCCESS(Status))
                        {
                            ELF_LOG1(FILES,
                                     "PerformClearRequest: Copy succeeded -- deleting %ws\n",
                                     Request->LogFile->LogFileName->Buffer);

                            Status = NtSetInformationFile(ClearHandle,
                                                          &IoStatusBlock,
                                                          &DeleteInfo,
                                                          sizeof(DeleteInfo),
                                                          FileDispositionInformation);

                            if (!NT_SUCCESS (Status))
                            {
                                ELF_LOG2(ERROR,
                                         "PerformClearRequest: Delete of %ws after "
                                             "successful copy failed %#x\n",
                                         Request->LogFile->LogFileName->Buffer,
                                         Status);
                            }
                        }
                    }
                    else if (NT_SUCCESS (Status))
                    {
                        FileRenamed = TRUE;
                    }

                    if (!NT_SUCCESS(Status))
                    {
                        ELF_LOG2(ERROR,
                                 "PerformClearRequest: Rename of %ws failed %#x\n",
                                 Request->LogFile->LogFileName->Buffer,
                                 Status);
                    }
                }
                else
                {
                    ELF_LOG0(ERROR,
                             "PerformClearRequest: Unable to allocate memory for "
                                 "FILE_RENAME_INFORMATION structure\n");

                    Status = STATUS_NO_MEMORY;
                }
            }
            else
            {
                //
                // No backup name was specified. Just delete the log file
                // (i.e. "clear it"). We can just delete it since we know
                // that the first time anything is written to a log file,
                // if that file does not exist, it is created and a header
                // is written to it. By deleting it here, we make it cleaner
                // to manage log files, and avoid having zero-length files all
                // over the disk.
                //
                ELF_LOG1(FILES,
                         "PerformClearRequest: No backup name specified -- deleting %ws\n",
                         Request->LogFile->LogFileName->Buffer);

                Status = NtSetInformationFile(ClearHandle,
                                              &IoStatusBlock,
                                              &DeleteInfo,
                                              sizeof(DeleteInfo),
                                              FileDispositionInformation);

                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG2(ERROR,
                             "PerformClearRequest: Delete of %ws failed %#x\n",
                             Request->LogFile->LogFileName->Buffer,
                             Status);
                }
            }

            IStatus = NtClose(ClearHandle);    // Discard status
            ASSERT(NT_SUCCESS(IStatus));
        }
        else
        {
            //
            // The open-for-delete failed.
            //
            ELF_LOG2(ERROR,
                     "PerformClearRequest: NtOpenFile of %ws for delete failed %#x\n",
                     Request->LogFile->LogFileName->Buffer,
                     Status);
        }

        //
        // If the user reduced the size of the log file, pick up the new
        // size as it couldn't be used until the log was cleared
        //
        if (NT_SUCCESS (Status))
        {
            if (Request->LogFile->NextClearMaxFileSize)
            {
                Request->LogFile->ConfigMaxFileSize = Request->LogFile->NextClearMaxFileSize;
            }

            //
            // We need to recreate the file or if the file was just closed,
            // then we reopen it.
            //
            IStatus = ElfOpenLogFile(Request->LogFile, ElfNormalLog);

            if (!NT_SUCCESS(IStatus))
            {
                ELF_LOG2(ERROR,
                         "PerformClearRequest: Open of %ws after successful delete "
                             "failed %#x\n",
                         Request->LogFile->LogFileName->Buffer,
                         IStatus);

                Status = IStatus;

                //
                // The open failed -- try to restore the old log file.  If
                // NewName is NULL, it means there was no backup file specified.
                //
                if (NewName != NULL && FileRenamed == TRUE)
                {
                    //
                    // Opening the new log file failed, reopen the old log and
                    // return this error from the Api
                    //
                    PFILE_RENAME_INFORMATION OldName;
                    UNICODE_STRING UnicodeString;

                    //
                    // Rename the file back to the original name. Reuse ClearHandle.
                    //
                    RtlInitUnicodeString(&UnicodeString, NewName->FileName);

                    InitializeObjectAttributes(&ObjectAttributes,
                                               &UnicodeString,
                                               OBJ_CASE_INSENSITIVE,
                                               NULL,
                                               NULL);

                    IStatus = NtOpenFile(&ClearHandle,
                                         GENERIC_READ | DELETE | SYNCHRONIZE,
                                         &ObjectAttributes,
                                         &IoStatusBlock,
                                         FILE_SHARE_DELETE,
                                         FILE_SYNCHRONOUS_IO_NONALERT);

                    if (NT_SUCCESS(IStatus))
                    {
                        //
                        // Set up the rename information structure with the old name
                        //
                        OldName = ElfpAllocateBuffer(Request->LogFile->LogFileName->Length
                                                         + sizeof(WCHAR) + sizeof(*OldName));

                        if (OldName)
                        {
                            PUNICODE_STRING pFileName = Request->LogFile->LogFileName;

                            RtlCopyMemory(OldName->FileName,
                                          pFileName->Buffer,
                                          pFileName->Length);

                            //
                            // Guarantee that it's NULL terminated
                            //
                            OldName->FileName[pFileName->Length / sizeof(WCHAR)] = L'\0';

                            OldName->ReplaceIfExists = FALSE;
                            OldName->RootDirectory   = NULL;
                            OldName->FileNameLength  = pFileName->Length;

                            //
                            // Change the name of the backed-up (i.e., cleared) log
                            // file to its original name.
                            //
                            IStatus = NtSetInformationFile(ClearHandle,
                                                           &IoStatusBlock,
                                                           OldName,
                                                           pFileName->Length
                                                               + sizeof(*OldName)
                                                               + sizeof(WCHAR),
                                                           FileRenameInformation);

                            ASSERT(NT_SUCCESS(IStatus));

                            //
                            // Reopen the original file.  This has to work.
                            //
                            IStatus = ElfOpenLogFile(Request->LogFile, ElfNormalLog);
                            ASSERT(NT_SUCCESS(IStatus));

                            ElfpFreeBuffer(OldName);
                        }

                        NtClose(ClearHandle);
                    }
                    else
                    {
                        ELF_LOG2(ERROR,
                                 "PerformClearRequest: Open of backed-up log file %ws "
                                     "failed %#x\n",
                                 NewName->FileName,
                                 IStatus);
                    }
                }
            }
        }
        else
        {
            //
            // The delete failed for some reason -- reopen the original log file
            //
            ELF_LOG1(FILES,
                     "PerformClearRequest: Delete of %ws failed -- reopening original file\n",
                     Request->LogFile->LogFileName->Buffer);

            IStatus = ElfOpenLogFile(Request->LogFile, ElfNormalLog);
            if(!NT_SUCCESS(IStatus))
            {
                Request->LogFile->bHosedByClear = TRUE;
                Request->LogFile->LastStatus = IStatus;
             }
        }

        Request->LogFile->RefCount = FileRefCount;      // Restore old value.

        if (Request->LogFile->logpLogPopup == LOGPOPUP_ALREADY_SHOWN)
        {
            //
            // This log has a viewable popup (i.e., it's not LOGPOPUP_NEVER_SHOW),
            // so we should show it again if the log fills up.
            //
            Request->LogFile->logpLogPopup = LOGPOPUP_CLEARED;
        }
        Request->LogFile->bFullAlertDone = FALSE;
        
        //
        // Mark any open context handles that point to this file as "invalid for
        // read."  This will fail any further READ operations and force the caller
        // to close and reopen the handle.
        //
        InvalidateContextHandlesForLogFile(Request->LogFile);

        //
        // Set status field in the request packet.
        //
        Request->Status = Status;
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG1(ERROR,
                 "PerformClearRequest: Caught exception %#x\n",
                 GetExceptionCode());

        Request->Status = STATUS_UNSUCCESSFUL;
    }

    //
    // Release the resource
    //
    RtlReleaseResource(&Request->Module->LogFile->Resource);

    ElfpFreeBuffer(NewName);
}


VOID
PerformBackupRequest(
    PELF_REQUEST_RECORD Request
    )

/*++

Routine Description:

    This routine will back up the log file specified.

    This routine impersonates the client in order to ensure that the correct
    access control is used.

    This routine is entered with the ElfGlobalResource held in a shared
    state and the logfile lock is acquired shared to prevent writing, but
    allow people to still read.

    This copies the file in two chunks, from the first record to the end
    of the file, and then from the top of the file (excluding the header)
    to the end of the EOF record.

Arguments:

    Pointer to the request packet.

Return Value:

    NONE, status is placed in the packet for later use by the API wrapper

--*/
{
    NTSTATUS Status, IStatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    LARGE_INTEGER MaximumSizeOfSection;
    LARGE_INTEGER Offset;
    ULONG LastRecordNumber;
    ULONG OldestRecordNumber;
    HANDLE  BackupHandle        = INVALID_HANDLE_VALUE;
    PBYTE StartOfCopy;
    PBYTE EndOfCopy;
    ULONG BytesToCopy;
    ULONG EndRecord = FILEHEADERBUFSIZE;
    BOOL ImpersonatingClient = FALSE;
    ELF_LOGFILE_HEADER FileHeaderBuf = { FILEHEADERBUFSIZE, // Size
                                         ELF_LOG_FILE_SIGNATURE,
                                         ELF_VERSION_MAJOR,
                                         ELF_VERSION_MINOR,
                                         FILEHEADERBUFSIZE, // Start offset
                                         FILEHEADERBUFSIZE, // End offset
                                         1,                 // Next record #
                                         1,                 // Oldest record #
                                         0,                 // Maxsize
                                         0,                 // Flags
                                         0,                 // Retention
                                         FILEHEADERBUFSIZE  // Size
                                       };


    //
    // Get shared access to the log file. This will ensure no one
    // else clears the file.
    //
    RtlAcquireResourceShared(&Request->Module->LogFile->Resource,
                             TRUE);                  // Wait until available

    try
    {
        //
        // Save away the next record number.  We'll stop copying when we get to
        // the record before this one.  Also save the first record number so we
        // can update the header and EOF record.
        //
        LastRecordNumber   = Request->LogFile->CurrentRecordNumber;
        OldestRecordNumber = Request->LogFile->OldestRecordNumber;

        //
        // Impersonate the client
        //
        Status = I_RpcMapWin32Status(RpcImpersonateClient(NULL));

        if (NT_SUCCESS(Status))
        {
            //
            // Keep this info so I can only revert in 1 place
            //
            ImpersonatingClient = TRUE;
          
            //
            // Set up the object attributes structure for the backup file
            //
            InitializeObjectAttributes(&ObjectAttributes,
                                       Request->Pkt.BackupPkt->BackupFileName,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            //
            // Open the backup file.  Fail if a file by this name already exists.
            //
            MaximumSizeOfSection =
                    RtlConvertUlongToLargeInteger(Request->LogFile->ActualMaxFileSize);

            Status = NtCreateFile(&BackupHandle,
                                  GENERIC_READ | GENERIC_WRITE | SYNCHRONIZE,
                                  &ObjectAttributes,
                                  &IoStatusBlock,
                                  &MaximumSizeOfSection,
                                  FILE_ATTRIBUTE_NORMAL,
                                  FILE_SHARE_READ,
                                  FILE_CREATE,
                                  FILE_WRITE_THROUGH | FILE_SYNCHRONOUS_IO_NONALERT,
                                  NULL,
                                  0);

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "PerformBackupRequest: Open of backup file %ws failed %#x\n",
                         Request->Pkt.BackupPkt->BackupFileName->Buffer,
                         Status);

                goto errorexit;
            }

            //
            // Write out the header, we'll update it later
            //
            FileHeaderBuf.CurrentRecordNumber = LastRecordNumber;
            FileHeaderBuf.OldestRecordNumber  = OldestRecordNumber;
            FileHeaderBuf.Flags               = 0;
            FileHeaderBuf.Retention           = Request->LogFile->Retention;

            Status = NtWriteFile(BackupHandle,           // Filehandle
                                 NULL,                   // Event
                                 NULL,                   // APC routine
                                 NULL,                   // APC context
                                 &IoStatusBlock,         // IO_STATUS_BLOCK
                                 &FileHeaderBuf,         // Buffer
                                 FILEHEADERBUFSIZE,      // Length
                                 NULL,                   // Byteoffset
                                 NULL);                  // Key


            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "PerformBackupRequest: Write of header to backup file %ws "
                             "failed %#x\n",
                         Request->Pkt.BackupPkt->BackupFileName->Buffer,
                         Status);

                goto errorexit;
            }

            //
            // Scan from the end of the file skipping over ELF_SKIP_DWORDs
            // to figure out how far to copy.  If we haven't wrapped, we just
            // copy to the EndRecord offset.
            //
            if (Request->LogFile->Flags & ELF_LOGFILE_HEADER_WRAP)
            {
                EndOfCopy = (PBYTE) Request->LogFile->BaseAddress
                                 + Request->LogFile->ActualMaxFileSize - sizeof(DWORD);

                while (*((PDWORD) EndOfCopy) == ELF_SKIP_DWORD)
                {
                    EndOfCopy -= sizeof(DWORD);
                }

                EndOfCopy += sizeof(DWORD);
            }
            else
            {
                EndOfCopy = (PBYTE) Request->LogFile->BaseAddress
                                 + Request->LogFile->EndRecord;
            }

            //
            // Now set the start position to be the first record and
            // calculate the number of bytes to copy
            //
            StartOfCopy = (PBYTE) Request->LogFile->BaseAddress
                               + Request->LogFile->BeginRecord;

            BytesToCopy = (ULONG) (EndOfCopy - StartOfCopy);
            EndRecord  += BytesToCopy;

            Status = NtWriteFile(BackupHandle,           // Filehandle
                                 NULL,                   // Event
                                 NULL,                   // APC routine
                                 NULL,                   // APC context
                                 &IoStatusBlock,         // IO_STATUS_BLOCK
                                 StartOfCopy,            // Buffer
                                 BytesToCopy,            // Length
                                 NULL,                   // Byteoffset
                                 NULL);                  // Key


            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "PerformBackupRequest: Block write to backup file %ws (1st "
                             "call) failed %#x\n",
                         Request->Pkt.BackupPkt->BackupFileName->Buffer,
                         Status);

                goto errorexit;
            }

            //
            // If the file's not wrapped, we're done except for the EOF
            // record.  If the file is wrapped we have to copy the 2nd
            // piece
            //
            if (Request->LogFile->Flags & ELF_LOGFILE_HEADER_WRAP)
            {
                StartOfCopy = (PBYTE) Request->LogFile->BaseAddress
                                   + FILEHEADERBUFSIZE;

                EndOfCopy   = (PBYTE) Request->LogFile->BaseAddress
                                   + Request->LogFile->EndRecord;

                BytesToCopy = (ULONG) (EndOfCopy - StartOfCopy);
                EndRecord  += BytesToCopy;

                Status = NtWriteFile(BackupHandle,           // Filehandle
                                     NULL,                   // Event
                                     NULL,                   // APC routine
                                     NULL,                   // APC context
                                     &IoStatusBlock,         // IO_STATUS_BLOCK
                                     StartOfCopy,            // Buffer
                                     BytesToCopy,            // Length
                                     NULL,                   // Byteoffset
                                     NULL);                  // Key


                if (!NT_SUCCESS(Status))
                {
                    ELF_LOG2(ERROR,
                             "PerformBackupRequest: Block write to backup file %ws "
                                 "(2nd call) failed %#x\n",
                             Request->Pkt.BackupPkt->BackupFileName->Buffer,
                             Status);

                    goto errorexit;
                }
            }

            //
            // Write out the EOF record after updating the fields needed for
            // recovery.
            //
            EOFRecord.BeginRecord         = FILEHEADERBUFSIZE;
            EOFRecord.EndRecord           = EndRecord;
            EOFRecord.CurrentRecordNumber = LastRecordNumber;
            EOFRecord.OldestRecordNumber  = OldestRecordNumber;

            Status = NtWriteFile(BackupHandle,           // Filehandle
                                 NULL,                   // Event
                                 NULL,                   // APC routine
                                 NULL,                   // APC context
                                 &IoStatusBlock,         // IO_STATUS_BLOCK
                                 &EOFRecord,             // Buffer
                                 ELFEOFRECORDSIZE,       // Length
                                 NULL,                   // Byteoffset
                                 NULL);                  // Key


            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "PerformBackupRequest: Write of EOF record to backup file "
                             "%ws failed %#x\n",
                         Request->Pkt.BackupPkt->BackupFileName->Buffer,
                         Status);

                goto errorexit;
            }

            //
            // Update the header with valid information
            //
            FileHeaderBuf.EndOffset = EndRecord;
            FileHeaderBuf.MaxSize   = EndRecord + ELFEOFRECORDSIZE;

            Offset = RtlConvertUlongToLargeInteger(0);

            Status = NtWriteFile(BackupHandle,           // Filehandle
                                 NULL,                   // Event
                                 NULL,                   // APC routine
                                 NULL,                   // APC context
                                 &IoStatusBlock,         // IO_STATUS_BLOCK
                                 &FileHeaderBuf,         // Buffer
                                 FILEHEADERBUFSIZE,      // Length
                                 &Offset,                // Byteoffset
                                 NULL);                  // Key

            if (!NT_SUCCESS(Status))
            {
                ELF_LOG2(ERROR,
                         "PerformBackupRequest: Rewrite of header to backup file "
                             "%ws failed %#x\n",
                         Request->Pkt.BackupPkt->BackupFileName->Buffer,
                         Status);

                goto errorexit;
            }

            //
            // Clear the LogFile flag archive bit, assuming the caller will
            // clear (or has cleared) this log's archive file attribute.
            // Note: No big deal if the caller didn't clear the archive
            // attribute.
            //
            // The next write to this log tests the LogFile flag archive bit.
            // If the bit is clear, the archive file attribute is set on the
            // log file.
            //
            Request->LogFile->Flags &= ~ELF_LOGFILE_ARCHIVE_SET;
        }
        else
        {
            ELF_LOG1(ERROR,
                     "PerformBackupRequest: RpcImpersonateClient failed %#x\n",
                     Status);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG1(ERROR,
                 "PerformBackupRequest: Caught exception %#x\n",
                 GetExceptionCode());

        Request->Status = STATUS_UNSUCCESSFUL;
    }

errorexit:

    if (ImpersonatingClient)
    {
        IStatus = I_RpcMapWin32Status(RpcRevertToSelf());

        if (!NT_SUCCESS(IStatus))
        {
            ELF_LOG1(ERROR,
                     "PerformBackupRequest: RpcRevertToSelf failed %#x\n",
                     IStatus);
        }
    }

    //
    // Close the output file
    //
    if (BackupHandle != INVALID_HANDLE_VALUE)
    {
        NtClose(BackupHandle);
    }

    //
    // Set status field in the request packet.
    //
    Request->Status = Status;

    //
    // Release the resource
    //
    RtlReleaseResource(&Request->Module->LogFile->Resource);
}


VOID
ElfPerformRequest(
    PELF_REQUEST_RECORD Request
    )

/*++

Routine Description:

    This routine takes the request packet and performs the operation
    on the event log.

    Before it does that, it takes the Global serialization resource
    for a READ to prevent other threads from doing WRITE operations on
    the resources of the service.

    After it has performed the requested operation, it writes any records
    generated by the eventlog service that have been put on the queued event
    list.

Arguments:

    Pointer to the request packet.

Return Value:

    NONE

--*/
{
    BOOL Acquired = FALSE;
    
    //
    // Acquire the global resource for shared access. If the resource is
    // not immediately available (i.e., don't wait) then some other thread
    // has it out for exclusive access.
    //
    // If we time out, one of two threads owns the global resource:
    //
    //      1) Thread monitoring the registry
    //              We can wait for this thread to finish so that the
    //              operation can continue.
    //
    //      2) Control thread
    //              In this case, it may turn out that the service is
    //              stopping.  We examine the current service state to
    //              see if it is still running. If so, we loop around
    //              and try to get the resource again.
    //

    while ((GetElState() == RUNNING) && (!Acquired))
    {
        Acquired = RtlAcquireResourceShared(&GlobalElfResource,
                                            FALSE);             // Don't wait

        if (!Acquired)
        {
            ELF_LOG1(TRACE,
                     "ElfPerformRequest: Sleep %d milliseconds waiting "
                         "for global resource\n",
                     ELF_GLOBAL_RESOURCE_WAIT);

            Sleep(ELF_GLOBAL_RESOURCE_WAIT);
        }
    }

    //
    // If the resource was not available and the status of the service
    // changed to one of the "non-working" states, then we just return
    // unsuccesful.  Rpc should not allow this to happen.
    //
    if (!Acquired)
    {
        ELF_LOG0(TRACE,
                 "ElfPerformRequest: Global resource not acquired\n");

        Request->Status = STATUS_UNSUCCESSFUL;
    }
    else
    {
        switch (Request->Command)
        {
            case ELF_COMMAND_READ:

                //
                // The read/write code paths are high risk for exceptions.
                // Ensure exceptions do not go beyond this point. Otherwise,
                // services.exe will be taken out.  Note that the try-except
                // blocks are in PerformReadRequest and PerformWriteRequest
                // since the risky calls are between calls to acquire and
                // release a resource -- if the block were out here, a thrown
                // exception would prevent the releasing of the resource
                // (Bug #175768)
                //

                PerformReadRequest(Request);
                break;

            case ELF_COMMAND_WRITE:
                PerformWriteRequest (Request);
                break;

            case ELF_COMMAND_CLEAR:
                PerformClearRequest(Request);
                break;

            case ELF_COMMAND_BACKUP:
                PerformBackupRequest(Request);
                break;

            case ELF_COMMAND_WRITE_QUEUED:
                break;
        }

        //
        // Now run the queued event list dequeueing elements and
        // writing them
        //
        if (!IsListEmpty(&QueuedEventListHead))
        {
            //
            // There are things queued up to write, do it
            //
            WriteQueuedEvents();
        }

        //
        // Release the global resource.
        //
        ReleaseGlobalResource();
    }
}


/****
@func         NTSTATUS | FindSizeofEventsSinceStart| This routine walks
            through all the logfile structures and returns the size of
            events that were reported since the start of the eventlog service
            and that need to be proapagated through the cluster-wide replicated
            logs.  For all logfiles that are returned in the list, the shared
            lock for their log file is held and must be released by the caller.

@parm        OUT PULONG | pulSize | Pointer to a LONG that contains the size on return.
@parm        OUT PULONG | pulNumLogFiles | Pointer to a LONG that number of log files
            configured for eventlogging.
@parm        OUT PPROPLOGFILEINFO | *ppPropLogFileInfo | A pointer to a PROPLOGFILEINFO with
            all the information about events that need to be propagated is returned via this.

@rdesc         Returns a result code. ERROR_SUCCESS on success.

@comm        This is called by ElfrRegisterClusterSvc
@xref        <f ElfrRegisterClusterSvc>
****/
NTSTATUS
FindSizeofEventsSinceStart(
    OUT PULONG            pulTotalEventSize,
    OUT PULONG            pulNumLogFiles,
    OUT PPROPLOGFILEINFO  *ppPropLogFileInfo
    )
{
    PLOGFILE            pLogFile;
    PVOID               pStartPropPosition;
    PVOID               pEndPropPosition;
    ULONG               ulSize;
    ULONG               ulNumLogFiles;
    PPROPLOGFILEINFO    pPropLogFileInfo = NULL;
    UINT                i;
    PVOID               PhysicalEOF;       // Physical end of file
    PVOID               PhysStart;         // Physical start of file (after file hdr)
    PVOID               BeginRecord;       // Points to first record
    PVOID               EndRecord;         // Points to byte after last record
    ELF_REQUEST_RECORD  Request;            // points to the elf request
    NTSTATUS            Status = STATUS_SUCCESS;
    READ_PKT            ReadPkt;

    //
    // Lock the linked list
    //
    RtlEnterCriticalSection(&LogFileCritSec);

    //
    // Initialize the number of files
    //
    ulNumLogFiles = 0;        // Count of files

    //
    // Initialize the number of files/total event size
    //
    *pulNumLogFiles    = 0;   // Count of files with events to be propagated
    *pulTotalEventSize = 0;

    //
    // Count the number of files
    // Initialize to the first logfile in the list
    //
    pLogFile = CONTAINING_RECORD(LogFilesHead.Flink,
                                 LOGFILE,
                                 FileList);

    //
    // While there are more
    //
    while(pLogFile->FileList.Flink != LogFilesHead.Flink)
    {
        ulNumLogFiles++;

        //
        // Advance to the next log file
        //
        pLogFile = CONTAINING_RECORD(pLogFile->FileList.Flink,
                                     LOGFILE,
                                     FileList);
    }

    ELF_LOG1(CLUSTER,
             "FindSizeOfEventsSinceStart: %d log files\n",
             ulNumLogFiles);

    if (!ulNumLogFiles)
    {
        goto FnExit;
    }

    //
    // Allocate a structure for log file info
    //
    pPropLogFileInfo =
        (PPROPLOGFILEINFO) ElfpAllocateBuffer(ulNumLogFiles * sizeof(PROPLOGFILEINFO));

    if (!pPropLogFileInfo)
    {
        ELF_LOG0(ERROR,
                 "FindSizeOfEventsSinceStart: Unable to allocate memory "
                     "for pPropLogFileInfo\n");

        Status = STATUS_NO_MEMORY;
        goto FnExit;
    }

    //
    // Gather information about the files
    // Initialize to the first logfile in the list
    //
    pLogFile = CONTAINING_RECORD(LogFilesHead.Flink,
                                 LOGFILE,
                                 FileList);

    i = 0;

    //
    // While there are more
    //

    //
    // BUGBUG: Based on the generation of ulNumLogFiles above, these
    //         two checks are actually identical
    //
    while ((pLogFile->FileList.Flink != LogFilesHead.Flink)
             &&
           (i < ulNumLogFiles))
    {
        ELF_LOG1(CLUSTER,
                 "FindSizeOfEventsSinceStart: Processing file %ws\n",
                 pLogFile->LogFileName->Buffer);

        //
        // Get shared access to the log file. This will allow multiple
        // readers to get to the file together.
        //
        RtlAcquireResourceShared(&pLogFile->Resource,
                                 TRUE);                // Wait until available

        //
        // Check if any records need to be propagated
        //
        if (pLogFile->CurrentRecordNumber == pLogFile->SessionStartRecordNumber)
        {
            ELF_LOG1(CLUSTER,
                     "FindSizeOfEventsSinceStart: No records to propagate from %ws log\n",
                     pLogFile->LogModuleName->Buffer);

            goto process_nextlogfile;
        }

        //
        // Records need to be propagated, so find the positions in the
        // file where they are logged
        //
        PhysicalEOF = (LPBYTE) pLogFile->BaseAddress
                           + pLogFile->ViewSize;

        PhysStart   = (LPBYTE)pLogFile->BaseAddress
                           + FILEHEADERBUFSIZE;

        BeginRecord = (LPBYTE) pLogFile->BaseAddress
                           + pLogFile->BeginRecord;    // Start at first record

        EndRecord   = (LPBYTE)pLogFile->BaseAddress
                           + pLogFile->EndRecord;      // Byte after end of last record


        //
        // Set up the request structure
        //
        Request.Pkt.ReadPkt = &ReadPkt;
        Request.LogFile     = pLogFile;

        //
        // Set up the read packet structure for the first event logged in this session
        //
        Request.Pkt.ReadPkt->LastSeekPos  = 0;
        Request.Pkt.ReadPkt->ReadFlags    = EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ;
        Request.Pkt.ReadPkt->RecordNumber = pLogFile->SessionStartRecordNumber;

        //
        //  Chittur Subbaraman (chitturs) - 3/22/99
        //
        //  Enclose the SeekToStartingRecord within a try-except block to
        //  account for the eventlog getting corrupted under certain
        //  circumstances (such as the system crashing). You don't want to
        //  read such corrupt records.
        //
        try
        {
            //
            // Find the size of events in this log file
            //
            Status = SeekToStartingRecord(&Request,
                                          &pStartPropPosition,
                                          BeginRecord,
                                          EndRecord,
                                          PhysicalEOF,
                                          PhysStart);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            ELF_LOG2(ERROR,
                     "FindSizeOfEventsSinceStart: Caught exception %#x while "
                         "seeking first record in %ws log\n",
                     GetExceptionCode(),
                     pLogFile->LogModuleName->Buffer);

            Status = STATUS_EVENTLOG_FILE_CORRUPT;
        }

        //
        // Skip this log file if error
        //
        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "FindSizeOfEventsSinceStart: SeekToStartingRecord (1st call) for %ws "
                         "log failed %#x\n",
                     pLogFile->LogModuleName->Buffer,
                     Status);

            //
            // Resetting status so that we skip only this file.
            //
            Status = STATUS_SUCCESS;
            goto process_nextlogfile;
        }

        //
        // SS: if this is not a valid position - the file could have wrapped since
        // Should be try and find the last valid record after the session start record
        // number then ?  Since this is unlikely to happen-its not worth the trouble
        // however valid position for session start record never succeeds even though
        // it is valid, so we skip it
        //

        //
        // Set up the read packet structure to seek till the start of the
        // last record
        //

        //
        // CODEWORK: We already have the position of the last record (via EndRecord)
        //           so just using ((PBYTE) EndRecord - *((PULONG) EndRecord - 1))
        //           should give the offset of the last record.
        //
        Request.Pkt.ReadPkt->LastSeekPos  = 0;
        Request.Pkt.ReadPkt->ReadFlags    = EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ;
        Request.Pkt.ReadPkt->RecordNumber = pLogFile->CurrentRecordNumber - 1;

        //
        //  Chittur Subbaraman (chitturs) - 3/22/99
        //
        //  Enclose the SeekToStartingRecord within a try-except block to
        //  account for the eventlog getting corrupted under certain
        //  circumstances (such as the system crashing). You don't want to
        //  read such corrupt records.
        //
        try
        {
            Status = SeekToStartingRecord(&Request,
                                          &pEndPropPosition,
                                          BeginRecord,
                                          EndRecord,
                                          PhysicalEOF,
                                          PhysStart);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            ELF_LOG2(ERROR,
                     "FindSizeOfEventsSinceStart: Caught exception %#x while "
                         "seeking last record in %ws log\n",
                     GetExceptionCode(),
                     pLogFile->LogModuleName->Buffer);

            Status = STATUS_EVENTLOG_FILE_CORRUPT;
        }

        //
        // Skip this log file if error
        //
        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(ERROR,
                     "FindSizeOfEventsSinceStart: SeekToStartingRecord (2nd call) for %ws "
                         "log failed %#x\n",
                     pLogFile->LogModuleName->Buffer,
                     Status);

            //
            // Resetting status so that we skip only this file.
            //
            Status = STATUS_SUCCESS;
            goto process_nextlogfile;
        }

        //
        // SS: if this is not a valid position - the file could have wrapped since
        //
        if (!ValidFilePos(pEndPropPosition,
                          BeginRecord,
                          EndRecord,
                          PhysicalEOF,
                          pLogFile->BaseAddress,
                          TRUE))
        {
            ELF_LOG1(ERROR,
                     "FindSizeOfEventsSinceStart: ValidFilePos for pEndPropPosition "
                         "in %ws log failed\n",
                     pLogFile->LogModuleName->Buffer);

            goto process_nextlogfile;
        }

        //
        // The end prop position
        //
        pEndPropPosition = (PBYTE) pEndPropPosition
                                + ((PEVENTLOGRECORD)pEndPropPosition)->Length;

        ELF_LOG3(CLUSTER,
                 "FindSizeOfEventsSinceStart: Log %ws, pStartPosition %p, pEndPosition %p\n",
                 pLogFile->LogModuleName->Buffer,
                 pStartPropPosition,
                 pEndPropPosition);

        //
        // If no records to propagate - skip the file
        //
        if (pStartPropPosition == pEndPropPosition)
        {
            ELF_LOG1(CLUSTER,
                     "FindSizeOfEventsSinceStart: Start and end positions in %ws log "
                         "are equal -- no events to propagate\n",
                     pLogFile->LogModuleName->Buffer);

            goto process_nextlogfile;
        }

        if (pEndPropPosition > pStartPropPosition)
        {
            ulSize = (ULONG) ((PBYTE) pEndPropPosition - (PBYTE) pStartPropPosition);
        }
        else
        {
            //
            // BUGBUG: This ignores any ELF_SKIP_DWORDs at the end of the file
            //
            ulSize = (ULONG) ((PBYTE) PhysicalEOF - (PBYTE) pStartPropPosition)
                          +
                     (ULONG) ((PBYTE)pEndPropPosition - (PBYTE)PhysStart);
        }

        ELF_LOG2(CLUSTER,
                 "FindSizeOfEventsSinceStart: Need to propagate %d bytes from %ws log\n",
                 ulSize,
                 pLogFile->LogModuleName->Buffer);

        pPropLogFileInfo[i].pLogFile         = pLogFile;
        pPropLogFileInfo[i].pStartPosition   = pStartPropPosition;
        pPropLogFileInfo[i].pEndPosition     = pEndPropPosition;
        pPropLogFileInfo[i].ulTotalEventSize = ulSize;
        pPropLogFileInfo[i].ulNumRecords     = pLogFile->CurrentRecordNumber
                                                   - pLogFile->SessionStartRecordNumber;
        i++;
        (*pulNumLogFiles)++;
        *pulTotalEventSize += ulSize;

        //
        // Advance to the next log file
        //
        pLogFile = CONTAINING_RECORD(pLogFile->FileList.Flink,
                                     LOGFILE,
                                     FileList);

        //
        // NB: We were successful with this log file and we therefore hold on to
        //     the lock -- the caller will/must release it.
        //
        continue;

process_nextlogfile:

        //
        // We were not successful with the log file -- release the lock
        //
        RtlReleaseResource(&pLogFile->Resource);

        //
        // Advance to the next log file
        //
        pLogFile = CONTAINING_RECORD(pLogFile->FileList.Flink,
                                     LOGFILE,
                                     FileList);
    }

    //
    // Free the memory if unsuccessful
    //
    if (!(*pulNumLogFiles))
    {
        ElfpFreeBuffer(pPropLogFileInfo);
        pPropLogFileInfo = NULL;
    }

FnExit:

    *ppPropLogFileInfo = pPropLogFileInfo;

    ELF_LOG3(CLUSTER,
             "FindSizeOfEventsSinceStart: ulTotalEventSize = %d, ulNumLogFiles = %d, "
                 "pPropLogFileInfo = %p\n",
             *pulTotalEventSize,
             *pulNumLogFiles,
             *ppPropLogFileInfo);

    //
    // Unlock the linked list
    //
    RtlLeaveCriticalSection(&LogFileCritSec);
    return Status;
}

/****
@func   NTSTATUS | GetEventsToProp| Given a propagate log file
        info structure, this events prepares a block of eventlog
        records to propagate.  The shared lock to the logfile must
        be held thru when the PROPLOGINFO structure is prepared
        to when this routine is called.

@parm   OUT PEVENTLOGRECORD | pEventLogRecords | Pointer to a EVENTLOGRECORD
        structure where the events to be propagated are returned.
@parm   IN PPROPLOGFILEINFO | pPropLogFileInfo | Pointer to a PROPLOGFILEINFO
        structure that contains the information to retrieve events from the
        corresponding eventlog file.

@rdesc  Returns a result code. ERROR_SUCCESS on success.

@xref
****/
NTSTATUS
GetEventsToProp(
    IN PEVENTLOGRECORD  pEventLogRecords,
    IN PPROPLOGFILEINFO pPropLogFileInfo
    )
{
    PVOID       BufferPosition;
    PVOID       XferPosition;
    PVOID       PhysicalEOF;
    PVOID       PhysicalStart;
    ULONG       ulBytesToMove;
    NTSTATUS    Status = STATUS_SUCCESS;

    ELF_LOG1(CLUSTER,
             "GetEventsToProp: Getting events for %ws log\n",
             pPropLogFileInfo->pLogFile->LogModuleName->Buffer);

    BufferPosition = pEventLogRecords;
    ulBytesToMove  = pPropLogFileInfo->ulTotalEventSize;

    //
    // If the start and end positions are the same there are no bytes to copy
    //
    if (pPropLogFileInfo->pStartPosition == pPropLogFileInfo->pEndPosition)
    {
        ASSERT(FALSE);

        //
        // Shouldn't come here as FindSizeofEventsSinceStart checks
        // for this explicitly
        //
        return STATUS_SUCCESS;
    }

    //
    //  Chittur Subbaraman (chitturs) - 3/15/99
    //
    //  Enclose the memcpy within a try-except block to account for
    //  the eventlog getting corrupted under certain circumstances (such
    //  as the system crashing). You don't want to read such corrupt
    //  records.
    //
    try
    {
        XferPosition  = pPropLogFileInfo->pStartPosition;
        ulBytesToMove = pPropLogFileInfo->ulTotalEventSize;

        if (pPropLogFileInfo->pStartPosition > pPropLogFileInfo->pEndPosition)
        {
            //
            // The log is wrapped -- copy the bytes from the start position
            // to the end of the file
            //
            PhysicalEOF   = (PBYTE) pPropLogFileInfo->pLogFile->BaseAddress
                                  + pPropLogFileInfo->pLogFile->ViewSize;

            PhysicalStart = (PBYTE) pPropLogFileInfo->pLogFile->BaseAddress
                                  + FILEHEADERBUFSIZE;

            //
            // BUGBUG: This copies any ELF_SKIP_DWORDs that are at the
            //         end of the file
            //
            ulBytesToMove = (ULONG) ((PBYTE) PhysicalEOF
                                          - (PBYTE) pPropLogFileInfo->pStartPosition);

            RtlCopyMemory(BufferPosition, XferPosition, ulBytesToMove);

            //
            // Set it up for the second half
            //
            BufferPosition = (PBYTE) BufferPosition + ulBytesToMove;
            ulBytesToMove  = pPropLogFileInfo->ulTotalEventSize - ulBytesToMove;
            XferPosition   = PhysicalStart;
        }

        RtlCopyMemory(BufferPosition, XferPosition, ulBytesToMove);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        ELF_LOG2(ERROR,
                 "GetEventsToProp: Caught exception %#x copying records from %ws log\n",
                 GetExceptionCode(),
                 pPropLogFileInfo->pLogFile->LogModuleName->Buffer);

        Status = STATUS_EVENTLOG_FILE_CORRUPT;
    }

    return Status;
}

//SS:end of changes made to enable cluster wide event logging
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\test\test.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    TEST.C

Abstract:

    Test program for the eventlog service. This program calls the Elf
    APIs to test out the operation of the service.

Author:

    Rajen Shah  (rajens) 05-Aug-1991

Revision History:


--*/
/*----------------------*/
/* INCLUDES             */
/*----------------------*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>      // printf
#include <string.h>     // stricmp
#include <stdlib.h>
#include <process.h>    // exit
#include <elfcommn.h>
#include <windows.h>
#include <ntiolog.h>
#include <malloc.h>

#define     READ_BUFFER_SIZE        1024*2      // Use 2K buffer

#define     SIZE_DATA_ARRAY         22

#define SET_OPERATION(x) \
        if (Operation != Invalid) { \
           printf("Only one operation at a time\n"); \
           Usage(); \
        } \
        Operation = x;

//
// Global buffer used to emulate "binary data" when writing an event
// record.
//
ULONG    Data[SIZE_DATA_ARRAY];
enum _OPERATION_TYPE {
   Invalid,
   Clear,
   Backup,
   Read,
   Write,
   Notify,
   TestFull,
   LPC
} Operation = Invalid;
ULONG ReadFlags;
BOOL Verbose = FALSE;
ULONG NumberofRecords = 1;
ULONG DelayInMilliseconds = 0;
CHAR DefaultModuleName[] = "TESTAPP";
PCHAR pModuleName = DefaultModuleName;
PCHAR pBackupFileName;
ANSI_STRING AnsiString;
UNICODE_STRING ServerName;
BOOL ReadingBackupFile = FALSE;
BOOL ReadingModule = FALSE;
BOOL WriteInvalidRecords = FALSE;
BOOL InvalidUser = FALSE;

// Function prototypes

VOID ParseParms(ULONG argc, PCHAR *argv);

VOID
Initialize (
    VOID
    )
{
    ULONG   i;

    // Initialize the values in the data buffer.
    //
    for (i=0; i< SIZE_DATA_ARRAY; i++)
        Data[i] = i;

}


VOID
Usage (
    VOID
    )
{
    printf( "usage: \n" );
    printf( "-c              Clears the specified log\n");
    printf( "-b <filename>   Backs up the log to file <filename>\n");
    printf( "-f <filename>   Filename of backup log to use for read\n");
    printf( "-i              Generate invalid SID\n");
    printf( "-l[i] nn        Writes nn records thru LPC port [i ==> bad records]\n");
    printf( "-m <modulename> Module name to use for read/clear\n");
    printf( "-n              Test out change notify\n");
    printf( "-rsb            Reads nn event log records sequentially backwards\n");
    printf( "-rsf nn         Reads nn event log records sequentially forwards\n");
    printf( "-rrb <record>   Reads event log from <record> backwards\n");
    printf( "-rrf <record>   Reads event log from <record> forwards\n");
    printf( "-s <servername> Name of server to remote calls to\n");
    printf( "-t nn           Number of milliseconds to delay between read/write"
            " (default 0)\n\tOnly used with -l switch\n");
    printf( "-w <count>      Writes <count> records\n");
    printf( "-z              Test to see if the logs are full\n");
    exit(0);

} // Usage


NTSTATUS
WriteLogEntry (
    HANDLE LogHandle,
    ULONG EventID
    )
{
#define NUM_STRINGS     2
#define SIZE_TOKEN_BUFFER 512

    SYSTEMTIME systime;
    NTSTATUS Status;
    USHORT   EventType, i;
    ULONG    DataSize;
    PSID     pUserSid = NULL;
    PWSTR    Strings[NUM_STRINGS] = {L"StringOne", L"StringTwo"};
    PUNICODE_STRING UStrings[NUM_STRINGS];
    HANDLE   hProcess;
    HANDLE   hToken;
    PTOKEN_USER pTokenUser;
    DWORD    SizeRequired;

    EventType = EVENTLOG_INFORMATION_TYPE;
    DataSize  = sizeof(ULONG) * SIZE_DATA_ARRAY;

    //
    // Get the SID of the current user (process)
    //

    pTokenUser = malloc(SIZE_TOKEN_BUFFER);

    if (!InvalidUser) {
        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE,
            GetCurrentProcessId());
        if (!hProcess) {
            printf("Couldn't open the process, rc = %d\n", GetLastError());
            return(STATUS_UNSUCCESSFUL);
        }

        if (!OpenProcessToken(hProcess, TOKEN_QUERY, &hToken)) {
            printf("Couldn't open the token, rc = %d\n", GetLastError());
            CloseHandle(hProcess);
            return(STATUS_UNSUCCESSFUL);
        }
        if (!pTokenUser) {
            printf("Couldn't allocate buffer for TokenUser\n");
            CloseHandle(hToken);
            CloseHandle(hProcess);
            return(STATUS_UNSUCCESSFUL);
        }

        if (!GetTokenInformation(hToken, TokenUser, pTokenUser, SIZE_TOKEN_BUFFER,
            &SizeRequired)) {
                printf("Couldn't get TokenUser information, rc = %d\n",
                    GetLastError());
                CloseHandle(hToken);
                CloseHandle(hProcess);
                free(pTokenUser);
                return(STATUS_UNSUCCESSFUL);
        }

        CloseHandle(hToken);
        CloseHandle(hProcess);
    }
    else {
        memset(pTokenUser, 0xFADE, SIZE_TOKEN_BUFFER);
        pTokenUser->User.Sid = (PSID)pUserSid;
    }

    pUserSid = pTokenUser->User.Sid;

    for (i=0; i< SIZE_DATA_ARRAY; i++)
        Data[i] += i;

    // Allocate space for the unicode strings in the array, and
    // copy over the strings from Strings[] to that array.
    //
    for (i=0; i<NUM_STRINGS; i++) {

        UStrings[i] = malloc(sizeof(UNICODE_STRING));
        RtlInitUnicodeString (UStrings[i], Strings[i]);
        UStrings[i]->MaximumLength = UStrings[i]->Length + sizeof(WCHAR);
    }

    //
    // Vary the data sizes.
    //

    GetLocalTime(&systime);

    DataSize = systime.wMilliseconds % sizeof(Data);
    printf("\nData Size = %lu\n", DataSize);

    Status = ElfReportEventW (
                    LogHandle,
                    EventType,
                    0,             // category
                    EventID,
                    pUserSid,
                    NUM_STRINGS,
                    DataSize,
                    UStrings,
                    (PVOID)Data,
                    0,              // Flags        -  paired event support
                    NULL,           // RecordNumber  | not in product 1
                    NULL            // TimeWritten  -
                    );

    for (i=0; i<NUM_STRINGS; i++)
        free(UStrings[i]);

    free(pTokenUser);
    return (Status);
}


VOID
DisplayEventRecords( PVOID Buffer,
                     ULONG  BufSize,
                     PULONG NumRecords)

{
    PEVENTLOGRECORD     pLogRecord;
    LPWSTR              pwString;
    ULONG               Count = 0;
    ULONG               Offset = 0;
    ULONG               i;

    pLogRecord = (PEVENTLOGRECORD) Buffer;

    while (Offset < BufSize && Count < *NumRecords) {

        printf("\nRecord # %lu\n", pLogRecord->RecordNumber);

        printf("Length: 0x%lx TimeGenerated: 0x%lx  EventID: 0x%lx EventType: 0x%x\n",
                pLogRecord->Length, pLogRecord->TimeGenerated, pLogRecord->EventID,
                pLogRecord->EventType);

        printf("NumStrings: 0x%x StringOffset: 0x%lx UserSidLength: 0x%lx TimeWritten: 0x%lx\n",
                pLogRecord->NumStrings, pLogRecord->StringOffset,
                pLogRecord->UserSidLength, pLogRecord->TimeWritten);

        printf("UserSidOffset: 0x%lx DataLength: 0x%lx DataOffset: 0x%lx Category: 0x%lx\n",
                pLogRecord->UserSidOffset, pLogRecord->DataLength,
                pLogRecord->DataOffset, pLogRecord->EventCategory);

        //
        // Print out module name
        //

        pwString = (PWSTR)((LPBYTE) pLogRecord + sizeof(EVENTLOGRECORD));
        printf("ModuleName: %ws\n", pwString);

        //
        // Display ComputerName
        //
        pwString += wcslen(pwString) + 1;
        printf("ComputerName: %ws\n", pwString);

        //
        // Display strings
        //

        pwString = (PWSTR)((LPBYTE)pLogRecord + pLogRecord->StringOffset);

        printf("Strings: ");
        for (i=0; i<pLogRecord->NumStrings; i++) {

            printf("  %ws  ", pwString);
            pwString += wcslen(pwString) + 1;
        }

        printf("\n");

        //
        // If verbose mode, display binary data (up to 256 bytes)
        //

        if (Verbose) {
            PULONG pData;
            PULONG pEnd;

            if (pLogRecord->DataLength < 80) {
                pEnd = (PULONG)((PBYTE) pLogRecord + pLogRecord->DataOffset +
                    pLogRecord->DataLength);
            }
            else {
                pEnd = (PULONG)((PBYTE) pLogRecord + pLogRecord->DataOffset +
                    256);
            }

            printf("Data: \n\n");
            for (pData = (PULONG)((PBYTE) pLogRecord + pLogRecord->DataOffset);
                 pData < pEnd; (PBYTE) pData += 32) {

                printf("\t%08x %08x %08x %08x\n", pData[0], pData[1], pData[2],
                    pData[3]);
            }
        }

        // Get next record
        //
        Offset += pLogRecord->Length;

//        pLogRecord = (PEVENTLOGRECORD)((ULONG)Buffer + Offset);
        pLogRecord = (PEVENTLOGRECORD)((BYTE *)Buffer + Offset);

        Count++;

    }

    *NumRecords = Count;

}


NTSTATUS
ReadFromLog ( HANDLE LogHandle,
             PVOID  Buffer,
             PULONG pBytesRead,
             ULONG  ReadFlag,
             ULONG  Record
             )
{
    NTSTATUS    Status;
    ULONG       MinBytesNeeded;

    Status = ElfReadEventLogW (
                        LogHandle,
                        ReadFlag,
                        Record,
                        Buffer,
                        READ_BUFFER_SIZE,
                        pBytesRead,
                        &MinBytesNeeded
                        );


    if (Status == STATUS_BUFFER_TOO_SMALL)
        printf("Buffer too small. Need %lu bytes min\n", MinBytesNeeded);

    return (Status);
}


NTSTATUS
TestReadEventLog (
    ULONG Count,
    ULONG ReadFlag,
    ULONG Record
    )

{
    NTSTATUS    Status, IStatus;

    HANDLE      LogHandle;
    UNICODE_STRING  ModuleNameU;
    ANSI_STRING ModuleNameA;
    ULONG   NumRecords, BytesReturned;
    PVOID   Buffer;
    ULONG   RecordOffset;
    ULONG   NumberOfRecords;
    ULONG   OldestRecord;

    printf("Testing ElfReadEventLog API to read %lu entries\n",Count);

    Buffer = malloc (READ_BUFFER_SIZE);

    //
    // Initialize the strings
    //
    NumRecords = Count;
    RtlInitAnsiString(&ModuleNameA, pModuleName);
    RtlAnsiStringToUnicodeString(&ModuleNameU, &ModuleNameA, TRUE);
    ModuleNameU.MaximumLength = ModuleNameU.Length + sizeof(WCHAR);

    //
    // Open the log handle
    //

    if (ReadingBackupFile) {
        printf("ElfOpenBackupEventLog - ");
        Status = ElfOpenBackupEventLogW (
                        &ServerName,
                        &ModuleNameU,
                        &LogHandle
                        );
    }
    else {
        printf("ElfOpenEventLog - ");
        Status = ElfOpenEventLogW (
                        &ServerName,
                        &ModuleNameU,
                        &LogHandle
                        );
    }

    if (!NT_SUCCESS(Status)) {
         printf("Error - 0x%lx\n", Status);

    } else {
        printf("SUCCESS\n");

        //
        // Get and print record information
        //

        Status = ElfNumberOfRecords(LogHandle, & NumberOfRecords);
        if (NT_SUCCESS(Status)) {
           Status = ElfOldestRecord(LogHandle, & OldestRecord);
        }

        if (!NT_SUCCESS(Status)) {
           printf("Query of record information failed with %X", Status);
           return(Status);
        }

        printf("\nThere are %d records in the file, %d is the oldest"
         " record number\n", NumberOfRecords, OldestRecord);

        RecordOffset = Record;

        while (Count && NT_SUCCESS(Status)) {

            printf("Read %u records\n", NumRecords);
            //
            // Read from the log
            //
            Status = ReadFromLog ( LogHandle,
                                   Buffer,
                                   &BytesReturned,
                                   ReadFlag,
                                   RecordOffset
                                 );
            if (NT_SUCCESS(Status)) {

                printf("Bytes read = 0x%lx\n", BytesReturned);
                NumRecords = Count;
                DisplayEventRecords(Buffer, BytesReturned, &NumRecords);
                Count -= NumRecords;
            }

        }
        printf("\n");

        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_END_OF_FILE) {
               printf("Tried to read more records than in log file\n");
            }
            else {
                printf ("Error - 0x%lx. Remaining count %lu\n", Status, Count);
            }
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling ElfCloseEventLog\n");
        IStatus = ElfCloseEventLog (LogHandle);
    }

    return (Status);
}


NTSTATUS
TestReportEvent (
    ULONG Count
    )

{
    NTSTATUS    Status, IStatus;
    HANDLE      LogHandle;
    UNICODE_STRING  ModuleNameU;
    ANSI_STRING ModuleNameA;
    ULONG EventID = 99;

    printf("Testing ElfReportEvent API\n");

    //
    // Initialize the strings
    //

    RtlInitAnsiString(&ModuleNameA, pModuleName);
    RtlAnsiStringToUnicodeString(&ModuleNameU, &ModuleNameA, TRUE);
    ModuleNameU.MaximumLength = ModuleNameU.Length + sizeof(WCHAR);

    //
    // Open the log handle
    //
    printf("Calling ElfRegisterEventSource for WRITE %lu times - ", Count);
    Status = ElfRegisterEventSourceW (
                    &ServerName,
                    &ModuleNameU,
                    &LogHandle
                    );

    if (!NT_SUCCESS(Status)) {
         printf("Error - 0x%lx\n", Status);

    } else {
        printf("SUCCESS\n");

        while (Count && NT_SUCCESS(Status)) {

            printf("Record # %u \n", Count);

            //
            // Write an entry into the log
            //
            Data[0] = Count;                        // Make data "unique"
            EventID = (EventID + Count) % 100;      // Vary the eventids
            Status = WriteLogEntry ( LogHandle, EventID );
            Count--;
        }
        printf("\n");

        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_LOG_FILE_FULL) {
                printf("Log Full\n");
            }
            else {
                printf ("Error - 0x%lx. Remaining count %lu\n", Status, Count);
            }
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling ElfDeregisterEventSource\n");
        IStatus = ElfDeregisterEventSource (LogHandle);
    }

    return (Status);
}


NTSTATUS
TestElfClearLogFile(
    VOID
    )

{
    NTSTATUS    Status, IStatus;
    HANDLE      LogHandle;
    UNICODE_STRING  BackupU, ModuleNameU;
    ANSI_STRING ModuleNameA;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    HANDLE  ClearHandle;
    FILE_DISPOSITION_INFORMATION DeleteInfo = {TRUE};
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN DontRetry = FALSE;

    printf("Testing ElfClearLogFile API\n");
    //
    // Initialize the strings
    //
    RtlInitAnsiString( &ModuleNameA, pModuleName);
    RtlAnsiStringToUnicodeString(&ModuleNameU, &ModuleNameA, TRUE);
    ModuleNameU.MaximumLength = ModuleNameU.Length + sizeof(WCHAR);

    //
    // Open the log handle
    //
    printf("Calling ElfOpenEventLog for CLEAR - ");
    Status = ElfOpenEventLogW (
                    &ServerName,
                    &ModuleNameU,
                    &LogHandle
                    );

    if (!NT_SUCCESS(Status)) {
         printf("Error - 0x%lx\n", Status);

    } else {
        printf("SUCCESS\n");

        //
        // Clear the log file and back it up to "view.evt"
        //

        RtlInitUnicodeString( &BackupU,
            L"\\SystemRoot\\System32\\Config\\view.evt" );
        BackupU.MaximumLength = BackupU.Length + sizeof(WCHAR);
retry:
        printf("Calling ElfClearEventLogFile backing up to view.evt  ");
        Status = ElfClearEventLogFileW (
                        LogHandle,
                        &BackupU
                        );

        if (Status == STATUS_OBJECT_NAME_COLLISION) {
            if (DontRetry) {
                printf("Still can't backup to View.Evt\n");
            }
            else {
                printf("Failed.\nView.Evt already exists, deleting ...\n");

                //
                // Open the file with delete access
                //

                InitializeObjectAttributes(
                                &ObjectAttributes,
                                &BackupU,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                                );

                Status = NtOpenFile(&ClearHandle,
                                    GENERIC_READ | DELETE | SYNCHRONIZE,
                                    &ObjectAttributes,
                                    &IoStatusBlock,
                                    FILE_SHARE_DELETE,
                                    FILE_SYNCHRONOUS_IO_NONALERT
                                    );

                Status = NtSetInformationFile(
                            ClearHandle,
                            &IoStatusBlock,
                            &DeleteInfo,
                            sizeof(DeleteInfo),
                            FileDispositionInformation
                            );

                if (NT_SUCCESS (Status) ) {
                    Status = NtClose (ClearHandle);    // Discard status
                    goto retry;
                }

                printf("Delete failed 0x%lx\n",Status);
                Status = NtClose (ClearHandle);    // Discard status
                goto JustClear;
            }
        }

        if (!NT_SUCCESS(Status)) {
            printf ("Error - 0x%lx\n", Status);
        } else {
            printf ("SUCCESS\n");
        }

JustClear:

        //
        // Now just clear the file without backing it up
        //
        printf("Calling ElfClearEventLogFile with no backup  ");
        Status = ElfClearEventLogFileW (
                        LogHandle,
                        NULL
                        );

        if (!NT_SUCCESS(Status)) {
            printf ("Error - 0x%lx\n", Status);
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling ElfCloseEventLog\n");
        IStatus = ElfCloseEventLog (LogHandle);
    }

    return(Status);
}


NTSTATUS
TestElfBackupLogFile(
    VOID
    )

{
    NTSTATUS    Status, IStatus;
    HANDLE      LogHandle;
    UNICODE_STRING  BackupU, ModuleNameU;
    ANSI_STRING AnsiString;

    printf("Testing ElfBackupLogFile API\n");

    //
    // Initialize the strings
    //

    RtlInitAnsiString( &AnsiString, pModuleName);
    RtlAnsiStringToUnicodeString(&ModuleNameU, &AnsiString, TRUE);
    ModuleNameU.MaximumLength = ModuleNameU.Length + sizeof(WCHAR);

    //
    // Open the log handle
    //

    printf("Calling ElfOpenEventLog for BACKUP - ");
    Status = ElfOpenEventLogW (
                    &ServerName,
                    &ModuleNameU,
                    &LogHandle
                    );

    if (!NT_SUCCESS(Status)) {
         printf("Error - 0x%lx\n", Status);

    } else {
        printf("SUCCESS\n");

        //
        // Backup the log file
        //

        printf("Calling ElfBackupEventLogFile backing up to %s ",
            pBackupFileName);

        RtlInitAnsiString( &AnsiString, pBackupFileName);
        RtlAnsiStringToUnicodeString(&BackupU, &AnsiString, TRUE);
        BackupU.MaximumLength = BackupU.Length + sizeof(WCHAR);

        Status = ElfBackupEventLogFileW (
                        LogHandle,
                        &BackupU
                        );

        if (!NT_SUCCESS(Status)) {
            printf ("Error - 0x%lx\n", Status);
        } else {
            printf ("SUCCESS\n");
        }


        printf("Calling ElfCloseEventLog - ");
        IStatus = ElfCloseEventLog (LogHandle);
        if (NT_SUCCESS(IStatus)) {
            printf("Success\n");
        }
        else {
            printf("Failed with code %X\n", IStatus);
        }
    }

    return(Status);
}

#define DRIVER_NAME L"FLOPPY"
#define DEVICE_NAME L"A:"
#define STRING L"Test String"

// These include the NULL terminator, but is length in chars, not bytes
#define DRIVER_NAME_LENGTH 7
#define DEVICE_NAME_LENGTH 3
#define STRING_LENGTH 12

#define NUMBER_OF_DATA_BYTES 8

VOID
TestLPCWrite(
   DWORD NumberOfRecords,
   DWORD MillisecondsToDelay
   )
{

    HANDLE PortHandle;
    UNICODE_STRING PortName;
    NTSTATUS Status;
    SECURITY_QUALITY_OF_SERVICE Qos;
    PIO_ERROR_LOG_MESSAGE pIoErrorLogMessage;
    DWORD i;
    LPWSTR pDestinationString;
    PPORT_MESSAGE RequestMessage;
    PORT_MESSAGE ReplyMessage;
    WORD DataLength;
    WORD TotalLength;
    INT YorN;
    CHAR NumberString[8];
    ULONG MessageId = 1;
    DWORD BadType = 0;

    //
    // Warn the user about how this test works
    //

    printf("\nThis test doesn't end!  It will write a number of\n"
           "records, then prompt you to write more.  This is \n"
           "required since it is simulating the system thread\n"
           "which never shuts down it's connection\n\n"
           "Do you wish to continue with this test (y or n)? ");

    YorN = getc(stdin);

    if (YorN == 'n' || YorN == 'N') {
        return;
    }

    //
    // Initialize the SecurityQualityofService structure
    //

    Qos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    Qos.ImpersonationLevel = SecurityImpersonation;
    Qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    Qos.EffectiveOnly = TRUE;

    //
    // Connect to the LPC Port
    //

    RtlInitUnicodeString( &PortName, L"\\ErrorLogPort" );

    Status = NtConnectPort(& PortHandle,
                           & PortName,
                           & Qos,
                           NULL,
                           NULL,
                           NULL,
                           NULL,
                           NULL
                           );

    if (!NT_SUCCESS(Status)) {
       printf("Connect to the LPC port failed with RC %X\n", Status);
       return;
    }

    //
    // Allocate the memory for the Message to send to the LPC port.  It
    // will contain a PORT_MESSAGE followed by an IO_ERROR_LOG_MESSAGE
    // followed by Drivername and Devicename UNICODE strings
    //

    DataLength =  PORT_MAXIMUM_MESSAGE_LENGTH -
        (sizeof(IO_ERROR_LOG_MESSAGE)
        + DRIVER_NAME_LENGTH  * sizeof(WCHAR)
        + DEVICE_NAME_LENGTH * sizeof(WCHAR)
        + STRING_LENGTH * sizeof(WCHAR));
    TotalLength = PORT_MAXIMUM_MESSAGE_LENGTH + (WORD) sizeof(PORT_MESSAGE);

    RequestMessage = (PPORT_MESSAGE) malloc(TotalLength);
    if (RequestMessage == NULL) {
       printf("Couldn't alloc %d bytes of memory for message\n", TotalLength);
       NtClose(PortHandle);
       return;
    }

    pIoErrorLogMessage = (PIO_ERROR_LOG_MESSAGE) ((LPBYTE) RequestMessage +
        sizeof(PORT_MESSAGE));

    //
    // Initialize the PORT_MESSAGE
    //

    RequestMessage->u1.s1.DataLength = PORT_MAXIMUM_MESSAGE_LENGTH;
    RequestMessage->u1.s1.TotalLength = TotalLength;
    RequestMessage->u2.s2.Type = 0;
    RequestMessage->u2.ZeroInit = 0;
    RequestMessage->ClientId.UniqueProcess = GetCurrentProcess();
    RequestMessage->ClientId.UniqueThread = GetCurrentThread();
    RequestMessage->MessageId = 0x1234;

    //
    // Initialize the IO_ERROR_LOG_MESSAGE
    //

    pIoErrorLogMessage->Type = IO_TYPE_ERROR_MESSAGE;
    pIoErrorLogMessage->Size = PORT_MAXIMUM_MESSAGE_LENGTH;
    pIoErrorLogMessage->DriverNameLength = DRIVER_NAME_LENGTH * sizeof(WCHAR);
    NtQuerySystemTime((PTIME) &pIoErrorLogMessage->TimeStamp);
    pIoErrorLogMessage->DriverNameOffset = sizeof(IO_ERROR_LOG_MESSAGE) +
        DataLength - sizeof(DWORD);

    pIoErrorLogMessage->EntryData.MajorFunctionCode = 1;
    pIoErrorLogMessage->EntryData.RetryCount = 5;
    pIoErrorLogMessage->EntryData.DumpDataSize = DataLength;
    pIoErrorLogMessage->EntryData.NumberOfStrings = 2;
    pIoErrorLogMessage->EntryData.StringOffset = sizeof(IO_ERROR_LOG_MESSAGE)
        - sizeof(DWORD) + DataLength +
        DRIVER_NAME_LENGTH * sizeof(WCHAR);
    pIoErrorLogMessage->EntryData.EventCategory = 0;
    pIoErrorLogMessage->EntryData.ErrorCode = 0xC0020008;
    pIoErrorLogMessage->EntryData.UniqueErrorValue = 0x20008;
    pIoErrorLogMessage->EntryData.FinalStatus = 0x1111;
    pIoErrorLogMessage->EntryData.SequenceNumber = 1;
    pIoErrorLogMessage->EntryData.IoControlCode = 0xFF;
    pIoErrorLogMessage->EntryData.DeviceOffset =
        RtlConvertUlongToLargeInteger(1);

    for (i = 0; i < DataLength ; i++ ) {
        pIoErrorLogMessage->EntryData.DumpData[i] = i;
    }

    //
    // Copy the strings
    //

    pDestinationString = (LPWSTR) ((LPBYTE) pIoErrorLogMessage
        + sizeof(IO_ERROR_LOG_MESSAGE)
        - sizeof(DWORD) + pIoErrorLogMessage->EntryData.DumpDataSize);
    wcscpy(pDestinationString, DRIVER_NAME);

    pDestinationString += DRIVER_NAME_LENGTH;
    wcscpy(pDestinationString, DEVICE_NAME);

    pDestinationString += DEVICE_NAME_LENGTH;
    wcscpy(pDestinationString, STRING);

    //
    // Write the packet as many times as requested, with delay, then ask
    // if they want to write more
    //
    while (NumberOfRecords) {

        printf("\n\nWriting %d records\n", NumberOfRecords);

        while(NumberOfRecords--) {
            printf(".");

            //
            // Put in a unique message number
            //

            RequestMessage->MessageId = MessageId++;

            //
            // If they want invalid records, give them invalid records
            //

            if (WriteInvalidRecords) {
                switch (BadType++) {
                case 0:
                    pIoErrorLogMessage->EntryData.DumpDataSize++;
                    break;

                case 1:
                    pIoErrorLogMessage->EntryData.NumberOfStrings++;
                    break;

                case 2:
                    pIoErrorLogMessage->EntryData.StringOffset++;
                    break;

                default:
                    BadType = 0;
                }
            }

            Status = NtRequestWaitReplyPort(PortHandle,
                                        RequestMessage,
                                        & ReplyMessage);

            if (!NT_SUCCESS(Status)) {
                printf("Request to LPC port failed with RC %X\n", Status);
                break;
            }

            //
            // Delay a little bit, if requested
            //

            if (MillisecondsToDelay) {
                Sleep(MillisecondsToDelay);
            }
        }
        printf("\nEnter the number of records to write ");

        while (!gets(NumberString) || !(NumberOfRecords = atoi(NumberString))) {
            printf("Enter the number of records to write ");
        }
    }

    //
    // Clean up and exit
    //

    Status = NtClose(PortHandle);
    if (!NT_SUCCESS(Status)) {
       printf("Close of Port failed with RC %X\n", Status);
    }

    free(RequestMessage);

    return;

}


VOID
TestChangeNotify(
   VOID
   )
{

    HANDLE Event;
    UNICODE_STRING  ModuleNameU;
    ANSI_STRING ModuleNameA;
    NTSTATUS Status;
    HANDLE LogHandle;
    OBJECT_ATTRIBUTES obja;
    ULONG NumRecords;
    ULONG BytesRead;
    ULONG MinBytesNeeded;
    PVOID Buffer;
    ULONG OldestRecord;
    ULONG NumberOfRecords;

    RtlInitAnsiString(&ModuleNameA, pModuleName);
    RtlAnsiStringToUnicodeString(&ModuleNameU, &ModuleNameA, TRUE);
    ModuleNameU.MaximumLength = ModuleNameU.Length + sizeof(WCHAR);

    Buffer = malloc (READ_BUFFER_SIZE);
    ASSERT(Buffer);

    //
    // Open the log handle
    //

    printf("ElfOpenEventLog - ");
    Status = ElfOpenEventLogW (
                    &ServerName,
                    &ModuleNameU,
                    &LogHandle
                    );

    if (!NT_SUCCESS(Status)) {
         printf("Error - 0x%lx\n", Status);
         return;
    }

    printf("SUCCESS\n");

    //
    // Create the Event
    //

    InitializeObjectAttributes( &obja, NULL, 0, NULL, NULL);

    Status = NtCreateEvent(
                   &Event,
                   SYNCHRONIZE | EVENT_QUERY_STATE | EVENT_MODIFY_STATE,
                   &obja,
                   SynchronizationEvent,
                   FALSE
                   );

    ASSERT(NT_SUCCESS(Status));

    //
    // Get the read pointer to the end of the log
    //

    Status = ElfOldestRecord(LogHandle, & OldestRecord);
    ASSERT(NT_SUCCESS(Status));
    Status = ElfNumberOfRecords(LogHandle, & NumberOfRecords);
    ASSERT(NT_SUCCESS(Status));
    OldestRecord += NumberOfRecords - 1;

    Status = ElfReadEventLogW (
                        LogHandle,
                        EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ,
                        OldestRecord,
                        Buffer,
                        READ_BUFFER_SIZE,
                        &BytesRead,
                        &MinBytesNeeded
                        );


    //
    // This one should hit end of file
    //

    Status = ElfReadEventLogW (
                        LogHandle,
                        EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ,
                        0,
                        Buffer,
                        READ_BUFFER_SIZE,
                        &BytesRead,
                        &MinBytesNeeded
                        );

    if (Status != STATUS_END_OF_FILE) {
        printf("Hmmm, should have hit EOF (unless there are writes going"
            " on elsewhere- %X\n", Status);
    }

    //
    // Call ElfChangeNotify
    //

    Status = ElfChangeNotify(LogHandle, Event);
    ASSERT(NT_SUCCESS(Status));

    //
    // Now loop waiting for the event to get toggled
    //

    while (1) {

        Status = NtWaitForSingleObject(Event, FALSE, 0);
        printf("The change notify event just got kicked\n");

        //
        // Now read the new records
        //

        while(1) {

            Status = ElfReadEventLogW (
                                LogHandle,
                                EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ,
                                0,
                                Buffer,
                                READ_BUFFER_SIZE,
                                &BytesRead,
                                &MinBytesNeeded
                                );

            if (Status == STATUS_END_OF_FILE) {
                break;
            }

            NumRecords = 0xffff; // should be plenty
            DisplayEventRecords (Buffer, BytesRead, &NumRecords);
        }
    }
}


VOID
TestLogFull(
    VOID
    )
{
    HANDLE  hLogFile;
    BOOL    fIsFull;
    BOOLEAN fPrevious = FALSE;
    DWORD   i;
    DWORD   dwBytesNeeded;
    BOOL    fIsSecLog;
    
    LPWSTR  szLogNames[] = { L"Application", L"Security", L"System" };

    for (i = 0; i < sizeof(szLogNames) / sizeof(LPWSTR); i++) {

        fIsSecLog = (wcscmp(szLogNames[i], L"Security") == 0);

        if (fIsSecLog) {

            if (!NT_SUCCESS(RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE,
                                               TRUE,
                                               FALSE,
                                               &fPrevious))) {

                printf("RtlAdjustPrivilege FAILED %d\n",
                       RtlNtStatusToDosError(GetLastError()));
            }
        }

        hLogFile = OpenEventLogW(NULL, szLogNames[i]);

        if (hLogFile != NULL) {

            if (GetEventLogInformation(hLogFile,
                                       0,          // Log full infolevel
                                       (LPBYTE)&fIsFull,
                                       sizeof(fIsFull),
                                       &dwBytesNeeded)) {

                printf("The %ws Log is%sfull\n",
                       szLogNames[i],
                       fIsFull ? " " : " not ");
            }
            else {

                printf("GetEventLogInformation FAILED %d for the %ws Log\n",
                       GetLastError(),
                       szLogNames[i]);
            }            
        }
        else {

            printf("OpenEventLog FAILED %d for the %ws Log\n",
                   GetLastError(),
                   szLogNames[i]);
        }

        if (fIsSecLog) {
            RtlAdjustPrivilege(SE_SECURITY_PRIVILEGE, fPrevious, FALSE, &fPrevious);
        }
    }
}


VOID
__cdecl
main (
    IN SHORT argc,
    IN PSZ argv[]
    )
{

    Initialize();           // Init any data

    //
    // Parse the command line
    //

    ParseParms(argc, argv);

    switch (Operation) {
       case Clear:

          TestElfClearLogFile();
          break;

       case Backup:

          TestElfBackupLogFile();
          break;

       case Read:

          if (ReadFlags & EVENTLOG_SEEK_READ) {
              TestReadEventLog(1, ReadFlags, NumberofRecords) ;
          }
          else {
              TestReadEventLog(NumberofRecords, ReadFlags, 0) ;
          }
          break;

       case Write:

          TestReportEvent (NumberofRecords);
          break;

        case LPC:
          TestLPCWrite(NumberofRecords, DelayInMilliseconds);
          break;

        case Notify:
          TestChangeNotify();
          break;

        case TestFull:
          TestLogFull();
          break;

        default:
            printf("Invalid switch from ParseParms %d\n", Operation);
    }
}


VOID
ParseParms(
    ULONG argc,
    PCHAR *argv
    )
{

   ULONG i;
   PCHAR pch;

   for (i = 1; i < argc; i++) {    /* for each argument */
       if (*(pch = argv[i]) == '-') {
           while (*++pch) {
               switch (*pch) {
                   case 'b':

                     SET_OPERATION(Backup)

                     //
                     // Get the file name for backup
                     //

                     if (i+1 < argc) {
                        pBackupFileName = argv[++i];
                     }
                     else {
                        Usage();
                     }
                     break;

                   case 'c':

                     SET_OPERATION(Clear)

                     break;

                  case 'f':
                     if (i+1 < argc) {
                        pModuleName = argv[++i];
                        ReadingBackupFile = TRUE;
                     }
                     else {
                        Usage();
                     }
                     break;

                  case '?':
                  case 'h':
                  case 'H':
                     Usage();
                     break;

                  case 'i':
                     InvalidUser = TRUE;
                     break;

                  case 'l':

                     SET_OPERATION(LPC);

                     //
                     // See if they want invalid records
                     //

                     if (*++pch == 'i') {
                         WriteInvalidRecords = TRUE;
                     }

                     //
                     // See if they specified a number of records
                     //

                     if (i + 1 < argc && argv[i+1][0] != '-') {
                        NumberofRecords = atoi(argv[++i]);
                        if (NumberofRecords == 0) {
                           Usage();
                        }
                     }

                     break;

                  case 'm':
                     if (i+1 < argc) {
                        pModuleName = argv[++i];
                        ReadingModule = TRUE;
                     }
                     else {
                        Usage();
                     }
                     break;

                  case 'n':
                     SET_OPERATION(Notify)
                     break;

                   case 'r':

                     SET_OPERATION(Read)

                     //
                     // Different Read options
                     //

                     if (*++pch == 's') {
                        ReadFlags |= EVENTLOG_SEQUENTIAL_READ;
                     }
                     else if (*pch == 'r') {
                        ReadFlags |= EVENTLOG_SEEK_READ;
                     }
                     else {
                        Usage();
                     }

                     if (*++pch == 'f') {
                        ReadFlags |= EVENTLOG_FORWARDS_READ;
                     }
                     else if (*pch == 'b') {
                        ReadFlags |= EVENTLOG_BACKWARDS_READ;
                     }
                     else {
                        Usage();
                     }

                     //
                     // See if they specified a number of records
                     //

                     if (i + 1 < argc && argv[i+1][0] != '-') {
                        NumberofRecords = atoi(argv[++i]);
                        if (NumberofRecords == 0) {
                           Usage();
                        }
                     }

                     break;

                  case 's':
                     if (i+1 >= argc) {
                         printf("Must supply a server name with -s\n");
                         Usage();
                     }
                     RtlInitAnsiString(&AnsiString, argv[++i]);
                     RtlAnsiStringToUnicodeString(&ServerName, &AnsiString,
                        TRUE);
                     break;

                  case 't':
                     DelayInMilliseconds = atoi(argv[++i]);
                     break;

                  case 'v':
                     Verbose = TRUE;
                     break;

                  case 'w':

                     SET_OPERATION(Write)

                     //
                     // See if they specified a number of records
                     //

                     if (i + 1 < argc && argv[i+1][0] != '-') {
                        NumberofRecords = atoi(argv[++i]);
                        if (NumberofRecords == 0) {
                           Usage();
                        }
                     }

                     break;

                  case 'z':

                      SET_OPERATION(TestFull)
                      break;

                  default:        /* Invalid options */
                     printf("Invalid option %c\n\n", *pch);
                     Usage();
                     break;
               }
           }
       }

       //
       // There aren't any non switch parms
       //

       else {
          Usage();
       }
   }

   //
   // Verify parms are correct
   //


   if ( Operation == Invalid) {
       printf( "Must specify an operation\n");
       Usage( );
   }

   if (ReadingBackupFile && ReadingModule) {
       printf("-m and -f are mutually exclusive\n");
       Usage();
   }

   if (ReadingBackupFile && Operation == Write) {
       printf("You cannot write to a backup log file\n");
       Usage();
   }
   if (DelayInMilliseconds && Operation != LPC) {
       printf("\n\n-t switch is only used with -l\n\n");
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\terminat.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    TERMINAT.C

Abstract:

    This file contains all the cleanup routines for the Eventlog service.
    These routines are called when the service is terminating.

Author:

    Rajen Shah  (rajens)    09-Aug-1991


Revision History:


--*/

//
// INCLUDES
//

#include <eventp.h>
#include <ntrpcp.h>
#include <elfcfg.h>



PORT_MESSAGE TerminateMsg;

VOID
StopLPCThread(
    VOID
    )

/*++

Routine Description:

    This routine stops the LPC thread and cleans up LPC-related resources.

Arguments:

    NONE

Return Value:

    NONE

--*/

{
    NTSTATUS status;
    BOOL bThreadExitedGracefully = FALSE;

    ELF_LOG0(TRACE,
             "StopLpcThread: Clean up LPC thread and global data\n");

    // Terminate the LPC thread.  Send it a stop message

    TerminateMsg.u1.s1.DataLength = 0;
    TerminateMsg.u1.s1.TotalLength = sizeof(PORT_MESSAGE);
    TerminateMsg.u2.s2.Type = 0;
    status = NtRequestPort(
                             ElfConnectionPortHandle,
                            &TerminateMsg);
    if(NT_SUCCESS(status))
    {
        DWORD dwRet = WaitForSingleObject(LPCThreadHandle, 10000);
        if(dwRet == WAIT_OBJECT_0)
            bThreadExitedGracefully = TRUE;    
    }
    
    //
    // Close communication port handle
    //
   /// NtClose(ElfCommunicationPortHandle);

    //
    // Close connection port handle
    //
    NtClose(ElfConnectionPortHandle);

    //
    // Terminate the LPC thread.
    //
    if(!bThreadExitedGracefully)
    {
        if (!TerminateThread(LPCThreadHandle, NO_ERROR))
            {
                ELF_LOG1(ERROR,
                         "StopLpcThread: TerminateThread failed %d\n",
                         GetLastError());
            }
    }
    CloseHandle(LPCThreadHandle);

    return;
}




VOID
FreeModuleAndLogFileStructs(
    VOID
    )

/*++

Routine Description:

    This routine walks the module and log file list and frees all the
    data structures.

Arguments:

    NONE

Return Value:

    NONE

Note:

    The file header and ditry bits must have been dealt with before
    this routine is called. Also, the file must have been unmapped and
    the handle closed.

--*/
{

    NTSTATUS Status;
    PLOGMODULE pModule;
    PLOGFILE pLogFile;

    ELF_LOG0(TRACE,
             "FreeModuleAndLogFileStructs: Emptying log module list\n");

    //
    // First free all the modules
    //
    while (!IsListEmpty(&LogModuleHead))
    {
        pModule = (PLOGMODULE) CONTAINING_RECORD(LogModuleHead.Flink, LOGMODULE, ModuleList);

        UnlinkLogModule(pModule);    // Remove from linked list
        ElfpFreeBuffer (pModule);    // Free module memory
    }

    //
    // Now free all the logfiles
    //
    ELF_LOG0(TRACE,
             "FreeModuleAndLogFileStructs: Emptying log file list\n");

    while (!IsListEmpty(&LogFilesHead))
    {
        pLogFile = (PLOGFILE) CONTAINING_RECORD(LogFilesHead.Flink, LOGFILE, FileList);

        Status = ElfpCloseLogFile(pLogFile, ELF_LOG_CLOSE_NORMAL, TRUE);

        if (!NT_SUCCESS(Status))
        {
            ELF_LOG2(FILES,
                     "FreeModuleAndLogFileStructs: ElfpCloseLogFile on %ws failed %#x\n",
                     pLogFile->LogModuleName->Buffer,
                     Status);
        }

    }
}


VOID
ElfpCleanUp (
    ULONG EventFlags
    )

/*++

Routine Description:

    This routine cleans up before the service terminates. It cleans up
    based on the parameter passed in (which indicates what has been allocated
    and/or started.

Arguments:

    Bit-mask indicating what needs to be cleaned up.

Return Value:

    NONE

Note:
    It is expected that the RegistryMonitor has already
    been notified of Shutdown prior to calling this routine.

--*/
{
    DWORD   status = NO_ERROR;

    //
    // Notify the Service Controller for the first time that we are
    // about to stop the service.
    //
    ElfStatusUpdate(STOPPING);

    ELF_LOG0(TRACE, "ElfpCleanUp: Cleaning up so service can exit\n");

    //
    // Give the ElfpSendMessage thread a 1 second chance to exit before
    // we free the QueuedMessageCritSec critical section
    //
    if( MBThreadHandle != NULL )
    {
        ELF_LOG0(TRACE, "ElfpCleanUp: Waiting for ElfpSendMessage thread to exit\n");

        status = WaitForSingleObject(MBThreadHandle, 1000);

        if (status != WAIT_OBJECT_0)
        {
            ELF_LOG1(ERROR, 
                     "ElfpCleanUp: NtWaitForSingleObject status = %d\n",
                     status);
        }
    }

    //
    // Stop the RPC Server
    //
    if (EventFlags & ELF_STARTED_RPC_SERVER)
    {
        ELF_LOG0(TRACE,
                 "ElfpCleanUp: Stopping the RPC server\n");

        status = ElfGlobalData->StopRpcServer(eventlog_ServerIfHandle);

        if (status != NO_ERROR)
        {
            ELF_LOG1(ERROR,
                     "ElfpCleanUp: StopRpcServer failed %d\n",
                     status);
        }
    }

    //
    // Stop the LPC thread
    //
    if (EventFlags & ELF_STARTED_LPC_THREAD)
    {
        StopLPCThread();
    }

    //
    // Tell service controller that we are making progress
    //
    ElfStatusUpdate(STOPPING);

    //
    // Flush all the log files to disk.
    //
    ELF_LOG0(TRACE,
             "ElfpCleanUp: Flushing log files\n");

    ElfpFlushFiles(TRUE);

    //
    // Tell service controller that we are making progress
    //
    ElfStatusUpdate(STOPPING);

    //
    // Clean up any resources that were allocated
    //
    FreeModuleAndLogFileStructs();

    //
    // If we queued up any events, flush them
    //
    ELF_LOG0(TRACE,
             "ElfpCleanUp: Flushing queued events\n");

    if (EventFlags & ELF_INIT_QUEUED_EVENT_CRIT_SEC)
        FlushQueuedEvents();

    //
    // Tell service controller of that we are making progress
    //
    ElfStatusUpdate(STOPPING);

    if (EventFlags & ELF_INIT_GLOBAL_RESOURCE)
    {
        RtlDeleteResource(&GlobalElfResource);
    }

    if (EventFlags & ELF_INIT_CLUS_CRIT_SEC)
    {
#if 0
        //
        //  Chittur Subbaraman (chitturs) - 09/25/2001
        //
        //  We can't handle the critsec deletion without adding code here to delete the timer 
        //  thread spawned for batching support (ElfpBatchEventsAndPropagate). If we call 
        //  DeleteTimerQueueTimer from here which will fully block until that timer thread
        //  goes away, we introduce a dependency on the eventlog service shutdown on the 
        //  quick disappearence of the timer thread which may not happen (since ApiPropPendingEvents
        //  is hung because clussvc is in the debugger). So, since the eventlog service cannot be
        //  stopped by the user and can be stopped only by SCM on windows shutdown, it is not worth 
        //  waiting here just to delete the gClPropCritsec.
        //
        RtlDeleteCriticalSection(&gClPropCritSec);
#endif
    }

    if (EventFlags & ELF_INIT_LOGHANDLE_CRIT_SEC)
    {
        RtlDeleteCriticalSection(&LogHandleCritSec);
    }

    if (EventFlags & ELF_INIT_QUEUED_MESSAGE_CRIT_SEC)
    {
        RtlDeleteCriticalSection(&QueuedMessageCritSec);
    }

    if (EventFlags & ELF_INIT_QUEUED_EVENT_CRIT_SEC)
    {
        RtlDeleteCriticalSection(&QueuedEventCritSec);
    }

    if (EventFlags & ELF_INIT_LOGMODULE_CRIT_SEC)
    {
        RtlDeleteCriticalSection(&LogModuleCritSec);
    }

    if (EventFlags & ELF_INIT_LOGFILE_CRIT_SEC)
    {
#if 0
        //
        //  Same comment as above
        //
        RtlDeleteCriticalSection(&LogFileCritSec);
#endif
    }

    if(GlobalMessageBoxTitle && bGlobalMessageBoxTitleNeedFree)
        LocalFree(GlobalMessageBoxTitle);
    GlobalMessageBoxTitle = NULL;

    //
    // *** STATUS UPDATE ***
    //
    ELF_LOG0(TRACE,
             "ElfpCleanUp: The Eventlog service has left the building\n");

    ElfStatusUpdate(STOPPED);
    ElCleanupStatus();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\server\logclear.c ===
/*++

Copyright (c) 1991-1994  Microsoft Corporation

Module Name:

    logclear.c

Abstract:

    Contains functions used to log an event indicating who cleared the log.
    This is only called after the security log has been cleared.

Author:

    Dan Lafferty (danl)     01-July-1994

Environment:

    User Mode -Win32

Revision History:

    01-July-1994    danl & robertre
        Created - Rob supplied the code which I fitted into the eventlog.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <msaudite.h>
#include <eventp.h>
#include <tstr.h>
#include <winsock2.h>
#include <strsafe.h>

#define NUM_STRINGS     6


//
// LOCAL FUNCTION PROTOTYPES
//
BOOL
GetUserInfo(
    IN HANDLE Token,
    OUT LPWSTR *UserName,
    OUT LPWSTR *DomainName,
    OUT LPWSTR *AuthenticationId,
    OUT PSID *UserSid
    );

LPWSTR 
GetNameFromIPAddress(
	LPWSTR pszComputerNameFromBinding);

BOOL
IsLocal(
    VOID
    );
    
VOID
ElfpGenerateLogClearedEvent(
    IELF_HANDLE    LogHandle,
    LPWSTR pwsClientSidString,
    LPWSTR  pwsComputerName,
    PTOKEN_USER pToken 
    )

/*++

Routine Description:

    This function generates an event indicating that the log was cleared.

Arguments:

    LogHandle -- This is a handle to the log that the event is to be placed in.
        It is intended that this function only be called when the SecurityLog
        has been cleared.  So it is expected the LogHandle will always be
        a handle to the security log.

Return Value:

    None -- Either it works or it doesn't.  If it doesn't, there isn't much
            we can do about it.

--*/
{
    LPWSTR  UserName               = L"-";
    LPWSTR  DomainName             = L"-";
    LPWSTR  AuthenticationId       = L"-";
    LPWSTR  ClientUserName         = pwsClientSidString;
    LPWSTR  ClientDomainName       = L"-";
    LPWSTR  ClientAuthenticationId = L"-";
    PSID    UserSid                = NULL;
    DWORD   i;
    BOOL    Result;
    HANDLE  Token;
    PUNICODE_STRING StringPtrArray[NUM_STRINGS];
    UNICODE_STRING  StringArray[NUM_STRINGS];
    NTSTATUS        Status;
    LARGE_INTEGER   Time;
    ULONG           EventTime;
    ULONG           LogHandleGrantedAccess;
    UNICODE_STRING  ComputerNameU;
    DWORD           dwStatus;
    BOOL bUserNameSet = FALSE;
    BOOL bClientInfoSet = FALSE;

    //
    // Get information about the Eventlog service (i.e., LocalSystem)
    //
    Result = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &Token);

    if (!Result)
    {
        ELF_LOG1(ERROR,
                 "ElfpGenerateLogClearedEvent: OpenProcessToken failed %d\n",
                 GetLastError());
    }
    else
    {

        Result = GetUserInfo(Token,
                             &UserName,
                             &DomainName,
                             &AuthenticationId,
                             &UserSid);

        CloseHandle(Token);

        if (!Result)
        {
            ELF_LOG1(ERROR,
                     "ElfpGenerateLogClearedEvent: GetUserInfo failed %d\n",
                     GetLastError());
        }
        else
            bUserNameSet = TRUE;
    }

    if(!bUserNameSet)
    {
        UserName               = L"-";
        DomainName             = L"-";
       AuthenticationId       = L"-";
       UserSid = pToken->User.Sid;
    }
    ELF_LOG3(TRACE,
             "ElfpGenerateLogClearedEvent: GetUserInfo returned: \n"
                 "\tUserName         = %ws,\n"
                 "\tDomainName       = %ws,\n"
                 "\tAuthenticationId = %ws\n",
             UserName,
             DomainName,
             AuthenticationId);

    //
    // Now impersonate in order to get the client's information.
    // This call should never fail.
    //
    dwStatus = RpcImpersonateClient(NULL);

    if (dwStatus != RPC_S_OK)
    {
        ELF_LOG1(ERROR,
                 "ElfpGenerateLogClearedEvent: RpcImpersonateClient failed %d\n",
                 dwStatus);
    }
    else
    {
        Result = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &Token);

        if (!Result)
        {
            ELF_LOG1(ERROR,
                     "ElfpGenerateLogClearedEvent: OpenThreadToken failed %d\n",
                     GetLastError());

            ASSERT(FALSE);
        }
        else
        {
            Result = GetUserInfo(Token,
                                 &ClientUserName,
                                 &ClientDomainName,
                                 &ClientAuthenticationId,
                                 NULL);

            CloseHandle(Token);

            if (!Result)
            {
                ELF_LOG1(ERROR,
                         "ElfpGenerateLogClearedEvent: GetUserInfo (call 2) failed %d\n",
                         GetLastError());
            }
            else
                bClientInfoSet = TRUE;
        }
        
    }
    if(!bClientInfoSet)
    {
            ClientUserName = pwsClientSidString;
            ClientDomainName = L"-";
            ClientAuthenticationId = L"-";
    }
    ELF_LOG3(TRACE,
             "ElfpGenerateLogClearedEvent: GetUserInfo (call 2) returned: \n"
                 "\tUserName         = %ws,\n"
                 "\tDomainName       = %ws,\n"
                 "\tAuthenticationId = %ws\n",
             ClientUserName,
             ClientDomainName,
             ClientAuthenticationId);

    RtlInitUnicodeString(&StringArray[0], UserName);
    RtlInitUnicodeString(&StringArray[1], DomainName);
    RtlInitUnicodeString(&StringArray[2], AuthenticationId);
    RtlInitUnicodeString(&StringArray[3], ClientUserName);
    RtlInitUnicodeString(&StringArray[4], ClientDomainName);
    RtlInitUnicodeString(&StringArray[5], ClientAuthenticationId);

    //
    // Create an array of pointers to UNICODE_STRINGs.
    //
    for (i = 0; i < NUM_STRINGS; i++)
    {
        StringPtrArray[i] = &StringArray[i];
    }

    //
    // Generate the time of the event. This is done on the client side
    // since that is where the event occurred.
    //
    NtQuerySystemTime(&Time);
    RtlTimeToSecondsSince1970(&Time, &EventTime);

    RtlInitUnicodeString(&ComputerNameU, pwsComputerName);

    //
    // Since all processes other than LSA are given read-only access
    // to the security log, we have to explicitly give the current
    // process the right to write the "Log cleared" event
    //
    LogHandleGrantedAccess    = LogHandle->GrantedAccess;
    LogHandle->GrantedAccess |= ELF_LOGFILE_WRITE;

    Status = ElfrReportEventW (
                 LogHandle,                         // Log Handle
                 EventTime,                         // Time
                 EVENTLOG_AUDIT_SUCCESS,            // Event Type
                 (USHORT)SE_CATEGID_SYSTEM,         // Event Category
                 SE_AUDITID_AUDIT_LOG_CLEARED,      // EventID
                 NUM_STRINGS,                       // NumStrings
                 0,                                 // DataSize
                 &ComputerNameU,                    // ComputerNameU
                 UserSid,                           // UserSid
                 StringPtrArray,                    // *Strings
                 NULL,                              // Data
                 0,                                 // Flags
                 NULL,                              // RecordNumber
                 NULL);                             // TimeWritten

    LogHandle->GrantedAccess = LogHandleGrantedAccess;

    //
    // We only come down this path if we know for sure that these
    // first three have been allocated.
    //

    if(bUserNameSet)
    {
        ElfpFreeBuffer(UserName);
        ElfpFreeBuffer(DomainName);
        ElfpFreeBuffer(AuthenticationId);
        ElfpFreeBuffer(UserSid);
    }
    if(bClientInfoSet)
    {
        ElfpFreeBuffer(ClientUserName);
        ElfpFreeBuffer(ClientDomainName);
        ElfpFreeBuffer(ClientAuthenticationId);
    }
    //
    // Stop impersonating
    //
    dwStatus = RpcRevertToSelf();
    
    if (dwStatus != RPC_S_OK)
    {
        ELF_LOG1(ERROR,
                 "ElfpGenerateLogClearedEvent: RpcRevertToSelf failed %d\n",
                 GetLastError());
    }
}


BOOL
GetUserInfo(
    IN HANDLE  Token,
    OUT LPWSTR *UserName,
    OUT LPWSTR *DomainName,
    OUT LPWSTR *AuthenticationId,
    OUT PSID   *UserSid
    )

/*++

Routine Description:

    This function gathers information about the user identified with the
    token.

Arguments:
    Token - This token identifies the entity for which we are gathering
        information.
    UserName - This is the entity's user name.
    DomainName -  This is the entity's domain name.
    AuthenticationId -  This is the entity's Authentication ID.
    UserSid - This is the entity's SID.

NOTE:
    Memory is allocated by this routine for UserName, DomainName,
    AuthenticationId, and UserSid.  It is the caller's responsibility to
    free this memory.

Return Value:
    TRUE - If the operation was successful.  It is possible that
        UserSid did not get allocated in the successful case.  Therefore,
        the caller should test prior to freeing.
    FALSE - If unsuccessful.  No memory is allocated in this case.


--*/
{
    PTOKEN_USER      Buffer      = NULL;
    LPWSTR           Domain      = NULL;
    LPWSTR           AccountName = NULL;
    SID_NAME_USE     Use;
    BOOL             Result;
    DWORD            RequiredLength;
    DWORD            AccountNameSize;
    DWORD            DomainNameSize;
    TOKEN_STATISTICS Statistics;
    WCHAR            LogonIdString[256];
    DWORD            Status = ERROR_SUCCESS;

    if(UserSid)
        *UserSid = NULL;

    Result = GetTokenInformation(Token, TokenUser, NULL, 0, &RequiredLength);

    if (!Result)
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            ELF_LOG1(TRACE,
                     "GetUserInfo: GetTokenInformation needs %d bytes\n",
                     RequiredLength);

            Buffer = ElfpAllocateBuffer(RequiredLength);

            if (Buffer == NULL)
            {
                ELF_LOG0(ERROR,
                         "GetUserInfo: Unable to allocate memory for token\n");

                return FALSE;
            }

            Result = GetTokenInformation(Token,
                                         TokenUser,
                                         Buffer,
                                         RequiredLength,
                                         &RequiredLength);

            if (!Result)
            {
                ELF_LOG1(ERROR,
                         "GetUserInfo: GetTokenInformation (call 2) failed %d\n",
                         GetLastError());
                ElfpFreeBuffer(Buffer);
                return FALSE;
            }
        }
        else
        {
            ELF_LOG1(ERROR,
                     "GetUserInfo: GetTokenInformation (call 1) failed %d\n",
                     GetLastError());

            return FALSE;
        }
    }

    AccountNameSize = 0;
    DomainNameSize  = 0;

    Result = LookupAccountSidW(L"",
                               Buffer->User.Sid,
                               NULL,
                               &AccountNameSize,
                               NULL,
                               &DomainNameSize,
                               &Use);

    if (!Result)
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            AccountName = ElfpAllocateBuffer((AccountNameSize + 1) * sizeof(WCHAR));
            Domain = ElfpAllocateBuffer((DomainNameSize + 1) * sizeof(WCHAR));

            if (AccountName == NULL)
            {
                ELF_LOG1(ERROR,
                         "GetUserInfo: Unable to allocate %d bytes for AccountName\n",
                         AccountNameSize);

                goto ErrorCleanup;
            }

            if (Domain == NULL)
            {
                ELF_LOG1(ERROR,
                         "GetUserInfo: Unable to allocate %d bytes for Domain\n",
                         DomainNameSize);

                goto ErrorCleanup;
            }

            Result = LookupAccountSidW(L"",
                                       Buffer->User.Sid,
                                       AccountName,
                                       &AccountNameSize,
                                       Domain,
                                       &DomainNameSize,
                                       &Use
                                       );
            if (!Result)
            {
                ELF_LOG1(ERROR,
                         "GetUserInfo: LookupAccountSid (call 2) failed %d\n",
                         GetLastError());

                goto ErrorCleanup;
            }
        }
        else
        {
            ELF_LOG1(ERROR,
                     "GetUserInfo: LookupAccountsid (call 1) failed %d\n",
                     GetLastError());

            goto ErrorCleanup;
        }
    }
    else
    {
        ELF_LOG0(ERROR,
                 "GetUserInfo: LookupAccountSid succeeded unexpectedly\n");

        goto ErrorCleanup;
    }

    ELF_LOG2(TRACE,
             "GetUserInfo: Name = %ws\\%ws\n",
             Domain,
             AccountName);

    Result = GetTokenInformation(Token,
                                 TokenStatistics,
                                 &Statistics,
                                 sizeof(Statistics),
                                 &RequiredLength);

    if (!Result)
    {
        ELF_LOG1(ERROR,
                 "GetUserInfo: GetTokenInformation (call 3) failed %d\n",
                 GetLastError());

        goto ErrorCleanup;
    }

    StringCchPrintfW(LogonIdString, 256,
             L"(0x%X,0x%X)",
             Statistics.AuthenticationId.HighPart,
             Statistics.AuthenticationId.LowPart);

    ELF_LOG1(TRACE,
             "GetUserInfo: LogonIdString = %ws\n",
             LogonIdString);

    *AuthenticationId = ElfpAllocateBuffer(WCSSIZE(LogonIdString));

    if (*AuthenticationId == NULL)
    {
        ELF_LOG0(ERROR,
                 "GetUserInfo: Unable to allocate memory for AuthenticationId\n");

        goto ErrorCleanup;
    }

    StringCchCopyW(*AuthenticationId, wcslen(LogonIdString) +1, LogonIdString);

    //
    // Return accumulated information
    //

    if(UserSid)
    {
        *UserSid = ElfpAllocateBuffer(GetLengthSid(Buffer->User.Sid));

        if (*UserSid == NULL)
        {
            ELF_LOG0(ERROR,
                     "GetUserInfo: Unable to allocate memory for UserSid\n");

            goto ErrorCleanup;
        }

        Result = CopySid(GetLengthSid(Buffer->User.Sid),
                         *UserSid,
                         Buffer->User.Sid);
    }
    ElfpFreeBuffer(Buffer);

    *DomainName = Domain;
    *UserName   = AccountName;

    return TRUE;

ErrorCleanup:

    ElfpFreeBuffer(Buffer);
    ElfpFreeBuffer(Domain);
    ElfpFreeBuffer(AccountName);
    if(UserSid)
        ElfpFreeBuffer(*UserSid);
    ElfpFreeBuffer(*AuthenticationId);

    return FALSE;
}



LPWSTR 
GetNameFromIPAddress(
	LPWSTR pszComputerNameFromBinding)
/*++

Routine Description:

    Examines a string and determines if it looks like an ip address.  If it
    does, then it converts it to a fqdn

Arguments:

    Machine name:  Could be xxx.xxx.xxx.xxx or anything else!

Return Value:

    If successful, returns a fully qualified domain name which the caller
    will free.  Returns NULL if there are any problems.


--*/
{

	LPWSTR pComputerName = NULL;
	DWORD dwAddr;
	char cName[17];  // should be plenty of room
	size_t NumConv;
	HOSTENT  FAR * pEnt;
	DWORD dwSize;
	WORD wVersionRequested;
	WSADATA wsaData;
	int error;
	
	NumConv = wcstombs(cName, pszComputerNameFromBinding, 16);  
	if(NumConv == -1 || NumConv == 0)
	    return NULL;

	// convert the string into a network order dword representation
	
	dwAddr = inet_addr(cName);
	if(dwAddr == INADDR_NONE)
		return NULL;

	//  initialize sockets.

	wVersionRequested = MAKEWORD( 2, 2 );
 
    error = WSAStartup( wVersionRequested, &wsaData );
	if(error != 0)
	{
	   	ELF_LOG1(TRACE,
           "GetNameFromIPAddress: failed to initialize sockets, error = 0x%x\n", error);
		return NULL;
	}

		
	pEnt = gethostbyaddr((char FAR *)&dwAddr, 4, PF_INET);
	if(pEnt == NULL || pEnt->h_name == NULL)
	{
	   	ELF_LOG1(TRACE,
                 "GetNameFromIPAddress: failed gethostbyaddr, error = 0x%x\n",
                 WSAGetLastError());
		WSACleanup();
		return NULL;
	}
	dwSize = strlen(pEnt->h_name) + 1 ;
	pComputerName = ElfpAllocateBuffer(2*dwSize);
	if(pComputerName == NULL)
	{
	   	ELF_LOG0(ERROR,
                 "GetNameFromIPAddress: failed trying to allocate memory\n");
	    WSACleanup();
		return NULL;
	}
	pComputerName[0] = 0;
	mbstowcs(pComputerName, pEnt->h_name, dwSize);
    WSACleanup();
	return pComputerName;
}

BOOL
IsLocal(
    VOID
    )
/*++

Routine Description:

    Determines if the caller is local. 

Arguments:

    NONE

Return Value:

    TRUE if definately local.


--*/
{
    UINT            LocalFlag;
    RPC_STATUS      RpcStatus;
    RpcStatus = I_RpcBindingIsClientLocal(0, &LocalFlag);

    if( RpcStatus != RPC_S_OK ) 
    {
        ELF_LOG1(ERROR,
                 "IsLocal: I_RpcBindingIsClientLocal failed %d\n",
                 RpcStatus);
        return FALSE;
    }
    if(LocalFlag == 0)
        return FALSE;
    else
    	return TRUE;
}

LPWSTR
ElfpGetComputerName(
    VOID
    )

/*++

Routine Description:

    This routine gets the LPWSTR name of the computer. 

Arguments:

    NONE

Return Value:

    Returns a pointer to the computer name, or a NULL.  Note that the caller
    is expected to free this via 


--*/
{
    RPC_STATUS      RpcStatus;
    handle_t hServerBinding = NULL;
    LPWSTR pszBinding = NULL;
    LPWSTR pszComputerNameFromBinding = NULL;
	LPWSTR pszComputerName = NULL;
	DWORD dwSize;
	BOOL bOK;

//      Check if the connection is local.  If it is, then just 
//      call GetComputerName

	if(IsLocal())
	{
		dwSize = MAX_COMPUTERNAME_LENGTH + 1 ;
		pszComputerName = ElfpAllocateBuffer(2*dwSize);
		if(pszComputerName == NULL)
		{
        	ELF_LOG0(ERROR,
                 "ElfpGetComputerName: failed trying to allocate memory\n");
			return NULL;
		}
		bOK = GetComputerNameW(pszComputerName, &dwSize);
		if(bOK == FALSE)
		{
			ElfpFreeBuffer(pszComputerName);
        	ELF_LOG1(ERROR,
                 "ElfpGetComputerName: failed calling GetComputerNameW, last error 0x%x\n",
                  GetLastError());
            return NULL;    
		}
		else
			return pszComputerName;
	}

    RpcStatus = RpcBindingServerFromClient( NULL, &hServerBinding );
    if( RpcStatus != RPC_S_OK ) 
    {
        ELF_LOG1(ERROR,
                 "ElfpGetComputerName: RpcBindingServerFromClient failed %d\n",
                 RpcStatus);
        return NULL;
    }

	// This gets us something like "ncacn_np:xxx.xxx.xxx.xxx" or 
	// "ncacn_np:localMachine"
	
    RpcStatus = RpcBindingToStringBinding( hServerBinding, &pszBinding );
    if( RpcStatus != RPC_S_OK )
    {
        ELF_LOG1(ERROR,
                 "ElfpGetComputerName: RpcBindingToStringBinding failed %d\n",
                 RpcStatus);
        goto CleanExitGetCompName;
    } 

    // Acquire just the network address.  That will be something like
    // "xxx.xxx.xxx.xxx" or "mymachine"

    RpcStatus = RpcStringBindingParse( pszBinding,
                                                NULL,
                                                NULL,
                                                &pszComputerNameFromBinding,
                                                NULL,
                                                NULL );
    if( RpcStatus != RPC_S_OK || pszComputerNameFromBinding == NULL)
    {
        ELF_LOG1(ERROR,
                 "ElfpGetComputerName: RpcStringBindingParse failed %d\n",
                 RpcStatus);
        goto CleanExitGetCompName;
    }

    // sometimes the name is an ip address.  If it is, then the following determines
    // that and returns the right string.

    pszComputerName = GetNameFromIPAddress(pszComputerNameFromBinding);                                                
    if(pszComputerName == NULL)
    {
        dwSize = wcslen(pszComputerNameFromBinding) + 1;
        pszComputerName = ElfpAllocateBuffer(2*dwSize);
        if(pszComputerName == NULL)
        {
            ELF_LOG0(ERROR,
                 "ElfpGetComputerName: failed trying to allocate memory\n");
        }
        else
            StringCchCopyW(pszComputerName, dwSize, pszComputerNameFromBinding);
    }

CleanExitGetCompName:
	if(hServerBinding)
		RpcStatus = RpcBindingFree(&hServerBinding);
	if(pszBinding)
		RpcStatus = RpcStringFree(&pszBinding);
	if(pszComputerNameFromBinding)
		RpcStatus = RpcStringFree(&pszComputerNameFromBinding);
    return pszComputerName;
}


NTSTATUS
ElfpGetClientSidString(
    LPWSTR * ppwsClientSidString,
    PTOKEN_USER * ppToken
    )
/*++

Routine Description:

    This routine gets the LPWSTR version of the RPC callers SID. Note that
    upon success, the calling routine should free this via ElfpFreeBuffer

Arguments:

    ppwsClientSidString - upon succes, this will have a fail safe version
    of the client info which the caller must free

Return Value:

    NTSTATUS value 


--*/
{
    NTSTATUS Status, RevertStatus;
    BOOL bImpersonating = FALSE;
    HANDLE hToken;
    BOOL bGotToken = FALSE;
    DWORD            RequiredLength;
    UNICODE_STRING UnicodeStringSid;
    BOOL bNeedToFreeUnicodeStr = FALSE;
    DWORD dwRetStringSize = 0;

    *ppwsClientSidString = NULL;
    *ppToken = NULL;
    
    // impersonate the client
    
    Status = I_RpcMapWin32Status( RpcImpersonateClient( NULL ) );
    if ( !NT_SUCCESS( Status ) )
    {
        ELF_LOG1(ERROR, "ElfpGetClientSidString: RpcImpersonateClient failed %#x\n", Status);
        goto ExitElfpGetClientSidString;
    }
    bImpersonating = TRUE;

    // Get the thread token
    
    Status = NtOpenThreadToken (GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken);
    if ( !NT_SUCCESS( Status ) )
    {
        ELF_LOG1(ERROR, "ElfpGetClientSidString: NtOpenThreadToken failed %#x\n", Status);
        goto ExitElfpGetClientSidString;
    }
    bGotToken = TRUE;

    // first find out how much memory is needed
    
    Status = NtQueryInformationToken (hToken, TokenUser, NULL, 0, &RequiredLength);
    if (Status != STATUS_BUFFER_TOO_SMALL)
    {
        ELF_LOG1(ERROR, "ElfpGetClientSidString: 1stNtQueryInformationToken isnt too small %#x\n", Status);
        if(NT_SUCCESS( Status ))
        {
            // weird case, should never happen, but we dont want caller to think this worked by
            // accident
            
            Status = STATUS_UNSUCCESSFUL;
        }
        goto ExitElfpGetClientSidString;
    }

    // get the memory and actually read the data
    
    *ppToken = ElfpAllocateBuffer(RequiredLength);
    if (*ppToken == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfpGetClientSidString: Unable to allocate memory for token\n");
        Status = STATUS_NO_MEMORY;
        goto ExitElfpGetClientSidString;
    }

    Status = NtQueryInformationToken (hToken,
                                 TokenUser,
                                 *ppToken,
                                 RequiredLength,
                                 &RequiredLength);
    if ( !NT_SUCCESS( Status ) )
    {
        ELF_LOG1(ERROR, "ElfpGetClientSidString: 2nNtQueryInformationToken failed %#x\n", Status);
        goto ExitElfpGetClientSidString;
    }

    // Convert using the Rtl functions

    Status = RtlConvertSidToUnicodeString( &UnicodeStringSid, (*ppToken)->User.Sid, TRUE );
    if ( !NT_SUCCESS( Status ) ) {
        ELF_LOG1(ERROR, "ElfpGetClientSidString: RtlConvertSidToUnicodeString failed %#x\n", Status);
        goto ExitElfpGetClientSidString;
    }
    bNeedToFreeUnicodeStr = TRUE;

    // allocate and convert

    dwRetStringSize = UnicodeStringSid.Length + sizeof(WCHAR);
    *ppwsClientSidString = ElfpAllocateBuffer(dwRetStringSize);
    if (*ppwsClientSidString == NULL)
    {
        ELF_LOG0(ERROR,
                 "ElfpGetClientSidString: Unable to allocate memory for returned string\n");
        Status = STATUS_NO_MEMORY;
        goto ExitElfpGetClientSidString;
    }

    StringCbCopyW( *ppwsClientSidString, dwRetStringSize, UnicodeStringSid.Buffer);
    Status = STATUS_SUCCESS;

ExitElfpGetClientSidString:

    if(bImpersonating)
    {
        RevertStatus = I_RpcMapWin32Status( RpcRevertToSelf() );
        if ( !NT_SUCCESS( RevertStatus ) )
        {
            ELF_LOG1(ERROR, "ElfpGetClientSidString: RpcRevertToSelf failed %#x\n", Status);
            if(NT_SUCCESS( Status ))
                Status = RevertStatus;
        }
    }
    if(!NT_SUCCESS( Status ) && *ppwsClientSidString)
    {
        ElfpFreeBuffer(*ppwsClientSidString);
        *ppwsClientSidString = NULL;
    }
    if(!NT_SUCCESS( Status ) && *ppToken)
    {
        ElfpFreeBuffer(*ppToken);
        *ppToken = NULL;
    }
    if(bGotToken)
        NtClose(hToken);
    if(bNeedToFreeUnicodeStr)
        RtlFreeUnicodeString( &UnicodeStringSid );
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\test\testwin.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    TESTWIN.C

Abstract:

    Test program for the eventlog service. This program calls the Win
    APIs to test out the operation of the service.

Author:

    Rajen Shah  (rajens) 05-Aug-1991

Revision History:


--*/
/*----------------------*/
/* INCLUDES             */
/*----------------------*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>      // printf
#include <string.h>     // stricmp
#include <stdlib.h>
#include <windows.h>
#include <netevent.h>

//
// Turn on NotifyChangeEventLog
//
#define     TEST_NOTIFY         1
//#define     TEST_REMOTE         1

#define     READ_BUFFER_SIZE        1024*2      // Use 2K buffer

#define     SIZE_DATA_ARRAY         65

//
// Global buffer used to emulate "binary data" when writing an event
// record.
//
    DWORD    Data[SIZE_DATA_ARRAY];
//    LPWSTR   ServerName=L"\\\\danl2";
    LPWSTR   ServerName=NULL;


VOID
Initialize (
    VOID
    )
{
    DWORD   i;

    // Initialize the values in the data buffer.
    //
    for (i=0; i< SIZE_DATA_ARRAY; i++)
        Data[i] = i;

}


BOOL
Usage (
    VOID
    )
{
    printf( "usage: \n" );
    printf( "-b <filename>  Tests BackupEventLog API\n");
    printf( "-c             Tests ClearEventLog API\n");
    printf( "-n             Tests NotifyChangeEventlog\n");
    printf( "-rsb           Reads event log sequentially backwards\n");
    printf( "-rsf           Reads event log sequentially forwards\n");
    printf( "-rrb <record>  Reads event log from <record> backwards\n");
    printf( "-rrf <record>  Reads event log from <record> forwards\n");
    printf( "-w <count>     Tests ReportEvent API <count> times\n");
    return ERROR_INVALID_PARAMETER;

} // Usage



BOOL
WriteLogEntry ( HANDLE LogHandle, DWORD EventID )

{
#define NUM_STRINGS     2

    BOOL    Status;
    WORD    EventType, i;
    DWORD   DataSize;
    PSID    pUserSid;

    PWSTR   Strings[NUM_STRINGS] = {L"StringAOne",
                                   L"StringATwo"
                                  };

    EventType = EVENTLOG_INFORMATION_TYPE;
    pUserSid   = NULL;
    DataSize  = sizeof(DWORD) * SIZE_DATA_ARRAY;

    for (i=0; i< SIZE_DATA_ARRAY; i++)
        Data[i] += i;

    Status = ReportEventW (
                    LogHandle,
                    EventType,
                    0,            // event category
                    EventID,
                    pUserSid,
                    NUM_STRINGS,
                    DataSize,
                    Strings,
                    (PVOID)Data
                    );

    return (Status);
}

DWORD
WriteLogEntryMsg ( HANDLE LogHandle, DWORD EventID )
/*
    This function requires a registry entry in the Applications section
    of the Eventlog for TESTWINAPP, it will use the netevent.dll message file.
*/

{
#define NUM_STRINGS     2

    WORD    EventType;
    DWORD   DataSize;
    PSID    pUserSid;

    PWSTR   Strings[NUM_STRINGS];

    Strings[0] = L"This is a BOGUS message for TEST purposes Ignore this substitution text";
    Strings[1] = L"GHOST SERVICE in the long string format - I wanted a long string to pass into this function";

    EventType = EVENTLOG_INFORMATION_TYPE;
    pUserSid   = NULL;
    DataSize  = sizeof(DWORD) * SIZE_DATA_ARRAY;


    if (!ReportEventW (
                    LogHandle,
                    EventType,
                    0,            // event category
                    EVENT_SERVICE_START_FAILED_NONE,
                    pUserSid,
                    NUM_STRINGS,
                    0,              // DataSize
                    Strings,
                    (PVOID)NULL     // Data
                    )) {

        printf("ReportEventW failed %d\n",GetLastError());
        return(GetLastError());
    }
    return (NO_ERROR);
}


VOID
DisplayEventRecords( PVOID Buffer,
                     DWORD  BufSize,
                     ULONG *NumRecords)

{
    PEVENTLOGRECORD     pLogRecord;
    ANSI_STRING         StringA;
    UNICODE_STRING      StringU;
    PWSTR               pwString;
    DWORD               Count = 0;
    DWORD               Offset = 0;
    DWORD               i;

    pLogRecord = (PEVENTLOGRECORD) Buffer;

    while ((DWORD)Offset < BufSize) {

        printf("\nRecord # %lu\n", ++Count);

        printf("Length: 0x%lx TimeGenerated: 0x%lx  EventID: 0x%lx EventType: 0x%x\n",
                pLogRecord->Length, pLogRecord->TimeGenerated, pLogRecord->EventID,
                pLogRecord->EventType);

        printf("NumStrings: 0x%x StringOffset: 0x%lx UserSidLength: 0x%lx TimeWritten: 0x%lx\n",
                pLogRecord->NumStrings, pLogRecord->StringOffset,
                pLogRecord->UserSidLength, pLogRecord->TimeWritten);

        printf("UserSidOffset: 0x%lx    DataLength: 0x%lx    DataOffset:  0x%lx \n",
                pLogRecord->UserSidOffset, pLogRecord->DataLength,
                pLogRecord->DataOffset);

        //
        // Print out module name
        //
        pwString = (PWSTR)((DWORD)pLogRecord + sizeof(EVENTLOGRECORD));
        RtlInitUnicodeString (&StringU, pwString);
        RtlUnicodeStringToAnsiString (&StringA, &StringU, TRUE);

        printf("ModuleName:  %s ", StringA.Buffer);
        RtlFreeAnsiString (&StringA);

        //
        // Display ComputerName
        //
        pwString = pwString + (wcslen(pwString) + 1);

        RtlInitUnicodeString (&StringU, pwString);
        RtlUnicodeStringToAnsiString (&StringA, &StringU, TRUE);

        printf("ComputerName: %s\n",StringA.Buffer);
        RtlFreeAnsiString (&StringA);

        //
        // Display strings
        //
        pwString = (PWSTR)((DWORD)Buffer + pLogRecord->StringOffset);

        printf("\nStrings: \n");
        for (i=0; i<pLogRecord->NumStrings; i++) {

            RtlInitUnicodeString (&StringU, pwString);
            RtlUnicodeStringToAnsiString (&StringA, &StringU, TRUE);

            printf("  %s  \n",StringA.Buffer);

            RtlFreeAnsiString (&StringA);

            pwString = (PWSTR)((DWORD)pwString + StringU.MaximumLength);
        }

        // Get next record
        //
        Offset += pLogRecord->Length;

        pLogRecord = (PEVENTLOGRECORD)((DWORD)Buffer + Offset);

    }
    *NumRecords = Count;

}


BOOL
ReadFromLog ( HANDLE LogHandle,
             PVOID  Buffer,
             ULONG *pBytesRead,
             DWORD  ReadFlag,
             DWORD  Record
             )
{
    BOOL        Status;
    DWORD       MinBytesNeeded;
    DWORD       ErrorCode;

    Status = ReadEventLogW (
                        LogHandle,
                        ReadFlag,
                        Record,
                        Buffer,
                        READ_BUFFER_SIZE,
                        pBytesRead,
                        &MinBytesNeeded
                        );


    if (!Status) {
         ErrorCode = GetLastError();
         if (ErrorCode == ERROR_HANDLE_EOF) {
             Status = TRUE;
         }
         else if (ErrorCode == ERROR_NO_MORE_FILES) {
            printf("Buffer too small. Need %lu bytes min\n", MinBytesNeeded);
         }
         else {
             printf("Error from ReadEventLog %d \n", ErrorCode);
         }

    }

    return (Status);
}




BOOL
TestReadEventLog (DWORD Count, DWORD ReadFlag, DWORD Record)

{
    BOOL    bStatus,IStatus;
    DWORD   status;
    HANDLE  LogHandle;
    LPWSTR  ModuleName;
    DWORD   NumRecords, BytesReturned;
    PVOID   Buffer;
    DWORD   RecordOffset;
    DWORD   NumberOfRecords;
    DWORD   OldestRecord;

    printf("Testing ReadEventLog API to read %lu entries\n",Count);

    Buffer = malloc (READ_BUFFER_SIZE);

    //
    // Initialize the strings
    //
    NumRecords = Count;
    ModuleName = L"TESTWINAPP";

    //
    // Open the log handle
    //
    printf("OpenEventLog - ");
    LogHandle = OpenEventLogW (
                    ServerName,
                    ModuleName
                    );

    if (LogHandle == NULL) {
         printf("Error - %d\n", GetLastError());

    } else {
        printf("SUCCESS\n");

        //
        // Get and print record information
        //

        bStatus = GetNumberOfEventLogRecords(LogHandle, & NumberOfRecords);
        if (bStatus) {
           bStatus = GetOldestEventLogRecord(LogHandle, & OldestRecord);
        }

        if (!bStatus) {
           printf("Query of record information failed with %X", GetLastError());
           return(bStatus);
        }

        printf("\nThere are %d records in the file, %d is the oldest"
         " record number\n", NumberOfRecords, OldestRecord);

        RecordOffset = Record;

        printf("Reading %u records\r", Count);

        while (Count) {

            //
            // Read from the log
            //
            bStatus = ReadFromLog ( LogHandle,
                                   Buffer,
                                   &BytesReturned,
                                   ReadFlag,
                                   RecordOffset
                                 );
            if (bStatus) {
                printf("Bytes read = 0x%lx\n", BytesReturned);
                printf("Read %u records\n", NumRecords);
                DisplayEventRecords(Buffer, BytesReturned, &NumRecords);
                Count -= NumRecords;
                RecordOffset += NumRecords;
            } else {
                break;
            }

            if (BytesReturned == 0)
                break;
        }
        printf("\n");

        if (!bStatus) {
            printf ("ReadFromLog Error - %d. Remaining count %lu\n", GetLastError(),
                Count);
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling CloseEventLog\n");
        IStatus = CloseEventLog (LogHandle);
    }

    return (bStatus);
}



BOOL
TestWriteEventLog (DWORD Count)

{
    DWORD       Status=NO_ERROR;
    BOOL        IStatus;
    HANDLE      LogHandle;
    LPWSTR      ModuleName;
    DWORD       EventID = 99;
    DWORD       WriteCount;
    DWORD       DataNum=0;

    printf("Testing ReportEvent API\n");

    //
    // Initialize the strings
    //
    ModuleName = L"TESTWINAPP";

    printf("Calling RegisterEventSource for WRITE %lu times\n", Count);
    while ((Count > 0) && (Status== NO_ERROR)) {
        //
        // Open the log handle
        //
        LogHandle = RegisterEventSourceW (
                        ServerName,
                        ModuleName
                        );

        if (LogHandle == NULL) {
            Status = GetLastError();
            printf("RegisterEventSource Failure - %d\n", Status);
            return(Status);

        } else {
            printf("Registered - ");
            WriteCount = 5;
            printf("Record # %u:  ", Count);

            while ((WriteCount>0) && (Status==NO_ERROR)) {

                //
                // Write an entry into the log
                //
                Data[0] = DataNum;                     // Make data "unique"
                EventID = (EventID + DataNum) % 100;   // Vary the eventids
                Status = WriteLogEntryMsg( LogHandle, EventID );
                DataNum++;
                WriteCount--;

                if (Status != NO_ERROR) {
                    printf ("WriteLogEntry Error - %d. Remaining count %lu\n",Status,Count);
                } else {
                    printf ("%d,",WriteCount);
                }
            }

            IStatus = DeregisterEventSource (LogHandle);
            printf(" - Deregistered\n");
        }
        Count--;
    }

    printf("\n");
    return (Status);
}



BOOL
TestClearLogFile ()

{
    BOOL        Status, IStatus;
    HANDLE      LogHandle;
    LPWSTR ModuleName, BackupName;

    printf("Testing ClearLogFile API\n");
    //
    // Initialize the strings
    //
    ModuleName = L"TESTWINAPP";

    //
    // Open the log handle
    //
    printf("Calling OpenEventLog for CLEAR - ");
    LogHandle = OpenEventLogW (
                    NULL,
                    ModuleName
                    );

    if (LogHandle == NULL) {
         printf("OpenEventLog Error - %d\n", GetLastError());

    } else {
        printf("SUCCESS\n");

        //
        // Clear the log file and back it up to "view.log"
        //

        printf("Calling ClearEventLog backing up to view.log  ");
        BackupName = L"\\\\danhi386\\roote\\view.log";

        Status = ClearEventLogW (
                        LogHandle,
                        BackupName
                        );

        if (!Status) {
            printf ("ClearEventLog Error - %d\n", GetLastError());
        } else {
            printf ("SUCCESS\n");
        }

        //
        // Now just clear the file without backing it up
        //
        printf("Calling ClearEventLog with no backup  ");
        Status = ClearEventLogW (
                        LogHandle,
                        NULL
                        );

        if (!Status) {
            printf ("ClearEventLogError - %d\n", GetLastError());
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling CloseEventLog\n");
        IStatus = CloseEventLog (LogHandle);
    }

    return(Status);
}

BOOL
TestBackupLogFile (LPSTR BackupFileName)

{
    BOOL        Status, IStatus;
    HANDLE      LogHandle;
    LPWSTR ModuleName;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    printf("Testing BackupLogFile API\n");
    //
    // Initialize the strings
    //
    ModuleName = L"TESTWINAPP";

    //
    // Open the log handle
    //
    printf("Calling OpenEventLog for BACKUP - ");
    LogHandle = OpenEventLogW (
                    NULL,
                    ModuleName
                    );

    if (LogHandle == NULL) {
         printf("OpenEventLog Failure %d\n", GetLastError());

    } else {
        printf("OpenEventLog SUCCESS\n");

        //
        // Backup the log file to BackupFileName
        //

        printf("Calling BackupEventLog backing up to %s  ", BackupFileName);

    RtlInitAnsiString(&AnsiString, BackupFileName);
    RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);

    Status = BackupEventLogW (LogHandle, UnicodeString.Buffer);

        if (!Status) {
            printf ("BackupEventLog failure - %d\n", GetLastError());
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling CloseEventLog\n");
        IStatus = CloseEventLog (LogHandle);
    }

    return(Status);
}

VOID
NotifyThread(
    HANDLE  hEventLog)
{
    Sleep(30000);
    printf("NotifyThread: Writing an event...\n");
    if (!WriteLogEntryMsg(hEventLog,1)) {
        printf("NotifyThread: WriteLogEntryMsg failed\n");
    }
    else {
        printf("Event was written\n");
    }
    ExitThread(NO_ERROR);
}

VOID
TestChangeNotify(
    )

/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    HANDLE      hEvent;
    HANDLE      hThread;
    HANDLE      hEventLog;
    DWORD       threadId;
    DWORD       status;

    hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    if (hEvent == NULL) {
        printf("CreateEvent Failed %d\n",GetLastError());
        return;
    }
#ifdef TEST_REMOTE
    hEventLog = RegisterEventSourceW(L"\\\\DANL2",L"TESTWINAPP");
#else
    hEventLog = RegisterEventSourceW(NULL,L"TESTWINAPP");
#endif
    if (hEventLog == NULL) {
        printf("OpenEventLog failed %d\n",GetLastError());
    }

#ifdef TEST_NOTIFY

    if (!NotifyChangeEventLog(hEventLog,hEvent)) {
        printf("NotifyChangeEventLog failed %d\n",GetLastError());
    }
#endif  // TEST_NOTIFY

    hThread = CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)NotifyThread,hEventLog,0,&threadId);
    if (hThread == NULL) {
        printf("CreateThread Failed %d\n",GetLastError());
        CloseHandle(hEvent);
        return;
    }

    CloseHandle(hThread);

    printf("Wait for event to become signaled\n");
    status = WaitForSingleObject(hEvent,INFINITE);
    if (status == WAIT_OBJECT_0) {
        printf("The Event was signaled\n");
    }
    else {
        printf("The Event was NOT signaled\n");
    }
    return;
}
/****************************************************************************/
DWORD __cdecl
main (
    IN SHORT argc,
    IN PSZ argv[],
    IN PSZ envp[]
    )
/*++
*
* Routine Description:
*
*
*
* Arguments:
*
*
*
*
* Return Value:
*
*
*
--*/
/****************************************************************************/
{

    DWORD   ReadFlags;

    Initialize();           // Init any data

    if ( argc < 2 ) {
        printf( "Not enough parameters\n" );
        return Usage( );
    }

    if ( stricmp( argv[1], "-c" ) == 0 ) {

        if ( argc < 3 ) {
            return TestClearLogFile();
        }
    }
    else if ( stricmp( argv[1], "-b" ) == 0 ) {

        if ( argc < 3 ) {
            printf("You must supply a filename to backup to\n");
            return(FALSE);
        }

            return TestBackupLogFile(argv[2]);

    } else if (stricmp ( argv[1], "-rsf" ) == 0 ) {

        ReadFlags = EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags,0 );
        } else  {
            return Usage();
        }
    } else if (stricmp ( argv[1], "-rsb" ) == 0 ) {

        ReadFlags = EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags,0 );
        } else  {
            return Usage();
        }
    } else if (stricmp ( argv[1], "-n" ) == 0 ) {
        TestChangeNotify();

    } else if (stricmp ( argv[1], "-rrf" ) == 0 ) {

        ReadFlags = EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags ,1);
        } else if (argc == 3) {
            return (TestReadEventLog (1, ReadFlags, atoi(argv[2])));
        }
    } else if (stricmp ( argv[1], "-rrb" ) == 0 ) {

        ReadFlags = EVENTLOG_SEEK_READ | EVENTLOG_BACKWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags, 1);
        } else if (argc == 3) {
            return (TestReadEventLog (1, ReadFlags, atoi(argv[2])));
        }
    } else if (stricmp ( argv[1], "-w" ) == 0 ) {

        if ( argc < 3 ) {
            return TestWriteEventLog(1);
        } else if (argc == 3) {
            return (TestWriteEventLog (atoi(argv[2])));
        }

    } else {

        return Usage();
    }

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);
    UNREFERENCED_PARAMETER(envp);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\cachesup.c ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    Cache.c

Abstract:

    This module implements the cache management routines for the Cdfs
    FSD and FSP, by calling the Common Cache Manager.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_CACHESUP)

//
//  Local debug trace level
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCompleteMdl)
#pragma alloc_text(PAGE, CdCreateInternalStream)
#pragma alloc_text(PAGE, CdDeleteInternalStream)
#pragma alloc_text(PAGE, CdPurgeVolume)
#endif


VOID
CdCreateInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This function creates an internal stream file for interaction
    with the cache manager.  The Fcb here can be for either a
    directory stream or for a path table stream.

Arguments:

    Vcb - Vcb for this volume.

    Fcb - Points to the Fcb for this file.  It is either an Index or
        Path Table Fcb.

Return Value:

    None.

--*/

{
    PFILE_OBJECT StreamFile = NULL;
    BOOLEAN DecrementReference = FALSE;

    BOOLEAN CleanupDirContext = FALSE;
    BOOLEAN UpdateFcbSizes = FALSE;

    DIRENT Dirent;
    DIRENT_ENUM_CONTEXT DirContext;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  We may only have the Fcb shared.  Lock the Fcb and do a
    //  safe test to see if we need to really create the file object.
    //

    CdLockFcb( IrpContext, Fcb );

    if (Fcb->FileObject != NULL) {

        CdUnlockFcb( IrpContext, Fcb );
        return;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Create the internal stream.  The Vpb should be pointing at our volume
        //  device object at this point.
        //

        StreamFile = IoCreateStreamFileObject( NULL, Vcb->Vpb->RealDevice );

        if (StreamFile == NULL) {

            CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        //  Initialize the fields of the file object.
        //

        StreamFile->ReadAccess = TRUE;
        StreamFile->WriteAccess = FALSE;
        StreamFile->DeleteAccess = FALSE;

        StreamFile->SectionObjectPointer = &Fcb->FcbNonpaged->SegmentObject;

        //
        //  Set the file object type and increment the Vcb counts.
        //

        CdSetFileObject( IrpContext,
                         StreamFile,
                         StreamFileOpen,
                         Fcb,
                         NULL );

        //
        //  We will reference the current Fcb twice to keep it from going
        //  away in the error path.  Otherwise if we dereference it
        //  below in the finally clause a close could cause the Fcb to
        //  be deallocated.
        //

        CdLockVcb( IrpContext, Vcb );
        CdIncrementReferenceCounts( IrpContext, Fcb, 2, 0 );
        CdUnlockVcb( IrpContext, Vcb );
        DecrementReference = TRUE;

        //
        //  Initialize the cache map for the file.
        //

        CcInitializeCacheMap( StreamFile,
                              (PCC_FILE_SIZES)&Fcb->AllocationSize,
                              TRUE,
                              &CdData.CacheManagerCallbacks,
                              Fcb );

        //
        //  Go ahead and store the stream file into the Fcb.
        //

        Fcb->FileObject = StreamFile;
        StreamFile = NULL;

        //
        //  If this is the first file object for a directory then we need to
        //  read the self entry for this directory and update the sizes
        //  in the Fcb.  We know that the Fcb has been initialized so
        //  that we have a least one sector available to read.
        //

        if (!FlagOn( Fcb->FcbState, FCB_STATE_INITIALIZED )) {

            ULONG NewDataLength;

            //
            //  Initialize the search structures.
            //

            CdInitializeDirContext( IrpContext, &DirContext );
            CdInitializeDirent( IrpContext, &Dirent );
            CleanupDirContext = TRUE;

            //
            //  Read the dirent from disk and transfer the data to the
            //  in-memory dirent.
            //

            CdLookupDirent( IrpContext,
                            Fcb,
                            Fcb->StreamOffset,
                            &DirContext );

            CdUpdateDirentFromRawDirent( IrpContext, Fcb, &DirContext, &Dirent );

            //
            //  Verify that this really for the self entry.  We do this by
            //  updating the name in the dirent and then checking that it matches
            //  one of the hard coded names.
            //

            CdUpdateDirentName( IrpContext, &Dirent, FALSE );

            if (Dirent.CdFileName.FileName.Buffer != CdUnicodeSelfArray) {

                CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            //
            //  If the data sizes are different then update the header
            //  and Mcb for this Fcb.
            //

            NewDataLength = BlockAlign( Vcb, Dirent.DataLength + Fcb->StreamOffset );

            if (NewDataLength == 0) {

                CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            if (NewDataLength != Fcb->FileSize.QuadPart) {

                Fcb->AllocationSize.QuadPart =
                Fcb->FileSize.QuadPart =
                Fcb->ValidDataLength.QuadPart = NewDataLength;

                CcSetFileSizes( Fcb->FileObject, (PCC_FILE_SIZES) &Fcb->AllocationSize );

                CdTruncateAllocation( IrpContext, Fcb, 0 );
                CdAddInitialAllocation( IrpContext,
                                        Fcb,
                                        Dirent.StartingOffset,
                                        NewDataLength );

                UpdateFcbSizes = TRUE;
            }

            //
            //  Check for the existence flag and transform to hidden.
            //

            if (FlagOn( Dirent.DirentFlags, CD_ATTRIBUTE_HIDDEN )) {

                SetFlag( Fcb->FileAttributes, FILE_ATTRIBUTE_HIDDEN );
            }

            //
            //  Convert the time to NT time.
            //

            CdConvertCdTimeToNtTime( IrpContext,
                                     Dirent.CdTime,
                                     (PLARGE_INTEGER) &Fcb->CreationTime );

            //
            //  Update the Fcb flags to indicate we have read the
            //  self entry.
            //

            SetFlag( Fcb->FcbState, FCB_STATE_INITIALIZED );

            //
            //  If we updated the sizes then we want to purge the file.  Go
            //  ahead and unpin and then purge the first page.
            //

            CdCleanupDirContext( IrpContext, &DirContext );
            CdCleanupDirent( IrpContext, &Dirent );
            CleanupDirContext = FALSE;

            if (UpdateFcbSizes) {

                CcPurgeCacheSection( &Fcb->FcbNonpaged->SegmentObject,
                                     NULL,
                                     0,
                                     FALSE );
            }
        }

    } finally {

        //
        //  Cleanup any dirent structures we may have used.
        //

        if (CleanupDirContext) {

            CdCleanupDirContext( IrpContext, &DirContext );
            CdCleanupDirent( IrpContext, &Dirent );
        }

        //
        //  If we raised then we need to dereference the file object.
        //

        if (StreamFile != NULL) {

            ObDereferenceObject( StreamFile );
            Fcb->FileObject = NULL;
        }

        //
        //  Dereference and unlock the Fcb.
        //

        if (DecrementReference) {

            CdLockVcb( IrpContext, Vcb );
            CdDecrementReferenceCounts( IrpContext, Fcb, 1, 0 );
            CdUnlockVcb( IrpContext, Vcb );
        }

        CdUnlockFcb( IrpContext, Fcb );
    }

    return;
}


VOID
CdDeleteInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This function creates an internal stream file for interaction
    with the cache manager.  The Fcb here can be for either a
    directory stream or for a path table stream.

Arguments:

    Fcb - Points to the Fcb for this file.  It is either an Index or
        Path Table Fcb.

Return Value:

    None.

--*/

{
    PFILE_OBJECT FileObject;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Lock the Fcb.
    //

    CdLockFcb( IrpContext, Fcb );

    //
    //  Capture the file object.
    //

    FileObject = Fcb->FileObject;
    Fcb->FileObject = NULL;

    //
    //  It is now safe to unlock the Fcb.
    //

    CdUnlockFcb( IrpContext, Fcb );

    //
    //  Dereference the file object if present.
    //

    if (FileObject != NULL) {

        if (FileObject->PrivateCacheMap != NULL) {

            CcUninitializeCacheMap( FileObject, NULL, NULL );
        }

        ObDereferenceObject( FileObject );
    }

    return;
}


NTSTATUS
CdCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the function of completing Mdl reads.
    It should be called only from CdFsdRead.

Arguments:

    Irp - Supplies the originating Irp.

Return Value:

    NTSTATUS - Will always be STATUS_SUCCESS.

--*/

{
    PFILE_OBJECT FileObject;

    PAGED_CODE();

    //
    // Do completion processing.
    //

    FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;

    CcMdlReadComplete( FileObject, Irp->MdlAddress );

    //
    // Mdl is now deallocated.
    //

    Irp->MdlAddress = NULL;

    //
    // Complete the request and exit right away.
    //

    CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


NTSTATUS
CdPurgeVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN DismountUnderway
    )

/*++

Routine Description:

    This routine is called to purge the volume.  The purpose is to make all the stale file
    objects in the system go away in order to lock the volume.

    The Vcb is already acquired exclusively.  We will lock out all file operations by
    acquiring the global file resource.  Then we will walk through all of the Fcb's and
    perform the purge.

Arguments:

    Vcb - Vcb for the volume to purge.

    DismountUnderway - Indicates that we are trying to delete all of the objects.
        We will purge the Path Table and VolumeDasd and dereference all
        internal streams.

Return Value:

    NTSTATUS - The first failure of the purge operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PVOID RestartKey = NULL;
    PFCB ThisFcb = NULL;
    PFCB NextFcb;

    BOOLEAN RemovedFcb;

    PAGED_CODE();

    ASSERT_EXCLUSIVE_VCB( Vcb);

    //
    //  Force any remaining Fcb's in the delayed close queue to be closed.
    //

    CdFspClose( Vcb );

    //
    //  Acquire the global file resource.
    //

    CdAcquireAllFiles( IrpContext, Vcb );

    //
    //  Loop through each Fcb in the Fcb Table and perform the flush.
    //

    while (TRUE) {

        //
        //  Lock the Vcb to lookup the next Fcb.
        //

        CdLockVcb( IrpContext, Vcb );
        NextFcb = CdGetNextFcb( IrpContext, Vcb, &RestartKey );

        //
        //  Reference the NextFcb if present.
        //

        if (NextFcb != NULL) {

            NextFcb->FcbReference += 1;
        }

        //
        //  If the last Fcb is present then decrement reference count and call teardown
        //  to see if it should be removed.
        //

        if (ThisFcb != NULL) {

            ThisFcb->FcbReference -= 1;

            CdUnlockVcb( IrpContext, Vcb );

            CdTeardownStructures( IrpContext, ThisFcb, &RemovedFcb );

        } else {

            CdUnlockVcb( IrpContext, Vcb );
        }

        //
        //  Break out of the loop if no more Fcb's.
        //

        if (NextFcb == NULL) {

            break;
        }

        //
        //  Move to the next Fcb.
        //

        ThisFcb = NextFcb;

        //
        //  If there is a image section then see if that can be closed.
        //

        if (ThisFcb->FcbNonpaged->SegmentObject.ImageSectionObject != NULL) {

            MmFlushImageSection( &ThisFcb->FcbNonpaged->SegmentObject, MmFlushForWrite );
        }

        //
        //  If there is a data section then purge this.  If there is an image
        //  section then we won't be able to.  Remember this if it is our first
        //  error.
        //

        if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
            !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                   NULL,
                                   0,
                                   FALSE ) &&
            (Status == STATUS_SUCCESS)) {

            Status = STATUS_UNABLE_TO_DELETE_SECTION;
        }

        //
        //  Dereference the internal stream if dismounting.
        //

        if (DismountUnderway &&
            (SafeNodeType( ThisFcb ) != CDFS_NTC_FCB_DATA) &&
            (ThisFcb->FileObject != NULL)) {

            CdDeleteInternalStream( IrpContext, ThisFcb );
        }
    }

    //
    //  Now look at the path table and volume Dasd Fcb's.
    //

    if (DismountUnderway) {

        if (Vcb->PathTableFcb != NULL) {

            ThisFcb = Vcb->PathTableFcb;
            InterlockedIncrement( &Vcb->PathTableFcb->FcbReference );

            if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
                !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                       NULL,
                                       0,
                                       FALSE ) &&
                (Status == STATUS_SUCCESS)) {

                Status = STATUS_UNABLE_TO_DELETE_SECTION;
            }

            CdDeleteInternalStream( IrpContext, ThisFcb );

            InterlockedDecrement( &ThisFcb->FcbReference );

            CdTeardownStructures( IrpContext, ThisFcb, &RemovedFcb );
        }

        if (Vcb->VolumeDasdFcb != NULL) {

            ThisFcb = Vcb->VolumeDasdFcb;
            InterlockedIncrement( &ThisFcb->FcbReference );

            if ((ThisFcb->FcbNonpaged->SegmentObject.DataSectionObject != NULL) &&
                !CcPurgeCacheSection( &ThisFcb->FcbNonpaged->SegmentObject,
                                       NULL,
                                       0,
                                       FALSE ) &&
                (Status == STATUS_SUCCESS)) {

                Status = STATUS_UNABLE_TO_DELETE_SECTION;
            }

            InterlockedDecrement( &ThisFcb->FcbReference );

            CdTeardownStructures( IrpContext, ThisFcb, &RemovedFcb );
        }
    }

    //
    //  Release all of the files.
    //

    CdReleaseAllFiles( IrpContext, Vcb );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\cd.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Cd.h

Abstract:

    This module defines the on-disk structure of the Cdfs file system.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _CDFS_
#define _CDFS_

//
//  Sector size on Cdrom disks is hard-coded to 2048
//

#ifndef SECTOR_SIZE
#define SECTOR_SIZE                 (2048)
#endif

#define RAW_SECTOR_SIZE             (2352)
#define SECTOR_MASK                 (SECTOR_SIZE - 1)
#define INVERSE_SECTOR_MASK         ~(SECTOR_SIZE - 1)

#ifndef SECTOR_SHIFT
#define SECTOR_SHIFT                (11)
#endif

#define XA_SECTOR_SIZE              (2352)

//
//  Cdfs file id is a large integer.
//

typedef LARGE_INTEGER               FILE_ID;
typedef FILE_ID                     *PFILE_ID;

//
//  The following constants are values from the disk.
//

#define FIRST_VD_SECTOR             (16)

#define VOL_ID_LEN                  (5)
#define ESC_SEQ_LEN                 (3)

#define VERSION_1                   (1)

#define VD_TERMINATOR               (255)
#define VD_PRIMARY                  (1)
#define VD_SECONDARY                (2)

#define VOLUME_ID_LENGTH            (32)

//
//  Leave the following so that CdfsBoot.c will compile
//

#define CD_SECTOR_SIZE              (2048)

#define ISO_VOL_ID                  "CD001"
#define HSG_VOL_ID                  "CDROM"

#define ISO_ATTR_MULTI              0x0080
#define ISO_ATTR_DIRECTORY          0x0002

#define MIN_DIR_REC_SIZE        (sizeof( RAW_DIR_REC ) - MAX_FILE_ID_LENGTH)

#define RVD_STD_ID( r, i )      (i ?    r->StandardId       : \
                                        ((PRAW_HSG_VD) r)->StandardId )

#define RVD_DESC_TYPE( r, i )   (i ?    r->DescType         : \
                                        ((PRAW_HSG_VD) r)->DescType )

#define RVD_VERSION( r, i )     (i ?    r->Version          : \
                                        ((PRAW_HSG_VD) r)->Version )

#define RVD_LB_SIZE( r, i )     (i ?    r->LogicalBlkSzI    : \
                                        ((PRAW_HSG_VD) r)->LogicalBlkSzI )

#define RVD_VOL_SIZE( r, i )    (i ?    r->VolSpaceI      : \
                                        ((PRAW_HSG_VD) r)->VolSpaceI )

#define RVD_ROOT_DE( r, i )     (i ?    r->RootDe           : \
                                        ((PRAW_HSG_VD) r)->RootDe )

#define DE_FILE_FLAGS( iso, de ) (iso ? de->FlagsISO : de->FlagsHSG)

//
//  Data track flag for track entries in TOC
//

#define TOC_DATA_TRACK              (0x04)
#define TOC_LAST_TRACK              (0xaa)


//
//  There is considerable rearrangement of the volume descriptors for
//  ISO and HSG.  However, within each standard the same structure can
//  be used for both the primary and secondary descriptors.
//
//  Both of these structures are aligned correctly so that no
//  special macros will be needed to unpack them.
//

//
//  Declaration of length of root directory entry in volume descriptor
//

#define LEN_ROOT_DE                 (34)

//
//  Maximum length of file ID on the disk.  We allow file size beyond the ISO 9660
//  standard.
//

#define MAX_FILE_ID_LENGTH          (255)


typedef struct _RAW_ISO_VD {

    UCHAR       DescType;           // volume type: 1 = standard, 2 = coded
    UCHAR       StandardId[5];      // volume structure standard id = CD001
    UCHAR       Version;            // volume structure version number = 1
    UCHAR       VolumeFlags;        // volume flags
    UCHAR       SystemId[32];       // system identifier
    UCHAR       VolumeId[32];       // volume identifier
    UCHAR       Reserved[8];        // reserved 8 = 0
    ULONG       VolSpaceI;          // size of the volume in LBN's Intel
    ULONG       VolSpaceM;          // size of the volume in LBN's Motorola
    UCHAR       CharSet[32];        // character set bytes 0 = ASCII
    USHORT      VolSetSizeI;        // volume set size Intel
    USHORT      VolSetSizeM;        // volume set size Motorola
    USHORT      VolSeqNumI;         // volume set sequence number Intel
    USHORT      VolSeqNumM;         // volume set sequence number Motorola
    USHORT      LogicalBlkSzI;      // logical block size Intel
    USHORT      LogicalBlkSzM;      // logical block size Motorola
    ULONG       PathTableSzI;       // path table size in bytes Intel
    ULONG       PathTableSzM;       // path table size in bytes Motorola
    ULONG       PathTabLocI[2];     // LBN of 2 path tables Intel
    ULONG       PathTabLocM[2];     // LBN of 2 path tables Motorola
    UCHAR       RootDe[LEN_ROOT_DE];// dir entry of the root directory
    UCHAR       VolSetId[128];      // volume set identifier
    UCHAR       PublId[128];        // publisher identifier
    UCHAR       PreparerId[128];    // data preparer identifier
    UCHAR       AppId[128];         // application identifier
    UCHAR       Copyright[37];      // file name of copyright notice
    UCHAR       Abstract[37];       // file name of abstract
    UCHAR       Bibliograph[37];    // file name of bibliography
    UCHAR       CreateDate[17];     // volume creation date and time
    UCHAR       ModDate[17];        // volume modification date and time
    UCHAR       ExpireDate[17];     // volume expiration date and time
    UCHAR       EffectDate[17];     // volume effective date and time
    UCHAR       FileStructVer;      // file structure version number = 1
    UCHAR       Reserved3;          // reserved
    UCHAR       ResApp[512];        // reserved for application
    UCHAR       Reserved4[653];     // remainder of 2048 bytes reserved

} RAW_ISO_VD;
typedef RAW_ISO_VD *PRAW_ISO_VD;


typedef struct _RAW_HSG_VD {

    ULONG       BlkNumI;            // logical block number Intel
    ULONG       BlkNumM;            // logical block number Motorola
    UCHAR       DescType;           // volume type: 1 = standard, 2 = coded
    UCHAR       StandardId[5];      // volume structure standard id = CDROM
    UCHAR       Version;            // volume structure version number = 1
    UCHAR       VolumeFlags;        // volume flags
    UCHAR       SystemId[32];       // system identifier
    UCHAR       VolumeId[32];       // volume identifier
    UCHAR       Reserved[8];        // reserved 8 = 0
    ULONG       VolSpaceI;          // size of the volume in LBN's Intel
    ULONG       VolSpaceM;          // size of the volume in LBN's Motorola
    UCHAR       CharSet[32];        // character set bytes 0 = ASCII
    USHORT      VolSetSizeI;        // volume set size Intel
    USHORT      VolSetSizeM;        // volume set size Motorola
    USHORT      VolSeqNumI;         // volume set sequence number Intel
    USHORT      VolSeqNumM;         // volume set sequence number Motorola
    USHORT      LogicalBlkSzI;      // logical block size Intel
    USHORT      LogicalBlkSzM;      // logical block size Motorola
    ULONG       PathTableSzI;       // path table size in bytes Intel
    ULONG       PathTableSzM;       // path table size in bytes Motorola
    ULONG       PathTabLocI[4];     // LBN of 4 path tables Intel
    ULONG       PathTabLocM[4];     // LBN of 4 path tables Motorola
    UCHAR       RootDe[LEN_ROOT_DE];// dir entry of the root directory
    UCHAR       VolSetId[128];      // volume set identifier
    UCHAR       PublId[128];        // publisher identifier
    UCHAR       PreparerId[128];    // data preparer identifier
    UCHAR       AppId[128];         // application identifier
    UCHAR       Copyright[32];      // file name of copyright notice
    UCHAR       Abstract[32];       // file name of abstract
    UCHAR       CreateDate[16];     // volume creation date and time
    UCHAR       ModDate[16];        // volume modification date and time
    UCHAR       ExpireDate[16];     // volume expiration date and time
    UCHAR       EffectDate[16];     // volume effective date and time
    UCHAR       FileStructVer;      // file structure version number
    UCHAR       Reserved3;          // reserved
    UCHAR       ResApp[512];        // reserved for application
    UCHAR       Reserved4[680];     // remainder of 2048 bytes reserved

} RAW_HSG_VD;
typedef RAW_HSG_VD *PRAW_HSG_VD;


typedef struct _RAW_JOLIET_VD {

    UCHAR       DescType;           // volume type: 2 = coded
    UCHAR       StandardId[5];      // volume structure standard id = CD001
    UCHAR       Version;            // volume structure version number = 1
    UCHAR       VolumeFlags;        // volume flags
    UCHAR       SystemId[32];       // system identifier
    UCHAR       VolumeId[32];       // volume identifier
    UCHAR       Reserved[8];        // reserved 8 = 0
    ULONG       VolSpaceI;          // size of the volume in LBN's Intel
    ULONG       VolSpaceM;          // size of the volume in LBN's Motorola
    UCHAR       CharSet[32];        // character set bytes 0 = ASCII, Joliett Seq here
    USHORT      VolSetSizeI;        // volume set size Intel
    USHORT      VolSetSizeM;        // volume set size Motorola
    USHORT      VolSeqNumI;         // volume set sequence number Intel
    USHORT      VolSeqNumM;         // volume set sequence number Motorola
    USHORT      LogicalBlkSzI;      // logical block size Intel
    USHORT      LogicalBlkSzM;      // logical block size Motorola
    ULONG       PathTableSzI;       // path table size in bytes Intel
    ULONG       PathTableSzM;       // path table size in bytes Motorola
    ULONG       PathTabLocI[2];     // LBN of 2 path tables Intel
    ULONG       PathTabLocM[2];     // LBN of 2 path tables Motorola
    UCHAR       RootDe[LEN_ROOT_DE];// dir entry of the root directory
    UCHAR       VolSetId[128];      // volume set identifier
    UCHAR       PublId[128];        // publisher identifier
    UCHAR       PreparerId[128];    // data preparer identifier
    UCHAR       AppId[128];         // application identifier
    UCHAR       Copyright[37];      // file name of copyright notice
    UCHAR       Abstract[37];       // file name of abstract
    UCHAR       Bibliograph[37];    // file name of bibliography
    UCHAR       CreateDate[17];     // volume creation date and time
    UCHAR       ModDate[17];        // volume modification date and time
    UCHAR       ExpireDate[17];     // volume expiration date and time
    UCHAR       EffectDate[17];     // volume effective date and time
    UCHAR       FileStructVer;      // file structure version number = 1
    UCHAR       Reserved3;          // reserved
    UCHAR       ResApp[512];        // reserved for application
    UCHAR       Reserved4[653];     // remainder of 2048 bytes reserved

} RAW_JOLIET_VD;
typedef RAW_JOLIET_VD *PRAW_JOLIET_VD;

//
//  Macros to access the different volume descriptors.
//

#define CdRvdId(R,F) (                  \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->StandardId :   \
    ((PRAW_ISO_VD) (R))->StandardId     \
)

#define CdRvdVersion(R,F) (             \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->Version :      \
    ((PRAW_ISO_VD) (R))->Version        \
)

#define CdRvdDescType(R,F) (            \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->DescType :     \
    ((PRAW_ISO_VD) (R))->DescType       \
)

#define CdRvdEsc(R,F) (                 \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->CharSet :      \
    ((PRAW_ISO_VD) (R))->CharSet        \
)

#define CdRvdVolId(R,F) (               \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->VolumeId :     \
    ((PRAW_ISO_VD) (R))->VolumeId       \
)

#define CdRvdBlkSz(R,F) (               \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->LogicalBlkSzI :\
    ((PRAW_ISO_VD) (R))->LogicalBlkSzI  \
)

#define CdRvdPtLoc(R,F) (               \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->PathTabLocI[0]:\
    ((PRAW_ISO_VD) (R))->PathTabLocI[0] \
)

#define CdRvdPtSz(R,F) (                \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->PathTableSzI : \
    ((PRAW_ISO_VD) (R))->PathTableSzI   \
)

#define CdRvdDirent(R,F) (              \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->RootDe :       \
    ((PRAW_ISO_VD) (R))->RootDe         \
)

#define CdRvdVolSz(R,F) (               \
    FlagOn( (F), VCB_STATE_HSG ) ?      \
    ((PRAW_HSG_VD) (R))->VolSpaceI :    \
    ((PRAW_ISO_VD) (R))->VolSpaceI      \
)


//
//  This structure is used to overlay a region of a disk sector
//  to retrieve a single directory entry.  There is a difference
//  in the file flags between the ISO and HSG version and a
//  additional byte in the ISO for the offset from Greenwich time.
//
//  The disk structure is aligned on a word boundary, so any 32
//  bit fields will be represented as an array of 16 bit fields.
//

typedef struct _RAW_DIRENT {

    UCHAR       DirLen;
    UCHAR       XarLen;
    UCHAR       FileLoc[4];
    UCHAR       FileLocMot[4];
    UCHAR       DataLen[4];
    UCHAR       DataLenMot[4];
    UCHAR       RecordTime[6];
    UCHAR       FlagsHSG;
    UCHAR       FlagsISO;
    UCHAR       IntLeaveSize;
    UCHAR       IntLeaveSkip;
    UCHAR       Vssn[2];
    UCHAR       VssnMot[2];
    UCHAR       FileIdLen;
    UCHAR       FileId[MAX_FILE_ID_LENGTH];

} RAW_DIRENT;
typedef RAW_DIRENT RAW_DIR_REC;
typedef RAW_DIRENT *PRAW_DIR_REC;
typedef RAW_DIRENT *PRAW_DIRENT;

#define CD_ATTRIBUTE_HIDDEN                         (0x01)
#define CD_ATTRIBUTE_DIRECTORY                      (0x02)
#define CD_ATTRIBUTE_ASSOC                          (0x04)
#define CD_ATTRIBUTE_MULTI                          (0x80)

#define CD_BASE_YEAR                                (1900)

#define MIN_RAW_DIRENT_LEN  (FIELD_OFFSET( RAW_DIRENT, FileId ) + 1)

#define BYTE_COUNT_8_DOT_3                          (24)

#define SHORT_NAME_SHIFT                            (5)

//
//  The following macro recovers the correct flag field.
//

#define CdRawDirentFlags(IC,RD) (                   \
    FlagOn( (IC)->Vcb->VcbState, VCB_STATE_HSG) ?   \
    (RD)->FlagsHSG :                                \
    (RD)->FlagsISO                                  \
)

//
//  The following macro converts from CD time to NT time.  On ISO
//  9660 media, we now pay attention to the GMT offset (integer
//  increments of 15 minutes offset from GMT).  HSG does not record
//  this field.
//
//  The restriction to the interval [-48, 52] comes from 9660 8.4.26.1
//
//  VOID
//  CdConvertCdTimeToNtTime (
//      IN PIRP_CONTEXT IrpContext,
//      IN PCHAR CdTime,
//      OUT PLARGE_INTEGER NtTime
//      );
//

#define GMT_OFFSET_TO_NT ((LONGLONG) 15 * 60 * 1000 * 1000 * 10)

#define CdConvertCdTimeToNtTime(IC,CD,NT) {                     \
    TIME_FIELDS _TimeField;                                     \
    CHAR GmtOffset;                                             \
    _TimeField.Year = (CSHORT) *((PCHAR) CD) + CD_BASE_YEAR;    \
    _TimeField.Month = (CSHORT) *(Add2Ptr( CD, 1, PCHAR ));     \
    _TimeField .Day = (CSHORT) *(Add2Ptr( CD, 2, PCHAR ));      \
    _TimeField.Hour = (CSHORT) *(Add2Ptr( CD, 3, PCHAR ));      \
    _TimeField.Minute = (CSHORT) *(Add2Ptr( CD, 4, PCHAR ));    \
    _TimeField.Second = (CSHORT) *(Add2Ptr( CD, 5, PCHAR ));    \
    _TimeField.Milliseconds = (CSHORT) 0;                       \
    RtlTimeFieldsToTime( &_TimeField, NT );                     \
    if (!FlagOn((IC)->Vcb->VcbState, VCB_STATE_HSG) &&          \
        ((GmtOffset = *(Add2Ptr( CD, 6, PCHAR ))) != 0 ) &&     \
        (GmtOffset >= -48 && GmtOffset <= 52)) {                \
            (NT)->QuadPart += -GmtOffset * GMT_OFFSET_TO_NT;     \
        }                                                       \
}


//
//  The on-disk representation of a Path Table entry differs between
//  the ISO version and the HSG version.  The fields are the same
//  and the same size, but the positions are different.
//

typedef struct _RAW_PATH_ISO {

    UCHAR           DirIdLen;
    UCHAR           XarLen;
    USHORT          DirLoc[2];
    USHORT          ParentNum;
    UCHAR           DirId[MAX_FILE_ID_LENGTH];

} RAW_PATH_ISO;
typedef RAW_PATH_ISO *PRAW_PATH_ISO;
typedef RAW_PATH_ISO RAW_PATH_ENTRY;
typedef RAW_PATH_ISO *PRAW_PATH_ENTRY;

typedef struct _RAW_PATH_HSG {

    USHORT          DirLoc[2];
    UCHAR           XarLen;
    UCHAR           DirIdLen;
    USHORT          ParentNum;
    UCHAR           DirId[MAX_FILE_ID_LENGTH];

} RAW_PATH_HSG;
typedef RAW_PATH_HSG *PRAW_PATH_HSG;

#define MIN_RAW_PATH_ENTRY_LEN      (FIELD_OFFSET( RAW_PATH_ENTRY, DirId ) + 1)

//
//  The following macros are used to recover the different fields of the
//  Path Table entries.  The macro to recover the disk location of the
//  directory must copy it into a different variable for alignment reasons.
//
//      CdRawPathIdLen - Length of directory name in bytes
//      CdRawPathXar - Number of Xar blocks
//      CdRawPathLoc - Address of unaligned ulong for disk offset in blocks
//

#define CdRawPathIdLen(IC, RP) (                    \
    FlagOn( (IC)->Vcb->VcbState, VCB_STATE_HSG ) ?  \
    ((PRAW_PATH_HSG) (RP))->DirIdLen :              \
    (RP)->DirIdLen                                  \
)

#define CdRawPathXar(IC, RP) (                      \
    FlagOn( (IC)->Vcb->VcbState, VCB_STATE_HSG ) ?  \
    ((PRAW_PATH_HSG) (RP))->XarLen :                \
    (RP)->XarLen                                    \
)

#define CdRawPathLoc(IC, RP) (                      \
    FlagOn( (IC)->Vcb->VcbState, VCB_STATE_HSG ) ?  \
    ((PRAW_PATH_HSG) (RP))->DirLoc :                \
    (RP)->DirLoc                                    \
)


//
//  System use are for XA data.  The following is the system use area for
//  directory entries on XA data disks.
//

typedef struct _SYSTEM_USE_XA {

    //
    //  Owner ID.  Not used in this version.
    //

    UCHAR OwnerId[4];

    //
    //  Extent attributes.  Only interested if mode2 form2 or digital audio.
    //  This is stored big endian.  We will define the attribute flags so
    //  we can ignore this fact.
    //

    USHORT Attributes;

    //
    //  XA signature.  This value must be 'XA'.
    //

    USHORT Signature;

    //
    //  File Number.
    //

    UCHAR FileNumber;

    //
    //  Not used in this version.
    //

    UCHAR Reserved[5];

} SYSTEM_USE_XA;
typedef SYSTEM_USE_XA *PSYSTEM_USE_XA;

#define SYSTEM_USE_XA_FORM1             (0x0008)
#define SYSTEM_USE_XA_FORM2             (0x0010)
#define SYSTEM_USE_XA_DA                (0x0040)

#define SYSTEM_XA_SIGNATURE             (0x4158)

typedef enum _XA_EXTENT_TYPE {

    Form1Data = 0,
    Mode2Form2Data,
    CDAudio

} XA_EXTENT_TYPE;
typedef XA_EXTENT_TYPE *PXA_EXTENT_TYPE;

#endif // _CDFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\allocsup.c ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    AllocSup.c

Abstract:

    This module implements the Allocation support routines for Cdfs.

    The data structure used here is the CD_MCB.  There is an entry in
    the Mcb for each dirent for a file.  The entry will map the offset
    within some file to a starting disk offset and number of bytes.
    The Mcb also contains the interleave information for an extent.
    An interleave consists of a number of blocks with data and a
    (possibly different) number of blocks to skip.  Any number of
    data/skip pairs may exist in an extent but the data and skip sizes
    are the same throughout the extent.

    We store the following information into an Mcb entry for an extent.

        FileOffset          Offset in file for start of extent
        DiskOffset          Offset on disk for start of extent
        ByteCount           Number of file bytes in extent, no skip bytes
        DataBlockByteCount  Number of bytes in each data block
        TotalBlockByteCount Number of bytes is data block and skip block

    The disk offset in the Mcb has already been biased by the size of
    the Xar block if present.  All of the byte count fields are aligned
    on logical block boundaries.  If this is a directory or path table
    then the file offset has been biased to round the initial disk
    offset down to a sector boundary.  The biasing is done when loading
    the values into an Mcb entry.

    An XA file has a header prepended to the file and each sector is 2352
    bytes.  The allocation information ignores the header and only deals
    with 2048 byte sectors.  Callers into the allocation package have
    adjusted the starting offset value to reflect 2048 sectors.  On return
    from this package the caller will have to convert from 2048 sector values
    into raw XA sector values.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_ALLOCSUP)

//
//  Local support routines
//

ULONG
CdFindMcbEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG FileOffset
    );

VOID
CdDiskOffsetFromMcbEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PCD_MCB_ENTRY McbEntry,
    IN LONGLONG FileOffset,
    IN PLONGLONG DiskOffset,
    IN PULONG ByteCount
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdAddInitialAllocation)
#pragma alloc_text(PAGE, CdAddAllocationFromDirent)
#pragma alloc_text(PAGE, CdDiskOffsetFromMcbEntry)
#pragma alloc_text(PAGE, CdFindMcbEntry)
#pragma alloc_text(PAGE, CdInitializeMcb)
#pragma alloc_text(PAGE, CdLookupAllocation)
#pragma alloc_text(PAGE, CdTruncateAllocation)
#pragma alloc_text(PAGE, CdUninitializeMcb)
#endif


VOID
CdLookupAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG FileOffset,
    OUT PLONGLONG DiskOffset,
    OUT PULONG ByteCount
    )

/*++

Routine Description:

    This routine looks through the mapping information for the file
    to find the logical diskoffset and number of bytes at that offset.
    We only deal with logical 2048 byte sectors here.

    If the mapping isn't present we will look it up on disk now.
    This routine assumes we are looking up a valid range in the file.  This
    routine raises if it can't find mapping for the file offset.

    The Fcb may not be locked prior to calling this routine.  We will always
    acquire it here.

Arguments:

    Fcb - Fcb representing this stream.

    FileOffset - Lookup the allocation beginning at this point.

    DiskOffset - Address to store the logical disk offset.

    ByteCount - Address to store the number of contiguous bytes beginning
        at DiskOffset above.

Return Value:

    None.

--*/

{
    BOOLEAN FirstPass = TRUE;
    ULONG McbEntryOffset;
    PFCB ParentFcb;
    BOOLEAN CleanupParent = FALSE;

    BOOLEAN UnlockFcb = FALSE;

    LONGLONG CurrentFileOffset;
    ULONG CurrentMcbOffset;
    PCD_MCB_ENTRY CurrentMcbEntry;

    DIRENT_ENUM_CONTEXT DirContext;
    DIRENT Dirent;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Use a try finally to facilitate cleanup.
    //

    try {

        //
        //  We use a loop to perform the lookup.  If we don't find the mapping in the
        //  first pass then we look up all of the allocation and then look again.

        while (TRUE) {

            //
            //
            //  Lookup the entry containing this file offset.
            //

            CdLockFcb( IrpContext, Fcb );
            UnlockFcb = TRUE;

            McbEntryOffset = CdFindMcbEntry( IrpContext, Fcb, FileOffset );

            //
            //  If within the Mcb then we use the data out of this entry and are
            //  done.
            //

            if (McbEntryOffset < Fcb->Mcb.CurrentEntryCount) {

                CdDiskOffsetFromMcbEntry( IrpContext,
                                          Fcb->Mcb.McbArray + McbEntryOffset,
                                          FileOffset,
                                          DiskOffset,
                                          ByteCount );

                break;

            //
            //  If this is not the first pass then the disk is corrupt.
            //

            } else if (!FirstPass) {

                CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
            }

            CdUnlockFcb( IrpContext, Fcb );
            UnlockFcb = FALSE;

            //
            //  Initialize the search dirent structures.
            //

            CdInitializeDirContext( IrpContext, &DirContext );
            CdInitializeDirent( IrpContext, &Dirent );

            //
            //  Otherwise we need to walk the dirents for this file until we find
            //  the one containing this entry.  The parent Fcb should always be
            //  present.
            //

            ParentFcb = Fcb->ParentFcb;
            CdAcquireFileShared( IrpContext, ParentFcb );
            CleanupParent = TRUE;

            //
            //  Do an unsafe test to see if we need to create a file object.
            //

            if (ParentFcb->FileObject == NULL) {

                CdCreateInternalStream( IrpContext, ParentFcb->Vcb, ParentFcb );
            }

            //
            //  Initialize the local variables to indicate the first dirent
            //  and lookup the first dirent.
            //

            CurrentFileOffset = 0;
            CurrentMcbOffset = 0;

            CdLookupDirent( IrpContext,
                            ParentFcb,
                            CdQueryFidDirentOffset( Fcb->FileId ),
                            &DirContext );

            //
            //  If we are adding allocation to the Mcb then add all of it.
            //

            while (TRUE ) {

                //
                //  Update the dirent from the on-disk dirent.
                //

                CdUpdateDirentFromRawDirent( IrpContext, ParentFcb, &DirContext, &Dirent );

                //
                //  Add this dirent to the Mcb if not already present.
                //

                CdLockFcb( IrpContext, Fcb );
                UnlockFcb = TRUE;

                if (CurrentMcbOffset >= Fcb->Mcb.CurrentEntryCount) {

                    CdAddAllocationFromDirent( IrpContext, Fcb, CurrentMcbOffset, CurrentFileOffset, &Dirent );
                }

                CdUnlockFcb( IrpContext, Fcb );
                UnlockFcb = FALSE;

                //
                //  If this is the last dirent for the file then exit.
                //

                if (!FlagOn( Dirent.DirentFlags, CD_ATTRIBUTE_MULTI )) {

                    break;
                }

                //
                //  If we couldn't find another entry then the directory is corrupt because
                //  the last dirent for a file doesn't exist.
                //

                if (!CdLookupNextDirent( IrpContext, ParentFcb, &DirContext, &DirContext )) {

                    CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
                }

                //
                //  Update our loop variables.
                //

                CurrentMcbEntry = Fcb->Mcb.McbArray + CurrentMcbOffset;
                CurrentFileOffset += CurrentMcbEntry->ByteCount;
                CurrentMcbOffset += 1;
            }

            //
            //  All of the allocation is loaded.  Go back and look up the mapping again.
            //  It better be there this time.
            //

            FirstPass = FALSE;
        }

    } finally {

        if (CleanupParent) {

            //
            //  Release the parent and cleanup the dirent structures.
            //

            CdReleaseFile( IrpContext, ParentFcb );

            CdCleanupDirContext( IrpContext, &DirContext );
            CdCleanupDirent( IrpContext, &Dirent );
        }

        if (UnlockFcb) { CdUnlockFcb( IrpContext, Fcb ); }
    }

    return;
}


VOID
CdAddAllocationFromDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG McbEntryOffset,
    IN LONGLONG StartingFileOffset,
    IN PDIRENT Dirent
    )

/*++

Routine Description:

    This routine is called to add an entry into the Cd Mcb.  We grow the Mcb
    as necessary and update the new entry.

    NOTE - The Fcb has already been locked prior to makeing this call.

Arguments:

    Fcb - Fcb containing the Mcb to update.

    McbEntryOffset - Offset into the Mcb array to add this data.

    StartingFileOffset - Offset in bytes from the start of the file.

    Dirent - Dirent containing the on-disk data for this entry.

Return Value:

    None

--*/

{
    ULONG NewArraySize;
    PVOID NewMcbArray;
    PCD_MCB_ENTRY McbEntry;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT_LOCKED_FCB( Fcb );

    //
    //  If we need to grow the Mcb then do it now.
    //

    if (McbEntryOffset >= Fcb->Mcb.MaximumEntryCount) {

        //
        //  Allocate a new buffer and copy the old data over.
        //

        NewArraySize = Fcb->Mcb.MaximumEntryCount * 2 * sizeof( CD_MCB_ENTRY );

        NewMcbArray = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                NewArraySize,
                                                TAG_MCB_ARRAY );

        RtlZeroMemory( NewMcbArray, NewArraySize );
        RtlCopyMemory( NewMcbArray,
                       Fcb->Mcb.McbArray,
                       Fcb->Mcb.MaximumEntryCount * sizeof( CD_MCB_ENTRY ));

        //
        //  Deallocate the current array unless it is embedded in the Fcb.
        //

        if (Fcb->Mcb.MaximumEntryCount != 1) {

            CdFreePool( &Fcb->Mcb.McbArray );
        }

        //
        //  Now update the Mcb with the new array.
        //

        Fcb->Mcb.MaximumEntryCount *= 2;
        Fcb->Mcb.McbArray = NewMcbArray;
    }

    //
    //  Update the new entry with the input data.
    //

    McbEntry = Fcb->Mcb.McbArray + McbEntryOffset;

    //
    //  Start with the location and length on disk.
    //

    McbEntry->DiskOffset = LlBytesFromBlocks( Fcb->Vcb, Dirent->StartingOffset );
    McbEntry->ByteCount = Dirent->DataLength;

    //
    //  Round the byte count up to a logical block boundary if this is
    //  the last extent.
    //

    if (!FlagOn( Dirent->DirentFlags, CD_ATTRIBUTE_MULTI )) {

        McbEntry->ByteCount = BlockAlign( Fcb->Vcb, McbEntry->ByteCount );
    }

    //
    //  The file offset is the logical position within this file.
    //  We know this is correct regardless of whether we bias the
    //  file size or disk offset.
    //

    McbEntry->FileOffset = StartingFileOffset;

    //
    //  Convert the interleave information from logical blocks to
    //  bytes.
    //

    if (Dirent->FileUnitSize != 0) {

        McbEntry->DataBlockByteCount = LlBytesFromBlocks( Fcb->Vcb, Dirent->FileUnitSize );
        McbEntry->TotalBlockByteCount = McbEntry->DataBlockByteCount +
                                        LlBytesFromBlocks( Fcb->Vcb, Dirent->InterleaveGapSize );

    //
    //  If the file is not interleaved then the size of the data block
    //  and total block are the same as the byte count.
    //

    } else {

        McbEntry->DataBlockByteCount =
        McbEntry->TotalBlockByteCount = McbEntry->ByteCount;
    }

    //
    //  Update the number of entries in the Mcb.  The Mcb is never sparse
    //  so whenever we add an entry it becomes the last entry in the Mcb.
    //

    Fcb->Mcb.CurrentEntryCount = McbEntryOffset + 1;

    return;
}


VOID
CdAddInitialAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG StartingBlock,
    IN LONGLONG DataLength
    )

/*++

Routine Description:

    This routine is called to set up the initial entry in an Mcb.

    This routine handles the single initial entry for a directory file.  We will 
    round the start block down to a sector boundary.  Our caller has already 
    biased the DataLength with any adjustments.  This is used for the case 
    where there is a single entry and we want to align the data on a sector 
    boundary.

Arguments:

    Fcb - Fcb containing the Mcb to update.

    StartingBlock - Starting logical block for this directory.  This is
        the start of the actual data.  We will bias this by the sector
        offset of the data.

    DataLength - Length of the data.

Return Value:

    None

--*/

{
    PCD_MCB_ENTRY McbEntry;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT_LOCKED_FCB( Fcb );
    ASSERT( 0 == Fcb->Mcb.CurrentEntryCount);
    ASSERT( CDFS_NTC_FCB_DATA != Fcb->NodeTypeCode);

    //
    //  Update the new entry with the input data.
    //

    McbEntry = Fcb->Mcb.McbArray;

    //
    //  Start with the location and length on disk.
    //

    McbEntry->DiskOffset = LlBytesFromBlocks( Fcb->Vcb, StartingBlock );
    McbEntry->DiskOffset -= Fcb->StreamOffset;

    McbEntry->ByteCount = DataLength;

    //
    //  The file offset is the logical position within this file.
    //  We know this is correct regardless of whether we bias the
    //  file size or disk offset.
    //

    McbEntry->FileOffset = 0;

    //
    //  If the file is not interleaved then the size of the data block
    //  and total block are the same as the byte count.
    //

    McbEntry->DataBlockByteCount =
    McbEntry->TotalBlockByteCount = McbEntry->ByteCount;

    //
    //  Update the number of entries in the Mcb.  The Mcb is never sparse
    //  so whenever we add an entry it becomes the last entry in the Mcb.
    //

    Fcb->Mcb.CurrentEntryCount = 1;

    return;
}


VOID
CdTruncateAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingFileOffset
    )

/*++

Routine Description:

    This routine truncates the Mcb for a file by eliminating all of the Mcb
    entries from the entry which contains the given offset.

    The Fcb should be locked when this routine is called.

Arguments:

    Fcb - Fcb containing the Mcb to truncate.

    StartingFileOffset - Offset in the file to truncate the Mcb from.

Return Value:

    None

--*/

{
    ULONG McbEntryOffset;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT_LOCKED_FCB( Fcb );

    //
    //  Find the entry containg this starting offset.
    //

    McbEntryOffset = CdFindMcbEntry( IrpContext, Fcb, StartingFileOffset );

    //
    //  Now set the current size of the mcb to this point.
    //

    Fcb->Mcb.CurrentEntryCount = McbEntryOffset;

    return;
}


VOID
CdInitializeMcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to initialize the Mcb in an Fcb.  We initialize
    this with an entry count of one and point to the entry in the Fcb
    itself.

    Fcb should be acquired exclusively when this is called.

Arguments:

    Fcb - Fcb containing the Mcb to initialize.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Set the entry counts to show there is one entry in the array and
    //  it is unused.
    //

    Fcb->Mcb.MaximumEntryCount = 1;
    Fcb->Mcb.CurrentEntryCount = 0;

    Fcb->Mcb.McbArray = &Fcb->McbEntry;

    return;
}


VOID
CdUninitializeMcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to cleanup an Mcb in an Fcb.  We look at the
    maximum run count in the Fcb and if greater than one we will deallocate
    the buffer.

    Fcb should be acquired exclusively when this is called.

Arguments:

    Fcb - Fcb containing the Mcb to uninitialize.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  If the count is greater than one then this is an allocated buffer.
    //

    if (Fcb->Mcb.MaximumEntryCount > 1) {

        CdFreePool( &Fcb->Mcb.McbArray );
    }

    return;
}


//
//  Local suupport routine
//

ULONG
CdFindMcbEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG FileOffset
    )

/*++

Routine Description:

    This routine is called to find the Mcb entry which contains the file
    offset at the given point.  If the file offset is not currently in the
    Mcb then we return the offset of the entry to add.

    Fcb should be locked when this is called.

Arguments:

    Fcb - Fcb containing the Mcb to uninitialize.

    FileOffset - Return the Mcb entry which contains this file offset.

Return Value:

    ULONG - Offset in the Mcb of the entry for this offset.

--*/

{
    ULONG CurrentMcbOffset;
    PCD_MCB_ENTRY CurrentMcbEntry;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );
    ASSERT_LOCKED_FCB( Fcb );

    //
    //  We expect a linear search will be sufficient here.
    //

    CurrentMcbOffset = 0;
    CurrentMcbEntry = Fcb->Mcb.McbArray;

    while (CurrentMcbOffset < Fcb->Mcb.CurrentEntryCount) {

        //
        //  Check if the offset lies within the current Mcb position.
        //

        if (FileOffset < CurrentMcbEntry->FileOffset + CurrentMcbEntry->ByteCount) {

            break;
        }

        //
        //  Move to the next entry.
        //

        CurrentMcbOffset += 1;
        CurrentMcbEntry += 1;
    }

    //
    //  This is the offset containing this file offset (or the point
    //  where an entry should be added).
    //

    return CurrentMcbOffset;
}


//
//  Local support routine
//

VOID
CdDiskOffsetFromMcbEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PCD_MCB_ENTRY McbEntry,
    IN LONGLONG FileOffset,
    IN PLONGLONG DiskOffset,
    IN PULONG ByteCount
    )

/*++

Routine Description:

    This routine is called to return the diskoffset and length of the file
    data which begins at offset 'FileOffset'.  We have the Mcb entry which
    contains the mapping and interleave information.

    NOTE - This routine deals with data in 2048 byte logical sectors.  If
        this is an XA file then our caller has already converted from
        'raw' file bytes to 'cooked' file bytes.

Arguments:

    McbEntry - Entry in the Mcb containing the allocation information.

    FileOffset - Starting Offset in the file to find the matching disk
        offsets.

    DiskOffset - Address to store the starting disk offset for this operation.

    ByteCount - Address to store number of contiguous bytes starting at this
        disk offset.

Return Value:

    None

--*/

{
    LONGLONG ExtentOffset;

    LONGLONG CurrentDiskOffset;
    LONGLONG CurrentExtentOffset;

    LONGLONG LocalByteCount;

    PAGED_CODE();
    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Extent offset is the difference between the file offset and the start
    //  of the extent.
    //

    ExtentOffset = FileOffset - McbEntry->FileOffset;

    //
    //  Optimize the non-interleave case.
    //

    if (McbEntry->ByteCount == McbEntry->DataBlockByteCount) {

        *DiskOffset = McbEntry->DiskOffset + ExtentOffset;

        LocalByteCount = McbEntry->ByteCount - ExtentOffset;

    } else {

        //
        //  Walk though any interleave until we reach the current offset in
        //  this extent.
        //

        CurrentExtentOffset = McbEntry->DataBlockByteCount;
        CurrentDiskOffset = McbEntry->DiskOffset;

        while (CurrentExtentOffset <= ExtentOffset) {

            CurrentDiskOffset += McbEntry->TotalBlockByteCount;
            CurrentExtentOffset += McbEntry->DataBlockByteCount;
        }

        //
        //  We are now positioned at the data block containing the starting
        //  file offset we were given.  The disk offset is the offset of
        //  the start of this block plus the extent offset into this block.
        //  The byte count is the data block byte count minus our offset into
        //  this block.
        //

        *DiskOffset = CurrentDiskOffset + (ExtentOffset + McbEntry->DataBlockByteCount - CurrentExtentOffset);

        //
        //  Make sure we aren't past the end of the data length.  This is possible
        //  if we only use part of the last data block on an interleaved file.
        //

        if (CurrentExtentOffset > McbEntry->ByteCount) {

            CurrentExtentOffset = McbEntry->ByteCount;
        }

        LocalByteCount = CurrentExtentOffset - ExtentOffset;
    }

    //
    //  If the byte count exceeds our limit then cut it to fit in 32 bits.
    //

    if (LocalByteCount > MAXULONG) {

        *ByteCount = MAXULONG;

    } else {

        *ByteCount = (ULONG) LocalByteCount;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\cddata.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    CdData.c

Abstract:

    This module declares the global data used by the Cdfs file system.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _CDDATA_
#define _CDDATA_

//
//  Global data structures
//

extern CD_DATA CdData;
extern FAST_IO_DISPATCH CdFastIoDispatch;

//
//  Global constants
//

//
//  This is the number of times a mounted Vcb will be referenced on behalf
//  of the system.  The counts include the following references.
//
//      1 reference - shows the volume is mounted
//      1 reference - 1 for VolumeDasdFcb.
//      2 references - 1 for RootIndexFcb, 1 for internal stream.
//      2 references - 1 for PathTableFcb, 1 for internal stream.
//
//  For user references we add one for the reference in each of the internal
//  Fcb's.
//

#define CDFS_RESIDUAL_REFERENCE                     (6)
#define CDFS_RESIDUAL_USER_REFERENCE                (3)

//
//  Reserved directory strings
//

extern WCHAR CdUnicodeSelfArray[];
extern WCHAR CdUnicodeParentArray[];

extern UNICODE_STRING CdUnicodeDirectoryNames[];

//
//  Volume descriptor identifier strings.
//

extern CHAR CdHsgId[];
extern CHAR CdIsoId[];
extern CHAR CdXaId[];

//
//  Volume label for audio disks.
//

extern WCHAR CdAudioLabel[];
extern USHORT CdAudioLabelLength;

//
//  Pseudo file names for audio disks.
//

extern CHAR CdAudioFileName[];
extern UCHAR CdAudioFileNameLength;
extern ULONG CdAudioDirentSize;
extern ULONG CdAudioDirentsPerSector;
extern ULONG CdAudioSystemUseOffset;

#define AUDIO_NAME_ONES_OFFSET              (6)
#define AUDIO_NAME_TENS_OFFSET              (5)

//
//  Escape sequences for mounting Unicode volumes.
//

extern PCHAR CdJolietEscape[];

//
//  Hardcoded header for RIFF files.
//

extern LONG CdXAFileHeader[];
extern LONG CdAudioPlayHeader[];
extern LONG CdXAAudioPhileHeader[];


//
//  Turn on pseudo-asserts if CD_FREE_ASSERTS is defined.
//

#if !DBG
#ifdef CD_FREE_ASSERTS
#undef ASSERT
#undef ASSERTMSG
#define ASSERT(exp)        if (!(exp)) { extern BOOLEAN KdDebuggerEnabled; DbgPrint("%s:%d %s\n",__FILE__,__LINE__,#exp); if (KdDebuggerEnabled) { DbgBreakPoint(); } }
#define ASSERTMSG(msg,exp) if (!(exp)) { extern BOOLEAN KdDebuggerEnabled; DbgPrint("%s:%d %s %s\n",__FILE__,__LINE__,msg,#exp); if (KdDebuggerEnabled) { DbgBreakPoint(); } }
#endif
#endif


//
//  The following assertion macros ensure that the indicated structure
//  is valid
//
//      ASSERT_STRUCT( IN PVOID Struct, IN CSHORT NodeType );
//      ASSERT_OPTIONAL_STRUCT( IN PVOID Struct OPTIONAL, IN CSHORT NodeType );
//
//      ASSERT_VCB( IN PVCB Vcb );
//      ASSERT_OPTIONAL_VCB( IN PVCB Vcb OPTIONAL );
//
//      ASSERT_FCB( IN PFCB Fcb );
//      ASSERT_OPTIONAL_FCB( IN PFCB Fcb OPTIONAL );
//
//      ASSERT_FCB_NONPAGED( IN PFCB_NONPAGED FcbNonpaged );
//      ASSERT_OPTIONAL_FCB( IN PFCB_NONPAGED FcbNonpaged OPTIONAL );
//
//      ASSERT_CCB( IN PSCB Ccb );
//      ASSERT_OPTIONAL_CCB( IN PSCB Ccb OPTIONAL );
//
//      ASSERT_IRP_CONTEXT( IN PIRP_CONTEXT IrpContext );
//      ASSERT_OPTIONAL_IRP_CONTEXT( IN PIRP_CONTEXT IrpContext OPTIONAL );
//
//      ASSERT_IRP( IN PIRP Irp );
//      ASSERT_OPTIONAL_IRP( IN PIRP Irp OPTIONAL );
//
//      ASSERT_FILE_OBJECT( IN PFILE_OBJECT FileObject );
//      ASSERT_OPTIONAL_FILE_OBJECT( IN PFILE_OBJECT FileObject OPTIONAL );
//
//  The following macros are used to check the current thread owns
//  the indicated resource
//
//      ASSERT_EXCLUSIVE_RESOURCE( IN PERESOURCE Resource );
//
//      ASSERT_SHARED_RESOURCE( IN PERESOURCE Resource );
//
//      ASSERT_RESOURCE_NOT_MINE( IN PERESOURCE Resource );
//
//  The following macros are used to check whether the current thread
//  owns the resoures in the given structures.
//
//      ASSERT_EXCLUSIVE_CDDATA
//
//      ASSERT_EXCLUSIVE_VCB( IN PVCB Vcb );
//
//      ASSERT_SHARED_VCB( IN PVCB Vcb );
//
//      ASSERT_EXCLUSIVE_FCB( IN PFCB Fcb );
//
//      ASSERT_SHARED_FCB( IN PFCB Fcb );
//
//      ASSERT_EXCLUSIVE_FILE( IN PFCB Fcb );
//
//      ASSERT_SHARED_FILE( IN PFCB Fcb );
//
//      ASSERT_LOCKED_VCB( IN PVCB Vcb );
//
//      ASSERT_NOT_LOCKED_VCB( IN PVCB Vcb );
//
//      ASSERT_LOCKED_FCB( IN PFCB Fcb );
//
//      ASSERT_NOT_LOCKED_FCB( IN PFCB Fcb );
//

//
//  Turn on the sanity checks if this is DBG or CD_FREE_ASSERTS
//

#if DBG
#undef CD_SANITY
#define CD_SANITY
#endif

#ifdef CD_SANITY

#define ASSERT_STRUCT(S,T)                  ASSERT( SafeNodeType( S ) == (T) )
#define ASSERT_OPTIONAL_STRUCT(S,T)         ASSERT( ((S) == NULL) ||  (SafeNodeType( S ) == (T)) )

#define ASSERT_VCB(V)                       ASSERT_STRUCT( (V), CDFS_NTC_VCB )
#define ASSERT_OPTIONAL_VCB(V)              ASSERT_OPTIONAL_STRUCT( (V), CDFS_NTC_VCB )

#define ASSERT_FCB(F)                                           \
    ASSERT( (SafeNodeType( F ) == CDFS_NTC_FCB_DATA ) ||        \
            (SafeNodeType( F ) == CDFS_NTC_FCB_INDEX ) ||       \
            (SafeNodeType( F ) == CDFS_NTC_FCB_PATH_TABLE ) )

#define ASSERT_OPTIONAL_FCB(F)                                  \
    ASSERT( ((F) == NULL) ||                                    \
            (SafeNodeType( F ) == CDFS_NTC_FCB_DATA ) ||        \
            (SafeNodeType( F ) == CDFS_NTC_FCB_INDEX ) ||       \
            (SafeNodeType( F ) == CDFS_NTC_FCB_PATH_TABLE ) )

#define ASSERT_FCB_NONPAGED(FN)             ASSERT_STRUCT( (FN), CDFS_NTC_FCB_NONPAGED )
#define ASSERT_OPTIONAL_FCB_NONPAGED(FN)    ASSERT_OPTIONAL_STRUCT( (FN), CDFS_NTC_FCB_NONPAGED )

#define ASSERT_CCB(C)                       ASSERT_STRUCT( (C), CDFS_NTC_CCB )
#define ASSERT_OPTIONAL_CCB(C)              ASSERT_OPTIONAL_STRUCT( (C), CDFS_NTC_CCB )

#define ASSERT_IRP_CONTEXT(IC)              ASSERT_STRUCT( (IC), CDFS_NTC_IRP_CONTEXT )
#define ASSERT_OPTIONAL_IRP_CONTEXT(IC)     ASSERT_OPTIONAL_STRUCT( (IC), CDFS_NTC_IRP_CONTEXT )

#define ASSERT_IRP(I)                       ASSERT_STRUCT( (I), IO_TYPE_IRP )
#define ASSERT_OPTIONAL_IRP(I)              ASSERT_OPTIONAL_STRUCT( (I), IO_TYPE_IRP )

#define ASSERT_FILE_OBJECT(FO)              ASSERT_STRUCT( (FO), IO_TYPE_FILE )
#define ASSERT_OPTIONAL_FILE_OBJECT(FO)     ASSERT_OPTIONAL_STRUCT( (FO), IO_TYPE_FILE )

#define ASSERT_EXCLUSIVE_RESOURCE(R)        ASSERT( ExIsResourceAcquiredExclusiveLite( R ))

#define ASSERT_SHARED_RESOURCE(R)           ASSERT( ExIsResourceAcquiredSharedLite( R ))

#define ASSERT_RESOURCE_NOT_MINE(R)         ASSERT( !ExIsResourceAcquiredSharedLite( R ))

#define ASSERT_EXCLUSIVE_CDDATA             ASSERT( ExIsResourceAcquiredExclusiveLite( &CdData.DataResource ))
#define ASSERT_EXCLUSIVE_VCB(V)             ASSERT( ExIsResourceAcquiredExclusiveLite( &(V)->VcbResource ))
#define ASSERT_SHARED_VCB(V)                ASSERT( ExIsResourceAcquiredSharedLite( &(V)->VcbResource ))

#define ASSERT_EXCLUSIVE_FCB(F)             ASSERT( ExIsResourceAcquiredExclusiveLite( &(F)->FcbNonpaged->FcbResource ))
#define ASSERT_SHARED_FCB(F)                ASSERT( ExIsResourceAcquiredSharedLite( &(F)->FcbNonpaged->FcbResource ))

#define ASSERT_EXCLUSIVE_FILE(F)            ASSERT( ExIsResourceAcquiredExclusiveLite( (F)->Resource ))
#define ASSERT_SHARED_FILE(F)               ASSERT( ExIsResourceAcquiredSharedLite( (F)->Resource ))

#define ASSERT_LOCKED_VCB(V)                ASSERT( (V)->VcbLockThread == PsGetCurrentThread() )
#define ASSERT_NOT_LOCKED_VCB(V)            ASSERT( (V)->VcbLockThread != PsGetCurrentThread() )

#define ASSERT_LOCKED_FCB(F)                ASSERT( !FlagOn( (F)->FcbState, FCB_STATE_IN_FCB_TABLE) || ((F)->FcbLockThread == PsGetCurrentThread()))
#define ASSERT_NOT_LOCKED_FCB(F)            ASSERT( (F)->FcbLockThread != PsGetCurrentThread() )

#else

#define DebugBreakOnStatus(S)           { NOTHING; }

#define ASSERT_STRUCT(S,T)              { NOTHING; }
#define ASSERT_OPTIONAL_STRUCT(S,T)     { NOTHING; }
#define ASSERT_VCB(V)                   { NOTHING; }
#define ASSERT_OPTIONAL_VCB(V)          { NOTHING; }
#define ASSERT_FCB(F)                   { NOTHING; }
#define ASSERT_OPTIONAL_FCB(F)          { NOTHING; }
#define ASSERT_FCB_NONPAGED(FN)         { NOTHING; }
#define ASSERT_OPTIONAL_FCB(FN)         { NOTHING; }
#define ASSERT_CCB(C)                   { NOTHING; }
#define ASSERT_OPTIONAL_CCB(C)          { NOTHING; }
#define ASSERT_IRP_CONTEXT(IC)          { NOTHING; }
#define ASSERT_OPTIONAL_IRP_CONTEXT(IC) { NOTHING; }
#define ASSERT_IRP(I)                   { NOTHING; }
#define ASSERT_OPTIONAL_IRP(I)          { NOTHING; }
#define ASSERT_FILE_OBJECT(FO)          { NOTHING; }
#define ASSERT_OPTIONAL_FILE_OBJECT(FO) { NOTHING; }
#define ASSERT_EXCLUSIVE_RESOURCE(R)    { NOTHING; }
#define ASSERT_SHARED_RESOURCE(R)       { NOTHING; }
#define ASSERT_RESOURCE_NOT_MINE(R)     { NOTHING; }
#define ASSERT_EXCLUSIVE_CDDATA         { NOTHING; }
#define ASSERT_EXCLUSIVE_VCB(V)         { NOTHING; }
#define ASSERT_SHARED_VCB(V)            { NOTHING; }
#define ASSERT_EXCLUSIVE_FCB(F)         { NOTHING; }
#define ASSERT_SHARED_FCB(F)            { NOTHING; }
#define ASSERT_EXCLUSIVE_FILE(F)        { NOTHING; }
#define ASSERT_SHARED_FILE(F)           { NOTHING; }
#define ASSERT_LOCKED_VCB(V)            { NOTHING; }
#define ASSERT_NOT_LOCKED_VCB(V)        { NOTHING; }
#define ASSERT_LOCKED_FCB(F)            { NOTHING; }
#define ASSERT_NOT_LOCKED_FCB(F)        { NOTHING; }

#endif

#endif // _CDDATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\eventlog\test\testwina.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    TESTWINA.C

Abstract:

    Test program for the eventlog service. This program calls the Win
    APIs to test out the operation of the service.

Author:

    Rajen Shah  (rajens) 05-Aug-1991

Revision History:


--*/
/*----------------------*/
/* INCLUDES             */
/*----------------------*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>      // printf
#include <string.h>     // stricmp
#include <stdlib.h>
#include <windows.h>
#include <netevent.h>
//#include <elfcommn.h>


#define     READ_BUFFER_SIZE        1024*2      // Use 2K buffer

#define     SIZE_DATA_ARRAY         65

//
// Global buffer used to emulate "binary data" when writing an event
// record.
//
DWORD    Data[SIZE_DATA_ARRAY];
BOOL     bHackTestBackup = FALSE;
PCHAR pServerName = NULL;


VOID
Initialize (
    VOID
    )
{
    DWORD   i;

    // Initialize the values in the data buffer.
    //
    for (i=0; i< SIZE_DATA_ARRAY; i++)
        Data[i] = i;

}


BOOL
Usage (
    VOID
    )
{
    printf( "usage: \n" );
    printf( "-c             Tests ClearEventLog API\n");
    printf( "-b filename    Tests BackupEventLog API\n");
    printf( "-rsb           Reads event log sequentially backwards\n");
    printf( "-rsf           Reads event log sequentially forwards\n");
    printf( "-rrb <record>  Reads event log from <record> backwards\n");
    printf( "-rrf <record>  Reads event log from <record> forwards\n");
    printf( "-w <count>     Tests ReportEvent API <count> times\n");
    return ERROR_INVALID_PARAMETER;

} // Usage



BOOL
WriteLogEntry ( HANDLE LogHandle, DWORD EventID )

{
#define NUM_STRINGS     2
#define MAX_STRING_SIZE 32767   // Max size is FFFF/2 for ANSI strings

    BOOL    Status;
    WORD    EventType;
    DWORD   i;
    DWORD   DataSize;
    PSID    pUserSid;
    PCHAR   BigString;

    // PSTR    Strings[NUM_STRINGS] = {"StringAOne","StringATwo" };
    PSTR    Strings[NUM_STRINGS];

    Strings[0] = "StringAOne";

    BigString = malloc(MAX_STRING_SIZE);

    for (i = 0; i < MAX_STRING_SIZE; i++) {
        BigString[i] = 'A';
    }

    BigString[MAX_STRING_SIZE-1] = '\0';
    Strings[1] = BigString;

    EventType = EVENTLOG_INFORMATION_TYPE;
    pUserSid   = NULL;
    DataSize  = sizeof(DWORD) * SIZE_DATA_ARRAY;

    for (i=0; i< SIZE_DATA_ARRAY; i++)
        Data[i] += i;

    Status = ReportEventA (
                    LogHandle,
                    EventType,
                    0,           // event category
                    EventID,
                    pUserSid,
                    (WORD) NUM_STRINGS,
                    DataSize,
                    Strings,
                    (PVOID)Data
                    );

    free(BigString);
    return (Status);
}

BOOL
WriteLogEntryMsg ( HANDLE LogHandle, DWORD EventID )
/*
    This function requires a registry entry in the Applications section
    of the Eventlog for TESTWINAAPP, it will use the netevent.dll message file.
*/
{
#define NUM_STRINGS     2

    BOOL    Status;
    WORD    EventType;
    DWORD   DataSize;
    PSID    pUserSid;
    PCHAR   BigString;

    PSTR    Strings[NUM_STRINGS];

    Strings[0] = "This is a BOGUS message for TEST purposes Ignore this substitution text";
    Strings[1] = "GHOST SERVICE in the long string format - I wanted a long string to pass into this function";

    EventType = EVENTLOG_INFORMATION_TYPE;
    pUserSid   = NULL;
    DataSize  = sizeof(DWORD) * SIZE_DATA_ARRAY;

    Status = ReportEventA (
                    LogHandle,
                    EventType,
                    0,          // event category
                    EVENT_SERVICE_START_FAILED_NONE,
                    pUserSid,
                    (WORD) NUM_STRINGS,
                    0,          // DataSize
                    Strings,
                    (PVOID)NULL // Data
                    );

    free(BigString);
    return (Status);
}


VOID
DisplayEventRecords( PVOID Buffer,
                     DWORD  BufSize,
                     ULONG *NumRecords)

{
    PEVENTLOGRECORD     pLogRecord;
    PSTR                pString;
    DWORD               Count = 0;
    DWORD               Offset = 0;
    DWORD               i;

    pLogRecord = (PEVENTLOGRECORD) Buffer;

    while ((DWORD)Offset < BufSize) {

        Count++;

        printf("\n\nRecord # %lu\n", pLogRecord->RecordNumber);

        printf("Length: 0x%lx TimeGenerated: 0x%lx  EventID: 0x%lx EventType: 0x%x\n",
                pLogRecord->Length, pLogRecord->TimeGenerated, pLogRecord->EventID,
                pLogRecord->EventType);

        printf("NumStrings: 0x%x StringOffset: 0x%lx UserSidLength: 0x%lx TimeWritten: 0x%lx\n",
                pLogRecord->NumStrings, pLogRecord->StringOffset,
                pLogRecord->UserSidLength, pLogRecord->TimeWritten);

        printf("UserSidOffset: 0x%lx    DataLength: 0x%lx    DataOffset:  0x%lx \n",
                pLogRecord->UserSidOffset, pLogRecord->DataLength,
                pLogRecord->DataOffset);

        //
        // Print out module name
        //
        pString = (PSTR)((DWORD)pLogRecord + sizeof(EVENTLOGRECORD));
        printf("ModuleName:  %s  ", pString);

        //
        // Display ComputerName
        //
        pString = (PSTR)((DWORD)pString + strlen(pString) + 1);
        printf("ComputerName: %s\n",pString);

        //
        // Display strings
        //
        pString = (PSTR)((DWORD)Buffer + pLogRecord->StringOffset);

        printf("Strings: ");
        for (i=0; i<pLogRecord->NumStrings; i++) {

            printf("  %s  ", pString);
            pString = (PSTR)((DWORD)pString + strlen(pString) + 1);
        }

        // Get next record

        Offset += pLogRecord->Length;

        pLogRecord = (PEVENTLOGRECORD)((DWORD)Buffer + Offset);

    }
    *NumRecords = Count;

}


BOOL
ReadFromLog ( HANDLE LogHandle,
             PVOID  Buffer,
             ULONG *pBytesRead,
             DWORD  ReadFlag,
             DWORD  Record
             )
{
    BOOL        Status;
    DWORD       MinBytesNeeded;
    DWORD       ErrorCode;

    Status = ReadEventLogA (
                        LogHandle,
                        ReadFlag,
                        Record,
                        Buffer,
                        READ_BUFFER_SIZE,
                        pBytesRead,
                        &MinBytesNeeded
                        );


    if (!Status) {
         ErrorCode = GetLastError();
         printf("Error from ReadEventLog %d \n", ErrorCode);
         if (ErrorCode == ERROR_NO_MORE_FILES)
            printf("Buffer too small. Need %lu bytes min\n", MinBytesNeeded);

    }

    return (Status);
}




BOOL
TestReadEventLog (DWORD Count, DWORD ReadFlag, DWORD Record)

{
    BOOL    Status, IStatus;

    HANDLE      LogHandle;
    LPSTR  ModuleName;
    DWORD   NumRecords, BytesReturned;
    PVOID   Buffer;
    DWORD   RecordOffset;
    DWORD   NumberOfRecords;
    DWORD   OldestRecord;

    printf("Testing ReadEventLog API to read %lu entries\n",Count);

    Buffer = malloc (READ_BUFFER_SIZE);

    //
    // Initialize the strings
    //
    NumRecords = Count;
    ModuleName = "TESTWINAAPP";

    //
    // Open the log handle
    //

    //
    // This is just a quick and dirty way to test the api to read a backup
    // log, until I can fix test.c to be more general purpose.
    //

    if (bHackTestBackup) {
        printf("OpenBackupEventLog = ");
        LogHandle = OpenBackupEventLog(
                NULL,
                "\\\\danhi386\\roote\\view.log"
                );
    }
    else {
        printf("OpenEventLog - ");
        LogHandle = OpenEventLog (
            pServerName,
            ModuleName
            );
    }

    if (LogHandle == NULL) {
         printf("Error - %d\n", GetLastError());

    } else {
        printf("SUCCESS\n");

        //
        // Get and print record information
        //

        Status = GetNumberOfEventLogRecords(LogHandle, & NumberOfRecords);
        if (NT_SUCCESS(Status)) {
           Status = GetOldestEventLogRecord(LogHandle, & OldestRecord);
        }

        if (!NT_SUCCESS(Status)) {
           printf("Get of record information failed with %X", Status);
           return(Status);
        }

        printf("\nThere are %d records in the file, %d is the oldest"
         " record number\n", NumberOfRecords, OldestRecord);

        RecordOffset = Record;

        while (Count && (BytesReturned != 0)) {

            printf("Read %u records\n", NumRecords);
            //
            // Read from the log
            //
            Status = ReadFromLog ( LogHandle,
                                   Buffer,
                                   &BytesReturned,
                                   ReadFlag,
                                   RecordOffset
                                 );
            if (Status) {
                printf("Bytes read = 0x%lx\n", BytesReturned);
                DisplayEventRecords(Buffer, BytesReturned, &NumRecords);
                Count -= NumRecords;
                RecordOffset += NumRecords;
            } else {
                break;
            }

        }
        printf("\n");

        if (!Status) {
            printf ("Error - %d. Remaining count %lu\n", GetLastError(), Count);
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling CloseEventLog\n");
        IStatus = CloseEventLog (LogHandle);
    }
    free(Buffer);
    return (Status);
}



BOOL
TestWriteEventLog (DWORD Count)

{
    BOOL        Status, IStatus;
    HANDLE      LogHandle=NULL;
    LPSTR       ModuleName;
    DWORD       EventID = 99;
    DWORD       WriteCount;

    printf("Testing ReportEvent API\n");

    //
    // Initialize the strings
    //
    ModuleName = "TESTWINAAPP";

    //
    // Open the log handle
    //
    while (Count && NT_SUCCESS(Status)) {
        //printf("Calling RegisterEventSource for WRITE %lu times - ", Count);
        LogHandle = RegisterEventSourceA (
                        pServerName,
                        ModuleName
                        );
    
        if (LogHandle == NULL) {
             printf("Error - %d\n", GetLastError());
    
        } else {
            printf("Registered - ");
            WriteCount = 5;
            printf("Record # %u ", Count);

            while (WriteCount && NT_SUCCESS(Status)) {

                //
                // Write an entry into the log
                //
                Data[0] = Count;                        // Make data "unique"
                EventID = (EventID + Count) % 100;      // Vary the eventids
                Status = WriteLogEntryMsg ( LogHandle, EventID );
                Count--;
                WriteCount--;
    
                if (!Status) {
                    printf ("Error - %d. Remaining count %lu\n", GetLastError(), Count);
                } else {
                    printf ("%d,",WriteCount);
                }
            }
            IStatus = DeregisterEventSource (LogHandle);
            printf(" - Deregistered\n");
        }
    }

    return (Status);
}



BOOL
TestClearLogFile ()

{
    BOOL        Status, IStatus;
    HANDLE      LogHandle;
    LPSTR ModuleName, BackupName;

    printf("Testing ClearLogFile API\n");
    //
    // Initialize the strings
    //
    ModuleName = "TESTWINAAPP";

    //
    // Open the log handle
    //
    printf("Calling OpenEventLog for CLEAR - ");
    LogHandle = OpenEventLogA (
                    pServerName,
                    ModuleName
                    );

    if (!Status) {
         printf("Error - %d\n", GetLastError());

    } else {
        printf("SUCCESS\n");

        //
        // Clear the log file and back it up to "view.log"
        //

        printf("Calling ClearEventLog backing up to view.log  ");
        BackupName = "view.log";

        Status = ClearEventLogA (
                        LogHandle,
                        BackupName
                        );

        if (!Status) {
            printf ("Error - %d\n", GetLastError());
        } else {
            printf ("SUCCESS\n");
        }

        //
        // Now just clear the file without backing it up
        //
        printf("Calling ClearEventLog with no backup  ");
        Status = ClearEventLogA (
                        LogHandle,
                        NULL
                        );

        if (!Status) {
            printf ("Error - %d\n", GetLastError());
        } else {
            printf ("SUCCESS\n");
        }

        printf("Calling CloseEventLog\n");
        IStatus = CloseEventLog (LogHandle);
    }

    return(Status);
}


BOOL
TestBackupLogFile(
    LPSTR FileName
    )

{
    HANDLE      LogHandle;

    printf("Testing BackupEventLog API\n");

    //
    // Open the log handle
    //

    printf("Calling ElfOpenEventLog for BACKUP - ");
    LogHandle = OpenEventLogA (
                    NULL,
                    "Application"
                    );

    if (!LogHandle) {
         printf("Error - %d\n", GetLastError());

    } else {
        printf("SUCCESS\n");

        //
        // Backup the log file
        //

        printf("Calling BackupEventLogFile backing up to %s\n", FileName);

        if (!BackupEventLogA (
                        LogHandle,
                        FileName
                        )) {
            printf ("Error - %d\n", GetLastError());
        } else {
            printf ("SUCCESS\n");
        }


        printf("Calling CloseEventLog - ");
        if (CloseEventLog (LogHandle)) {
            printf("Success\n");
        }
        else {
            printf("Failed with code %d\n", GetLastError());
        }
    }

    return(TRUE);
}


/****************************************************************************/
BOOL
main (
    IN SHORT argc,
    IN PSZ argv[],
    )
/*++
*
* Routine Description:
*
*
*
* Arguments:
*
*
*
*
* Return Value:
*
*
*
--*/
/****************************************************************************/
{

    DWORD   ReadFlags;

    Initialize();           // Init any data

    //
    // Just till I can replace this horrid parm parsing with my own
    //

    if (getenv("REMOTE")) {
       pServerName = "\\\\danhi20";
    }

    if ( argc < 2 ) {
        printf( "Not enough parameters\n" );
        return Usage( );
    }

    if ( stricmp( argv[1], "-c" ) == 0 ) {

        if ( argc < 3 ) {
            return TestClearLogFile();
        }

    } else if (stricmp ( argv[1], "-b" ) == 0 ) {

        if ( argc < 3 ) {
            return Usage();
        } else {
            return TestBackupLogFile(argv[2]);
        }

    } else if (stricmp ( argv[1], "-rsf" ) == 0 ) {

        ReadFlags = EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags,0 );
        } else  {
            return Usage();
        }
    } else if (stricmp ( argv[1], "-xsf" ) == 0 ) {

        ReadFlags = EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ;
    bHackTestBackup = TRUE;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags,0 );
        } else  {
            return Usage();
        }
    } else if (stricmp ( argv[1], "-rsb" ) == 0 ) {

        ReadFlags = EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags,0 );
        } else  {
            return Usage();
        }
    } else if (stricmp ( argv[1], "-rrf" ) == 0 ) {

        ReadFlags = EVENTLOG_SEEK_READ | EVENTLOG_FORWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags ,1);
        } else if (argc == 3) {
            return (TestReadEventLog (1, ReadFlags, atoi(argv[2])));
        }
    } else if (stricmp ( argv[1], "-rrb" ) == 0 ) {

        ReadFlags = EVENTLOG_SEEK_READ | EVENTLOG_BACKWARDS_READ;
        if ( argc < 3 ) {
            return TestReadEventLog(1,ReadFlags, 1);
        } else if (argc == 3) {
            return (TestReadEventLog (1, ReadFlags, atoi(argv[2])));
        }
    } else if (stricmp ( argv[1], "-w" ) == 0 ) {

        if ( argc < 3 ) {
            return TestWriteEventLog(1);
        } else if (argc == 3) {
            return (TestWriteEventLog (atoi(argv[2])));
        }

    } else {

        return Usage();
    }

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\cddata.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    CdData.c

Abstract:

    This module declares the global data used by the Cdfs file system.

    This module also handles the dispath routines in the Fsd threads as well as
    handling the IrpContext and Irp through the exception path.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

#ifdef CD_SANITY
BOOLEAN CdTestTopLevel = TRUE;
BOOLEAN CdTestRaisedStatus = TRUE;
BOOLEAN CdBreakOnAnyRaise = FALSE;
BOOLEAN CdTraceRaises = FALSE;
NTSTATUS CdInterestingExceptionCodes[] = { STATUS_DISK_CORRUPT_ERROR, 
                                           STATUS_FILE_CORRUPT_ERROR,
                                           0, 0, 0, 0, 0, 0, 0, 0 };
#endif

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_CDDATA)

//
//  Global data structures
//

CD_DATA CdData;
FAST_IO_DISPATCH CdFastIoDispatch;

//
//  Reserved directory strings.
//

WCHAR CdUnicodeSelfArray[] = { L'.' };
WCHAR CdUnicodeParentArray[] = { L'.', L'.' };

UNICODE_STRING CdUnicodeDirectoryNames[] = {
    { 2, 2, CdUnicodeSelfArray},
    { 4, 4, CdUnicodeParentArray}
};

//
//  Volume descriptor identifier strings.
//

CHAR CdHsgId[] = { 'C', 'D', 'R', 'O', 'M' };
CHAR CdIsoId[] = { 'C', 'D', '0', '0', '1' };
CHAR CdXaId[] = { 'C', 'D', '-', 'X', 'A', '0', '0', '1' };

//
//  Volume label for audio disks.
//

WCHAR CdAudioLabel[] = { L'A', L'u', L'd', L'i', L'o', L' ', L'C', L'D' };
USHORT CdAudioLabelLength = sizeof( CdAudioLabel );

//
//  Pseudo file names for audio disks.
//

CHAR CdAudioFileName[] = { 'T', 'r', 'a', 'c', 'k', '0', '0', '.', 'c', 'd', 'a' };
UCHAR CdAudioFileNameLength = sizeof( CdAudioFileName );
ULONG CdAudioDirentSize = FIELD_OFFSET( RAW_DIRENT, FileId ) + sizeof( CdAudioFileName ) + sizeof( SYSTEM_USE_XA );
ULONG CdAudioDirentsPerSector = SECTOR_SIZE / (FIELD_OFFSET( RAW_DIRENT, FileId ) + sizeof( CdAudioFileName ) + sizeof( SYSTEM_USE_XA ));
ULONG CdAudioSystemUseOffset = FIELD_OFFSET( RAW_DIRENT, FileId ) + sizeof( CdAudioFileName );

//
//  Escape sequences for mounting Unicode volumes.
//

PCHAR CdJolietEscape[] = { "%/@", "%/C", "%/E" };

//
//  Audio Play Files consist completely of this header block.  These
//  files are readable in the root of any audio disc regardless of
//  the capabilities of the drive.
//
//  The "Unique Disk ID Number" is a calculated value consisting of
//  a combination of parameters, including the number of tracks and
//  the starting locations of those tracks.
//
//  Applications interpreting CDDA RIFF files should be advised that
//  additional RIFF file chunks may be added to this header in the
//  future in order to add information, such as the disk and song title.
//

LONG CdAudioPlayHeader[] = {
    0x46464952,                         // Chunk ID = 'RIFF'
    4 * 11 - 8,                         // Chunk Size = (file size - 8)
    0x41444443,                         // 'CDDA'
    0x20746d66,                         // 'fmt '
    24,                                 // Chunk Size (of 'fmt ' subchunk) = 24
    0x00000001,                         // WORD Format Tag, WORD Track Number
    0x00000000,                         // DWORD Unique Disk ID Number
    0x00000000,                         // DWORD Track Starting Sector (LBN)
    0x00000000,                         // DWORD Track Length (LBN count)
    0x00000000,                         // DWORD Track Starting Sector (MSF)
    0x00000000                          // DWORD Track Length (MSF)
};

//  Audio Philes begin with this header block to identify the data as a
//  PCM waveform.  AudioPhileHeader is coded as if it has no data included
//  in the waveform.  Data must be added in 2352-byte multiples.
//
//  Fields marked 'ADJUST' need to be adjusted based on the size of the
//  data: Add (nSectors*2352) to the DWORDs at offsets 1*4 and 10*4.
//
//  File Size of TRACK??.WAV = nSectors*2352 + sizeof(AudioPhileHeader)
//  RIFF('WAVE' fmt(1, 2, 44100, 176400, 16, 4) data( <CD Audio Raw Data> )
//
//  The number of sectors in a CD-XA CD-DA file is (DataLen/2048).
//  CDFS will expose these files to applications as if they were just
//  'WAVE' files, adjusting the file size so that the RIFF file is valid.
//
//  NT NOTE: We do not do any fidelity adjustment. These are presented as raw
//  2352 byte sectors - 95 has the glimmer of an idea to allow CDFS to expose
//  the CDXA CDDA data at different sampling rates in a virtual directory
//  structure, but we will never do that.
//

LONG CdXAAudioPhileHeader[] = {
    0x46464952,                         // Chunk ID = 'RIFF'
    -8,                                 // Chunk Size = (file size - 8) ADJUST1
    0x45564157,                         // 'WAVE'
    0x20746d66,                         // 'fmt '
    16,                                 // Chunk Size (of 'fmt ' subchunk) = 16
    0x00020001,                         // WORD Format Tag WORD nChannels
    44100,                              // DWORD nSamplesPerSecond
    2352 * 75,                          // DWORD nAvgBytesPerSec
    0x00100004,                         // WORD nBlockAlign WORD nBitsPerSample
    0x61746164,                         // 'data'
    -44                                 // <CD Audio Raw Data>          ADJUST2
};

//
//  XA Files begin with this RIFF header block to identify the data as
//  raw CD-XA sectors.  Data must be added in 2352-byte multiples.
//
//  This header is added to all CD-XA files which are marked as having
//  mode2form2 sectors.
//
//  Fields marked 'ADJUST' need to be adjusted based on the size of the
//  data: Add file size to the marked DWORDS.
//
//  File Size of TRACK??.WAV = nSectors*2352 + sizeof(XAFileHeader)
//
//  RIFF('CDXA' FMT(Owner, Attr, 'X', 'A', FileNum, 0) data ( <CDXA Raw Data> )
//

LONG CdXAFileHeader[] = {
    0x46464952,                         // Chunk ID = 'RIFF'
    -8,                                 // Chunk Size = (file size - 8) ADJUST
    0x41584443,                         // 'CDXA'
    0x20746d66,                         // 'fmt '
    16,                                 // Chunk Size (of CDXA chunk) = 16
    0,                                  // DWORD Owner ID
    0x41580000,                         // WORD Attributes
                                        // BYTE Signature byte 1 'X'
                                        // BYTE Signature byte 2 'A'
    0,                                  // BYTE File Number
    0,                                  // BYTE Reserved[7]
    0x61746164,                         // 'data'
    -44                                 // <CD-XA Raw Sectors>          ADJUST
};

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdFastIoCheckIfPossible)
#pragma alloc_text(PAGE, CdSerial32)
#endif


NTSTATUS
CdFsdDispatch (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the driver entry to all of the Fsd dispatch points.

    Conceptually the Io routine will call this routine on all requests
    to the file system.  We case on the type of request and invoke the
    correct handler for this type of request.  There is an exception filter
    to catch any exceptions in the CDFS code as well as the CDFS process
    exception routine.

    This routine allocates and initializes the IrpContext for this request as
    well as updating the top-level thread context as necessary.  We may loop
    in this routine if we need to retry the request for any reason.  The
    status code STATUS_CANT_WAIT is used to indicate this.  Suppose the disk
    in the drive has changed.  An Fsd request will proceed normally until it
    recognizes this condition.  STATUS_VERIFY_REQUIRED is raised at that point
    and the exception code will handle the verify and either return
    STATUS_CANT_WAIT or STATUS_PENDING depending on whether the request was
    posted.

Arguments:

    VolumeDeviceObject - Supplies the volume device object for this request

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    THREAD_CONTEXT ThreadContext;
    PIRP_CONTEXT IrpContext = NULL;
    BOOLEAN Wait;

#ifdef CD_SANITY
    PVOID PreviousTopLevel;
#endif

    NTSTATUS Status;

    KIRQL SaveIrql = KeGetCurrentIrql();

    ASSERT_OPTIONAL_IRP( Irp );

    FsRtlEnterFileSystem();

#ifdef CD_SANITY
    PreviousTopLevel = IoGetTopLevelIrp();
#endif

    //
    //  Loop until this request has been completed or posted.
    //

    do {

        //
        //  Use a try-except to handle the exception cases.
        //

        try {

            //
            //  If the IrpContext is NULL then this is the first pass through
            //  this loop.
            //

            if (IrpContext == NULL) {

                //
                //  Decide if this request is waitable an allocate the IrpContext.
                //  If the file object in the stack location is NULL then this
                //  is a mount which is always waitable.  Otherwise we look at
                //  the file object flags.
                //

                if (IoGetCurrentIrpStackLocation( Irp )->FileObject == NULL) {

                    Wait = TRUE;

                } else {

                    Wait = CanFsdWait( Irp );
                }

                IrpContext = CdCreateIrpContext( Irp, Wait );

                //
                //  Update the thread context information.
                //

                CdSetThreadContext( IrpContext, &ThreadContext );

#ifdef CD_SANITY
                ASSERT( !CdTestTopLevel ||
                        SafeNodeType( IrpContext->TopLevel ) == CDFS_NTC_IRP_CONTEXT );
#endif

            //
            //  Otherwise cleanup the IrpContext for the retry.
            //

            } else {

                //
                //  Set the MORE_PROCESSING flag to make sure the IrpContext
                //  isn't inadvertently deleted here.  Then cleanup the
                //  IrpContext to perform the retry.
                //

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
                CdCleanupIrpContext( IrpContext, FALSE );
            }

            //
            //  Case on the major irp code.
            //

            switch (IrpContext->MajorFunction) {

            case IRP_MJ_CREATE :

                Status = CdCommonCreate( IrpContext, Irp );
                break;

            case IRP_MJ_CLOSE :

                Status = CdCommonClose( IrpContext, Irp );
                break;

            case IRP_MJ_READ :

                //
                //  If this is an Mdl complete request, don't go through
                //  common read.
                //

                if (FlagOn( IrpContext->MinorFunction, IRP_MN_COMPLETE )) {

                    Status = CdCompleteMdl( IrpContext, Irp );

                } else {

                    Status = CdCommonRead( IrpContext, Irp );
                }

                break;

            case IRP_MJ_QUERY_INFORMATION :

                Status = CdCommonQueryInfo( IrpContext, Irp );
                break;

            case IRP_MJ_SET_INFORMATION :

                Status = CdCommonSetInfo( IrpContext, Irp );
                break;

            case IRP_MJ_QUERY_VOLUME_INFORMATION :

                Status = CdCommonQueryVolInfo( IrpContext, Irp );
                break;

            case IRP_MJ_DIRECTORY_CONTROL :

                Status = CdCommonDirControl( IrpContext, Irp );
                break;

            case IRP_MJ_FILE_SYSTEM_CONTROL :

                Status = CdCommonFsControl( IrpContext, Irp );
                break;

            case IRP_MJ_DEVICE_CONTROL :

                Status = CdCommonDevControl( IrpContext, Irp );
                break;

            case IRP_MJ_LOCK_CONTROL :

                Status = CdCommonLockControl( IrpContext, Irp );
                break;

            case IRP_MJ_CLEANUP :

                Status = CdCommonCleanup( IrpContext, Irp );
                break;

            case IRP_MJ_PNP :

                Status = CdCommonPnp( IrpContext, Irp );
                break;

            default :

                Status = STATUS_INVALID_DEVICE_REQUEST;
                CdCompleteRequest( IrpContext, Irp, Status );
            }

        } except( CdExceptionFilter( IrpContext, GetExceptionInformation() )) {

            Status = CdProcessException( IrpContext, Irp, GetExceptionCode() );
        }

    } while (Status == STATUS_CANT_WAIT);

#ifdef CD_SANITY
    ASSERT( !CdTestTopLevel ||
            (PreviousTopLevel == IoGetTopLevelIrp()) );
#endif

    FsRtlExitFileSystem();

    ASSERT( SaveIrql == KeGetCurrentIrql( ));

    return Status;
}


#ifdef CD_SANITY

VOID
CdRaiseStatusEx(
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status,
    IN BOOLEAN NormalizeStatus,
    IN OPTIONAL ULONG FileId,
    IN OPTIONAL ULONG Line
    )
{
    BOOLEAN BreakIn = FALSE;
    
    AssertVerifyDevice( IrpContext, Status);

    if (CdTraceRaises)  {

        DbgPrint( "%p CdRaiseStatusEx 0x%x @ fid %d, line %d\n", PsGetCurrentThread(), Status, FileId, Line);
    }

    if (CdTestRaisedStatus && !CdBreakOnAnyRaise)  {

        ULONG Index;

        for (Index = 0; 
             Index < (sizeof( CdInterestingExceptionCodes) / sizeof( CdInterestingExceptionCodes[0])); 
             Index++)  {

            if ((STATUS_SUCCESS != CdInterestingExceptionCodes[Index]) &&
                (CdInterestingExceptionCodes[Index] == Status))  {

                BreakIn = TRUE;
                break;
            }
        }
    }

    if (BreakIn || CdBreakOnAnyRaise)  {
        
        DbgPrint( "CDFS: Breaking on raised status %08x  (BI=%d,BA=%d)\n", Status, BreakIn, CdBreakOnAnyRaise);
        DbgPrint( "CDFS: (FILEID %d LINE %d)\n", FileId, Line);
        DbgPrint( "CDFS: Contact CDFS.SYS component owner for triage.\n");
        DbgPrint( "CDFS: 'eb %p 0;eb %p 0' to disable this alert.\n", &CdTestRaisedStatus, &CdBreakOnAnyRaise);

        DbgBreakPoint();
    }
    
    if (NormalizeStatus)  {

        IrpContext->ExceptionStatus = FsRtlNormalizeNtstatus( Status, STATUS_UNEXPECTED_IO_ERROR);
    }
    else {

        IrpContext->ExceptionStatus = Status;
    }

    IrpContext->RaisedAtLineFile = (FileId << 16) | Line;
    
    ExRaiseStatus( IrpContext->ExceptionStatus);
}

#endif


LONG
CdExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )

/*++

Routine Description:

    This routine is used to decide whether we will handle a raised exception
    status.  If CDFS explicitly raised an error then this status is already
    in the IrpContext.  We choose which is the correct status code and
    either indicate that we will handle the exception or bug-check the system.

Arguments:

    ExceptionCode - Supplies the exception code to being checked.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or bugchecks

--*/

{
    NTSTATUS ExceptionCode;
    BOOLEAN TestStatus = TRUE;

    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );

    ExceptionCode = ExceptionPointer->ExceptionRecord->ExceptionCode;

    //
    // If the exception is STATUS_IN_PAGE_ERROR, get the I/O error code
    // from the exception record.
    //

    if ((ExceptionCode == STATUS_IN_PAGE_ERROR) &&
        (ExceptionPointer->ExceptionRecord->NumberParameters >= 3)) {

        ExceptionCode =
            (NTSTATUS)ExceptionPointer->ExceptionRecord->ExceptionInformation[2];
    }

    //
    //  If there is an Irp context then check which status code to use.
    //

    if (ARGUMENT_PRESENT( IrpContext )) {

        if (IrpContext->ExceptionStatus == STATUS_SUCCESS) {

            //
            //  Store the real status into the IrpContext.
            //

            IrpContext->ExceptionStatus = ExceptionCode;

        } else {

            //
            //  No need to test the status code if we raised it ourselves.
            //

            TestStatus = FALSE;
        }
    }

    AssertVerifyDevice( IrpContext, IrpContext->ExceptionStatus );
    
    //
    //  Bug check if this status is not supported.
    //

    if (TestStatus && !FsRtlIsNtstatusExpected( ExceptionCode )) {

        CdBugCheck( (ULONG_PTR) ExceptionPointer->ExceptionRecord,
                    (ULONG_PTR) ExceptionPointer->ContextRecord,
                    (ULONG_PTR) ExceptionPointer->ExceptionRecord->ExceptionAddress );

    }

    return EXCEPTION_EXECUTE_HANDLER;
}


NTSTATUS
CdProcessException (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This routine processes an exception.  It either completes the request
    with the exception status in the IrpContext, sends this off to the Fsp
    workque or causes it to be retried in the current thread if a verification
    is needed.

    If the volume needs to be verified (STATUS_VERIFY_REQUIRED) and we can
    do the work in the current thread we will translate the status code
    to STATUS_CANT_WAIT to indicate that we need to retry the request.

Arguments:

    Irp - Supplies the Irp being processed

    ExceptionCode - Supplies the normalized exception status being handled

Return Value:

    NTSTATUS - Returns the results of either posting the Irp or the
        saved completion status.

--*/

{
    PDEVICE_OBJECT Device;
    PVPB Vpb;
    PETHREAD Thread;

    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );
    
    //
    //  If there is not an irp context, then complete the request with the
    //  current status code.
    //

    if (!ARGUMENT_PRESENT( IrpContext )) {

        CdCompleteRequest( NULL, Irp, ExceptionCode );
        return ExceptionCode;
    }

    //
    //  Get the real exception status from the IrpContext.
    //

    ExceptionCode = IrpContext->ExceptionStatus;

    //
    //  If we are not a top level request then we just complete the request
    //  with the current status code.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL )) {

        CdCompleteRequest( IrpContext, Irp, ExceptionCode );
        return ExceptionCode;
    }

    //
    //  Check if we are posting this request.  One of the following must be true
    //  if we are to post a request.
    //
    //      - Status code is STATUS_CANT_WAIT and the request is asynchronous
    //          or we are forcing this to be posted.
    //
    //      - Status code is STATUS_VERIFY_REQUIRED and we are at APC level
    //          or higher.  Can't wait for IO in the verify path in this case.
    //
    //  Set the MORE_PROCESSING flag in the IrpContext to keep if from being
    //  deleted if this is a retryable condition.
    //
    //
    //  Note that (children of) CdFsdPostRequest can raise (Mdl allocation).
    //

    try {
    
        if (ExceptionCode == STATUS_CANT_WAIT) {

            if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST )) {

                ExceptionCode = CdFsdPostRequest( IrpContext, Irp );
            }

        } else if (ExceptionCode == STATUS_VERIFY_REQUIRED) {

            if (KeGetCurrentIrql() >= APC_LEVEL) {

                ExceptionCode = CdFsdPostRequest( IrpContext, Irp );
            }
        }
    }
    except( CdExceptionFilter( IrpContext, GetExceptionInformation() ))  {
    
        ExceptionCode = GetExceptionCode();        
    }
    
    //
    //  If we posted the request or our caller will retry then just return here.
    //

    if ((ExceptionCode == STATUS_PENDING) ||
        (ExceptionCode == STATUS_CANT_WAIT)) {

        return ExceptionCode;
    }

    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );

    //
    //  Store this error into the Irp for posting back to the Io system.
    //

    Irp->IoStatus.Status = ExceptionCode;

    if (IoIsErrorUserInduced( ExceptionCode )) {

        //
        //  Check for the various error conditions that can be caused by,
        //  and possibly resolved my the user.
        //

        if (ExceptionCode == STATUS_VERIFY_REQUIRED) {

            //
            //  Now we are at the top level file system entry point.
            //
            //  If we have already posted this request then the device to
            //  verify is in the original thread.  Find this via the Irp.
            //

            Device = IoGetDeviceToVerify( Irp->Tail.Overlay.Thread );
            IoSetDeviceToVerify( Irp->Tail.Overlay.Thread, NULL );
            
            //
            //  If there is no device in that location then check in the
            //  current thread.
            //

            if (Device == NULL) {

                Device = IoGetDeviceToVerify( PsGetCurrentThread() );
                IoSetDeviceToVerify( PsGetCurrentThread(), NULL );

                ASSERT( Device != NULL );

                //
                //  Let's not BugCheck just because the driver messes up.
                //

                if (Device == NULL) {

                    ExceptionCode = STATUS_DRIVER_INTERNAL_ERROR;

                    CdCompleteRequest( IrpContext, Irp, ExceptionCode );

                    return ExceptionCode;
                }
            }

            //
            //  CdPerformVerify() will do the right thing with the Irp.
            //  If we return STATUS_CANT_WAIT then the current thread
            //  can retry the request.
            //

            return CdPerformVerify( IrpContext, Irp, Device );
        }

        //
        //  The other user induced conditions generate an error unless
        //  they have been disabled for this request.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS )) {

            CdCompleteRequest( IrpContext, Irp, ExceptionCode );

            return ExceptionCode;

        } 
        //
        //  Generate a pop-up.
        //
        else {

            if (IoGetCurrentIrpStackLocation( Irp )->FileObject != NULL) {

                Vpb = IoGetCurrentIrpStackLocation( Irp )->FileObject->Vpb;

            } else {

                Vpb = NULL;
            }

            //
            //  The device to verify is either in my thread local storage
            //  or that of the thread that owns the Irp.
            //

            Thread = Irp->Tail.Overlay.Thread;
            Device = IoGetDeviceToVerify( Thread );

            if (Device == NULL) {

                Thread = PsGetCurrentThread();
                Device = IoGetDeviceToVerify( Thread );

                ASSERT( Device != NULL );

                //
                //  Let's not BugCheck just because the driver messes up.
                //

                if (Device == NULL) {

                    CdCompleteRequest( IrpContext, Irp, ExceptionCode );

                    return ExceptionCode;
                }
            }

            //
            //  This routine actually causes the pop-up.  It usually
            //  does this by queuing an APC to the callers thread,
            //  but in some cases it will complete the request immediately,
            //  so it is very important to IoMarkIrpPending() first.
            //

            IoMarkIrpPending( Irp );
            IoRaiseHardError( Irp, Vpb, Device );

            //
            //  We will be handing control back to the caller here, so
            //  reset the saved device object.
            //

            IoSetDeviceToVerify( Thread, NULL );

            //
            //  The Irp will be completed by Io or resubmitted.  In either
            //  case we must clean up the IrpContext here.
            //

            CdCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
            return STATUS_PENDING;
        }
    }

    //
    //  This is just a run of the mill error.
    //

    CdCompleteRequest( IrpContext, Irp, ExceptionCode );

    return ExceptionCode;
}


VOID
CdCompleteRequest (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This routine completes a Irp and cleans up the IrpContext.  Either or
    both of these may not be specified.

Arguments:

    Irp - Supplies the Irp being processed.

    Status - Supplies the status to complete the Irp with

Return Value:

    None.

--*/

{
    ASSERT_OPTIONAL_IRP_CONTEXT( IrpContext );
    ASSERT_OPTIONAL_IRP( Irp );

    //
    //  Cleanup the IrpContext if passed in here.
    //

    if (ARGUMENT_PRESENT( IrpContext )) {

        CdCleanupIrpContext( IrpContext, FALSE );
    }

    //
    //  If we have an Irp then complete the irp.
    //

    if (ARGUMENT_PRESENT( Irp )) {

        //
        //  Clear the information field in case we have used this Irp
        //  internally.
        //

        if (NT_ERROR( Status ) &&
            FlagOn( Irp->Flags, IRP_INPUT_OPERATION )) {

            Irp->IoStatus.Information = 0;
        }

        Irp->IoStatus.Status = Status;

        AssertVerifyDeviceIrp( Irp );
        
        IoCompleteRequest( Irp, IO_CD_ROM_INCREMENT );
    }

    return;
}


VOID
CdSetThreadContext (
    IN PIRP_CONTEXT IrpContext,
    IN PTHREAD_CONTEXT ThreadContext
    )

/*++

Routine Description:

    This routine is called at each Fsd/Fsp entry point set up the IrpContext
    and thread local storage to track top level requests.  If there is
    not a Cdfs context in the thread local storage then we use the input one.
    Otherwise we use the one already there.  This routine also updates the
    IrpContext based on the state of the top-level context.

    If the TOP_LEVEL flag in the IrpContext is already set when we are called
    then we force this request to appear top level.

Arguments:

    ThreadContext - Address on stack for local storage if not already present.

    ForceTopLevel - We force this request to appear top level regardless of
        any previous stack value.

Return Value:

    None

--*/

{
    PTHREAD_CONTEXT CurrentThreadContext;
    ULONG_PTR StackTop;
    ULONG_PTR StackBottom;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );

    //
    //  Get the current top-level irp out of the thread storage.
    //  If NULL then this is the top-level request.
    //

    CurrentThreadContext = (PTHREAD_CONTEXT) IoGetTopLevelIrp();

    if (CurrentThreadContext == NULL) {

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL );
    }

    //
    //  Initialize the input context unless we are using the current
    //  thread context block.  We use the new block if our caller
    //  specified this or the existing block is invalid.
    //
    //  The following must be true for the current to be a valid Cdfs context.
    //
    //      Structure must lie within current stack.
    //      Address must be ULONG aligned.
    //      Cdfs signature must be present.
    //
    //  If this is not a valid Cdfs context then use the input thread
    //  context and store it in the top level context.
    //

    IoGetStackLimits( &StackTop, &StackBottom);

    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL ) ||
        (((ULONG_PTR) CurrentThreadContext > StackBottom - sizeof( THREAD_CONTEXT )) ||
         ((ULONG_PTR) CurrentThreadContext <= StackTop) ||
         FlagOn( (ULONG_PTR) CurrentThreadContext, 0x3 ) ||
         (CurrentThreadContext->Cdfs != 0x53464443))) {

        ThreadContext->Cdfs = 0x53464443;
        ThreadContext->SavedTopLevelIrp = (PIRP) CurrentThreadContext;
        ThreadContext->TopLevelIrpContext = IrpContext;
        IoSetTopLevelIrp( (PIRP) ThreadContext );

        IrpContext->TopLevel = IrpContext;
        IrpContext->ThreadContext = ThreadContext;

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL_CDFS );

    //
    //  Otherwise use the IrpContext in the thread context.
    //

    } else {

        IrpContext->TopLevel = CurrentThreadContext->TopLevelIrpContext;
    }

    return;
}


BOOLEAN
CdFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine checks if fast i/o is possible for a read/write operation

Arguments:

    FileObject - Supplies the file object used in the query

    FileOffset - Supplies the starting byte offset for the read/write operation

    Length - Supplies the length, in bytes, of the read/write operation

    Wait - Indicates if we can wait

    LockKey - Supplies the lock key

    CheckForReadOperation - Indicates if this is a check for a read or write
        operation

    IoStatus - Receives the status of the operation if our return value is
        FastIoReturnError

Return Value:

    BOOLEAN - TRUE if fast I/O is possible and FALSE if the caller needs
        to take the long route.

--*/

{
    PFCB Fcb;
    TYPE_OF_OPEN TypeOfOpen;
    LARGE_INTEGER LargeLength;

    PAGED_CODE();

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    if ((TypeOfOpen != UserFileOpen) || !CheckForReadOperation) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    LargeLength.QuadPart = Length;

    //
    //  Check whether the file locks will allow for fast io.
    //

    if ((Fcb->FileLock == NULL) ||
        FsRtlFastCheckLockForRead( Fcb->FileLock,
                                   FileOffset,
                                   &LargeLength,
                                   LockKey,
                                   FileObject,
                                   PsGetCurrentProcess() )) {

        return TRUE;
    }

    return FALSE;
}


ULONG
CdSerial32 (
    IN PCHAR Buffer,
    IN ULONG ByteCount
    )
/*++

Routine Description:

    This routine is called to generate a 32 bit serial number.  This is
    done by doing four separate checksums into an array of bytes and
    then treating the bytes as a ULONG.

Arguments:

    Buffer - Pointer to the buffer to generate the ID for.

    ByteCount - Number of bytes in the buffer.

Return Value:

    ULONG - The 32 bit serial number.

--*/

{
    union {
        UCHAR   Bytes[4];
        ULONG   SerialId;
    } Checksum;

    PAGED_CODE();

    //
    //  Initialize the serial number.
    //

    Checksum.SerialId = 0;

    //
    //  Continue while there are more bytes to use.
    //

    while (ByteCount--) {

        //
        //  Increment this sub-checksum.
        //

        Checksum.Bytes[ByteCount & 0x3] += *(Buffer++);
    }

    //
    //  Return the checksums as a ULONG.
    //

    return Checksum.SerialId;
}


// @@BEGIN_DDKSPLIT

#ifdef CD_TRACE

ULONG CdDebugTraceLevel = 0;
BOOLEAN CdTraceProcess = FALSE;
LONG CdDebugTraceIndent = 0;

#define Min(a,b) (((a)<(b)) ? (a) : (b))
#include <stdio.h>

BOOLEAN
CdDebugTrace (
    ULONG TraceMask,
    PCHAR Format,
    ...
    )

/*++

Routine Description:

    This routine is a simple debug info printer that returns a constant boolean value.  This
    makes it possible to splice it into the middle of boolean expressions to discover which
    elements are firing.
    
    We will use this as our general debug printer.  See udfdata.h for how we use the DebugTrace
    macro to accomplish the effect.
    
Arguments:

    IndentIncrement - amount to change the indentation by.
    
    TraceMask - specification of what debug trace level this call should be noisy at.

Return Value:

    USHORT - The 16bit CRC

--*/

{
    va_list Arglist;
    LONG i;
    UCHAR Buffer[256];
    UCHAR *Pb;
    int Bytes;
    int ThreadChars;

    if (TraceMask == 0 || (CdDebugTraceLevel & TraceMask) != 0) {

        if (CdTraceProcess)  {
            
            ThreadChars = sprintf(Buffer, "%p.%p ", PsGetCurrentProcess(), PsGetCurrentThread());
        }
        else {
            
            ThreadChars = sprintf(Buffer, "%p ", PsGetCurrentThread());
        }

        //
        // Format the output into a buffer and then print it.
        //

        va_start( Arglist, Format );
        Bytes = _vsnprintf( Buffer + ThreadChars, sizeof(Buffer) - ThreadChars, Format, Arglist );
        va_end( Arglist );

        //
        // detect buffer overflow
        //

        if (Bytes == -1) {

            Buffer[sizeof(Buffer) - 1] = '\n';
        }

        DbgPrint( Buffer );
    }

    return TRUE;
}

#endif

// @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\cdinit.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    CdInit.c

Abstract:

    This module implements the DRIVER_INITIALIZATION routine for Cdfs

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_CDINIT)

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
CdUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
CdInitializeGlobalData (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FileSystemDeviceObject
    );

NTSTATUS
CdShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, CdUnload)
#pragma alloc_text(PAGE, CdShutdown)
#pragma alloc_text(INIT, CdInitializeGlobalData)
#endif


//
//  Local support routine
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the initialization routine for the Cdrom file system
    device driver.  This routine creates the device object for the FileSystem
    device and performs all other driver initialization.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    NTSTATUS - The function value is the final status from the initialization
        operation.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    PDEVICE_OBJECT CdfsFileSystemDeviceObject;

    //
    // Create the device object.
    //

    RtlInitUnicodeString( &UnicodeString, L"\\Cdfs" );

    Status = IoCreateDevice( DriverObject,
                             0,
                             &UnicodeString,
                             FILE_DEVICE_CD_ROM_FILE_SYSTEM,
                             0,
                             FALSE,
                             &CdfsFileSystemDeviceObject );

    if (!NT_SUCCESS( Status )) {
        return Status;
    }
    DriverObject->DriverUnload = CdUnload;
    //
    //  Note that because of the way data caching is done, we set neither
    //  the Direct I/O or Buffered I/O bit in DeviceObject->Flags.  If
    //  data is not in the cache, or the request is not buffered, we may,
    //  set up for Direct I/O by hand.
    //

    //
    //  Initialize the driver object with this driver's entry points.
    //
    //  NOTE - Each entry in the dispatch table must have an entry in
    //  the Fsp/Fsd dispatch switch statements.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE]                  =
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   =
    DriverObject->MajorFunction[IRP_MJ_READ]                    =
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION]       =
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]         =
    DriverObject->MajorFunction[IRP_MJ_QUERY_VOLUME_INFORMATION]=
    DriverObject->MajorFunction[IRP_MJ_DIRECTORY_CONTROL]       =
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL]     =
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          =
    DriverObject->MajorFunction[IRP_MJ_LOCK_CONTROL]            =
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]                 =
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = (PDRIVER_DISPATCH) CdFsdDispatch;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN]                = CdShutdown;

    DriverObject->FastIoDispatch = &CdFastIoDispatch;

    Status = IoRegisterShutdownNotification (CdfsFileSystemDeviceObject);
    if (!NT_SUCCESS (Status)) {
        IoDeleteDevice (CdfsFileSystemDeviceObject);
        return Status;
    }

    //
    //  Initialize the global data structures
    //

    Status = CdInitializeGlobalData( DriverObject, CdfsFileSystemDeviceObject );
    if (!NT_SUCCESS (Status)) {
        IoDeleteDevice (CdfsFileSystemDeviceObject);
        return Status;
    }

    //
    //  Register the file system as low priority with the I/O system.  This will cause
    //  CDFS to receive mount requests after a) other filesystems currently registered
    //  and b) other normal priority filesystems that may be registered later.
    //

    CdfsFileSystemDeviceObject->Flags |= DO_LOW_PRIORITY_FILESYSTEM;

    IoRegisterFileSystem( CdfsFileSystemDeviceObject );
    ObReferenceObject (CdfsFileSystemDeviceObject);

    //
    //  And return to our caller
    //

    return( STATUS_SUCCESS );
}

NTSTATUS
CdShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is the shutdown handler for CDFS.

Arguments:

    DeviceObject - Supplies the registered device object for CDFS.
    Irp - Shutdown IRP
    

Return Value:

    None.

--*/
{
    IoUnregisterFileSystem (DeviceObject);
    IoDeleteDevice (CdData.FileSystemDeviceObject);

    CdCompleteRequest( NULL, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


VOID
CdUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine unload routine for CDFS.

Arguments:

    DriverObject - Supplies the driver object for CDFS.

Return Value:

    None.

--*/
{
    PIRP_CONTEXT IrpContext;

    //
    // Free any IRP contexts
    //
    while (1) {
        IrpContext = (PIRP_CONTEXT) PopEntryList( &CdData.IrpContextList) ;
        if (IrpContext == NULL) {
            break;
        }
        CdFreePool(&IrpContext);
    }

    IoFreeWorkItem (CdData.CloseItem);
    ExDeleteResourceLite( &CdData.DataResource );
    ObDereferenceObject (CdData.FileSystemDeviceObject);
}

//
//  Local support routine
//

NTSTATUS
CdInitializeGlobalData (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT FileSystemDeviceObject
    )

/*++

Routine Description:

    This routine initializes the global cdfs data structures.

Arguments:

    DriverObject - Supplies the driver object for CDFS.

    FileSystemDeviceObject - Supplies the device object for CDFS.

Return Value:

    None.

--*/

{
    //
    //  Start by initializing the FastIoDispatch Table.
    //

    RtlZeroMemory( &CdFastIoDispatch, sizeof( FAST_IO_DISPATCH ));

    CdFastIoDispatch.SizeOfFastIoDispatch =    sizeof(FAST_IO_DISPATCH);
    CdFastIoDispatch.FastIoCheckIfPossible =   CdFastIoCheckIfPossible;  //  CheckForFastIo
    CdFastIoDispatch.FastIoRead =              FsRtlCopyRead;            //  Read
    CdFastIoDispatch.FastIoQueryBasicInfo =    CdFastQueryBasicInfo;     //  QueryBasicInfo
    CdFastIoDispatch.FastIoQueryStandardInfo = CdFastQueryStdInfo;       //  QueryStandardInfo
    CdFastIoDispatch.FastIoLock =              CdFastLock;               //  Lock
    CdFastIoDispatch.FastIoUnlockSingle =      CdFastUnlockSingle;       //  UnlockSingle
    CdFastIoDispatch.FastIoUnlockAll =         CdFastUnlockAll;          //  UnlockAll
    CdFastIoDispatch.FastIoUnlockAllByKey =    CdFastUnlockAllByKey;     //  UnlockAllByKey
    CdFastIoDispatch.AcquireFileForNtCreateSection =  CdAcquireForCreateSection;
    CdFastIoDispatch.ReleaseFileForNtCreateSection =  CdReleaseForCreateSection;
    CdFastIoDispatch.FastIoQueryNetworkOpenInfo =     CdFastQueryNetworkInfo;   //  QueryNetworkInfo
    
    CdFastIoDispatch.MdlRead = FsRtlMdlReadDev;
    CdFastIoDispatch.MdlReadComplete = FsRtlMdlReadCompleteDev;
    CdFastIoDispatch.PrepareMdlWrite = FsRtlPrepareMdlWriteDev;
    CdFastIoDispatch.MdlWriteComplete = FsRtlMdlWriteCompleteDev;

    //
    //  Initialize the CdData structure.
    //

    RtlZeroMemory( &CdData, sizeof( CD_DATA ));

    CdData.NodeTypeCode = CDFS_NTC_DATA_HEADER;
    CdData.NodeByteSize = sizeof( CD_DATA );

    CdData.DriverObject = DriverObject;
    CdData.FileSystemDeviceObject = FileSystemDeviceObject;

    InitializeListHead( &CdData.VcbQueue );

    ExInitializeResourceLite( &CdData.DataResource );

    //
    //  Initialize the cache manager callback routines
    //

    CdData.CacheManagerCallbacks.AcquireForLazyWrite  = &CdAcquireForCache;
    CdData.CacheManagerCallbacks.ReleaseFromLazyWrite = &CdReleaseFromCache;
    CdData.CacheManagerCallbacks.AcquireForReadAhead  = &CdAcquireForCache;
    CdData.CacheManagerCallbacks.ReleaseFromReadAhead = &CdReleaseFromCache;

    CdData.CacheManagerVolumeCallbacks.AcquireForLazyWrite  = &CdNoopAcquire;
    CdData.CacheManagerVolumeCallbacks.ReleaseFromLazyWrite = &CdNoopRelease;
    CdData.CacheManagerVolumeCallbacks.AcquireForReadAhead  = &CdNoopAcquire;
    CdData.CacheManagerVolumeCallbacks.ReleaseFromReadAhead = &CdNoopRelease;

    //
    //  Initialize the lock mutex and the async and delay close queues.
    //

    ExInitializeFastMutex( &CdData.CdDataMutex );
    InitializeListHead( &CdData.AsyncCloseQueue );
    InitializeListHead( &CdData.DelayedCloseQueue );

    CdData.CloseItem = IoAllocateWorkItem (FileSystemDeviceObject);
    if (CdData.CloseItem == NULL) {
        
        ExDeleteResourceLite( &CdData.DataResource );
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    //  Do the initialization based on the system size.
    //

    switch (MmQuerySystemSize()) {

    case MmSmallSystem:

        CdData.IrpContextMaxDepth = 4;
        CdData.MaxDelayedCloseCount = 8;
        CdData.MinDelayedCloseCount = 2;
        break;

    case MmMediumSystem:

        CdData.IrpContextMaxDepth = 8;
        CdData.MaxDelayedCloseCount = 24;
        CdData.MinDelayedCloseCount = 6;
        break;

    case MmLargeSystem:

        CdData.IrpContextMaxDepth = 32;
        CdData.MaxDelayedCloseCount = 72;
        CdData.MinDelayedCloseCount = 18;
        break;
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\cdprocs.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    CdProcs.h

Abstract:

    This module defines all of the globally used procedures in the Cdfs
    file system.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _CDPROCS_
#define _CDPROCS_

#include <ntifs.h>

#include <ntddcdrm.h>
#include <ntdddisk.h>
#include <ntddscsi.h>

#ifndef INLINE
#define INLINE __inline
#endif

#include "nodetype.h"
#include "Cd.h"
#include "CdStruc.h"
#include "CdData.h"


//**** x86 compiler bug ****

#if defined(_M_IX86)
#undef Int64ShraMod32
#define Int64ShraMod32(a, b) ((LONGLONG)(a) >> (b))
#endif

//
//  Here are the different pool tags.
//

#define TAG_CCB                 'ccdC'      //  Ccb
#define TAG_CDROM_TOC           'ctdC'      //  TOC
#define TAG_DIRENT_NAME         'nddC'      //  CdName in dirent
#define TAG_ENUM_EXPRESSION     'eedC'      //  Search expression for enumeration
#define TAG_FCB_DATA            'dfdC'      //  Data Fcb
#define TAG_FCB_INDEX           'ifdC'      //  Index Fcb
#define TAG_FCB_NONPAGED        'nfdC'      //  Nonpaged Fcb
#define TAG_FCB_TABLE           'tfdC'      //  Fcb Table entry
#define TAG_FILE_NAME           'nFdC'      //  Filename buffer
#define TAG_GEN_SHORT_NAME      'sgdC'      //  Generated short name
#define TAG_IO_BUFFER           'fbdC'      //  Temporary IO buffer
#define TAG_IO_CONTEXT          'oidC'      //  Io context for async reads
#define TAG_IRP_CONTEXT         'cidC'      //  Irp Context
#define TAG_IRP_CONTEXT_LITE    'lidC'      //  Irp Context lite
#define TAG_MCB_ARRAY           'amdC'      //  Mcb array
#define TAG_PATH_ENTRY_NAME     'nPdC'      //  CdName in path entry
#define TAG_PREFIX_ENTRY        'epdC'      //  Prefix Entry
#define TAG_PREFIX_NAME         'npdC'      //  Prefix Entry name
#define TAG_SPANNING_PATH_TABLE 'psdC'      //  Buffer for spanning path table
#define TAG_UPCASE_NAME         'nudC'      //  Buffer for upcased name
#define TAG_VOL_DESC            'dvdC'      //  Buffer for volume descriptor
#define TAG_VPB                 'pvdC'      //  Vpb allocated in filesystem

//
//  Tag all of our allocations if tagging is turned on
//

#ifdef POOL_TAGGING

#undef FsRtlAllocatePool
#undef FsRtlAllocatePoolWithQuota
#define FsRtlAllocatePool(a,b) FsRtlAllocatePoolWithTag(a,b,'sfdC')
#define FsRtlAllocatePoolWithQuota(a,b) FsRtlAllocatePoolWithQuotaTag(a,b,'sfdC')

#endif // POOL_TAGGING

// @@BEGIN_DDKSPLIT

#ifdef CD_TRACE

#include <stdarg.h>

BOOLEAN
CdDebugTrace (
    ULONG TraceMask,
    PCHAR Format,
    ...
    );

#define DebugTrace(x) CdDebugTrace x

#else

#define DebugTrace(x)

#endif

// @@END_DDKSPLIT

//
//  File access check routine, implemented in AcChkSup.c
//

//
//  BOOLEAN
//  CdIllegalFcbAccess (
//      IN PIRP_CONTEXT IrpContext,
//      IN TYPE_OF_OPEN TypeOfOpen,
//      IN ACCESS_MASK DesiredAccess
//      );
//

#define CdIllegalFcbAccess(IC,T,DA) (                           \
           BooleanFlagOn( (DA),                                 \
                          ((T) != UserVolumeOpen ?              \
                           (FILE_WRITE_ATTRIBUTES           |   \
                            FILE_WRITE_DATA                 |   \
                            FILE_WRITE_EA                   |   \
                            FILE_ADD_FILE                   |   \
                            FILE_ADD_SUBDIRECTORY           |   \
                            FILE_APPEND_DATA) : 0)          |   \
                          FILE_DELETE_CHILD                 |   \
                          DELETE                            |   \
                          WRITE_DAC ))


//
//  Allocation support routines, implemented in AllocSup.c
//
//  These routines are for querying allocation on individual streams.
//

VOID
CdLookupAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG FileOffset,
    OUT PLONGLONG DiskOffset,
    OUT PULONG ByteCount
    );

VOID
CdAddAllocationFromDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG McbEntryOffset,
    IN LONGLONG StartingFileOffset,
    IN PDIRENT Dirent
    );

VOID
CdAddInitialAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG StartingBlock,
    IN LONGLONG DataLength
    );

VOID
CdTruncateAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingFileOffset
    );

VOID
CdInitializeMcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
CdUninitializeMcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );


//
//   Buffer control routines for data caching, implemented in CacheSup.c
//

VOID
CdCreateInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb
    );

VOID
CdDeleteInternalStream (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

NTSTATUS
CdCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdPurgeVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN DismountUnderway
    );

//
//  VOID
//  CdUnpinData (
//      IN PIRP_CONTEXT IrpContext,
//      IN OUT PBCB *Bcb
//      );
//

#define CdUnpinData(IC,B)   \
    if (*(B) != NULL) { CcUnpinData( *(B) ); *(B) = NULL; }


//
//  Device I/O routines, implemented in DevIoSup.c
//
//  These routines perform the actual device read and writes.  They only affect
//  the on disk structure and do not alter any other data structures.
//

NTSTATUS
CdNonCachedRead (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount
    );

NTSTATUS
CdNonCachedXARead (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount
    );

BOOLEAN
CdReadSectors (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN BOOLEAN RaiseOnError,
    IN OUT PVOID Buffer,
    IN PDEVICE_OBJECT TargetDeviceObject
    );

NTSTATUS
CdCreateUserMdl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BufferLength,
    IN BOOLEAN RaiseOnError
    );

NTSTATUS
CdPerformDevIoCtrl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT Device,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN BOOLEAN OverrideVerify,
    OUT PIO_STATUS_BLOCK Iosb OPTIONAL
    );

//
//  VOID
//  CdMapUserBuffer (
//      IN PIRP_CONTEXT IrpContext
//      OUT PVOID UserBuffer
//      );
//
//  Returns pointer to sys address.  Will raise on failure.
//
//
//  VOID
//  CdLockUserBuffer (
//      IN PIRP_CONTEXT IrpContext,
//      IN ULONG BufferLength
//      );
//

#define CdMapUserBuffer(IC, UB) {                                               \
            *(UB) = (PVOID) ( ((IC)->Irp->MdlAddress == NULL) ?                 \
                    (IC)->Irp->UserBuffer :                                     \
                    (MmGetSystemAddressForMdlSafe( (IC)->Irp->MdlAddress, NormalPagePriority)));   \
            if (NULL == *(UB))  {                         \
                CdRaiseStatus( (IC), STATUS_INSUFFICIENT_RESOURCES);            \
            }                                                                   \
        }                                                                       
        

#define CdLockUserBuffer(IC,BL) {                   \
    if ((IC)->Irp->MdlAddress == NULL) {            \
        (VOID) CdCreateUserMdl( (IC), (BL), TRUE ); \
    }                                               \
}


//
//  Dirent support routines, implemented in DirSup.c
//

VOID
CdLookupDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG DirentOffset,
    OUT PDIRENT_ENUM_CONTEXT DirContext
    );

BOOLEAN
CdLookupNextDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIRENT_ENUM_CONTEXT CurrentDirContext,
    OUT PDIRENT_ENUM_CONTEXT NextDirContext
    );

VOID
CdUpdateDirentFromRawDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIRENT_ENUM_CONTEXT DirContext,
    IN OUT PDIRENT Dirent
    );

VOID
CdUpdateDirentName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PDIRENT Dirent,
    IN ULONG IgnoreCase
    );

BOOLEAN
CdFindFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN OUT PFILE_ENUM_CONTEXT FileContext,
    OUT PCD_NAME *MatchingName
    );

BOOLEAN
CdFindDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN OUT PFILE_ENUM_CONTEXT FileContext
    );

BOOLEAN
CdFindFileByShortName (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN ULONG ShortNameDirentOffset,
    IN OUT PFILE_ENUM_CONTEXT FileContext
    );

BOOLEAN
CdLookupNextInitialFileDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_ENUM_CONTEXT FileContext
    );

VOID
CdLookupLastFileDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_ENUM_CONTEXT FileContext
    );

VOID
CdCleanupFileContext (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_ENUM_CONTEXT FileContext
    );

//
//  VOID
//  CdInitializeFileContext (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFILE_ENUM_CONTEXT FileContext
//      );
//
//
//  VOID
//  CdInitializeDirent (
//      IN PIRP_CONTEXT IrpContext,
//      IN PDIRENT Dirent
//      );
//
//  VOID
//  CdInitializeDirContext (
//      IN PIRP_CONTEXT IrpContext,
//      IN PDIRENT_ENUM_CONTEXT DirContext
//      );
//
//  VOID
//  CdCleanupDirent (
//      IN PIRP_CONTEXT IrpContext,
//      IN PDIRENT Dirent
//      );
//
//  VOID
//  CdCleanupDirContext (
//      IN PIRP_CONTEXT IrpContext,
//      IN PDIRENT_ENUM_CONTEXT DirContext
//      );
//
//  VOID
//  CdLookupInitialFileDirent (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN PFILE_ENUM_CONTEXT FileContext,
//      IN ULONG DirentOffset
//      );
//

#define CdInitializeFileContext(IC,FC) {                                \
    RtlZeroMemory( FC, sizeof( FILE_ENUM_CONTEXT ));                    \
    (FC)->PriorDirent = &(FC)->Dirents[0];                              \
    (FC)->InitialDirent = &(FC)->Dirents[1];                            \
    (FC)->CurrentDirent = &(FC)->Dirents[2];                            \
    (FC)->ShortName.FileName.MaximumLength = BYTE_COUNT_8_DOT_3;        \
    (FC)->ShortName.FileName.Buffer = (FC)->ShortNameBuffer;            \
}

#define CdInitializeDirent(IC,D)                                \
    RtlZeroMemory( D, sizeof( DIRENT ))

#define CdInitializeDirContext(IC,DC)                           \
    RtlZeroMemory( DC, sizeof( DIRENT_ENUM_CONTEXT ))

#define CdCleanupDirent(IC,D)  {                                \
    if (FlagOn( (D)->Flags, DIRENT_FLAG_ALLOC_BUFFER )) {       \
        CdFreePool( &(D)->CdFileName.FileName.Buffer );          \
    }                                                           \
}

#define CdCleanupDirContext(IC,DC)                              \
    CdUnpinData( (IC), &(DC)->Bcb )

#define CdLookupInitialFileDirent(IC,F,FC,DO)                       \
    CdLookupDirent( IC,                                             \
                    F,                                              \
                    DO,                                             \
                    &(FC)->InitialDirent->DirContext );             \
    CdUpdateDirentFromRawDirent( IC,                                \
                                 F,                                 \
                                 &(FC)->InitialDirent->DirContext,  \
                                 &(FC)->InitialDirent->Dirent )


//
//  The following routines are used to manipulate the fscontext fields
//  of the file object, implemented in FilObSup.c
//

//
//  Type of opens.  FilObSup.c depends on this order.
//

typedef enum _TYPE_OF_OPEN {

    UnopenedFileObject = 0,
    StreamFileOpen,
    UserVolumeOpen,
    UserDirectoryOpen,
    UserFileOpen,
    BeyondValidType

} TYPE_OF_OPEN;
typedef TYPE_OF_OPEN *PTYPE_OF_OPEN;

VOID
CdSetFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PFCB Fcb OPTIONAL,
    IN PCCB Ccb OPTIONAL
    );

TYPE_OF_OPEN
CdDecodeFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb,
    OUT PCCB *Ccb
    );

TYPE_OF_OPEN
CdFastDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb
    );


//
//  Name support routines, implemented in NameSup.c
//

VOID
CdConvertNameToCdName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PCD_NAME CdName
    );

VOID
CdConvertBigToLittleEndian (
    IN PIRP_CONTEXT IrpContext,
    IN PCHAR BigEndian,
    IN ULONG ByteCount,
    OUT PCHAR LittleEndian
    );

VOID
CdUpcaseName (
    IN PIRP_CONTEXT IrpContext,
    IN PCD_NAME Name,
    IN OUT PCD_NAME UpcaseName
    );

VOID
CdDissectName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PUNICODE_STRING RemainingName,
    OUT PUNICODE_STRING FinalName
    );

BOOLEAN
CdIs8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING FileName
    );

VOID
CdGenerate8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING FileName,
    IN ULONG DirentOffset,
    OUT PWCHAR ShortFileName,
    OUT PUSHORT ShortByteCount
    );

BOOLEAN
CdIsNameInExpression (
    IN PIRP_CONTEXT IrpContext,
    IN PCD_NAME CurrentName,
    IN PCD_NAME SearchExpression,
    IN ULONG  WildcardFlags,
    IN BOOLEAN CheckVersion
    );

ULONG
CdShortNameDirentOffset (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name
    );

FSRTL_COMPARISON_RESULT
CdFullCompareNames (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING NameA,
    IN PUNICODE_STRING NameB
    );


//
//  Filesystem control operations.  Implemented in Fsctrl.c
//

NTSTATUS
CdLockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    );

NTSTATUS
CdUnlockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    );


//
//  Path table enumeration routines.  Implemented in PathSup.c
//

VOID
CdLookupPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG PathEntryOffset,
    IN ULONG Ordinal,
    IN BOOLEAN VerifyBounds,
    IN OUT PCOMPOUND_PATH_ENTRY CompoundPathEntry
    );

BOOLEAN
CdLookupNextPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PPATH_ENUM_CONTEXT PathContext,
    IN OUT PPATH_ENTRY PathEntry
    );

BOOLEAN
CdFindPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb,
    IN PCD_NAME DirName,
    IN BOOLEAN IgnoreCase,
    IN OUT PCOMPOUND_PATH_ENTRY CompoundPathEntry
    );

VOID
CdUpdatePathEntryName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PPATH_ENTRY PathEntry,
    IN BOOLEAN IgnoreCase
    );

//
//  VOID
//  CdInitializeCompoundPathEntry (
//      IN PIRP_CONTEXT IrpContext,
//      IN PCOMPOUND_PATH_ENTRY CompoundPathEntry
//      );
//
//  VOID
//  CdCleanupCompoundPathEntry (
//      IN PIRP_CONTEXT IrpContext,
//      IN PCOMPOUND_PATH_ENTRY CompoundPathEntry
//      );
//

#define CdInitializeCompoundPathEntry(IC,CP)                                    \
    RtlZeroMemory( CP, sizeof( COMPOUND_PATH_ENTRY ))

#define CdCleanupCompoundPathEntry(IC,CP)     {                                 \
    CdUnpinData( (IC), &(CP)->PathContext.Bcb );                                \
    if ((CP)->PathContext.AllocatedData) {                                      \
        CdFreePool( &(CP)->PathContext.Data );                                   \
    }                                                                           \
    if (FlagOn( (CP)->PathEntry.Flags, PATH_ENTRY_FLAG_ALLOC_BUFFER )) {        \
        CdFreePool( &(CP)->PathEntry.CdDirName.FileName.Buffer );                \
    }                                                                           \
}


//
//  Largest matching prefix searching routines, implemented in PrefxSup.c
//

VOID
CdInsertPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortNameMatch,
    IN PFCB ParentFcb
    );

VOID
CdRemovePrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
CdFindPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB *CurrentFcb,
    IN OUT PUNICODE_STRING RemainingName,
    IN BOOLEAN IgnoreCase
    );


//
//  Synchronization routines.  Implemented in Resrcsup.c
//
//  The following routines/macros are used to synchronize the in-memory structures.
//
//      Routine/Macro               Synchronizes                            Subsequent
//
//      CdAcquireCdData             Volume Mounts/Dismounts,Vcb Queue       CdReleaseCdData
//      CdAcquireVcbExclusive       Vcb for open/close                      CdReleaseVcb
//      CdAcquireVcbShared          Vcb for open/close                      CdReleaseVcb
//      CdAcquireAllFiles           Locks out operations to all files       CdReleaseAllFiles
//      CdAcquireFileExclusive      Locks out file operations               CdReleaseFile
//      CdAcquireFileShared         Files for file operations               CdReleaseFile
//      CdAcquireFcbExclusive       Fcb for open/close                      CdReleaseFcb
//      CdAcquireFcbShared          Fcb for open/close                      CdReleaseFcb
//      CdLockCdData                Fields in CdData                        CdUnlockCdData
//      CdLockVcb                   Vcb fields, FcbReference, FcbTable      CdUnlockVcb
//      CdLockFcb                   Fcb fields, prefix table, Mcb           CdUnlockFcb
//

typedef enum _TYPE_OF_ACQUIRE {
    
    AcquireExclusive,
    AcquireShared,
    AcquireSharedStarveExclusive

} TYPE_OF_ACQUIRE, *PTYPE_OF_ACQUIRE;

BOOLEAN
CdAcquireResource (
    IN PIRP_CONTEXT IrpContext,
    IN PERESOURCE Resource,
    IN BOOLEAN IgnoreWait,
    IN TYPE_OF_ACQUIRE Type
    );

//
//  BOOLEAN
//  CdAcquireCdData (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdReleaseCdData (
//      IN PIRP_CONTEXT IrpContext
//    );
//
//  BOOLEAN
//  CdAcquireVcbExclusive (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  BOOLEAN
//  CdAcquireVcbShared (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  VOID
//  CdReleaseVcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb
//      );
//
//  VOID
//  CdAcquireAllFiles (
//      IN PIRP_CONTEXT,
//      IN PVCB Vcb
//      );
//
//  VOID
//  CdReleaseAllFiles (
//      IN PIRP_CONTEXT,
//      IN PVCB Vcb
//      );
//
//  VOID
//  CdAcquireFileExclusive (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      );
//
//  VOID
//  CdAcquireFileShared (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  CdReleaseFile (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//    );
//
//  BOOLEAN
//  CdAcquireFcbExclusive (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  BOOLEAN
//  CdAcquireFcbShared (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN BOOLEAN IgnoreWait
//      );
//
//  BOOLEAN
//  CdReleaseFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  CdLockCdData (
//      );
//
//  VOID
//  CdUnlockCdData (
//      );
//
//  VOID
//  CdLockVcb (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdUnlockVcb (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdLockFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  CdUnlockFcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//

#define CdAcquireCdData(IC)                                                             \
    ExAcquireResourceExclusiveLite( &CdData.DataResource, TRUE )

#define CdReleaseCdData(IC)                                                             \
    ExReleaseResourceLite( &CdData.DataResource )

#define CdAcquireVcbExclusive(IC,V,I)                                                   \
    CdAcquireResource( (IC), &(V)->VcbResource, (I), AcquireExclusive )

#define CdAcquireVcbShared(IC,V,I)                                                      \
    CdAcquireResource( (IC), &(V)->VcbResource, (I), AcquireShared )

#define CdReleaseVcb(IC,V)                                                              \
    ExReleaseResourceLite( &(V)->VcbResource )

#define CdAcquireAllFiles(IC,V)                                                         \
    CdAcquireResource( (IC), &(V)->FileResource, FALSE, AcquireExclusive )

#define CdReleaseAllFiles(IC,V)                                                         \
    ExReleaseResourceLite( &(V)->FileResource )

#define CdAcquireFileExclusive(IC,F)                                                    \
    CdAcquireResource( (IC), (F)->Resource, FALSE, AcquireExclusive )

#define CdAcquireFileShared(IC,F)                                                       \
    CdAcquireResource( (IC), (F)->Resource, FALSE, AcquireShared )

#define CdAcquireFileSharedStarveExclusive(IC,F)                                        \
    CdAcquireResource( (IC), (F)->Resource, FALSE, AcquireSharedStarveExclusive )

#define CdReleaseFile(IC,F)                                                             \
    ExReleaseResourceLite( (F)->Resource )

#define CdAcquireFcbExclusive(IC,F,I)                                                   \
    CdAcquireResource( (IC), &(F)->FcbNonpaged->FcbResource, (I), AcquireExclusive )

#define CdAcquireFcbShared(IC,F,I)                                                      \
    CdAcquireResource( (IC), &(F)->FcbNonpaged->FcbResource, (I), AcquireShared )

#define CdReleaseFcb(IC,F)                                                              \
    ExReleaseResourceLite( &(F)->FcbNonpaged->FcbResource )

#define CdLockCdData()                                                                  \
    ExAcquireFastMutex( &CdData.CdDataMutex );                                          \
    CdData.CdDataLockThread = PsGetCurrentThread()

#define CdUnlockCdData()                                                                \
    CdData.CdDataLockThread = NULL;                                                     \
    ExReleaseFastMutex( &CdData.CdDataMutex )

#define CdLockVcb(IC,V)                                                                 \
    ExAcquireFastMutex( &(V)->VcbMutex );                                               \
    ASSERT( NULL == (V)->VcbLockThread);                                                \
    (V)->VcbLockThread = PsGetCurrentThread()

#define CdUnlockVcb(IC,V)                                                               \
    ASSERT( NULL != (V)->VcbLockThread);                                                \
    (V)->VcbLockThread = NULL;                                                          \
    ExReleaseFastMutex( &(V)->VcbMutex )

#define CdLockFcb(IC,F) {                                                               \
    PVOID _CurrentThread = PsGetCurrentThread();                                        \
    if (_CurrentThread != (F)->FcbLockThread) {                                         \
        ExAcquireFastMutex( &(F)->FcbNonpaged->FcbMutex );                              \
        ASSERT( (F)->FcbLockCount == 0 );                                               \
        (F)->FcbLockThread = _CurrentThread;                                            \
    }                                                                                   \
    (F)->FcbLockCount += 1;                                                             \
}

#define CdUnlockFcb(IC,F) {                                                             \
    (F)->FcbLockCount -= 1;                                                             \
    if ((F)->FcbLockCount == 0) {                                                       \
        (F)->FcbLockThread = NULL;                                                      \
        ExReleaseFastMutex( &(F)->FcbNonpaged->FcbMutex );                              \
    }                                                                                   \
}

BOOLEAN
CdNoopAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    );

VOID
CdNoopRelease (
    IN PVOID Fcb
    );

BOOLEAN
CdAcquireForCache (
    IN PFCB Fcb,
    IN BOOLEAN Wait
    );

VOID
CdReleaseFromCache (
    IN PFCB Fcb
    );

VOID
CdAcquireForCreateSection (
    IN PFILE_OBJECT FileObject
    );

VOID
CdReleaseForCreateSection (
    IN PFILE_OBJECT FileObject
    );


//
//  In-memory structure support routines.  Implemented in StrucSup.c
//

VOID
CdInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb,
    IN PCDROM_TOC CdromToc,
    IN ULONG TocLength,
    IN ULONG TocTrackCount,
    IN ULONG TocDiskFlags,
    IN ULONG BlockFactor,
    IN ULONG MediaChangeCount
    );

VOID
CdUpdateVcbFromVolDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PCHAR RawIsoVd OPTIONAL
    );

VOID
CdDeleteVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    );

PFCB
CdCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN FILE_ID FileId,
    IN NODE_TYPE_CODE NodeTypeCode,
    OUT PBOOLEAN FcbExisted OPTIONAL
    );

VOID
CdInitializeFcbFromPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB ParentFcb OPTIONAL,
    IN PPATH_ENTRY PathEntry
    );

VOID
CdInitializeFcbFromFileContext (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB ParentFcb OPTIONAL,
    IN PFILE_ENUM_CONTEXT FileContext
    );

PCCB
CdCreateCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Flags
    );

VOID
CdDeleteCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb
    );

BOOLEAN
CdCreateFileLock (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb,
    IN BOOLEAN RaiseOnError
    );

VOID
CdDeleteFileLock (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_LOCK FileLock
    );

PIRP_CONTEXT
CdCreateIrpContext (
    IN PIRP Irp,
    IN BOOLEAN Wait
    );

VOID
CdCleanupIrpContext (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN Post
    );

VOID
CdInitializeStackIrpContext (
    OUT PIRP_CONTEXT IrpContext,
    IN PIRP_CONTEXT_LITE IrpContextLite
    );

//
//  PIRP_CONTEXT_LITE
//  CdCreateIrpContextLite (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdFreeIrpContextLite (
//      IN PIRP_CONTEXT_LITE IrpContextLite
//      );
//

#define CdCreateIrpContextLite(IC)  \
    ExAllocatePoolWithTag( CdNonPagedPool, sizeof( IRP_CONTEXT_LITE ), TAG_IRP_CONTEXT_LITE )

#define CdFreeIrpContextLite(ICL)  \
    CdFreePool( &(ICL) )

VOID
CdTeardownStructures (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB StartingFcb,
    OUT PBOOLEAN RemovedStartingFcb
    );

//
//  VOID
//  CdIncrementCleanupCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  CdDecrementCleanupCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  CdIncrementReferenceCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ULONG ReferenceCount
//      IN ULONG UserReferenceCount
//      );
//
//  VOID
//  CdDecrementReferenceCounts (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb,
//      IN ULONG ReferenceCount
//      IN ULONG UserReferenceCount
//      );
//
//  VOID
//  CdIncrementFcbReference (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  CdDecrementFcbReference (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//

#define CdIncrementCleanupCounts(IC,F) {        \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbCleanup += 1;                       \
    (F)->Vcb->VcbCleanup += 1;                  \
}

#define CdDecrementCleanupCounts(IC,F) {        \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbCleanup -= 1;                       \
    (F)->Vcb->VcbCleanup -= 1;                  \
}

#define CdIncrementReferenceCounts(IC,F,C,UC) { \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbReference += (C);                   \
    (F)->FcbUserReference += (UC);              \
    (F)->Vcb->VcbReference += (C);              \
    (F)->Vcb->VcbUserReference += (UC);         \
}

#define CdDecrementReferenceCounts(IC,F,C,UC) { \
    ASSERT_LOCKED_VCB( (F)->Vcb );              \
    (F)->FcbReference -= (C);                   \
    (F)->FcbUserReference -= (UC);              \
    (F)->Vcb->VcbReference -= (C);              \
    (F)->Vcb->VcbUserReference -= (UC);         \
}

//
//  PCD_IO_CONTEXT
//  CdAllocateIoContext (
//      );
//
//  VOID
//  CdFreeIoContext (
//      PCD_IO_CONTEXT IoContext
//      );
//

#define CdAllocateIoContext()                           \
    FsRtlAllocatePoolWithTag( CdNonPagedPool,           \
                              sizeof( CD_IO_CONTEXT ),  \
                              TAG_IO_CONTEXT )

#define CdFreeIoContext(IO)     CdFreePool( &(IO) )

PFCB
CdLookupFcbTable (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FILE_ID FileId
    );

PFCB
CdGetNextFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PVOID *RestartKey
    );

NTSTATUS
CdProcessToc (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PCDROM_TOC CdromToc,
    IN OUT PULONG Length,
    OUT PULONG TrackCount,
    OUT PULONG DiskFlags
    );

//
//  For debugging purposes we sometimes want to allocate our structures from nonpaged
//  pool so that in the kernel debugger we can walk all the structures.
//

#define CdPagedPool                 PagedPool
#define CdNonPagedPool              NonPagedPool
#define CdNonPagedPoolCacheAligned  NonPagedPoolCacheAligned


//
//  Verification support routines.  Contained in verfysup.c
//


INLINE
BOOLEAN
CdOperationIsDasdOpen(
    IN PIRP_CONTEXT IrpContext
    )
{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( IrpContext->Irp);
    
    return ((IrpContext->MajorFunction == IRP_MJ_CREATE) &&
            (IrpSp->FileObject->FileName.Length == 0) &&
            (IrpSp->FileObject->RelatedFileObject == NULL));
}


NTSTATUS
CdPerformVerify (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceToVerify
    );

BOOLEAN
CdCheckForDismount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB,
    IN BOOLEAN Force
    );

VOID
CdVerifyVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

BOOLEAN
CdVerifyFcbOperation (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb
    );

BOOLEAN
CdDismountVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

// @@BEGIN_DDKSPLIT

//
//  Some debug aids we don't want cluttering the shipped IFSkit sample code.
//

//
//  Macros for insterting delays for debugging purposes.
//

#define DELAY_N_SECONDS( S)  {                                             \
    INT64 Delay = -1000*1000*(S);                                          \
    KeDelayExecutionThread( KernelMode, FALSE, (PLARGE_INTEGER)&Delay);    \
}

#define DELAY_WHILE_TRUE( V)  {     \
    while (V)  {                    \
        DELAY_N_SECONDS( 1);        \
    }                               \
}

#ifdef CD_TRACE

#define CdUpdateMediaChangeCount( V, C)  { DebugTrace(( 1, "V %p  MC %d -> %d (%d %s)\n", (V), (V)->MediaChangeCount, (C), __LINE__, __FILE__)); \
                                           (V)->MediaChangeCount = (C); }

#define CdUpdateVcbCondition( V, C)      { DebugTrace(( 1, "V %p  Condition %d -> %d (%d %s)\n", (V), (V)->VcbCondition, (C), __LINE__, __FILE__)); \
                                           (V)->VcbCondition = (C); }

#define CdMarkRealDevForVerify( DO)  { DebugTrace(( 1, "D %p  Mark for verify (%d %s)\n", (DO), __LINE__, __FILE__)); \
                                       SetFlag( (DO)->Flags, DO_VERIFY_VOLUME); }

#define CdMarkRealDevVerifyOk( DO)   { DebugTrace(( 1, "D %p  Mark verify OK (%d %s)\n", (DO), __LINE__, __FILE__)); \
                                       ClearFlag( (DO)->Flags, DO_VERIFY_VOLUME); }
#else
// @@END_DDKSPLIT

//
//  Macros to abstract device verify flag changes.
//

#define CdUpdateMediaChangeCount( V, C)  (V)->MediaChangeCount = (C)
#define CdUpdateVcbCondition( V, C)      (V)->VcbCondition = (C)

#define CdMarkRealDevForVerify( DO)  SetFlag( (DO)->Flags, DO_VERIFY_VOLUME)
                                     
#define CdMarkRealDevVerifyOk( DO)   ClearFlag( (DO)->Flags, DO_VERIFY_VOLUME)

// @@BEGIN_DDKSPLIT
#endif
// @@END_DDKSPLIT

#define CdRealDevNeedsVerify( DO)    BooleanFlagOn( (DO)->Flags, DO_VERIFY_VOLUME)

//
//  BOOLEAN
//  CdIsRawDevice (
//      IN PIRP_CONTEXT IrpContext,
//      IN NTSTATUS Status
//      );
//

#define CdIsRawDevice(IC,S) (           \
    ((S) == STATUS_DEVICE_NOT_READY) || \
    ((S) == STATUS_NO_MEDIA_IN_DEVICE)  \
)


//
//  Work queue routines for posting and retrieving an Irp, implemented in
//  workque.c
//

NTSTATUS
CdFsdPostRequest(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
CdPrePostIrp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
CdOplockComplete (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );


//
//  Miscellaneous support routines
//

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

//#ifndef BooleanFlagOn
//#define BooleanFlagOn(F,SF) (    \
//    (BOOLEAN)(((F) & (SF)) != 0) \
//)
//#endif

//#ifndef SetFlag
//#define SetFlag(Flags,SingleFlag) { \
//    (Flags) |= (SingleFlag);        \
//}
//#endif

//#ifndef ClearFlag
//#define ClearFlag(Flags,SingleFlag) { \
//    (Flags) &= ~(SingleFlag);         \
//}
//#endif

//
//      CAST
//      Add2Ptr (
//          IN PVOID Pointer,
//          IN ULONG Increment
//          IN (CAST)
//          );
//
//      ULONG
//      PtrOffset (
//          IN PVOID BasePtr,
//          IN PVOID OffsetPtr
//          );
//

#define Add2Ptr(PTR,INC,CAST) ((CAST)((PUCHAR)(PTR) + (INC)))

#define PtrOffset(BASE,OFFSET) ((ULONG)((ULONG_PTR)(OFFSET) - (ULONG_PTR)(BASE)))

//
//  This macro takes a pointer (or ulong) and returns its rounded up word
//  value
//

#define WordAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 1) & 0xfffffffe) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up longword
//  value
//

#define LongAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 3) & 0xfffffffc) \
    )

//
//  This macro takes a pointer (or ulong) and returns its rounded up quadword
//  value
//

#define QuadAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 7) & 0xfffffff8) \
    )

//
//  The following macros round up and down to sector boundaries.
//

#define SectorAlign(L) (                                                \
    ((((ULONG)(L)) + (SECTOR_SIZE - 1)) & ~(SECTOR_SIZE - 1))           \
)

#define LlSectorAlign(L) (                                              \
    ((((LONGLONG)(L)) + (SECTOR_SIZE - 1)) & ~(SECTOR_SIZE - 1))        \
)

#define SectorTruncate(L) (                                             \
    ((ULONG)(L)) & ~(SECTOR_SIZE - 1)                                   \
)

#define LlSectorTruncate(L) (                                           \
    ((LONGLONG)(L)) & ~(SECTOR_SIZE - 1)                                \
)

#define BytesFromSectors(L) (                                           \
    ((ULONG) (L)) << SECTOR_SHIFT                                       \
)

#define SectorsFromBytes(L) (                                           \
    ((ULONG) (L)) >> SECTOR_SHIFT                                       \
)

#define LlBytesFromSectors(L) (                                         \
    Int64ShllMod32( (LONGLONG)(L), SECTOR_SHIFT )                       \
)

#define LlSectorsFromBytes(L) (                                         \
    Int64ShraMod32( (LONGLONG)(L), SECTOR_SHIFT )                       \
)

#define SectorOffset(L) (                                               \
    ((ULONG)(ULONG_PTR) (L)) & SECTOR_MASK                              \
)

#define SectorBlockOffset(V,LB) (                                       \
    ((ULONG) (LB)) & ((V)->BlocksPerSector - 1)                         \
)

#define BytesFromBlocks(V,B) (                                          \
    (ULONG) (B) << (V)->BlockToByteShift                                \
)

#define LlBytesFromBlocks(V,B) (                                        \
    Int64ShllMod32( (LONGLONG) (B), (V)->BlockToByteShift )             \
)

#define BlockAlign(V,L) (                                               \
    ((ULONG)(L) + (V)->BlockMask) & (V)->BlockInverseMask               \
)

//
//  Carefully make sure the mask is sign extended to 64bits
//

#define LlBlockAlign(V,L) (                                                     \
    ((LONGLONG)(L) + (V)->BlockMask) & (LONGLONG)((LONG)(V)->BlockInverseMask)  \
)

#define BlockOffset(V,L) (                                              \
    ((ULONG) (L)) & (V)->BlockMask                                      \
)

#define RawSectorAlign( B) ((((B)+(RAW_SECTOR_SIZE - 1)) / RAW_SECTOR_SIZE) * RAW_SECTOR_SIZE)

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

typedef union _USHORT2 {
    USHORT Ushort[2];
    ULONG  ForceAlignment;
} USHORT2, *PUSHORT2;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                           \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src));  \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                           \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src));  \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                           \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src));  \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//  accessing the source on a word boundary.
//

#define CopyUshort2(Dst,Src) {                          \
    *((USHORT2 *)(Dst)) = *((UNALIGNED USHORT2 *)(Src));\
    }


//
//  Following routines handle entry in and out of the filesystem.  They are
//  contained in CdData.c
//

NTSTATUS
CdFsdDispatch (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    );

LONG
CdExceptionFilter (
    IN PIRP_CONTEXT IrpContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

NTSTATUS
CdProcessException (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp,
    IN NTSTATUS ExceptionCode
    );

VOID
CdCompleteRequest (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PIRP Irp OPTIONAL,
    IN NTSTATUS Status
    );

//
//  VOID
//  CdRaiseStatus (
//      IN PRIP_CONTEXT IrpContext,
//      IN NT_STATUS Status
//      );
//
//  VOID
//  CdNormalizeAndRaiseStatus (
//      IN PRIP_CONTEXT IrpContext,
//      IN NT_STATUS Status
//      );
//

#if 0
#define AssertVerifyDevice(C, S)                                                    \
    ASSERT( (C) == NULL ||                                                          \
            FlagOn( (C)->Flags, IRP_CONTEXT_FLAG_IN_FSP ) ||                        \
            !((S) == STATUS_VERIFY_REQUIRED &&                                      \
              IoGetDeviceToVerify( PsGetCurrentThread() ) == NULL ));

#define AssertVerifyDeviceIrp(I)                                                    \
    ASSERT( (I) == NULL ||                                                          \
            !(((I)->IoStatus.Status) == STATUS_VERIFY_REQUIRED &&                   \
              ((I)->Tail.Overlay.Thread == NULL ||                                  \
                IoGetDeviceToVerify( (I)->Tail.Overlay.Thread ) == NULL )));
#else
#define AssertVerifyDevice(C, S)
#define AssertVerifyDeviceIrp(I)
#endif


#ifdef CD_SANITY

DECLSPEC_NORETURN
VOID
CdRaiseStatusEx(
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status,
    IN BOOLEAN NormalizeStatus,
    IN OPTIONAL ULONG FileId,
    IN OPTIONAL ULONG Line
    );

#else

INLINE
DECLSPEC_NORETURN
VOID
CdRaiseStatusEx(
    IN PIRP_CONTEXT IrpContext,
    IN NTSTATUS Status,
    IN BOOLEAN NormalizeStatus,
    IN ULONG Fileid,
    IN ULONG Line
    )
{
    if (NormalizeStatus)  {

        IrpContext->ExceptionStatus = FsRtlNormalizeNtstatus( Status, STATUS_UNEXPECTED_IO_ERROR);
    }
    else {

        IrpContext->ExceptionStatus = Status;
    }

    IrpContext->RaisedAtLineFile = (Fileid << 16) | Line;

    ExRaiseStatus( IrpContext->ExceptionStatus );
}

#endif

#define CdRaiseStatus( IC, S)               CdRaiseStatusEx( (IC), (S), FALSE, BugCheckFileId, __LINE__);
#define CdNormalizeAndRaiseStatus( IC, S)   CdRaiseStatusEx( (IC), (S), TRUE, BugCheckFileId, __LINE__);

//
//  Following are the fast entry points.
//

BOOLEAN
CdFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
CdFastQueryNetworkInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

//
//  Following are the routines to handle the top level thread logic.
//

VOID
CdSetThreadContext (
    IN PIRP_CONTEXT IrpContext,
    IN PTHREAD_CONTEXT ThreadContext
    );


//
//  VOID
//  CdRestoreThreadContext (
//      IN PIRP_CONTEXT IrpContext
//      );
//

#define CdRestoreThreadContext(IC)                              \
    (IC)->ThreadContext->Cdfs = 0;                              \
    IoSetTopLevelIrp( (IC)->ThreadContext->SavedTopLevelIrp );  \
    (IC)->ThreadContext = NULL

ULONG
CdSerial32 (
    IN PCHAR Buffer,
    IN ULONG ByteCount
    );

//
//  The following macro is used to determine if an FSD thread can block
//  for I/O or wait for a resource.  It returns TRUE if the thread can
//  block and FALSE otherwise.  This attribute can then be used to call
//  the FSD & FSP common work routine with the proper wait value.
//

#define CanFsdWait(I)   IoIsOperationSynchronous(I)

//
//  The following macro is used to set the fast i/o possible bits in the
//  FsRtl header.
//
//      FastIoIsNotPossible - If the Fcb is bad or there are oplocks on the file.
//
//      FastIoIsQuestionable - If there are file locks.
//
//      FastIoIsPossible - In all other cases.
//
//

#define CdIsFastIoPossible(F) ((BOOLEAN)                                            \
    ((((F)->Vcb->VcbCondition != VcbMounted ) ||                                    \
      !FsRtlOplockIsFastIoPossible( &(F)->Oplock )) ?                               \
                                                                                    \
     FastIoIsNotPossible :                                                          \
                                                                                    \
     ((((F)->FileLock != NULL) && FsRtlAreThereCurrentFileLocks( (F)->FileLock )) ? \
                                                                                    \
        FastIoIsQuestionable :                                                      \
                                                                                    \
        FastIoIsPossible))                                                          \
)


//
//  The FSP level dispatch/main routine.  This is the routine that takes
//  IRP's off of the work queue and calls the appropriate FSP level
//  work routine.
//

VOID
CdFspDispatch (                             //  implemented in FspDisp.c
    IN PIRP_CONTEXT IrpContext
    );

VOID
CdFspClose (                                //  implemented in Close.c
    IN PVCB Vcb OPTIONAL
    );

//
//  The following routines are the entry points for the different operations
//  based on the IrpSp major functions.
//

NTSTATUS
CdCommonCreate (                            //  Implemented in Create.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonClose (                             //  Implemented in Close.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonRead (                              //  Implemented in Read.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonQueryInfo (                         //  Implemented in FileInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonSetInfo (                           //  Implemented in FileInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonQueryVolInfo (                      //  Implemented in VolInfo.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonDirControl (                        //  Implemented in DirCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonFsControl (                         //  Implemented in FsCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonDevControl (                        //  Implemented in DevCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonLockControl (                       //  Implemented in LockCtrl.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonCleanup (                           //  Implemented in Cleanup.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdCommonPnp (                               //  Implemented in Pnp.c
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );


//
//  The following macros are used to establish the semantics needed
//  to do a return from within a try-finally clause.  As a rule every
//  try clause must end with a label call try_exit.  For example,
//
//      try {
//              :
//              :
//
//      try_exit: NOTHING;
//      } finally {
//
//              :
//              :
//      }
//
//  Every return statement executed inside of a try clause should use the
//  try_return macro.  If the compiler fully supports the try-finally construct
//  then the macro should be
//
//      #define try_return(S)  { return(S); }
//
//  If the compiler does not support the try-finally construct then the macro
//  should be
//
//      #define try_return(S)  { S; goto try_exit; }
//

#define try_return(S) { S; goto try_exit; }
#define try_leave(S) { S; leave; }

//
//  Encapsulate safe pool freeing
//

INLINE
VOID
CdFreePool(
    IN PVOID *Pool
    )
{
    if (*Pool != NULL) {

        ExFreePool(*Pool);
        *Pool = NULL;
    }
}

#endif // _CDPROCS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\create.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for Cdfs called by the
    Fsd/Fsp dispatch routines.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_CREATE)

//
//  Local support routines
//

NTSTATUS
CdNormalizeFileNames (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN OpenByFileId,
    IN BOOLEAN IgnoreCase,
    IN TYPE_OF_OPEN RelatedTypeOfOpen,
    IN PCCB RelatedCcb OPTIONAL,
    IN PUNICODE_STRING RelatedFileName OPTIONAL,
    IN OUT PUNICODE_STRING FileName,
    IN OUT PCD_NAME RemainingName
    );

NTSTATUS
CdOpenByFileId (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb
    );

NTSTATUS
CdOpenExistingFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PFCB *CurrentFcb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN IgnoreCase,
    IN PCCB RelatedCcb OPTIONAL
    );

NTSTATUS
CdOpenDirectoryFromPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN PCD_NAME DirName,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortNameMatch,
    IN PPATH_ENTRY PathEntry,
    IN BOOLEAN PerformUserOpen,
    IN PCCB RelatedCcb OPTIONAL
    );

NTSTATUS
CdOpenFileFromFileContext (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN PCD_NAME FileName,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortNameMatch,
    IN PFILE_ENUM_CONTEXT FileContext,
    IN PCCB RelatedCcb OPTIONAL
    );

NTSTATUS
CdCompleteFcbOpen (
    IN PIRP_CONTEXT IrpContext,
    PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN ULONG UserCcbFlags,
    IN ACCESS_MASK DesiredAccess
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonCreate)
#pragma alloc_text(PAGE, CdCompleteFcbOpen)
#pragma alloc_text(PAGE, CdNormalizeFileNames)
#pragma alloc_text(PAGE, CdOpenByFileId)
#pragma alloc_text(PAGE, CdOpenDirectoryFromPathEntry)
#pragma alloc_text(PAGE, CdOpenExistingFcb)
#pragma alloc_text(PAGE, CdOpenFileFromFileContext)
#endif


NTSTATUS
CdCommonCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for opening a file called by both the
    Fsp and Fsd threads.

    The file can be opened either by name or by file Id either with or without
    a relative name.  The file name field in the file object passed to this routine
    contains either a unicode string or a 64 bit value which is the file Id.
    If this is not a Joliet disk then we will convert the unicode name to
    an Oem string in this routine.  If there is a related file object with
    a name then we will already have converted that name to Oem.

    We will store the full name for the file in the file object on a successful
    open.  We will allocate a larger buffer if necessary and combine the
    related and file object names.  The only exception is the relative open
    when the related file object is for an OpenByFileId file.  If we need to
    allocate a buffer for a case insensitive name then we allocate it at
    the tail of the buffer we will store into the file object.  The upcased
    portion will begin immediately after the name defined by the FileName
    in the file object.

    Once we have the full name in the file object we don't want to split the
    name in the event of a retry.  We use a flag in the IrpContext to indicate
    that the name has been split.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - This is the status from this open operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFILE_OBJECT FileObject;

    COMPOUND_PATH_ENTRY CompoundPathEntry;
    BOOLEAN CleanupCompoundPathEntry = FALSE;

    FILE_ENUM_CONTEXT FileContext;
    BOOLEAN CleanupFileContext = FALSE;
    BOOLEAN FoundEntry;

    PVCB Vcb;

    BOOLEAN OpenByFileId;
    BOOLEAN IgnoreCase;
    ULONG CreateDisposition;

    BOOLEAN ShortNameMatch;
    ULONG ShortNameDirentOffset;

    BOOLEAN VolumeOpen = FALSE;

    //
    //  We will be acquiring and releasing file Fcb's as we move down the
    //  directory tree during opens.  At any time we need to know the deepest
    //  point we have traversed down in the tree in case we need to cleanup
    //  any structures created here.
    //
    //  CurrentFcb - represents this point.  If non-null it means we have
    //      acquired it and need to release it in finally clause.
    //
    //  NextFcb - represents the NextFcb to walk to but haven't acquired yet.
    //

    TYPE_OF_OPEN RelatedTypeOfOpen = UnopenedFileObject;
    PFILE_OBJECT RelatedFileObject;
    PCCB RelatedCcb = NULL;

    PFCB NextFcb;
    PFCB CurrentFcb = NULL;

    //
    //  During the open we need to combine the related file object name
    //  with the remaining name.  We also may need to upcase the file name
    //  in order to do a case-insensitive name comparison.  We also need
    //  to restore the name in the file object in the event that we retry
    //  the request.  We use the following string variables to manage the
    //  name.  We will can put these strings into either Unicode or Ansi
    //  form.
    //
    //  FileName - Pointer to name as currently stored in the file
    //      object.  We store the full name into the file object early in
    //      the open operation.
    //
    //  RelatedFileName - Pointer to the name in the related file object.
    //
    //  RemainingName - String containing remaining name to parse.
    //
    //  MatchingName - Address of name structure in FileContext which matched.
    //      We need this to know whether we matched the long or short name.
    //

    PUNICODE_STRING FileName;
    PUNICODE_STRING RelatedFileName = NULL;

    CD_NAME RemainingName;
    CD_NAME FinalName;
    PCD_NAME MatchingName;

    PAGED_CODE();

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS.
    //

    if (IrpContext->Vcb == NULL) {

        CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Get create parameters from the Irp.
    //

    OpenByFileId = BooleanFlagOn( IrpSp->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID );
    IgnoreCase = !BooleanFlagOn( IrpSp->Flags, SL_CASE_SENSITIVE );
    CreateDisposition = (IrpSp->Parameters.Create.Options >> 24) & 0x000000ff;

    //
    //  Do some preliminary checks to make sure the operation is supported.
    //  We fail in the following cases immediately.
    //
    //      - Open a paging file.
    //      - Open a target directory.
    //      - Open a file with Eas.
    //      - Create a file.
    //

    if (FlagOn( IrpSp->Flags, SL_OPEN_PAGING_FILE | SL_OPEN_TARGET_DIRECTORY) ||
        (IrpSp->Parameters.Create.EaLength != 0) ||
        (CreateDisposition == FILE_CREATE)) {

        CdCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );
        return STATUS_ACCESS_DENIED;
    }

    //
    //  Copy the Vcb to a local.  Assume the starting directory is the root.
    //

    Vcb = IrpContext->Vcb;
    NextFcb = Vcb->RootIndexFcb;

    //
    //  Reference our input parameters to make things easier
    //

    FileObject = IrpSp->FileObject;
    RelatedFileObject = NULL;

    FileName = &FileObject->FileName;

    //
    //  Set up the file object's Vpb pointer in case anything happens.
    //  This will allow us to get a reasonable pop-up.
    //

    if ((FileObject->RelatedFileObject != NULL) && !OpenByFileId) {

        RelatedFileObject = FileObject->RelatedFileObject;
        FileObject->Vpb = RelatedFileObject->Vpb;

        RelatedTypeOfOpen = CdDecodeFileObject( IrpContext, RelatedFileObject, &NextFcb, &RelatedCcb );

        //
        //  Fail the request if this is not a user file object.
        //

        if (RelatedTypeOfOpen < UserVolumeOpen) {

            CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }

        //
        //  Remember the name in the related file object.
        //

        RelatedFileName = &RelatedFileObject->FileName;
    }

    //
    //  If we haven't initialized the names then make sure the strings are valid.
    //  If this an OpenByFileId then verify the file id buffer.
    //
    //  After this routine returns we know that the full name is in the
    //  FileName buffer and the buffer will hold the upcased portion
    //  of the name yet to parse immediately after the full name in the
    //  buffer.  Any trailing backslash has been removed and the flag
    //  in the IrpContext will indicate whether we removed the
    //  backslash.
    //

    Status = CdNormalizeFileNames( IrpContext,
                                   Vcb,
                                   OpenByFileId,
                                   IgnoreCase,
                                   RelatedTypeOfOpen,
                                   RelatedCcb,
                                   RelatedFileName,
                                   FileName,
                                   &RemainingName );

    //
    //  Return the error code if not successful.
    //

    if (!NT_SUCCESS( Status )) {

        CdCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  We want to acquire the Vcb.  Exclusively for a volume open, shared otherwise.
    //  The file name is empty for a volume open.
    //

    if ((FileName->Length == 0) &&
        (RelatedTypeOfOpen <= UserVolumeOpen) &&
        !OpenByFileId) {

        VolumeOpen = TRUE;
        CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    } else {

        CdAcquireVcbShared( IrpContext, Vcb, FALSE );
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify that the Vcb is not in an unusable condition.  This routine
        //  will raise if not usable.
        //

        CdVerifyVcb( IrpContext, Vcb );

        //
        //  If the Vcb is locked then we cannot open another file
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_LOCKED )) {

            try_return( Status = STATUS_ACCESS_DENIED );
        }

        //
        //  If we are opening this file by FileId then process this immediately
        //  and exit.
        //

        if (OpenByFileId) {

            //
            //  We only allow Dasd opens of audio disks.  Fail this request at
            //  this point.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_AUDIO_DISK )) {

                try_return( Status = STATUS_INVALID_DEVICE_REQUEST );
            }

            //
            //  The only create disposition we allow is OPEN.
            //

            if ((CreateDisposition != FILE_OPEN) &&
                (CreateDisposition != FILE_OPEN_IF)) {

                try_return( Status = STATUS_ACCESS_DENIED );
            }

            //
            //  Make sure we can wait for this request.
            //

            if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            try_return( Status = CdOpenByFileId( IrpContext,
                                                 IrpSp,
                                                 Vcb,
                                                 &CurrentFcb ));
        }

        //
        //  If we are opening this volume Dasd then process this immediately
        //  and exit.
        //

        if (VolumeOpen) {

            //
            //  The only create disposition we allow is OPEN.
            //

            if ((CreateDisposition != FILE_OPEN) &&
                (CreateDisposition != FILE_OPEN_IF)) {

                try_return( Status = STATUS_ACCESS_DENIED );
            }

            //
            //  If they wanted to open a directory, surprise.
            //

            if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

                try_return( Status = STATUS_NOT_A_DIRECTORY );
            }

            //
            //  Acquire the Fcb first.
            //

            CurrentFcb = Vcb->VolumeDasdFcb;
            CdAcquireFcbExclusive( IrpContext, CurrentFcb, FALSE );

            try_return( Status = CdOpenExistingFcb( IrpContext,
                                                    IrpSp,
                                                    &CurrentFcb,
                                                    UserVolumeOpen,
                                                    FALSE,
                                                    NULL ));
        }

        //
        //  At this point CurrentFcb points to the deepest Fcb for this open
        //  in the tree.  Let's acquire this Fcb to keep it from being deleted
        //  beneath us.
        //

        CdAcquireFcbExclusive( IrpContext, NextFcb, FALSE );
        CurrentFcb = NextFcb;

        //
        //  Do a prefix search if there is more of the name to parse.
        //

        if (RemainingName.FileName.Length != 0) {

            //
            //  Do the prefix search to find the longest matching name.
            //

            CdFindPrefix( IrpContext,
                          &CurrentFcb,
                          &RemainingName.FileName,
                          IgnoreCase );
        }

        //
        //  If the remaining name length is zero then we have found our
        //  target.
        //

        if (RemainingName.FileName.Length == 0) {

            //
            //  If this is a file so verify the user didn't want to open
            //  a directory.
            //

            if (SafeNodeType( CurrentFcb ) == CDFS_NTC_FCB_DATA) {

                if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TRAIL_BACKSLASH ) ||
                    FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

                    try_return( Status = STATUS_NOT_A_DIRECTORY );
                }

                //
                //  The only create disposition we allow is OPEN.
                //

                if ((CreateDisposition != FILE_OPEN) &&
                    (CreateDisposition != FILE_OPEN_IF)) {

                    try_return( Status = STATUS_ACCESS_DENIED );
                }

                try_return( Status = CdOpenExistingFcb( IrpContext,
                                                        IrpSp,
                                                        &CurrentFcb,
                                                        UserFileOpen,
                                                        IgnoreCase,
                                                        RelatedCcb ));

            //
            //  This is a directory.  Verify the user didn't want to open
            //  as a file.
            //

            } else if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE )) {

                try_return( Status = STATUS_FILE_IS_A_DIRECTORY );

            //
            //  Open the file as a directory.
            //

            } else {

                //
                //  The only create disposition we allow is OPEN.
                //

                if ((CreateDisposition != FILE_OPEN) &&
                    (CreateDisposition != FILE_OPEN_IF)) {

                    try_return( Status = STATUS_ACCESS_DENIED );
                }

                try_return( Status = CdOpenExistingFcb( IrpContext,
                                                        IrpSp,
                                                        &CurrentFcb,
                                                        UserDirectoryOpen,
                                                        IgnoreCase,
                                                        RelatedCcb ));
            }
        }

        //
        //  We have more work to do.  We have a starting Fcb which we own shared.
        //  We also have the remaining name to parse.  Walk through the name
        //  component by component looking for the full name.
        //

        //
        //  Our starting Fcb better be a directory.
        //

        if (!FlagOn( CurrentFcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

            try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );
        }

        //
        //  If we can't wait then post this request.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

            CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
        }

        //
        //  Make sure the final name has no version string.
        //

        FinalName.VersionString.Length = 0;

        while (TRUE) {

            ShortNameMatch = FALSE;

            //
            //  Split off the next component from the name.
            //

            CdDissectName( IrpContext,
                           &RemainingName.FileName,
                           &FinalName.FileName );

            //
            //  Go ahead and look this entry up in the path table.
            //

            CdInitializeCompoundPathEntry( IrpContext, &CompoundPathEntry );
            CleanupCompoundPathEntry = TRUE;

            FoundEntry = CdFindPathEntry( IrpContext,
                                          CurrentFcb,
                                          &FinalName,
                                          IgnoreCase,
                                          &CompoundPathEntry );

            //
            //  If we didn't find the entry then check if the current name
            //  is a possible short name.
            //

            if (!FoundEntry) {

                ShortNameDirentOffset = CdShortNameDirentOffset( IrpContext, &FinalName.FileName );

                //
                //  If there is an embedded short name offset then look for the
                //  matching long name in the directory.
                //

                if (ShortNameDirentOffset != MAXULONG) {

                    if (CleanupFileContext) {

                        CdCleanupFileContext( IrpContext, &FileContext );
                    }

                    CdInitializeFileContext( IrpContext, &FileContext );
                    CleanupFileContext = TRUE;

                    FoundEntry = CdFindFileByShortName( IrpContext,
                                                        CurrentFcb,
                                                        &FinalName,
                                                        IgnoreCase,
                                                        ShortNameDirentOffset,
                                                        &FileContext );

                    //
                    //  If we found an entry and it is a directory then look
                    //  this up in the path table.
                    //

                    if (FoundEntry) {

                        ShortNameMatch = TRUE;

                        if (FlagOn( FileContext.InitialDirent->Dirent.DirentFlags,
                                    CD_ATTRIBUTE_DIRECTORY )) {

                            CdCleanupCompoundPathEntry( IrpContext, &CompoundPathEntry );
                            CdInitializeCompoundPathEntry( IrpContext, &CompoundPathEntry );

                            FoundEntry = CdFindPathEntry( IrpContext,
                                                          CurrentFcb,
                                                          &FileContext.InitialDirent->Dirent.CdCaseFileName,
                                                          IgnoreCase,
                                                          &CompoundPathEntry );

                            //
                            //  We better find this entry.
                            //

                            if (!FoundEntry) {

                                CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                            }

                            //
                            //  Upcase the name with the short name if case
                            //  insensitive.
                            //

                            if (IgnoreCase) {

                                CdUpcaseName( IrpContext, &FinalName, &FinalName );
                            }

                        //
                        //  We found a matching file.  If we are at the last
                        //  entry then break out of the loop and open the
                        //  file below.  Otherwise we return an error.
                        //

                        } else if (RemainingName.FileName.Length == 0) {

                            //
                            //  Break out of the loop.  We will process the dirent
                            //  below.
                            //

                            MatchingName = &FileContext.ShortName;
                            break;

                        } else {

                            try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );
                        }
                    }
                }

                //
                //  We didn't find the name in either the path table or as
                //  a short name in a directory.  If the remaining name
                //  length is zero then break out of the loop to search
                //  the directory.
                //

                if (!FoundEntry) {

                    if (RemainingName.FileName.Length == 0) {

                        break;

                    //
                    //  Otherwise this path could not be cracked.
                    //

                    } else {

                        try_return( Status = STATUS_OBJECT_PATH_NOT_FOUND );
                    }
                }
            }

            //
            //  If this is an ignore case open then copy the exact case
            //  in the file object name.  If it was a short name match then
            //  the name must be upcase already.
            //

            if (IgnoreCase && !ShortNameMatch) {

                RtlCopyMemory( FinalName.FileName.Buffer,
                               CompoundPathEntry.PathEntry.CdDirName.FileName.Buffer,
                               CompoundPathEntry.PathEntry.CdDirName.FileName.Length );
            }

            //
            //  If we have found the last component then open this as a directory
            //  and return to our caller.
            //

            if (RemainingName.FileName.Length == 0) {

                if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE )) {

                    try_return( Status = STATUS_FILE_IS_A_DIRECTORY );
                }

                //
                //  The only create disposition we allow is OPEN.
                //

                if ((CreateDisposition != FILE_OPEN) &&
                    (CreateDisposition != FILE_OPEN_IF)) {

                    try_return( Status = STATUS_ACCESS_DENIED );
                }

                try_return( Status = CdOpenDirectoryFromPathEntry( IrpContext,
                                                                   IrpSp,
                                                                   Vcb,
                                                                   &CurrentFcb,
                                                                   &FinalName,
                                                                   IgnoreCase,
                                                                   ShortNameMatch,
                                                                   &CompoundPathEntry.PathEntry,
                                                                   TRUE,
                                                                   RelatedCcb ));
            }

            //
            //  Otherwise open an Fcb for this intermediate index Fcb.
            //

            CdOpenDirectoryFromPathEntry( IrpContext,
                                          IrpSp,
                                          Vcb,
                                          &CurrentFcb,
                                          &FinalName,
                                          IgnoreCase,
                                          ShortNameMatch,
                                          &CompoundPathEntry.PathEntry,
                                          FALSE,
                                          NULL );

            CdCleanupCompoundPathEntry( IrpContext, &CompoundPathEntry );
            CleanupCompoundPathEntry = FALSE;
        }

        //
        //  We need to scan the current directory for a matching file name
        //  if we don't already have one.
        //

        if (!FoundEntry) {

            if (CleanupFileContext) {

                CdCleanupFileContext( IrpContext, &FileContext );
            }

            CdInitializeFileContext( IrpContext, &FileContext );
            CleanupFileContext = TRUE;

            //
            //  Split our search name into separate components.
            //

            CdConvertNameToCdName( IrpContext, &FinalName );

            FoundEntry = CdFindFile( IrpContext,
                                     CurrentFcb,
                                     &FinalName,
                                     IgnoreCase,
                                     &FileContext,
                                     &MatchingName );
        }

        //
        //  If we didn't find a match then check if the name is invalid to
        //  determine which error code to return.
        //

        if (!FoundEntry) {

            if ((CreateDisposition == FILE_OPEN) ||
                (CreateDisposition == FILE_OVERWRITE)) {

                try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
            }

            //
            //  Any other operation return STATUS_ACCESS_DENIED.
            //

            try_return( Status = STATUS_ACCESS_DENIED );
        }

        //
        //  If this is a directory then the disk is corrupt because it wasn't
        //  in the Path Table.
        //

        if (FlagOn( FileContext.InitialDirent->Dirent.Flags, CD_ATTRIBUTE_DIRECTORY )) {

            CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
        }

        //
        //  Make sure our opener didn't want a directory.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TRAIL_BACKSLASH ) ||
            FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

            try_return( Status = STATUS_NOT_A_DIRECTORY );
        }

        //
        //  The only create disposition we allow is OPEN.
        //

        if ((CreateDisposition != FILE_OPEN) &&
            (CreateDisposition != FILE_OPEN_IF)) {

            try_return( Status = STATUS_ACCESS_DENIED );
        }

        //
        //  If this is an ignore case open then copy the exact case
        //  in the file object name.  Any version portion should
        //  already be upcased.
        //

        if (IgnoreCase) {

            RtlCopyMemory( FinalName.FileName.Buffer,
                           MatchingName->FileName.Buffer,
                           MatchingName->FileName.Length );
        }

        //
        //  Open the file using the file context.  We already have the
        //  first and last dirents.
        //

        try_return( Status = CdOpenFileFromFileContext( IrpContext,
                                                        IrpSp,
                                                        Vcb,
                                                        &CurrentFcb,
                                                        &FinalName,
                                                        IgnoreCase,
                                                        (BOOLEAN) (MatchingName == &FileContext.ShortName),
                                                        &FileContext,
                                                        RelatedCcb ));

    try_exit:  NOTHING;
    } finally {

        //
        //  Cleanup the PathEntry if initialized.
        //

        if (CleanupCompoundPathEntry) {

            CdCleanupCompoundPathEntry( IrpContext, &CompoundPathEntry );
        }

        //
        //  Cleanup the FileContext if initialized.
        //

        if (CleanupFileContext) {

            CdCleanupFileContext( IrpContext, &FileContext );
        }

        //
        //  The result of this open could be success, pending or some error
        //  condition.
        //

        if (AbnormalTermination()) {


            //
            //  In the error path we start by calling our teardown routine if we
            //  have a CurrentFcb.
            //

            if (CurrentFcb != NULL) {

                BOOLEAN RemovedFcb;

                CdTeardownStructures( IrpContext, CurrentFcb, &RemovedFcb );

                if (RemovedFcb) {

                    CurrentFcb = NULL;
                }
            }

            //
            //  No need to complete the request.
            //

            IrpContext = NULL;
            Irp = NULL;

        //
        //  If we posted this request through the oplock package we need
        //  to show that there is no reason to complete the request.
        //

        } else if (Status == STATUS_PENDING) {

            IrpContext = NULL;
            Irp = NULL;
        }

        //
        //  Release the Current Fcb if still acquired.
        //

        if (CurrentFcb != NULL) {

            CdReleaseFcb( IrpContext, CurrentFcb );
        }

        //
        //  Release the Vcb.
        //

        CdReleaseVcb( IrpContext, Vcb );

        //
        //  Call our completion routine.  It will handle the case where either
        //  the Irp and/or IrpContext are gone.
        //

        CdCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdNormalizeFileNames (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN OpenByFileId,
    IN BOOLEAN IgnoreCase,
    IN TYPE_OF_OPEN RelatedTypeOfOpen,
    IN PCCB RelatedCcb OPTIONAL,
    IN PUNICODE_STRING RelatedFileName OPTIONAL,
    IN OUT PUNICODE_STRING FileName,
    IN OUT PCD_NAME RemainingName
    )

/*++

Routine Description:

    This routine is called to store the full name and upcased name into the
    filename buffer.  We only upcase the portion yet to parse.  We also
    check for a trailing backslash and lead-in double backslashes.  This
    routine also verifies the mode of the related open against the name
    currently in the filename.

Arguments:

    Vcb - Vcb for this volume.

    OpenByFileId - Indicates if the filename should be a 64 bit FileId.

    IgnoreCase - Indicates if this open is a case-insensitive operation.

    RelatedTypeOfOpen - Indicates the type of the related file object.

    RelatedCcb - Ccb for the related open.  Ignored if no relative open.

    RelatedFileName - FileName buffer for related open.  Ignored if no
        relative open.

    FileName - FileName to update in this routine.  The name should
        either be a 64-bit FileId or a Unicode string.

    RemainingName - Name with the remaining portion of the name.  This
        will begin after the related name and any separator.  For a
        non-relative open we also step over the initial separator.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the names are OK, appropriate error code
        otherwise.

--*/

{
    ULONG RemainingNameLength;
    ULONG RelatedNameLength = 0;
    ULONG SeparatorLength = 0;

    ULONG BufferLength;

    UNICODE_STRING NewFileName;

    PAGED_CODE();

    //
    //  If this is the first pass then we need to build the full name and
    //  check for name compatibility.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_FULL_NAME )) {

        //
        //  Deal with the regular file name case first.
        //

        if (!OpenByFileId) {

            //
            //  This is here because the Win32 layer can't avoid sending me double
            //  beginning backslashes.
            //
            
            if ((FileName->Length > sizeof( WCHAR )) &&
                (FileName->Buffer[1] == L'\\') &&
                (FileName->Buffer[0] == L'\\')) {

                //
                //  If there are still two beginning backslashes, the name is bogus.
                //

                if ((FileName->Length > 2 * sizeof( WCHAR )) &&
                    (FileName->Buffer[2] == L'\\')) {

                    return STATUS_OBJECT_NAME_INVALID;
                }

                //
                //  Slide the name down in the buffer.
                //

                FileName->Length -= sizeof( WCHAR );

                RtlMoveMemory( FileName->Buffer,
                               FileName->Buffer + 1,
                               FileName->Length );
            }

            //
            //  Check for a trailing backslash.  Don't strip off if only character
            //  in the full name or for relative opens where this is illegal.
            //

            if (((FileName->Length > sizeof( WCHAR)) ||
                 ((FileName->Length == sizeof( WCHAR )) && (RelatedTypeOfOpen == UserDirectoryOpen))) &&
                (FileName->Buffer[ (FileName->Length/2) - 1 ] == L'\\')) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_TRAIL_BACKSLASH );
                FileName->Length -= sizeof( WCHAR );
            }

            //
            //  Remember the length we need for this portion of the name.
            //

            RemainingNameLength = FileName->Length;

            //
            //  If this is a related file object then we verify the compatibility
            //  of the name in the file object with the relative file object.
            //

            if (RelatedTypeOfOpen != UnopenedFileObject) {

                //
                //  If the filename length was zero then it must be legal.
                //  If there are characters then check with the related
                //  type of open.
                //

                if (FileName->Length != 0) {

                    //
                    //  The name length must always be zero for a volume open.
                    //

                    if (RelatedTypeOfOpen <= UserVolumeOpen) {

                        return STATUS_INVALID_PARAMETER;

                    //
                    //  The remaining name cannot begin with a backslash.
                    //

                    } else if (FileName->Buffer[0] == L'\\' ) {

                        return STATUS_INVALID_PARAMETER;

                    //
                    //  If the related file is a user file then there
                    //  is no file with this path.
                    //

                    } else if (RelatedTypeOfOpen == UserFileOpen) {

                        return STATUS_OBJECT_PATH_NOT_FOUND;
                    }
                }

                //
                //  Remember the length of the related name when building
                //  the full name.  We leave the RelatedNameLength and
                //  SeparatorLength at zero if the relative file is opened
                //  by Id.
                //

                if (!FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    //
                    //  Add a separator if the name length is non-zero
                    //  unless the relative Fcb is at the root.
                    //

                    if ((FileName->Length != 0) &&
                        (RelatedCcb->Fcb != Vcb->RootIndexFcb)) {

                        SeparatorLength = sizeof( WCHAR );
                    }

                    RelatedNameLength = RelatedFileName->Length;
                }

            //
            //  The full name is already in the filename.  It must either
            //  be length 0 or begin with a backslash.
            //

            } else if (FileName->Length != 0) {

                if (FileName->Buffer[0] != L'\\') {

                    return STATUS_INVALID_PARAMETER;
                }

                //
                //  We will want to trim the leading backslash from the
                //  remaining name we return.
                //

                RemainingNameLength -= sizeof( WCHAR );
                SeparatorLength = sizeof( WCHAR );
            }

            //
            //  Now see if the buffer is large enough to hold the full name.
            //

            BufferLength = RelatedNameLength + SeparatorLength + RemainingNameLength;

            //
            //  Check for an overflow of the maximum filename size.
            //
            
            if (BufferLength > MAXUSHORT) {

                return STATUS_INVALID_PARAMETER;
            }
            
            //
            //  Now see if we need to allocate a new buffer.
            //

            if (FileName->MaximumLength < BufferLength) {

                NewFileName.Buffer = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                               BufferLength,
                                                               TAG_FILE_NAME );

                NewFileName.MaximumLength = (USHORT) BufferLength;

            } else {

                NewFileName.Buffer = FileName->Buffer;
                NewFileName.MaximumLength = FileName->MaximumLength;
            }

            //
            //  If there is a related name then we need to slide the remaining bytes up and
            //  insert the related name.  Otherwise the name is in the correct position
            //  already.
            //

            if (RelatedNameLength != 0) {

                //
                //  Store the remaining name in its correct position.
                //

                if (RemainingNameLength != 0) {

                    RtlMoveMemory( Add2Ptr( NewFileName.Buffer, RelatedNameLength + SeparatorLength, PVOID ),
                                   FileName->Buffer,
                                   RemainingNameLength );
                }

                RtlCopyMemory( NewFileName.Buffer,
                               RelatedFileName->Buffer,
                               RelatedNameLength );

                //
                //  Add the separator if needed.
                //

                if (SeparatorLength != 0) {

                    *(Add2Ptr( NewFileName.Buffer, RelatedNameLength, PWCHAR )) = L'\\';
                }

                //
                //  Update the filename value we got from the user.
                //

                if (NewFileName.Buffer != FileName->Buffer) {

                    if (FileName->Buffer != NULL) {

                        CdFreePool( &FileName->Buffer );
                    }

                    FileName->Buffer = NewFileName.Buffer;
                    FileName->MaximumLength = NewFileName.MaximumLength;
                }

                //
                //  Copy the name length to the user's filename.
                //

                FileName->Length = (USHORT) (RelatedNameLength + SeparatorLength + RemainingNameLength);
            }

            //
            //  Now update the remaining name to parse.
            //

            RemainingName->FileName.MaximumLength =
            RemainingName->FileName.Length = (USHORT) RemainingNameLength;
            RemainingName->VersionString.Length = 0;

            RemainingName->FileName.Buffer = Add2Ptr( FileName->Buffer,
                                                      RelatedNameLength + SeparatorLength,
                                                      PWCHAR );

            //
            //  Upcase the name if necessary.
            //

            if (IgnoreCase && (RemainingNameLength != 0)) {

                CdUpcaseName( IrpContext,
                              RemainingName,
                              RemainingName );
            }

            //
            //  Do a quick check to make sure there are no wildcards.
            //

            if (FsRtlDoesNameContainWildCards( &RemainingName->FileName )) {

                return STATUS_OBJECT_NAME_INVALID;
            }

        //
        //  For the open by file Id case we verify the name really contains
        //  a 64 bit value.
        //

        } else {

            //
            //  Check for validity of the buffer.
            //

            if (FileName->Length != sizeof( FILE_ID )) {

                return STATUS_INVALID_PARAMETER;
            }
        }

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FULL_NAME );

    //
    //  If we are in the retry path then the full name is already in the
    //  file object name.  If this is a case-sensitive operation then
    //  we need to upcase the name from the end of any related file name already stored
    //  there.
    //

    } else {

        //
        //  Assume there is no relative name.
        //

        RemainingName->FileName = *FileName;
        RemainingName->VersionString.Length = 0;

        //
        //  Nothing to do if the name length is zero.
        //

        if (RemainingName->FileName.Length != 0) {

            //
            //  If there is a relative name then we need to walk past it.
            //

            if (RelatedTypeOfOpen != UnopenedFileObject) {

                //
                //  Nothing to walk past if the RelatedCcb is opened by FileId.
                //


                if (!FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    //
                    //  Related file name is a proper prefix of the full name.
                    //  We step over the related name and if we are then
                    //  pointing at a separator character we step over that.
                    //

                    RemainingName->FileName.Buffer = Add2Ptr( RemainingName->FileName.Buffer,
                                                              RelatedFileName->Length,
                                                              PWCHAR );

                    RemainingName->FileName.Length -= RelatedFileName->Length;
                }
            }

            //
            //  If we are pointing at a separator character then step past that.
            //

            if (RemainingName->FileName.Length != 0) {

                if (*(RemainingName->FileName.Buffer) == L'\\') {

                    RemainingName->FileName.Buffer = Add2Ptr( RemainingName->FileName.Buffer,
                                                              sizeof( WCHAR ),
                                                              PWCHAR );

                    RemainingName->FileName.Length -= sizeof( WCHAR );
                }
            }
        }

        //
        //  Upcase the name if necessary.
        //

        if (IgnoreCase && (RemainingName->FileName.Length != 0)) {

            CdUpcaseName( IrpContext,
                          RemainingName,
                          RemainingName );
        }
    }

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
CdOpenByFileId (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb
    )

/*++

Routine Description:

    This routine is called to open a file by the FileId.  The file Id is in
    the FileObject name buffer and has been verified to be 64 bits.

    We extract the Id number and then check to see whether we are opening a
    file or directory and compare that with the create options.  If this
    generates no error then optimistically look up the Fcb in the Fcb Table.

    If we don't find the Fcb then we need to carefully verify there is a file
    at this offset.  First check whether the Parent Fcb is in the table.  If
    not then lookup the parent at the path table offset given by file ID.

    If found then build the Fcb from this entry and store the new Fcb in the
    tree.

    We know have the parent Fcb.  Do a directory scan to find the dirent at
    the given offset in this stream.  This must point to the first entry
    of a valid file.

    Finally we call our worker routine to complete the open on this Fcb.

Arguments:

    IrpSp - Stack location within the create Irp.

    Vcb - Vcb for this volume.

    CurrentFcb - Address to store the Fcb for this open.  We only store the
        CurrentFcb here when we have acquired it so our caller knows to
        free or deallocate it.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    NTSTATUS Status = STATUS_ACCESS_DENIED;

    BOOLEAN UnlockVcb = FALSE;
    BOOLEAN Found;

    ULONG StreamOffset;

    NODE_TYPE_CODE NodeTypeCode;
    TYPE_OF_OPEN TypeOfOpen;

    FILE_ENUM_CONTEXT FileContext;
    BOOLEAN CleanupFileContext = FALSE;

    COMPOUND_PATH_ENTRY CompoundPathEntry;
    BOOLEAN CleanupCompoundPathEntry = FALSE;

    FILE_ID FileId;
    FILE_ID ParentFileId;

    PFCB NextFcb;

    PAGED_CODE();

    //
    //  Extract the FileId from the FileObject.
    //

    RtlCopyMemory( &FileId, IrpSp->FileObject->FileName.Buffer, sizeof( FILE_ID ));

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Go ahead and figure out the TypeOfOpen and NodeType.  We can
        //  get these from the input FileId.
        //

        if (CdFidIsDirectory( FileId )) {

            TypeOfOpen = UserDirectoryOpen;
            NodeTypeCode = CDFS_NTC_FCB_INDEX;

            //
            //  If the offset isn't zero then the file Id is bad.
            //

            if (CdQueryFidDirentOffset( FileId ) != 0) {

                try_return( Status = STATUS_INVALID_PARAMETER );
            }

        } else {

            TypeOfOpen = UserFileOpen;
            NodeTypeCode = CDFS_NTC_FCB_DATA;
        }

        //
        //  Acquire the Vcb and check if there is already an Fcb.
        //  If not we will need to carefully verify the Fcb.
        //  We will post the request if we don't find the Fcb and this
        //  request can't wait.
        //

        CdLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;

        NextFcb = CdLookupFcbTable( IrpContext, Vcb, FileId );

        if (NextFcb == NULL) {

            //
            //  Get the path table offset from the file id.
            //

            StreamOffset = CdQueryFidPathTableOffset( FileId );

            //
            //  Build the parent FileId for this and try looking it
            //  up in the PathTable.
            //

            CdSetFidDirentOffset( ParentFileId, 0 );
            CdSetFidPathTableOffset( ParentFileId, StreamOffset );
            CdFidSetDirectory( ParentFileId );

            NextFcb = CdLookupFcbTable( IrpContext, Vcb, ParentFileId );

            //
            //  If not present then walk through the PathTable to this point.
            //

            if (NextFcb == NULL) {

                CdUnlockVcb( IrpContext, Vcb );
                UnlockVcb = FALSE;

                //
                //  Check that the path table offset lies within the path
                //  table.
                //

                if (StreamOffset > Vcb->PathTableFcb->FileSize.LowPart) {

                    try_return( Status = STATUS_INVALID_PARAMETER );
                }

                CdInitializeCompoundPathEntry( IrpContext, &CompoundPathEntry );
                CleanupCompoundPathEntry = TRUE;

                //
                //  Start at the first entry in the PathTable.
                //

                CdLookupPathEntry( IrpContext,
                                   Vcb->PathTableFcb->StreamOffset,
                                   1,
                                   TRUE,
                                   &CompoundPathEntry );

                //
                //  Continue looking until we have passed our target offset.
                //

                while (TRUE) {

                    //
                    //  Move to the next entry.
                    //

                    Found = CdLookupNextPathEntry( IrpContext,
                                                   &CompoundPathEntry.PathContext,
                                                   &CompoundPathEntry.PathEntry );

                    //
                    //  If we didn't find the entry or are beyond it then the
                    //  input Id is invalid.
                    //

                    if (!Found ||
                        (CompoundPathEntry.PathEntry.PathTableOffset > StreamOffset)) {

                        try_return( Status = STATUS_INVALID_PARAMETER );
                    }
                }

                //
                //  If the FileId specified a directory then we have found
                //  the entry.  Make sure our caller wanted to open a directory.
                //

                if ((TypeOfOpen == UserDirectoryOpen) &&
                    FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE )) {

                    try_return( Status = STATUS_FILE_IS_A_DIRECTORY );
                }

                //
                //  Lock the Vcb and create the Fcb if necessary.
                //

                CdLockVcb( IrpContext, Vcb );
                UnlockVcb = TRUE;

                NextFcb = CdCreateFcb( IrpContext, ParentFileId, NodeTypeCode, &Found );

                //
                //  It's possible that someone got in here ahead of us.
                //

                if (!Found) {

                    CdInitializeFcbFromPathEntry( IrpContext,
                                                  NextFcb,
                                                  NULL,
                                                  &CompoundPathEntry.PathEntry );
                }

                //
                //  If the user wanted to open a directory then we have found
                //  it.  Store this Fcb into the CurrentFcb and skip the
                //  directory scan.
                //

                if (TypeOfOpen == UserDirectoryOpen) {

                    *CurrentFcb = NextFcb;
                    NextFcb = NULL;
                }
            }

            //
            //  Perform the directory scan if we don't already have our target.
            //

            if (NextFcb != NULL) {

                //
                //  Acquire the parent.  We currently own the Vcb lock so
                //  do this without waiting first.
                //

                if (!CdAcquireFcbExclusive( IrpContext,
                                            NextFcb,
                                            TRUE )) {

                    NextFcb->FcbReference += 1;
                    CdUnlockVcb( IrpContext, Vcb );

                    CdAcquireFcbExclusive( IrpContext, NextFcb, FALSE );

                    CdLockVcb( IrpContext, Vcb );
                    NextFcb->FcbReference -= 1;
                    CdUnlockVcb( IrpContext, Vcb );

                } else {

                    CdUnlockVcb( IrpContext, Vcb );
                }

                UnlockVcb = FALSE;

                //
                //  Set up the CurrentFcb pointers.  We know there was
                //  no previous parent in this case.
                //

                *CurrentFcb = NextFcb;

                //
                //  Calculate the offset in the stream.
                //

                StreamOffset = CdQueryFidDirentOffset( FileId );

                //
                //  Create the stream file if it doesn't exist.  This will update
                //  the Fcb with the size from the self entry.
                //

                if (NextFcb->FileObject == NULL) {

                    CdCreateInternalStream( IrpContext, Vcb, NextFcb );
                }

                //
                //  If our offset is beyond the end of the directory then the
                //  FileId is invalid.
                //

                if (StreamOffset > NextFcb->FileSize.LowPart) {

                    try_return( Status = STATUS_INVALID_PARAMETER );
                }

                //
                //  Otherwise position ourselves at the self entry and walk
                //  through dirent by dirent until this location is found.
                //

                CdInitializeFileContext( IrpContext, &FileContext );
                CdLookupInitialFileDirent( IrpContext,
                                           NextFcb,
                                           &FileContext,
                                           NextFcb->StreamOffset );

                CleanupFileContext = TRUE;

                while (TRUE) {

                    //
                    //  Move to the first entry of the next file.
                    //

                    Found = CdLookupNextInitialFileDirent( IrpContext,
                                                           NextFcb,
                                                           &FileContext );

                    //
                    //  If we didn't find the entry or are beyond it then the
                    //  input Id is invalid.
                    //

                    if (!Found ||
                        (FileContext.InitialDirent->Dirent.DirentOffset > StreamOffset)) {

                        try_return( Status = STATUS_INVALID_PARAMETER );
                    }
                }

                //
                //  This better not be a directory.  Directory FileIds must
                //  refer to the self entry for directories.
                //

                if (FlagOn( FileContext.InitialDirent->Dirent.DirentFlags,
                            CD_ATTRIBUTE_DIRECTORY )) {

                    try_return( Status = STATUS_INVALID_PARAMETER );
                }

                //
                //  Check that our caller wanted to open a file.
                //

                if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

                    try_return( Status = STATUS_NOT_A_DIRECTORY );
                }

                //
                //  Otherwise we want to collect all of the dirents for this file
                //  and create an Fcb with this.
                //

                CdLookupLastFileDirent( IrpContext, NextFcb, &FileContext );

                CdLockVcb( IrpContext, Vcb );
                UnlockVcb = TRUE;

                NextFcb = CdCreateFcb( IrpContext, FileId, NodeTypeCode, &Found );

                //
                //  It's possible that someone has since created this Fcb since we
                //  first checked.  If so then can simply use this.  Otherwise
                //  we need to initialize a new Fcb and attach it to our parent
                //  and insert it into the Fcb Table.
                //

                if (!Found) {

                    CdInitializeFcbFromFileContext( IrpContext,
                                                    NextFcb,
                                                    *CurrentFcb,
                                                    &FileContext );
                }
            }

        //
        //  We have the Fcb.  Check that the type of the file is compatible with
        //  the desired type of file to open.
        //

        } else {

            if (FlagOn( NextFcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

                if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NON_DIRECTORY_FILE )) {

                    try_return( Status = STATUS_FILE_IS_A_DIRECTORY );
                }

            } else if (FlagOn( IrpSp->Parameters.Create.Options, FILE_DIRECTORY_FILE )) {

                try_return( Status = STATUS_NOT_A_DIRECTORY );
            }
        }

        //
        //  If we have a the previous Fcb and have inserted the next Fcb into
        //  the Fcb Table.  It is safe to release the current Fcb if present
        //  since it is referenced through the child Fcb.
        //

        if (*CurrentFcb != NULL) {

            CdReleaseFcb( IrpContext, *CurrentFcb );
        }

        //
        //  We now know the Fcb and currently hold the Vcb lock.
        //  Try to acquire this Fcb without waiting.  Otherwise we
        //  need to reference it, drop the Vcb, acquire the Fcb and
        //  then dereference the Fcb.
        //

        if (!CdAcquireFcbExclusive( IrpContext, NextFcb, TRUE )) {

            NextFcb->FcbReference += 1;

            CdUnlockVcb( IrpContext, Vcb );

            CdAcquireFcbExclusive( IrpContext, NextFcb, FALSE );

            CdLockVcb( IrpContext, Vcb );
            NextFcb->FcbReference -= 1;
            CdUnlockVcb( IrpContext, Vcb );

        } else {

            CdUnlockVcb( IrpContext, Vcb );
        }

        UnlockVcb = FALSE;

        //
        //  Move to this Fcb.
        //

        *CurrentFcb = NextFcb;

        //
        //  Check the requested access on this Fcb.
        //

        if (!CdIllegalFcbAccess( IrpContext,
                                 TypeOfOpen,
                                 IrpSp->Parameters.Create.SecurityContext->DesiredAccess )) {

            //
            //  Call our worker routine to complete the open.
            //

            Status = CdCompleteFcbOpen( IrpContext,
                                        IrpSp,
                                        Vcb,
                                        CurrentFcb,
                                        TypeOfOpen,
                                        CCB_FLAG_OPEN_BY_ID,
                                        IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
        }

    try_exit:  NOTHING;
    } finally {

        if (UnlockVcb) {

            CdUnlockVcb( IrpContext, Vcb );
        }

        if (CleanupFileContext) {

            CdCleanupFileContext( IrpContext, &FileContext );
        }

        if (CleanupCompoundPathEntry) {

            CdCleanupCompoundPathEntry( IrpContext, &CompoundPathEntry );
        }
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdOpenExistingFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT PFCB *CurrentFcb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN IgnoreCase,
    IN PCCB RelatedCcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to open an Fcb which is already in the Fcb table.
    We will verify the access to the file and then call our worker routine
    to perform the final operations.

Arguments:

    IrpSp - Pointer to the stack location for this open.

    CurrentFcb - Address of Fcb to open.  We will clear this if the Fcb
        is released here.

    TypeOfOpen - Indicates whether we are opening a file, directory or volume.

    IgnoreCase - Indicates if this open is case-insensitive.

    RelatedCcb - Ccb for related file object if relative open.  We use
        this when setting the Ccb flags for this open.  It will tell
        us whether the name currently in the file object is relative or
        absolute.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    ULONG CcbFlags = 0;

    NTSTATUS Status = STATUS_ACCESS_DENIED;

    PAGED_CODE();

    //
    //  Check that the desired access is legal.
    //

    if (!CdIllegalFcbAccess( IrpContext,
                             TypeOfOpen,
                             IrpSp->Parameters.Create.SecurityContext->DesiredAccess )) {

        //
        //  Set the Ignore case.
        //

        if (IgnoreCase) {

            SetFlag( CcbFlags, CCB_FLAG_IGNORE_CASE );
        }

        //
        //  Check the related Ccb to see if this was an OpenByFileId and
        //  whether there was a version.
        //

        if (ARGUMENT_PRESENT( RelatedCcb )) {

            SetFlag( CcbFlags, FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_WITH_VERSION ));


            if (FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID | CCB_FLAG_OPEN_RELATIVE_BY_ID )) {

                SetFlag( CcbFlags, CCB_FLAG_OPEN_RELATIVE_BY_ID );
            }
        }

        //
        //  Call our worker routine to complete the open.
        //

        Status = CdCompleteFcbOpen( IrpContext,
                                    IrpSp,
                                    (*CurrentFcb)->Vcb,
                                    CurrentFcb,
                                    TypeOfOpen,
                                    CcbFlags,
                                    IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdOpenDirectoryFromPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN PCD_NAME DirName,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortNameMatch,
    IN PPATH_ENTRY PathEntry,
    IN BOOLEAN PerformUserOpen,
    IN PCCB RelatedCcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to open a directory where the directory was found
    in the path table.  This routine is called in the case where this is the
    file to open for the user and where this is an intermediate node in the
    full path to open.

    We first check that the desired access is legal for a directory.  Then we
    construct the FileId for this and do a check to see if it is the Fcb
    Table.  It is always possible that either it was created since or simply
    wasn't in the prefix table at the time of the prefix table search.
    Initialize the Fcb and store into the FcbTable if not present.

    Next we will add this to the prefix table of our parent if needed.

    Once we know that the new Fcb has been initialized then we move our pointer
    in the tree down to this position.

    This routine does not own the Vcb lock on entry.  We must be sure to release
    it on exit.

Arguments:

    IrpSp - Stack location for this request.

    Vcb - Vcb for this volume.

    CurrentFcb - On input this is the parent of the Fcb to open.  On output we
        store the Fcb for the file being opened.

    DirName - This is always the exact name used to reach this file.

    IgnoreCase - Indicates the type of case match for the open.

    ShortNameMatch - Indicates if we are opening via the short name.

    PathEntry - Path entry for the entry found.

    PerformUserOpen - TRUE if we are to open this for a user, FALSE otherwise.

    RelatedCcb - RelatedCcb for relative file object used to make this open.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    ULONG CcbFlags = 0;
    FILE_ID FileId;

    BOOLEAN UnlockVcb = FALSE;
    BOOLEAN FcbExisted;

    PFCB NextFcb;
    PFCB ParentFcb = NULL;

    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Check for illegal access to this file.
    //

    if (PerformUserOpen &&
        CdIllegalFcbAccess( IrpContext,
                            UserDirectoryOpen,
                            IrpSp->Parameters.Create.SecurityContext->DesiredAccess )) {

        return STATUS_ACCESS_DENIED;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Check the related Ccb to see if this was an OpenByFileId.
        //

        if (ARGUMENT_PRESENT( RelatedCcb ) &&
            FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID | CCB_FLAG_OPEN_RELATIVE_BY_ID )) {

            CcbFlags = CCB_FLAG_OPEN_RELATIVE_BY_ID;
        }

        if (IgnoreCase) {

            SetFlag( CcbFlags, CCB_FLAG_IGNORE_CASE );
        }

        //
        //  Build the file Id for this file.
        //

        FileId.QuadPart = 0;
        CdSetFidPathTableOffset( FileId, PathEntry->PathTableOffset );
        CdFidSetDirectory( FileId );

        //
        //  Lock the Vcb so we can examine the Fcb Table.
        //

        CdLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;

        //
        //  Get the Fcb for this directory.
        //

        NextFcb = CdCreateFcb( IrpContext, FileId, CDFS_NTC_FCB_INDEX, &FcbExisted );

        //
        //  If the Fcb was created here then initialize from the values in the
        //  path table entry.
        //

        if (!FcbExisted) {

            CdInitializeFcbFromPathEntry( IrpContext, NextFcb, *CurrentFcb, PathEntry );
        }

        //
        //  Now try to acquire the new Fcb without waiting.  We will reference
        //  the Fcb and retry with wait if unsuccessful.
        //

        if (!CdAcquireFcbExclusive( IrpContext, NextFcb, TRUE )) {

            NextFcb->FcbReference += 1;

            CdUnlockVcb( IrpContext, Vcb );

            CdReleaseFcb( IrpContext, *CurrentFcb );
            CdAcquireFcbExclusive( IrpContext, NextFcb, FALSE );
            CdAcquireFcbExclusive( IrpContext, *CurrentFcb, FALSE );

            CdLockVcb( IrpContext, Vcb );
            NextFcb->FcbReference -= 1;
            CdUnlockVcb( IrpContext, Vcb );

        } else {

            //
            //  Unlock the Vcb and move down to this new Fcb.  Remember that we still
            //  own the parent however.
            //

            CdUnlockVcb( IrpContext, Vcb );
        }

        UnlockVcb = FALSE;

        ParentFcb = *CurrentFcb;
        *CurrentFcb = NextFcb;

        //
        //  Store this name into the prefix table for the parent.
        //

        if (ShortNameMatch) {

            //
            //  Make sure the exact case is always in the tree.
            //

            CdInsertPrefix( IrpContext,
                            NextFcb,
                            DirName,
                            FALSE,
                            TRUE,
                            ParentFcb );

            if (IgnoreCase) {

                CdInsertPrefix( IrpContext,
                                NextFcb,
                                DirName,
                                TRUE,
                                TRUE,
                                ParentFcb );
            }

        } else {

            //
            //  Make sure the exact case is always in the tree.
            //

            CdInsertPrefix( IrpContext,
                            NextFcb,
                            &PathEntry->CdDirName,
                            FALSE,
                            FALSE,
                            ParentFcb );

            if (IgnoreCase) {

                CdInsertPrefix( IrpContext,
                                NextFcb,
                                &PathEntry->CdCaseDirName,
                                TRUE,
                                FALSE,
                                ParentFcb );
            }
        }

        //
        //  Release the parent Fcb at this point.
        //

        CdReleaseFcb( IrpContext, ParentFcb );
        ParentFcb = NULL;

        //
        //  Call our worker routine to complete the open.
        //

        if (PerformUserOpen) {

            Status = CdCompleteFcbOpen( IrpContext,
                                        IrpSp,
                                        Vcb,
                                        CurrentFcb,
                                        UserDirectoryOpen,
                                        CcbFlags,
                                        IrpSp->Parameters.Create.SecurityContext->DesiredAccess );
        }

    } finally {

        //
        //  Unlock the Vcb if held.
        //

        if (UnlockVcb) {

            CdUnlockVcb( IrpContext, Vcb );
        }

        //
        //  Release the parent if held.
        //

        if (ParentFcb != NULL) {

            CdReleaseFcb( IrpContext, ParentFcb );
        }
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdOpenFileFromFileContext (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN PCD_NAME FileName,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortNameMatch,
    IN PFILE_ENUM_CONTEXT FileContext,
    IN PCCB RelatedCcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to open a file where the file was found in a directory scan.
    This should only be for a file in the case since we will find the directories in the
    path table.

    We first check that the desired access is legal for this file.  Then we
    construct the FileId for this and do a check to see if it is the Fcb
    Table.  It is always possible that either it was created since or simply
    wasn't in the prefix table at the time of the prefix table search.
    Initialize the Fcb and store into the FcbTable if not present.

    Next we will add this to the prefix table of our parent if needed.

    Once we know that the new Fcb has been initialized then we move our pointer
    in the tree down to this position.

    This routine does not own the Vcb lock on entry.  We must be sure to release
    it on exit.

Arguments:

    IrpSp - Stack location for this request.

    Vcb - Vcb for the current volume.

    CurrentFcb - On input this is the parent of the Fcb to open.  On output we
        store the Fcb for the file being opened.

    FileName - This is always the exact name used to reach this file.

    IgnoreCase - Indicates the type of case of CaseName above.

    ShortNameMatch - Indicates if we are opening via the short name.

    FileContext - This is the context used to find the file.

    RelatedCcb - RelatedCcb for relative file object used to make this open.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    ULONG CcbFlags = 0;
    FILE_ID FileId;

    BOOLEAN UnlockVcb = FALSE;
    BOOLEAN FcbExisted;

    PFCB NextFcb;
    PFCB ParentFcb = NULL;

    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Check for illegal access to this file.
    //

    if (CdIllegalFcbAccess( IrpContext,
                            UserFileOpen,
                            IrpSp->Parameters.Create.SecurityContext->DesiredAccess )) {

        return STATUS_ACCESS_DENIED;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Check if a version number was used to open this file.
        //

        if (FileName->VersionString.Length != 0) {

            SetFlag( CcbFlags, CCB_FLAG_OPEN_WITH_VERSION );
        }

        //
        //  Check the related Ccb to see if this was an OpenByFileId.
        //

        if (ARGUMENT_PRESENT( RelatedCcb ) &&
            FlagOn( RelatedCcb->Flags, CCB_FLAG_OPEN_BY_ID | CCB_FLAG_OPEN_RELATIVE_BY_ID )) {

            SetFlag( CcbFlags, CCB_FLAG_OPEN_RELATIVE_BY_ID );
        }

        if (IgnoreCase) {

            SetFlag( CcbFlags, CCB_FLAG_IGNORE_CASE );
        }

        //
        //  Build the file Id for this file.  We can use the path table offset from the
        //  parent and the directory offset from the dirent.
        //

        CdSetFidPathTableOffset( FileId, CdQueryFidPathTableOffset( (*CurrentFcb)->FileId ));
        CdSetFidDirentOffset( FileId, FileContext->InitialDirent->Dirent.DirentOffset );

        //
        //  Lock the Vcb so we can examine the Fcb Table.
        //

        CdLockVcb( IrpContext, Vcb );
        UnlockVcb = TRUE;

        //
        //  Get the Fcb for this file.
        //

        NextFcb = CdCreateFcb( IrpContext, FileId, CDFS_NTC_FCB_DATA, &FcbExisted );

        //
        //  If the Fcb was created here then initialize from the values in the
        //  dirent.
        //

        if (!FcbExisted) {

            CdInitializeFcbFromFileContext( IrpContext,
                                            NextFcb,
                                            *CurrentFcb,
                                            FileContext );
        }

        //
        //  Now try to acquire the new Fcb without waiting.  We will reference
        //  the Fcb and retry with wait if unsuccessful.
        //

        if (!CdAcquireFcbExclusive( IrpContext, NextFcb, TRUE )) {

            NextFcb->FcbReference += 1;

            CdUnlockVcb( IrpContext, Vcb );

            CdReleaseFcb( IrpContext, *CurrentFcb );
            CdAcquireFcbExclusive( IrpContext, NextFcb, FALSE );
            CdAcquireFcbExclusive( IrpContext, *CurrentFcb, FALSE );

            CdLockVcb( IrpContext, Vcb );
            NextFcb->FcbReference -= 1;
            CdUnlockVcb( IrpContext, Vcb );

        } else {

            //
            //  Unlock the Vcb and move down to this new Fcb.  Remember that we still
            //  own the parent however.
            //

            CdUnlockVcb( IrpContext, Vcb );
        }

        UnlockVcb = FALSE;

        ParentFcb = *CurrentFcb;
        *CurrentFcb = NextFcb;

        //
        //  Store this name into the prefix table for the parent.
        //


        if (ShortNameMatch) {

            //
            //  Make sure the exact case is always in the tree.
            //

            CdInsertPrefix( IrpContext,
                            NextFcb,
                            FileName,
                            FALSE,
                            TRUE,
                            ParentFcb );

            if (IgnoreCase) {

                CdInsertPrefix( IrpContext,
                                NextFcb,
                                FileName,
                                TRUE,
                                TRUE,
                                ParentFcb );
            }

        //
        //  Insert this into the prefix table if we found this without
        //  using a version string.
        //

        } else if (FileName->VersionString.Length == 0) {

            //
            //  Make sure the exact case is always in the tree.
            //

            CdInsertPrefix( IrpContext,
                            NextFcb,
                            &FileContext->InitialDirent->Dirent.CdFileName,
                            FALSE,
                            FALSE,
                            ParentFcb );

            if (IgnoreCase) {

                CdInsertPrefix( IrpContext,
                                NextFcb,
                                &FileContext->InitialDirent->Dirent.CdCaseFileName,
                                TRUE,
                                FALSE,
                                ParentFcb );
            }
        }

        //
        //  Release the parent Fcb at this point.
        //

        CdReleaseFcb( IrpContext, ParentFcb );
        ParentFcb = NULL;

        //
        //  Call our worker routine to complete the open.
        //

        Status = CdCompleteFcbOpen( IrpContext,
                                    IrpSp,
                                    Vcb,
                                    CurrentFcb,
                                    UserFileOpen,
                                    CcbFlags,
                                    IrpSp->Parameters.Create.SecurityContext->DesiredAccess );

    } finally {

        //
        //  Unlock the Vcb if held.
        //

        if (UnlockVcb) {

            CdUnlockVcb( IrpContext, Vcb );
        }

        //
        //  Release the parent if held.
        //

        if (ParentFcb != NULL) {

            CdReleaseFcb( IrpContext, ParentFcb );
        }
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdCompleteFcbOpen (
    IN PIRP_CONTEXT IrpContext,
    PIO_STACK_LOCATION IrpSp,
    IN PVCB Vcb,
    IN OUT PFCB *CurrentFcb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN ULONG UserCcbFlags,
    IN ACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This is the worker routine which takes an existing Fcb and completes
    the open.  We will do any necessary oplock checks and sharing checks.
    Finally we will create the Ccb and update the file object and any
    file object flags.

Arguments:

    IrpSp - Stack location for the current request.

    Vcb - Vcb for the current volume.

    CurrentFcb - Address of pointer to Fcb to open.  We clear this field if
        we release the resource for this file.

    TypeOfOpen - Type of open for this request.

    UserCcbFlags - Flags to OR into the Ccb flags.

    DesiredAccess - Desired access for this open.

Return Value:

    NTSTATUS - STATUS_SUCCESS if we complete this request, STATUS_PENDING if
        the oplock package takes the Irp or SHARING_VIOLATION if there is a
        sharing check conflict.

--*/

{
    NTSTATUS Status;
    NTSTATUS OplockStatus  = STATUS_SUCCESS;
    ULONG Information = FILE_OPENED;

    BOOLEAN LockVolume = FALSE;

    PFCB Fcb = *CurrentFcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Expand maximum allowed to something sensible for share access checking
    //

    if (MAXIMUM_ALLOWED == DesiredAccess)  {
    
        DesiredAccess = FILE_ALL_ACCESS & ~((TypeOfOpen != UserVolumeOpen ?
                                             (FILE_WRITE_ATTRIBUTES           |
                                              FILE_WRITE_DATA                 |
                                              FILE_WRITE_EA                   |
                                              FILE_ADD_FILE                   |                     
                                              FILE_ADD_SUBDIRECTORY           |
                                              FILE_APPEND_DATA) : 0)          |
                                            FILE_DELETE_CHILD                 |
                                            DELETE                            |
                                            WRITE_DAC );
    }

    //
    //  If this a volume open and the user wants to lock the volume then
    //  purge and lock the volume.
    //

    if ((TypeOfOpen <= UserVolumeOpen) &&
        !FlagOn( IrpSp->Parameters.Create.ShareAccess, FILE_SHARE_READ )) {

        //
        //  If there are open handles then fail this immediately.
        //

        if (Vcb->VcbCleanup != 0) {

            return STATUS_SHARING_VIOLATION;
        }

        //
        //  If we can't wait then force this to be posted.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

            CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
        }

        LockVolume = TRUE;

        //
        //  Purge the volume and make sure all of the user references
        //  are gone.
        //

        Status = CdPurgeVolume( IrpContext, Vcb, FALSE );

        if (Status != STATUS_SUCCESS) {

            return Status;
        }

        //
        //  Now force all of the delayed close operations to go away.
        //

        CdFspClose( Vcb );

        if (Vcb->VcbUserReference > CDFS_RESIDUAL_USER_REFERENCE) {

            return STATUS_SHARING_VIOLATION;
        }
    }
    
    //
    //  If the Fcb already existed then we need to check the oplocks and
    //  the share access.
    //

    if (Fcb->FcbCleanup != 0) {

        //
        //  If this is a user file open then check whether there are any
        //  batch oplock.
        //

        if (TypeOfOpen == UserFileOpen) {

            //
            //  Store the address of the Fcb for a possible teardown into
            //  the IrpContext.  We will release this in the call to
            //  prepost the Irp.
            //

            IrpContext->TeardownFcb = CurrentFcb;

            if (FsRtlCurrentBatchOplock( &Fcb->Oplock )) {

                //
                //  We remember if a batch oplock break is underway for the
                //  case where the sharing check fails.
                //

                Information = FILE_OPBATCH_BREAK_UNDERWAY;

                OplockStatus = FsRtlCheckOplock( &Fcb->Oplock,
                                                 IrpContext->Irp,
                                                 IrpContext,
                                                 CdOplockComplete,
                                                 CdPrePostIrp );

                if (OplockStatus == STATUS_PENDING) {

                    return STATUS_PENDING;
                }
            }

            //
            //  Check the share access before breaking any exclusive oplocks.
            //

            Status = IoCheckShareAccess( DesiredAccess,
                                         IrpSp->Parameters.Create.ShareAccess,
                                         IrpSp->FileObject,
                                         &Fcb->ShareAccess,
                                         FALSE );

            if (!NT_SUCCESS( Status )) {

                return Status;
            }

            //
            //  Now check that we can continue based on the oplock state of the
            //  file.
            //

            OplockStatus = FsRtlCheckOplock( &Fcb->Oplock,
                                             IrpContext->Irp,
                                             IrpContext,
                                             CdOplockComplete,
                                             CdPrePostIrp );

            if (OplockStatus == STATUS_PENDING) {

                return STATUS_PENDING;
            }

            IrpContext->TeardownFcb = NULL;

        //
        //  Otherwise just do the sharing check.
        //

        } else {

            Status = IoCheckShareAccess( DesiredAccess,
                                         IrpSp->Parameters.Create.ShareAccess,
                                         IrpSp->FileObject,
                                         &Fcb->ShareAccess,
                                         FALSE );

            if (!NT_SUCCESS( Status )) {

                return Status;
            }
        }
    }

    //
    //  Create the Ccb now.
    //

    Ccb = CdCreateCcb( IrpContext, Fcb, UserCcbFlags );

    //
    //  Update the share access.
    //

    if (Fcb->FcbCleanup == 0) {

        IoSetShareAccess( DesiredAccess,
                          IrpSp->Parameters.Create.ShareAccess,
                          IrpSp->FileObject,
                          &Fcb->ShareAccess );

    } else {

        IoUpdateShareAccess( IrpSp->FileObject, &Fcb->ShareAccess );
    }

    //
    //  Set the file object type.
    //

    CdSetFileObject( IrpContext, IrpSp->FileObject, TypeOfOpen, Fcb, Ccb );

    //
    //  Set the appropriate cache flags for a user file object.
    //

    if (TypeOfOpen == UserFileOpen) {

        if (FlagOn( IrpSp->Parameters.Create.Options, FILE_NO_INTERMEDIATE_BUFFERING )) {

            SetFlag( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING );

        } else {

            SetFlag( IrpSp->FileObject->Flags, FO_CACHE_SUPPORTED );
        }
    }
    else if (TypeOfOpen == UserVolumeOpen)  {

        SetFlag( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING );
    }

    //
    //  Update the open and cleanup counts.  Check the fast io state here.
    //

    CdLockVcb( IrpContext, Vcb );

    CdIncrementCleanupCounts( IrpContext, Fcb );
    CdIncrementReferenceCounts( IrpContext, Fcb, 1, 1 );

    if (LockVolume) {

        Vcb->VolumeLockFileObject = IrpSp->FileObject;
        SetFlag( Vcb->VcbState, VCB_STATE_LOCKED );
    }

    CdUnlockVcb( IrpContext, Vcb );

    CdLockFcb( IrpContext, Fcb );

    if (TypeOfOpen == UserFileOpen) {

        Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );

    } else {

        Fcb->IsFastIoPossible = FastIoIsNotPossible;
    }

    CdUnlockFcb( IrpContext, Fcb );

    //
    //  Show that we opened the file.
    //

    IrpContext->Irp->IoStatus.Information = Information;

    //
    //  Point to the section object pointer in the non-paged Fcb.
    //

    IrpSp->FileObject->SectionObjectPointer = &Fcb->FcbNonpaged->SegmentObject;
    return OplockStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\devctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DevCtrl.c

Abstract:

    This module implements the File System Device Control routines for Cdfs
    called by the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   04-Mar-1991

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_DEVCTRL)

//
//  Local support routines
//

NTSTATUS
CdDevCtrlCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonDevControl)
#endif


NTSTATUS
CdCommonDevControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS Status;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PIO_STACK_LOCATION IrpSp;
    PIO_STACK_LOCATION NextIrpSp;

    PVOID TargetBuffer = NULL;

    PAGED_CODE();

    //
    //  Extract and decode the file object.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TypeOfOpen = CdDecodeFileObject( IrpContext,
                                     IrpSp->FileObject,
                                     &Fcb,
                                     &Ccb );

    //
    //  The only type of opens we accept are user volume opens.
    //

    if (TypeOfOpen != UserVolumeOpen) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_READ_TOC) {

        //
        //  Verify the Vcb in this case to detect if the volume has changed.
        //

        CdVerifyVcb( IrpContext, Fcb->Vcb );

    //
    //  Handle the case of the disk type ourselves.
    //

    } else if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_CDROM_DISK_TYPE) {

        //
        //  Verify the Vcb in this case to detect if the volume has changed.
        //

        CdVerifyVcb( IrpContext, Fcb->Vcb );

        //
        //  Check the size of the output buffer.
        //

        if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof( CDROM_DISK_DATA )) {

            CdCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        //  Copy the data from the Vcb.
        //

        ((PCDROM_DISK_DATA) Irp->AssociatedIrp.SystemBuffer)->DiskData = Fcb->Vcb->DiskFlags;

        Irp->IoStatus.Information = sizeof( CDROM_DISK_DATA );
        CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Get the next stack location, and copy over the stack parameter
    //  information.
    //

    NextIrpSp = IoGetNextIrpStackLocation( Irp );

    *NextIrpSp = *IrpSp;

    //
    //  Set up the completion routine
    //

    IoSetCompletionRoutine( Irp,
                            CdDevCtrlCompletionRoutine,
                            NULL,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request.
    //

    Status = IoCallDriver( IrpContext->Vcb->TargetDeviceObject, Irp );

    //
    //  Cleanup our Irp Context.  The driver has completed the Irp.
    //

    CdCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdDevCtrlCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    //
    //  Add the hack-o-ramma to fix formats.
    //

    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );
    }

    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Contxt );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\cdstruc.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    CdStruc.h

Abstract:

    This module defines the data structures that make up the major internal
    part of the Cdfs file system.

    In-Memory structures:

        The global data structures with the CdDataRecord.  It contains a pointer
        to a File System Device object and a queue of Vcb's.  There is a Vcb for
        every currently or previously mounted volumes.  We may be in the process
        of tearing down the Vcb's which have been dismounted.  The Vcb's are
        allocated as an extension to a volume device object.

            +--------+
            | CdData |     +--------+
            |        | --> |FilSysDo|
            |        |     |        |
            |        | <+  +--------+
            +--------+  |
                        |
                        |  +--------+     +--------+
                        |  |VolDo   |     |VolDo   |
                        |  |        |     |        |
                        |  +--------+     +--------+
                        +> |Vcb     | <-> |Vcb     | <-> ...
                           |        |     |        |
                           +--------+     +--------+


        Each Vcb contains a table of all the Fcbs for the volume indexed by
        their FileId.  Each Vcb contains a pointer to the root directory of
        the volume.  Each directory Fcb contains a queue of child Fcb's for
        its children.  There can also be detached subtrees due to open operations
        by Id where the Fcb's are not connected to the root.

        The following diagram shows the root structure.

            +--------+     +--------+
            |  Vcb   |---->| Fcb    |-----------------------------------------------+
            |        |     |  Table |--------------------------------------------+  |                                   |
            |        |--+  |        |-----------------------------------------+  |  |                                   |
            +--------+  |  +--------+                                         |  |  |
                        |    |  |  |                                          |  |  |
                        |    |  |  +--------------------+                     |  |  |
                        |    V  +---------+             |                     |  |  |
                        |  +--------+     |             |                     |  |  |
                        |  |RootFcb |     V             V                     |  |  |
                        +->|        |   +--------+    +--------+              |  |  |
                           |        |-->|Child   |    |Child   |              |  |  |
                           +--------+   | Fcb    |<-->| Fcb    |<--> ...      |  |  |
                                        |        |    |        |              |  |  |
                                        +--------+    +--------+              |  |  |
                                                                              |  |  |
                          (Freestanding sub-tree)                             |  |  |
                          +--------+                                          |  |  |
                          |OpenById|<-----------------------------------------+  |  |
                          | Dir    |    +--------+                               |  |
                          |        |--->|OpenById|<------------------------------+  |
                          +--------+    | Child  |    +--------+                    |
                                        |  Dir   |--->|OpenById|<-------------------+
                                        +--------+    | Child  |
                                                      |  File  |
                                                      +--------+

        Attached to each Directory Fcb is a prefix table containing the names
        of children of this directory for which there is an Fcb.  Not all Fcb's
        will necessarily have an entry in this table.

            +--------+      +--------+
            |  Dir   |      | Prefix |
            |   Fcb  |----->|  Table |--------------------+
            |        |      |        |-------+            |
            +--------+      +--------+       |            |
                |              |             |            |
                |              |             |            |
                |              V             V            V
                |           +--------+    +--------+    +--------+    +--------+
                |           |  Fcb   |    |  Fcb   |    |  Fcb   |    |  Fcb   |
                +---------->|        |<-->|        |<-->|        |<-->|        |
                            |        |    |        |    |        |    |        |
                            +--------+    +--------+    +--------+    +--------+


        Each file object open on a CDROM volume contains two context pointers.  The
        first will point back to the Fcb for the file object.  The second, if present,
        points to a Ccb (ContextControlBlock) which contains the per-handle information.
        This includes the state of any directory enumeration.

          +--------+       +--------+    +--------+
          |  Fcb   |<------| File   |    |  Ccb   |
          |        |       |  Object|--->|        |
          |        |       |        |    |        |
          +--------+       +--------+    +--------+
            ^    ^
            |    |         +--------+    +--------+
            |    |         | File   |    |  Ccb   |
            |    +---------|  Object|--->|        |
            |              |        |    |        |
            |              +--------+    +--------+
            |
            |              +--------+
            |              |Stream  |
            +--------------| File   |
                           |  Object|
                           +--------+


    Synchronization:

        1. A resource in the CdData synchronizes access to the Vcb queue.  This
            is used during mount/verify/dismount operations.

        2. A resource in the Vcb is used to synchronize access to Vcb for
            open/close operations.  Typically acquired shared, it
            is acquired exclusively to lock out these operations.

        3. A second resource in the Vcb is used to synchronize all file operations.
            Typically acquired shared, it is acquired exclusively to lock
            out all file operations.  Acquiring both Vcb resources will lock
            the entire volume.

        4. A resource in the nonpaged Fcb will synchronize open/close operations
            on an Fcb.

        5. A fast mutex in the Vcb will protect access to the Fcb table and
            the open counts in the Vcb.  It is also used to modify the reference
            counts in all Fcbs.  This mutex cannot be acquired
            exclusely and is an end resource.

        6. A fast mutex in the Fcb will synchronize access to all Fcb fields
            which aren't synchronized in some other way.  A thread may acquire
            mutexes for multiple Fcb's as long as it works it way toward the
            root of the tree.  This mutex can also be acquired recursively.

        7. Normal locking order is CdData/Vcb/Fcb starting at any point in this
            chain.  The Vcb is required prior to acquiring resources for multiple
            files.  Shared ownership of the Vcb is sufficient in this case.

        8. Normal locking order when acquiring multiple Fcb's is from some
            starting Fcb and walking towards the root of tree.  Create typically
            walks down the tree.  In this case we will attempt to acquire the
            next node optimistically and if that fails we will reference
            the current node in the tree, release it and acquire the next node.
            At that point it will be safe to reacquire the parent node.

        9. Locking order for the Fcb (via the fast mutex) will be from leaf of
            tree back towards the root.  No other resource may be acquired
            after locking the Vcb (other than in-page reads).

       10. Cleanup operations only lock the Vcb and Fcb long enough to change the
            critical counts and share access fields.  No reason to synchronize
            otherwise.  None of the structures can go away from beneath us
            in this case.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _CDSTRUC_
#define _CDSTRUC_

typedef PVOID PBCB;     //**** Bcb's are now part of the cache module

#define BYTE_COUNT_EMBEDDED_NAME        (32)


//
//  The CD_MCB is used to store the mapping of logical file offset to
//  logical disk offset.  NOTE - This package only deals with the
//  logical 2048 sectors.  Translating to 'raw' sectors happens in
//  software.  We will embed a single MCB_ENTRY in the Fcb since this
//  will be the typical case.
//

typedef struct _CD_MCB {

    //
    //  Size and current count of the Mcb entries.
    //

    ULONG MaximumEntryCount;
    ULONG CurrentEntryCount;

    //
    //  Pointer to the start of the Mcb entries.
    //

    struct _CD_MCB_ENTRY *McbArray;

} CD_MCB;
typedef CD_MCB *PCD_MCB;

typedef struct _CD_MCB_ENTRY {

    //
    //  Starting offset and number of bytes described by this entry.
    //  The Byte count is rounded to a logical block boundary if this is
    //  the last block.
    //

    LONGLONG DiskOffset;
    LONGLONG ByteCount;

    //
    //  Starting offset in the file of mapping described by this dirent.
    //

    LONGLONG FileOffset;

    //
    //  Data length and block length.  Data length is the length of each
    //  data block.  Total length is the length of each data block and
    //  the skip size.
    //

    LONGLONG DataBlockByteCount;
    LONGLONG TotalBlockByteCount;

} CD_MCB_ENTRY;
typedef CD_MCB_ENTRY *PCD_MCB_ENTRY;


//
//  Cd name structure.  The following structure is used to represent the
//  full Cdrom name.  This name can be stored in either Unicode or ANSI
//  format.
//

typedef struct _CD_NAME {

    //
    //  String containing name without the version number.
    //  The maximum length field for filename indicates the
    //  size of the buffer allocated for the two parts of the name.
    //

    UNICODE_STRING FileName;

    //
    //  String containging the version number.
    //

    UNICODE_STRING VersionString;

} CD_NAME;
typedef CD_NAME *PCD_NAME;

//
//  Following is the splay link structure for the prefix lookup.
//  The names can be in either Unicode string or Ansi string format.
//

typedef struct _NAME_LINK {

    RTL_SPLAY_LINKS Links;
    UNICODE_STRING FileName;

} NAME_LINK;
typedef NAME_LINK *PNAME_LINK;


//
//  Prefix entry.  There is one of these for each name in the prefix table.
//  An Fcb will have one of these embedded for the long name and an optional
//  pointer to the short name entry.
//

typedef struct _PREFIX_ENTRY {

    //
    //  Pointer to the Fcb for this entry.
    //

    struct _FCB *Fcb;

    //
    //  Flags field.  Used to indicate if the name is in the prefix table.
    //

    ULONG PrefixFlags;

    //
    //  Exact case name match.
    //

    NAME_LINK ExactCaseName;

    //
    //  Case-insensitive name link.
    //

    NAME_LINK IgnoreCaseName;

    WCHAR FileNameBuffer[ BYTE_COUNT_EMBEDDED_NAME ];

} PREFIX_ENTRY;
typedef PREFIX_ENTRY *PPREFIX_ENTRY;

#define PREFIX_FLAG_EXACT_CASE_IN_TREE              (0x00000001)
#define PREFIX_FLAG_IGNORE_CASE_IN_TREE             (0x00000002)


//
//  The CD_DATA record is the top record in the CDROM file system in-memory
//  data structure.  This structure must be allocated from non-paged pool.
//

typedef struct _CD_DATA {

    //
    //  The type and size of this record (must be CDFS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  A pointer to the Driver object we were initialized with
    //

    PDRIVER_OBJECT DriverObject;

    //
    //  Vcb queue.
    //

    LIST_ENTRY VcbQueue;

    //
    //  The following fields are used to allocate IRP context structures
    //  using a lookaside list, and other fixed sized structures from a
    //  small cache.  We use the CdData mutex to protext these structures.
    //

    ULONG IrpContextDepth;
    ULONG IrpContextMaxDepth;
    SINGLE_LIST_ENTRY IrpContextList;

    //
    //  Filesystem device object for CDFS.
    //

    PDEVICE_OBJECT FileSystemDeviceObject;

    //
    //  Following are used to manage the async and delayed close queue.
    //
    //  FspCloseActive - Indicates whether there is a thread processing the
    //      two close queues.
    //  ReduceDelayedClose - Indicates that we have hit the upper threshold
    //      for the delayed close queue and need to reduce it to lower threshold.
    //
    //  AsyncCloseQueue - Queue of IrpContext waiting for async close operation.
    //  AsyncCloseCount - Number of entries on the async close queue.
    //
    //  DelayedCloseQueue - Queue of IrpContextLite waiting for delayed close
    //      operation.
    //  MaxDelayedCloseCount - Trigger delay close work at this threshold.
    //  MinDelayedCloseCount - Turn off delay close work at this threshold.
    //  DelayedCloseCount - Number of entries on the delayted close queue.
    //
    //  CloseItem - Workqueue item used to start FspClose thread.
    //

    LIST_ENTRY AsyncCloseQueue;
    ULONG AsyncCloseCount;
    BOOLEAN FspCloseActive;
    BOOLEAN ReduceDelayedClose;
    USHORT PadUshort;

    //
    //  The following fields describe the deferred close file objects.
    //

    LIST_ENTRY DelayedCloseQueue;
    ULONG DelayedCloseCount;
    ULONG MaxDelayedCloseCount;
    ULONG MinDelayedCloseCount;

    //
    //  Fast mutex used to lock the fields of this structure.
    //

    PVOID CdDataLockThread;
    FAST_MUTEX CdDataMutex;

    //
    //  A resource variable to control access to the global CDFS data record
    //

    ERESOURCE DataResource;

    //
    //  Cache manager call back structure, which must be passed on each call
    //  to CcInitializeCacheMap.
    //

    CACHE_MANAGER_CALLBACKS CacheManagerCallbacks;
    CACHE_MANAGER_CALLBACKS CacheManagerVolumeCallbacks;

    //
    //  This is the ExWorkerItem that does both kinds of deferred closes.
    //

    PIO_WORKITEM CloseItem;

} CD_DATA;
typedef CD_DATA *PCD_DATA;


//
//  The Vcb (Volume control block) record corresponds to every
//  volume mounted by the file system.  They are ordered in a queue off
//  of CdData.VcbQueue.
//
//  The Vcb will be in several conditions during its lifespan.
//
//      NotMounted - Disk is not currently mounted (i.e. removed
//          from system) but cleanup and close operations are
//          supported.
//
//      MountInProgress - State of the Vcb from the time it is
//          created until it is successfully mounted or the mount
//          fails.
//
//      Mounted - Volume is currently in the mounted state.
//
//      Invalid - User has invalidated the volume.  Only legal operations
//          are cleanup and close.
//
//      DismountInProgress - We have begun the process of tearing down the
//          Vcb.  It can be deleted when all the references to it
//          have gone away.
//

typedef enum _VCB_CONDITION {

    VcbNotMounted = 0,
    VcbMountInProgress,
    VcbMounted,
    VcbInvalid,
    VcbDismountInProgress

} VCB_CONDITION;

typedef struct _VCB {

    //
    //  The type and size of this record (must be CDFS_NTC_VCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Vpb for this volume.
    //

    PVPB Vpb;

    //
    //  Device object for the driver below us.
    //

    PDEVICE_OBJECT TargetDeviceObject;

    //
    //  File object used to lock the volume.
    //

    PFILE_OBJECT VolumeLockFileObject;

    //
    //  Link into queue of Vcb's in the CdData structure.  We will create a union with
    //  a LONGLONG to force the Vcb to be quad-aligned.
    //

    union {

        LIST_ENTRY VcbLinks;
        LONGLONG Alignment;
    };

    //
    //  State flags and condition for the Vcb.
    //

    ULONG VcbState;
    VCB_CONDITION VcbCondition;

    //
    //  Various counts for this Vcb.
    //
    //      VcbCleanup - Open handles left on this system.
    //      VcbReference - Number of reasons this Vcb is still present.
    //      VcbUserReference - Number of user file objects still present.
    //

    ULONG VcbCleanup;
    ULONG VcbReference;
    ULONG VcbUserReference;

    //
    //  Fcb for the Volume Dasd file, root directory and the Path Table.
    //

    struct _FCB *VolumeDasdFcb;
    struct _FCB *RootIndexFcb;
    struct _FCB *PathTableFcb;

    //
    //  Location of current session and offset of volume descriptors.
    //

    ULONG BaseSector;
    ULONG VdSectorOffset;
    ULONG PrimaryVdSectorOffset;

    //
    //  Following is a sector from the last non-cached read of an XA file.
    //  Also the cooked offset on the disk.
    //

    PVOID XASector;
    LONGLONG XADiskOffset;

    //
    //  Vcb resource.  This is used to synchronize open/cleanup/close operations.
    //

    ERESOURCE VcbResource;

    //
    //  File resource.  This is used to synchronize all file operations except
    //  open/cleanup/close.
    //

    ERESOURCE FileResource;

    //
    //  Vcb fast mutex.  This is used to synchronize the fields in the Vcb
    //  when modified when the Vcb is not held exclusively.  Included here
    //  are the count fields and Fcb table.
    //
    //  We also use this to synchronize changes to the Fcb reference field.
    //

    FAST_MUTEX VcbMutex;
    PVOID VcbLockThread;

    //
    //  The following is used to synchronize the dir notify package.
    //

    PNOTIFY_SYNC NotifySync;

    //
    //  The following is the head of a list of notify Irps.
    //

    LIST_ENTRY DirNotifyList;

    //
    //  Logical block size for this volume as well constant values
    //  associated with the block size.
    //

    ULONG BlockSize;
    ULONG BlockToSectorShift;
    ULONG BlockToByteShift;
    ULONG BlocksPerSector;
    ULONG BlockMask;
    ULONG BlockInverseMask;

    //
    //  Fcb table.  Synchronized with the Vcb fast mutex.
    //

    RTL_GENERIC_TABLE FcbTable;

    //
    //  Volume TOC.  Cache this information for quick lookup.
    //

    PCDROM_TOC CdromToc;
    ULONG TocLength;
    ULONG TrackCount;
    ULONG DiskFlags;

    //
    //  Block factor to determine last session information.
    //

    ULONG BlockFactor;

    //
    //  Media change count from device driver for bulletproof detection
    //  of media movement
    //

    ULONG MediaChangeCount;

    //
    //  For raw reads, CDFS must obey the port maximum transfer restrictions.
    //

    ULONG MaximumTransferRawSectors;
    ULONG MaximumPhysicalPages;

    //
    //  Preallocated VPB for swapout, so we are not forced to consider
    //  must succeed pool.
    //

    PVPB SwapVpb;

} VCB;
typedef VCB *PVCB;

#define VCB_STATE_HSG                               (0x00000001)
#define VCB_STATE_ISO                               (0x00000002)
#define VCB_STATE_JOLIET                            (0x00000004)
#define VCB_STATE_LOCKED                            (0x00000010)
#define VCB_STATE_REMOVABLE_MEDIA                   (0x00000020)
#define VCB_STATE_CDXA                              (0x00000040)
#define VCB_STATE_AUDIO_DISK                        (0x00000080)
#define VCB_STATE_NOTIFY_REMOUNT                    (0x00000100)
#define VCB_STATE_VPB_NOT_ON_DEVICE                 (0x00000200)


//
//  The Volume Device Object is an I/O system device object with a
//  workqueue and an VCB record appended to the end.  There are multiple
//  of these records, one for every mounted volume, and are created during
//  a volume mount operation.  The work queue is for handling an overload
//  of work requests to the volume.
//

typedef struct _VOLUME_DEVICE_OBJECT {

    DEVICE_OBJECT DeviceObject;

    //
    //  The following field tells how many requests for this volume have
    //  either been enqueued to ExWorker threads or are currently being
    //  serviced by ExWorker threads.  If the number goes above
    //  a certain threshold, put the request on the overflow queue to be
    //  executed later.
    //

    ULONG PostedRequestCount;

    //
    //  The following field indicates the number of IRP's waiting
    //  to be serviced in the overflow queue.
    //

    ULONG OverflowQueueCount;

    //
    //  The following field contains the queue header of the overflow queue.
    //  The Overflow queue is a list of IRP's linked via the IRP's ListEntry
    //  field.
    //

    LIST_ENTRY OverflowQueue;

    //
    //  The following spinlock protects access to all the above fields.
    //

    KSPIN_LOCK OverflowQueueSpinLock;

    //
    //  This is the file system specific volume control block.
    //

    VCB Vcb;

} VOLUME_DEVICE_OBJECT;
typedef VOLUME_DEVICE_OBJECT *PVOLUME_DEVICE_OBJECT;


//
//  The following two structures are the separate union structures for
//  data and index Fcb's.  The path table is actually the same structure
//  as the index Fcb since it uses the first few fields.
//

typedef enum _FCB_CONDITION {
    FcbGood = 1,
    FcbBad,
    FcbNeedsToBeVerified
} FCB_CONDITION;

typedef struct _FCB_DATA {

    //
    //  The following field is used by the oplock module
    //  to maintain current oplock information.
    //

    OPLOCK Oplock;

    //
    //  The following field is used by the filelock module
    //  to maintain current byte range locking information.
    //  A file lock is allocated as needed.
    //

    PFILE_LOCK FileLock;

} FCB_DATA;
typedef FCB_DATA *PFCB_DATA;

typedef struct _FCB_INDEX {

    //
    //  Internal stream file.
    //

    PFILE_OBJECT FileObject;

    //
    //  Offset of first entry in stream.  This is for case where directory
    //  or path table does not begin on a sector boundary.  This value is
    //  added to all offset values to determine the real offset.
    //

    ULONG StreamOffset;

    //
    //  List of child fcbs.
    //

    LIST_ENTRY FcbQueue;

    //
    //  Ordinal number for this directory.  Combine this with the path table offset
    //  in the FileId and you have a starting point in the path table.
    //

    ULONG Ordinal;

    //
    //  Children path table start.  This is the offset in the path table
    //  for the first child of the directory.  A value of zero indicates
    //  that we haven't found the first child yet.  If there are no child
    //  directories we will position at a point in the path table so that
    //  subsequent searches will fail quickly.
    //

    ULONG ChildPathTableOffset;
    ULONG ChildOrdinal;

    //
    //  Root of splay trees for exact and ignore case prefix trees.
    //

    PRTL_SPLAY_LINKS ExactCaseRoot;
    PRTL_SPLAY_LINKS IgnoreCaseRoot;

} FCB_INDEX;
typedef FCB_INDEX *PFCB_INDEX;

typedef struct _FCB_NONPAGED {

    //
    //  Type and size of this record must be CDFS_NTC_FCB_NONPAGED
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  The following field contains a record of special pointers used by
    //  MM and Cache to manipluate section objects.  Note that the values
    //  are set outside of the file system.  However the file system on an
    //  open/create will set the file object's SectionObject field to
    //  point to this field
    //

    SECTION_OBJECT_POINTERS SegmentObject;

    //
    //  This is the resource structure for this Fcb.
    //

    ERESOURCE FcbResource;

    //
    //  This is the FastMutex for this Fcb.
    //

    FAST_MUTEX FcbMutex;

    //
    //  This is the mutex that is inserted into the FCB_ADVANCED_HEADER
    //  FastMutex field
    //

    FAST_MUTEX AdvancedFcbHeaderMutex;

} FCB_NONPAGED;
typedef FCB_NONPAGED *PFCB_NONPAGED;

//
//  The Fcb/Dcb record corresponds to every open file and directory, and to
//  every directory on an opened path.
//

typedef struct _FCB {

    //
    //  The following field is used for fast I/O.  It contains the node
    //  type code and size, indicates if fast I/O is possible, contains
    //  allocation, file, and valid data size, a resource, and call back
    //  pointers for FastIoRead and FastMdlRead.
    //
    //
    //  Node type codes for the Fcb must be one of the following.
    //
    //      CDFS_NTC_FCB_PATH_TABLE
    //      CDFS_NTC_FCB_INDEX
    //      CDFS_NTC_FCB_DATA
    //

    //
    //  Common Fsrtl Header.  The named header is for the fieldoff.c output.  We
    //  use the unnamed header internally.
    //

    union{

        FSRTL_ADVANCED_FCB_HEADER Header;
        FSRTL_ADVANCED_FCB_HEADER;
    };

    //
    //  Vcb for this Fcb.
    //

    PVCB Vcb;

    //
    //  Parent Fcb for this Fcb.  This may be NULL if this file was opened
    //  by ID, also for the root Fcb.
    //

    struct _FCB *ParentFcb;

    //
    //  Links to the queue of Fcb's in the parent.
    //

    LIST_ENTRY FcbLinks;

    //
    //  FileId for this file.
    //

    FILE_ID FileId;

    //
    //  Counts on this Fcb.  Cleanup count represents the number of open handles
    //  on this Fcb.  Reference count represents the number of reasons this Fcb
    //  is still present.  It includes file objects, children Fcb and anyone
    //  who wants to prevent this Fcb from going away.  Cleanup count is synchronized
    //  with the FcbResource.  The reference count is synchronized with the
    //  VcbMutex.
    //

    ULONG FcbCleanup;
    ULONG FcbReference;
    ULONG FcbUserReference;

    //
    //  State flags for this Fcb.
    //

    ULONG FcbState;

    //
    //  NT style attributes for the Fcb.
    //

    ULONG FileAttributes;

    //
    //  CDXA attributes for this file.
    //

    USHORT XAAttributes;

    //
    //  File number from the system use area.
    //

    UCHAR XAFileNumber;

    //
    //  This is the thread and count for the thread which has locked this
    //  Fcb.
    //

    PVOID FcbLockThread;
    ULONG FcbLockCount;

    //
    //  Pointer to the Fcb non-paged structures.
    //

    PFCB_NONPAGED FcbNonpaged;

    //
    //  Share access structure.
    //

    SHARE_ACCESS ShareAccess;

    //
    //  Mcb for the on disk mapping and a single map entry.
    //

    CD_MCB_ENTRY McbEntry;
    CD_MCB Mcb;

    //
    //  Embed the prefix entry for the longname.  Store an optional pointer
    //  to a prefix structure for the short name.
    //

    PPREFIX_ENTRY ShortNamePrefix;
    PREFIX_ENTRY FileNamePrefix;

    //
    //  Time stamp for this file.
    //

    LONGLONG CreationTime;

    union{

        ULONG FcbType;
        FCB_DATA;
        FCB_INDEX;
    };

} FCB;
typedef FCB *PFCB;

#define FCB_STATE_INITIALIZED                   (0x00000001)
#define FCB_STATE_IN_FCB_TABLE                  (0x00000002)
#define FCB_STATE_MODE2FORM2_FILE               (0x00000004)
#define FCB_STATE_MODE2_FILE                    (0x00000008)
#define FCB_STATE_DA_FILE                       (0x00000010)

//
//  These file types are read as raw 2352 byte sectors
//

#define FCB_STATE_RAWSECTOR_MASK                ( FCB_STATE_MODE2FORM2_FILE | \
                                                  FCB_STATE_MODE2_FILE      | \
                                                  FCB_STATE_DA_FILE )

#define SIZEOF_FCB_DATA     \
    (FIELD_OFFSET( FCB, FcbType ) + sizeof( FCB_DATA ))

#define SIZEOF_FCB_INDEX    \
    (FIELD_OFFSET( FCB, FcbType ) + sizeof( FCB_INDEX ))


//
//  The Ccb record is allocated for every file object
//

typedef struct _CCB {

    //
    //  Type and size of this record (must be CDFS_NTC_CCB)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Flags.  Indicates flags to apply for the current open.
    //

    ULONG Flags;

    //
    //  Fcb for the file being opened.
    //

    PFCB Fcb;

    //
    //  We store state information in the Ccb for a directory
    //  enumeration on this handle.
    //

    //
    //  Offset in the directory stream to base the next enumeration.
    //

    ULONG CurrentDirentOffset;
    CD_NAME SearchExpression;

} CCB;
typedef CCB *PCCB;

#define CCB_FLAG_OPEN_BY_ID                     (0x00000001)
#define CCB_FLAG_OPEN_RELATIVE_BY_ID            (0x00000002)
#define CCB_FLAG_IGNORE_CASE                    (0x00000004)
#define CCB_FLAG_OPEN_WITH_VERSION              (0x00000008)
#define CCB_FLAG_DISMOUNT_ON_CLOSE              (0x00000010)

//
//  Following flags refer to index enumeration.
//

#define CCB_FLAG_ENUM_NAME_EXP_HAS_WILD         (0x00010000)
#define CCB_FLAG_ENUM_VERSION_EXP_HAS_WILD      (0x00020000)
#define CCB_FLAG_ENUM_MATCH_ALL                 (0x00040000)
#define CCB_FLAG_ENUM_VERSION_MATCH_ALL         (0x00080000)
#define CCB_FLAG_ENUM_RETURN_NEXT               (0x00100000)
#define CCB_FLAG_ENUM_INITIALIZED               (0x00200000)
#define CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY    (0x00400000)


//
//  The Irp Context record is allocated for every orginating Irp.  It is
//  created by the Fsd dispatch routines, and deallocated by the CdComplete
//  request routine
//

typedef struct _IRP_CONTEXT {

    //
    //  Type and size of this record (must be CDFS_NTC_IRP_CONTEXT)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Originating Irp for the request.
    //

    PIRP Irp;

    //
    //  Vcb for this operation.  When this is NULL it means we were called
    //  with our filesystem device object instead of a volume device object.
    //  (Mount will fill this in once the Vcb is created)
    //

    PVCB Vcb;

    //
    //  Exception encountered during the request.  Any error raised explicitly by
    //  the file system will be stored here.  Any other error raised by the system
    //  is stored here after normalizing it.
    //

    NTSTATUS ExceptionStatus;
    ULONG RaisedAtLineFile;

    //
    //  Flags for this request.
    //

    ULONG Flags;

    //
    //  Real device object.  This represents the physical device closest to the media.
    //

    PDEVICE_OBJECT RealDevice;

    //
    //  Io context for a read request.
    //  Address of Fcb for teardown oplock in create case.
    //

    union {

        struct _CD_IO_CONTEXT *IoContext;
        PFCB *TeardownFcb;
    };

    //
    //  Top level irp context for this thread.
    //

    struct _IRP_CONTEXT *TopLevel;

    //
    //  Major and minor function codes.
    //

    UCHAR MajorFunction;
    UCHAR MinorFunction;

    //
    //  Pointer to the top-level context if this IrpContext is responsible
    //  for cleaning it up.
    //

    struct _THREAD_CONTEXT *ThreadContext;

    //
    //  This structure is used for posting to the Ex worker threads.
    //

    WORK_QUEUE_ITEM WorkQueueItem;

} IRP_CONTEXT;
typedef IRP_CONTEXT *PIRP_CONTEXT;

#define IRP_CONTEXT_FLAG_ON_STACK               (0x00000001)
#define IRP_CONTEXT_FLAG_MORE_PROCESSING        (0x00000002)
#define IRP_CONTEXT_FLAG_WAIT                   (0x00000004)
#define IRP_CONTEXT_FLAG_FORCE_POST             (0x00000008)
#define IRP_CONTEXT_FLAG_TOP_LEVEL              (0x00000010)
#define IRP_CONTEXT_FLAG_TOP_LEVEL_CDFS         (0x00000020)
#define IRP_CONTEXT_FLAG_IN_FSP                 (0x00000040)
#define IRP_CONTEXT_FLAG_IN_TEARDOWN            (0x00000080)
#define IRP_CONTEXT_FLAG_ALLOC_IO               (0x00000100)
#define IRP_CONTEXT_FLAG_DISABLE_POPUPS         (0x00000200)
#define IRP_CONTEXT_FLAG_FORCE_VERIFY           (0x00000400)

//
//  Flags used for create.
//

#define IRP_CONTEXT_FLAG_FULL_NAME              (0x10000000)
#define IRP_CONTEXT_FLAG_TRAIL_BACKSLASH        (0x20000000)

//
//  The following flags need to be cleared when a request is posted.
//

#define IRP_CONTEXT_FLAGS_CLEAR_ON_POST (   \
    IRP_CONTEXT_FLAG_MORE_PROCESSING    |   \
    IRP_CONTEXT_FLAG_WAIT               |   \
    IRP_CONTEXT_FLAG_FORCE_POST         |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL          |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL_CDFS     |   \
    IRP_CONTEXT_FLAG_IN_FSP             |   \
    IRP_CONTEXT_FLAG_IN_TEARDOWN        |   \
    IRP_CONTEXT_FLAG_DISABLE_POPUPS         \
)

//
//  The following flags need to be cleared when a request is retried.
//

#define IRP_CONTEXT_FLAGS_CLEAR_ON_RETRY (  \
    IRP_CONTEXT_FLAG_MORE_PROCESSING    |   \
    IRP_CONTEXT_FLAG_IN_TEARDOWN        |   \
    IRP_CONTEXT_FLAG_DISABLE_POPUPS         \
)

//
//  The following flags are set each time through the Fsp loop.
//

#define IRP_CONTEXT_FSP_FLAGS (             \
    IRP_CONTEXT_FLAG_WAIT               |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL          |   \
    IRP_CONTEXT_FLAG_TOP_LEVEL_CDFS     |   \
    IRP_CONTEXT_FLAG_IN_FSP                 \
)


//
//  Following structure is used to queue a request to the delayed close queue.
//  This structure should be the minimum block allocation size.
//

typedef struct _IRP_CONTEXT_LITE {

    //
    //  Type and size of this record (must be CDFS_NTC_IRP_CONTEXT_LITE)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;

    //
    //  Fcb for the file object being closed.
    //

    PFCB Fcb;

    //
    //  List entry to attach to delayed close queue.
    //

    LIST_ENTRY DelayedCloseLinks;

    //
    //  User reference count for the file object being closed.
    //

    ULONG UserReference;

    //
    //  Real device object.  This represents the physical device closest to the media.
    //

    PDEVICE_OBJECT RealDevice;

} IRP_CONTEXT_LITE;
typedef IRP_CONTEXT_LITE *PIRP_CONTEXT_LITE;


//
//  Context structure for asynchronous I/O calls.  Most of these fields
//  are actually only required for the ReadMultiple routines, but
//  the caller must allocate one as a local variable anyway before knowing
//  whether there are multiple requests are not.  Therefore, a single
//  structure is used for simplicity.
//

typedef struct _CD_IO_CONTEXT {

    //
    //  These two fields are used for multiple run Io
    //

    LONG IrpCount;
    PIRP MasterIrp;
    NTSTATUS Status;
    BOOLEAN AllocatedContext;

    union {

        //
        //  This element handles the asynchronous non-cached Io
        //

        struct {

            PERESOURCE Resource;
            ERESOURCE_THREAD ResourceThreadId;
            ULONG RequestedByteCount;
        };

        //
        //  and this element handles the synchronous non-cached Io.
        //

        KEVENT SyncEvent;
    };

} CD_IO_CONTEXT;
typedef CD_IO_CONTEXT *PCD_IO_CONTEXT;


//
//  Following structure is used to track the top level request.  Each Cdfs
//  Fsd and Fsp entry point will examine the top level irp location in the
//  thread local storage to determine if this request is top level and/or
//  top level Cdfs.  The top level Cdfs request will remember the previous
//  value and update that location with a stack location.  This location
//  can be accessed by recursive Cdfs entry points.
//

typedef struct _THREAD_CONTEXT {

    //
    //  CDFS signature.  Used to confirm structure on stack is valid.
    //

    ULONG Cdfs;

    //
    //  Previous value in top-level thread location.  We restore this
    //  when done.
    //

    PIRP SavedTopLevelIrp;

    //
    //  Top level Cdfs IrpContext.  Initial Cdfs entry point on stack
    //  will store the IrpContext for the request in this stack location.
    //

    PIRP_CONTEXT TopLevelIrpContext;

} THREAD_CONTEXT;
typedef THREAD_CONTEXT *PTHREAD_CONTEXT;


//
//  The following structure is used for enumerating the entries in the
//  path table.  We will always map this two sectors at a time so we don't
//  have to worry about entries which span sectors.  We move through
//  one sector at a time though.  We will unpin and remap after
//  crossing a sector boundary.
//
//  The only special case is where we span a cache view.  In that case
//  we will allocate a buffer and read both pieces into it.
//
//  This strategy takes advantage of the CC enhancement which allows
//  overlapping ranges.
//

typedef struct _PATH_ENUM_CONTEXT {

    //
    //  Pointer to the current sector and the offset of this sector to
    //  the beginning of the path table.  The Data pointer may be
    //  a pool block in the case where we cross a cache view
    //  boundary.  Also the length of the data for this block.
    //

    PVOID Data;
    ULONG BaseOffset;
    ULONG DataLength;

    //
    //  Bcb for the sector.  (We may actually have pinned two sectors)
    //  This will be NULL for the case where we needed to allocate a
    //  buffer in the case where we span a cache view.
    //

    PBCB Bcb;

    //
    //  Offset to current entry within the current data block.
    //

    ULONG DataOffset;

    //
    //  Did we allocate the buffer for the entry.
    //

    BOOLEAN AllocatedData;

    //
    //  End of Path Table.  This tells us whether the current data
    //  block includes the end of the path table.  This is the
    //  only block where we need to do a careful check about whether
    //  the path table entry fits into the buffer.
    //
    //  Also once we have reached the end of the path table we don't
    //  need to remap the data as we move into the final sector.
    //  We always look at the last two sectors together.
    //

    BOOLEAN LastDataBlock;

} PATH_ENUM_CONTEXT;
typedef PATH_ENUM_CONTEXT *PPATH_ENUM_CONTEXT;

#define VACB_MAPPING_MASK               (VACB_MAPPING_GRANULARITY - 1)
#define LAST_VACB_SECTOR_OFFSET         (VACB_MAPPING_GRANULARITY - SECTOR_SIZE)


//
//  Path Entry.  This is our representation of the on disk data.
//

typedef struct _PATH_ENTRY {

    //
    //  Directory number and offset.  This is the ordinal and the offset from
    //  the beginning of the path table stream for this entry.
    //
    //

    ULONG Ordinal;
    ULONG PathTableOffset;

    //
    //  Logical block Offset on the disk for this entry.  We already bias
    //  this by any Xar blocks.
    //

    ULONG DiskOffset;

    //
    //  Length of on-disk path table entry.
    //

    ULONG PathEntryLength;

    //
    //  Parent number.
    //

    ULONG ParentOrdinal;

    //
    //  DirName length and Id.  Typically the pointer here points to the raw on-disk
    //  bytes.  We will point to a fixed self entry if this is the root directory.
    //

    ULONG DirNameLen;
    PCHAR DirName;

    //
    //  Following are the flags used to cleanup this structure.
    //

    ULONG Flags;

    //
    //  The following is the filename string and version number strings.  We embed a buffer
    //  large enough to hold two 8.3 names.  One for exact case and one for case insensitive.
    //

    CD_NAME CdDirName;
    CD_NAME CdCaseDirName;

    WCHAR NameBuffer[BYTE_COUNT_EMBEDDED_NAME / sizeof( WCHAR ) * 2];

} PATH_ENTRY;
typedef PATH_ENTRY *PPATH_ENTRY;

#define PATH_ENTRY_FLAG_ALLOC_BUFFER            (0x00000001)


//
//  Compound path entry.  This structure combines the on-disk entries
//  with the in-memory structures.
//

typedef struct _COMPOUND_PATH_ENTRY {

    PATH_ENUM_CONTEXT PathContext;
    PATH_ENTRY PathEntry;

} COMPOUND_PATH_ENTRY;
typedef COMPOUND_PATH_ENTRY *PCOMPOUND_PATH_ENTRY;


//
//  The following is used for enumerating through a directory via the
//  dirents.
//

typedef struct _DIRENT_ENUM_CONTEXT {

    //
    //  Pointer the current sector and the offset of this sector within
    //  the directory file.  Also the data length of this pinned block.
    //

    PVOID Sector;
    ULONG BaseOffset;
    ULONG DataLength;

    //
    //  Bcb for the sector.
    //

    PBCB Bcb;

    //
    //  Offset to the current dirent within this sector.
    //

    ULONG SectorOffset;

    //
    //  Length to next dirent.  A zero indicates to move to the next sector.
    //

    ULONG NextDirentOffset;

} DIRENT_ENUM_CONTEXT;
typedef DIRENT_ENUM_CONTEXT *PDIRENT_ENUM_CONTEXT;


//
//  Following structure is used to smooth out the differences in the HSG, ISO
//  and Joliett directory entries.
//

typedef struct _DIRENT {

    //
    //  Offset in the Directory of this entry.  Note this includes
    //  any bytes added to the beginning of the directory to pad
    //  down to a sector boundary.
    //

    ULONG DirentOffset;

    ULONG DirentLength;

    //
    //  Starting offset on the disk including any Xar blocks.
    //

    ULONG StartingOffset;

    //
    //  DataLength of the data.  If not the last block then this should
    //  be an integral number of logical blocks.
    //

    ULONG DataLength;

    //
    //  The following field is the time stamp out of the directory entry.
    //  Use a pointer into the dirent for this.
    //

    PCHAR CdTime;

    //
    //  The following field is the dirent file flags field.
    //

    UCHAR DirentFlags;

    //
    //  Following field is a Cdfs flag field used to clean up this structure.
    //

    UCHAR Flags;

    //
    //  The following fields indicate the file unit size and interleave gap
    //  for interleaved files.  Each of these are in logical blocks.
    //

    ULONG FileUnitSize;
    ULONG InterleaveGapSize;

    //
    //  System use offset.  Zero value indicates no system use area.
    //

    ULONG SystemUseOffset;

    //
    //  CDXA attributes and file number for this file.
    //

    USHORT XAAttributes;
    UCHAR XAFileNumber;

    //
    //  Filename length and ID.  We copy the length (in bytes) and keep
    //  a pointer to the start of the name.
    //

    ULONG FileNameLen;
    PCHAR FileName;

    //
    //  The following are the filenames stored by name and version numbers.
    //  The fixed buffer here can hold two Unicode 8.3 names.  This allows
    //  us to upcase the name into a fixed buffer.
    //

    CD_NAME CdFileName;
    CD_NAME CdCaseFileName;

    //
    //  Data stream type.  Indicates if this is audio, XA mode2 form2 or cooked sectors.
    //

    XA_EXTENT_TYPE ExtentType;

    WCHAR NameBuffer[BYTE_COUNT_EMBEDDED_NAME / sizeof( WCHAR ) * 2];

} DIRENT;
typedef DIRENT *PDIRENT;

#define DIRENT_FLAG_ALLOC_BUFFER                (0x01)
#define DIRENT_FLAG_CONSTANT_ENTRY              (0x02)

#define DIRENT_FLAG_NOT_PERSISTENT              (0)


//
//  Following structure combines the on-disk information with the normalized
//  structure.
//

typedef struct _COMPOUND_DIRENT {

    DIRENT_ENUM_CONTEXT DirContext;
    DIRENT Dirent;

} COMPOUND_DIRENT;
typedef COMPOUND_DIRENT *PCOMPOUND_DIRENT;


//
//  The following structure is used to enumerate the files in a directory.
//  It contains three DirContext/Dirent pairs and then self pointers to
//  know which of these is begin used how.
//

typedef struct _FILE_ENUM_CONTEXT {

    //
    //  Pointers to the current compound dirents below.
    //
    //      PriorDirent - Initial dirent for the last file encountered.
    //      InitialDirent - Initial dirent for the current file.
    //      CurrentDirent - Second or later dirent for the current file.
    //

    PCOMPOUND_DIRENT PriorDirent;
    PCOMPOUND_DIRENT InitialDirent;
    PCOMPOUND_DIRENT CurrentDirent;

    //
    //  Flags indicating the state of the search.
    //

    ULONG Flags;

    //
    //  This is an accumulation of the file sizes of the different extents
    //  of a single file.
    //

    LONGLONG FileSize;

    //
    //  Short name for this file.
    //

    CD_NAME ShortName;
    WCHAR ShortNameBuffer[ BYTE_COUNT_8_DOT_3 / sizeof( WCHAR ) ];

    //
    //  Array of compound dirents.
    //

    COMPOUND_DIRENT Dirents[3];

} FILE_ENUM_CONTEXT;
typedef FILE_ENUM_CONTEXT *PFILE_ENUM_CONTEXT;

#define FILE_CONTEXT_MULTIPLE_DIRENTS       (0x00000001)


//
//  RIFF header.  Prepended to the data of a file containing XA sectors.
//  This is a hard-coded structure except that we bias the 'ChunkSize' and
//  'RawSectors' fields with the file size.  We also copy the attributes flag
//  from the system use area in the dirent.  We always initialize this
//  structure by copying the XAFileHeader.
//

typedef struct _RIFF_HEADER {

    ULONG ChunkId;
    LONG ChunkSize;
    ULONG SignatureCDXA;
    ULONG SignatureFMT;
    ULONG XAChunkSize;
    ULONG OwnerId;
    USHORT Attributes;
    USHORT SignatureXA;
    UCHAR FileNumber;
    UCHAR Reserved[7];
    ULONG SignatureData;
    ULONG RawSectors;

} RIFF_HEADER;
typedef RIFF_HEADER *PRIFF_HEADER;

//
//  Audio play header for CDDA tracks.
//

typedef struct _AUDIO_PLAY_HEADER {

    ULONG Chunk;
    ULONG ChunkSize;
    ULONG SignatureCDDA;
    ULONG SignatureFMT;
    ULONG FMTChunkSize;
    USHORT FormatTag;
    USHORT TrackNumber;
    ULONG DiskID;
    ULONG StartingSector;
    ULONG SectorCount;
    UCHAR TrackAddress[4];
    UCHAR TrackLength[4];

} AUDIO_PLAY_HEADER;
typedef AUDIO_PLAY_HEADER *PAUDIO_PLAY_HEADER;


//
//  Some macros for supporting the use of a Generic Table
//  containing all the FCB/DCBs and indexed by their FileId.
//
//  For directories:
//
//      The HighPart contains the path table offset of this directory in the
//      path table.
//
//      The LowPart contains zero except for the upper bit which is
//      set to indicate that this is a directory.
//
//  For files:
//
//      The HighPart contains the path table offset of the parent directory
//      in the path table.
//
//      The LowPart contains the byte offset of the dirent in the parent
//      directory file.
//
//  A directory is always entered into the Fcb Table as if it's
//  dirent offset was zero.  This enables any child to look in the FcbTable
//  for it's parent by searching with the same HighPart but with zero
//  as the value for LowPart.
//
//  The Id field is a LARGE_INTEGER where the High and Low parts can be
//  accessed separately.
//
//  The following macros are used to access the Fid fields.
//
//      CdQueryFidDirentOffset      - Accesses the Dirent offset field
//      CdQueryFidPathTableNumber   - Accesses the PathTable offset field
//      CdSetFidDirentOffset        - Sets the Dirent offset field
//      CdSetFidPathTableNumber     - Sets the PathTable ordinal field
//      CdFidIsDirectory            - Queries if directory bit is set
//      CdFidSetDirectory           - Sets directory bit
//

#define FID_DIR_MASK  0x80000000            // high order bit means directory.

#define CdQueryFidDirentOffset(I)           ((I).LowPart & ~FID_DIR_MASK)
#define CdQueryFidPathTableOffset(I)        ((I).HighPart)
#define CdSetFidDirentOffset(I,D)           ((I).LowPart = D)
#define CdSetFidPathTableOffset(I,P)        ((I).HighPart = P)
#define CdFidIsDirectory(I)                 FlagOn( (I).LowPart, FID_DIR_MASK )
#define CdFidSetDirectory(I)                SetFlag( (I).LowPart, FID_DIR_MASK )

#define CdSetFidFromParentAndDirent(I,F,D)  {                                           \
        CdSetFidPathTableOffset( (I), CdQueryFidPathTableOffset( (F)->FileId ));        \
        CdSetFidDirentOffset( (I), (D)->DirentOffset );                                 \
        if (FlagOn( (D)->DirentFlags, CD_ATTRIBUTE_DIRECTORY )) {                       \
            CdFidSetDirectory((I));                                                     \
        }                                                                               \
}

#endif // _CDSTRUC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\close.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for Cdfs called by the
    Fsd/Fsp dispatch routines.

    The close operation interacts with both the async and delayed close queues
    in the CdData structure.  Since close may be called recursively we may
    violate the locking order in acquiring the Vcb or Fcb.  In this case
    we may move the request to the async close queue.  If this is the last
    reference on the Fcb and there is a chance the user may reopen this
    file again soon we would like to defer the close.  In this case we
    may move the request to the async close queue.

    Once we are past the decode file operation there is no need for the
    file object.  If we are moving the request to either of the work
    queues then we remember all of the information from the file object and
    complete the request with STATUS_SUCCESS.  The Io system can then
    reuse the file object and we can complete the request when convenient.

    The async close queue consists of requests which we would like to
    complete as soon as possible.  They are queued using the original
    IrpContext where some of the fields have been overwritten with
    information from the file object.  We will extract this information,
    cleanup the IrpContext and then call the close worker routine.

    The delayed close queue consists of requests which we would like to
    defer the close for.  We keep size of this list within a range
    determined by the size of the system.  We let it grow to some maximum
    value and then shrink to some minimum value.  We allocate a small
    structure which contains the key information from the file object
    and use this information along with an IrpContext on the stack
    to complete the request.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_CLOSE)

//
//  Local support routines
//

BOOLEAN
CdCommonClosePrivate (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN FromFsd
    );

VOID
CdQueueClose (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN DelayedClose
    );

PIRP_CONTEXT
CdRemoveClose (
    IN PVCB Vcb OPTIONAL
    );

VOID
CdCloseWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonClose)
#pragma alloc_text(PAGE, CdCommonClosePrivate)
#pragma alloc_text(PAGE, CdQueueClose)
#pragma alloc_text(PAGE, CdRemoveClose)
#pragma alloc_text(PAGE, CdCloseWorker)
#endif


VOID
CdFspClose (
    IN PVCB Vcb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to process the close queues in the CdData.  If the
    Vcb is passed then we want to remove all of the closes for this Vcb.
    Otherwise we will do as many of the delayed closes as we need to do.

Arguments:

    Vcb - If specified then we are looking for all of the closes for the
        given Vcb.

Return Value:

    None

--*/

{
    PIRP_CONTEXT IrpContext;
    IRP_CONTEXT StackIrpContext;

    THREAD_CONTEXT ThreadContext;

    PFCB Fcb;
    ULONG UserReference;

    ULONG VcbHoldCount = 0;
    PVCB CurrentVcb = NULL;

    BOOLEAN PotentialVcbTeardown = FALSE;

    PAGED_CODE();

    FsRtlEnterFileSystem();

    //
    //  Continue processing until there are no more closes to process.
    //

    while (IrpContext = CdRemoveClose( Vcb )) {

        //
        //  If we don't have an IrpContext then use the one on the stack.
        //  Initialize it for this request.
        //

        if (SafeNodeType( IrpContext ) != CDFS_NTC_IRP_CONTEXT ) {

            //
            //  Update the local values from the IrpContextLite.
            //

            Fcb = ((PIRP_CONTEXT_LITE) IrpContext)->Fcb;
            UserReference = ((PIRP_CONTEXT_LITE) IrpContext)->UserReference;

            //
            //  Update the stack irp context with the values from the
            //  IrpContextLite.
            //

            CdInitializeStackIrpContext( &StackIrpContext,
                                         (PIRP_CONTEXT_LITE) IrpContext );

            //
            //  Free the IrpContextLite.
            //

            CdFreeIrpContextLite( (PIRP_CONTEXT_LITE) IrpContext );

            //
            //  Remember we have the IrpContext from the stack.
            //

            IrpContext = &StackIrpContext;

        //
        //  Otherwise cleanup the existing IrpContext.
        //

        } else {

            //
            //  Remember the Fcb and user reference count.
            //

            Fcb = (PFCB) IrpContext->Irp;
            IrpContext->Irp = NULL;

            UserReference = (ULONG) IrpContext->ExceptionStatus;
            IrpContext->ExceptionStatus = STATUS_SUCCESS;
        }

        //
        //  We have an IrpContext.  Now we need to set the top level thread
        //  context.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FSP_FLAGS );

        //
        //  If we were given a Vcb then there is a request on top of this.
        //

        if (ARGUMENT_PRESENT( Vcb )) {

            ClearFlag( IrpContext->Flags,
                       IRP_CONTEXT_FLAG_TOP_LEVEL | IRP_CONTEXT_FLAG_TOP_LEVEL_CDFS );
        }

        CdSetThreadContext( IrpContext, &ThreadContext );

        //
        //  If we have hit the maximum number of requests to process without
        //  releasing the Vcb then release the Vcb now.  If we are holding
        //  a different Vcb to this one then release the previous Vcb.
        //
        //  In either case acquire the current Vcb.
        //
        //  We use the MinDelayedCloseCount from the CdData since it is
        //  a convenient value based on the system size.  Only thing we are trying
        //  to do here is prevent this routine starving other threads which
        //  may need this Vcb exclusively.
        //
        //  Note that the check for potential teardown below is unsafe.  We'll 
        //  repeat later within the cddata lock.
        //

        PotentialVcbTeardown = !ARGUMENT_PRESENT( Vcb ) &&
                               (Fcb->Vcb->VcbCondition != VcbMounted) &&
                               (Fcb->Vcb->VcbCondition != VcbMountInProgress) &&
                               (Fcb->Vcb->VcbCleanup == 0);

        if (PotentialVcbTeardown ||
            (VcbHoldCount > CdData.MinDelayedCloseCount) ||
            (Fcb->Vcb != CurrentVcb)) {

            if (CurrentVcb != NULL) {

                CdReleaseVcb( IrpContext, CurrentVcb );
            }

            if (PotentialVcbTeardown) {

                CdAcquireCdData( IrpContext );

                //
                //  Repeat the checks with global lock held.  The volume could have
                //  been remounted while we didn't hold the lock.
                //

                PotentialVcbTeardown = !ARGUMENT_PRESENT( Vcb ) &&
                                       (Fcb->Vcb->VcbCondition != VcbMounted) &&
                                       (Fcb->Vcb->VcbCondition != VcbMountInProgress) &&
                                       (Fcb->Vcb->VcbCleanup == 0);
                                
                if (!PotentialVcbTeardown)  {

                    CdReleaseCdData( IrpContext);
                }
            }

            CurrentVcb = Fcb->Vcb;
            CdAcquireVcbShared( IrpContext, CurrentVcb, FALSE );

            VcbHoldCount = 0;

        } else {

            VcbHoldCount += 1;
        }

        //
        //  Call our worker routine to perform the close operation.
        //

        CdCommonClosePrivate( IrpContext, CurrentVcb, Fcb, UserReference, FALSE );

        //
        //  If the reference count on this Vcb is below our residual reference
        //  then check if we should dismount the volume.
        //

        if (PotentialVcbTeardown) {

            CdReleaseVcb( IrpContext, CurrentVcb );
            CdCheckForDismount( IrpContext, CurrentVcb, FALSE );

            CurrentVcb = NULL;

            CdReleaseCdData( IrpContext );
            PotentialVcbTeardown = FALSE;
        }

        //
        //  Complete the current request to cleanup the IrpContext.
        //

        CdCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
    }

    //
    //  Release any Vcb we may still hold.
    //

    if (CurrentVcb != NULL) {

        CdReleaseVcb( IrpContext, CurrentVcb );

    }

    FsRtlExitFileSystem();
}


NTSTATUS
CdCommonClose (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the Fsd entry for the close operation.  We decode the file
    object to find the CDFS structures and type of open.  We call our internal
    worker routine to perform the actual work.  If the work wasn't completed
    then we post to one of our worker queues.  The Ccb isn't needed after this
    point so we delete the Ccb and return STATUS_SUCCESS to our caller in all
    cases.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    STATUS_SUCCESS

--*/

{
    TYPE_OF_OPEN TypeOfOpen;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;
    ULONG UserReference = 0;

    BOOLEAN PotentialVcbTeardown = FALSE;
    BOOLEAN ForceDismount = FALSE;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS.
    //

    if (IrpContext->Vcb == NULL) {

        CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Decode the file object to get the type of open and Fcb/Ccb.
    //

    TypeOfOpen = CdDecodeFileObject( IrpContext,
                                     IoGetCurrentIrpStackLocation( Irp )->FileObject,
                                     &Fcb,
                                     &Ccb );

    //
    //  No work to do for unopened file objects.
    //

    if (TypeOfOpen == UnopenedFileObject) {

        CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

        return STATUS_SUCCESS;
    }

    Vcb = Fcb->Vcb;

    //
    //  Clean up any CCB associated with this open.
    //
    
    if (Ccb != NULL) {

        UserReference = 1;

        //
        //  Was a FSCTL_DISMOUNT issued on this handle?  If so,  we need to
        //  force a dismount of the volume now.
        //
        
        ForceDismount = BooleanFlagOn( Ccb->Flags, CCB_FLAG_DISMOUNT_ON_CLOSE);

        //
        //  We can always deallocate the Ccb if present.
        //

        CdDeleteCcb( IrpContext, Ccb );
    }

    //
    //  If this is the last reference to a user file or directory on a 
    //  currently mounted volume, then post it to the delayed close queue.  Note
    //  that the VcbCondition check is unsafe,  but it doesn't really matter -
    //  we just might delay the volume teardown a little by posting this close.
    //

    if ((Vcb->VcbCondition == VcbMounted) &&
        (Fcb->FcbReference == 1) &&
        ((TypeOfOpen == UserFileOpen) ||
         (TypeOfOpen == UserDirectoryOpen))) {

        CdQueueClose( IrpContext, Fcb, UserReference, TRUE );
        IrpContext = NULL;

    //
    //  Otherwise try to process this close.  Post to the async close queue
    //  if we can't acquire all of the resources.
    //

    } else {

        //
        //  If we may be dismounting this volume then acquire the CdData
        //  resource.
        //
        //  Since we now must make volumes go away as soon as reasonable after
        //  the last user handles closes, key off of the cleanup count.  It is
        //  OK to do this more than neccesary.  Since this Fcb could be holding
        //  a number of other Fcbs (and thus their references), a simple check
        //  on reference count is not appropriate.
        //
        //  Do an unsafe check first to avoid taking the (global) cddata lock in the 
        //  common case.
        //

        if (((Vcb->VcbCleanup == 0) || ForceDismount) &&
            (Vcb->VcbCondition != VcbMounted))  {

            //
            //  Possible.  Acquire CdData to synchronise with the remount path,  and
            //  then repeat the tests.
            //
            //  Note that we must send the notification outside of any locks,  since 
            //  the worker that processes the notify could also be calling into our 
            //  pnp path which wants both CdData and VcbResource.  For a force dismount
            //  the volume will be marked invalid (no going back),  so we will definitely
            //  go ahead and dismount below.
            //

            if (ForceDismount)  {
            
                //
                //  Send notification.
                //
                
                FsRtlNotifyVolumeEvent( IoGetCurrentIrpStackLocation( Irp )->FileObject, 
                                        FSRTL_VOLUME_DISMOUNT );
            }
            
            CdAcquireCdData( IrpContext );

            if (((Vcb->VcbCleanup == 0) || ForceDismount) &&
                (Vcb->VcbCondition != VcbMounted) &&
                (Vcb->VcbCondition != VcbMountInProgress) &&
                FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_TOP_LEVEL_CDFS ))  {

                PotentialVcbTeardown = TRUE;
            }
            else {

                //
                //  We can't dismount this volume now,  there are other references or
                //  it's just been remounted.
                //

                CdReleaseCdData( IrpContext);
            }
        }

        if (ForceDismount)  {
        
            //
            //  Physically disconnect this Vcb from the device so a new mount can
            //  occur.  Vcb deletion cannot happen at this time since there is
            //  a handle on it associated with this very request,  but we'll call
            //  check for dismount again later anyway.
            //

            CdCheckForDismount( IrpContext, Vcb, TRUE );
        }
        
        //
        //  Call the worker routine to perform the actual work.  This routine
        //  should never raise except for a fatal error.
        //

        if (!CdCommonClosePrivate( IrpContext, Vcb, Fcb, UserReference, TRUE )) {

            //
            //  If we didn't complete the request then post the request as needed.
            //

            CdQueueClose( IrpContext, Fcb, UserReference, FALSE );
            IrpContext = NULL;

        //
        //  Check whether we should be dismounting the volume and then complete
        //  the request.
        //

        } else if (PotentialVcbTeardown) {

            CdCheckForDismount( IrpContext, Vcb, FALSE );
        }
    }

    //
    //  Always complete this request with STATUS_SUCCESS.
    //

    CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    if (PotentialVcbTeardown) {

        CdReleaseCdData( IrpContext );
    }

    //
    //  Always return STATUS_SUCCESS for closes.
    //

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

BOOLEAN
CdCommonClosePrivate (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN FromFsd
    )

/*++

Routine Description:

    This is the worker routine for the close operation.  We can be called in
    an Fsd thread or from a worker Fsp thread.  If called from the Fsd thread
    then we acquire the resources without waiting.  Otherwise we know it is
    safe to wait.

    We check to see whether we should post this request to the delayed close
    queue.  If we are to process the close here then we acquire the Vcb and
    Fcb.  We will adjust the counts and call our teardown routine to see
    if any of the structures should go away.

Arguments:

    Vcb - Vcb for this volume.

    Fcb - Fcb for this request.

    UserReference - Number of user references for this file object.  This is
        zero for an internal stream.

    FromFsd - This request was called from an Fsd thread.  Indicates whether
        we should wait to acquire resources.

    DelayedClose - Address to store whether we should try to put this on
        the delayed close queue.  Ignored if this routine can process this
        close.

Return Value:

    BOOLEAN - TRUE if this thread processed the close, FALSE otherwise.

--*/

{
    BOOLEAN RemovedFcb;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Try to acquire the Vcb and Fcb.  If we can't acquire them then return
    //  and let our caller know he should post the request to the async
    //  queue.
    //

    if (CdAcquireVcbShared( IrpContext, Vcb, FromFsd )) {

        if (!CdAcquireFcbExclusive( IrpContext, Fcb, FromFsd )) {

            //
            //  We couldn't get the Fcb.  Release the Vcb and let our caller
            //  know to post this request.
            //

            CdReleaseVcb( IrpContext, Vcb );
            return FALSE;
        }

    //
    //  We didn't get the Vcb.  Let our caller know to post this request.
    //

    } else {

        return FALSE;
    }

    //
    //  Lock the Vcb and decrement the reference counts.
    //

    CdLockVcb( IrpContext, Vcb );
    CdDecrementReferenceCounts( IrpContext, Fcb, 1, UserReference );
    CdUnlockVcb( IrpContext, Vcb );

    //
    //  Call our teardown routine to see if this object can go away.
    //  If we don't remove the Fcb then release it.
    //

    CdTeardownStructures( IrpContext, Fcb, &RemovedFcb );

    if (!RemovedFcb) {

        CdReleaseFcb( IrpContext, Fcb );
    }

    //
    //  Release the Vcb and return to our caller.  Let him know we completed
    //  this request.
    //

    CdReleaseVcb( IrpContext, Vcb );

    return TRUE;
}

VOID
CdCloseWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    Worker routine to call CsFspClose.

Arguments:

    DeviceObject - Filesystem registration device object

    Context - Callers context

Return Value:

    None

--*/

{
    CdFspClose (NULL);
}


VOID
CdQueueClose (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG UserReference,
    IN BOOLEAN DelayedClose
    )

/*++

Routine Description:

    This routine is called to queue a request to either the async or delayed
    close queue.  For the delayed queue we need to allocate a smaller
    structure to contain the information about the file object.  We do
    that so we don't put the larger IrpContext structures into this long
    lived queue.  If we can allocate this structure then we put this
    on the async queue instead.

Arguments:

    Fcb - Fcb for this file object.

    UserReference - Number of user references for this file object.  This is
        zero for an internal stream.

    DelayedClose - Indicates whether this should go on the async or delayed
        close queue.

Return Value:

    None

--*/

{
    PIRP_CONTEXT_LITE IrpContextLite = NULL;
    BOOLEAN StartWorker = FALSE;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_FCB( Fcb );

    //
    //  Start with the delayed queue request.  We can move this to the async
    //  queue if there is an allocation failure.
    //

    if (DelayedClose) {

        //
        //  Try to allocate non-paged pool for the IRP_CONTEXT_LITE.
        //

        IrpContextLite = CdCreateIrpContextLite( IrpContext );
    }

    //
    //  We want to clear the top level context in this thread if
    //  necessary.  Call our cleanup routine to do the work.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
    CdCleanupIrpContext( IrpContext, TRUE );

    //
    //  Synchronize with the CdData lock.
    //

    CdLockCdData();

    //
    //  If we have an IrpContext then put the request on the delayed close queue.
    //

    if (IrpContextLite != NULL) {

        //
        //  Initialize the IrpContextLite.
        //

        IrpContextLite->NodeTypeCode = CDFS_NTC_IRP_CONTEXT_LITE;
        IrpContextLite->NodeByteSize = sizeof( IRP_CONTEXT_LITE );
        IrpContextLite->Fcb = Fcb;
        IrpContextLite->UserReference = UserReference;
        IrpContextLite->RealDevice = IrpContext->RealDevice;

        //
        //  Add this to the delayed close list and increment
        //  the count.
        //

        InsertTailList( &CdData.DelayedCloseQueue,
                        &IrpContextLite->DelayedCloseLinks );

        CdData.DelayedCloseCount += 1;

        //
        //  If we are above our threshold then start the delayed
        //  close operation.
        //

        if (CdData.DelayedCloseCount > CdData.MaxDelayedCloseCount) {

            CdData.ReduceDelayedClose = TRUE;

            if (!CdData.FspCloseActive) {

                CdData.FspCloseActive = TRUE;
                StartWorker = TRUE;
            }
        }

        //
        //  Unlock the CdData.
        //

        CdUnlockCdData();

        //
        //  Cleanup the IrpContext.
        //

        CdCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    //
    //  Otherwise drop into the async case below.
    //

    } else {

        //
        //  Store the information about the file object into the IrpContext.
        //

        IrpContext->Irp = (PIRP) Fcb;
        IrpContext->ExceptionStatus = (NTSTATUS) UserReference;

        //
        //  Add this to the async close list and increment the count.
        //

        InsertTailList( &CdData.AsyncCloseQueue,
                        &IrpContext->WorkQueueItem.List );

        CdData.AsyncCloseCount += 1;

        //
        //  Remember to start the Fsp close thread if not currently started.
        //

        if (!CdData.FspCloseActive) {

            CdData.FspCloseActive = TRUE;

            StartWorker = TRUE;
        }

        //
        //  Unlock the CdData.
        //

        CdUnlockCdData();
    }

    //
    //  Start the FspClose thread if we need to.
    //

    if (StartWorker) {

        IoQueueWorkItem( CdData.CloseItem, CdCloseWorker, CriticalWorkQueue, NULL );
    }

    //
    //  Return to our caller.
    //

    return;
}


//
//  Local support routine
//

PIRP_CONTEXT
CdRemoveClose (
    IN PVCB Vcb OPTIONAL
    )

/*++

Routine Description:

Arguments:

    This routine is called to scan the async and delayed close queues looking
    for a suitable entry.  If the Vcb is specified then we scan both queues
    looking for an entry with the same Vcb.  Otherwise we will look in the
    async queue first for any close item.  If none found there then we look
    in the delayed close queue provided that we have triggered the delayed
    close operation.

Return Value:

    PIRP_CONTEXT - NULL if no work item found.  Otherwise it is the pointer to
        either the IrpContext or IrpContextLite for this request.

--*/

{
    PIRP_CONTEXT IrpContext = NULL;
    PIRP_CONTEXT NextIrpContext;
    PIRP_CONTEXT_LITE NextIrpContextLite;

    PLIST_ENTRY Entry;

    PAGED_CODE();

    ASSERT_OPTIONAL_VCB( Vcb );

    //
    //  Lock the CdData to perform the scan.
    //

    CdLockCdData();

    //
    //  First check the list of async closes.
    //

    Entry = CdData.AsyncCloseQueue.Flink;

    while (Entry != &CdData.AsyncCloseQueue) {

        //
        //  Extract the IrpContext.
        //

        NextIrpContext = CONTAINING_RECORD( Entry,
                                            IRP_CONTEXT,
                                            WorkQueueItem.List );

        //
        //  If no Vcb was specified or this Vcb is for our volume
        //  then perform the close.
        //

        if (!ARGUMENT_PRESENT( Vcb ) || (NextIrpContext->Vcb == Vcb)) {

            RemoveEntryList( Entry );
            CdData.AsyncCloseCount -= 1;

            IrpContext = NextIrpContext;
            break;
        }

        //
        //  Move to the next entry.
        //

        Entry = Entry->Flink;
    }

    //
    //  If we didn't find anything look through the delayed close
    //  queue.
    //
    //  We will only check the delayed close queue if we were given
    //  a Vcb or the delayed close operation is active.
    //

    if ((IrpContext == NULL) &&
        (ARGUMENT_PRESENT( Vcb ) ||
         (CdData.ReduceDelayedClose &&
          (CdData.DelayedCloseCount > CdData.MinDelayedCloseCount)))) {

        Entry = CdData.DelayedCloseQueue.Flink;

        while (Entry != &CdData.DelayedCloseQueue) {

            //
            //  Extract the IrpContext.
            //

            NextIrpContextLite = CONTAINING_RECORD( Entry,
                                                    IRP_CONTEXT_LITE,
                                                    DelayedCloseLinks );

            //
            //  If no Vcb was specified or this Vcb is for our volume
            //  then perform the close.
            //

            if (!ARGUMENT_PRESENT( Vcb ) || (NextIrpContextLite->Fcb->Vcb == Vcb)) {

                RemoveEntryList( Entry );
                CdData.DelayedCloseCount -= 1;

                IrpContext = (PIRP_CONTEXT) NextIrpContextLite;
                break;
            }

            //
            //  Move to the next entry.
            //

            Entry = Entry->Flink;
        }
    }

    //
    //  If the Vcb wasn't specified and we couldn't find an entry
    //  then turn off the Fsp thread.
    //

    if (!ARGUMENT_PRESENT( Vcb ) && (IrpContext == NULL)) {

        CdData.FspCloseActive = FALSE;
        CdData.ReduceDelayedClose = FALSE;
    }

    //
    //  Unlock the CdData.
    //

    CdUnlockCdData();

    return IrpContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\cleanup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for Cdfs called by the
    dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_CLEANUP)


NTSTATUS
CdCommonCleanup (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for cleanup of a file/directory called by both
    the fsd and fsp threads.

    Cleanup is invoked whenever the last handle to a file object is closed.
    This is different than the Close operation which is invoked when the last
    reference to a file object is deleted.

    The function of cleanup is to essentially "cleanup" the file/directory
    after a user is done with it.  The Fcb/Dcb remains around (because MM
    still has the file object referenced) but is now available for another
    user to open (i.e., as far as the user is concerned the is now closed).

    See close for a more complete description of what close does.

    We do no synchronization in this routine until we get to the point
    where we modify the counts, share access and volume lock field.

    We need to update the Fcb and Vcb to show that a user handle has been closed.
    The following structures and fields are affected.

    Vcb:

        VolumeLockFileObject - Did the user lock the volume with this file object.
        VcbState - Check if we are unlocking the volume here.
        VcbCleanup - Count of outstanding handles on the volume.
        DirNotifyQueue - If this file object has pending DirNotify Irps.

    Fcb:

        ShareAccess - If this is a user handle.
        FcbCleanup - Count of outstanding handles on this Fcb.
        Oplock - Any outstanding oplocks on this file object.
        FileLock - Any outstanding filelocks on this file object.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;

    BOOLEAN SendUnlockNotification = FALSE;
    BOOLEAN AttemptTeardown;
    BOOLEAN VcbAcquired = FALSE;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    KIRQL SavedIrql;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS.
    //

    if (IrpContext->Vcb == NULL) {

        CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Get the file object out of the Irp and decode the type of open.
    //

    FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;

    TypeOfOpen = CdDecodeFileObject( IrpContext,
                                     FileObject,
                                     &Fcb,
                                     &Ccb );

    //
    //  No work here for either an UnopenedFile object or a StreamFileObject.
    //

    if (TypeOfOpen <= StreamFileOpen) {

        CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

        return STATUS_SUCCESS;
    }

    //
    //  Keep a local pointer to the Vcb.
    //

    Vcb = Fcb->Vcb;
    
    //
    //  Synchronise with reads while we set the cleanup complete 
    //  flag on this fileobject.  Once this flag is set,  any further
    //  reads will be rejected (CdVerifyFcbOperation)
    //

    CdAcquireFileExclusive( IrpContext, Fcb);

    //
    //  Set the flag in the FileObject to indicate that cleanup is complete.
    //

    SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

    CdReleaseFile( IrpContext, Fcb);
    
    //
    //  Acquire the current file.
    //

    CdAcquireFcbExclusive( IrpContext, Fcb, FALSE );
    
    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {
    
        //
        //  Case on the type of open that we are trying to cleanup.
        //

        switch (TypeOfOpen) {

        case UserDirectoryOpen:

            //
            //  Check if we need to complete any dir notify Irps on this file object.
            //

            FsRtlNotifyCleanup( Vcb->NotifySync,
                                &Vcb->DirNotifyList,
                                Ccb );

            break;

        case UserFileOpen:

            //
            //  Coordinate the cleanup operation with the oplock state.
            //  Oplock cleanup operations can always cleanup immediately so no
            //  need to check for STATUS_PENDING.
            //

            FsRtlCheckOplock( &Fcb->Oplock,
                              Irp,
                              IrpContext,
                              NULL,
                              NULL );

            //
            //  Unlock all outstanding file locks.
            //

            if (Fcb->FileLock != NULL) {

                FsRtlFastUnlockAll( Fcb->FileLock,
                                    FileObject,
                                    IoGetRequestorProcess( Irp ),
                                    NULL );
            }

            //
            //  Cleanup the cache map.
            //

            CcUninitializeCacheMap( FileObject, NULL, NULL );

            //
            //  Check the fast io state.
            //

            CdLockFcb( IrpContext, Fcb );
            Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );
            CdUnlockFcb( IrpContext, Fcb );

            break;

        case UserVolumeOpen :

            break;

        default :

            CdBugCheck( TypeOfOpen, 0, 0 );
        }

        //
        //  Now lock the Vcb in order to modify the fields in the in-memory
        //  structures.
        //

        CdLockVcb( IrpContext, Vcb );

        //
        //  Decrement the cleanup counts in the Vcb and Fcb.
        //

        CdDecrementCleanupCounts( IrpContext, Fcb );

        //
        //  If the cleanup count hit zero and the volume is not mounted, we
        //  will want to try to spark teardown.
        //

        AttemptTeardown = (Vcb->VcbCleanup == 0 && Vcb->VcbCondition == VcbNotMounted);

        //
        //  If this file object has locked the volume then perform the unlock operation.
        //  We do this regardless of explicit or implicit (no share DASD open) lock.
        //

        if (FileObject == Vcb->VolumeLockFileObject) {

            ASSERT( FlagOn( Vcb->VcbState, VCB_STATE_LOCKED));

            IoAcquireVpbSpinLock( &SavedIrql ); 

            ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED);
            ClearFlag( Vcb->VcbState, VCB_STATE_LOCKED );
            Vcb->VolumeLockFileObject = NULL;
            SendUnlockNotification = TRUE;

            IoReleaseVpbSpinLock( SavedIrql );  
        }

        CdUnlockVcb( IrpContext, Vcb );

        //
        //  We must clean up the share access at this time, since we may not
        //  get a Close call for awhile if the file was mapped through this
        //  File Object.
        //

        IoRemoveShareAccess( FileObject, &Fcb->ShareAccess );

    } finally {

        CdReleaseFcb( IrpContext, Fcb );
        
        if (SendUnlockNotification) {
            
            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_UNLOCK );
        }
    }

    //
    //  If appropriate, try to spark teardown by purging the volume.  Should
    //  this very fileobject we were cleaning up be the last reason for the
    //  volume to remain, teardown will commence on completion of this Irp.
    //
    
    if (AttemptTeardown) {

        //
        //  Preacquire CdData here,  since the purges will generate closes which
        //  may acquire CdData if there is a possibility of tearing the volume
        //  down.
        //
        
        CdAcquireCdData( IrpContext);

        try {
            
            CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );
            VcbAcquired = TRUE;
            
            CdPurgeVolume( IrpContext, Vcb, FALSE );

        } finally {

            if (VcbAcquired) { CdReleaseVcb( IrpContext, Vcb ); }
            
            CdReleaseCdData( IrpContext);
        }
    }

    //
    //  If this is a normal termination then complete the request
    //

    CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\dirctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DirCtrl.c

Abstract:

    This module implements the File Directory Control routines for Cdfs called
    by the Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_DIRCTRL)

//
//  Local support routines
//

NTSTATUS
CdQueryDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN PCCB Ccb
    );

NTSTATUS
CdNotifyChangeDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PCCB Ccb
    );

VOID
CdInitializeEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN OUT PCCB Ccb,
    IN OUT PFILE_ENUM_CONTEXT FileContext,
    OUT PBOOLEAN ReturnNextEntry,
    OUT PBOOLEAN ReturnSingleEntry,
    OUT PBOOLEAN InitialQuery
    );

BOOLEAN
CdEnumerateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN OUT PFILE_ENUM_CONTEXT FileContext,
    IN BOOLEAN ReturnNextEntry
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonDirControl)
#pragma alloc_text(PAGE, CdEnumerateIndex)
#pragma alloc_text(PAGE, CdInitializeEnumeration)
#pragma alloc_text(PAGE, CdNotifyChangeDirectory)
#pragma alloc_text(PAGE, CdQueryDirectory)
#endif


NTSTATUS
CdCommonDirControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the entry point for the directory control operations.  These
    are directory enumerations and directory notify calls.  We verify the
    user's handle is for a directory and then call the appropriate routine.

Arguments:

    Irp - Irp for this request.

Return Value:

    NTSTATUS - Status returned from the lower level routines.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the user file object and fail this request if it is not
    //  a user directory.
    //

    if (CdDecodeFileObject( IrpContext,
                            IrpSp->FileObject,
                            &Fcb,
                            &Ccb ) != UserDirectoryOpen) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We know this is a directory control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_QUERY_DIRECTORY:

        Status = CdQueryDirectory( IrpContext, Irp, IrpSp, Fcb, Ccb );
        break;

    case IRP_MN_NOTIFY_CHANGE_DIRECTORY:

        Status = CdNotifyChangeDirectory( IrpContext, Irp, IrpSp, Ccb );
        break;

    default:

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return Status;
}


//
//  Local support routines
//

NTSTATUS
CdQueryDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the query directory operation.  It is responsible
    for either completing of enqueuing the input Irp.  We store the state of the
    search in the Ccb.

Arguments:

    Irp - Supplies the Irp to process

    IrpSp - Stack location for this Irp.

    Fcb - Fcb for this directory.

    Ccb - Ccb for this directory open.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Information = 0;

    ULONG LastEntry = 0;
    ULONG NextEntry = 0;

    ULONG FileNameBytes;
    ULONG SeparatorBytes;
    ULONG VersionStringBytes;

    FILE_ENUM_CONTEXT FileContext;
    PDIRENT ThisDirent;
    BOOLEAN InitialQuery;
    BOOLEAN ReturnNextEntry;
    BOOLEAN ReturnSingleEntry;
    BOOLEAN Found;
    BOOLEAN DoCcbUpdate = FALSE;

    PCHAR UserBuffer;
    ULONG BytesRemainingInBuffer;

    ULONG BaseLength;

    PFILE_BOTH_DIR_INFORMATION DirInfo;
    PFILE_NAMES_INFORMATION NamesInfo;
    PFILE_ID_FULL_DIR_INFORMATION IdFullDirInfo;
    PFILE_ID_BOTH_DIR_INFORMATION IdBothDirInfo;

    PAGED_CODE();

    //
    //  Check if we support this search mode.  Also remember the size of the base part of
    //  each of these structures.
    //

    switch (IrpSp->Parameters.QueryDirectory.FileInformationClass) {

    case FileDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_DIRECTORY_INFORMATION,
                                   FileName[0] );
        break;

    case FileFullDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_FULL_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileIdFullDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_ID_FULL_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileNamesInformation:

        BaseLength = FIELD_OFFSET( FILE_NAMES_INFORMATION,
                                   FileName[0] );
        break;

    case FileBothDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_BOTH_DIR_INFORMATION,
                                   FileName[0] );
        break;

    case FileIdBothDirectoryInformation:

        BaseLength = FIELD_OFFSET( FILE_ID_BOTH_DIR_INFORMATION,
                                   FileName[0] );
        break;

    default:

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_INFO_CLASS );
        return STATUS_INVALID_INFO_CLASS;
    }

    //
    //  Get the user buffer.
    //

    CdMapUserBuffer( IrpContext, &UserBuffer);

    //
    //  Initialize our search context.
    //

    CdInitializeFileContext( IrpContext, &FileContext );

    //
    //  Acquire the directory.
    //

    CdAcquireFileShared( IrpContext, Fcb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Fcb is still good.
        //

        CdVerifyFcbOperation( IrpContext, Fcb );

        //
        //  Start by getting the initial state for the enumeration.  This will set up the Ccb with
        //  the initial search parameters and let us know the starting offset in the directory
        //  to search.
        //

        CdInitializeEnumeration( IrpContext,
                                 IrpSp,
                                 Fcb,
                                 Ccb,
                                 &FileContext,
                                 &ReturnNextEntry,
                                 &ReturnSingleEntry,
                                 &InitialQuery );

        //
        //  The current dirent is stored in the InitialDirent field.  We capture
        //  this here so that we have a valid restart point even if we don't
        //  find a single entry.
        //

        ThisDirent = &FileContext.InitialDirent->Dirent;

        //
        //  At this point we are about to enter our query loop.  We have
        //  determined the index into the directory file to begin the
        //  search.  LastEntry and NextEntry are used to index into the user
        //  buffer.  LastEntry is the last entry we've added, NextEntry is
        //  current one we're working on.  If NextEntry is non-zero, then
        //  at least one entry was added.
        //

        while (TRUE) {

            //
            //  If the user had requested only a single match and we have
            //  returned that, then we stop at this point.  We update the Ccb with
            //  the status based on the last entry returned.
            //

            if ((NextEntry != 0) && ReturnSingleEntry) {

                DoCcbUpdate = TRUE;
                try_leave( Status );
            }

            //
            //  We try to locate the next matching dirent.  Our search if based on a starting
            //  dirent offset, whether we should return the current or next entry, whether
            //  we should be doing a short name search and finally whether we should be
            //  checking for a version match.
            //

            Found = CdEnumerateIndex( IrpContext, Ccb, &FileContext, ReturnNextEntry );

            //
            //  Initialize the value for the next search.
            //

            ReturnNextEntry = TRUE;

            //
            //  If we didn't receive a dirent, then we are at the end of the
            //  directory.  If we have returned any files, we exit with
            //  success, otherwise we return STATUS_NO_MORE_FILES.
            //

            if (!Found) {

                if (NextEntry == 0) {

                    Status = STATUS_NO_MORE_FILES;

                    if (InitialQuery) {

                        Status = STATUS_NO_SUCH_FILE;
                    }
                }

                DoCcbUpdate = TRUE;
                try_leave( Status );
            }

            //
            //  Remember the dirent for the file we just found.
            //

            ThisDirent = &FileContext.InitialDirent->Dirent;

            //
            //  Here are the rules concerning filling up the buffer:
            //
            //  1.  The Io system garentees that there will always be
            //      enough room for at least one base record.
            //
            //  2.  If the full first record (including file name) cannot
            //      fit, as much of the name as possible is copied and
            //      STATUS_BUFFER_OVERFLOW is returned.
            //
            //  3.  If a subsequent record cannot completely fit into the
            //      buffer, none of it (as in 0 bytes) is copied, and
            //      STATUS_SUCCESS is returned.  A subsequent query will
            //      pick up with this record.
            //

            //
            //  Let's compute the number of bytes we need to transfer the current entry.
            //

            SeparatorBytes =
            VersionStringBytes = 0;

            //
            //  We can look directly at the dirent that we found.
            //

            FileNameBytes = ThisDirent->CdFileName.FileName.Length;

            //
            //  Compute the number of bytes for the version string if
            //  we will return this. Allow directories with illegal ";".
            //

            if (((Ccb->SearchExpression.VersionString.Length != 0) ||
                 (FlagOn(ThisDirent->DirentFlags, CD_ATTRIBUTE_DIRECTORY))) &&
                (ThisDirent->CdFileName.VersionString.Length != 0)) {

                SeparatorBytes = 2;

                VersionStringBytes = ThisDirent->CdFileName.VersionString.Length;
            }

            //
            //  If the slot for the next entry would be beyond the length of the
            //  user's buffer just exit (we know we've returned at least one entry
            //  already). This will happen when we align the pointer past the end.
            //

            if (NextEntry > IrpSp->Parameters.QueryDirectory.Length) {

                ReturnNextEntry = FALSE;
                DoCcbUpdate = TRUE;
                try_leave( Status = STATUS_SUCCESS );
            }

            //
            //  Compute the number of bytes remaining in the buffer.  Round this
            //  down to a WCHAR boundary so we can copy full characters.
            //

            BytesRemainingInBuffer = IrpSp->Parameters.QueryDirectory.Length - NextEntry;
            ClearFlag( BytesRemainingInBuffer, 1 );

            //
            //  If this won't fit and we have returned a previous entry then just
            //  return STATUS_SUCCESS.
            //

            if ((BaseLength + FileNameBytes + SeparatorBytes + VersionStringBytes) > BytesRemainingInBuffer) {

                //
                //  If we already found an entry then just exit.
                //

                if (NextEntry != 0) {

                    ReturnNextEntry = FALSE;
                    DoCcbUpdate = TRUE;
                    try_leave( Status = STATUS_SUCCESS );
                }

                //
                //  Don't even try to return the version string if it doesn't all fit.
                //  Reduce the FileNameBytes to just fit in the buffer.
                //

                if ((BaseLength + FileNameBytes) > BytesRemainingInBuffer) {

                    FileNameBytes = BytesRemainingInBuffer - BaseLength;
                }

                //
                //  Don't return any version string bytes.
                //

                VersionStringBytes =
                SeparatorBytes = 0;

                //
                //  Use a status code of STATUS_BUFFER_OVERFLOW.  Also set
                //  ReturnSingleEntry so that we will exit the loop at the top.
                //

                Status = STATUS_BUFFER_OVERFLOW;
                ReturnSingleEntry = TRUE;
            }

            //
            //  Protect access to the user buffer with an exception handler.
            //  Since (at our request) IO doesn't buffer these requests, we have
            //  to guard against a user messing with the page protection and other
            //  such trickery.
            //
            
            try {
            
                //
                //  Zero and initialize the base part of the current entry.
                //

                RtlZeroMemory( Add2Ptr( UserBuffer, NextEntry, PVOID ),
                               BaseLength );
    
                //
                //  Now we have an entry to return to our caller.
                //  We'll case on the type of information requested and fill up
                //  the user buffer if everything fits.
                //

                switch (IrpSp->Parameters.QueryDirectory.FileInformationClass) {
    
                case FileBothDirectoryInformation:
                case FileFullDirectoryInformation:
                case FileIdBothDirectoryInformation:
                case FileIdFullDirectoryInformation:
                case FileDirectoryInformation:
    
                    DirInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_BOTH_DIR_INFORMATION );
    
                    //
                    //  Use the create time for all the time stamps.
                    //
    
                    CdConvertCdTimeToNtTime( IrpContext,
                                             FileContext.InitialDirent->Dirent.CdTime,
                                             &DirInfo->CreationTime );
    
                    DirInfo->LastWriteTime = DirInfo->ChangeTime = DirInfo->CreationTime;
    
                    //
                    //  Set the attributes and sizes separately for directories and
                    //  files.
                    //
    
                    if (FlagOn( ThisDirent->DirentFlags, CD_ATTRIBUTE_DIRECTORY )) {
    
                        DirInfo->EndOfFile.QuadPart = DirInfo->AllocationSize.QuadPart = 0;
    
                        SetFlag( DirInfo->FileAttributes, FILE_ATTRIBUTE_DIRECTORY );
    
                    } else {
    
                        DirInfo->EndOfFile.QuadPart = FileContext.FileSize;
                        DirInfo->AllocationSize.QuadPart = LlSectorAlign( FileContext.FileSize );
                    }
    
                    //
                    //  All Cdrom files are readonly.  We also copy the existence
                    //  bit to the hidden attribute.
                    //
    
                    SetFlag( DirInfo->FileAttributes, FILE_ATTRIBUTE_READONLY );
    
                    if (FlagOn( ThisDirent->DirentFlags,
                                CD_ATTRIBUTE_HIDDEN )) {
    
                        SetFlag( DirInfo->FileAttributes, FILE_ATTRIBUTE_HIDDEN );
                    }
    
                    DirInfo->FileIndex = ThisDirent->DirentOffset;
    
                    DirInfo->FileNameLength = FileNameBytes + SeparatorBytes + VersionStringBytes;
    
                    break;
    
                case FileNamesInformation:
    
                    NamesInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_NAMES_INFORMATION );
    
                    NamesInfo->FileIndex = ThisDirent->DirentOffset;
    
                    NamesInfo->FileNameLength = FileNameBytes + SeparatorBytes + VersionStringBytes;
    
                    break;
                }

                //
                //  Fill in the FileId
                //

                switch (IrpSp->Parameters.QueryDirectory.FileInformationClass) {

                case FileIdBothDirectoryInformation:

                    IdBothDirInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_ID_BOTH_DIR_INFORMATION );
                    CdSetFidFromParentAndDirent( IdBothDirInfo->FileId, Fcb, ThisDirent );
                    break;

                case FileIdFullDirectoryInformation:

                    IdFullDirInfo = Add2Ptr( UserBuffer, NextEntry, PFILE_ID_FULL_DIR_INFORMATION );
                    CdSetFidFromParentAndDirent( IdFullDirInfo->FileId, Fcb, ThisDirent );
                    break;

                default:
                    break;
                }
    
                //
                //  Now copy as much of the name as possible.  We also may have a version
                //  string to copy.
                //
    
                if (FileNameBytes != 0) {
    
                    //
                    //  This is a Unicode name, we can copy the bytes directly.
                    //
    
                    RtlCopyMemory( Add2Ptr( UserBuffer, NextEntry + BaseLength, PVOID ),
                                   ThisDirent->CdFileName.FileName.Buffer,
                                   FileNameBytes );
    
                    if (SeparatorBytes != 0) {
    
                        *(Add2Ptr( UserBuffer,
                                   NextEntry + BaseLength + FileNameBytes,
                                   PWCHAR )) = L';';
    
                        if (VersionStringBytes != 0) {
    
                            RtlCopyMemory( Add2Ptr( UserBuffer,
                                                    NextEntry + BaseLength + FileNameBytes + sizeof( WCHAR ),
                                                    PVOID ),
                                           ThisDirent->CdFileName.VersionString.Buffer,
                                           VersionStringBytes );
                        }
                    }
                }

                //
                //  Fill in the short name if we got STATUS_SUCCESS.  The short name
                //  may already be in the file context.  Otherwise we will check
                //  whether the long name is 8.3.  Special case the self and parent
                //  directory names.
                //

                if ((Status == STATUS_SUCCESS) &&
                    (IrpSp->Parameters.QueryDirectory.FileInformationClass == FileBothDirectoryInformation ||
                     IrpSp->Parameters.QueryDirectory.FileInformationClass == FileIdBothDirectoryInformation) &&
                    (Ccb->SearchExpression.VersionString.Length == 0) &&
                    !FlagOn( ThisDirent->Flags, DIRENT_FLAG_CONSTANT_ENTRY )) {
    
                    //
                    //  If we already have the short name then copy into the user's buffer.
                    //
    
                    if (FileContext.ShortName.FileName.Length != 0) {
    
                        RtlCopyMemory( DirInfo->ShortName,
                                       FileContext.ShortName.FileName.Buffer,
                                       FileContext.ShortName.FileName.Length );
    
                        DirInfo->ShortNameLength = (CCHAR) FileContext.ShortName.FileName.Length;
    
                    //
                    //  If the short name length is currently zero then check if
                    //  the long name is not 8.3.  We can copy the short name in
                    //  unicode form directly into the caller's buffer.
                    //
    
                    } else {
    
                        if (!CdIs8dot3Name( IrpContext,
                                            ThisDirent->CdFileName.FileName )) {
    
                            CdGenerate8dot3Name( IrpContext,
                                                 &ThisDirent->CdCaseFileName.FileName,
                                                 ThisDirent->DirentOffset,
                                                 DirInfo->ShortName,
                                                 &FileContext.ShortName.FileName.Length );
    
                            DirInfo->ShortNameLength = (CCHAR) FileContext.ShortName.FileName.Length;
                        }
                    }
    
                }

                //
                //  Sum the total number of bytes for the information field.
                //

                FileNameBytes += SeparatorBytes + VersionStringBytes;

                //
                //  Update the information with the number of bytes stored in the
                //  buffer.  We quad-align the existing buffer to add any necessary
                //  pad bytes.
                //

                Information = NextEntry + BaseLength + FileNameBytes;

                //
                //  Go back to the previous entry and fill in the update to this entry.
                //

                *(Add2Ptr( UserBuffer, LastEntry, PULONG )) = NextEntry - LastEntry;

                //
                //  Set up our variables for the next dirent.
                //

                InitialQuery = FALSE;

                LastEntry = NextEntry;
                NextEntry = QuadAlign( Information );
            
            } except (EXCEPTION_EXECUTE_HANDLER) {

                  //
                  //  We had a problem filling in the user's buffer, so stop and
                  //  fail this request.  This is the only reason any exception
                  //  would have occured at this level.
                  //
                  
                  Information = 0;
                  try_leave( Status = GetExceptionCode());
            }
        }
        
        DoCcbUpdate = TRUE;

    } finally {

        //
        //  Cleanup our search context - *before* aquiring the FCB mutex exclusive,
        //  else can block on threads in cdcreateinternalstream/purge which 
        //  hold the FCB but are waiting for all maps in this stream to be released.
        //

        CdCleanupFileContext( IrpContext, &FileContext );

        //
        //  Now we can safely aqure the FCB mutex if we need to.
        //

        if (DoCcbUpdate && !NT_ERROR( Status )) {
        
            //
            //  Update the Ccb to show the current state of the enumeration.
            //

            CdLockFcb( IrpContext, Fcb );
            
            Ccb->CurrentDirentOffset = ThisDirent->DirentOffset;

            ClearFlag( Ccb->Flags, CCB_FLAG_ENUM_RETURN_NEXT );

            if (ReturnNextEntry) {

                SetFlag( Ccb->Flags, CCB_FLAG_ENUM_RETURN_NEXT );
            }

            CdUnlockFcb( IrpContext, Fcb );
        }

        //
        //  Release the Fcb.
        //

        CdReleaseFile( IrpContext, Fcb );
    }

    //
    //  Complete the request here.
    //

    Irp->IoStatus.Information = Information;

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routines
//

NTSTATUS
CdNotifyChangeDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PIO_STACK_LOCATION IrpSp,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine performs the notify change directory operation.  It is
    responsible for either completing of enqueuing the input Irp.  Although there
    will never be a notify signalled on a CDROM disk we still support this call.

    We have already checked that this is not an OpenById handle.

Arguments:

    Irp - Supplies the Irp to process

    IrpSp - Io stack location for this request.

    Ccb - Handle to the directory being watched.

Return Value:

    NTSTATUS - STATUS_PENDING, any other error will raise.

--*/

{
    PAGED_CODE();

    //
    //  Always set the wait bit in the IrpContext so the initial wait can't fail.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    //
    //  Acquire the Vcb shared.
    //

    CdAcquireVcbShared( IrpContext, IrpContext->Vcb, FALSE );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Vcb.
        //

        CdVerifyVcb( IrpContext, IrpContext->Vcb );

        //
        //  Call the Fsrtl package to process the request.  We cast the
        //  unicode strings to ansi strings as the dir notify package
        //  only deals with memory matching.
        //

        FsRtlNotifyFullChangeDirectory( IrpContext->Vcb->NotifySync,
                                        &IrpContext->Vcb->DirNotifyList,
                                        Ccb,
                                        (PSTRING) &IrpSp->FileObject->FileName,
                                        BooleanFlagOn( IrpSp->Flags, SL_WATCH_TREE ),
                                        FALSE,
                                        IrpSp->Parameters.NotifyDirectory.CompletionFilter,
                                        Irp,
                                        NULL,
                                        NULL );

    } finally {

        //
        //  Release the Vcb.
        //

        CdReleaseVcb( IrpContext, IrpContext->Vcb );
    }

    //
    //  Cleanup the IrpContext.
    //

    CdCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return STATUS_PENDING;
}


//
//  Local support routine
//

VOID
CdInitializeEnumeration (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_STACK_LOCATION IrpSp,
    IN PFCB Fcb,
    IN OUT PCCB Ccb,
    IN OUT PFILE_ENUM_CONTEXT FileContext,
    OUT PBOOLEAN ReturnNextEntry,
    OUT PBOOLEAN ReturnSingleEntry,
    OUT PBOOLEAN InitialQuery
    )

/*++

Routine Description:

    This routine is called to initialize the enumeration variables and structures.
    We look at the state of a previous enumeration from the Ccb as well as any
    input values from the user.  On exit we will position the FileContext at
    a file in the directory and let the caller know whether this entry or the
    next entry should be returned.

Arguments:

    IrpSp - Irp stack location for this request.

    Fcb - Fcb for this directory.

    Ccb - Ccb for the directory handle.

    FileContext - FileContext to use for this enumeration.

    ReturnNextEntry - Address to store whether we should return the entry at
        the FileContext position or the next entry.

    ReturnSingleEntry - Address to store whether we should only return
        a single entry.

    InitialQuery - Address to store whether this is the first enumeration
        query on this handle.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    PUNICODE_STRING FileName;
    CD_NAME WildCardName;
    CD_NAME SearchExpression;

    ULONG CcbFlags;

    ULONG DirentOffset;
    ULONG LastDirentOffset;
    BOOLEAN KnownOffset;

    BOOLEAN Found;

    PAGED_CODE();

    //
    //  If this is the initial query then build a search expression from the input
    //  file name.
    //

    if (!FlagOn( Ccb->Flags, CCB_FLAG_ENUM_INITIALIZED )) {

        FileName = IrpSp->Parameters.QueryDirectory.FileName;

        CcbFlags = 0;

        //
        //  If the filename is not specified or is a single '*' then we will
        //  match all names.
        //

        if ((FileName == NULL) ||
            (FileName->Buffer == NULL) ||
            (FileName->Length == 0) ||
            ((FileName->Length == sizeof( WCHAR )) &&
             (FileName->Buffer[0] == L'*'))) {

            SetFlag( CcbFlags, CCB_FLAG_ENUM_MATCH_ALL );
            RtlZeroMemory( &SearchExpression, sizeof( SearchExpression ));

        //
        //  Otherwise build the CdName from the name in the stack location.
        //  This involves building both the name and version portions and
        //  checking for wild card characters.  We also upcase the string if
        //  this is a case-insensitive search.
        //

        } else {

            //
            //  Create a CdName to check for wild cards.
            //

            WildCardName.FileName = *FileName;

            CdConvertNameToCdName( IrpContext, &WildCardName );

            //
            //  The name better have at least one character.
            //

            if (WildCardName.FileName.Length == 0) {

                CdRaiseStatus( IrpContext, STATUS_INVALID_PARAMETER );
            }

            //
            //  Check for wildcards in the separate components.
            //

            if (FsRtlDoesNameContainWildCards( &WildCardName.FileName)) {

                SetFlag( CcbFlags, CCB_FLAG_ENUM_NAME_EXP_HAS_WILD );
            }

            if ((WildCardName.VersionString.Length != 0) &&
                (FsRtlDoesNameContainWildCards( &WildCardName.VersionString ))) {

                SetFlag( CcbFlags, CCB_FLAG_ENUM_VERSION_EXP_HAS_WILD );

                //
                //  Check if this is a wild card only and match all version
                //  strings.
                //

                if ((WildCardName.VersionString.Length == sizeof( WCHAR )) &&
                    (WildCardName.VersionString.Buffer[0] == L'*')) {

                    SetFlag( CcbFlags, CCB_FLAG_ENUM_VERSION_MATCH_ALL );
                }
            }

            //
            //  Now create the search expression to store in the Ccb.
            //

            SearchExpression.FileName.Buffer = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                                         FileName->Length,
                                                                         TAG_ENUM_EXPRESSION );

            SearchExpression.FileName.MaximumLength = FileName->Length;

            //
            //  Either copy the name directly or perform the upcase.
            //

            if (FlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE )) {

                Status = RtlUpcaseUnicodeString( (PUNICODE_STRING) &SearchExpression.FileName,
                                                 FileName,
                                                 FALSE );

                //
                //  This should never fail.
                //

                ASSERT( Status == STATUS_SUCCESS );

            } else {

                RtlCopyMemory( SearchExpression.FileName.Buffer,
                               FileName->Buffer,
                               FileName->Length );
            }

            //
            //  Now split into the separate name and version components.
            //

            SearchExpression.FileName.Length = WildCardName.FileName.Length;
            SearchExpression.VersionString.Length = WildCardName.VersionString.Length;
            SearchExpression.VersionString.MaximumLength = WildCardName.VersionString.MaximumLength;

            SearchExpression.VersionString.Buffer = Add2Ptr( SearchExpression.FileName.Buffer,
                                                             SearchExpression.FileName.Length + sizeof( WCHAR ),
                                                             PWCHAR );
        }

        //
        //  But we do not want to return the constant "." and ".." entries for
        //  the root directory, for consistency with the rest of Microsoft's
        //  filesystems.
        //

        if (Fcb == Fcb->Vcb->RootIndexFcb) {

            SetFlag( CcbFlags, CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY );
        }

        //
        //  Now lock the Fcb in order to update the Ccb with the inital
        //  enumeration values.
        //

        CdLockFcb( IrpContext, Fcb );

        //
        //  Check again that this is the initial search.
        //

        if (!FlagOn( Ccb->Flags, CCB_FLAG_ENUM_INITIALIZED )) {

            //
            //  Update the values in the Ccb.
            //

            Ccb->CurrentDirentOffset = Fcb->StreamOffset;
            Ccb->SearchExpression = SearchExpression;

            //
            //  Set the appropriate flags in the Ccb.
            //

            SetFlag( Ccb->Flags, CcbFlags | CCB_FLAG_ENUM_INITIALIZED );

        //
        //  Otherwise cleanup any buffer allocated here.
        //

        } else {

            if (!FlagOn( CcbFlags, CCB_FLAG_ENUM_MATCH_ALL )) {

                CdFreePool( &SearchExpression.FileName.Buffer );
            }
        }

    //
    //  Otherwise lock the Fcb so we can read the current enumeration values.
    //

    } else {

        CdLockFcb( IrpContext, Fcb );
    }

    //
    //  Capture the current state of the enumeration.
    //
    //  If the user specified an index then use his offset.  We always
    //  return the next entry in this case.
    //

    if (FlagOn( IrpSp->Flags, SL_INDEX_SPECIFIED )) {

        KnownOffset = FALSE;
        DirentOffset = IrpSp->Parameters.QueryDirectory.FileIndex;
        *ReturnNextEntry = TRUE;

    //
    //  If we are restarting the scan then go from the self entry.
    //

    } else if (FlagOn( IrpSp->Flags, SL_RESTART_SCAN )) {

        KnownOffset = TRUE;
        DirentOffset = Fcb->StreamOffset;
        *ReturnNextEntry = FALSE;

    //
    //  Otherwise use the values from the Ccb.
    //

    } else {

        KnownOffset = TRUE;
        DirentOffset = Ccb->CurrentDirentOffset;
        *ReturnNextEntry = BooleanFlagOn( Ccb->Flags, CCB_FLAG_ENUM_RETURN_NEXT );
    }

    //
    //  Unlock the Fcb.
    //

    CdUnlockFcb( IrpContext, Fcb );

    //
    //  We have the starting offset in the directory and whether to return
    //  that entry or the next.  If we are at the beginning of the directory
    //  and are returning that entry, then tell our caller this is the
    //  initial query.
    //

    *InitialQuery = FALSE;

    if ((DirentOffset == Fcb->StreamOffset) &&
        !(*ReturnNextEntry)) {

        *InitialQuery = TRUE;
    }

    //
    //  If there is no file object then create it now.
    //

    if (Fcb->FileObject == NULL) {

        CdCreateInternalStream( IrpContext, Fcb->Vcb, Fcb );
    }

    //
    //  Determine the offset in the stream to position the FileContext and
    //  whether this offset is known to be a file offset.
    //
    //  If this offset is known to be safe then go ahead and position the
    //  file context.  This handles the cases where the offset is the beginning
    //  of the stream, the offset is from a previous search or this is the
    //  initial query.
    //

    if (KnownOffset) {

        CdLookupInitialFileDirent( IrpContext, Fcb, FileContext, DirentOffset );

    //
    //  Otherwise we walk through the directory from the beginning until
    //  we reach the entry which contains this offset.
    //

    } else {

        LastDirentOffset = Fcb->StreamOffset;
        Found = TRUE;

        CdLookupInitialFileDirent( IrpContext, Fcb, FileContext, LastDirentOffset );

        //
        //  If the requested offset is prior to the beginning offset in the stream
        //  then don't return the next entry.
        //

        if (DirentOffset < LastDirentOffset) {

            *ReturnNextEntry = FALSE;

        //
        //  Else look for the last entry which ends past the desired index.
        //

        } else {

            //
            //  Keep walking through the directory until we run out of
            //  entries or we find an entry which ends beyond the input
            //  index value.
            //

            do {

                //
                //  If we have passed the index value then exit.
                //

                if (FileContext->InitialDirent->Dirent.DirentOffset > DirentOffset) {

                    Found = FALSE;
                    break;
                }

                //
                //  Remember the current position in case we need to go back.
                //

                LastDirentOffset = FileContext->InitialDirent->Dirent.DirentOffset;

                //
                //  Exit if the next entry is beyond the desired index value.
                //

                if (LastDirentOffset + FileContext->InitialDirent->Dirent.DirentLength > DirentOffset) {

                    break;
                }

                Found = CdLookupNextInitialFileDirent( IrpContext, Fcb, FileContext );

            } while (Found);

            //
            //  If we didn't find the entry then go back to the last known entry.
            //  This can happen if the index lies in the unused range at the
            //  end of a sector.
            //

            if (!Found) {

                CdCleanupFileContext( IrpContext, FileContext );
                CdInitializeFileContext( IrpContext, FileContext );

                CdLookupInitialFileDirent( IrpContext, Fcb, FileContext, LastDirentOffset );
            }
        }
    }

    //
    //  Only update the dirent name if we will need it for some reason.
    //  Don't update this name if we are returning the next entry and
    //  the search string has a version component.
    //

    FileContext->ShortName.FileName.Length = 0;

    if (!(*ReturnNextEntry) ||
        (Ccb->SearchExpression.VersionString.Length == 0)) {

        //
        //  Update the name in the dirent into filename and version components.
        //

        CdUpdateDirentName( IrpContext,
                            &FileContext->InitialDirent->Dirent,
                            FlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ));
    }

    //
    //  Look at the flag in the IrpSp indicating whether to return just
    //  one entry.
    //

    *ReturnSingleEntry = FALSE;

    if (FlagOn( IrpSp->Flags, SL_RETURN_SINGLE_ENTRY )) {

        *ReturnSingleEntry = TRUE;
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
CdEnumerateIndex (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb,
    IN OUT PFILE_ENUM_CONTEXT FileContext,
    IN BOOLEAN ReturnNextEntry
    )

/*++

Routine Description:

    This routine is the worker routine for index enumeration.  We are positioned
    at some dirent in the directory and will either return the first match
    at that point or look to the next entry.  The Ccb contains details about
    the type of matching to do.  If the user didn't specify a version in
    his search string then we only return the first version of a sequence
    of files with versions.  We also don't return any associated files.

Arguments:

    Ccb - Ccb for this directory handle.

    FileContext - File context already positioned at some entry in the directory.

    ReturnNextEntry - Indicates if we are returning this entry or should start
        with the next entry.

Return Value:

    BOOLEAN - TRUE if next entry is found, FALSE otherwise.

--*/

{
    PDIRENT PreviousDirent = NULL;
    PDIRENT ThisDirent = &FileContext->InitialDirent->Dirent;

    BOOLEAN Found = FALSE;

    PAGED_CODE();

    //
    //  Loop until we find a match or exaust the directory.
    //

    while (TRUE) {

        //
        //  Move to the next entry unless we want to consider the current
        //  entry.
        //

        if (ReturnNextEntry) {

            if (!CdLookupNextInitialFileDirent( IrpContext, Ccb->Fcb, FileContext )) {

                break;
            }

            PreviousDirent = ThisDirent;
            ThisDirent = &FileContext->InitialDirent->Dirent;

            CdUpdateDirentName( IrpContext, ThisDirent, FlagOn( Ccb->Flags, CCB_FLAG_IGNORE_CASE ));
        
        } else {

            ReturnNextEntry = TRUE;
        }

        //
        //  Don't bother if we have a constant entry and are ignoring them.
        //
        
        if (FlagOn( ThisDirent->Flags, DIRENT_FLAG_CONSTANT_ENTRY ) &&
            FlagOn( Ccb->Flags, CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY )) {

            continue;
        }

        //
        //  Look at the current entry if it is not an associated file
        //  and the name doesn't match the previous file if the version
        //  name is not part of the search.
        //

        if (!FlagOn( ThisDirent->DirentFlags, CD_ATTRIBUTE_ASSOC )) {

            //
            //  Check if this entry matches the previous entry except
            //  for version number and whether we should return the
            //  entry in that case.  Go directly to the name comparison
            //  if:
            //
            //      There is no previous entry.
            //      The search expression has a version component.
            //      The name length doesn't match the length of the previous entry.
            //      The base name strings don't match.
            //

            if ((PreviousDirent == NULL) ||
                (Ccb->SearchExpression.VersionString.Length != 0) ||
                (PreviousDirent->CdCaseFileName.FileName.Length != ThisDirent->CdCaseFileName.FileName.Length) ||
                FlagOn( PreviousDirent->DirentFlags, CD_ATTRIBUTE_ASSOC ) ||
                !RtlEqualMemory( PreviousDirent->CdCaseFileName.FileName.Buffer,
                                 ThisDirent->CdCaseFileName.FileName.Buffer,
                                 ThisDirent->CdCaseFileName.FileName.Length )) {

                //
                //  If we match all names then return to our caller.
                //

                if (FlagOn( Ccb->Flags, CCB_FLAG_ENUM_MATCH_ALL )) {

                    FileContext->ShortName.FileName.Length = 0;
                    Found = TRUE;
                    break;
                }

                //
                //  Check if the long name matches the search expression.
                //

                if (CdIsNameInExpression( IrpContext,
                                          &ThisDirent->CdCaseFileName,
                                          &Ccb->SearchExpression,
                                          Ccb->Flags,
                                          TRUE )) {

                    //
                    //  Let our caller know we found an entry.
                    //

                    Found = TRUE;
                    FileContext->ShortName.FileName.Length = 0;
                    break;
                }

                //
                //  The long name didn't match so we need to check for a
                //  possible short name match.  There is no match if the
                //  long name is 8dot3 or the search expression has a
                //  version component.  Special case the self and parent
                //  entries.
                //

                if ((Ccb->SearchExpression.VersionString.Length == 0) &&
                    !FlagOn( ThisDirent->Flags, DIRENT_FLAG_CONSTANT_ENTRY ) &&
                    !CdIs8dot3Name( IrpContext,
                                    ThisDirent->CdFileName.FileName )) {

                    CdGenerate8dot3Name( IrpContext,
                                         &ThisDirent->CdCaseFileName.FileName,
                                         ThisDirent->DirentOffset,
                                         FileContext->ShortName.FileName.Buffer,
                                         &FileContext->ShortName.FileName.Length );

                    //
                    //  Check if this name matches.
                    //

                    if (CdIsNameInExpression( IrpContext,
                                              &FileContext->ShortName,
                                              &Ccb->SearchExpression,
                                              Ccb->Flags,
                                              FALSE )) {

                        //
                        //  Let our caller know we found an entry.
                        //

                        Found = TRUE;
                        break;
                    }
                }
            }
        }
    }

    //
    //  If we found the entry then make sure we walk through all of the
    //  file dirents.
    //

    if (Found) {

        CdLookupLastFileDirent( IrpContext, Ccb->Fcb, FileContext );
    }

    return Found;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\dirsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DirSup.c

Abstract:

    This module implements the dirent support routines for Cdfs.

    Directories on a CD consist of a number of contiguous sectors on
    the disk.  File descriptors consist of one or more directory entries
    (dirents) within a directory.  Files may contain version numbers.  If
    present all like-named files will be ordered contiguously in the
    directory by decreasing version numbers.  We will only return the
    first of these on a directory query unless the user explicitly
    asks for version numbers.  Finally dirents will not span sector
    boundaries.  Unused bytes at the end of a sector will be zero
    filled.

    Directory sector:                                                   Offset
                                                                        2048
        +---------------------------------------------------------------+
        |            |          |          |           |          |     |
        | foo;4      | foo;4    | foo;3    |  hat      |  zebra   | Zero|
        |            |          |          |           |          | Fill|
        |            |  final   |  single  |           |          |     |
        |            |  extent  |   extent |           |          |     |
        +---------------------------------------------------------------+

    Dirent operations:

        - Position scan at known offset in directory.  Dirent at this
            offset must exist and is valid.  Used when scanning a directory
            from the beginning when the self entry is known to be valid.
            Used when positioning at the first dirent for an open
            file to scan the allocation information.  Used when resuming
            a directory enumeration from a valid directory entry.

        - Position scan at known offset in directory.  Dirent is known to
            start at this position but must be checked for validity.
            Used to read the self-directory entry.

        - Move to the next dirent within a directory.

        - Given a known starting dirent, collect all the dirents for
            that file.  Scan will finish positioned at the last dirent
            for the file.  We will accumulate the extent lengths to
            find the size of the file.

        - Given a known starting dirent, position the scan for the first
            dirent of the following file.  Used when not interested in
            all of the details for the current file and are looking for
            the next file.

        - Update a common dirent structure with the details of the on-disk
            structure.  This is used to smooth out the differences

        - Build the filename (name and version strings) out of the stream
            of bytes in the file name on disk.  For Joliet disks we will have
            to convert to little endian.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_DIRSUP)

//
//  Local macros
//

//
//  PRAW_DIRENT
//  CdRawDirent (
//      IN PIRP_CONTEXT IrpContext,
//      IN PDIR_ENUM_CONTEXT DirContext
//      );
//

#define CdRawDirent(IC,DC)                                      \
    Add2Ptr( (DC)->Sector, (DC)->SectorOffset, PRAW_DIRENT )

//
//  Local support routines
//

ULONG
CdCheckRawDirentBounds (
    IN PIRP_CONTEXT IrpContext,
    IN PDIRENT_ENUM_CONTEXT DirContext
    );

XA_EXTENT_TYPE
CdCheckForXAExtent (
    IN PIRP_CONTEXT IrpContext,
    IN PRAW_DIRENT RawDirent,
    IN OUT PDIRENT Dirent
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCheckForXAExtent)
#pragma alloc_text(PAGE, CdCheckRawDirentBounds)
#pragma alloc_text(PAGE, CdCleanupFileContext)
#pragma alloc_text(PAGE, CdFindFile)
#pragma alloc_text(PAGE, CdFindDirectory)
#pragma alloc_text(PAGE, CdFindFileByShortName)
#pragma alloc_text(PAGE, CdLookupDirent)
#pragma alloc_text(PAGE, CdLookupLastFileDirent)
#pragma alloc_text(PAGE, CdLookupNextDirent)
#pragma alloc_text(PAGE, CdLookupNextInitialFileDirent)
#pragma alloc_text(PAGE, CdUpdateDirentFromRawDirent)
#pragma alloc_text(PAGE, CdUpdateDirentName)
#endif


VOID
CdLookupDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG DirentOffset,
    OUT PDIRENT_ENUM_CONTEXT DirContext
    )

/*++

Routine Description:

    This routine is called to initiate a walk through a directory.  We will
    position ourselves in the directory at offset DirentOffset.  We know that
    a dirent begins at this boundary but may have to verify the dirent bounds.
    We will call this routine when looking up the first entry of a known
    file or verifying the self entry of a directory.

Arguments:

    Fcb - Fcb for the directory being traversed.

    DirentOffset - This is our target point in the directory.  We will map the
        page containing this entry and possibly verify the dirent bounds at
        this location.

    DirContext - This is the dirent context for this scan.  We update it with
        the location of the dirent we found.  This structure has been initialized
        outside of this call.

Return Value:

    None.

--*/

{
    LONGLONG BaseOffset;

    PAGED_CODE();

    //
    //  Initialize the offset of the first dirent we want to map.
    //

    DirContext->BaseOffset = SectorTruncate( DirentOffset );
    BaseOffset = DirContext->BaseOffset;

    DirContext->DataLength = SECTOR_SIZE;

    DirContext->SectorOffset = SectorOffset( DirentOffset );

    //
    //  Truncate the data length if we are at the end of the file.
    //

    if (DirContext->DataLength > (Fcb->FileSize.QuadPart - BaseOffset)) {

        DirContext->DataLength = (ULONG) (Fcb->FileSize.QuadPart - BaseOffset);
    }

    //
    //  Now map the data at this offset.
    //

    CcMapData( Fcb->FileObject,
               (PLARGE_INTEGER) &BaseOffset,
               DirContext->DataLength,
               TRUE,
               &DirContext->Bcb,
               &DirContext->Sector );

    //
    //  Verify the dirent bounds.
    //

    DirContext->NextDirentOffset = CdCheckRawDirentBounds( IrpContext,
                                                           DirContext );

    return;
}


BOOLEAN
CdLookupNextDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIRENT_ENUM_CONTEXT CurrentDirContext,
    OUT PDIRENT_ENUM_CONTEXT NextDirContext
    )

/*++

Routine Description:

    This routine is called to find the next dirent in the directory.  The
    current position is given and we look for the next.  We leave the context
    for the starting position untouched and update the context for the
    dirent we found.  The target context may already be initialized so we
    may already have the sector in memory.

    This routine will position the enumeration context for the next dirent and
    verify the dirent bounds.

    NOTE - This routine can be called with CurrentDirContext and NextDirContext
        pointing to the same enumeration context.

Arguments:

    Fcb - Fcb for the directory being traversed.

    CurrentDirContext - This is the dirent context for this scan.  We update
        it with the location of the dirent we found.  This is currently
        pointing to a dirent location.  The dirent bounds at this location
        have already been verified.

    NextDirContext - This is the dirent context to update with the dirent we
        find.  This may already point to a dirent so we need to check if
        we are in the same sector and unmap any buffer as necessary.

        This dirent is left in an indeterminant state if we don't find a dirent.

Return Value:

    BOOLEAN - TRUE if we find a location for the next dirent, FALSE otherwise.
        This routine can cause a raise if the directory is corrupt.

--*/

{
    LONGLONG CurrentBaseOffset = CurrentDirContext->BaseOffset;
    ULONG TempUlong;

    BOOLEAN FoundDirent = FALSE;

    PAGED_CODE();

    //
    //  Check if a different sector is mapped.  If so then move our target
    //  enumeration context to the same sector.
    //

    if ((CurrentDirContext->BaseOffset != NextDirContext->BaseOffset) ||
        (NextDirContext->Bcb == NULL)) {

        //
        //  Unpin the current target Bcb and map the next sector.
        //

        CdUnpinData( IrpContext, &NextDirContext->Bcb );

        CcMapData( Fcb->FileObject,
                   (PLARGE_INTEGER) &CurrentBaseOffset,
                   CurrentDirContext->DataLength,
                   TRUE,
                   &NextDirContext->Bcb,
                   &NextDirContext->Sector );

        //
        //  Copy the data length and sector offset.
        //

        NextDirContext->DataLength = CurrentDirContext->DataLength;
        NextDirContext->BaseOffset = CurrentDirContext->BaseOffset;
    }

    //
    //  Now move to the same offset in the sector.
    //

    NextDirContext->SectorOffset = CurrentDirContext->SectorOffset;

    //
    //  If the value is zero then unmap the current sector and set up
    //  the base offset to the beginning of the next sector.
    //

    if (CurrentDirContext->NextDirentOffset == 0) {

        CurrentBaseOffset = NextDirContext->BaseOffset + NextDirContext->DataLength;

        //
        //  Unmap the current sector.  We test the value of the Bcb in the
        //  loop below to see if we need to read in another sector.
        //

        CdUnpinData( IrpContext, &NextDirContext->Bcb );

    //
    //  There is another possible dirent in the current sector.  Update the
    //  enumeration context to reflect this.
    //

    } else {

        NextDirContext->SectorOffset += CurrentDirContext->NextDirentOffset;
    }

    //
    //  Now loop until we find the next possible dirent or walk off the directory.
    //

    while (TRUE) {

        //
        //  If we don't currently have a sector mapped then map the
        //  directory at the current offset.
        //

        if (NextDirContext->Bcb == NULL) {

            TempUlong = SECTOR_SIZE;

            if (TempUlong > (ULONG) (Fcb->FileSize.QuadPart - CurrentBaseOffset)) {

                TempUlong = (ULONG) (Fcb->FileSize.QuadPart - CurrentBaseOffset);

                //
                //  If the length is zero then there is no dirent.
                //

                if (TempUlong == 0) {

                    break;
                }
            }

            CcMapData( Fcb->FileObject,
                       (PLARGE_INTEGER) &CurrentBaseOffset,
                       TempUlong,
                       TRUE,
                       &NextDirContext->Bcb,
                       &NextDirContext->Sector );

            NextDirContext->BaseOffset = (ULONG) CurrentBaseOffset;
            NextDirContext->SectorOffset = 0;
            NextDirContext->DataLength = TempUlong;
        }

        //
        //  The CDFS spec allows for sectors in a directory to contain all zeroes.
        //  In this case we need to move to the next sector.  So look at the
        //  current potential dirent for a zero length.  Move to the next
        //  dirent if length is zero.
        //

        if (*((PCHAR) CdRawDirent( IrpContext, NextDirContext )) != 0) {

            FoundDirent = TRUE;
            break;
        }

        CurrentBaseOffset = NextDirContext->BaseOffset + NextDirContext->DataLength;
        CdUnpinData( IrpContext, &NextDirContext->Bcb );
    }

    //
    //  Check the dirent bounds if we found a dirent.
    //

    if (FoundDirent) {

        NextDirContext->NextDirentOffset = CdCheckRawDirentBounds( IrpContext,
                                                                   NextDirContext );
    }

    return FoundDirent;
}


VOID
CdUpdateDirentFromRawDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PDIRENT_ENUM_CONTEXT DirContext,
    IN OUT PDIRENT Dirent
    )

/*++

Routine Description:

    This routine is called to safely copy the data from the dirent on disk
    to the in-memory dirent.  The fields on disk are unaligned so we
    need to safely copy them to our structure.

Arguments:

    Fcb - Fcb for the directory being scanned.

    DirContext - Enumeration context for the raw disk dirent.

    Dirent - In-memory dirent to update.

Return Value:

    None.

--*/

{
    PRAW_DIRENT RawDirent = CdRawDirent( IrpContext, DirContext );

    PAGED_CODE();

    //
    //  Clear all of the current state flags except the flag indicating that
    //  we allocated a name string.
    //

    ClearFlag( Dirent->Flags, DIRENT_FLAG_NOT_PERSISTENT );

    //
    //  The dirent offset is the sum of the start of the sector and the
    //  sector offset.
    //

    Dirent->DirentOffset = DirContext->BaseOffset + DirContext->SectorOffset;

    //
    //  Copy the dirent length from the raw dirent.
    //

    Dirent->DirentLength = RawDirent->DirLen;

    //
    //  The starting offset on disk is computed by finding the starting
    //  logical block and stepping over the Xar block.
    //

    CopyUchar4( &Dirent->StartingOffset, RawDirent->FileLoc );

    Dirent->StartingOffset += RawDirent->XarLen;

    //
    //  Do a safe copy to get the data length.
    //

    CopyUchar4( &Dirent->DataLength, RawDirent->DataLen );

    //
    //  Save a pointer to the time stamps.
    //

    Dirent->CdTime = RawDirent->RecordTime;

    //
    //  Copy the dirent flags.
    //

    Dirent->DirentFlags = CdRawDirentFlags( IrpContext, RawDirent );

    //
    //  For both the file unit and interleave skip we want to take the
    //  logical block count.
    //

    Dirent->FileUnitSize =
    Dirent->InterleaveGapSize = 0;

    if (RawDirent->IntLeaveSize != 0) {

        Dirent->FileUnitSize = RawDirent->IntLeaveSize;
        Dirent->InterleaveGapSize = RawDirent->IntLeaveSkip;
    }

    //
    //  Get the name length and remember a pointer to the start of the
    //  name string.  We don't do any processing on the name at this
    //  point.
    //
    //  Check that the name length is non-zero.
    //

    if (RawDirent->FileIdLen == 0) {

        CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    Dirent->FileNameLen = RawDirent->FileIdLen;
    Dirent->FileName = RawDirent->FileId;

    //
    //  If there are any remaining bytes at the end of the dirent then
    //  there may be a system use area.  We protect ourselves from
    //  disks which don't pad the dirent entries correctly by using
    //  a fudge factor of one.  All system use areas must have a length
    //  greater than one.  Don't bother with the system use area
    //  if this is a directory.
    //

    Dirent->XAAttributes = 0;
    Dirent->XAFileNumber = 0;
    Dirent->ExtentType = Form1Data;
    Dirent->SystemUseOffset = 0;

    if (!FlagOn( Dirent->DirentFlags, CD_ATTRIBUTE_DIRECTORY ) &&
        (Dirent->DirentLength > ((FIELD_OFFSET( RAW_DIRENT, FileId ) + Dirent->FileNameLen) + 1))) {

        Dirent->SystemUseOffset = WordAlign( FIELD_OFFSET( RAW_DIRENT, FileId ) + Dirent->FileNameLen );
    }

    return;
}


VOID
CdUpdateDirentName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PDIRENT Dirent,
    IN ULONG IgnoreCase
    )

/*++

Routine Description:

    This routine is called to update the name in the dirent with the name
    from the disk.  We will look for the special case of the self and
    parent entries and also construct the Unicode name for the Joliet disk
    in order to work around the BigEndian on-disk structure.

Arguments:

    Dirent - Pointer to the in-memory dirent structure.

    IgnoreCase - TRUE if we should build the upcased version.  Otherwise we
        use the exact case name.

Return Value:

    None.

--*/

{
    UCHAR DirectoryValue;
    ULONG Length;

    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Check if this is a self or parent entry.  There is no version number
    //  in these cases.  We use a fixed string for these.
    //
    //      Self-Entry - Length is 1, value is 0.
    //      Parent-Entry - Length is 1, value is 1.
    //

    if ((Dirent->FileNameLen == 1) &&
        FlagOn( Dirent->DirentFlags, CD_ATTRIBUTE_DIRECTORY )) {

        DirectoryValue = *((PCHAR) Dirent->FileName);

        if ((DirectoryValue == 0) || (DirectoryValue == 1)) {

            //
            //  We should not have allocated a name by the time we see these cases.
            //  If we have, this means that the image is in violation of ISO 9660 7.6.2,
            //  which states that the ./.. entries must be the first two in the directory.
            //

            if (FlagOn( Dirent->Flags, DIRENT_FLAG_ALLOC_BUFFER )) {

                CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            //
            //  Now use one of the hard coded directory names.
            //

            Dirent->CdFileName.FileName = CdUnicodeDirectoryNames[DirectoryValue];

            //
            //  Show that there is no version number.
            //

            Dirent->CdFileName.VersionString.Length = 0;

            //
            //  The case name is the same as the exact name.
            //

            Dirent->CdCaseFileName = Dirent->CdFileName;

            //
            //  Mark this as a constant value entry.
            //

            SetFlag( Dirent->Flags, DIRENT_FLAG_CONSTANT_ENTRY );

            //
            //  Return now.
            //

            return;
        }
    }

    //
    //  Mark this as a non-constant value entry.
    //

    ClearFlag( Dirent->Flags, DIRENT_FLAG_CONSTANT_ENTRY );

    //
    //  Compute how large a buffer we will need.  If this is an ignore
    //  case operation then we will want a double size buffer.  If the disk is not
    //  a Joliet disk then we might need two bytes for each byte in the name.
    //

    Length = Dirent->FileNameLen;

    if (IgnoreCase) {

        Length *= 2;
    }

    if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_JOLIET )) {

        Length *= sizeof( WCHAR );
    }

    //
    //  Now decide if we need to allocate a new buffer.  We will if
    //  this name won't fit in the embedded name buffer and it is
    //  larger than the current allocated buffer.  We always use the
    //  allocated buffer if present.
    //
    //  If we haven't allocated a buffer then use the embedded buffer if the data
    //  will fit.  This is the typical case.
    //

    if (!FlagOn( Dirent->Flags, DIRENT_FLAG_ALLOC_BUFFER ) &&
        (Length <= sizeof( Dirent->NameBuffer ))) {

        Dirent->CdFileName.FileName.MaximumLength = sizeof( Dirent->NameBuffer );
        Dirent->CdFileName.FileName.Buffer = Dirent->NameBuffer;

    } else {

        //
        //  We need to use an allocated buffer.  Check if the current buffer
        //  is large enough.
        //

        if (Length > Dirent->CdFileName.FileName.MaximumLength) {

            //
            //  Free any allocated buffer.
            //

            if (FlagOn( Dirent->Flags, DIRENT_FLAG_ALLOC_BUFFER )) {

                CdFreePool( &Dirent->CdFileName.FileName.Buffer );
                ClearFlag( Dirent->Flags, DIRENT_FLAG_ALLOC_BUFFER );
            }

            Dirent->CdFileName.FileName.Buffer = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                                            Length,
                                                                            TAG_DIRENT_NAME );

            SetFlag( Dirent->Flags, DIRENT_FLAG_ALLOC_BUFFER );

            Dirent->CdFileName.FileName.MaximumLength = (USHORT) Length;
        }
    }

    //
    //  We now have a buffer for the name.  We need to either convert the on-disk bigendian
    //  to little endian or covert the name to Unicode.
    //

    if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_JOLIET )) {

        Status = RtlOemToUnicodeN( Dirent->CdFileName.FileName.Buffer,
                                   Dirent->CdFileName.FileName.MaximumLength,
                                   &Length,
                                   Dirent->FileName,
                                   Dirent->FileNameLen );

        ASSERT( Status == STATUS_SUCCESS );
        Dirent->CdFileName.FileName.Length = (USHORT) Length;

    } else {

        //
        //  Convert this string to little endian.
        //

        CdConvertBigToLittleEndian( IrpContext,
                                    Dirent->FileName,
                                    Dirent->FileNameLen,
                                    (PCHAR) Dirent->CdFileName.FileName.Buffer );

        Dirent->CdFileName.FileName.Length = (USHORT) Dirent->FileNameLen;
    }

    //
    //  Split the name into name and version strings.
    //

    CdConvertNameToCdName( IrpContext,
                           &Dirent->CdFileName );

    //
    //  The name length better be non-zero.
    //

    if (Dirent->CdFileName.FileName.Length == 0) {

        CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    //
    //  If the filename ends with a period then back up one character.
    //

    if (Dirent->CdFileName.FileName.Buffer[(Dirent->CdFileName.FileName.Length - sizeof( WCHAR )) / 2] == L'.') {

        //
        //  Slide the version string down.
        //

        if (Dirent->CdFileName.VersionString.Length != 0) {

            PWCHAR NewVersion;

            //
            //  Start from the position currently containing the separator.
            //

            NewVersion = Add2Ptr( Dirent->CdFileName.FileName.Buffer,
                                  Dirent->CdFileName.FileName.Length,
                                  PWCHAR );

            //
            //  Now overwrite the period.
            //

            RtlMoveMemory( NewVersion - 1,
                           NewVersion,
                           Dirent->CdFileName.VersionString.Length + sizeof( WCHAR ));

            //
            //  Now point to the new version string.
            //

            Dirent->CdFileName.VersionString.Buffer = NewVersion;
        }

        //
        //  Shrink the filename length.
        //

        Dirent->CdFileName.FileName.Length -= sizeof( WCHAR );
    }

    //
    //  If this an exact case operation then use the filename exactly.
    //

    if (!IgnoreCase) {

        Dirent->CdCaseFileName = Dirent->CdFileName;

    //
    //  Otherwise perform our upcase operation.  We already have guaranteed the buffers are
    //  there.
    //

    } else {

        Dirent->CdCaseFileName.FileName.Buffer = Add2Ptr( Dirent->CdFileName.FileName.Buffer,
                                                          Dirent->CdFileName.FileName.MaximumLength / 2,
                                                          PWCHAR);

        Dirent->CdCaseFileName.FileName.MaximumLength = Dirent->CdFileName.FileName.MaximumLength / 2;

        CdUpcaseName( IrpContext,
                      &Dirent->CdFileName,
                      &Dirent->CdCaseFileName );
    }

    return;
}


BOOLEAN
CdFindFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN OUT PFILE_ENUM_CONTEXT FileContext,
    OUT PCD_NAME *MatchingName
    )

/*++

Routine Description:

    This routine is called to search a dirctory for a file matching the input
    name.  This name has been upcased at this point if this a case-insensitive
    search.  The name has been separated into separate name and version strings.
    We look for an exact match in the name and only consider the version if
    there is a version specified in the search name.

Arguments:

    Fcb - Fcb for the directory being scanned.

    Name - Name to search for.

    IgnoreCase - Indicates the case of the search.

    FileContext - File context to use for the search.  This has already been
        initialized.

    MatchingName - Pointer to buffer containing matching name.  We need this
        in case we don't match the name in the directory but match the
        short name instead.

Return Value:

    BOOLEAN - TRUE if matching entry is found, FALSE otherwise.

--*/

{
    PDIRENT Dirent;
    ULONG ShortNameDirentOffset;

    BOOLEAN Found = FALSE;

    PAGED_CODE();

    //
    //  Make sure there is a stream file for this Fcb.
    //

    if (Fcb->FileObject == NULL) {

        CdCreateInternalStream( IrpContext, Fcb->Vcb, Fcb );
    }

    //
    //  Check to see whether we need to check for a possible short name.
    //

    ShortNameDirentOffset = CdShortNameDirentOffset( IrpContext, &Name->FileName );

    //
    //  Position ourselves at the first entry.
    //

    CdLookupInitialFileDirent( IrpContext, Fcb, FileContext, Fcb->StreamOffset );

    //
    //  Loop while there are more entries in this directory.
    //

    do {

        Dirent = &FileContext->InitialDirent->Dirent;

        //
        //  We only consider files which don't have the associated bit set.
        //  We also only look for files.  All directories would already
        //  have been found.
        //

        if (!FlagOn( Dirent->DirentFlags, CD_ATTRIBUTE_ASSOC | CD_ATTRIBUTE_DIRECTORY )) {

            //
            //  Update the name in the current dirent.
            //

            CdUpdateDirentName( IrpContext, Dirent, IgnoreCase );

            //
            //  Don't bother with constant entries.
            //

            if (FlagOn( Dirent->Flags, DIRENT_FLAG_CONSTANT_ENTRY )) {

                continue;
            }

            //
            //  Now check whether we have a name match.
            //  We exit the loop if we have a match.
            //

            if (CdIsNameInExpression( IrpContext,
                                      &Dirent->CdCaseFileName,
                                      Name,
                                      0,
                                      TRUE )) {

                *MatchingName = &Dirent->CdCaseFileName;
                Found = TRUE;
                break;
            }

            //
            //  The names didn't match.  If the input name is a possible short
            //  name and we are at the correct offset in the directory then
            //  check if the short names match.
            //

            if (((Dirent->DirentOffset >> SHORT_NAME_SHIFT) == ShortNameDirentOffset) &&
                (Name->VersionString.Length == 0) &&
                !CdIs8dot3Name( IrpContext,
                                Dirent->CdFileName.FileName )) {

                //
                //  Create the short name and check for a match.
                //

                CdGenerate8dot3Name( IrpContext,
                                     &Dirent->CdCaseFileName.FileName,
                                     Dirent->DirentOffset,
                                     FileContext->ShortName.FileName.Buffer,
                                     &FileContext->ShortName.FileName.Length );

                //
                //  Now check whether we have a name match.
                //  We exit the loop if we have a match.
                //

                if (CdIsNameInExpression( IrpContext,
                                          &FileContext->ShortName,
                                          Name,
                                          0,
                                          FALSE )) {

                    *MatchingName = &FileContext->ShortName,
                    Found = TRUE;
                    break;
                }
            }
        }

        //
        //  Go to the next initial dirent for a file.
        //

    } while (CdLookupNextInitialFileDirent( IrpContext, Fcb, FileContext ));

    //
    //  If we find the file then collect all of the dirents.
    //

    if (Found) {

        CdLookupLastFileDirent( IrpContext, Fcb, FileContext );

    }

    return Found;
}


BOOLEAN
CdFindDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN OUT PFILE_ENUM_CONTEXT FileContext
    )

/*++

Routine Description:

    This routine is called to search a dirctory for a directory matching the input
    name.  This name has been upcased at this point if this a case-insensitive
    search.  We look for an exact match in the name and do not look for shortname
    equivalents.

Arguments:

    Fcb - Fcb for the directory being scanned.

    Name - Name to search for.

    IgnoreCase - Indicates the case of the search.

    FileContext - File context to use for the search.  This has already been
        initialized.

Return Value:

    BOOLEAN - TRUE if matching entry is found, FALSE otherwise.

--*/

{
    PDIRENT Dirent;

    BOOLEAN Found = FALSE;

    PAGED_CODE();

    //
    //  Make sure there is a stream file for this Fcb.
    //

    if (Fcb->FileObject == NULL) {

        CdCreateInternalStream( IrpContext, Fcb->Vcb, Fcb );
    }

    //
    //  Position ourselves at the first entry.
    //

    CdLookupInitialFileDirent( IrpContext, Fcb, FileContext, Fcb->StreamOffset );

    //
    //  Loop while there are more entries in this directory.
    //

    do {

        Dirent = &FileContext->InitialDirent->Dirent;

        //
        //  We only look for directories.  Directories cannot have the
        //  associated bit set.
        //

        if (FlagOn( Dirent->DirentFlags, CD_ATTRIBUTE_DIRECTORY )) {

            //
            //  Update the name in the current dirent.
            //

            CdUpdateDirentName( IrpContext, Dirent, IgnoreCase );

            //
            //  Don't bother with constant entries.
            //

            if (FlagOn( Dirent->Flags, DIRENT_FLAG_CONSTANT_ENTRY )) {

                continue;
            }

            //
            //  Now check whether we have a name match.
            //  We exit the loop if we have a match.
            //

            if (CdIsNameInExpression( IrpContext,
                                      &Dirent->CdCaseFileName,
                                      Name,
                                      0,
                                      TRUE )) {

                Found = TRUE;
                break;
            }
        }

        //
        //  Go to the next initial dirent.
        //

    } while (CdLookupNextInitialFileDirent( IrpContext, Fcb, FileContext ));

    return Found;
}


BOOLEAN
CdFindFileByShortName (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN ULONG ShortNameDirentOffset,
    IN OUT PFILE_ENUM_CONTEXT FileContext
    )

/*++

Routine Description:

    This routine is called to find the file name entry whose short name
    is defined by the input DirentOffset.  The dirent offset here is
    multiplied by 32 and we look for the dirent begins in this 32 byte offset in
    directory.  The minimum dirent length is 34 so we are guaranteed that only
    one dirent can begin in each 32 byte block in the directory.

Arguments:

    Fcb - Fcb for the directory being scanned.

    Name - Name we are trying to match.  We know this contains the tilde
        character followed by decimal characters.

    IgnoreCase - Indicates whether we need to upcase the long name and
        generated short name.

    ShortNameDirentOffset - This is the shifted value for the offset of the
        name in the directory.

    FileContext - This is the initialized file context to use for the search.

Return Value:

    BOOLEAN - TRUE if a matching name was found, FALSE otherwise.

--*/

{
    BOOLEAN Found = FALSE;
    PDIRENT Dirent;

    ULONG ThisShortNameDirentOffset;

    PAGED_CODE();

    //
    //  Make sure there is a stream file for this Fcb.
    //

    if (Fcb->FileObject == NULL) {

        CdCreateInternalStream( IrpContext, Fcb->Vcb, Fcb );
    }

    //
    //  Position ourselves at the start of the directory and update
    //
    //

    CdLookupInitialFileDirent( IrpContext, Fcb, FileContext, Fcb->StreamOffset );

    //
    //  Loop until we have found the entry or are beyond this dirent.
    //

    do {

        //
        //  Compute the short name dirent offset for the current dirent.
        //

        Dirent = &FileContext->InitialDirent->Dirent;
        ThisShortNameDirentOffset = Dirent->DirentOffset >> SHORT_NAME_SHIFT;

        //
        //  If beyond the target then exit.
        //

        if (ThisShortNameDirentOffset > ShortNameDirentOffset) {

            break;
        }

        //
        //  If equal to the target then check if we have a name match.
        //  We will either match or fail here.
        //

        if (ThisShortNameDirentOffset == ShortNameDirentOffset) {

            //
            //  If this is an associated file then get out.
            //

            if (FlagOn( Dirent->DirentFlags, CD_ATTRIBUTE_ASSOC )) {

                break;
            }

            //
            //  Update the name in the dirent and check if it is not
            //  an 8.3 name.
            //

            CdUpdateDirentName( IrpContext, Dirent, IgnoreCase );

            if (CdIs8dot3Name( IrpContext,
                               Dirent->CdFileName.FileName )) {

                break;
            }

            //
            //  Generate the 8.3 name see if it matches our input name.
            //

            CdGenerate8dot3Name( IrpContext,
                                 &Dirent->CdCaseFileName.FileName,
                                 Dirent->DirentOffset,
                                 FileContext->ShortName.FileName.Buffer,
                                 &FileContext->ShortName.FileName.Length );

            //
            //  Check if this name matches.
            //

            if (CdIsNameInExpression( IrpContext,
                                      Name,
                                      &FileContext->ShortName,
                                      0,
                                      FALSE )) {

                //
                //  Let our caller know we found an entry.
                //

                Found = TRUE;
            }

            //
            //  Break out of the loop.
            //

            break;
        }

        //
        //  Continue until there are no more entries.
        //

    } while (CdLookupNextInitialFileDirent( IrpContext, Fcb, FileContext ));

    //
    //  If we find the file then collect all of the dirents.
    //

    if (Found) {

        CdLookupLastFileDirent( IrpContext, Fcb, FileContext );

    }

    return Found;
}


BOOLEAN
CdLookupNextInitialFileDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_ENUM_CONTEXT FileContext
    )

/*++

Routine Description:

    This routine is called to walk through the directory until we find the
    first possible dirent for file.  We are positioned at some point described
    by the FileContext.  We will walk through any remaing dirents for the
    current file until we find the first dirent for some subsequent file.

    We can be called when we have found just one dirent for a file or all
    of them.  We first check the CurrentDirContext.  In the typical
    single-extent case this is unused.  Then we look to the InitialDirContext
    which must be initialized.

    This routine will save the initial DirContext to the PriorDirContext and
    clean up any existing DirContext for the Prior or Current positions in
    the enumeration context.

Arguments:

    Fcb - This is the directory to scan.

    FileContext - This is the file enumeration context.  It is currently pointing
        at some file in the directory.

Return Value:

--*/

{
    PRAW_DIRENT RawDirent;

    PDIRENT_ENUM_CONTEXT CurrentDirContext;
    PDIRENT_ENUM_CONTEXT TargetDirContext;
    PCOMPOUND_DIRENT TempDirent;

    BOOLEAN FoundDirent = FALSE;
    BOOLEAN FoundLastDirent;

    PAGED_CODE();

    //
    //  Start by saving the initial dirent of the current file as the
    //  previous file.
    //

    TempDirent = FileContext->PriorDirent;
    FileContext->PriorDirent = FileContext->InitialDirent;
    FileContext->InitialDirent = TempDirent;

    //
    //  We will use the initial dirent of the prior file unless the
    //  previous search returned multiple extents.
    //

    CurrentDirContext = &FileContext->PriorDirent->DirContext;

    if (FlagOn( FileContext->Flags, FILE_CONTEXT_MULTIPLE_DIRENTS )) {

        CurrentDirContext = &FileContext->CurrentDirent->DirContext;
    }

    //
    //  Clear all of the flags and file size for the next file.
    //

    FileContext->Flags = 0;
    FileContext->FileSize = 0;

    FileContext->ShortName.FileName.Length = 0;

    //
    //  We always want to store the result into the updated initial dirent
    //  context.
    //

    TargetDirContext = &FileContext->InitialDirent->DirContext;

    //
    //  Loop until we find the first dirent after the last dirent of the
    //  current file.  We may not be at the last dirent for the current file yet
    //  so we may walk forward looking for the last and then find the
    //  initial dirent for the next file after that.
    //

    while (TRUE) {

        //
        //  Remember if the last dirent we visited was the last dirent for
        //  a file.
        //

        RawDirent = CdRawDirent( IrpContext, CurrentDirContext );

        FoundLastDirent = !FlagOn( CdRawDirentFlags( IrpContext, RawDirent ), CD_ATTRIBUTE_MULTI );

        //
        //  Try to find another dirent.
        //

        FoundDirent = CdLookupNextDirent( IrpContext,
                                          Fcb,
                                          CurrentDirContext,
                                          TargetDirContext );

        //
        //  Exit the loop if no entry found.
        //

        if (!FoundDirent) {

            break;

        }

        //
        //  Update the in-memory dirent.
        //

        CdUpdateDirentFromRawDirent( IrpContext,
                                     Fcb,
                                     TargetDirContext,
                                     &FileContext->InitialDirent->Dirent );

        //
        //  Exit the loop if we had the end for the previous file.
        //

        if (FoundLastDirent) {

            break;
        }

        //
        //  Always use a single dirent from this point on.
        //

        CurrentDirContext = TargetDirContext;
    }

    return FoundDirent;
}


VOID
CdLookupLastFileDirent (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFILE_ENUM_CONTEXT FileContext
    )

/*++

Routine Description:

    This routine is called when we've found the matching initial dirent for
    a file.  Now we want to find all of the dirents for a file as well as
    compute the running total for the file size.

    We also go out to the system use area and check whether this is an
    XA sector.  In that case we will compute the real file size.

    The dirent in the initial compound dirent has been updated from the
    raw dirent when this routine is called.

Arguments:

    Fcb - Directory containing the entries for the file.

    FileContext - Enumeration context for this search.  It currently points
        to the first dirent of the file and the in-memory dirent has been
        updated.

Return Value:

    None.  This routine may raise STATUS_FILE_CORRUPT.

--*/

{
    XA_EXTENT_TYPE ExtentType;
    PCOMPOUND_DIRENT CurrentCompoundDirent;
    PDIRENT CurrentDirent;

    BOOLEAN FirstPass = TRUE;
    BOOLEAN FoundDirent;

    PAGED_CODE();

    //
    //  The current dirent to look at is the initial dirent for the file.
    //

    CurrentCompoundDirent = FileContext->InitialDirent;

    //
    //  Loop until we reach the last dirent for the file.
    //

    while (TRUE) {

        CurrentDirent = &CurrentCompoundDirent->Dirent;

        //
        //  Check if this extent has XA sectors.
        //

        if ((CurrentDirent->SystemUseOffset != 0) &&
            FlagOn( Fcb->Vcb->VcbState, VCB_STATE_CDXA ) &&
            CdCheckForXAExtent( IrpContext,
                                CdRawDirent( IrpContext, &CurrentCompoundDirent->DirContext ),
                                CurrentDirent )) {

            //
            //  Any previous dirent must describe XA sectors as well.
            //

            if (!FirstPass && (ExtentType != CurrentDirent->ExtentType)) {

                CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            //
            //  If there are XA sectors then the data on the disk must
            //  be correctly aligned on sectors and be an integral number of
            //  sectors.  Only an issue if the logical block size is not
            //  2048.
            //

            if (Fcb->Vcb->BlockSize != SECTOR_SIZE) {

                //
                //  We will do the following checks.
                //
                //      Data must start on a sector boundary.
                //      Data length must be integral number of sectors.
                //

                if ((SectorBlockOffset( Fcb->Vcb, CurrentDirent->StartingOffset ) != 0) ||
                    (SectorBlockOffset( Fcb->Vcb, CurrentDirent->DataLength ) != 0)) {

                    CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                }

                //
                //  If interleaved then both the file unit and interleave
                //  gap must be integral number of sectors.
                //

                if ((CurrentDirent->FileUnitSize != 0) &&
                    ((SectorBlockOffset( Fcb->Vcb, CurrentDirent->FileUnitSize ) != 0) ||
                     (SectorBlockOffset( Fcb->Vcb, CurrentDirent->InterleaveGapSize ) != 0))) {

                    CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                }
            }

            //
            //  If this is the first dirent then add the bytes for the RIFF
            //  header.
            //

            if (FirstPass) {

                FileContext->FileSize = sizeof( RIFF_HEADER );
            }

            //
            //  Add the size of the mode2-form2 sector for each sector
            //  we have here.
            //

            FileContext->FileSize += Int32x32To64( CurrentDirent->DataLength >> SECTOR_SHIFT,
                                                   XA_SECTOR_SIZE);

        } else {

            //
            //  This extent does not have XA sectors.  Any previous dirent
            //  better not have XA sectors.
            //

            if (!FirstPass && (ExtentType != CurrentDirent->ExtentType)) {

                CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            //
            //  Add these bytes to the file size.
            //

            FileContext->FileSize += CurrentDirent->DataLength;
        }

        //
        //  If we are at the last dirent then exit.
        //

        if (!FlagOn( CurrentDirent->DirentFlags, CD_ATTRIBUTE_MULTI )) {

            break;
        }

        //
        //  Remember the extent type of the current extent.
        //

        ExtentType = CurrentDirent->ExtentType;

        //
        //  Look for the next dirent of the file.
        //

        FoundDirent = CdLookupNextDirent( IrpContext,
                                          Fcb,
                                          &CurrentCompoundDirent->DirContext,
                                          &FileContext->CurrentDirent->DirContext );

        //
        //  If we didn't find the entry then this is a corrupt directory.
        //

        if (!FoundDirent) {

            CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        //
        //  Remember the dirent we just found.
        //

        CurrentCompoundDirent = FileContext->CurrentDirent;
        FirstPass = FALSE;

        //
        //  Look up all of the dirent information for the given dirent.
        //

        CdUpdateDirentFromRawDirent( IrpContext,
                                     Fcb,
                                     &CurrentCompoundDirent->DirContext,
                                     &CurrentCompoundDirent->Dirent );

        //
        //  Set flag to show there were multiple extents.
        //

        SetFlag( FileContext->Flags, FILE_CONTEXT_MULTIPLE_DIRENTS );
    }

    return;
}


VOID
CdCleanupFileContext (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_ENUM_CONTEXT FileContext
    )

/*++

Routine Description:

    This routine is called to cleanup the enumeration context for a file
    search in a directory.  We will unpin any remaining Bcbs and free
    any allocated buffers.

Arguments:

    FileContext - Enumeration context for the file search.

Return Value:

    None.

--*/

{
    PCOMPOUND_DIRENT CurrentCompoundDirent;
    ULONG Count = 2;

    PAGED_CODE();

    //
    //  Cleanup the individual compound dirents.
    //

    do {

        CurrentCompoundDirent = &FileContext->Dirents[ Count ];
        CdCleanupDirContext( IrpContext, &CurrentCompoundDirent->DirContext );
        CdCleanupDirent( IrpContext, &CurrentCompoundDirent->Dirent );

    } while (Count--);

    return;
}


//
//  Local support routine
//

ULONG
CdCheckRawDirentBounds (
    IN PIRP_CONTEXT IrpContext,
    IN PDIRENT_ENUM_CONTEXT DirContext
    )

/*++

Routine Description:

    This routine takes a Dirent enumeration context and computes the offset
    to the next dirent.  A non-zero value indicates the offset within this
    sector.  A zero value indicates to move to the next sector.  If the
    current dirent does not fit within the sector then we will raise
    STATUS_CORRUPT.

Arguments:

    DirContext - Enumeration context indicating the current position in
        the sector.

Return Value:

    ULONG - Offset to the next dirent in this sector or zero if the
        next dirent is in the next sector.

    This routine will raise on a dirent which does not fit into the
    described data buffer.

--*/

{
    ULONG NextDirentOffset;
    PRAW_DIRENT RawDirent;

    PAGED_CODE();

    //
    //  We should always have at least a byte still available in the
    //  current buffer.
    //

    ASSERT( (DirContext->DataLength - DirContext->SectorOffset) >= 1 );

    //
    //  Get a pointer to the current dirent.
    //

    RawDirent = CdRawDirent( IrpContext, DirContext );

    //
    //  If the dirent length is non-zero then look at the current dirent.
    //

    if (RawDirent->DirLen != 0) {

        //
        //  Check the following bound for the dirent length.
        //
        //      - Fits in the available bytes in the sector.
        //      - Is at least the minimal dirent size.
        //      - Is large enough to hold the file name.
        //

        if ((RawDirent->DirLen > (DirContext->DataLength - DirContext->SectorOffset)) ||
            (RawDirent->DirLen < MIN_RAW_DIRENT_LEN) ||
            (RawDirent->DirLen < (MIN_RAW_DIRENT_LEN - 1 + RawDirent->FileIdLen))) {

            CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
        }

        //
        //  Copy the dirent length field.
        //

        NextDirentOffset = RawDirent->DirLen;

        //
        //  If we are exactly at the next sector then tell our caller by
        //  returning zero.
        //

        if (NextDirentOffset == (DirContext->DataLength - DirContext->SectorOffset)) {

            NextDirentOffset = 0;
        }

    } else {

        NextDirentOffset = 0;
    }

    return NextDirentOffset;
}


//
//  Local support routine
//

XA_EXTENT_TYPE
CdCheckForXAExtent (
    IN PIRP_CONTEXT IrpContext,
    IN PRAW_DIRENT RawDirent,
    IN OUT PDIRENT Dirent
    )

/*++

Routine Description:

    This routine is called to scan through the system use area to test if
    the current dirent has the XA bit set.  The bit in the in-memory
    dirent will be set as appropriate.

Arguments:

    RawDirent - Pointer to the on-disk dirent.

    Dirent - Pointer to the in-memory dirent.  We will update this with the
        appropriate XA flag.

Return Value:

    XA_EXTENT_TYPE - Type of physical extent for this on disk dirent.

--*/

{
    XA_EXTENT_TYPE ExtentType = Form1Data;
    PSYSTEM_USE_XA SystemUseArea;

    PAGED_CODE();

    //
    //  Check if there is enough space for the XA system use area.
    //

    if (Dirent->DirentLength - Dirent->SystemUseOffset >= sizeof( SYSTEM_USE_XA )) {

        SystemUseArea = Add2Ptr( RawDirent, Dirent->SystemUseOffset, PSYSTEM_USE_XA );

        //
        //  Check for a valid signature.
        //

        if (SystemUseArea->Signature == SYSTEM_XA_SIGNATURE) {

            //
            //  Check for an audio track.
            //

            if (FlagOn( SystemUseArea->Attributes, SYSTEM_USE_XA_DA )) {

                ExtentType = CDAudio;

            } else if (FlagOn( SystemUseArea->Attributes, SYSTEM_USE_XA_FORM2 )) {

                //
                //  Check for XA data.  Note that a number of discs (video CDs)
                //  have files marked as type XA Mode 2 Form 1 (2048 bytes of 
                //  user data),  but actually record these sectors as Mode2 Form 2 
                //  (2352). We will fail to read these files,  since for M2F1,  
                //  a normal read CD command is issued (as per SCSI specs).
                //
                
                ExtentType = Mode2Form2Data;
            }

            Dirent->XAAttributes = SystemUseArea->Attributes;
            Dirent->XAFileNumber = SystemUseArea->FileNumber;
        }
    }

    Dirent->ExtentType = ExtentType;
    return ExtentType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\fieldoff.c ===
#include "CdProcs.h"
#include <stdio.h>

#define doit(a,b) { printf("%s %04lx %4lx %s\n", #a, FIELD_OFFSET(a,b), sizeof(d.b), #b); }

VOID
__cdecl
main (argc, argv)
    int argc;
    char *argv[];
{
    printf("<Record>  <offset>  <size>  <field>\n\n");
    {
        CD_MCB d;
        doit( CD_MCB, MaximumEntryCount );
        doit( CD_MCB, CurrentEntryCount );
        doit( CD_MCB, McbArray );
    }
    printf("\n");
    {
        CD_MCB_ENTRY d;
        doit( CD_MCB_ENTRY, DiskOffset );
        doit( CD_MCB_ENTRY, ByteCount );
        doit( CD_MCB_ENTRY, FileOffset );
        doit( CD_MCB_ENTRY, DataBlockByteCount );
        doit( CD_MCB_ENTRY, TotalBlockByteCount );
    }
    printf("\n");
    {
        CD_NAME d;
        doit( CD_NAME, FileName );
        doit( CD_NAME, VersionString );
    }
    printf("\n");
    {
        NAME_LINK d;
        doit( NAME_LINK, Links );
        doit( NAME_LINK, FileName );
    }
    printf("\n");
    {
        PREFIX_ENTRY d;
        doit( PREFIX_ENTRY, Fcb );
        doit( PREFIX_ENTRY, PrefixFlags );
        doit( PREFIX_ENTRY, ExactCaseName );
        doit( PREFIX_ENTRY, IgnoreCaseName );
        doit( PREFIX_ENTRY, FileNameBuffer );
    }
    printf("\n");
    {
        CD_DATA d;
        doit( CD_DATA, NodeTypeCode );
        doit( CD_DATA, NodeByteSize );
        doit( CD_DATA, DriverObject );
        doit( CD_DATA, VcbQueue );
        doit( CD_DATA, IrpContextDepth );
        doit( CD_DATA, IrpContextMaxDepth );
        doit( CD_DATA, IrpContextList );
        doit( CD_DATA, FileSystemDeviceObject );
        doit( CD_DATA, AsyncCloseQueue );
        doit( CD_DATA, AsyncCloseCount );
        doit( CD_DATA, FspCloseActive );
        doit( CD_DATA, ReduceDelayedClose );
        doit( CD_DATA, PadUshort );
        doit( CD_DATA, DelayedCloseQueue );
        doit( CD_DATA, DelayedCloseCount );
        doit( CD_DATA, MinDelayedCloseCount );
        doit( CD_DATA, MaxDelayedCloseCount );
        doit( CD_DATA, CdDataLockThread );
        doit( CD_DATA, CdDataMutex );
        doit( CD_DATA, DataResource );
        doit( CD_DATA, CacheManagerCallbacks );
        doit( CD_DATA, CacheManagerVolumeCallbacks );
        doit( CD_DATA, CloseItem );
    }
    printf("\n");
    {
        VCB d;
        doit( VCB, NodeTypeCode );
        doit( VCB, NodeByteSize );
        doit( VCB, Vpb );
        doit( VCB, TargetDeviceObject );
        doit( VCB, VolumeLockFileObject );
        doit( VCB, VcbLinks );
        doit( VCB, VcbState );
        doit( VCB, VcbCondition );
        doit( VCB, VcbCleanup );
        doit( VCB, VcbReference );
        doit( VCB, VcbUserReference );
        doit( VCB, VolumeDasdFcb );
        doit( VCB, RootIndexFcb );
        doit( VCB, PathTableFcb );
        doit( VCB, BaseSector );
        doit( VCB, VdSectorOffset );
        doit( VCB, PrimaryVdSectorOffset );
        doit( VCB, XASector );
        doit( VCB, XADiskOffset );
        doit( VCB, VcbResource );
        doit( VCB, FileResource );
        doit( VCB, VcbMutex );
        doit( VCB, VcbLockThread );
        doit( VCB, NotifySync );
        doit( VCB, DirNotifyList );
        doit( VCB, BlockSize );
        doit( VCB, BlockToSectorShift );
        doit( VCB, BlockToByteShift );
        doit( VCB, BlocksPerSector );
        doit( VCB, BlockMask );
        doit( VCB, BlockInverseMask );
        doit( VCB, FcbTable );
        doit( VCB, CdromToc );
        doit( VCB, TocLength );
        doit( VCB, TrackCount );
        doit( VCB, DiskFlags );
        doit( VCB, BlockFactor );
    }
    printf("\n");
    {
        VOLUME_DEVICE_OBJECT d;
        doit( VOLUME_DEVICE_OBJECT, DeviceObject );
        doit( VOLUME_DEVICE_OBJECT, PostedRequestCount );
        doit( VOLUME_DEVICE_OBJECT, OverflowQueueCount );
        doit( VOLUME_DEVICE_OBJECT, OverflowQueue );
        doit( VOLUME_DEVICE_OBJECT, OverflowQueueSpinLock );
        doit( VOLUME_DEVICE_OBJECT, Vcb );
    }
    printf("\n");
    {
        FCB_DATA d;
        doit( FCB_DATA, Oplock );
        doit( FCB_DATA, FileLock );
    }
    printf("\n");
    {
        FCB_INDEX d;
        doit( FCB_INDEX, FileObject );
        doit( FCB_INDEX, StreamOffset );
        doit( FCB_INDEX, FcbQueue );
        doit( FCB_INDEX, Ordinal );
        doit( FCB_INDEX, ChildPathTableOffset );
        doit( FCB_INDEX, ChildOrdinal );
        doit( FCB_INDEX, ExactCaseRoot );
        doit( FCB_INDEX, IgnoreCaseRoot );
    }
    printf("\n");
    {
        FCB_NONPAGED d;
        doit( FCB_NONPAGED, NodeTypeCode );
        doit( FCB_NONPAGED, NodeByteSize );
        doit( FCB_NONPAGED, SegmentObject );
        doit( FCB_NONPAGED, FcbResource );
        doit( FCB_NONPAGED, FcbMutex );
    }
    printf("\n");
    {
        FCB d;
        doit( FCB, Header );
        doit( FCB, Vcb );
        doit( FCB, ParentFcb );
        doit( FCB, FcbLinks );
        doit( FCB, FileId );
        doit( FCB, FcbCleanup );
        doit( FCB, FcbReference );
        doit( FCB, FcbUserReference );
        doit( FCB, FcbState );
        doit( FCB, FileAttributes );
        doit( FCB, XAAttributes );
        doit( FCB, XAFileNumber );
        doit( FCB, FcbLockThread );
        doit( FCB, FcbLockCount );
        doit( FCB, FcbNonpaged );
        doit( FCB, ShareAccess );
        doit( FCB, McbEntry );
        doit( FCB, Mcb );
        doit( FCB, ShortNamePrefix );
        doit( FCB, FileNamePrefix );
        doit( FCB, CreationTime );
        doit( FCB, FcbType );
    }
    printf("\n");
    {
        CCB d;
        doit( CCB, NodeTypeCode );
        doit( CCB, NodeByteSize );
        doit( CCB, Flags );
        doit( CCB, Fcb );
        doit( CCB, CurrentDirentOffset );
        doit( CCB, SearchExpression );
    }
    printf("\n");
    {
        IRP_CONTEXT d;
        doit( IRP_CONTEXT, NodeTypeCode );
        doit( IRP_CONTEXT, NodeByteSize );
        doit( IRP_CONTEXT, Irp );
        doit( IRP_CONTEXT, Vcb );
        doit( IRP_CONTEXT, ExceptionStatus );
        doit( IRP_CONTEXT, Flags );
        doit( IRP_CONTEXT, RealDevice );
        doit( IRP_CONTEXT, IoContext );
        doit( IRP_CONTEXT, TeardownFcb );
        doit( IRP_CONTEXT, TopLevel );
        doit( IRP_CONTEXT, MajorFunction );
        doit( IRP_CONTEXT, MinorFunction );
        doit( IRP_CONTEXT, ThreadContext );
        doit( IRP_CONTEXT, WorkQueueItem );
    }
    printf("\n");
    {
        IRP_CONTEXT_LITE d;
        doit( IRP_CONTEXT_LITE, NodeTypeCode );
        doit( IRP_CONTEXT_LITE, NodeByteSize );
        doit( IRP_CONTEXT_LITE, Fcb );
        doit( IRP_CONTEXT_LITE, DelayedCloseLinks );
        doit( IRP_CONTEXT_LITE, UserReference );
        doit( IRP_CONTEXT_LITE, RealDevice );
    }
    printf("\n");
    {
        CD_IO_CONTEXT d;
        doit( CD_IO_CONTEXT, IrpCount );
        doit( CD_IO_CONTEXT, MasterIrp );
        doit( CD_IO_CONTEXT, Status );
        doit( CD_IO_CONTEXT, AllocatedContext );
        doit( CD_IO_CONTEXT, Resource );
        doit( CD_IO_CONTEXT, ResourceThreadId );
        doit( CD_IO_CONTEXT, SyncEvent );
    }
    printf("\n");
    {
        THREAD_CONTEXT d;
        doit( THREAD_CONTEXT, Cdfs );
        doit( THREAD_CONTEXT, SavedTopLevelIrp );
        doit( THREAD_CONTEXT, TopLevelIrpContext );
    }
    printf("\n");
    {
        PATH_ENUM_CONTEXT d;
        doit( PATH_ENUM_CONTEXT, Data );
        doit( PATH_ENUM_CONTEXT, BaseOffset );
        doit( PATH_ENUM_CONTEXT, DataLength );
        doit( PATH_ENUM_CONTEXT, Bcb );
        doit( PATH_ENUM_CONTEXT, DataOffset );
        doit( PATH_ENUM_CONTEXT, AllocatedData );
        doit( PATH_ENUM_CONTEXT, LastDataBlock );
    }
    printf("\n");
    {
        PATH_ENTRY d;
        doit( PATH_ENTRY, Ordinal );
        doit( PATH_ENTRY, PathTableOffset );
        doit( PATH_ENTRY, DiskOffset );
        doit( PATH_ENTRY, PathEntryLength );
        doit( PATH_ENTRY, ParentOrdinal );
        doit( PATH_ENTRY, DirNameLen );
        doit( PATH_ENTRY, DirName );
        doit( PATH_ENTRY, Flags );
        doit( PATH_ENTRY, CdDirName );
        doit( PATH_ENTRY, CdCaseDirName );
        doit( PATH_ENTRY, NameBuffer );
    }
    printf("\n");
    {
        COMPOUND_PATH_ENTRY d;
        doit( COMPOUND_PATH_ENTRY, PathContext );
        doit( COMPOUND_PATH_ENTRY, PathEntry );
    }
    printf("\n");
    {
        DIRENT_ENUM_CONTEXT d;
        doit( DIRENT_ENUM_CONTEXT, Sector );
        doit( DIRENT_ENUM_CONTEXT, BaseOffset );
        doit( DIRENT_ENUM_CONTEXT, DataLength );
        doit( DIRENT_ENUM_CONTEXT, Bcb );
        doit( DIRENT_ENUM_CONTEXT, SectorOffset );
        doit( DIRENT_ENUM_CONTEXT, NextDirentOffset );
    }
    printf("\n");
    {
        DIRENT d;
        doit( DIRENT, DirentOffset );
        doit( DIRENT, DirentLength );
        doit( DIRENT, StartingOffset );
        doit( DIRENT, DataLength );
        doit( DIRENT, CdTime );
        doit( DIRENT, DirentFlags );
        doit( DIRENT, Flags );
        doit( DIRENT, FileUnitSize );
        doit( DIRENT, InterleaveGapSize );
        doit( DIRENT, SystemUseOffset );
        doit( DIRENT, XAAttributes );
        doit( DIRENT, XAFileNumber );
        doit( DIRENT, FileNameLen );
        doit( DIRENT, FileName );
        doit( DIRENT, CdFileName );
        doit( DIRENT, CdCaseFileName );
        doit( DIRENT, ExtentType );
        doit( DIRENT, NameBuffer );
    }
    printf("\n");
    {
        COMPOUND_DIRENT d;
        doit( COMPOUND_DIRENT, DirContext );
        doit( COMPOUND_DIRENT, Dirent );
    }
    printf("\n");
    {
        FILE_ENUM_CONTEXT d;
        doit( FILE_ENUM_CONTEXT, PriorDirent );
        doit( FILE_ENUM_CONTEXT, InitialDirent );
        doit( FILE_ENUM_CONTEXT, CurrentDirent );
        doit( FILE_ENUM_CONTEXT, Flags );
        doit( FILE_ENUM_CONTEXT, FileSize );
        doit( FILE_ENUM_CONTEXT, ShortName );
        doit( FILE_ENUM_CONTEXT, ShortNameBuffer );
        doit( FILE_ENUM_CONTEXT, Dirents );
    }
    printf("\n");
    {
        RIFF_HEADER d;
        doit( RIFF_HEADER, ChunkId );
        doit( RIFF_HEADER, ChunkSize );
        doit( RIFF_HEADER, SignatureCDXA );
        doit( RIFF_HEADER, SignatureFMT );
        doit( RIFF_HEADER, XAChunkSize );
        doit( RIFF_HEADER, OwnerId );
        doit( RIFF_HEADER, Attributes );
        doit( RIFF_HEADER, SignatureXA );
        doit( RIFF_HEADER, FileNumber );
        doit( RIFF_HEADER, Reserved );
        doit( RIFF_HEADER, SignatureData );
        doit( RIFF_HEADER, RawSectors );
    }
    printf("\n");
    {
        AUDIO_PLAY_HEADER d;
        doit( AUDIO_PLAY_HEADER, Chunk );
        doit( AUDIO_PLAY_HEADER, ChunkSize );
        doit( AUDIO_PLAY_HEADER, SignatureCDDA );
        doit( AUDIO_PLAY_HEADER, SignatureFMT );
        doit( AUDIO_PLAY_HEADER, FMTChunkSize );
        doit( AUDIO_PLAY_HEADER, FormatTag );
        doit( AUDIO_PLAY_HEADER, TrackNumber );
        doit( AUDIO_PLAY_HEADER, DiskID );
        doit( AUDIO_PLAY_HEADER, StartingSector );
        doit( AUDIO_PLAY_HEADER, SectorCount );
        doit( AUDIO_PLAY_HEADER, TrackAddress );
        doit( AUDIO_PLAY_HEADER, TrackLength );
    }
    printf("\n");
    {
        RAW_ISO_VD d;
        doit( RAW_ISO_VD, DescType );
        doit( RAW_ISO_VD, StandardId );
        doit( RAW_ISO_VD, Version );
        doit( RAW_ISO_VD, VolumeFlags );
        doit( RAW_ISO_VD, SystemId );
        doit( RAW_ISO_VD, VolumeId );
        doit( RAW_ISO_VD, Reserved );
        doit( RAW_ISO_VD, VolSpaceI );
        doit( RAW_ISO_VD, VolSpaceM );
        doit( RAW_ISO_VD, CharSet );
        doit( RAW_ISO_VD, VolSetSizeI );
        doit( RAW_ISO_VD, VolSetSizeM );
        doit( RAW_ISO_VD, VolSeqNumI );
        doit( RAW_ISO_VD, VolSeqNumM );
        doit( RAW_ISO_VD, LogicalBlkSzI );
        doit( RAW_ISO_VD, LogicalBlkSzM );
        doit( RAW_ISO_VD, PathTableSzI );
        doit( RAW_ISO_VD, PathTableSzM );
        doit( RAW_ISO_VD, PathTabLocI );
        doit( RAW_ISO_VD, PathTabLocM );
        doit( RAW_ISO_VD, RootDe );
        doit( RAW_ISO_VD, VolSetId );
        doit( RAW_ISO_VD, PublId );
        doit( RAW_ISO_VD, PreparerId );
        doit( RAW_ISO_VD, AppId );
        doit( RAW_ISO_VD, Copyright );
        doit( RAW_ISO_VD, Abstract );
        doit( RAW_ISO_VD, Bibliograph );
        doit( RAW_ISO_VD, CreateDate );
        doit( RAW_ISO_VD, ModDate );
        doit( RAW_ISO_VD, ExpireDate );
        doit( RAW_ISO_VD, EffectDate );
        doit( RAW_ISO_VD, FileStructVer );
        doit( RAW_ISO_VD, Reserved3 );
        doit( RAW_ISO_VD, ResApp );
        doit( RAW_ISO_VD, Reserved4 );
    }
    printf("\n");
    {
        RAW_HSG_VD d;
        doit( RAW_HSG_VD, BlkNumI );
        doit( RAW_HSG_VD, BlkNumM );
        doit( RAW_HSG_VD, DescType );
        doit( RAW_HSG_VD, StandardId );
        doit( RAW_HSG_VD, Version );
        doit( RAW_HSG_VD, VolumeFlags );
        doit( RAW_HSG_VD, SystemId );
        doit( RAW_HSG_VD, VolumeId );
        doit( RAW_HSG_VD, Reserved );
        doit( RAW_HSG_VD, VolSpaceI );
        doit( RAW_HSG_VD, VolSpaceM );
        doit( RAW_HSG_VD, CharSet );
        doit( RAW_HSG_VD, VolSetSizeI );
        doit( RAW_HSG_VD, VolSetSizeM );
        doit( RAW_HSG_VD, VolSeqNumI );
        doit( RAW_HSG_VD, VolSeqNumM );
        doit( RAW_HSG_VD, LogicalBlkSzI );
        doit( RAW_HSG_VD, LogicalBlkSzM );
        doit( RAW_HSG_VD, PathTableSzI );
        doit( RAW_HSG_VD, PathTableSzM );
        doit( RAW_HSG_VD, PathTabLocI );
        doit( RAW_HSG_VD, PathTabLocM );
        doit( RAW_HSG_VD, RootDe );
        doit( RAW_HSG_VD, VolSetId );
        doit( RAW_HSG_VD, PublId );
        doit( RAW_HSG_VD, PreparerId );
        doit( RAW_HSG_VD, AppId );
        doit( RAW_HSG_VD, Copyright );
        doit( RAW_HSG_VD, Abstract );
        doit( RAW_HSG_VD, CreateDate );
        doit( RAW_HSG_VD, ModDate );
        doit( RAW_HSG_VD, ExpireDate );
        doit( RAW_HSG_VD, EffectDate );
        doit( RAW_HSG_VD, FileStructVer );
        doit( RAW_HSG_VD, Reserved3 );
        doit( RAW_HSG_VD, ResApp );
        doit( RAW_HSG_VD, Reserved4 );
    }
    printf("\n");
    {
        RAW_DIRENT d;
        doit( RAW_DIRENT, DirLen );
        doit( RAW_DIRENT, XarLen );
        doit( RAW_DIRENT, FileLoc );
        doit( RAW_DIRENT, FileLocMot );
        doit( RAW_DIRENT, DataLen );
        doit( RAW_DIRENT, DataLenMot );
        doit( RAW_DIRENT, RecordTime );
        doit( RAW_DIRENT, FlagsHSG );
        doit( RAW_DIRENT, FlagsISO );
        doit( RAW_DIRENT, IntLeaveSize );
        doit( RAW_DIRENT, IntLeaveSkip );
        doit( RAW_DIRENT, Vssn );
        doit( RAW_DIRENT, VssnMot );
        doit( RAW_DIRENT, FileIdLen );
        doit( RAW_DIRENT, FileId );
    }
    printf("\n");
    {
        RAW_PATH_ISO d;
        doit( RAW_PATH_ISO, DirIdLen );
        doit( RAW_PATH_ISO, XarLen );
        doit( RAW_PATH_ISO, DirLoc );
        doit( RAW_PATH_ISO, ParentNum );
        doit( RAW_PATH_ISO, DirId );
    }
    printf("\n");
    {
        RAW_PATH_HSG d;
        doit( RAW_PATH_HSG, DirLoc );
        doit( RAW_PATH_HSG, XarLen );
        doit( RAW_PATH_HSG, DirIdLen );
        doit( RAW_PATH_HSG, ParentNum );
        doit( RAW_PATH_HSG, DirId );
    }
    printf("\n");
    {
        SYSTEM_USE_XA d;
        doit( SYSTEM_USE_XA, OwnerId );
        doit( SYSTEM_USE_XA, Attributes );
        doit( SYSTEM_USE_XA, Signature );
        doit( SYSTEM_USE_XA, FileNumber );
        doit( SYSTEM_USE_XA, Reserved );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\deviosup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    DevIoSup.c

Abstract:

    This module implements the low lever disk read/write support for Cdfs.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_DEVIOSUP)

//
//  Local structure definitions
//

//
//  An array of these structures is passed to CdMultipleAsync describing
//  a set of runs to execute in parallel.
//

typedef struct _IO_RUN {

    //
    //  Disk offset to read from and number of bytes to read.  These
    //  must be a multiple of 2048 and the disk offset is also a
    //  multiple of 2048.
    //

    LONGLONG DiskOffset;
    ULONG DiskByteCount;

    //
    //  Current position in user buffer.  This is the final destination for
    //  this portion of the Io transfer.
    //

    PVOID UserBuffer;

    //
    //  Buffer to perform the transfer to.  If this is the same as the
    //  user buffer above then we are using the user's buffer.  Otherwise
    //  we either allocated a temporary buffer or are using a different portion
    //  of the user's buffer.
    //
    //  TransferBuffer - Read full sectors into this location.  This can
    //      be a pointer into the user's buffer at the exact location the
    //      data should go.  It can also be an earlier point in the user's
    //      buffer if the complete I/O doesn't start on a sector boundary.
    //      It may also be a pointer into an allocated buffer.
    //
    //  TransferByteCount - Count of bytes to transfer to user's buffer.  A
    //      value of zero indicates that we did do the transfer into the
    //      user's buffer directly.
    //
    //  TransferBufferOffset - Offset in this buffer to begin the transfer
    //      to the user's buffer.
    //

    PVOID TransferBuffer;
    ULONG TransferByteCount;
    ULONG TransferBufferOffset;

    //
    //  This is the Mdl describing the locked pages in memory.  It may
    //  be allocated to describe the allocated buffer.  Or it may be
    //  the Mdl in the originating Irp.  The MdlOffset is the offset of
    //  the current buffer from the beginning of the buffer described by
    //  the Mdl below.  If the TransferMdl is not the same as the Mdl
    //  in the user's Irp then we know we have allocated it.
    //

    PMDL TransferMdl;
    PVOID TransferVirtualAddress;

    //
    //  Associated Irp used to perform the Io.
    //

    PIRP SavedIrp;

} IO_RUN;
typedef IO_RUN *PIO_RUN;

#define MAX_PARALLEL_IOS            5

//
//  Local support routines
//

BOOLEAN
CdPrepareBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PVOID UserBuffer,
    IN ULONG UserBufferOffset,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PIO_RUN IoRuns,
    IN PULONG RunCount,
    IN PULONG ThisByteCount
    );

VOID
CdPrepareXABuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PVOID UserBuffer,
    IN ULONG UserBufferOffset,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PIO_RUN IoRuns,
    IN PULONG RunCount,
    IN PULONG ThisByteCount
    );

BOOLEAN
CdFinishBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_RUN IoRuns,
    IN ULONG RunCount,
    IN BOOLEAN FinalCleanup,
    IN BOOLEAN SaveXABuffer
    );

VOID
CdMultipleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG RunCount,
    IN PIO_RUN IoRuns
    );

VOID
CdMultipleXAAsync (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG RunCount,
    IN PIO_RUN IoRuns,
    IN PRAW_READ_INFO RawReads,
    IN TRACK_MODE_TYPE TrackMode
    );

VOID
CdSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG ByteOffset,
    IN ULONG ByteCount
    );

VOID
CdWaitSync (
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
CdMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CdMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CdSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
CdSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
CdReadAudioSystemFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PVOID SystemBuffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCreateUserMdl)
#pragma alloc_text(PAGE, CdMultipleAsync)
#pragma alloc_text(PAGE, CdMultipleXAAsync)
#pragma alloc_text(PAGE, CdNonCachedRead)
#pragma alloc_text(PAGE, CdNonCachedXARead)
#pragma alloc_text(PAGE, CdFinishBuffers)
#pragma alloc_text(PAGE, CdPerformDevIoCtrl)
#pragma alloc_text(PAGE, CdPrepareBuffers)
#pragma alloc_text(PAGE, CdReadAudioSystemFile)
#pragma alloc_text(PAGE, CdReadSectors)
#pragma alloc_text(PAGE, CdSingleAsync)
#pragma alloc_text(PAGE, CdWaitSync)
#endif


__inline
TRACK_MODE_TYPE
CdFileTrackMode (
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine converts FCB XA file type flags to the track mode
    used by the device drivers.

Arguments:

    Fcb - Fcb representing the file to read.

Return Value:

    TrackMode of the file represented by the Fcb.

--*/
{
    ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_MODE2FORM2_FILE |
                                   FCB_STATE_MODE2_FILE |
                                   FCB_STATE_DA_FILE ));

    if (FlagOn( Fcb->FcbState, FCB_STATE_MODE2FORM2_FILE )) {

        return XAForm2;

    } else if (FlagOn( Fcb->FcbState, FCB_STATE_DA_FILE )) {

        return CDDA;

    }
    
    //
    //  FCB_STATE_MODE2_FILE
    //
        
    return YellowMode2;
}


NTSTATUS
CdNonCachedRead (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached reads to 'cooked' sectors (2048 bytes
    per sector).  This is done by performing the following in a loop.

        Fill in the IoRuns array for the next block of Io.
        Send the Io to the device.
        Perform any cleanup on the Io runs array.

    We will not do async Io to any request that generates non-aligned Io.
    Also we will not perform async Io if it will exceed the size of our
    IoRuns array.  These should be the unusual cases but we will raise
    or return CANT_WAIT in this routine if we detect this case.

Arguments:

    Fcb - Fcb representing the file to read.

    StartingOffset - Logical offset in the file to read from.

    ByteCount - Number of bytes to read.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    IO_RUN IoRuns[MAX_PARALLEL_IOS];
    ULONG RunCount = 0;
    ULONG CleanupRunCount = 0;

    PVOID UserBuffer;
    ULONG UserBufferOffset = 0;
    LONGLONG CurrentOffset = StartingOffset;
    ULONG RemainingByteCount = ByteCount;
    ULONG ThisByteCount;

    BOOLEAN Unaligned;
    BOOLEAN FlushIoBuffers = FALSE;
    BOOLEAN FirstPass = TRUE;

    PAGED_CODE();

    //
    //  We want to make sure the user's buffer is locked in all cases.
    //

    if (IrpContext->Irp->MdlAddress == NULL) {

        CdCreateUserMdl( IrpContext, ByteCount, TRUE );
    }

    CdMapUserBuffer( IrpContext, &UserBuffer);

    //
    //  Special case the root directory and path table for a music volume.
    //

    if (FlagOn( Fcb->Vcb->VcbState, VCB_STATE_AUDIO_DISK ) &&
        ((SafeNodeType( Fcb ) == CDFS_NTC_FCB_INDEX) ||
         (SafeNodeType( Fcb ) == CDFS_NTC_FCB_PATH_TABLE))) {

        CdReadAudioSystemFile( IrpContext,
                               Fcb,
                               StartingOffset,
                               ByteCount,
                               UserBuffer );

        return STATUS_SUCCESS;
    }

    //
    //  Use a try-finally to perform the final cleanup.
    //

    try {

        //
        //  Loop while there are more bytes to transfer.
        //

        do {

            //
            //  Call prepare buffers to set up the next entries
            //  in the IoRuns array.  Remember if there are any
            //  unaligned entries.  This routine will raise CANT_WAIT 
            //  if there are unaligned entries for an async request.
            //

            RtlZeroMemory( IoRuns, sizeof( IoRuns ));

            Unaligned = CdPrepareBuffers( IrpContext,
                                          IrpContext->Irp,
                                          Fcb,
                                          UserBuffer,
                                          UserBufferOffset,
                                          CurrentOffset,
                                          RemainingByteCount,
                                          IoRuns,
                                          &CleanupRunCount,
                                          &ThisByteCount );


            RunCount = CleanupRunCount;

            //
            //  If this is an async request and there aren't enough entries
            //  in the Io array then post the request.
            //

            if ((ThisByteCount < RemainingByteCount) &&
                !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            //
            //  If the entire Io is contained in a single run then
            //  we can pass the Io down to the driver.  Send the driver down
            //  and wait on the result if this is synchronous.
            //

            if ((RunCount == 1) && !Unaligned && FirstPass) {

                CdSingleAsync( IrpContext,
                               IoRuns[0].DiskOffset,
                               IoRuns[0].DiskByteCount );

                //
                //  No cleanup needed for the IoRuns array here.
                //

                CleanupRunCount = 0;

                //
                //  Wait if we are synchronous, otherwise return
                //

                if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                    CdWaitSync( IrpContext );

                    Status = IrpContext->Irp->IoStatus.Status;

                //
                //  Our completion routine will free the Io context but
                //  we do want to return STATUS_PENDING.
                //

                } else {

                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );
                    Status = STATUS_PENDING;
                }

                try_return( NOTHING );
            }

            //
            //  Otherwise we will perform multiple Io to read in the data.
            //

            CdMultipleAsync( IrpContext, RunCount, IoRuns );

            //
            //  If this is a synchronous request then perform any necessary
            //  post-processing.
            //

            if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                //
                //  Wait for the request to complete.
                //

                CdWaitSync( IrpContext );

                Status = IrpContext->Irp->IoStatus.Status;

                //
                //  Exit this loop if there is an error.
                //

                if (!NT_SUCCESS( Status )) {

                    try_return( NOTHING );
                }

                //
                //  Perform post read operations on the IoRuns if
                //  necessary.
                //

                if (Unaligned &&
                    CdFinishBuffers( IrpContext, IoRuns, RunCount, FALSE, FALSE )) {

                    FlushIoBuffers = TRUE;
                }
                
                CleanupRunCount = 0;

                //
                //  Exit this loop if there are no more bytes to transfer
                //  or we have any error.
                //

                RemainingByteCount -= ThisByteCount;
                CurrentOffset += ThisByteCount;
                UserBuffer = Add2Ptr( UserBuffer, ThisByteCount, PVOID );
                UserBufferOffset += ThisByteCount;

            //
            //  Otherwise this is an asynchronous request.  Always return
            //  STATUS_PENDING.
            //

            } else {

                ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );
                CleanupRunCount = 0;
                try_return( Status = STATUS_PENDING );
                break;
            }

            FirstPass = FALSE;
        } while (RemainingByteCount != 0);

        //
        //  Flush the hardware cache if we performed any copy operations.
        //

        if (FlushIoBuffers) {

            KeFlushIoBuffers( IrpContext->Irp->MdlAddress, TRUE, FALSE );
        }

    try_exit:  NOTHING;
    } finally {

        //
        //  Perform final cleanup on the IoRuns if necessary.
        //

        if (CleanupRunCount != 0) {

            CdFinishBuffers( IrpContext, IoRuns, CleanupRunCount, TRUE, FALSE );
        }
    }

    return Status;
}


NTSTATUS
CdNonCachedXARead (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine performs the non-cached reads for 'raw' sectors (2352 bytes
    per sector).  We also prepend a hard-coded RIFF header of 44 bytes to the file.
    All of this is already reflected in the file size.

    We start by checking whether to prepend any portion of the RIFF header.  Then we check
    if the last raw sector read was from the beginning portion of this file, deallocating
    that buffer if necessary.  Finally we do the following in a loop.

        Fill the IoRuns array for the next block of Io.
        Send the Io to the device driver.
        Perform any cleanup necessary on the IoRuns array.

    We will not do any async request in this path.  The request would have been
    posted to a worker thread before getting to this point.

Arguments:

    Fcb - Fcb representing the file to read.

    StartingOffset - Logical offset in the file to read from.

    ByteCount - Number of bytes to read.

Return Value:

    NTSTATUS - Status indicating the result of the operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    RIFF_HEADER LocalRiffHeader;
    PRIFF_HEADER RiffHeader;

    RAW_READ_INFO RawReads[MAX_PARALLEL_IOS];
    IO_RUN IoRuns[MAX_PARALLEL_IOS];
    ULONG RunCount = 0;
    ULONG CleanupRunCount = 0;

    PVOID UserBuffer;
    ULONG UserBufferOffset = 0;
    LONGLONG CurrentOffset = StartingOffset;
    ULONG RemainingByteCount = ByteCount;
    ULONG ThisByteCount;

    BOOLEAN TryingYellowbookMode2 = FALSE;

    TRACK_MODE_TYPE TrackMode;

    PAGED_CODE();

    //
    //  We want to make sure the user's buffer is locked in all cases.
    //

    if (IrpContext->Irp->MdlAddress == NULL) {

        CdCreateUserMdl( IrpContext, ByteCount, TRUE );
    }

    //
    //  The byte count was rounded up to a logical sector boundary.  It has
    //  nothing to do with the raw sectors on disk.  Limit the remaining
    //  byte count to file size.
    //

    if (CurrentOffset + RemainingByteCount > Fcb->FileSize.QuadPart) {

        RemainingByteCount = (ULONG) (Fcb->FileSize.QuadPart - CurrentOffset);
    }

    CdMapUserBuffer( IrpContext, &UserBuffer);

    //
    //  Use a try-finally to perform the final cleanup.
    //

    try {

        //
        //  If the initial offset lies within the RIFF header then copy the
        //  necessary bytes to the user's buffer.
        //

        if (CurrentOffset < sizeof( RIFF_HEADER )) {

            //
            //  Copy the appropriate RIFF header.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_DA_FILE )) {

                //
                //  Create the pseudo entries for a music disk.
                //

                if (FlagOn( Fcb->Vcb->VcbState, VCB_STATE_AUDIO_DISK )) {

                    PAUDIO_PLAY_HEADER AudioPlayHeader;
                    PTRACK_DATA TrackData;
                    ULONG SectorCount;

                    AudioPlayHeader = (PAUDIO_PLAY_HEADER) &LocalRiffHeader;
                    TrackData = &Fcb->Vcb->CdromToc->TrackData[Fcb->XAFileNumber];

                    //
                    //  Copy the data header into our local buffer.
                    //

                    RtlCopyMemory( AudioPlayHeader,
                                   CdAudioPlayHeader,
                                   sizeof( AUDIO_PLAY_HEADER ));

                    //
                    //  Copy the serial number into the Id field.  Also
                    //  the track number in the TOC.
                    //

                    AudioPlayHeader->DiskID = Fcb->Vcb->Vpb->SerialNumber;
                    AudioPlayHeader->TrackNumber = TrackData->TrackNumber;

                    //
                    //  TOC contains MSF (Minute/Second/Frame) addresses.  This is very
                    //  arcane, and we wind up having to bias around by the size of the
                    //  leadins and other such silliness to find real live sector addrs.
                    //
                    //  One frame == One sector.
                    //  One second == 75 frames (winds up being a 44.1khz sample)
                    //

                    //
                    //  Fill in the address and length fields.
                    //

                    AudioPlayHeader->TrackAddress[2] = TrackData->Address[1];
                    AudioPlayHeader->TrackAddress[1] = TrackData->Address[2];
                    AudioPlayHeader->TrackAddress[0] = TrackData->Address[3];

                    AudioPlayHeader->StartingSector = TrackData->Address[3];
                    AudioPlayHeader->StartingSector += (TrackData->Address[2] * 75);
                    AudioPlayHeader->StartingSector += (TrackData->Address[1] * 60 * 75);

                    //
                    //  Subtract 2 seconds for the block number.
                    //

                    AudioPlayHeader->StartingSector -= 150;

                    //
                    //  Go to the next track and find the starting point.
                    //

                    TrackData = &Fcb->Vcb->CdromToc->TrackData[Fcb->XAFileNumber + 1];

                    AudioPlayHeader->SectorCount = TrackData->Address[3];
                    AudioPlayHeader->SectorCount += (TrackData->Address[2] * 75);
                    AudioPlayHeader->SectorCount += (TrackData->Address[1] * 60 * 75);

                    //
                    //  Bias the sector count by 2 seconds.
                    //  Check that the offset is at least two seconds.
                    //

                    if (AudioPlayHeader->SectorCount < 150) {

                        AudioPlayHeader->SectorCount = 0;

                    } else {

                        AudioPlayHeader->SectorCount -= 150;
                    }

                    //
                    //  Now compute the difference.  If there is an error then use
                    //  a length of zero.
                    //

                    if (AudioPlayHeader->SectorCount < AudioPlayHeader->StartingSector) {

                        AudioPlayHeader->SectorCount = 0;

                    } else {

                        AudioPlayHeader->SectorCount -= AudioPlayHeader->StartingSector;
                    }

                    //
                    //  Use the sector count to determine the MSF length.
                    //

                    SectorCount = AudioPlayHeader->SectorCount;

                    AudioPlayHeader->TrackLength[0] = (UCHAR) (SectorCount % 75);
                    SectorCount /= 75;

                    AudioPlayHeader->TrackLength[1] = (UCHAR) (SectorCount % 60);
                    SectorCount /= 60;

                    AudioPlayHeader->TrackLength[2] = (UCHAR) (SectorCount % 60);

                    ThisByteCount = sizeof( RIFF_HEADER ) - (ULONG) CurrentOffset;

                    RtlCopyMemory( UserBuffer,
                                   Add2Ptr( AudioPlayHeader,
                                            sizeof( RIFF_HEADER ) - ThisByteCount,
                                            PCHAR ),
                                   ThisByteCount );

                //
                //  CD-XA CDDA
                //

                } else {

                    //
                    //  The WAVE header format is actually much closer to an audio play
                    //  header in format but we only need to modify the filesize fields.
                    //

                    RiffHeader = &LocalRiffHeader;

                    //
                    //  Copy the data header into our local buffer and add the file size to it.
                    //

                    RtlCopyMemory( RiffHeader,
                                   CdXAAudioPhileHeader,
                                   sizeof( RIFF_HEADER ));

                    RiffHeader->ChunkSize += Fcb->FileSize.LowPart;
                    RiffHeader->RawSectors += Fcb->FileSize.LowPart;

                    ThisByteCount = sizeof( RIFF_HEADER ) - (ULONG) CurrentOffset;
                    RtlCopyMemory( UserBuffer,
                                   Add2Ptr( RiffHeader,
                                            sizeof( RIFF_HEADER ) - ThisByteCount,
                                            PCHAR ),
                                   ThisByteCount );
                }

            //
            //  CD-XA non-audio
            //
            
            } else { 
    
                ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_MODE2_FILE | FCB_STATE_MODE2FORM2_FILE ));

                RiffHeader = &LocalRiffHeader;

                //
                //  Copy the data header into our local buffer and add the file size to it.
                //

                RtlCopyMemory( RiffHeader,
                               CdXAFileHeader,
                               sizeof( RIFF_HEADER ));

                RiffHeader->ChunkSize += Fcb->FileSize.LowPart;
                RiffHeader->RawSectors += Fcb->FileSize.LowPart;

                RiffHeader->Attributes = (USHORT) Fcb->XAAttributes;
                RiffHeader->FileNumber = (UCHAR) Fcb->XAFileNumber;

                ThisByteCount = sizeof( RIFF_HEADER ) - (ULONG) CurrentOffset;
                RtlCopyMemory( UserBuffer,
                               Add2Ptr( RiffHeader,
                                        sizeof( RIFF_HEADER ) - ThisByteCount,
                                        PCHAR ),
                               ThisByteCount );
            }

            //
            //  Adjust the starting offset and byte count to reflect that
            //  we copied over the RIFF bytes.
            //

            UserBuffer = Add2Ptr( UserBuffer, ThisByteCount, PVOID );
            UserBufferOffset += ThisByteCount;
            CurrentOffset += ThisByteCount;
            RemainingByteCount -= ThisByteCount;
        }

        //
        //  Set up the appropriate trackmode
        //

        TrackMode = CdFileTrackMode(Fcb);

        //
        //  Loop while there are more bytes to transfer.
        //

        while (RemainingByteCount != 0) {

            //
            //  Call prepare buffers to set up the next entries
            //  in the IoRuns array.  Remember if there are any
            //  unaligned entries.  If we're just retrying the previous
            //  runs with a different track mode,  then don't do anything here.
            //

            if (!TryingYellowbookMode2)  {
            
                RtlZeroMemory( IoRuns, sizeof( IoRuns ));
                RtlZeroMemory( RawReads, sizeof( RawReads ));

                CdPrepareXABuffers( IrpContext,
                                    IrpContext->Irp,
                                    Fcb,
                                    UserBuffer,
                                    UserBufferOffset,
                                    CurrentOffset,
                                    RemainingByteCount,
                                    IoRuns,
                                    &CleanupRunCount,
                                    &ThisByteCount );
            }
            
            //
            //  Perform multiple Io to read in the data.  Note that
            //  there may be no Io to do if we were able to use an
            //  existing buffer from the Vcb.
            //

            if (CleanupRunCount != 0) {

                RunCount = CleanupRunCount;

                CdMultipleXAAsync( IrpContext,
                                   RunCount,
                                   IoRuns,
                                   RawReads,
                                   TrackMode );
                //
                //  Wait for the request to complete.
                //

                CdWaitSync( IrpContext );

                Status = IrpContext->Irp->IoStatus.Status;

                //
                //  Exit this loop if there is an error.
                //

                if (!NT_SUCCESS( Status )) {

                    if (!TryingYellowbookMode2 && 
                        FlagOn( Fcb->FcbState, FCB_STATE_MODE2FORM2_FILE )) {

                        //
                        //  There are wacky cases where someone has mastered as CD-XA
                        //  but the sectors they claim are Mode2Form2 are really, according
                        //  to ATAPI devices, Yellowbook Mode2. We will try once more
                        //  with these. Kodak PHOTO-CD has been observed to do this.
                        //

                        TryingYellowbookMode2 = TRUE;
                        TrackMode = YellowMode2;
                        
                        //
                        //  Clear our 'cumulative' error status value
                        //
                        
                        IrpContext->IoContext->Status = STATUS_SUCCESS;

                        continue;
                    }

                    try_return( NOTHING );
                }
                
                CleanupRunCount = 0;
                
                if (TryingYellowbookMode2) {

                    //
                    //  We succesfully got data when we tried switching the trackmode,
                    //  so change the state of the FCB to remember that.
                    //

                    SetFlag( Fcb->FcbState, FCB_STATE_MODE2_FILE );
                    ClearFlag( Fcb->FcbState, FCB_STATE_MODE2FORM2_FILE );

                    TryingYellowbookMode2 = FALSE;
                }

                //
                //  Perform post read operations on the IoRuns if
                //  necessary.
                //

                CdFinishBuffers( IrpContext, IoRuns, RunCount, FALSE, TRUE );
            }

            //
            //  Adjust our loop variants.
            //

            RemainingByteCount -= ThisByteCount;
            CurrentOffset += ThisByteCount;
            UserBuffer = Add2Ptr( UserBuffer, ThisByteCount, PVOID );
            UserBufferOffset += ThisByteCount;
        }

        //
        //  Always flush the hardware cache.
        //

        KeFlushIoBuffers( IrpContext->Irp->MdlAddress, TRUE, FALSE );

    try_exit:  NOTHING;
    } finally {

        //
        //  Perform final cleanup on the IoRuns if necessary.
        //

        if (CleanupRunCount != 0) {

            CdFinishBuffers( IrpContext, IoRuns, CleanupRunCount, TRUE, FALSE );
        }
    }

    return Status;
}


BOOLEAN
CdReadSectors (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN BOOLEAN ReturnError,
    IN OUT PVOID Buffer,
    IN PDEVICE_OBJECT TargetDeviceObject
    )

/*++

Routine Description:

    This routine is called to transfer sectors from the disk to a
    specified buffer.  It is used for mount and volume verify operations.

    This routine is synchronous, it will not return until the operation
    is complete or until the operation fails.

    The routine allocates an IRP and then passes this IRP to a lower
    level driver.  Errors may occur in the allocation of this IRP or
    in the operation of the lower driver.

Arguments:

    StartingOffset - Logical offset on the disk to start the read.  This
        must be on a sector boundary, no check is made here.

    ByteCount - Number of bytes to read.  This is an integral number of
        2K sectors, no check is made here to confirm this.

    ReturnError - Indicates whether we should return TRUE or FALSE
        to indicate an error or raise an error condition.  This only applies
        to the result of the IO.  Any other error may cause a raise.

    Buffer - Buffer to transfer the disk data into.

    TargetDeviceObject - The device object for the volume to be read.

Return Value:

    BOOLEAN - Depending on 'RaiseOnError' flag above.  TRUE if operation
              succeeded, FALSE otherwise.

--*/

{
    NTSTATUS Status;
    KEVENT  Event;
    PIRP Irp;

    PAGED_CODE();

    //
    //  Initialize the event.
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Attempt to allocate the IRP.  If unsuccessful, raise
    //  STATUS_INSUFFICIENT_RESOURCES.
    //

    Irp = IoBuildSynchronousFsdRequest( IRP_MJ_READ,
                                        TargetDeviceObject,
                                        Buffer,
                                        ByteCount,
                                        (PLARGE_INTEGER) &StartingOffset,
                                        &Event,
                                        &IrpContext->Irp->IoStatus );

    if (Irp == NULL) {

        CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
    }

    //
    //  Ignore the change line (verify) for mount and verify requests
    //

    SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    //
    //  Send the request down to the driver.  If an error occurs return
    //  it to the caller.
    //

    Status = IoCallDriver( TargetDeviceObject, Irp );

    //
    //  If the status was STATUS_PENDING then wait on the event.
    //

    if (Status == STATUS_PENDING) {

        Status = KeWaitForSingleObject( &Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL );

        //
        //  On a successful wait pull the status out of the IoStatus block.
        //

        if (NT_SUCCESS( Status )) {

            Status = IrpContext->Irp->IoStatus.Status;
        }
    }

    //
    //  Check whether we should raise in the error case.
    //

    if (!NT_SUCCESS( Status )) {

        if (!ReturnError) {

            CdNormalizeAndRaiseStatus( IrpContext, Status );
        }

        //
        //  We don't raise, but return FALSE to indicate an error.
        //

        return FALSE;

    //
    //  The operation completed successfully.
    //

    } else {

        return TRUE;
    }
}


NTSTATUS
CdCreateUserMdl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG BufferLength,
    IN BOOLEAN RaiseOnError
    )

/*++

Routine Description:

    This routine locks the specified buffer for read access (we only write into
    the buffer).  The file system requires this routine since it does not
    ask the I/O system to lock its buffers for direct I/O.  This routine
    may only be called from the Fsd while still in the user context.

    This routine is only called if there is not already an Mdl.

Arguments:

    BufferLength - Length of user buffer.

    RaiseOnError - Indicates if our caller wants this routine to raise on
        an error condition.

Return Value:

    NTSTATUS - Status from this routine.  Error status only returned if
        RaiseOnError is FALSE.

--*/

{
    NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;
    PMDL Mdl;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( IrpContext->Irp );
    ASSERT( IrpContext->Irp->MdlAddress == NULL );

    //
    // Allocate the Mdl, and Raise if we fail.
    //

    Mdl = IoAllocateMdl( IrpContext->Irp->UserBuffer,
                         BufferLength,
                         FALSE,
                         FALSE,
                         IrpContext->Irp );

    if (Mdl != NULL) {

        //
        //  Now probe the buffer described by the Irp.  If we get an exception,
        //  deallocate the Mdl and return the appropriate "expected" status.
        //

        try {

            MmProbeAndLockPages( Mdl, IrpContext->Irp->RequestorMode, IoWriteAccess );

            Status = STATUS_SUCCESS;

        } except(EXCEPTION_EXECUTE_HANDLER) {

            Status = GetExceptionCode();

            IoFreeMdl( Mdl );
            IrpContext->Irp->MdlAddress = NULL;

            if (!FsRtlIsNtstatusExpected( Status )) {

                Status = STATUS_INVALID_USER_BUFFER;
            }
        }
    }

    //
    //  Check if we are to raise or return
    //

    if (Status != STATUS_SUCCESS) {

        if (RaiseOnError) {

            CdRaiseStatus( IrpContext, Status );
        }
    }

    //
    //  Return the status code.
    //

    return Status;
}


NTSTATUS
CdPerformDevIoCtrl (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT Device,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    IN BOOLEAN OverrideVerify,
    OUT PIO_STATUS_BLOCK Iosb OPTIONAL
    )

/*++

Routine Description:

    This routine is called to perform DevIoCtrl functions internally within
    the filesystem.  We take the status from the driver and return it to our
    caller.

Arguments:

    IoControlCode - Code to send to driver.

    Device - This is the device to send the request to.

    OutPutBuffer - Pointer to output buffer.

    OutputBufferLength - Length of output buffer above.

    InternalDeviceIoControl - Indicates if this is an internal or external
        Io control code.

    OverrideVerify - Indicates if we should tell the driver not to return
        STATUS_VERIFY_REQUIRED for mount and verify.

    Iosb - If specified, we return the results of the operation here.

Return Value:

    NTSTATUS - Status returned by next lower driver.

--*/

{
    NTSTATUS Status;
    PIRP Irp;
    KEVENT Event;
    IO_STATUS_BLOCK LocalIosb;
    PIO_STATUS_BLOCK IosbToUse = &LocalIosb;

    PAGED_CODE();

    //
    //  Check if the user gave us an Iosb.
    //

    if (ARGUMENT_PRESENT( Iosb )) {

        IosbToUse = Iosb;
    }

    IosbToUse->Status = 0;
    IosbToUse->Information = 0;

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest( IoControlCode,
                                         Device,
                                         NULL,
                                         0,
                                         OutputBuffer,
                                         OutputBufferLength,
                                         InternalDeviceIoControl,
                                         &Event,
                                         IosbToUse );

    if (Irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (OverrideVerify) {

        SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );
    }

    Status = IoCallDriver( Device, Irp );

    //
    //  We check for device not ready by first checking Status
    //  and then if status pending was returned, the Iosb status
    //  value.
    //

    if (Status == STATUS_PENDING) {

        (VOID) KeWaitForSingleObject( &Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER)NULL );

        Status = IosbToUse->Status;
    }

    ASSERT( !(OverrideVerify && (STATUS_VERIFY_REQUIRED == Status)));

    return Status;
}


//
//  Local support routine
//

BOOLEAN
CdPrepareBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PVOID UserBuffer,
    IN ULONG UserBufferOffset,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PIO_RUN IoRuns,
    IN PULONG RunCount,
    IN PULONG ThisByteCount
    )

/*++

Routine Description:

    This routine is the worker routine which looks up each run of an IO
    request and stores an entry for it in the IoRuns array.  If the run
    begins on an unaligned disk boundary then we will allocate a buffer
    and Mdl for the unaligned portion and put it in the IoRuns entry.

    This routine will raise CANT_WAIT if an unaligned transfer is encountered
    and this request can't wait.

Arguments:

    Irp - Originating Irp for this request.

    Fcb - This is the Fcb for this data stream.  It may be a file, directory,
        path table or the volume file.

    UserBuffer - Current position in the user's buffer.

    UserBufferOffset - Offset from the start of the original user buffer.

    StartingOffset - Offset in the stream to begin the read.

    ByteCount - Number of bytes to read.  We will fill the IoRuns array up
        to this point.  We will stop early if we exceed the maximum number
        of parallel Ios we support.

    IoRuns - Pointer to the IoRuns array.  The entire array is zeroes when
        this routine is called.

    RunCount - Number of entries in the IoRuns array filled here.

    ThisByteCount - Number of bytes described by the IoRun entries.  Will
        not exceed the ByteCount passed in.

Return Value:

    BOOLEAN - TRUE if one of the entries in an unaligned buffer (provided
        this is synchronous).  FALSE otherwise.

--*/

{
    BOOLEAN FoundUnaligned = FALSE;
    PIO_RUN ThisIoRun = IoRuns;

    //
    //  Following indicate where we are in the current transfer.  Current
    //  position in the file and number of bytes yet to transfer from
    //  this position.
    //

    ULONG RemainingByteCount = ByteCount;
    LONGLONG CurrentFileOffset = StartingOffset;

    //
    //  Following indicate the state of the user's buffer.  We have
    //  the destination of the next transfer and its offset in the
    //  buffer.  We also have the next available position in the buffer
    //  available for a scratch buffer.  We will align this up to a sector
    //  boundary.
    //

    PVOID CurrentUserBuffer = UserBuffer;
    ULONG CurrentUserBufferOffset = UserBufferOffset;

    PVOID ScratchUserBuffer = UserBuffer;
    ULONG ScratchUserBufferOffset = UserBufferOffset;

    //
    //  The following is the next contiguous bytes on the disk to
    //  transfer.  Read from the allocation package.
    //

    LONGLONG DiskOffset;
    ULONG CurrentByteCount;

    PAGED_CODE();

    //
    //  Initialize the RunCount and ByteCount.
    //

    *RunCount = 0;
    *ThisByteCount = 0;

    //
    //  Loop while there are more bytes to process or there are
    //  available entries in the IoRun array.
    //

    while (TRUE) {

        *RunCount += 1;

        //
        //  Initialize the current position in the IoRuns array.
        //  Find the user's buffer for this portion of the transfer.
        //

        ThisIoRun->UserBuffer = CurrentUserBuffer;

        //
        //  Find the allocation information for the current offset in the
        //  stream.
        //

        CdLookupAllocation( IrpContext,
                            Fcb,
                            CurrentFileOffset,
                            &DiskOffset,
                            &CurrentByteCount );

        //
        //  Limit ourselves to the data requested.
        //

        if (CurrentByteCount > RemainingByteCount) {

            CurrentByteCount = RemainingByteCount;
        }

        //
        //  Handle the case where this is an unaligned transfer.  The
        //  following must all be true for this to be an aligned transfer.
        //
        //      Disk offset on a 2048 byte boundary (Start of transfer)
        //
        //      Byte count is a multiple of 2048 (Length of transfer)
        //
        //      Current buffer offset is also on a 2048 byte boundary.
        //
        //  If the ByteCount is at least one sector then do the
        //  unaligned transfer only for the tail.  We can use the
        //  user's buffer for the aligned portion.
        //

        if (FlagOn( (ULONG) DiskOffset, SECTOR_MASK ) ||
            FlagOn( CurrentUserBufferOffset, SECTOR_MASK ) ||
            (FlagOn( (ULONG) CurrentByteCount, SECTOR_MASK ) &&
             (CurrentByteCount < SECTOR_SIZE))) {

            //
            //  If we can't wait then raise.
            //

            if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            //
            //  Remember the offset and the number of bytes out of
            //  the transfer buffer to copy into the user's buffer.
            //  We will truncate the current read to end on a sector
            //  boundary.
            //

            ThisIoRun->TransferBufferOffset = SectorOffset( DiskOffset );

            //
            //  Make sure this transfer ends on a sector boundary.
            //

            ThisIoRun->DiskOffset = LlSectorTruncate( DiskOffset );

            //
            //  Check if we can use a free portion of the user's buffer.
            //  If we can copy the bytes to an earlier portion of the
            //  buffer then read into that location and slide the bytes
            //  up.
            //
            //  We can use the user's buffer if:
            //
            //      The temporary location in the buffer is before the
            //      final destination.
            //
            //      There is at least one sector of data to read.
            //

            if ((ScratchUserBufferOffset + ThisIoRun->TransferBufferOffset < CurrentUserBufferOffset) &&
                (ThisIoRun->TransferBufferOffset + CurrentByteCount >= SECTOR_SIZE)) {

                ThisIoRun->DiskByteCount = SectorTruncate( ThisIoRun->TransferBufferOffset + CurrentByteCount );
                CurrentByteCount = ThisIoRun->DiskByteCount - ThisIoRun->TransferBufferOffset;
                ThisIoRun->TransferByteCount = CurrentByteCount;

                //
                //  Point to the user's buffer and Mdl for this transfer.
                //

                ThisIoRun->TransferBuffer = ScratchUserBuffer;
                ThisIoRun->TransferMdl = Irp->MdlAddress;
                ThisIoRun->TransferVirtualAddress = Add2Ptr( Irp->UserBuffer,
                                                             ScratchUserBufferOffset,
                                                             PVOID );

                ScratchUserBuffer = Add2Ptr( ScratchUserBuffer,
                                             ThisIoRun->DiskByteCount,
                                             PVOID );

                ScratchUserBufferOffset += ThisIoRun->DiskByteCount;

            //
            //  Otherwise we need to allocate an auxilary buffer for the next sector.
            //

            } else {

                //
                //  Read up to a page containing the partial data
                //

                ThisIoRun->DiskByteCount = SectorAlign( ThisIoRun->TransferBufferOffset + CurrentByteCount );

                if (ThisIoRun->DiskByteCount > PAGE_SIZE) {

                    ThisIoRun->DiskByteCount = PAGE_SIZE;
                }

                if (ThisIoRun->TransferBufferOffset + CurrentByteCount > ThisIoRun->DiskByteCount) {

                    CurrentByteCount = ThisIoRun->DiskByteCount - ThisIoRun->TransferBufferOffset;
                }

                ThisIoRun->TransferByteCount = CurrentByteCount;

                //
                //  Allocate a buffer for the non-aligned transfer.
                //

                ThisIoRun->TransferBuffer = FsRtlAllocatePoolWithTag( CdNonPagedPool, PAGE_SIZE, TAG_IO_BUFFER );

                //
                //  Allocate and build the Mdl to describe this buffer.
                //

                ThisIoRun->TransferMdl = IoAllocateMdl( ThisIoRun->TransferBuffer,
                                                        PAGE_SIZE,
                                                        FALSE,
                                                        FALSE,
                                                        NULL );

                ThisIoRun->TransferVirtualAddress = ThisIoRun->TransferBuffer;

                if (ThisIoRun->TransferMdl == NULL) {

                    IrpContext->Irp->IoStatus.Information = 0;
                    CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
                }

                MmBuildMdlForNonPagedPool( ThisIoRun->TransferMdl );
            }

            //
            //  Remember we found an unaligned transfer.
            //

            FoundUnaligned = TRUE;

        //
        //  Otherwise we use the buffer and Mdl from the original request.
        //

        } else {

            //
            //  Truncate the read length to a sector-aligned value.  We know
            //  the length must be at least one sector or we wouldn't be
            //  here now.
            //

            CurrentByteCount = SectorTruncate( CurrentByteCount );

            //
            //  Read these sectors from the disk.
            //

            ThisIoRun->DiskOffset = DiskOffset;
            ThisIoRun->DiskByteCount = CurrentByteCount;

            //
            //  Use the user's buffer and Mdl as our transfer buffer
            //  and Mdl.
            //

            ThisIoRun->TransferBuffer = CurrentUserBuffer;
            ThisIoRun->TransferMdl = Irp->MdlAddress;
            ThisIoRun->TransferVirtualAddress = Add2Ptr( Irp->UserBuffer,
                                                         CurrentUserBufferOffset,
                                                         PVOID );

            ScratchUserBuffer = Add2Ptr( CurrentUserBuffer,
                                         CurrentByteCount,
                                         PVOID );

            ScratchUserBufferOffset += CurrentByteCount;
        }

        //
        //  Update our position in the transfer and the RunCount and
        //  ByteCount for the user.
        //

        RemainingByteCount -= CurrentByteCount;

        //
        //  Break out if no more positions in the IoRuns array or
        //  we have all of the bytes accounted for.
        //

        *ThisByteCount += CurrentByteCount;

        if ((RemainingByteCount == 0) || (*RunCount == MAX_PARALLEL_IOS)) {

            break;
        }

        //
        //  Update our pointers for the user's buffer.
        //

        ThisIoRun += 1;
        CurrentUserBuffer = Add2Ptr( CurrentUserBuffer, CurrentByteCount, PVOID );
        CurrentUserBufferOffset += CurrentByteCount;
        CurrentFileOffset += CurrentByteCount;
    }

    return FoundUnaligned;
}


//
//  Local support routine
//

VOID
CdPrepareXABuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb,
    IN PVOID UserBuffer,
    IN ULONG UserBufferOffset,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PIO_RUN IoRuns,
    IN PULONG RunCount,
    IN PULONG ThisByteCount
    )

/*++

Routine Description:

    This routine is the worker routine which looks up the individual runs
    of an IO request and stores an entry for it in the IoRuns array.  The
    worker routine is for XA files where we need to convert the raw offset
    in the file to logical cooked sectors.  We store one raw sector in
    the Vcb.  If the current read is to that sector then we can simply copy
    whatever bytes are needed from that sector.

Arguments:

    Irp - Originating Irp for this request.

    Fcb - This is the Fcb for this data stream.  It must be a data stream.

    UserBuffer - Current position in the user's buffer.

    UserBufferOffset - Offset of this buffer from the beginning of the user's
        buffer for the original request.

    StartingOffset - Offset in the stream to begin the read.

    ByteCount - Number of bytes to read.  We will fill the IoRuns array up
        to this point.  We will stop early if we exceed the maximum number
        of parallel Ios we support.

    IoRuns - Pointer to the IoRuns array.  The entire array is zeroes when
        this routine is called.

    RunCount - Number of entries in the IoRuns array filled here.

    ThisByteCount - Number of bytes described by the IoRun entries.  Will
        not exceed the ByteCount passed in.

Return Value:

    None

--*/

{
    PIO_RUN ThisIoRun = IoRuns;
    BOOLEAN PerformedCopy;

    //
    //  The following deal with where we are in the range of raw sectors.
    //  Note that we will bias the input file offset by the RIFF header
    //  to deal directly with the raw sectors.
    //

    ULONG RawSectorOffset;
    ULONG RemainingRawByteCount = ByteCount;
    LONGLONG CurrentRawOffset = StartingOffset - sizeof( RIFF_HEADER );

    //
    //  The following is the offset into the cooked sectors for the file.
    //

    LONGLONG CurrentCookedOffset;
    ULONG RemainingCookedByteCount;

    //
    //  Following indicate the state of the user's buffer.  We have
    //  the destination of the next transfer and its offset in the
    //  buffer.  We also have the next available position in the buffer
    //  available for a scratch buffer.
    //

    PVOID CurrentUserBuffer = UserBuffer;
    ULONG CurrentUserBufferOffset = UserBufferOffset;

    PVOID ScratchUserBuffer = UserBuffer;
    ULONG ScratchUserBufferOffset = UserBufferOffset;
    BOOLEAN RoundScratchBuffer = TRUE;

    //
    //  The following is the next contiguous bytes on the disk to
    //  transfer.  These are represented by cooked byte offset and length.
    //  We also compute the number of raw bytes in the current transfer.
    //

    LONGLONG DiskOffset;
    ULONG CurrentCookedByteCount;
    ULONG CurrentRawByteCount;

    PAGED_CODE();

    //
    //  We need to maintain our position as we walk through the sectors on the disk.
    //  We keep separate values for the cooked offset as well as the raw offset.
    //  These are initialized on sector boundaries and we move through these
    //  the file sector-by-sector.
    //
    //  Try to do 32-bit math.
    //

    if (((PLARGE_INTEGER) &CurrentRawOffset)->HighPart == 0) {

        //
        //  Prefix/fast: Note that the following are safe since we only
        //               take this path for 32bit offsets.
        //

        CurrentRawOffset = (LONGLONG) ((ULONG) CurrentRawOffset / RAW_SECTOR_SIZE);

        CurrentCookedOffset = (LONGLONG) ((ULONG) CurrentRawOffset << SECTOR_SHIFT );

        CurrentRawOffset = (LONGLONG) ((ULONG) CurrentRawOffset * RAW_SECTOR_SIZE);

    //
    //  Otherwise we need to do 64-bit math (sigh).
    //

    } else {

        CurrentRawOffset /= RAW_SECTOR_SIZE;

        CurrentCookedOffset = CurrentRawOffset << SECTOR_SHIFT;

        CurrentRawOffset *= RAW_SECTOR_SIZE;
    }

    //
    //  Now compute the full number of sectors to be read.  Count all of the raw
    //  sectors that need to be read and convert to cooked bytes.
    //

    RawSectorOffset = (ULONG) ( StartingOffset - CurrentRawOffset) - sizeof( RIFF_HEADER );
    CurrentRawByteCount = (RawSectorOffset + RemainingRawByteCount + RAW_SECTOR_SIZE - 1) / RAW_SECTOR_SIZE;

    RemainingCookedByteCount = CurrentRawByteCount << SECTOR_SHIFT;

    //
    //  Initialize the RunCount and ByteCount.
    //

    *RunCount = 0;
    *ThisByteCount = 0;

    //
    //  Loop while there are more bytes to process or there are
    //  available entries in the IoRun array.
    //

    while (TRUE) {

        PerformedCopy = FALSE;
        *RunCount += 1;

        //
        //  Round the scratch buffer up to a sector boundary for alignment.
        //

        if (RoundScratchBuffer) {

            if (SectorOffset( ScratchUserBuffer ) != 0) {

                CurrentRawByteCount = SECTOR_SIZE - SectorOffset( ScratchUserBuffer );

                ScratchUserBuffer = Add2Ptr( ScratchUserBuffer,
                                             CurrentRawByteCount,
                                             PVOID );

                ScratchUserBufferOffset += CurrentRawByteCount;
            }

            RoundScratchBuffer = FALSE;
        }

        //
        //  Initialize the current position in the IoRuns array.  Find the 
        //  eventual destination in the user's buffer for this portion of the transfer.
        //

        ThisIoRun->UserBuffer = CurrentUserBuffer;

        //
        //  Find the allocation information for the current offset in the
        //  stream.
        //

        CdLookupAllocation( IrpContext,
                            Fcb,
                            CurrentCookedOffset,
                            &DiskOffset,
                            &CurrentCookedByteCount );
        //
        //  Maybe we got lucky and this is the same sector as in the
        //  Vcb.
        //

        if (DiskOffset == Fcb->Vcb->XADiskOffset) {

            //
            //  We will perform safe synchronization.  Check again that
            //  this is the correct sector.
            //

            CdLockVcb( IrpContext, Fcb->Vcb );

            if ((DiskOffset == Fcb->Vcb->XADiskOffset) &&
                (Fcb->Vcb->XASector != NULL)) {

                //
                //  Copy any bytes we can from the current sector.
                //

                CurrentRawByteCount = RAW_SECTOR_SIZE - RawSectorOffset;

                //
                //  Check whether we don't go to the end of the sector.
                //

                if (CurrentRawByteCount > RemainingRawByteCount) {

                    CurrentRawByteCount = RemainingRawByteCount;
                }

                RtlCopyMemory( CurrentUserBuffer,
                               Add2Ptr( Fcb->Vcb->XASector, RawSectorOffset, PCHAR ),
                               CurrentRawByteCount );

                CdUnlockVcb( IrpContext, Fcb->Vcb );

                //
                //  Adjust the run count and pointer in the IoRuns array
                //  to show that we didn't use a position.
                //

                *RunCount -= 1;
                ThisIoRun -= 1;

                //
                //  Remember that we performed a copy operation and update
                //  the next available position in the scratch buffer.
                //

                PerformedCopy = TRUE;

                ScratchUserBuffer = Add2Ptr( ScratchUserBuffer,
                                             CurrentRawByteCount,
                                             PVOID );

                ScratchUserBufferOffset += CurrentRawByteCount;

                CurrentCookedByteCount = SECTOR_SIZE;

                //
                //  Set the flag indicating we want to round the scratch buffer
                //  to a sector boundary.
                //
                
                RoundScratchBuffer = TRUE;

            } else {

                //
                //  The safe test showed no available buffer.  Drop down to common code to
                //  perform the Io.
                //

                CdUnlockVcb( IrpContext, Fcb->Vcb );
            }
        }

        //
        //  No work in this pass if we did a copy operation.
        //

        if (!PerformedCopy) {

            //
            //  Limit ourselves by the number of remaining cooked bytes.
            //

            if (CurrentCookedByteCount > RemainingCookedByteCount) {

                CurrentCookedByteCount = RemainingCookedByteCount;
            }

            ThisIoRun->DiskOffset = DiskOffset;
            ThisIoRun->TransferBufferOffset = RawSectorOffset;

            //
            //  We will always need to perform copy operations for XA files.
            //  We allocate an auxillary buffer to read the start of the
            //  transfer.  Then we can use a range of the user's buffer to
            //  perform the next range of the transfer.  Finally we may
            //  need to allocate a buffer for the tail of the transfer.
            //
            //  We can use the user's buffer (at the current scratch buffer) if the
            //  following are true:
            //
            //      If we are to store the beginning of the raw sector in the user's buffer.
            //      The current scratch buffer precedes the destination in the user's buffer 
            //          (and hence also lies within it)
            //      There are enough bytes remaining in the buffer for at least one
            //          raw sector.
            //

            if ((RawSectorOffset == 0) &&
                (ScratchUserBufferOffset <= CurrentUserBufferOffset) &&
                (CurrentUserBufferOffset - ScratchUserBufferOffset + RemainingRawByteCount >= RAW_SECTOR_SIZE)) {

                //
                //  We can use the scratch buffer.  We must ensure we don't send down reads
                //  greater than the device can handle, since the driver is unable to split
                //  raw requests.
                //

                if (CurrentCookedByteCount <= Fcb->Vcb->MaximumTransferRawSectors * SECTOR_SIZE) {

                    CurrentRawByteCount = (SectorAlign( CurrentCookedByteCount) >> SECTOR_SHIFT) * RAW_SECTOR_SIZE;
    
                } else {

                    CurrentCookedByteCount = Fcb->Vcb->MaximumTransferRawSectors * SECTOR_SIZE;
                    CurrentRawByteCount = Fcb->Vcb->MaximumTransferRawSectors * RAW_SECTOR_SIZE;
                }

                //
                //  Now make sure we are within the page transfer limit.
                //

                while (ADDRESS_AND_SIZE_TO_SPAN_PAGES(ScratchUserBuffer, RawSectorAlign( CurrentRawByteCount)) > 
                       Fcb->Vcb->MaximumPhysicalPages )  {

                    CurrentRawByteCount -= RAW_SECTOR_SIZE;
                    CurrentCookedByteCount -= SECTOR_SIZE;
                }

                //
                //  Trim the number of bytes to read if it won't fit into the current buffer. Take
                //  account of the fact that we must read in whole raw sector multiples.
                //

                while ( RawSectorAlign( CurrentRawByteCount) > 
                        (CurrentUserBufferOffset - ScratchUserBufferOffset + RemainingRawByteCount) )  {

                    CurrentRawByteCount -= RAW_SECTOR_SIZE;
                    CurrentCookedByteCount -= SECTOR_SIZE;
                }

                //
                //  Now trim the maximum number of raw bytes to the remaining bytes.
                //

                if (CurrentRawByteCount > RemainingRawByteCount) {

                    CurrentRawByteCount = RemainingRawByteCount;
                }
                
                //
                //  Update the IO run array.  We point to the scratch buffer as
                //  well as the buffer and Mdl in the original Irp.
                //

                ThisIoRun->DiskByteCount = SectorAlign( CurrentCookedByteCount);

                //
                //  Store the number of bytes which we actually care about from this transfer
                //
                
                ThisIoRun->TransferByteCount = CurrentRawByteCount;

                //
                //  Point to the user's buffer and Mdl for this transfer.
                //

                ThisIoRun->TransferBuffer = ScratchUserBuffer;
                ThisIoRun->TransferMdl = Irp->MdlAddress;
                ThisIoRun->TransferVirtualAddress = Add2Ptr( Irp->UserBuffer, 
                                                             ScratchUserBufferOffset,
                                                             PVOID);
                //
                //  Update the scratch buffer pointer.  Note that since the underlying
                //  driver stack will always transfer in multiples of raw sectors,
                //  we must round up here rather than simply advancing by the length of the
                //  of the data which we actually care about.
                //

                ScratchUserBuffer = Add2Ptr( ScratchUserBuffer,
                                             RawSectorAlign( CurrentRawByteCount),
                                             PVOID );
                                             
                ScratchUserBufferOffset += RawSectorAlign( CurrentRawByteCount);;

                //
                //  Set the flag indicating we want to round the scratch buffer
                //  to a cooked sector boundary.
                //

                RoundScratchBuffer = TRUE;

            } else {

                //
                //  We need to determine the number of bytes to transfer and the
                //  offset into this page to begin the transfer.
                //
                //  We will transfer only one raw sector.
                //

                ThisIoRun->DiskByteCount = SECTOR_SIZE;

                CurrentCookedByteCount = SECTOR_SIZE;

                ThisIoRun->TransferByteCount = RAW_SECTOR_SIZE - RawSectorOffset;
                ThisIoRun->TransferBufferOffset = RawSectorOffset;

                if (ThisIoRun->TransferByteCount > RemainingRawByteCount) {

                    ThisIoRun->TransferByteCount = RemainingRawByteCount;
                }

                CurrentRawByteCount = ThisIoRun->TransferByteCount;

                //
                //  We need to allocate an auxillary buffer.  We will allocate
                //  a single page.  Then we will build an Mdl to describe the buffer.
                //

                ThisIoRun->TransferBuffer = FsRtlAllocatePoolWithTag( CdNonPagedPool, PAGE_SIZE, TAG_IO_BUFFER );

                //
                //  Allocate and build the Mdl to describe this buffer.
                //

                ThisIoRun->TransferMdl = IoAllocateMdl( ThisIoRun->TransferBuffer,
                                                        PAGE_SIZE,
                                                        FALSE,
                                                        FALSE,
                                                        NULL );

                ThisIoRun->TransferVirtualAddress = ThisIoRun->TransferBuffer;

                if (ThisIoRun->TransferMdl == NULL) {

                    IrpContext->Irp->IoStatus.Information = 0;
                    CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
                }

                MmBuildMdlForNonPagedPool( ThisIoRun->TransferMdl );
            }
        }

        //
        //  Update the byte count for our caller.
        //

        RemainingRawByteCount -= CurrentRawByteCount;
        *ThisByteCount += CurrentRawByteCount;

        //
        //  Break out if no more positions in the IoRuns array or
        //  we have all of the bytes accounted for.
        //

        if ((RemainingRawByteCount == 0) || (*RunCount == MAX_PARALLEL_IOS)) {

            break;
        }

        //
        //  Update our local pointers to allow for the current range of bytes.
        //

        ThisIoRun += 1;

        CurrentUserBuffer = Add2Ptr( CurrentUserBuffer, CurrentRawByteCount, PVOID );
        CurrentUserBufferOffset += CurrentRawByteCount;

        RawSectorOffset = 0;

        CurrentCookedOffset += CurrentCookedByteCount;
        RemainingCookedByteCount -= CurrentCookedByteCount;
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
CdFinishBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIO_RUN IoRuns,
    IN ULONG RunCount,
    IN BOOLEAN FinalCleanup,
    IN BOOLEAN SaveXABuffer
    )

/*++

Routine Description:

    This routine is called to perform any data transferred required for
    unaligned Io or to perform the final cleanup of the IoRuns array.

    In all cases this is where we will deallocate any buffer and mdl
    allocated to perform the unaligned transfer.  If this is not the
    final cleanup then we also transfer the bytes to the user buffer
    and flush the hardware cache.

    We walk backwards through the run array because we may be shifting data
    in the user's buffer.  Typical case is where we allocated a buffer for
    the first part of a read and then used the user's buffer for the
    next section (but stored it at the beginning of the buffer.

Arguments:

    IoRuns - Pointer to the IoRuns array.

    RunCount - Number of entries in the IoRuns array filled here.

    FinalCleanup - Indicates if we should be deallocating temporary buffers
        (TRUE) or transferring bytes for a unaligned transfers and
        deallocating the buffers (FALSE).  Flush the system cache if
        transferring data.

    SaveXABuffer - TRUE if we should try to save an XA buffer, FALSE otherwise

Return Value:

    BOOLEAN - TRUE if this request needs the Io buffers to be flushed, FALSE otherwise.

--*/

{
    BOOLEAN FlushIoBuffers = FALSE;

    ULONG RemainingEntries = RunCount;
    PIO_RUN ThisIoRun = &IoRuns[RunCount - 1];
    PVCB Vcb;

    PAGED_CODE();

    //
    //  Walk through each entry in the IoRun array.
    //

    while (RemainingEntries != 0) {

        //
        //  We only need to deal with the case of an unaligned transfer.
        //

        if (ThisIoRun->TransferByteCount != 0) {

            //
            //  If not the final cleanup then transfer the data to the
            //  user's buffer and remember that we will need to flush
            //  the user's buffer to memory.
            //

            if (!FinalCleanup) {

                //
                //  If we are shifting in the user's buffer then use
                //  MoveMemory.
                //

                if (ThisIoRun->TransferMdl == IrpContext->Irp->MdlAddress) {

                    RtlMoveMemory( ThisIoRun->UserBuffer,
                                   Add2Ptr( ThisIoRun->TransferBuffer,
                                            ThisIoRun->TransferBufferOffset,
                                            PVOID ),
                                   ThisIoRun->TransferByteCount );

                } else {

                    RtlCopyMemory( ThisIoRun->UserBuffer,
                                   Add2Ptr( ThisIoRun->TransferBuffer,
                                            ThisIoRun->TransferBufferOffset,
                                            PVOID ),
                                   ThisIoRun->TransferByteCount );
                }

                FlushIoBuffers = TRUE;
            }

            //
            //  Free any Mdl we may have allocated.  If the Mdl isn't
            //  present then we must have failed during the allocation
            //  phase.
            //

            if (ThisIoRun->TransferMdl != IrpContext->Irp->MdlAddress) {

                if (ThisIoRun->TransferMdl != NULL) {

                    IoFreeMdl( ThisIoRun->TransferMdl );
                }

                //
                //  Now free any buffer we may have allocated.  If the Mdl
                //  doesn't match the original Mdl then free the buffer.
                //

                if (ThisIoRun->TransferBuffer != NULL) {

                    //
                    //  If this is the final buffer for an XA read then store this buffer
                    //  into the Vcb so that we will have it when reading any remaining
                    //  portion of this buffer.
                    //

                    if (SaveXABuffer) {

                        Vcb = IrpContext->Vcb;

                        CdLockVcb( IrpContext, Vcb );

                        if (Vcb->XASector != NULL) {

                            CdFreePool( &Vcb->XASector );
                        }

                        Vcb->XASector = ThisIoRun->TransferBuffer;
                        Vcb->XADiskOffset = ThisIoRun->DiskOffset;

                        SaveXABuffer = FALSE;

                        CdUnlockVcb( IrpContext, Vcb );

                    //
                    //  Otherwise just free the buffer.
                    //

                    } else {

                        CdFreePool( &ThisIoRun->TransferBuffer );
                    }
                }
            }
        }

        //
        //  Now handle the case where we failed in the process
        //  of allocating associated Irps and Mdls.
        //

        if (ThisIoRun->SavedIrp != NULL) {

            if (ThisIoRun->SavedIrp->MdlAddress != NULL) {

                IoFreeMdl( ThisIoRun->SavedIrp->MdlAddress );
            }

            IoFreeIrp( ThisIoRun->SavedIrp );
        }

        //
        //  Move to the previous IoRun entry.
        //

        ThisIoRun -= 1;
        RemainingEntries -= 1;
    }

    //
    //  If we copied any data then flush the Io buffers.
    //

    return FlushIoBuffers;
}


//
//  Local support routine
//

VOID
CdMultipleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG RunCount,
    IN PIO_RUN IoRuns
    )

/*++

Routine Description:

    This routine first does the initial setup required of a Master IRP that is
    going to be completed using associated IRPs.  This routine should not
    be used if only one async request is needed, instead the single read
    async routines should be called.

    A context parameter is initialized, to serve as a communications area
    between here and the common completion routine.

    Next this routine reads or writes one or more contiguous sectors from
    a device asynchronously, and is used if there are multiple reads for a
    master IRP.  A completion routine is used to synchronize with the
    completion of all of the I/O requests started by calls to this routine.

    Also, prior to calling this routine the caller must initialize the
    IoStatus field in the Context, with the correct success status and byte
    count which are expected if all of the parallel transfers complete
    successfully.  After return this status will be unchanged if all requests
    were, in fact, successful.  However, if one or more errors occur, the
    IoStatus will be modified to reflect the error status and byte count
    from the first run (by Vbo) which encountered an error.  I/O status
    from all subsequent runs will not be indicated.

Arguments:

    RunCount - Supplies the number of multiple async requests
        that will be issued against the master irp.

    IoRuns - Supplies an array containing the Offset and ByteCount for the
        separate requests.

Return Value:

    None.

--*/

{
    PIO_COMPLETION_ROUTINE CompletionRoutine;
    PIO_STACK_LOCATION IrpSp;
    PMDL Mdl;
    PIRP Irp;
    PIRP MasterIrp;
    ULONG UnwindRunCount;

    PAGED_CODE();

    //
    //  Set up things according to whether this is truely async.
    //

    CompletionRoutine = CdMultiSyncCompletionRoutine;

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

        CompletionRoutine = CdMultiAsyncCompletionRoutine;
    }

    //
    //  Initialize some local variables.
    //

    MasterIrp = IrpContext->Irp;

    //
    //  Itterate through the runs, doing everything that can fail.
    //  We let the cleanup in CdFinishBuffers clean up on error.
    //

    for (UnwindRunCount = 0;
         UnwindRunCount < RunCount;
         UnwindRunCount += 1) {

        //
        //  Create an associated IRP, making sure there is one stack entry for
        //  us, as well.
        //

        IoRuns[UnwindRunCount].SavedIrp =
        Irp = IoMakeAssociatedIrp( MasterIrp, (CCHAR)(IrpContext->Vcb->TargetDeviceObject->StackSize + 1) );

        if (Irp == NULL) {

            IrpContext->Irp->IoStatus.Information = 0;
            CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        //
        // Allocate and build a partial Mdl for the request.
        //

        Mdl = IoAllocateMdl( IoRuns[UnwindRunCount].TransferVirtualAddress,
                             IoRuns[UnwindRunCount].DiskByteCount,
                             FALSE,
                             FALSE,
                             Irp );

        if (Mdl == NULL) {

            IrpContext->Irp->IoStatus.Information = 0;
            CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        IoBuildPartialMdl( IoRuns[UnwindRunCount].TransferMdl,
                           Mdl,
                           IoRuns[UnwindRunCount].TransferVirtualAddress,
                           IoRuns[UnwindRunCount].DiskByteCount );

        //
        //  Get the first IRP stack location in the associated Irp
        //

        IoSetNextIrpStackLocation( Irp );
        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        //  Setup the Stack location to describe our read.
        //

        IrpSp->MajorFunction = IRP_MJ_READ;
        IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].DiskByteCount;
        IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].DiskOffset;

        //
        // Set up the completion routine address in our stack frame.
        //

        IoSetCompletionRoutine( Irp,
                                CompletionRoutine,
                                IrpContext->IoContext,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Setup the next IRP stack location in the associated Irp for the disk
        //  driver beneath us.
        //

        IrpSp = IoGetNextIrpStackLocation( Irp );

        //
        //  Setup the Stack location to do a read from the disk driver.
        //

        IrpSp->MajorFunction = IRP_MJ_READ;
        IrpSp->Parameters.Read.Length = IoRuns[UnwindRunCount].DiskByteCount;
        IrpSp->Parameters.Read.ByteOffset.QuadPart = IoRuns[UnwindRunCount].DiskOffset;
    }

    //
    //  We only need to set the associated IRP count in the master irp to
    //  make it a master IRP.  But we set the count to one more than our
    //  caller requested, because we do not want the I/O system to complete
    //  the I/O.  We also set our own count.
    //

    IrpContext->IoContext->IrpCount = RunCount;
    IrpContext->IoContext->MasterIrp = MasterIrp;

    //
    //  We set the count in the master Irp to 1 since typically we
    //  will clean up the associated irps ourselves.  Setting this to one
    //  means completing the last associated Irp with SUCCESS (in the async
    //  case) will complete the master irp.
    //

    MasterIrp->AssociatedIrp.IrpCount = 1;

    //
    //  Now that all the dangerous work is done, issue the Io requests
    //

    for (UnwindRunCount = 0;
         UnwindRunCount < RunCount;
         UnwindRunCount++) {

        Irp = IoRuns[UnwindRunCount].SavedIrp;
        IoRuns[UnwindRunCount].SavedIrp = NULL;

        //
        //  If IoCallDriver returns an error, it has completed the Irp
        //  and the error will be caught by our completion routines
        //  and dealt with as a normal IO error.
        //

        (VOID) IoCallDriver( IrpContext->Vcb->TargetDeviceObject, Irp );
    }

    return;
}


//
//  Local support routine
//

VOID
CdMultipleXAAsync (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG RunCount,
    IN PIO_RUN IoRuns,
    IN PRAW_READ_INFO RawReads,
    IN TRACK_MODE_TYPE TrackMode
    )

/*++

Routine Description:

    This routine first does the initial setup required of a Master IRP that is
    going to be completed using associated IRPs.  This routine is used to generate
    the associated Irps used to read raw sectors from the disk.

    A context parameter is initialized, to serve as a communications area
    between here and the common completion routine.

    Next this routine reads or writes one or more contiguous sectors from
    a device asynchronously, and is used if there are multiple reads for a
    master IRP.  A completion routine is used to synchronize with the
    completion of all of the I/O requests started by calls to this routine.

    Also, prior to calling this routine the caller must initialize the
    IoStatus field in the Context, with the correct success status and byte
    count which are expected if all of the parallel transfers complete
    successfully.  After return this status will be unchanged if all requests
    were, in fact, successful.  However, if one or more errors occur, the
    IoStatus will be modified to reflect the error status and byte count
    from the first run (by Vbo) which encountered an error.  I/O status
    from all subsequent runs will not be indicated.

Arguments:

    RunCount - Supplies the number of multiple async requests
        that will be issued against the master irp.

    IoRuns - Supplies an array containing the Offset and ByteCount for the
        separate requests.

    RawReads - Supplies an array of structures to store in the Irps passed to the
        device driver to perform the low-level Io.

    TrackMode - Supplies the recording mode of sectors in these IoRuns

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PMDL Mdl;
    PIRP Irp;
    PIRP MasterIrp;
    ULONG UnwindRunCount;
    ULONG RawByteCount;

    PIO_RUN ThisIoRun = IoRuns;
    PRAW_READ_INFO ThisRawRead = RawReads;

    PAGED_CODE();

    //
    //  Initialize some local variables.
    //

    MasterIrp = IrpContext->Irp;

    //
    //  Itterate through the runs, doing everything that can fail.
    //  We let the cleanup in CdFinishBuffers clean up on error.
    //

    for (UnwindRunCount = 0;
         UnwindRunCount < RunCount;
         UnwindRunCount += 1, ThisIoRun += 1, ThisRawRead += 1) {

        //
        //  Create an associated IRP, making sure there is one stack entry for
        //  us, as well.
        //

        ThisIoRun->SavedIrp =
        Irp = IoMakeAssociatedIrp( MasterIrp, (CCHAR)(IrpContext->Vcb->TargetDeviceObject->StackSize + 1) );

        if (Irp == NULL) {

            IrpContext->Irp->IoStatus.Information = 0;
            CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }
        
        //
        //  Should have been passed a byte count of at least one sector, and 
        //  must be a multiple of sector size
        //
        
        ASSERT( ThisIoRun->DiskByteCount && !SectorOffset(ThisIoRun->DiskByteCount));

        RawByteCount = SectorsFromBytes( ThisIoRun->DiskByteCount) * RAW_SECTOR_SIZE;

        //
        // Allocate and build a partial Mdl for the request.
        //

        Mdl = IoAllocateMdl( ThisIoRun->TransferVirtualAddress,
                             RawByteCount,
                             FALSE,
                             FALSE,
                             Irp );

        if (Mdl == NULL) {

            IrpContext->Irp->IoStatus.Information = 0;
            CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        IoBuildPartialMdl( ThisIoRun->TransferMdl,
                           Mdl,
                           ThisIoRun->TransferVirtualAddress,
                           RawByteCount);
        //
        //  Get the first IRP stack location in the associated Irp
        //

        IoSetNextIrpStackLocation( Irp );
        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        //
        //  Setup the Stack location to describe our read (using cooked values)
        //  These values won't be used for the raw read in any case.
        //

        IrpSp->MajorFunction = IRP_MJ_READ;
        IrpSp->Parameters.Read.Length = ThisIoRun->DiskByteCount;
        IrpSp->Parameters.Read.ByteOffset.QuadPart = ThisIoRun->DiskOffset;

        //
        // Set up the completion routine address in our stack frame.
        //

        IoSetCompletionRoutine( Irp,
                                CdMultiSyncCompletionRoutine,
                                IrpContext->IoContext,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Setup the next IRP stack location in the associated Irp for the disk
        //  driver beneath us.
        //

        IrpSp = IoGetNextIrpStackLocation( Irp );

        //
        //  Setup the stack location to do a read of raw sectors at this location.
        //  Note that the storage stack always reads multiples of whole XA sectors.
        //

        ThisRawRead->DiskOffset.QuadPart = ThisIoRun->DiskOffset;
        ThisRawRead->SectorCount = ThisIoRun->DiskByteCount >> SECTOR_SHIFT;
        ThisRawRead->TrackMode = TrackMode;

        IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;

        IrpSp->Parameters.DeviceIoControl.OutputBufferLength = ThisRawRead->SectorCount * RAW_SECTOR_SIZE;
        Irp->UserBuffer = ThisIoRun->TransferVirtualAddress;

        IrpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof( RAW_READ_INFO );
        IrpSp->Parameters.DeviceIoControl.Type3InputBuffer = ThisRawRead;

        IrpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_CDROM_RAW_READ;
    }

    //
    //  We only need to set the associated IRP count in the master irp to
    //  make it a master IRP.  But we set the count to one more than our
    //  caller requested, because we do not want the I/O system to complete
    //  the I/O.  We also set our own count.
    //

    IrpContext->IoContext->IrpCount = RunCount;
    IrpContext->IoContext->MasterIrp = MasterIrp;

    //
    //  We set the count in the master Irp to 1 since typically we
    //  will clean up the associated irps ourselves.  Setting this to one
    //  means completing the last associated Irp with SUCCESS (in the async
    //  case) will complete the master irp.
    //

    MasterIrp->AssociatedIrp.IrpCount = 1;

    //
    //  Now that all the dangerous work is done, issue the Io requests
    //

    for (UnwindRunCount = 0;
         UnwindRunCount < RunCount;
         UnwindRunCount++) {

        Irp = IoRuns[UnwindRunCount].SavedIrp;
        IoRuns[UnwindRunCount].SavedIrp = NULL;

        //
        //
        //  If IoCallDriver returns an error, it has completed the Irp
        //  and the error will be caught by our completion routines
        //  and dealt with as a normal IO error.
        //

        (VOID) IoCallDriver( IrpContext->Vcb->TargetDeviceObject, Irp );
    }

    return;
}


//
//  Local support routine
//

VOID
CdSingleAsync (
    IN PIRP_CONTEXT IrpContext,
    IN LONGLONG ByteOffset,
    IN ULONG ByteCount
    )

/*++

Routine Description:

    This routine reads one or more contiguous sectors from a device
    asynchronously, and is used if there is only one read necessary to
    complete the IRP.  It implements the read by simply filling
    in the next stack frame in the Irp, and passing it on.  The transfer
    occurs to the single buffer originally specified in the user request.

Arguments:

    ByteOffset - Supplies the starting Logical Byte Offset to begin reading from

    ByteCount - Supplies the number of bytes to read from the device

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PIO_COMPLETION_ROUTINE CompletionRoutine;

    PAGED_CODE();

    //
    //  Set up things according to whether this is truely async.
    //

    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

        CompletionRoutine = CdSingleSyncCompletionRoutine;

    } else {

        CompletionRoutine = CdSingleAsyncCompletionRoutine;
    }

    //
    // Set up the completion routine address in our stack frame.
    //

    IoSetCompletionRoutine( IrpContext->Irp,
                            CompletionRoutine,
                            IrpContext->IoContext,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Setup the next IRP stack location in the associated Irp for the disk
    //  driver beneath us.
    //

    IrpSp = IoGetNextIrpStackLocation( IrpContext->Irp );

    //
    //  Setup the Stack location to do a read from the disk driver.
    //

    IrpSp->MajorFunction = IRP_MJ_READ;
    IrpSp->Parameters.Read.Length = ByteCount;
    IrpSp->Parameters.Read.ByteOffset.QuadPart = ByteOffset;

    //
    //  Issue the Io request
    //

    //
    //  If IoCallDriver returns an error, it has completed the Irp
    //  and the error will be caught by our completion routines
    //  and dealt with as a normal IO error.
    //

    (VOID)IoCallDriver( IrpContext->Vcb->TargetDeviceObject, IrpContext->Irp );

    //
    //  And return to our caller
    //

    return;
}


//
//  Local support routine
//

VOID
CdWaitSync (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine waits for one or more previously started I/O requests
    from the above routines, by simply waiting on the event.

Arguments:

Return Value:

    None

--*/

{
    PAGED_CODE();

    KeWaitForSingleObject( &IrpContext->IoContext->SyncEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL );

    KeClearEvent( &IrpContext->IoContext->SyncEvent );

    return;
}


//
//  Local support routine
//

NTSTATUS
CdMultiSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all synchronous reads
    started via CdMultipleAsynch.

    The completion routine has has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        and remember the error status in the Context.

        If the IrpCount goes to 1, then it sets the event in the Context
        parameter to signal the caller that all of the asynch requests
        are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
        Irp will no longer be accessible after this routine returns.)

    Context - The context parameter which was specified for all of
        the multiple asynch I/O requests for this MasterIrp.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{
    PCD_IO_CONTEXT IoContext = Context;

    AssertVerifyDeviceIrp( Irp );

    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        InterlockedExchange( &IoContext->Status, Irp->IoStatus.Status );
        IoContext->MasterIrp->IoStatus.Information = 0;
    }

    //
    //  We must do this here since IoCompleteRequest won't get a chance
    //  on this associated Irp.
    //

    IoFreeMdl( Irp->MdlAddress );
    IoFreeIrp( Irp );

    if (InterlockedDecrement( &IoContext->IrpCount ) == 0) {

        //
        //  Update the Master Irp with any error status from the associated Irps.
        //

        IoContext->MasterIrp->IoStatus.Status = IoContext->Status;
        KeSetEvent( &IoContext->SyncEvent, 0, FALSE );
    }

    UNREFERENCED_PARAMETER( DeviceObject );

    return STATUS_MORE_PROCESSING_REQUIRED;
}


//
//  Local support routine
//

NTSTATUS
CdMultiAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all asynchronous reads
    started via CdMultipleAsynch.

    The completion routine has has the following responsibilities:

        If the individual request was completed with an error, then
        this completion routine must see if this is the first error
        and remember the error status in the Context.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the associated Irp which is being completed.  (This
        Irp will no longer be accessible after this routine returns.)

    Context - The context parameter which was specified for all of
             the multiple asynch I/O requests for this MasterIrp.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{
    PCD_IO_CONTEXT IoContext = Context;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    AssertVerifyDeviceIrp( Irp );
    
    //
    //  If we got an error (or verify required), remember it in the Irp
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        InterlockedExchange( &IoContext->Status, Irp->IoStatus.Status );
    }

    //
    //  Decrement IrpCount and see if it goes to zero.
    //

    if (InterlockedDecrement( &IoContext->IrpCount ) == 0) {

        //
        //  Mark the master Irp pending
        //

        IoMarkIrpPending( IoContext->MasterIrp );

        //
        //  Update the Master Irp with any error status from the associated Irps.
        //

        IoContext->MasterIrp->IoStatus.Status = IoContext->Status;

        //
        //  Update the information field with the correct value.
        //

        IoContext->MasterIrp->IoStatus.Information = 0;

        if (NT_SUCCESS( IoContext->MasterIrp->IoStatus.Status )) {

            IoContext->MasterIrp->IoStatus.Information = IoContext->RequestedByteCount;
        }

        //
        //  Now release the resource
        //

        ExReleaseResourceForThreadLite( IoContext->Resource,
                                    IoContext->ResourceThreadId );

        //
        //  and finally, free the context record.
        //

        CdFreeIoContext( IoContext );

        //
        //  Return success in this case.
        //

        return STATUS_SUCCESS;

    } else {

        //
        //  We need to cleanup the associated Irp and its Mdl.
        //

        IoFreeMdl( Irp->MdlAddress );
        IoFreeIrp( Irp );

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine
//

NTSTATUS
CdSingleSyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all reads started via CdSingleAsynch.

    The completion routine has has the following responsibilities:

        It sets the event in the Context parameter to signal the caller
        that all of the asynch requests are done.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
        be accessible after this routine returns.)

    Context - The context parameter which was specified in the call to
        CdSingleAsynch.

Return Value:

    The routine returns STATUS_MORE_PROCESSING_REQUIRED so that we can
    immediately complete the Master Irp without being in a race condition
    with the IoCompleteRequest thread trying to decrement the IrpCount in
    the Master Irp.

--*/

{
    AssertVerifyDeviceIrp( Irp );
    
    //
    //  Store the correct information field into the Irp.
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        Irp->IoStatus.Information = 0;
    }

    KeSetEvent( &((PCD_IO_CONTEXT)Context)->SyncEvent, 0, FALSE );

    return STATUS_MORE_PROCESSING_REQUIRED;
}


//
//  Local support routine
//

NTSTATUS
CdSingleAsyncCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This is the completion routine for all asynchronous reads
    started via CdSingleAsynch.

Arguments:

    DeviceObject - Pointer to the file system device object.

    Irp - Pointer to the Irp for this request.  (This Irp will no longer
        be accessible after this routine returns.)

    Context - The context parameter which was specified in the call to
        CdSingleAsynch.

Return Value:

    Currently always returns STATUS_SUCCESS.

--*/

{
    AssertVerifyDeviceIrp( Irp );
    
    //
    //  Update the information field with the correct value for bytes read.
    //

    Irp->IoStatus.Information = 0;

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        Irp->IoStatus.Information = ((PCD_IO_CONTEXT) Context)->RequestedByteCount;
    }

    //
    //  Mark the Irp pending
    //

    IoMarkIrpPending( Irp );

    //
    //  Now release the resource
    //

    ExReleaseResourceForThreadLite( ((PCD_IO_CONTEXT) Context)->Resource,
                                ((PCD_IO_CONTEXT) Context)->ResourceThreadId );

    //
    //  and finally, free the context record.
    //

    CdFreeIoContext( (PCD_IO_CONTEXT) Context );
    return STATUS_SUCCESS;

    UNREFERENCED_PARAMETER( DeviceObject );
}


//
//  Local support routine
//

VOID
CdReadAudioSystemFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG StartingOffset,
    IN ULONG ByteCount,
    IN PVOID SystemBuffer
    )

/*++

Routine Description:

    This routine is called to read the pseudo root directory and path
    table for a music disk.  We build the individual elements on the
    stack and copy into the cache buffer.

Arguments:

    Fcb - Fcb representing the file to read.

    StartingOffset - Logical offset in the file to read from.

    ByteCount - Number of bytes to read.

    SystemBuffer - Pointer to buffer to fill in.  This will always be page
        aligned.

Return Value:

    None.

--*/

{
    PRAW_PATH_ISO RawPath;
    PRAW_DIRENT RawDirent;

    ULONG CurrentTrack;
    ULONG SectorOffset;
    ULONG EntryCount;
    UCHAR TrackOnes;
    UCHAR TrackTens;
    PTRACK_DATA ThisTrack;

    LONGLONG CurrentOffset;

    PVOID CurrentSector;

    PSYSTEM_USE_XA SystemUse;

    ULONG BytesToCopy;

    UCHAR LocalBuffer[FIELD_OFFSET( RAW_DIRENT, FileId ) + 12];

    PAGED_CODE();

    //
    //  If this is the path table then we just need a single entry.
    //

    if (SafeNodeType( Fcb ) == CDFS_NTC_FCB_PATH_TABLE) {

        //
        //  Sanity check that the offset is zero.
        //

        ASSERT( StartingOffset == 0 );

        //
        //  Store a pseudo path entry in our local buffer.
        //

        RawPath = (PRAW_PATH_ISO) LocalBuffer;

        RtlZeroMemory( RawPath, sizeof( LocalBuffer ));

        RawPath->DirIdLen = 1;
        RawPath->ParentNum = 1;
        RawPath->DirId[0] = '\0';

        //
        //  Now copy to the user's buffer.
        //

        BytesToCopy = FIELD_OFFSET( RAW_PATH_ISO, DirId ) + 2;

        if (BytesToCopy > ByteCount) {

            BytesToCopy = ByteCount;
        }

        RtlCopyMemory( SystemBuffer,
                       RawPath,
                       BytesToCopy );

    //
    //  We need to deal with the multiple sector case for the root directory.
    //

    } else {

        //
        //  Initialize the first track to return to our caller.
        //

        CurrentTrack = 0;

        //
        //  If the offset is zero then store the entries for the self and parent
        //  entries.
        //

        if (StartingOffset == 0) {

            RawDirent = SystemBuffer;

            //
            //  Clear all of the fields initially.
            //

            RtlZeroMemory( RawDirent, FIELD_OFFSET( RAW_DIRENT, FileId ));

            //
            //  Now fill in the interesting fields.
            //

            RawDirent->DirLen = FIELD_OFFSET( RAW_DIRENT, FileId ) + 1;
            RawDirent->FileIdLen = 1;
            RawDirent->FileId[0] = '\0';
            SetFlag( RawDirent->FlagsISO, CD_ATTRIBUTE_DIRECTORY );

            //
            //  Set the time stamp to be Jan 1, 1995
            //

            RawDirent->RecordTime[0] = 95;
            RawDirent->RecordTime[1] = 1;
            RawDirent->RecordTime[2] = 1;

            SectorOffset = RawDirent->DirLen;

            RawDirent = Add2Ptr( RawDirent, SectorOffset, PRAW_DIRENT );

            //
            //  Clear all of the fields initially.
            //

            RtlZeroMemory( RawDirent, FIELD_OFFSET( RAW_DIRENT, FileId ));

            //
            //  Now fill in the interesting fields.
            //

            RawDirent->DirLen = FIELD_OFFSET( RAW_DIRENT, FileId ) + 1;
            RawDirent->FileIdLen = 1;
            RawDirent->FileId[0] = '\1';
            SetFlag( RawDirent->FlagsISO, CD_ATTRIBUTE_DIRECTORY );

            //
            //  Set the time stamp to be Jan 1, 1995
            //

            RawDirent->RecordTime[0] = 95;
            RawDirent->RecordTime[1] = 1;
            RawDirent->RecordTime[2] = 1;

            SectorOffset += RawDirent->DirLen;
            EntryCount = 2;

        //
        //  Otherwise compute the starting track to write to the buffer.
        //

        } else {

            //
            //  Count the tracks in each preceding sector.
            //

            CurrentOffset = 0;

            do {

                CurrentTrack += CdAudioDirentsPerSector;
                CurrentOffset += SECTOR_SIZE;

            } while (CurrentOffset < StartingOffset);

            //
            //  Bias the track count to reflect the two default entries.
            //

            CurrentTrack -= 2;

            SectorOffset = 0;
            EntryCount = 0;
        }

        //
        //  We now know the first track to return as well as where we are in
        //  the current sector.  We will walk through sector by sector adding
        //  the entries for the separate tracks in the TOC.  We will zero
        //  any sectors or partial sectors without data.
        //

        CurrentSector = SystemBuffer;
        BytesToCopy = SECTOR_SIZE;

        //
        //  Loop for each sector.
        //

        do {

            //
            //  Add entries until we reach our threshold for each sector.
            //

            do {

                //
                //  If we are beyond the entries in the TOC then exit.
                //

                if (CurrentTrack >= IrpContext->Vcb->TrackCount) {

                    break;
                }

                ThisTrack = &IrpContext->Vcb->CdromToc->TrackData[CurrentTrack];

                //
                //  Point to the current position in the buffer.
                //

                RawDirent = Add2Ptr( CurrentSector, SectorOffset, PRAW_DIRENT );

                //
                //  Clear all of the fields initially.
                //

                RtlZeroMemory( RawDirent, CdAudioDirentSize );

                //
                //  Now fill in the interesting fields.
                //

                RawDirent->DirLen = (UCHAR) CdAudioDirentSize;
                RawDirent->FileIdLen = CdAudioFileNameLength;

                RtlCopyMemory( RawDirent->FileId,
                               CdAudioFileName,
                               CdAudioFileNameLength );

                //
                //  Set the time stamp to be Jan 1, 1995
                //

                RawDirent->RecordTime[0] = 95;
                RawDirent->RecordTime[1] = 1;
                RawDirent->RecordTime[2] = 1;

                //
                //  Now bias by the values in the TOC.
                //

                RawDirent->RecordTime[4] = ThisTrack->Address[1] % 60;
                RawDirent->RecordTime[5] = ThisTrack->Address[2] % 60;

                //
                //  Put the track number into the file name.
                //

                TrackTens = TrackOnes = ThisTrack->TrackNumber;

                TrackOnes = (TrackOnes % 10) + '0';

                TrackTens /= 10;
                TrackTens = (TrackTens % 10) + '0';

                RawDirent->FileId[AUDIO_NAME_TENS_OFFSET] = TrackTens;
                RawDirent->FileId[AUDIO_NAME_ONES_OFFSET] = TrackOnes;

                SystemUse = Add2Ptr( RawDirent, CdAudioSystemUseOffset, PSYSTEM_USE_XA );

                SystemUse->Attributes = SYSTEM_USE_XA_DA;
                SystemUse->Signature = SYSTEM_XA_SIGNATURE;

                //
                //  Store the track number as the file number.
                //

                SystemUse->FileNumber = (UCHAR) CurrentTrack;

                EntryCount += 1;
                SectorOffset += CdAudioDirentSize;
                CurrentTrack += 1;

            } while (EntryCount < CdAudioDirentsPerSector);

            //
            //  Zero the remaining portion of this buffer.
            //

            RtlZeroMemory( Add2Ptr( CurrentSector, SectorOffset, PVOID ),
                           SECTOR_SIZE - SectorOffset );

            //
            //  Prepare for the next sector.
            //

            EntryCount = 0;
            BytesToCopy += SECTOR_SIZE;
            SectorOffset = 0;
            CurrentSector = Add2Ptr( CurrentSector, SECTOR_SIZE, PVOID );

        } while (BytesToCopy <= ByteCount);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\filobsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FilObSup.c

Abstract:

    This module implements the Cdfs File object support routines.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_FILOBSUP)

//
//  Local constants.
//

#define TYPE_OF_OPEN_MASK               (0x00000007)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdDecodeFileObject)
#pragma alloc_text(PAGE, CdFastDecodeFileObject)
#pragma alloc_text(PAGE, CdSetFileObject)
#endif


VOID
CdSetFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN PFCB Fcb OPTIONAL,
    IN PCCB Ccb OPTIONAL
    )

/*++

Routine Description:

    This routine will initialize the FileObject context fields based on the
    input type and data structures.

Arguments:

    FileObject - Supplies the file object pointer being initialized.

    TypeOfOpen - Sets the type of open.

    Fcb - Fcb for this file object.  Ignored for UnopenedFileObject.

    Ccb - Ccb for the handle corresponding to this file object.  Will not
        be present for stream file objects.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  We only have values 0 to 7 available so make sure we didn't
    //  inadvertantly add a new type.
    //

    ASSERTMSG( "FileObject types exceed available bits\n", BeyondValidType <= 8 );

    //
    //  Setting a file object to type UnopenedFileObject means just
    //  clearing all of the context fields.  All the other input
    //

    if (TypeOfOpen == UnopenedFileObject) {

        FileObject->FsContext =
        FileObject->FsContext2 = NULL;

        return;
    }

    //
    //  Check that the 3 low-order bits of the Ccb are clear.
    //

    ASSERTMSG( "Ccb is not quad-aligned\n", !FlagOn( ((ULONG_PTR) Ccb), TYPE_OF_OPEN_MASK ));

    //
    //  We will or the type of open into the low order bits of FsContext2
    //  along with the Ccb value.
    //  The Fcb is stored into the FsContext field.
    //

    FileObject->FsContext = Fcb;
    FileObject->FsContext2 = Ccb;

    SetFlag( ((ULONG_PTR) FileObject->FsContext2), TypeOfOpen );

    //
    //  Set the Vpb field in the file object.
    //

    FileObject->Vpb = Fcb->Vcb->Vpb;

    return;
}



TYPE_OF_OPEN
CdDecodeFileObject (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb,
    OUT PCCB *Ccb
    )

/*++

Routine Description:

    This routine takes a file object and extracts the Fcb and Ccb (possibly NULL)
    and returns the type of open.

Arguments:

    FileObject - Supplies the file object pointer being initialized.

    Fcb - Address to store the Fcb contained in the file object.

    Ccb - Address to store the Ccb contained in the file object.

Return Value:

    TYPE_OF_OPEN - Indicates the type of file object.

--*/

{
    TYPE_OF_OPEN TypeOfOpen;

    PAGED_CODE();

    //
    //  If this is an unopened file object then return NULL for the
    //  Fcb/Ccb.  Don't trust any other values in the file object.
    //

    TypeOfOpen = (TYPE_OF_OPEN) FlagOn( (ULONG_PTR) FileObject->FsContext2,
                                        TYPE_OF_OPEN_MASK );

    if (TypeOfOpen == UnopenedFileObject) {

        *Fcb = NULL;
        *Ccb = NULL;

    } else {

        //
        //  The Fcb is pointed to by the FsContext field.  The Ccb is in
        //  FsContext2 (after clearing the low three bits).  The low three
        //  bits are the file object type.
        //

        *Fcb = FileObject->FsContext;
        *Ccb = FileObject->FsContext2;

        ClearFlag( (ULONG_PTR) *Ccb, TYPE_OF_OPEN_MASK );
    }

    //
    //  Now return the type of open.
    //

    return TypeOfOpen;
}


TYPE_OF_OPEN
CdFastDecodeFileObject (
    IN PFILE_OBJECT FileObject,
    OUT PFCB *Fcb
    )

/*++

Routine Description:

    This procedure takes a pointer to a file object, that has already been
    opened by Cdfs and does a quick decode operation.  It will only return
    a non null value if the file object is a user file open

Arguments:

    FileObject - Supplies the file object pointer being interrogated

    Fcb - Address to store Fcb if this is a user file object.  NULL
        otherwise.

Return Value:

    TYPE_OF_OPEN - type of open of this file object.

--*/

{
    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    //
    //  The Fcb is in the FsContext field.  The type of open is in the low
    //  bits of the Ccb.
    //

    *Fcb = FileObject->FsContext;

    return (TYPE_OF_OPEN)
            FlagOn( (ULONG_PTR) FileObject->FsContext2, TYPE_OF_OPEN_MASK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\fsctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FsCtrl.c

Abstract:

    This module implements the File System Control routines for Cdfs called
    by the Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_FSCTRL)

//
//  Local constants
//

BOOLEAN CdDisable = FALSE;
BOOLEAN CdNoJoliet = FALSE;

//
//  Local support routines
//

NTSTATUS
CdUserFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
CdReMountOldVcb(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB OldVcb,
    IN PVCB NewVcb,
    IN PDEVICE_OBJECT DeviceObjectWeTalkTo
    );

NTSTATUS
CdMountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdVerifyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdLockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdUnlockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdDismountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

CdIsVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdIsVolumeMounted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdIsPathnameValid (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

NTSTATUS
CdInvalidateVolumes (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

VOID
CdScanForDismountedVcb (
    IN PIRP_CONTEXT IrpContext
    );

BOOLEAN
CdFindPrimaryVd (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PCHAR RawIsoVd,
    IN ULONG BlockFactor,
    IN BOOLEAN ReturnOnError,
    IN BOOLEAN VerifyVolume
    );

BOOLEAN
CdIsRemount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PVCB *OldVcb
    );

VOID
CdFindActiveVolDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PCHAR RawIsoVd,
    IN BOOLEAN VerifyVolume
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonFsControl)
#pragma alloc_text(PAGE, CdDismountVolume)
#pragma alloc_text(PAGE, CdFindActiveVolDescriptor)
#pragma alloc_text(PAGE, CdFindPrimaryVd)
#pragma alloc_text(PAGE, CdIsPathnameValid)
#pragma alloc_text(PAGE, CdIsRemount)
#pragma alloc_text(PAGE, CdIsVolumeDirty)
#pragma alloc_text(PAGE, CdIsVolumeMounted)
#pragma alloc_text(PAGE, CdLockVolume)
#pragma alloc_text(PAGE, CdMountVolume)
#pragma alloc_text(PAGE, CdOplockRequest)
#pragma alloc_text(PAGE, CdScanForDismountedVcb)
#pragma alloc_text(PAGE, CdUnlockVolume)
#pragma alloc_text(PAGE, CdUserFsctl)
#pragma alloc_text(PAGE, CdVerifyVolume)
#endif


//
//  Local support routine
//

NTSTATUS
CdLockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    )

/*++

Routine Description:

    This routine performs the actual lock volume operation.  It will be called
    by anyone wishing to try to protect the volume for a long duration.  PNP
    operations are such a user.
    
    The volume must be held exclusive by the caller.

Arguments:

    Vcb - The volume being locked.
    
    FileObject - File corresponding to the handle locking the volume.  If this
        is not specified, a system lock is assumed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KIRQL SavedIrql;
    NTSTATUS FinalStatus = (FileObject? STATUS_ACCESS_DENIED: STATUS_DEVICE_BUSY);
    ULONG RemainingUserReferences = (FileObject? 1: 0);

    //
    //  The cleanup count for the volume only reflects the fileobject that
    //  will lock the volume.  Otherwise, we must fail the request.
    //
    //  Since the only cleanup is for the provided fileobject, we will try
    //  to get rid of all of the other user references.  If there is only one
    //  remaining after the purge then we can allow the volume to be locked.
    //
    
    CdPurgeVolume( IrpContext, Vcb, FALSE );

    //
    //  Now back out of our synchronization and wait for the lazy writer
    //  to finish off any lazy closes that could have been outstanding.
    //
    //  Since we purged, we know that the lazy writer will issue all
    //  possible lazy closes in the next tick - if we hadn't, an otherwise
    //  unopened file with a large amount of dirty data could have hung
    //  around for a while as the data trickled out to the disk.
    //
    //  This is even more important now since we send notification to
    //  alert other folks that this style of check is about to happen so
    //  that they can close their handles.  We don't want to enter a fast
    //  race with the lazy writer tearing down his references to the file.
    //

    CdReleaseVcb( IrpContext, Vcb );

    Status = CcWaitForCurrentLazyWriterActivity();

    //
    //  This is intentional. If we were able to get the Vcb before, just
    //  wait for it and take advantage of knowing that it is OK to leave
    //  the flag up.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );
    
    if (!NT_SUCCESS( Status )) {

        return Status;
    }

    CdFspClose( Vcb );

    //
    //  If the volume is already explicitly locked then fail.  We use the
    //  Vpb locked flag as an 'explicit lock' flag in the same way as Fat.
    //

    IoAcquireVpbSpinLock( &SavedIrql ); 
        
    if (!FlagOn( Vcb->Vpb->Flags, VPB_LOCKED ) && 
        (Vcb->VcbCleanup == RemainingUserReferences) &&
        (Vcb->VcbUserReference == CDFS_RESIDUAL_USER_REFERENCE + RemainingUserReferences))  {

        SetFlag( Vcb->VcbState, VCB_STATE_LOCKED );
        SetFlag( Vcb->Vpb->Flags, VPB_LOCKED);
        Vcb->VolumeLockFileObject = FileObject;
        FinalStatus = STATUS_SUCCESS;
    }
    
    IoReleaseVpbSpinLock( SavedIrql );  
    
    return FinalStatus;
}


NTSTATUS
CdUnlockVolumeInternal (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject OPTIONAL
    )

/*++

Routine Description:

    This routine performs the actual unlock volume operation. 
    
    The volume must be held exclusive by the caller.

Arguments:

    Vcb - The volume being locked.
    
    FileObject - File corresponding to the handle locking the volume.  If this
        is not specified, a system lock is assumed.

Return Value:

    NTSTATUS - The return status for the operation
    
    Attempting to remove a system lock that did not exist is OK.

--*/

{
    NTSTATUS Status = STATUS_NOT_LOCKED;
    KIRQL SavedIrql;

    //
    //  Note that we check the VPB_LOCKED flag here rather than the Vcb
    //  lock flag.  The Vpb flag is only set for an explicit lock request,  not
    //  for the implicit lock obtained on a volume open with zero share mode.
    //
    
    IoAcquireVpbSpinLock( &SavedIrql ); 
 
    if (FlagOn(Vcb->Vpb->Flags, VPB_LOCKED) && 
        (FileObject == Vcb->VolumeLockFileObject))  {

        ClearFlag( Vcb->VcbState, VCB_STATE_LOCKED );
        ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED);
        Vcb->VolumeLockFileObject = NULL;
        Status = STATUS_SUCCESS;
    }
    
    IoReleaseVpbSpinLock( SavedIrql );  

    return Status;
}


NTSTATUS
CdCommonFsControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing FileSystem control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get a pointer to the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  We know this is a file system control so we'll case on the
    //  minor function, and call a internal worker routine to complete
    //  the irp.
    //

    switch (IrpSp->MinorFunction) {

    case IRP_MN_USER_FS_REQUEST:

        Status = CdUserFsctl( IrpContext, Irp );
        break;

    case IRP_MN_MOUNT_VOLUME:

        Status = CdMountVolume( IrpContext, Irp );
        break;

    case IRP_MN_VERIFY_VOLUME:

        Status = CdVerifyVolume( IrpContext, Irp );
        break;

    default:

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdUserFsctl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the common routine for implementing the user's requests made
    through NtFsControlFile.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  Case on the control code.
    //

    switch ( IrpSp->Parameters.FileSystemControl.FsControlCode ) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1 :
    case FSCTL_REQUEST_OPLOCK_LEVEL_2 :
    case FSCTL_REQUEST_BATCH_OPLOCK :
    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE :
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING :
    case FSCTL_OPLOCK_BREAK_NOTIFY :
    case FSCTL_OPLOCK_BREAK_ACK_NO_2 :
    case FSCTL_REQUEST_FILTER_OPLOCK :

        Status = CdOplockRequest( IrpContext, Irp );
        break;

    case FSCTL_LOCK_VOLUME :

        Status = CdLockVolume( IrpContext, Irp );
        break;

    case FSCTL_UNLOCK_VOLUME :

        Status = CdUnlockVolume( IrpContext, Irp );
        break;

    case FSCTL_DISMOUNT_VOLUME :

        Status = CdDismountVolume( IrpContext, Irp );
        break;

    case FSCTL_IS_VOLUME_DIRTY :

        Status = CdIsVolumeDirty( IrpContext, Irp );
        break;

    case FSCTL_IS_VOLUME_MOUNTED :

        Status = CdIsVolumeMounted( IrpContext, Irp );
        break;

    case FSCTL_IS_PATHNAME_VALID :

        Status = CdIsPathnameValid( IrpContext, Irp );
        break;

    case FSCTL_INVALIDATE_VOLUMES :

        Status = CdInvalidateVolumes( IrpContext, Irp );
        break;


    //
    //  We don't support any of the known or unknown requests.
    //

    default:

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        Status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    return Status;
}


VOID
CdReMountOldVcb(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB OldVcb,
    IN PVCB NewVcb,
    IN PDEVICE_OBJECT DeviceObjectWeTalkTo
    )
{
    KIRQL SavedIrql;
    
    ObDereferenceObject( OldVcb->TargetDeviceObject );

    IoAcquireVpbSpinLock( &SavedIrql );

    NewVcb->Vpb->RealDevice->Vpb = OldVcb->Vpb;
    
    OldVcb->Vpb->RealDevice = NewVcb->Vpb->RealDevice;
    OldVcb->TargetDeviceObject = DeviceObjectWeTalkTo;
    
    CdUpdateVcbCondition( OldVcb, VcbMounted);
    CdUpdateMediaChangeCount( OldVcb, NewVcb->MediaChangeCount);

    ClearFlag( OldVcb->VcbState, VCB_STATE_VPB_NOT_ON_DEVICE);

    IoReleaseVpbSpinLock( SavedIrql );
}


//
//  Local support routine
//

NTSTATUS
CdMountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the mount volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

    Its job is to verify that the volume denoted in the IRP is a Cdrom volume,
    and create the VCB and root DCB structures.  The algorithm it
    uses is essentially as follows:

    1. Create a new Vcb Structure, and initialize it enough to do I/O
       through the on-disk volume descriptors.

    2. Read the disk and check if it is a Cdrom volume.

    3. If it is not a Cdrom volume then delete the Vcb and
       complete the IRP back with an appropriate status.

    4. Check if the volume was previously mounted and if it was then do a
       remount operation.  This involves deleting the VCB, hook in the
       old VCB, and complete the IRP.

    5. Otherwise create a Vcb and root DCB for each valid volume descriptor.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PVOLUME_DEVICE_OBJECT VolDo = NULL;
    PVCB Vcb = NULL;
    PVCB OldVcb;
    
    BOOLEAN FoundPvd = FALSE;
    BOOLEAN SetDoVerifyOnFail;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_OBJECT DeviceObjectWeTalkTo = IrpSp->Parameters.MountVolume.DeviceObject;
    PVPB Vpb = IrpSp->Parameters.MountVolume.Vpb;

    PFILE_OBJECT FileObjectToNotify = NULL;

    ULONG BlockFactor;
    DISK_GEOMETRY DiskGeometry;

    IO_SCSI_CAPABILITIES Capabilities;

    IO_STATUS_BLOCK Iosb;

    PCHAR RawIsoVd = NULL;

    PCDROM_TOC CdromToc = NULL;
    ULONG TocLength = 0;
    ULONG TocTrackCount = 0;
    ULONG TocDiskFlags = 0;
    ULONG MediaChangeCount = 0;

    PAGED_CODE();

    //
    //  Check that we are talking to a Cdrom device.  This request should
    //  always be waitable.
    //

    ASSERT( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM );
    ASSERT( FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT ));

    //
    //  Update the real device in the IrpContext from the Vpb.  There was no available
    //  file object when the IrpContext was created.
    //

    IrpContext->RealDevice = Vpb->RealDevice;

    SetDoVerifyOnFail = CdRealDevNeedsVerify( IrpContext->RealDevice);

    //
    //  Check if we have disabled the mount process.
    //

    if (CdDisable) {

        CdCompleteRequest( IrpContext, Irp, STATUS_UNRECOGNIZED_VOLUME );
        return STATUS_UNRECOGNIZED_VOLUME;
    }

    //
    //  Do a CheckVerify here to lift the MediaChange ticker from the driver
    //

    Status = CdPerformDevIoCtrl( IrpContext,
                                 IOCTL_CDROM_CHECK_VERIFY,
                                 DeviceObjectWeTalkTo,
                                 &MediaChangeCount,
                                 sizeof(ULONG),
                                 FALSE,
                                 TRUE,
                                 &Iosb );

    if (!NT_SUCCESS( Status )) {
        
        CdCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }
    
    if (Iosb.Information != sizeof(ULONG)) {

        //
        //  Be safe about the count in case the driver didn't fill it in
        //

        MediaChangeCount = 0;
    }

    //
    //  Now let's make Jeff delirious and call to get the disk geometry.  This
    //  will fix the case where the first change line is swallowed.
    //

    Status = CdPerformDevIoCtrl( IrpContext,
                                 IOCTL_CDROM_GET_DRIVE_GEOMETRY,
                                 DeviceObjectWeTalkTo,
                                 &DiskGeometry,
                                 sizeof( DISK_GEOMETRY ),
                                 FALSE,
                                 TRUE,
                                 NULL );

    //
    //  Return insufficient sources to our caller.
    //

    if (Status == STATUS_INSUFFICIENT_RESOURCES) {

        CdCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Now check the block factor for addressing the volume descriptors.
    //  If the call for the disk geometry failed then assume there is one
    //  block per sector.
    //

    BlockFactor = 1;

    if (NT_SUCCESS( Status ) &&
        (DiskGeometry.BytesPerSector != 0) &&
        (DiskGeometry.BytesPerSector < SECTOR_SIZE)) {

        BlockFactor = SECTOR_SIZE / DiskGeometry.BytesPerSector;
    }

    //
    //  Acquire the global resource to do mount operations.
    //

    CdAcquireCdData( IrpContext );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Allocate a buffer to query the TOC.
        //

        CdromToc = FsRtlAllocatePoolWithTag( CdPagedPool,
                                             sizeof( CDROM_TOC ),
                                             TAG_CDROM_TOC );

        RtlZeroMemory( CdromToc, sizeof( CDROM_TOC ));

        //
        //  Do a quick check to see if there any Vcb's which can be removed.
        //

        CdScanForDismountedVcb( IrpContext );

        //
        //  Get our device object and alignment requirement.
        //

        Status = IoCreateDevice( CdData.DriverObject,
                                 sizeof( VOLUME_DEVICE_OBJECT ) - sizeof( DEVICE_OBJECT ),
                                 NULL,
                                 FILE_DEVICE_CD_ROM_FILE_SYSTEM,
                                 0,
                                 FALSE,
                                 (PDEVICE_OBJECT *) &VolDo );

        if (!NT_SUCCESS( Status )) { try_leave( Status ); }

        //
        //  Our alignment requirement is the larger of the processor alignment requirement
        //  already in the volume device object and that in the DeviceObjectWeTalkTo
        //

        if (DeviceObjectWeTalkTo->AlignmentRequirement > VolDo->DeviceObject.AlignmentRequirement) {

            VolDo->DeviceObject.AlignmentRequirement = DeviceObjectWeTalkTo->AlignmentRequirement;
        }

        //
        //  We must initialize the stack size in our device object before
        //  the following reads, because the I/O system has not done it yet.
        //

        ((PDEVICE_OBJECT) VolDo)->StackSize = (CCHAR) (DeviceObjectWeTalkTo->StackSize + 1);

        ClearFlag( VolDo->DeviceObject.Flags, DO_DEVICE_INITIALIZING );

        //
        //  Initialize the overflow queue for the volume
        //

        VolDo->OverflowQueueCount = 0;
        InitializeListHead( &VolDo->OverflowQueue );

        VolDo->PostedRequestCount = 0;
        KeInitializeSpinLock( &VolDo->OverflowQueueSpinLock );

        //
        //  Let's query for the Toc now and handle any error we get from this operation.
        //

        Status = CdProcessToc( IrpContext,
                               DeviceObjectWeTalkTo,
                               CdromToc,
                               &TocLength,
                               &TocTrackCount,
                               &TocDiskFlags );

        //
        //  If we failed to read the TOC, then bail out.  Probably blank media.
        //

        if (Status != STATUS_SUCCESS)  { 

            try_leave( Status ); 
        }

        //
        //  Now before we can initialize the Vcb we need to set up the
        //  device object field in the VPB to point to our new volume device
        //  object.
        //

        Vpb->DeviceObject = (PDEVICE_OBJECT) VolDo;

        //
        //  Initialize the Vcb.  This routine will raise on an allocation
        //  failure.
        //

        CdInitializeVcb( IrpContext,
                         &VolDo->Vcb,
                         DeviceObjectWeTalkTo,
                         Vpb,
                         CdromToc,
                         TocLength,
                         TocTrackCount,
                         TocDiskFlags,
                         BlockFactor,
                         MediaChangeCount );

        //
        //  Show that we initialized the Vcb and can cleanup with the Vcb.
        //

        Vcb = &VolDo->Vcb;
        VolDo = NULL;
        Vpb = NULL;
        CdromToc = NULL;

        //
        //  Store the Vcb in the IrpContext as we didn't have one before.
        //

        IrpContext->Vcb = Vcb;

        CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

        //
        //  Let's reference the Vpb to make sure we are the one to
        //  have the last dereference.
        //

        Vcb->Vpb->ReferenceCount += 1;

        //
        //  Clear the verify bit for the start of mount.
        //

        CdMarkRealDevVerifyOk( Vcb->Vpb->RealDevice);

        if (!FlagOn( Vcb->VcbState, VCB_STATE_AUDIO_DISK))  {
            
            //
            //  Allocate a buffer to read in the volume descriptors.  We allocate a full
            //  page to make sure we don't hit any alignment problems.
            //

            RawIsoVd = FsRtlAllocatePoolWithTag( CdNonPagedPool,
                                                 ROUND_TO_PAGES( SECTOR_SIZE ),
                                                 TAG_VOL_DESC );

            //
            //  Try to find the primary volume descriptor.
            //

            FoundPvd = CdFindPrimaryVd(   IrpContext,
                                          Vcb,
                                          RawIsoVd,
                                          BlockFactor,
                                          TRUE,
                                          FALSE );

            if (!FoundPvd)  {

                //
                //  We failed to find a valid VD in the data track,  but there were also
                //  audio tracks on this disc,  so we'll try to mount it as an audio CD.
                //  Since we're always last in the mount order,  we won't be preventing
                //  any other FS from trying to mount the data track.  However if the 
                //  data track was at the start of the disc,  then we abort,  to avoid
                //  having to filter it from our synthesised directory listing later.  We
                //  already filtered off any data track at the end.
                //

                if (!(TocDiskFlags & CDROM_DISK_AUDIO_TRACK) ||
                     BooleanFlagOn( Vcb->CdromToc->TrackData[0].Control, TOC_DATA_TRACK))  {
                
                    try_leave( Status = STATUS_UNRECOGNIZED_VOLUME);
                }

                SetFlag( Vcb->VcbState, VCB_STATE_AUDIO_DISK | VCB_STATE_CDXA );

                CdFreePool( &RawIsoVd );
                RawIsoVd = NULL;
            }
        }
        
        //
        //  Look and see if there is a secondary volume descriptor we want to
        //  use.
        //

        if (FoundPvd) {

            //
            //  Store the primary volume descriptor in the second half of
            //  RawIsoVd.  Then if our search for a secondary fails we can
            //  recover this immediately.
            //

            RtlCopyMemory( Add2Ptr( RawIsoVd, SECTOR_SIZE, PVOID ),
                           RawIsoVd,
                           SECTOR_SIZE );

            //
            //  We have the initial volume descriptor.  Locate a secondary
            //  volume descriptor if present.
            //

            CdFindActiveVolDescriptor( IrpContext,
                                       Vcb,
                                       RawIsoVd,
                                       FALSE);
        }

        //
        //  Check if this is a remount operation.  If so then clean up
        //  the data structures passed in and created here.
        //

        if (CdIsRemount( IrpContext, Vcb, &OldVcb )) {

            KIRQL SavedIrql;

            ASSERT( NULL != OldVcb->SwapVpb );

            //
            //  Link the old Vcb to point to the new device object that we
            //  should be talking to, dereferencing the previous.  Call a 
            //  nonpaged routine to do this since we take the Vpb spinlock.
            //

            CdReMountOldVcb( IrpContext, 
                             OldVcb, 
                             Vcb, 
                             DeviceObjectWeTalkTo);

            //
            //  See if we will need to provide notification of the remount.  This is the readonly
            //  filesystem's form of dismount/mount notification - we promise that whenever a
            //  volume is "dismounted", that a mount notification will occur when it is revalidated.
            //  Note that we do not send mount on normal remounts - that would duplicate the media
            //  arrival notification of the device driver.
            //
    
            if (FlagOn( OldVcb->VcbState, VCB_STATE_NOTIFY_REMOUNT )) {
    
                ClearFlag( OldVcb->VcbState, VCB_STATE_NOTIFY_REMOUNT );
                
                FileObjectToNotify = OldVcb->RootIndexFcb->FileObject;
                ObReferenceObject( FileObjectToNotify );
            }
            
            try_leave( Status = STATUS_SUCCESS );
        }

        //
        //  This is a new mount.  Go ahead and initialize the
        //  Vcb from the volume descriptor.
        //

        CdUpdateVcbFromVolDescriptor( IrpContext,
                                      Vcb,
                                      RawIsoVd );

        //
        //  Drop an extra reference on the root dir file so we'll be able to send
        //  notification.
        //

        if (Vcb->RootIndexFcb) {

            FileObjectToNotify = Vcb->RootIndexFcb->FileObject;
            ObReferenceObject( FileObjectToNotify );
        }

        //
        //  Now check the maximum transfer limits on the device in case we
        //  get raw reads on this volume.
        //

        Status = CdPerformDevIoCtrl( IrpContext,
                                     IOCTL_SCSI_GET_CAPABILITIES,
                                     DeviceObjectWeTalkTo,
                                     &Capabilities,
                                     sizeof( IO_SCSI_CAPABILITIES ),
                                     FALSE,
                                     TRUE,
                                     NULL );

        if (NT_SUCCESS(Status)) {

            Vcb->MaximumTransferRawSectors = Capabilities.MaximumTransferLength / RAW_SECTOR_SIZE;
            Vcb->MaximumPhysicalPages = Capabilities.MaximumPhysicalPages;

        } else {

            //
            //  This should never happen, but we can safely assume 64k and 16 pages.
            //

            Vcb->MaximumTransferRawSectors = (64 * 1024) / RAW_SECTOR_SIZE;
            Vcb->MaximumPhysicalPages = 16;
        }

        //
        //  The new mount is complete.  Remove the additional references on this
        //  Vcb and the device we are mounted on top of.
        //

        Vcb->VcbReference -= CDFS_RESIDUAL_REFERENCE;
        ASSERT( Vcb->VcbReference == CDFS_RESIDUAL_REFERENCE );

        ObDereferenceObject( Vcb->TargetDeviceObject );

        CdUpdateVcbCondition( Vcb, VcbMounted);

        CdReleaseVcb( IrpContext, Vcb );
        Vcb = NULL;

        Status = STATUS_SUCCESS;

    } finally {

        //
        //  Free the TOC buffer if not in the Vcb.
        //

        if (CdromToc != NULL) {

            CdFreePool( &CdromToc );
        }

        //
        //  Free the sector buffer if allocated.
        //

        if (RawIsoVd != NULL) {

            CdFreePool( &RawIsoVd );
        }

        //
        //  If we are not mounting the device,  then set the verify bit again.
        //
        
        if ((AbnormalTermination() || (Status != STATUS_SUCCESS)) && 
            SetDoVerifyOnFail)  {

            CdMarkRealDevForVerify( IrpContext->RealDevice);
        }

        //
        //  If we didn't complete the mount then cleanup any remaining structures.
        //

        if (Vpb != NULL) { Vpb->DeviceObject = NULL; }

        if (Vcb != NULL) {

            //
            //  Make sure there is no Vcb in the IrpContext since it could go away
            //

            IrpContext->Vcb = NULL;

            Vcb->VcbReference -= CDFS_RESIDUAL_REFERENCE;

            if (CdDismountVcb( IrpContext, Vcb )) {

                CdReleaseVcb( IrpContext, Vcb );
            }

        } else if (VolDo != NULL) {

            IoDeleteDevice( (PDEVICE_OBJECT) VolDo );
        }

        //
        //  Release the global resource.
        //

        CdReleaseCdData( IrpContext );
    }

    //
    //  Now send mount notification.
    //
    
    if (FileObjectToNotify) {

        FsRtlNotifyVolumeEvent( FileObjectToNotify, FSRTL_VOLUME_MOUNT );
        ObDereferenceObject( FileObjectToNotify );
    }

    //
    //  Complete the request if no exception.
    //

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdVerifyVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the verify volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    PVPB Vpb = IrpSp->Parameters.VerifyVolume.Vpb;
    PVCB Vcb = &((PVOLUME_DEVICE_OBJECT) IrpSp->Parameters.VerifyVolume.DeviceObject)->Vcb;

    PCHAR RawIsoVd = NULL;

    PCDROM_TOC CdromToc = NULL;
    ULONG TocLength = 0;
    ULONG TocTrackCount = 0;
    ULONG TocDiskFlags = 0;

    ULONG MediaChangeCount = Vcb->MediaChangeCount;

    PFILE_OBJECT FileObjectToNotify = NULL;

    BOOLEAN ReturnError;
    BOOLEAN ReleaseVcb = FALSE;

    IO_STATUS_BLOCK Iosb;

    STRING AnsiLabel;
    UNICODE_STRING UnicodeLabel;

    WCHAR VolumeLabel[ VOLUME_ID_LENGTH ];
    ULONG VolumeLabelLength;

    ULONG Index;

    NTSTATUS Status;

    PAGED_CODE();

    //
    //  We check that we are talking to a Cdrom device.
    //

    ASSERT( Vpb->RealDevice->DeviceType == FILE_DEVICE_CD_ROM );
    ASSERT( FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT ));

    //
    //  Update the real device in the IrpContext from the Vpb.  There was no available
    //  file object when the IrpContext was created.
    //

    IrpContext->RealDevice = Vpb->RealDevice;

    //
    //  Acquire the global resource to synchronise against mounts and teardown,
    //  finally clause releases.
    //

    CdAcquireCdData( IrpContext );

    try {

        CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );
        ReleaseVcb = TRUE;

        //
        //  Verify that there is a disk here.
        //

        Status = CdPerformDevIoCtrl( IrpContext,
                                     IOCTL_CDROM_CHECK_VERIFY,
                                     Vcb->TargetDeviceObject,
                                     &MediaChangeCount,
                                     sizeof(ULONG),
                                     FALSE,
                                     TRUE,
                                     &Iosb );

        if (!NT_SUCCESS( Status )) {

            //
            //  If we will allow a raw mount then return WRONG_VOLUME to
            //  allow the volume to be mounted by raw.
            //

            if (FlagOn( IrpSp->Flags, SL_ALLOW_RAW_MOUNT )) {

                Status = STATUS_WRONG_VOLUME;
            }

            try_return( Status );
        }
        
        if (Iosb.Information != sizeof(ULONG)) {

            //
            //  Be safe about the count in case the driver didn't fill it in
            //

            MediaChangeCount = 0;
        }

        //
        //  Verify that the device actually saw a change. If the driver does not
        //  support the MCC, then we must verify the volume in any case.
        //

        if (MediaChangeCount == 0 ||
            (Vcb->MediaChangeCount != MediaChangeCount)) {

            //
            //  Allocate a buffer to query the TOC.
            //

            CdromToc = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                 sizeof( CDROM_TOC ),
                                                 TAG_CDROM_TOC );

            RtlZeroMemory( CdromToc, sizeof( CDROM_TOC ));

            //
            //  Let's query for the Toc now and handle any error we get from this operation.
            //

            Status = CdProcessToc( IrpContext,
                                   Vcb->TargetDeviceObject,
                                   CdromToc,
                                   &TocLength,
                                   &TocTrackCount,
                                   &TocDiskFlags );

            //
            //  If we failed to read the TOC,  then give up now.  Drives will fail
            //  a TOC read on,  for example,  erased CD-RW media.
            //

            if (Status != STATUS_SUCCESS) {

                //
                //  For any errors other than no media and not ready,  commute the
                //  status to ensure that the current VPB is kicked off the device
                //  below - there is probably blank media in the drive,  since we got
                //  further than the check verify.
                //

                if (!CdIsRawDevice( IrpContext, Status )) {

                    Status = STATUS_WRONG_VOLUME;
                }

                try_return( Status );

            //
            //  We got a TOC.  Verify that it matches the previous Toc.
            //

            } else if ((Vcb->TocLength != TocLength) ||
                       (Vcb->TrackCount != TocTrackCount) ||
                       (Vcb->DiskFlags != TocDiskFlags) ||
                       !RtlEqualMemory( CdromToc,
                                        Vcb->CdromToc,
                                        TocLength )) {

                try_return( Status = STATUS_WRONG_VOLUME );
            }

            //
            //  If the disk to verify is an audio disk then we already have a
            //  match.  Otherwise we need to check the volume descriptor.
            //

            if (!FlagOn( Vcb->VcbState, VCB_STATE_AUDIO_DISK )) {

                //
                //  Allocate a buffer for the sector buffer.
                //

                RawIsoVd = FsRtlAllocatePoolWithTag( CdNonPagedPool,
                                                     ROUND_TO_PAGES( 2 * SECTOR_SIZE ),
                                                     TAG_VOL_DESC );

                //
                //  Read the primary volume descriptor for this volume.  If we
                //  get an io error and this verify was a the result of DASD open,
                //  commute the Io error to STATUS_WRONG_VOLUME.  Note that if we currently
                //  expect a music disk then this request should fail.
                //

                ReturnError = FALSE;

                if (FlagOn( IrpSp->Flags, SL_ALLOW_RAW_MOUNT )) {

                    ReturnError = TRUE;
                }

                if (!CdFindPrimaryVd( IrpContext,
                                      Vcb,
                                      RawIsoVd,
                                      Vcb->BlockFactor,
                                      ReturnError,
                                      TRUE )) {

                    //
                    //  If the previous Vcb did not represent a raw disk
                    //  then show this volume was dismounted.
                    //

                    try_return( Status = STATUS_WRONG_VOLUME );

                } 
                else {

                    //
                    //  Look for a supplementary VD.
                    //
                    //  Store the primary volume descriptor in the second half of
                    //  RawIsoVd.  Then if our search for a secondary fails we can
                    //  recover this immediately.
                    //

                    RtlCopyMemory( Add2Ptr( RawIsoVd, SECTOR_SIZE, PVOID ),
                                   RawIsoVd,
                                   SECTOR_SIZE );

                    //
                    //  We have the initial volume descriptor.  Locate a secondary
                    //  volume descriptor if present.
                    //

                    CdFindActiveVolDescriptor( IrpContext,
                                               Vcb,
                                               RawIsoVd,
                                               TRUE);
                    //
                    //  Compare the serial numbers.  If they don't match, set the
                    //  status to wrong volume.
                    //

                    if (Vpb->SerialNumber != CdSerial32( RawIsoVd, SECTOR_SIZE )) {

                        try_return( Status = STATUS_WRONG_VOLUME );
                    }

                    //
                    //  Verify the volume labels.
                    //

                    if (!FlagOn( Vcb->VcbState, VCB_STATE_JOLIET )) {

                        //
                        //  Compute the length of the volume name
                        //

                        AnsiLabel.Buffer = CdRvdVolId( RawIsoVd, Vcb->VcbState );
                        AnsiLabel.MaximumLength = AnsiLabel.Length = VOLUME_ID_LENGTH;

                        UnicodeLabel.MaximumLength = VOLUME_ID_LENGTH * sizeof( WCHAR );
                        UnicodeLabel.Buffer = VolumeLabel;

                        //
                        //  Convert this to unicode.  If we get any error then use a name
                        //  length of zero.
                        //

                        VolumeLabelLength = 0;

                        if (NT_SUCCESS( RtlOemStringToCountedUnicodeString( &UnicodeLabel,
                                                                            &AnsiLabel,
                                                                            FALSE ))) {

                            VolumeLabelLength = UnicodeLabel.Length;
                        }

                    //
                    //  We need to convert from big-endian to little endian.
                    //

                    } else {

                        CdConvertBigToLittleEndian( IrpContext,
                                                    CdRvdVolId( RawIsoVd, Vcb->VcbState ),
                                                    VOLUME_ID_LENGTH,
                                                    (PCHAR) VolumeLabel );

                        VolumeLabelLength = VOLUME_ID_LENGTH;
                    }

                    //
                    //  Strip the trailing spaces or zeroes from the name.
                    //

                    Index = VolumeLabelLength / sizeof( WCHAR );

                    while (Index > 0) {

                        if ((VolumeLabel[ Index - 1 ] != L'\0') &&
                            (VolumeLabel[ Index - 1 ] != L' ')) {

                            break;
                        }

                        Index -= 1;
                    }

                    //
                    //  Now set the final length for the name.
                    //

                    VolumeLabelLength = (USHORT) (Index * sizeof( WCHAR ));

                    //
                    //  Now check that the label matches.
                    //
                    if ((Vpb->VolumeLabelLength != VolumeLabelLength) ||
                        !RtlEqualMemory( Vpb->VolumeLabel,
                                         VolumeLabel,
                                         VolumeLabelLength )) {

                        try_return( Status = STATUS_WRONG_VOLUME );
                    }
                }
            }
        }

        //
        //  The volume is OK, clear the verify bit.
        //

        CdUpdateVcbCondition( Vcb, VcbMounted);

        CdMarkRealDevVerifyOk( Vpb->RealDevice);

        //
        //  See if we will need to provide notification of the remount.  This is the readonly
        //  filesystem's form of dismount/mount notification.
        //

        if (FlagOn( Vcb->VcbState, VCB_STATE_NOTIFY_REMOUNT )) {

            ClearFlag( Vcb->VcbState, VCB_STATE_NOTIFY_REMOUNT );
            
            FileObjectToNotify = Vcb->RootIndexFcb->FileObject;
            ObReferenceObject( FileObjectToNotify );
        }
        
    try_exit: NOTHING;

        //
        //  Update the media change count to note that we have verified the volume
        //  at this value - regardless of the outcome.
        //

        CdUpdateMediaChangeCount( Vcb, MediaChangeCount);

        //
        //  If we got the wrong volume then free any remaining XA sector in
        //  the current Vcb.  Also mark the Vcb as not mounted.
        //

        if (Status == STATUS_WRONG_VOLUME) {

            CdUpdateVcbCondition( Vcb, VcbNotMounted);

            if (Vcb->XASector != NULL) {

                CdFreePool( &Vcb->XASector );
                Vcb->XASector = 0;
                Vcb->XADiskOffset = 0;
            }

            //
            //  Now, if there are no user handles to the volume, try to spark
            //  teardown by purging the volume.
            //

            if (Vcb->VcbCleanup == 0) {

                if (NT_SUCCESS( CdPurgeVolume( IrpContext, Vcb, FALSE ))) {
                    
                    ReleaseVcb = CdCheckForDismount( IrpContext, Vcb, FALSE );
                }
            }
        }

    } finally {

        //
        //  Free the TOC buffer if allocated.
        //

        if (CdromToc != NULL) {

            CdFreePool( &CdromToc );
        }

        if (RawIsoVd != NULL) {

            CdFreePool( &RawIsoVd );
        }

        if (ReleaseVcb) {
            
            CdReleaseVcb( IrpContext, Vcb );
        }

        CdReleaseCdData( IrpContext );
    }

    //
    //  Now send mount notification.
    //
    
    if (FileObjectToNotify) {

        FsRtlNotifyVolumeEvent( FileObjectToNotify, FSRTL_VOLUME_MOUNT );
        ObDereferenceObject( FileObjectToNotify );
    }
    
    //
    //  Complete the request if no exception.
    //

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdOplockRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine to handle oplock requests made via the
    NtFsControlFile call.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PFCB Fcb;
    PCCB Ccb;

    ULONG OplockCount = 0;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  We only permit oplock requests on files.
    //

    if (CdDecodeFileObject( IrpContext,
                            IrpSp->FileObject,
                            &Fcb,
                            &Ccb ) != UserFileOpen ) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Make this a waitable Irpcontext so we don't fail to acquire
    //  the resources.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );

    //
    //  Switch on the function control code.  We grab the Fcb exclusively
    //  for oplock requests, shared for oplock break acknowledgement.
    //

    switch (IrpSp->Parameters.FileSystemControl.FsControlCode) {

    case FSCTL_REQUEST_OPLOCK_LEVEL_1 :
    case FSCTL_REQUEST_OPLOCK_LEVEL_2 :
    case FSCTL_REQUEST_BATCH_OPLOCK :
    case FSCTL_REQUEST_FILTER_OPLOCK :

        CdAcquireFcbExclusive( IrpContext, Fcb, FALSE );

        if (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_REQUEST_OPLOCK_LEVEL_2) {

            if (Fcb->FileLock != NULL) {

                OplockCount = (ULONG) FsRtlAreThereCurrentFileLocks( Fcb->FileLock );
            }

        } else {

            OplockCount = Fcb->FcbCleanup;
        }

        break;

    case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
    case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
    case FSCTL_OPLOCK_BREAK_NOTIFY:
    case FSCTL_OPLOCK_BREAK_ACK_NO_2:

        CdAcquireFcbShared( IrpContext, Fcb, FALSE );
        break;

    default:

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Use a try finally to free the Fcb.
    //

    try {

        //
        //  Verify the Fcb.
        //

        CdVerifyFcbOperation( IrpContext, Fcb );

        //
        //  Call the FsRtl routine to grant/acknowledge oplock.
        //

        Status = FsRtlOplockFsctrl( &Fcb->Oplock,
                                    Irp,
                                    OplockCount );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        CdLockFcb( IrpContext, Fcb );
        Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );
        CdUnlockFcb( IrpContext, Fcb );

        //
        //  The oplock package will complete the Irp.
        //

        Irp = NULL;

    } finally {

        //
        //  Release all of our resources
        //

        CdReleaseFcb( IrpContext, Fcb );
    }

    //
    //  Complete the request if there was no exception.
    //

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdLockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the lock volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the file object, the only type of opens we accept are
    //  user volume opens.
    //

    if (CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb ) != UserVolumeOpen) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Send our notification so that folks that like to hold handles on
    //  volumes can get out of the way.
    //

    FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_LOCK );

    //
    //  Acquire exclusive access to the Vcb.
    //

    Vcb = Fcb->Vcb;
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    try {

        //
        //  Verify the Vcb.
        //

        CdVerifyVcb( IrpContext, Vcb );

        Status = CdLockVolumeInternal( IrpContext, Vcb, IrpSp->FileObject );

    } finally {

        //
        //  Release the Vcb.
        //

        CdReleaseVcb( IrpContext, Vcb );
        
        if (AbnormalTermination() || !NT_SUCCESS( Status )) {

            FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_LOCK_FAILED );
        }
    }

    //
    //  Complete the request if there haven't been any exceptions.
    //

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdUnlockVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the unlock volume operation.  It is responsible for
    either completing of enqueuing the input Irp.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the file object, the only type of opens we accept are
    //  user volume opens.
    //

    if (CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb ) != UserVolumeOpen ) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire exclusive access to the Vcb.
    //

    Vcb = Fcb->Vcb;

    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  We won't check for a valid Vcb for this request.  An unlock will always
    //  succeed on a locked volume.
    //

    Status = CdUnlockVolumeInternal( IrpContext, Vcb, IrpSp->FileObject );

    //
    //  Release all of our resources
    //

    CdReleaseVcb( IrpContext, Vcb );

    //
    //  Send notification that the volume is avaliable.
    //

    if (NT_SUCCESS( Status )) {

        FsRtlNotifyVolumeEvent( IrpSp->FileObject, FSRTL_VOLUME_UNLOCK );
    }

    //
    //  Complete the request if there haven't been any exceptions.
    //

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}



//
//  Local support routine
//

NTSTATUS
CdDismountVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the dismount volume operation.  It is responsible for
    either completing of enqueuing the input Irp.  We only dismount a volume which
    has been locked.  The intent here is that someone has locked the volume (they are the
    only remaining handle).  We set the verify bit here and the user will close his handle.
    We will dismount a volume with no user's handles in the verify path.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    if (CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb ) != UserVolumeOpen ) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    Vcb = Fcb->Vcb;

    //
    //  Make this request waitable.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
    
    //
    //  Acquire exclusive access to the Vcb,  and take the global resource to
    //  sync. against mounts,  verifies etc.
    //

    CdAcquireCdData( IrpContext );
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  Mark the volume as needs to be verified, but only do it if
    //  the vcb is locked by this handle and the volume is currently mounted.
    //

    if (Vcb->VcbCondition != VcbMounted) {

        Status = STATUS_VOLUME_DISMOUNTED;

    } else {

        //
        //  Invalidate the volume right now.
        //
        //  The intent here is to make every subsequent operation
        //  on the volume fail and grease the rails toward dismount.
        //  By definition there is no going back from a SURPRISE.
        //
            
        CdLockVcb( IrpContext, Vcb );
        
        if (Vcb->VcbCondition != VcbDismountInProgress) {
        
            CdUpdateVcbCondition( Vcb, VcbInvalid);
        }
        
        CdUnlockVcb( IrpContext, Vcb );

        //
        //  Set flag to tell the close path that we want to force dismount
        //  the volume when this handle is closed.
        //
        
        SetFlag( Ccb->Flags, CCB_FLAG_DISMOUNT_ON_CLOSE);
        
        Status = STATUS_SUCCESS;
    }

    //
    //  Release all of our resources
    //

    CdReleaseVcb( IrpContext, Vcb );
    CdReleaseCdData( IrpContext);

    //
    //  Complete the request if there haven't been any exceptions.
    //

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


//
//  Local support routine
//

CdIsVolumeDirty (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if a volume is currently dirty.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PULONG VolumeState;
    
    //
    //  Get the current stack location and extract the output
    //  buffer information.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Get a pointer to the output buffer.
    //

    if (Irp->AssociatedIrp.SystemBuffer != NULL) {

        VolumeState = Irp->AssociatedIrp.SystemBuffer;

    } else {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_USER_BUFFER );
        return STATUS_INVALID_USER_BUFFER;
    }

    //
    //  Make sure the output buffer is large enough and then initialize
    //  the answer to be that the volume isn't dirty.
    //

    if (IrpSp->Parameters.FileSystemControl.OutputBufferLength < sizeof(ULONG)) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    *VolumeState = 0;

    //
    //  Decode the file object
    //

    TypeOfOpen = CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb );

    if (TypeOfOpen != UserVolumeOpen) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if (Fcb->Vcb->VcbCondition != VcbMounted) {

        CdCompleteRequest( IrpContext, Irp, STATUS_VOLUME_DISMOUNTED );
        return STATUS_VOLUME_DISMOUNTED;
    }

    //
    //  Now set up to return the clean state.  CDs obviously can never be dirty
    //  but we want to make sure we have enforced the full semantics of this call.
    //
    
    Irp->IoStatus.Information = sizeof( ULONG );

    CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
CdIsVolumeMounted (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if a volume is currently mounted.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Decode the file object.
    //

    CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb );

    if (Fcb != NULL) {

        //
        //  Disable PopUps, we want to return any error.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS );

        //
        //  Verify the Vcb.  This will raise in the error condition.
        //

        CdVerifyVcb( IrpContext, Fcb->Vcb );
    }

    CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
CdIsPathnameValid (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine determines if pathname is a valid CDFS pathname.
    We always succeed this request.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    None

--*/

{
    PAGED_CODE();

    CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
CdInvalidateVolumes (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine searches for all the volumes mounted on the same real device
    of the current DASD handle, and marks them all bad.  The only operation
    that can be done on such handles is cleanup and close.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    KIRQL SavedIrql;
    
    BOOLEAN UnlockVcb = FALSE;
    
    LUID TcbPrivilege = {SE_TCB_PRIVILEGE, 0};

    HANDLE Handle;

    PVCB Vcb;

    PLIST_ENTRY Links;

    PFILE_OBJECT FileToMarkBad;
    PDEVICE_OBJECT DeviceToMarkBad;

    //
    //  We only allow the invalidate call to come in on our file system devices.
    //
    
    if (IrpSp->DeviceObject != CdData.FileSystemDeviceObject)  {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Check for the correct security access.
    //  The caller must have the SeTcbPrivilege.
    //

    if (!SeSinglePrivilegeCheck( TcbPrivilege, Irp->RequestorMode )) {

        CdCompleteRequest( IrpContext, Irp, STATUS_PRIVILEGE_NOT_HELD );

        return STATUS_PRIVILEGE_NOT_HELD;
    }

    //
    //  Try to get a pointer to the device object from the handle passed in.
    //

#if defined(_WIN64)
    if (IoIs32bitProcess( Irp )) {
        
        if (IrpSp->Parameters.FileSystemControl.InputBufferLength != sizeof( UINT32 )) {

            CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }

        Handle = (HANDLE) LongToHandle( *((PUINT32) Irp->AssociatedIrp.SystemBuffer) );
    
    } else {
#endif
        if (IrpSp->Parameters.FileSystemControl.InputBufferLength != sizeof( HANDLE )) {

            CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
            return STATUS_INVALID_PARAMETER;
        }
        Handle = *((PHANDLE) Irp->AssociatedIrp.SystemBuffer);
#if defined(_WIN64)
    }
#endif

    Status = ObReferenceObjectByHandle( Handle,
                                        0,
                                        *IoFileObjectType,
                                        KernelMode,
                                        &FileToMarkBad,
                                        NULL );

    if (!NT_SUCCESS(Status)) {

        CdCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Grab the DeviceObject from the FileObject.
    //

    DeviceToMarkBad = FileToMarkBad->DeviceObject;

    //
    //  We only needed the device object involved, not a reference to the file.
    //

    ObDereferenceObject( FileToMarkBad );

    //
    //  Make sure this request can wait.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );

    //
    //  Synchronise with pnp/mount/verify paths.
    //
    
    CdAcquireCdData( IrpContext );

    //
    //  Nothing can go wrong now.
    //

    //
    //  Now walk through all the mounted Vcb's looking for candidates to
    //  mark invalid.
    //
    //  On volumes we mark invalid, check for dismount possibility (which is
    //  why we have to get the next link so early).
    //

    Links = CdData.VcbQueue.Flink;

    while (Links != &CdData.VcbQueue) {

        Vcb = CONTAINING_RECORD( Links, VCB, VcbLinks);

        Links = Links->Flink;

        //
        //  If we get a match, mark the volume Bad, and also check to
        //  see if the volume should go away.
        //

        CdLockVcb( IrpContext, Vcb );

        if (Vcb->Vpb->RealDevice == DeviceToMarkBad) {

            //
            //  Take the VPB spinlock,  and look to see if this volume is the 
            //  one currently mounted on the actual device.  If it is,  pull it 
            //  off immediately.
            //
            
            IoAcquireVpbSpinLock( &SavedIrql );

            if (DeviceToMarkBad->Vpb == Vcb->Vpb)  {
            
                PVPB NewVpb = Vcb->SwapVpb;

                ASSERT( FlagOn( Vcb->Vpb->Flags, VPB_MOUNTED));
                ASSERT( NULL != NewVpb);

                RtlZeroMemory( NewVpb, sizeof( VPB ) );

                NewVpb->Type = IO_TYPE_VPB;
                NewVpb->Size = sizeof( VPB );
                NewVpb->RealDevice = DeviceToMarkBad;
                NewVpb->Flags = FlagOn( DeviceToMarkBad->Vpb->Flags, VPB_REMOVE_PENDING );

                DeviceToMarkBad->Vpb = NewVpb;
                Vcb->SwapVpb = NULL;
            }

            IoReleaseVpbSpinLock( SavedIrql );

            if (Vcb->VcbCondition != VcbDismountInProgress) {
                
                CdUpdateVcbCondition( Vcb, VcbInvalid);
            }

            CdUnlockVcb( IrpContext, Vcb );

            CdAcquireVcbExclusive( IrpContext, Vcb, FALSE);
            
            CdPurgeVolume( IrpContext, Vcb, FALSE );

            UnlockVcb = CdCheckForDismount( IrpContext, Vcb, FALSE );

            if (UnlockVcb)  {

                CdReleaseVcb( IrpContext, Vcb);
            }

        } else {

            CdUnlockVcb( IrpContext, Vcb );
        }
    }

    CdReleaseCdData( IrpContext );

    CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}


//
//  Local support routine
//

VOID
CdScanForDismountedVcb (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine walks through the list of Vcb's looking for any which may
    now be deleted.  They may have been left on the list because there were
    outstanding references.

Arguments:

Return Value:

    None

--*/

{
    PVCB Vcb;
    PLIST_ENTRY Links;

    PAGED_CODE();

    //
    //  Walk through all of the Vcb's attached to the global data.
    //

    Links = CdData.VcbQueue.Flink;

    while (Links != &CdData.VcbQueue) {

        Vcb = CONTAINING_RECORD( Links, VCB, VcbLinks );

        //
        //  Move to the next link now since the current Vcb may be deleted.
        //

        Links = Links->Flink;

        //
        //  If dismount is already underway then check if this Vcb can
        //  go away.
        //

        if ((Vcb->VcbCondition == VcbDismountInProgress) ||
            (Vcb->VcbCondition == VcbInvalid) ||
            ((Vcb->VcbCondition == VcbNotMounted) && (Vcb->VcbReference <= CDFS_RESIDUAL_REFERENCE))) {

            CdCheckForDismount( IrpContext, Vcb, FALSE );
        }
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
CdFindPrimaryVd (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PCHAR RawIsoVd,
    IN ULONG BlockFactor,
    IN BOOLEAN ReturnOnError,
    IN BOOLEAN VerifyVolume
    )

/*++

Routine Description:

    This routine is called to walk through the volume descriptors looking
    for a primary volume descriptor.  When/if a primary is found a 32-bit
    serial number is generated and stored into the Vpb.  We also store the
    location of the primary volume descriptor in the Vcb.

Arguments:

    Vcb - Pointer to the VCB for the volume.

    RawIsoVd - Pointer to a sector buffer which will contain the primary
               volume descriptor on exit, if successful.

    BlockFactor - Block factor used by the current device for the TableOfContents.

    ReturnOnError - Indicates that we should raise on I/O errors rather than
        returning a FALSE value.

    VerifyVolume - Indicates if we were called from the verify path.  We
        do a few things different in this path.  We don't update the Vcb in
        the verify path.

Return Value:

    BOOLEAN - TRUE if a valid primary volume descriptor found, FALSE
              otherwise.

--*/

{
    NTSTATUS Status;
    ULONG ThisPass = 1;
    BOOLEAN FoundVd = FALSE;

    ULONG BaseSector;
    ULONG SectorOffset;

    PCDROM_TOC CdromToc;

    ULONG VolumeFlags;

    PAGED_CODE();

    //
    //  If there are no data tracks, don't even bother hunting for descriptors.
    //
    //  This explicitly breaks various non-BlueBook compliant CDs that scribble
    //  an ISO filesystem on media claiming only audio tracks.  Since these
    //  disks can cause serious problems in some CDROM units, fail fast.  I admit
    //  that it is possible that someone can still record the descriptors in the
    //  audio track, record a data track (but fail to record descriptors there)
    //  and still have the disk work.  As this form of error worked in NT 4.0, and
    //  since these disks really do exist, I don't want to change them.
    //
    //  If we wished to support all such media (we don't), it would be neccesary
    //  to clear this flag on finding ISO or HSG descriptors below.
    //

    if (FlagOn(Vcb->VcbState, VCB_STATE_AUDIO_DISK)) {

        return FALSE;
    }
    
    //
    //  We will make at most two passes through the volume descriptor sequence.
    //
    //  On the first pass we will query for the last session.  Using this
    //  as a starting offset we will attempt to mount the volume.  On any failure
    //  we will go to the second pass and try without using any multi-session
    //  information.
    //
    //  On the second pass we will start offset from sector zero.
    //

    while (!FoundVd && (ThisPass <= 2)) {

        //
        //  If we aren't at pass 1 then we start at sector 0.  Otherwise we
        //  try to look up the multi-session information.
        //

        BaseSector = 0;

        if (ThisPass == 1) {

            CdromToc = NULL;

            //
            //  Check for whether this device supports XA and multi-session.
            //

            try {

                //
                //  Allocate a buffer for the last session information.
                //

                CdromToc = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                     sizeof( CDROM_TOC ),
                                                     TAG_CDROM_TOC );

                RtlZeroMemory( CdromToc, sizeof( CDROM_TOC ));

                //
                //  Query the last session information from the driver.
                //

                Status = CdPerformDevIoCtrl( IrpContext,
                                             IOCTL_CDROM_GET_LAST_SESSION,
                                             Vcb->TargetDeviceObject,
                                             CdromToc,
                                             sizeof( CDROM_TOC ),
                                             FALSE,
                                             TRUE,
                                             NULL );

                //
                //  Raise an exception if there was an allocation failure.
                //

                if (Status == STATUS_INSUFFICIENT_RESOURCES) {

                    CdRaiseStatus( IrpContext, Status );
                }

                //
                //  We don't handle any errors yet.  We will hit that below
                //  as we try to scan the disk.  If we have last session information
                //  then modify the base sector.
                //

                if (NT_SUCCESS( Status ) &&
                    (CdromToc->FirstTrack != CdromToc->LastTrack)) {

                    PCHAR Source, Dest;
                    ULONG Count;

                    Count = 4;

                    //
                    //  The track address is BigEndian, we need to flip the bytes.
                    //

                    Source = (PUCHAR) &CdromToc->TrackData[0].Address[3];
                    Dest = (PUCHAR) &BaseSector;

                    do {

                        *Dest++ = *Source--;

                    } while (--Count);

                    //
                    //  Now adjust the base sector by the block factor of the
                    //  device.
                    //

                    BaseSector /= BlockFactor;

                //
                //  Make this look like the second pass since we are only using the
                //  first session.  No reason to retry on error.
                //

                } else {

                    ThisPass += 1;
                }

            } finally {

                if (CdromToc != NULL) { CdFreePool( &CdromToc ); }
            }
        }

        //
        //  Compute the starting sector offset from the start of the session.
        //

        SectorOffset = FIRST_VD_SECTOR;

        //
        //  Start by assuming we have neither Hsg or Iso volumes.
        //

        VolumeFlags = 0;

        //
        //  Loop until either error encountered, primary volume descriptor is
        //  found or a terminal volume descriptor is found.
        //

        while (TRUE) {

            //
            //  Attempt to read the desired sector. Exit directly if operation
            //  not completed.
            //
            //  If this is pass 1 we will ignore errors in read sectors and just
            //  go to the next pass.
            //

            if (!CdReadSectors( IrpContext,
                                LlBytesFromSectors( BaseSector + SectorOffset ),
                                SECTOR_SIZE,
                                (BOOLEAN) ((ThisPass == 1) || ReturnOnError),
                                RawIsoVd,
                                Vcb->TargetDeviceObject )) {

                break;
            }

            //
            //  Check if either an ISO or HSG volume.
            //

            if (RtlEqualMemory( CdIsoId,
                                CdRvdId( RawIsoVd, VCB_STATE_ISO ),
                                VOL_ID_LEN )) {

                SetFlag( VolumeFlags, VCB_STATE_ISO );

            } else if (RtlEqualMemory( CdHsgId,
                                       CdRvdId( RawIsoVd, VCB_STATE_HSG ),
                                       VOL_ID_LEN )) {

                SetFlag( VolumeFlags, VCB_STATE_HSG );

            //
            //  We have neither so break out of the loop.
            //

            } else {

                 break;
            }

            //
            //  Break out if the version number is incorrect or this is
            //  a terminator.
            //

            if ((CdRvdVersion( RawIsoVd, VolumeFlags ) != VERSION_1) ||
                (CdRvdDescType( RawIsoVd, VolumeFlags ) == VD_TERMINATOR)) {

                break;
            }

            //
            //  If this is a primary volume descriptor then our search is over.
            //

            if (CdRvdDescType( RawIsoVd, VolumeFlags ) == VD_PRIMARY) {

                //
                //  If we are not in the verify path then initialize the
                //  fields in the Vcb with basic information from this
                //  descriptor.
                //

                if (!VerifyVolume) {

                    //
                    //  Set the flag for the volume type.
                    //

                    SetFlag( Vcb->VcbState, VolumeFlags );

                    //
                    //  Store the base sector and sector offset for the
                    //  primary volume descriptor.
                    //

                    Vcb->BaseSector = BaseSector;
                    Vcb->VdSectorOffset = SectorOffset;
                    Vcb->PrimaryVdSectorOffset = SectorOffset;
                }

                FoundVd = TRUE;
                break;
            }

            //
            //  Indicate that we're at the next sector.
            //

            SectorOffset += 1;
        }

        ThisPass += 1;
    }

    return FoundVd;
}


//
//  Local support routine
//

BOOLEAN
CdIsRemount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    OUT PVCB *OldVcb
    )
/*++

Routine Description:

    This routine walks through the links of the Vcb chain in the global
    data structure.  The remount condition is met when the following
    conditions are all met:

        If the new Vcb is a device only Mvcb and there is a previous
        device only Mvcb.

        Otherwise following conditions must be matched.

            1 - The 32 serial in the current VPB matches that in a previous
                VPB.

            2 - The volume label in the Vpb matches that in the previous
                Vpb.

            3 - The system pointer to the real device object in the current
                VPB matches that in the same previous VPB.

            4 - Finally the previous Vcb cannot be invalid or have a dismount
                underway.

    If a VPB is found which matches these conditions, then the address of
    the VCB for that VPB is returned via the pointer Vcb.

    Skip over the current Vcb.

Arguments:

    Vcb - This is the Vcb we are checking for a remount.

    OldVcb -  A pointer to the address to store the address for the Vcb
              for the volume if this is a remount.  (This is a pointer to
              a pointer)

Return Value:

    BOOLEAN - TRUE if this is in fact a remount, FALSE otherwise.

--*/

{
    PLIST_ENTRY Link;

    PVPB Vpb = Vcb->Vpb;
    PVPB OldVpb;

    BOOLEAN Remount = FALSE;

    PAGED_CODE();

    //
    //  Check whether we are looking for a device only Mvcb.
    //

    for (Link = CdData.VcbQueue.Flink;
         Link != &CdData.VcbQueue;
         Link = Link->Flink) {

        *OldVcb = CONTAINING_RECORD( Link, VCB, VcbLinks );

        //
        //  Skip ourselves.
        //

        if (Vcb == *OldVcb) { continue; }

        //
        //  Look at the Vpb and state of the previous Vcb.
        //

        OldVpb = (*OldVcb)->Vpb;

        if ((OldVpb != Vpb) &&
            (OldVpb->RealDevice == Vpb->RealDevice) &&
            ((*OldVcb)->VcbCondition == VcbNotMounted)) {

            //
            //  If the current disk is a raw disk then it can match a previous music or
            //  raw disk.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_AUDIO_DISK)) {

                if (FlagOn( (*OldVcb)->VcbState, VCB_STATE_AUDIO_DISK )) {

                    //
                    //  If we have both TOC then fail the remount if the lengths
                    //  are different or they don't match.
                    //

                    if ((Vcb->TocLength != (*OldVcb)->TocLength) ||
                        ((Vcb->TocLength != 0) &&
                         !RtlEqualMemory( Vcb->CdromToc,
                                          (*OldVcb)->CdromToc,
                                          Vcb->TocLength ))) {

                        continue;
                    }

                    Remount = TRUE;
                    break;
                }

            //
            //  The current disk is not a raw disk.  Go ahead and compare
            //  serial numbers and volume label.
            //

            } else if ((OldVpb->SerialNumber == Vpb->SerialNumber) &&
                       (Vpb->VolumeLabelLength == OldVpb->VolumeLabelLength) &&
                       (RtlEqualMemory( OldVpb->VolumeLabel,
                                        Vpb->VolumeLabel,
                                        Vpb->VolumeLabelLength ))) {

                //
                //  Remember the old mvcb.  Then set the return value to
                //  TRUE and break.
                //

                Remount = TRUE;
                break;
            }
        }
    }

    return Remount;
}


//
//  Local support routine
//

VOID
CdFindActiveVolDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PCHAR RawIsoVd,
    IN BOOLEAN VerifyVolume
    )

/*++

Routine Description:

    This routine is called to search for a valid secondary volume descriptor that
    we will support.  Right now we only support Joliet escape sequences for
    the secondary descriptor.

    If we don't find the secondary descriptor then we will reread the primary.

    This routine will update the serial number and volume label in the Vpb.

Arguments:

    Vcb - This is the Vcb for the volume being mounted.

    RawIsoVd - Sector buffer used to read the volume descriptors from the disks, but
               on input should contain the PVD (ISO) in the SECOND 'sector' of the
               buffer.

    VerifyVolume - indicates we are being called by the verify path, and should
                   not modify the Vcb fields.

Return Value:

    None

--*/

{
    BOOLEAN FoundSecondaryVd = FALSE;
    ULONG SectorOffset = FIRST_VD_SECTOR;

    ULONG Length;

    ULONG Index;

    PAGED_CODE();

    //
    //  We only look for secondary volume descriptors on an Iso disk.
    //

    if ((FlagOn( Vcb->VcbState, VCB_STATE_ISO) || VerifyVolume) && !CdNoJoliet) {

        //
        //  Scan the volume descriptors from the beginning looking for a valid
        //  secondary or a terminator.
        //

        SectorOffset = FIRST_VD_SECTOR;

        while (TRUE) {

            //
            //  Read the next sector.  We should never have an error in this
            //  path.
            //

            CdReadSectors( IrpContext,
                           LlBytesFromSectors( Vcb->BaseSector + SectorOffset ),
                           SECTOR_SIZE,
                           FALSE,
                           RawIsoVd,
                           Vcb->TargetDeviceObject );

            //
            //  Break out if the version number or standard Id is incorrect.
            //  Also break out if this is a terminator.
            //

            if (!RtlEqualMemory( CdIsoId, CdRvdId( RawIsoVd, VCB_STATE_JOLIET ), VOL_ID_LEN ) ||
                (CdRvdVersion( RawIsoVd, VCB_STATE_JOLIET ) != VERSION_1) ||
                (CdRvdDescType( RawIsoVd, VCB_STATE_JOLIET ) == VD_TERMINATOR)) {

                break;
            }

            //
            //  We have a match if this is a secondary descriptor with a matching
            //  escape sequence.
            //

            if ((CdRvdDescType( RawIsoVd, VCB_STATE_JOLIET ) == VD_SECONDARY) &&
                (RtlEqualMemory( CdRvdEsc( RawIsoVd, VCB_STATE_JOLIET ),
                                 CdJolietEscape[0],
                                 ESC_SEQ_LEN ) ||
                 RtlEqualMemory( CdRvdEsc( RawIsoVd, VCB_STATE_JOLIET ),
                                 CdJolietEscape[1],
                                 ESC_SEQ_LEN ) ||
                 RtlEqualMemory( CdRvdEsc( RawIsoVd, VCB_STATE_JOLIET ),
                                 CdJolietEscape[2],
                                 ESC_SEQ_LEN ))) {

                if (!VerifyVolume)  {
                        
                    //
                    //  Update the Vcb with the new volume descriptor.
                    //

                    ClearFlag( Vcb->VcbState, VCB_STATE_ISO );
                    SetFlag( Vcb->VcbState, VCB_STATE_JOLIET );

                    Vcb->VdSectorOffset = SectorOffset;
                }
                
                FoundSecondaryVd = TRUE;
                break;
            }

            //
            //  Otherwise move on to the next sector.
            //

            SectorOffset += 1;
        }

        //
        //  If we didn't find the secondary then recover the original volume
        //  descriptor stored in the second half of the RawIsoVd.
        //

        if (!FoundSecondaryVd) {

            RtlCopyMemory( RawIsoVd,
                           Add2Ptr( RawIsoVd, SECTOR_SIZE, PVOID ),
                           SECTOR_SIZE );
        }
    }

    //
    //  If we're in the verify path,  our work is done,  since we don't want
    //  to update any Vcb/Vpb values.
    //
    
    if (VerifyVolume)  {

        return;
    }
        
    //
    //  Compute the serial number and volume label from the volume descriptor.
    //

    Vcb->Vpb->SerialNumber = CdSerial32( RawIsoVd, SECTOR_SIZE );

    //
    //  Make sure the CD label will fit in the Vpb.
    //

    ASSERT( VOLUME_ID_LENGTH * sizeof( WCHAR ) <= MAXIMUM_VOLUME_LABEL_LENGTH );

    //
    //  If this is not a Unicode label we must convert it to unicode.
    //

    if (!FlagOn( Vcb->VcbState, VCB_STATE_JOLIET )) {

        //
        //  Convert the label to unicode.  If we get any error then use a name
        //  length of zero.
        //

        Vcb->Vpb->VolumeLabelLength = 0;

        if (NT_SUCCESS( RtlOemToUnicodeN( &Vcb->Vpb->VolumeLabel[0],
                                          MAXIMUM_VOLUME_LABEL_LENGTH,
                                          &Length,
                                          CdRvdVolId( RawIsoVd, Vcb->VcbState ),
                                          VOLUME_ID_LENGTH ))) {

            Vcb->Vpb->VolumeLabelLength = (USHORT) Length;
        }

    //
    //  We need to convert from big-endian to little endian.
    //

    } else {

        CdConvertBigToLittleEndian( IrpContext,
                                    CdRvdVolId( RawIsoVd, Vcb->VcbState ),
                                    VOLUME_ID_LENGTH,
                                    (PCHAR) Vcb->Vpb->VolumeLabel );

        Vcb->Vpb->VolumeLabelLength = VOLUME_ID_LENGTH * sizeof( WCHAR );
    }

    //
    //  Strip the trailing spaces or zeroes from the name.
    //

    Index = Vcb->Vpb->VolumeLabelLength / sizeof( WCHAR );

    while (Index > 0) {

        if ((Vcb->Vpb->VolumeLabel[ Index - 1 ] != L'\0') &&
            (Vcb->Vpb->VolumeLabel[ Index - 1 ] != L' ')) {

            break;
        }

        Index -= 1;
    }

    //
    //  Now set the final length for the name.
    //

    Vcb->Vpb->VolumeLabelLength = (USHORT) (Index * sizeof( WCHAR ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\fileinfo.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FileInfo.c

Abstract:

    This module implements the File Information routines for Cdfs called by
    the Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_FILEINFO)

//
//  Local support routines
//

VOID
CdQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
CdQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
CdQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
CdQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
CdQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
CdQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
CdQueryAlternateNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

VOID
CdQueryNetworkInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN OUT PULONG Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonQueryInfo)
#pragma alloc_text(PAGE, CdCommonSetInfo)
#pragma alloc_text(PAGE, CdFastQueryBasicInfo)
#pragma alloc_text(PAGE, CdFastQueryStdInfo)
#pragma alloc_text(PAGE, CdFastQueryNetworkInfo)
#pragma alloc_text(PAGE, CdQueryAlternateNameInfo)
#pragma alloc_text(PAGE, CdQueryBasicInfo)
#pragma alloc_text(PAGE, CdQueryEaInfo)
#pragma alloc_text(PAGE, CdQueryInternalInfo)
#pragma alloc_text(PAGE, CdQueryNameInfo)
#pragma alloc_text(PAGE, CdQueryNetworkInfo)
#pragma alloc_text(PAGE, CdQueryPositionInfo)
#pragma alloc_text(PAGE, CdQueryStandardInfo)
#endif


NTSTATUS
CdCommonQueryInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for query file information called by both the
    fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for this operation.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ULONG Length;
    FILE_INFORMATION_CLASS FileInformationClass;
    PFILE_ALL_INFORMATION Buffer;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN ReleaseFcb = FALSE;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryFile.Length;
    FileInformationClass = IrpSp->Parameters.QueryFile.FileInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Decode the file object
    //

    TypeOfOpen = CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We only support query on file and directory handles.
        //

        switch (TypeOfOpen) {

        case UserDirectoryOpen :
        case UserFileOpen :

            //
            //  Acquire shared access to this file.  NOTE that this could be
            //  a recursive acquire,  if we already preacquired in
            //  CdAcquireForCreateSection().
            //

            CdAcquireFileShared( IrpContext, Fcb );
            ReleaseFcb = TRUE;

            //
            //  Make sure we have the correct sizes for a directory.
            //

            if (!FlagOn( Fcb->FcbState, FCB_STATE_INITIALIZED )) {

                ASSERT( TypeOfOpen == UserDirectoryOpen );
                CdCreateInternalStream( IrpContext, Fcb->Vcb, Fcb );
            }

            //
            //  Make sure the Fcb is in a usable condition.  This will raise
            //  an error condition if the volume is unusable
            //

            CdVerifyFcbOperation( IrpContext, Fcb );

            //
            //  Based on the information class we'll do different
            //  actions.  Each of hte procedures that we're calling fills
            //  up the output buffer, if possible.  They will raise the
            //  status STATUS_BUFFER_OVERFLOW for an insufficient buffer.
            //  This is considered a somewhat unusual case and is handled
            //  more cleanly with the exception mechanism rather than
            //  testing a return status value for each call.
            //

            switch (FileInformationClass) {

            case FileAllInformation:

                //
                //  We don't allow this operation on a file opened by file Id.
                //

                if (FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    Status = STATUS_INVALID_PARAMETER;
                    break;
                }

                //
                //  In this case go ahead and call the individual routines to
                //  fill in the buffer.  Only the name routine will
                //  pointer to the output buffer and then call the
                //  individual routines to fill in the buffer.
                //

                Length -= (sizeof( FILE_ACCESS_INFORMATION ) +
                           sizeof( FILE_MODE_INFORMATION ) +
                           sizeof( FILE_ALIGNMENT_INFORMATION ));

                CdQueryBasicInfo( IrpContext, Fcb, &Buffer->BasicInformation, &Length );
                CdQueryStandardInfo( IrpContext, Fcb, &Buffer->StandardInformation, &Length );
                CdQueryInternalInfo( IrpContext, Fcb, &Buffer->InternalInformation, &Length );
                CdQueryEaInfo( IrpContext, Fcb, &Buffer->EaInformation, &Length );
                CdQueryPositionInfo( IrpContext, IrpSp->FileObject, &Buffer->PositionInformation, &Length );
                Status = CdQueryNameInfo( IrpContext, IrpSp->FileObject, &Buffer->NameInformation, &Length );

                break;

            case FileBasicInformation:

                CdQueryBasicInfo( IrpContext, Fcb, (PFILE_BASIC_INFORMATION) Buffer, &Length );
                break;

            case FileStandardInformation:

                CdQueryStandardInfo( IrpContext, Fcb, (PFILE_STANDARD_INFORMATION) Buffer, &Length );
                break;

            case FileInternalInformation:

                CdQueryInternalInfo( IrpContext, Fcb, (PFILE_INTERNAL_INFORMATION) Buffer, &Length );
                break;

            case FileEaInformation:

                CdQueryEaInfo( IrpContext, Fcb, (PFILE_EA_INFORMATION) Buffer, &Length );
                break;

            case FilePositionInformation:

                CdQueryPositionInfo( IrpContext, IrpSp->FileObject, (PFILE_POSITION_INFORMATION) Buffer, &Length );
                break;

            case FileNameInformation:

                //
                //  We don't allow this operation on a file opened by file Id.
                //

                if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    Status = CdQueryNameInfo( IrpContext, IrpSp->FileObject, (PFILE_NAME_INFORMATION) Buffer, &Length );

                } else {

                    Status = STATUS_INVALID_PARAMETER;
                }

                break;

            case FileAlternateNameInformation:

                if (!FlagOn( Ccb->Flags, CCB_FLAG_OPEN_BY_ID )) {

                    Status = CdQueryAlternateNameInfo( IrpContext, Fcb, Ccb, (PFILE_NAME_INFORMATION) Buffer, &Length );

                } else {

                    Status = STATUS_INVALID_PARAMETER;
                }

                break;

            case FileNetworkOpenInformation:

                CdQueryNetworkInfo( IrpContext, Fcb, (PFILE_NETWORK_OPEN_INFORMATION) Buffer, &Length );
                break;

            default :

                Status = STATUS_INVALID_PARAMETER;
            }

            break;

        default :

            Status = STATUS_INVALID_PARAMETER;
        }

        //
        //  Set the information field to the number of bytes actually filled in
        //  and then complete the request
        //

        Irp->IoStatus.Information = IrpSp->Parameters.QueryFile.Length - Length;

    } finally {

        //
        //  Release the file.
        //

        if (ReleaseFcb) {

            CdReleaseFile( IrpContext, Fcb );
        }
    }

    //
    //  Complete the request if we didn't raise.
    //

    CdCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
CdCommonSetInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for set file information called by both the
    fsd and fsp threads.  We only support operations which set the file position.

Arguments:

    Irp - Supplies the Irp to process.

Return Value:

    NTSTATUS - The return status for this operation.

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PFILE_POSITION_INFORMATION Buffer;

    PAGED_CODE();

    //
    //  Decode the file object
    //

    TypeOfOpen = CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb );

    //
    //  We only support a SetPositionInformation on a user file.
    //

    if ((TypeOfOpen != UserFileOpen) ||
        (IrpSp->Parameters.QueryFile.FileInformationClass != FilePositionInformation)) {

        CdCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Acquire shared access to this file.
    //

    CdAcquireFileShared( IrpContext, Fcb );

    try {

        //
        //  Make sure the Fcb is in a usable condition.  This
        //  will raise an error condition if the fcb is unusable
        //

        CdVerifyFcbOperation( IrpContext, Fcb );

        Buffer = Irp->AssociatedIrp.SystemBuffer;

        //
        //  Check if the file does not use intermediate buffering.  If it
        //  does not use intermediate buffering then the new position we're
        //  supplied must be aligned properly for the device
        //

        if (FlagOn( IrpSp->FileObject->Flags, FO_NO_INTERMEDIATE_BUFFERING ) &&
            ((Buffer->CurrentByteOffset.LowPart & Fcb->Vcb->BlockMask) != 0)) {

            try_return( NOTHING );
        }

        //
        //  The input parameter is fine so set the current byte offset and
        //  complete the request
        //

        //
        //  Lock the Fcb to provide synchronization.
        //

        CdLockFcb( IrpContext, Fcb );
        IrpSp->FileObject->CurrentByteOffset = Buffer->CurrentByteOffset;
        CdUnlockFcb( IrpContext, Fcb );

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;
    } finally {

        CdReleaseFile( IrpContext, Fcb );
    }

    //
    //  Complete the request if there was no raise.
    //

    CdCompleteRequest( IrpContext, Irp, Status );
    return Status;
}


BOOLEAN
CdFastQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for basic file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Result = FALSE;
    TYPE_OF_OPEN TypeOfOpen;

    PFCB Fcb;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    FsRtlEnterFileSystem();

    //
    //  Decode the file object to find the type of open and the data
    //  structures.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    //
    //  We only support this request on user file or directory objects.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        ((TypeOfOpen != UserDirectoryOpen) || !FlagOn( Fcb->FcbState, FCB_STATE_INITIALIZED))) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Acquire the file shared to access the Fcb.
    //

    if (!ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Only deal with 'good' Fcb's.
        //

        if (CdVerifyFcbOperation( NULL, Fcb )) {

            //
            //  Fill in the input buffer from the Fcb fields.
            //

            Buffer->CreationTime.QuadPart =
            Buffer->LastWriteTime.QuadPart =
            Buffer->ChangeTime.QuadPart = Fcb->CreationTime;

            Buffer->LastAccessTime.QuadPart = 0;

            Buffer->FileAttributes = Fcb->FileAttributes;

            //
            //  Update the IoStatus block with the size of this data.
            //

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( FILE_BASIC_INFORMATION );

            Result = TRUE;
        }

    } finally {

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();
    }

    return Result;
}


BOOLEAN
CdFastQueryStdInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for standard file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Result = FALSE;
    TYPE_OF_OPEN TypeOfOpen;

    PFCB Fcb;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    FsRtlEnterFileSystem();

    //
    //  Decode the file object to find the type of open and the data
    //  structures.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    //
    //  We only support this request on initialized user file or directory objects.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        ((TypeOfOpen != UserDirectoryOpen) || !FlagOn( Fcb->FcbState, FCB_STATE_INITIALIZED ))) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Acquire the file shared to access the Fcb.
    //

    if (!ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Only deal with 'good' Fcb's.
        //

        if (CdVerifyFcbOperation( NULL, Fcb )) {

            //
            //  Check whether this is a directory.
            //

            if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

                Buffer->AllocationSize.QuadPart =
                Buffer->EndOfFile.QuadPart = 0;

                Buffer->Directory = TRUE;

            } else {

                Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
                Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;

                Buffer->Directory = FALSE;
            }

            Buffer->NumberOfLinks = 1;
            Buffer->DeletePending = FALSE;

            //
            //  Update the IoStatus block with the size of this data.
            //

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( FILE_STANDARD_INFORMATION );

            Result = TRUE;
        }

    } finally {

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();
    }

    return Result;
}


BOOLEAN
CdFastQueryNetworkInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is for the fast query call for network file information.

Arguments:

    FileObject - Supplies the file object used in this operation

    Wait - Indicates if we are allowed to wait for the information

    Buffer - Supplies the output buffer to receive the basic information

    IoStatus - Receives the final status of the operation

Return Value:

    BOOLEAN - TRUE if the operation succeeded and FALSE if the caller
        needs to take the long route.

--*/

{
    BOOLEAN Result = FALSE;
    TYPE_OF_OPEN TypeOfOpen;

    PFCB Fcb;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    FsRtlEnterFileSystem();

    //
    //  Decode the file object to find the type of open and the data
    //  structures.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    //
    //  We only support this request on user file or directory objects.
    //

    if ((TypeOfOpen != UserFileOpen) &&
        ((TypeOfOpen != UserDirectoryOpen) || !FlagOn( Fcb->FcbState, FCB_STATE_INITIALIZED))) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Acquire the file shared to access the Fcb.
    //

    if (!ExAcquireResourceSharedLite( Fcb->Resource, Wait )) {

        FsRtlExitFileSystem();
        return FALSE;
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Only deal with 'good' Fcb's.
        //

        if (CdVerifyFcbOperation( NULL, Fcb )) {

            //
            //  Fill in the input buffer from the Fcb fields.
            //

            Buffer->CreationTime.QuadPart =
            Buffer->LastWriteTime.QuadPart =
            Buffer->ChangeTime.QuadPart = Fcb->CreationTime;

            Buffer->LastAccessTime.QuadPart = 0;

            Buffer->FileAttributes = Fcb->FileAttributes;

            //
            //  Check whether this is a directory.
            //

            if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

                Buffer->AllocationSize.QuadPart =
                Buffer->EndOfFile.QuadPart = 0;

            } else {

                Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
                Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;
            }

            //
            //  Update the IoStatus block with the size of this data.
            //

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( FILE_NETWORK_OPEN_INFORMATION );

            Result = TRUE;
        }

    } finally {

        ExReleaseResourceLite( Fcb->Resource );

        FsRtlExitFileSystem();
    }

    return Result;
}


//
//  Local support routine
//

VOID
CdQueryBasicInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_BASIC_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

 Description:

    This routine performs the query basic information function for Cdfs

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  We only support creation, last modify and last write times on Cdfs.
    //

    Buffer->LastWriteTime.QuadPart =
    Buffer->CreationTime.QuadPart =
    Buffer->ChangeTime.QuadPart = Fcb->CreationTime;

    Buffer->LastAccessTime.QuadPart = 0;

    Buffer->FileAttributes = Fcb->FileAttributes;

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_BASIC_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
CdQueryStandardInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_STANDARD_INFORMATION Buffer,
    IN OUT PULONG Length
    )
/*++

Routine Description:

    This routine performs the query standard information function for cdfs.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  There is only one link and delete is never pending on a Cdrom file.
    //

    Buffer->NumberOfLinks = 1;
    Buffer->DeletePending = FALSE;

    //
    //  We get the sizes from the header.  Return a size of zero
    //  for all directories.
    //

    if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

        Buffer->AllocationSize.QuadPart =
        Buffer->EndOfFile.QuadPart = 0;

        Buffer->Directory = TRUE;

    } else {

        Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
        Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;

        Buffer->Directory = FALSE;
    }

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_STANDARD_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
CdQueryInternalInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_INTERNAL_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query internal information function for cdfs.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Index number is the file Id number in the Fcb.
    //

    Buffer->IndexNumber = Fcb->FileId;
    *Length -= sizeof( FILE_INTERNAL_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
CdQueryEaInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_EA_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query Ea information function for cdfs.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  No Ea's on Cdfs volumes.
    //

    Buffer->EaSize = 0;
    *Length -= sizeof( FILE_EA_INFORMATION );

    return;
}


//
//  Local support routine
//

VOID
CdQueryPositionInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_POSITION_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query position information function for cdfs.

Arguments:

    FileObject - Supplies the File object being queried

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Get the current position found in the file object.
    //

    Buffer->CurrentByteOffset = FileObject->CurrentByteOffset;

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_POSITION_INFORMATION );

    return;
}


//
//  Local support routine
//

NTSTATUS
CdQueryNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query name information function for cdfs.

Arguments:

    FileObject - Supplies the file object containing the name.

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    NTSTATUS - STATUS_BUFFER_OVERFLOW if the entire name can't be copied.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG LengthToCopy;

    PAGED_CODE();

    ASSERT(*Length >= sizeof(ULONG));
    
    //
    //  Simply copy the name in the file object to the user's buffer.
    //

    //
    //  Place the size of the filename in the user's buffer and reduce the remaining
    //  size to match.
    //

    Buffer->FileNameLength = LengthToCopy = FileObject->FileName.Length;
    *Length -= sizeof(ULONG);

    if (LengthToCopy > *Length) {

        LengthToCopy = *Length;
        Status = STATUS_BUFFER_OVERFLOW;
    }

    RtlCopyMemory( Buffer->FileName, FileObject->FileName.Buffer, LengthToCopy );

    //
    //  Reduce the available bytes by the amount stored into this buffer.  In the overflow
    //  case, this simply drops to zero.  The returned filenamelength will indicate to the
    //  caller how much space is required.
    //

    *Length -= LengthToCopy;

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdQueryAlternateNameInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN OUT PFILE_NAME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine performs the query alternate name information function.
    We lookup the dirent for this file and then check if there is a
    short name.

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified.

    Ccb - Ccb for this open handle.

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned.

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    NTSTATUS - STATUS_SUCCESS if the whole name would fit into the user buffer,
               STATUS_OBJECT_NAME_NOT_FOUND if we can't return the name,
               STATUS_BUFFER_OVERFLOW otherwise.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    DIRENT_ENUM_CONTEXT DirContext;
    DIRENT Dirent;

    PUNICODE_STRING NameToUse;
    ULONG DirentOffset;

    COMPOUND_PATH_ENTRY CompoundPathEntry;
    FILE_ENUM_CONTEXT FileContext;

    PFCB ParentFcb;
    BOOLEAN ReleaseParentFcb = FALSE;

    BOOLEAN CleanupFileLookup = FALSE;
    BOOLEAN CleanupDirectoryLookup = FALSE;

    WCHAR ShortNameBuffer[ BYTE_COUNT_8_DOT_3 / 2 ];
    USHORT ShortNameLength;

    PAGED_CODE();

    //
    //  Initialize the buffer length to zero.
    //

    Buffer->FileNameLength = 0;

    //
    //  If this is the root or this file was opened using a version number then
    //  there is no short name.
    //

    if ((Fcb == Fcb->Vcb->RootIndexFcb) ||
        FlagOn( Ccb->Flags, CCB_FLAG_OPEN_WITH_VERSION)) {

        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    //  Use a try-finally to cleanup the structures.
    //

    try {

        ParentFcb = Fcb->ParentFcb;
        CdAcquireFileShared( IrpContext, ParentFcb );
        ReleaseParentFcb = TRUE;
    
        //
        //  Do an unsafe test to see if we need to create a file object.
        //

        if (ParentFcb->FileObject == NULL) {

            CdCreateInternalStream( IrpContext, ParentFcb->Vcb, ParentFcb );
        }

        if (CdFidIsDirectory( Fcb->FileId)) {

            //
            //  Fcb is for a directory, so we need to dig the dirent from the parent.  In
            //  order to do this we need to get the name of the directory from its pathtable
            //  entry and then search in the parent for a matching dirent.
            //
            //  This could be optimized somewhat.
            //

            CdInitializeCompoundPathEntry( IrpContext, &CompoundPathEntry );
            CdInitializeFileContext( IrpContext, &FileContext );

            CleanupDirectoryLookup = TRUE;

            CdLookupPathEntry( IrpContext,
                               CdQueryFidPathTableOffset( Fcb->FileId ),
                               Fcb->Ordinal,
                               FALSE,
                               &CompoundPathEntry );

            CdUpdatePathEntryName( IrpContext, &CompoundPathEntry.PathEntry, TRUE );

            if (!CdFindDirectory( IrpContext,
                                  ParentFcb,
                                  &CompoundPathEntry.PathEntry.CdCaseDirName,
                                  TRUE,
                                  &FileContext )) {

                //
                //  If we failed to find the child directory by name in the parent
                //  something is quite wrong with this disc.
                //

                CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
            }

            NameToUse = &FileContext.InitialDirent->Dirent.CdCaseFileName.FileName;
            DirentOffset = FileContext.InitialDirent->Dirent.DirentOffset;
        
        } else {

            //
            //  Initialize the search dirent structures.
            //
        
            CdInitializeDirContext( IrpContext, &DirContext );
            CdInitializeDirent( IrpContext, &Dirent );
    
            CleanupFileLookup = TRUE;
        
            CdLookupDirent( IrpContext,
                            ParentFcb,
                            CdQueryFidDirentOffset( Fcb->FileId ),
                            &DirContext );
    
            CdUpdateDirentFromRawDirent( IrpContext,
                                         ParentFcb,
                                         &DirContext,
                                         &Dirent );

            //
            //  Now update the dirent name.
            //
    
            CdUpdateDirentName( IrpContext, &Dirent, TRUE );
    
            NameToUse = &Dirent.CdCaseFileName.FileName;
            DirentOffset = Dirent.DirentOffset;
        }

        //
        //  If the name is 8.3 then fail this request.
        //

        if (CdIs8dot3Name( IrpContext,
                           *NameToUse )) {


            try_return( Status = STATUS_OBJECT_NAME_NOT_FOUND );
        }

        CdGenerate8dot3Name( IrpContext,
                             NameToUse,
                             DirentOffset,
                             ShortNameBuffer,
                             &ShortNameLength );

        //
        //  We now have the short name.  We have left it in Unicode form so copy it directly.
        //

        Buffer->FileNameLength = ShortNameLength;

        if (Buffer->FileNameLength + sizeof( ULONG ) > *Length) {

            Buffer->FileNameLength = *Length - sizeof( ULONG );
            Status = STATUS_BUFFER_OVERFLOW;
        }

        RtlCopyMemory( Buffer->FileName, ShortNameBuffer, Buffer->FileNameLength );

    try_exit:  NOTHING;
    } finally {

        if (CleanupFileLookup) {

            CdCleanupDirContext( IrpContext, &DirContext );
            CdCleanupDirent( IrpContext, &Dirent );

        } else if (CleanupDirectoryLookup) {

            CdCleanupCompoundPathEntry( IrpContext, &CompoundPathEntry );
            CdCleanupFileContext( IrpContext, &FileContext );
        }

        if (ReleaseParentFcb) {

            CdReleaseFile( IrpContext, ParentFcb );
        }
    }

    //
    //  Reduce the available bytes by the amount stored into this buffer.
    //

    if (Status != STATUS_OBJECT_NAME_NOT_FOUND) {

        *Length -= sizeof( ULONG ) + Buffer->FileNameLength;
    }

    return Status;
}


//
//  Local support routine
//

VOID
CdQueryNetworkInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

 Description:

    This routine performs the query network open information function for Cdfs

Arguments:

    Fcb - Supplies the Fcb being queried, it has been verified

    Buffer - Supplies a pointer to the buffer where the information is to
        be returned

    Length - Supplies the length of the buffer in bytes, and receives the
        remaining bytes free in the buffer upon return.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  We only support creation, last modify and last write times on Cdfs.
    //

    Buffer->LastWriteTime.QuadPart =
    Buffer->CreationTime.QuadPart =
    Buffer->ChangeTime.QuadPart = Fcb->CreationTime;

    Buffer->LastAccessTime.QuadPart = 0;

    Buffer->FileAttributes = Fcb->FileAttributes;

    //
    //  We get the sizes from the header.  Return a size of zero
    //  for all directories.
    //

    if (FlagOn( Fcb->FileAttributes, FILE_ATTRIBUTE_DIRECTORY )) {

        Buffer->AllocationSize.QuadPart =
        Buffer->EndOfFile.QuadPart = 0;

    } else {

        Buffer->AllocationSize.QuadPart = Fcb->AllocationSize.QuadPart;
        Buffer->EndOfFile.QuadPart = Fcb->FileSize.QuadPart;
    }

    //
    //  Update the length and status output variables
    //

    *Length -= sizeof( FILE_NETWORK_OPEN_INFORMATION );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\fspdisp.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    FspDisp.c

Abstract:

    This module implements the main dispatch procedure/thread for the Cdfs
    Fsp

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   02-Jan-1991

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_FSPDISP)


VOID
CdFspDispatch (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This is the main FSP thread routine that is executed to receive
    and dispatch IRP requests.  Each FSP thread begins its execution here.
    There is one thread created at system initialization time and subsequent
    threads created as needed.

Arguments:

    IrpContext - IrpContext for a request to process.

Return Value:

    None

--*/

{
    THREAD_CONTEXT ThreadContext;
    NTSTATUS Status;

    PIRP Irp = IrpContext->Irp;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PVOLUME_DEVICE_OBJECT VolDo = NULL;

    //
    //  If this request has an associated volume device object, remember it.
    //

    if (IrpSp->FileObject != NULL) {

        VolDo = CONTAINING_RECORD( IrpSp->DeviceObject,
                                   VOLUME_DEVICE_OBJECT,
                                   DeviceObject );
    }

    //
    //  Now case on the function code.  For each major function code,
    //  either call the appropriate worker routine.  This routine that
    //  we call is responsible for completing the IRP, and not us.
    //  That way the routine can complete the IRP and then continue
    //  post processing as required.  For example, a read can be
    //  satisfied right away and then read can be done.
    //
    //  We'll do all of the work within an exception handler that
    //  will be invoked if ever some underlying operation gets into
    //  trouble.
    //

    while ( TRUE ) {

        //
        //  Set all the flags indicating we are in the Fsp.
        //

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FSP_FLAGS );

        FsRtlEnterFileSystem();

        CdSetThreadContext( IrpContext, &ThreadContext );

        while (TRUE) {

            try {

                //
                //  Reinitialize for the next try at completing this
                //  request.
                //

                Status =
                IrpContext->ExceptionStatus = STATUS_SUCCESS;

                //
                //  Initialize the Io status field in the Irp.
                //

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = 0;

                //
                //  Case on the major irp code.
                //

                switch (IrpContext->MajorFunction) {

                case IRP_MJ_CREATE :

                    CdCommonCreate( IrpContext, Irp );
                    break;

                case IRP_MJ_CLOSE :

                    ASSERT( FALSE );
                    break;

                case IRP_MJ_READ :

                    CdCommonRead( IrpContext, Irp );
                    break;

                case IRP_MJ_QUERY_INFORMATION :

                    CdCommonQueryInfo( IrpContext, Irp );
                    break;

                case IRP_MJ_SET_INFORMATION :

                    CdCommonSetInfo( IrpContext, Irp );
                    break;

                case IRP_MJ_QUERY_VOLUME_INFORMATION :

                    CdCommonQueryVolInfo( IrpContext, Irp );
                    break;

                case IRP_MJ_DIRECTORY_CONTROL :

                    CdCommonDirControl( IrpContext, Irp );
                    break;

                case IRP_MJ_FILE_SYSTEM_CONTROL :

                    CdCommonFsControl( IrpContext, Irp );
                    break;

                case IRP_MJ_DEVICE_CONTROL :

                    CdCommonDevControl( IrpContext, Irp );
                    break;

                case IRP_MJ_LOCK_CONTROL :

                    CdCommonLockControl( IrpContext, Irp );
                    break;

                case IRP_MJ_CLEANUP :

                    CdCommonCleanup( IrpContext, Irp );
                    break;

                case IRP_MJ_PNP :

                    ASSERT( FALSE );
                    CdCommonPnp( IrpContext, Irp );
                    break;

                default :

                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    CdCompleteRequest( IrpContext, Irp, Status );
                }

            } except( CdExceptionFilter( IrpContext, GetExceptionInformation() )) {

                Status = CdProcessException( IrpContext, Irp, GetExceptionCode() );
            }

            //
            //  Break out of the loop if we didn't get CANT_WAIT.
            //

            if (Status != STATUS_CANT_WAIT) { break; }

            //
            //  We are retrying this request.  Cleanup the IrpContext for the retry.
            //

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
            CdCleanupIrpContext( IrpContext, FALSE );
        }

        FsRtlExitFileSystem();

        //
        //  If there are any entries on this volume's overflow queue, service
        //  them.
        //

        if (VolDo != NULL) {

            KIRQL SavedIrql;
            PVOID Entry = NULL;

            //
            //  We have a volume device object so see if there is any work
            //  left to do in its overflow queue.
            //

            KeAcquireSpinLock( &VolDo->OverflowQueueSpinLock, &SavedIrql );

            if (VolDo->OverflowQueueCount > 0) {

                //
                //  There is overflow work to do in this volume so we'll
                //  decrement the Overflow count, dequeue the IRP, and release
                //  the Event
                //

                VolDo->OverflowQueueCount -= 1;

                Entry = RemoveHeadList( &VolDo->OverflowQueue );
            }

            KeReleaseSpinLock( &VolDo->OverflowQueueSpinLock, SavedIrql );

            //
            //  There wasn't an entry, break out of the loop and return to
            //  the Ex Worker thread.
            //

            if (Entry == NULL) { break; }

            //
            //  Extract the IrpContext , Irp, set wait to TRUE, and loop.
            //

            IrpContext = CONTAINING_RECORD( Entry,
                                            IRP_CONTEXT,
                                            WorkQueueItem.List );

            Irp = IrpContext->Irp;
            IrpSp = IoGetCurrentIrpStackLocation( Irp );

            continue;
        }

        break;
    }

    //
    //  Decrement the PostedRequestCount if there was a volume device object.
    //

    if (VolDo) {

        InterlockedDecrement( &VolDo->PostedRequestCount );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\namesup.c ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

    NameSup.c

Abstract:

    This module implements the Cdfs Name support routines

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_NAMESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdConvertBigToLittleEndian)
#pragma alloc_text(PAGE, CdConvertNameToCdName)
#pragma alloc_text(PAGE, CdDissectName)
#pragma alloc_text(PAGE, CdGenerate8dot3Name)
#pragma alloc_text(PAGE, CdFullCompareNames)
#pragma alloc_text(PAGE, CdIs8dot3Name)
#pragma alloc_text(PAGE, CdIsNameInExpression)
#pragma alloc_text(PAGE, CdShortNameDirentOffset)
#pragma alloc_text(PAGE, CdUpcaseName)
#endif


VOID
CdConvertNameToCdName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PCD_NAME CdName
    )

/*++

Routine Description:

    This routine is called to convert a string of bytes into a CdName.

    The full name is already in the CdName structure in the FileName field.
    We split this into the filename and version strings.

Arguments:

    CdName - Pointer to CdName structure to update.

Return Value:

    None.

--*/

{
    ULONG NameLength = 0;
    PWCHAR CurrentCharacter = CdName->FileName.Buffer;

    PAGED_CODE();

    //
    //  Look for a separator character.
    //

    while ((NameLength < CdName->FileName.Length) &&
           (*CurrentCharacter != L';')) {

        CurrentCharacter += 1;
        NameLength += 2;
    }

    //
    //  If there is at least one more character after a possible separator then it
    //  and all following characters are part of the version string.
    //

    CdName->VersionString.Length = 0;
    if (NameLength + sizeof( WCHAR ) < CdName->FileName.Length) {

        CdName->VersionString.MaximumLength =
        CdName->VersionString.Length = (USHORT) (CdName->FileName.Length - NameLength - sizeof( WCHAR ));
        CdName->VersionString.Buffer = Add2Ptr( CdName->FileName.Buffer,
                                                NameLength + sizeof( WCHAR ),
                                                PWCHAR );
    }

    //
    //  Now update the filename portion of the name.
    //

    CdName->FileName.Length = (USHORT) NameLength;

    return;
}


VOID
CdConvertBigToLittleEndian (
    IN PIRP_CONTEXT IrpContext,
    IN PCHAR BigEndian,
    IN ULONG ByteCount,
    OUT PCHAR LittleEndian
    )

/*++

Routine Description:

    This routine is called to convert a unicode string in big endian to
    little endian.  We start by copying all of the source bytes except
    the first.  This will put the low order bytes in the correct position.
    We then copy each high order byte in its correct position.

Arguments:

    BigEndian - Pointer to the string of big endian characters.

    ByteCount - Number of unicode characters in this string.

    LittleEndian - Pointer to array to store the little endian characters.

Return Value:

    None.

--*/

{
    ULONG RemainingByteCount = ByteCount;

    PCHAR Source = BigEndian;
    PCHAR Destination = LittleEndian;

    PAGED_CODE();

    //
    //  If the byte count isn't an even number then the disk is corrupt.
    //

    if (FlagOn( ByteCount, 1 )) {

        CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
    }

    //
    //  Start by copy the low-order bytes into the correct position.  Do
    //  this by skipping the first byte in the BigEndian string.
    //

    RtlCopyMemory( Destination,
                   Source + 1,
                   RemainingByteCount - 1 );

    //
    //  Now move the high-order bytes into position.
    //

    Destination += 1;

    while (RemainingByteCount != 0) {

        *Destination = *Source;

        Source += 2;
        Destination += 2;

        RemainingByteCount -= 2;
    }

    return;
}


VOID
CdUpcaseName (
    IN PIRP_CONTEXT IrpContext,
    IN PCD_NAME Name,
    IN OUT PCD_NAME UpcaseName
    )

/*++

Routine Description:

    This routine is called to upcase a CdName structure.  We will do both
    the filename and version strings.

Arguments:

    Name - This is the mixed case version of the name.

    UpcaseName - This is the destination for the upcase operation.

Return Value:

    None.  This routine will raise all errors.

--*/

{
    NTSTATUS Status;
    PVOID NewBuffer;

    PAGED_CODE();

    //
    //  If the name structures are different then initialize the different components.
    //

    if (Name != UpcaseName) {

        //
        //  Initialize the version string portion of the name.
        //

        UpcaseName->VersionString.Length = 0;

        if (Name->VersionString.Length != 0) {

            UpcaseName->VersionString.MaximumLength =
            UpcaseName->VersionString.Length = Name->VersionString.Length;

            //
            //  Initially set the buffer to point to where we need to insert
            //  the separator.
            //

            UpcaseName->VersionString.Buffer = Add2Ptr( UpcaseName->FileName.Buffer,
                                                        Name->FileName.Length,
                                                        PWCHAR );

            //
            //  We are currently pointing to the location to store the separator.
            //  Store the ';' and then move to the next character to
            //  copy the data.
            //

            *(UpcaseName->VersionString.Buffer) = L';';

            UpcaseName->VersionString.Buffer += 1;
        }
    }

    //
    //  Upcase the string using the correct upcase routine.
    //

    Status = RtlUpcaseUnicodeString( &UpcaseName->FileName,
                                     &Name->FileName,
                                     FALSE );

    //
    //  This should never fail.
    //

    ASSERT( Status == STATUS_SUCCESS );

    if (Name->VersionString.Length != 0) {

        Status = RtlUpcaseUnicodeString( &UpcaseName->VersionString,
                                         &Name->VersionString,
                                         FALSE );

        //
        //  This should never fail.
        //

        ASSERT( Status == STATUS_SUCCESS );
    }

    return;
}


VOID
CdDissectName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PUNICODE_STRING RemainingName,
    OUT PUNICODE_STRING FinalName
    )

/*++

Routine Description:

    This routine is called to strip off leading components of the name strings.  We search
    for either the end of the string or separating characters.  The input remaining
    name strings should have neither a trailing or leading backslash.

Arguments:

    RemainingName - Remaining name.

    FinalName - Location to store next component of name.

Return Value:

    None.

--*/

{
    ULONG NameLength;
    PWCHAR NextWchar;

    PAGED_CODE();

    //
    //  Find the offset of the next component separators.
    //

    for (NameLength = 0, NextWchar = RemainingName->Buffer;
         (NameLength < RemainingName->Length) && (*NextWchar != L'\\');
         NameLength += sizeof( WCHAR) , NextWchar += 1);

    //
    //  Adjust all the strings by this amount.
    //

    FinalName->Buffer = RemainingName->Buffer;

    FinalName->MaximumLength = FinalName->Length = (USHORT) NameLength;

    //
    //  If this is the last component then set the RemainingName lengths to zero.
    //

    if (NameLength == RemainingName->Length) {

        RemainingName->Length = 0;

    //
    //  Otherwise we adjust the string by this amount plus the separating character.
    //

    } else {

        RemainingName->MaximumLength -= (USHORT) (NameLength + sizeof( WCHAR ));
        RemainingName->Length -= (USHORT) (NameLength + sizeof( WCHAR ));
        RemainingName->Buffer = Add2Ptr( RemainingName->Buffer,
                                         NameLength + sizeof( WCHAR ),
                                         PWCHAR );
    }

    return;
}


BOOLEAN
CdIs8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN UNICODE_STRING FileName
    )

/*++

Routine Description:

    This routine checks if the name follows the 8.3 name conventions.  We check for
    the name length and whether the characters are valid.

Arguments:

    FileName - String of bytes containing the name.

Return Value:

    BOOLEAN - TRUE if this name is a legal 8.3 name, FALSE otherwise.

--*/

{
    CHAR DbcsNameBuffer[ BYTE_COUNT_8_DOT_3 ];
    STRING DbcsName;

    PWCHAR NextWchar;
    ULONG Count;

    ULONG DotCount = 0;
    BOOLEAN LastCharDot = FALSE;

    PAGED_CODE();

    //
    //  The length must be less than 24 bytes.
    //

    ASSERT( FileName.Length != 0 );
    if (FileName.Length > BYTE_COUNT_8_DOT_3) {

        return FALSE;
    }

    //
    //  Walk though and check for a space character.
    //

    NextWchar = FileName.Buffer;
    Count = 0;

    do {

        //
        //  No spaces allowed.
        //

        if (*NextWchar == L' ') { return FALSE; }

        if (*NextWchar == L'.') {

            //
            //  Not an 8.3 name if more than 1 dot or more than 8 characters
            //  remaining.  (It is legal for the dot to be in the ninth
            //  position)
            //

            if ((DotCount > 0) ||
                (Count > 8 * sizeof( WCHAR ))) {

                return FALSE;
            }

            DotCount += 1;
            LastCharDot = TRUE;

        } else {

            LastCharDot = FALSE;
        }

        Count += 2;
        NextWchar += 1;

    } while (Count < FileName.Length);

    //
    //  Go ahead and truncate the dot if at the end.
    //

    if (LastCharDot) {

        FileName.Length -= sizeof( WCHAR );
    }

    //
    //  Create an Oem name to use to check for a valid short name.
    //

    DbcsName.MaximumLength = BYTE_COUNT_8_DOT_3;
    DbcsName.Buffer = DbcsNameBuffer;

    if (!NT_SUCCESS( RtlUnicodeStringToCountedOemString( &DbcsName,
                                                         &FileName,
                                                         FALSE ))) {

        return FALSE;
    }

    //
    //  We have now initialized the Oem string.  Call the FsRtl package to check for a
    //  valid FAT name.
    //

    return FsRtlIsFatDbcsLegal( DbcsName, FALSE, FALSE, FALSE );
}


VOID
CdGenerate8dot3Name (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING FileName,
    IN ULONG DirentOffset,
    OUT PWCHAR ShortFileName,
    OUT PUSHORT ShortByteCount
    )

/*++

Routine Description:

    This routine is called to generate a short name from the given long name.  We will
    generate a short name from the given long name.

    We go through the following steps to make this conversion.

        1 - Generate the generic short name.  This will also be in unicode format.

        2 - Build the string representation of the dirent offset.

        3 - Build the biased short name string by combining the generic short name with
            the dirent offset string.

        4 - Copy the final unicode string back to our caller's buffer.

Arguments:

    FileName - String of bytes containing the name.

    DirentOffset - Offset in the directory for this filename.  We incorporate the offset into
        the short name by dividing this by 32 and prepending a tilde character to the
        digit character.  We then append this to the base of the generated short name.

    ShortFileName - Pointer to the buffer to store the short name into.

    ShortByteCount - Address to store the number of bytes in the short name.

Return Value:

    None.

--*/

{
    UNICODE_STRING ShortName;
    UNICODE_STRING BiasedShortName;
    WCHAR ShortNameBuffer[ BYTE_COUNT_8_DOT_3 / sizeof( WCHAR ) ];
    WCHAR BiasedShortNameBuffer[ BYTE_COUNT_8_DOT_3 / sizeof( WCHAR ) ];

    GENERATE_NAME_CONTEXT NameContext;

    ULONG BiasedDirentOffset;

    ULONG MaximumBaseBytes;
    ULONG BaseNameOffset;

    PWCHAR NextWchar;
    WCHAR ThisWchar;
    USHORT Length;

    BOOLEAN FoundTilde = FALSE;

    OEM_STRING OemName;
    USHORT OemNameOffset = 0;
    BOOLEAN OverflowBuffer = FALSE;

    PAGED_CODE();

    //
    //  Initialize the short string to use the input buffer.
    //

    ShortName.Buffer = ShortNameBuffer;
    ShortName.MaximumLength = BYTE_COUNT_8_DOT_3;

    //
    //  Initialize the name context.
    //

    RtlZeroMemory( &NameContext, sizeof( GENERATE_NAME_CONTEXT ));

    //
    //  We now have the unicode name for the input string.  Go ahead and generate
    //  the short name.
    //

    RtlGenerate8dot3Name( FileName, TRUE, &NameContext, &ShortName );

    //
    //  We now have the generic short name.  We want incorporate the dirent offset
    //  into the name in order to reduce the chance of name conflicts.  We will use
    //  a tilde character followed by a character representation of the dirent offset.
    //  This will be the hexadecimal representation of the dirent offset in the directory.
    //  It is actuall this offset divided by 32 since we don't need the full
    //  granularity.
    //

    BiasedDirentOffset = DirentOffset >> SHORT_NAME_SHIFT;

    //
    //  Point to a local buffer to store the offset string.  We start
    //  at the end of the buffer and work backwards.
    //

    NextWchar = Add2Ptr( BiasedShortNameBuffer,
                         BYTE_COUNT_8_DOT_3,
                         PWCHAR );

    BiasedShortName.MaximumLength = BYTE_COUNT_8_DOT_3;

    //
    //  Generate an OEM version of the string so that we can check for double
    //  byte characters.
    //
    
    RtlUnicodeStringToOemString(&OemName, &ShortName, TRUE);
    
    Length = 0;

    //
    //  Now add the characters for the dirent offset.  We need to start
    //  from the least significant digit and work backwards.
    //

    do {

        NextWchar -= 1;

        ThisWchar = (WCHAR) (BiasedDirentOffset & 0x0000000f);

        //
        //  Store in the next character.  Bias against either '0' or 'A'
        //

        if (ThisWchar <= 9) {

            *NextWchar = ThisWchar + L'0';

        } else {

            *NextWchar = ThisWchar + L'A' - 0xA;
        }

        Length += sizeof( WCHAR );

        //
        //  Shift out the low 4 bits of the offset.
        //

        BiasedDirentOffset >>= 4;

    } while (BiasedDirentOffset != 0);

    //
    //  Now store in the tilde character.
    //

    NextWchar -= 1;
    *NextWchar = L'~';
    Length += sizeof( WCHAR );

    //
    //  Set the length of this string.
    //

    BiasedShortName.Length = Length;
    BiasedShortName.Buffer = NextWchar;

    //
    //  Figure out the maximum number of characters we can copy of the base
    //  name.  We subract the number of characters in the dirent string from 8.
    //  We will copy this many characters or stop when we reach a '.' character
    //  or a '~' character in the name.
    //

    MaximumBaseBytes = 16 - Length;

    BaseNameOffset = 0;

    //
    //  Keep copying from the base name until we hit a '.', '~'  or the end of
    //  the short name.
    //

    NextWchar = ShortFileName;
    Length = 0;

    while ((BaseNameOffset < ShortName.Length) &&
           (ShortName.Buffer[BaseNameOffset / 2] != L'.')) {

        //
        //  Remember if we found a tilde character in the short name,
        //  so we don't copy it or anything following it.
        //

        if (ShortName.Buffer[BaseNameOffset / 2] == L'~') {

            FoundTilde = TRUE;
        }

        //
        // We need to consider the DBCS code page,  because Unicode characters
        // may use 2 bytes as DBCS characters.
        //

        if (FsRtlIsLeadDbcsCharacter(OemName.Buffer[OemNameOffset])) {

            OemNameOffset += 2;

            if ((OemNameOffset + (BiasedShortName.Length / sizeof(WCHAR))) > 8)  {
            
                OverflowBuffer = TRUE;
            }
        }
        else  {
        
            OemNameOffset++;
        }

        //
        //  Only copy the bytes if we still have space for the dirent string.
        //

        if (!FoundTilde && !OverflowBuffer && (BaseNameOffset < MaximumBaseBytes)) {

            *NextWchar = ShortName.Buffer[BaseNameOffset / 2];
            Length += sizeof( WCHAR );
            NextWchar += 1;
        }

        BaseNameOffset += 2;
    }

    RtlFreeOemString(&OemName);

    //
    //  Now copy the dirent string into the biased name buffer.
    //

    RtlCopyMemory( NextWchar,
                   BiasedShortName.Buffer,
                   BiasedShortName.Length );

    Length += BiasedShortName.Length;
    NextWchar += (BiasedShortName.Length / sizeof( WCHAR ));

    //
    //  Now copy any remaining bytes over to the biased short name.
    //

    if (BaseNameOffset != ShortName.Length) {

        RtlCopyMemory( NextWchar,
                       &ShortName.Buffer[BaseNameOffset / 2],
                       ShortName.Length - BaseNameOffset );

        Length += (ShortName.Length - (USHORT) BaseNameOffset);
    }

    //
    //  The final short name is stored in the user's buffer.
    //

    *ShortByteCount = Length;

    return;
}


BOOLEAN
CdIsNameInExpression (
    IN PIRP_CONTEXT IrpContext,
    IN PCD_NAME CurrentName,
    IN PCD_NAME SearchExpression,
    IN ULONG  WildcardFlags,
    IN BOOLEAN CheckVersion
    )

/*++

Routine Description:

    This routine will compare two CdName strings.  We assume that if this
    is to be a case-insensitive search then they are already upcased.

    We compare the filename portions of the name and if they match we
    compare the version strings if requested.

Arguments:

    CurrentName - Filename from the disk.

    SearchExpression - Filename expression to use for match.

    WildcardFlags - Flags field which indicates which parts of the
        search expression might have wildcards.  These flags are the
        same as in the Ccb flags field.

    CheckVersion - Indicates whether we should check both the name and the
        version strings or just the name.

Return Value:

    BOOLEAN - TRUE if the expressions match, FALSE otherwise.

--*/

{
    BOOLEAN Match = TRUE;
    PAGED_CODE();

    //
    //  If there are wildcards in the expression then we call the
    //  appropriate FsRtlRoutine.
    //

    if (FlagOn( WildcardFlags, CCB_FLAG_ENUM_NAME_EXP_HAS_WILD )) {

        Match = FsRtlIsNameInExpression( &SearchExpression->FileName,
                                         &CurrentName->FileName,
                                         FALSE,
                                         NULL );

    //
    //  Otherwise do a direct memory comparison for the name string.
    //

    } else {

        if ((CurrentName->FileName.Length != SearchExpression->FileName.Length) ||
            (!RtlEqualMemory( CurrentName->FileName.Buffer,
                              SearchExpression->FileName.Buffer,
                              CurrentName->FileName.Length ))) {

            Match = FALSE;
        }
    }

    //
    //  Check the version numbers if requested by the user and we have a
    //  match on the name and the version number is present.
    //

    if (Match && CheckVersion && SearchExpression->VersionString.Length &&
        !FlagOn( WildcardFlags, CCB_FLAG_ENUM_VERSION_MATCH_ALL )) {

        //
        //  If there are wildcards in the expression then call the
        //  appropriate search expression.
        //

        if (FlagOn( WildcardFlags, CCB_FLAG_ENUM_VERSION_EXP_HAS_WILD )) {

            Match = FsRtlIsNameInExpression( &SearchExpression->VersionString,
                                             &CurrentName->VersionString,
                                             FALSE,
                                             NULL );

        //
        //  Otherwise do a direct memory comparison for the name string.
        //

        } else {

            if ((CurrentName->VersionString.Length != SearchExpression->VersionString.Length) ||
                (!RtlEqualMemory( CurrentName->VersionString.Buffer,
                                  SearchExpression->VersionString.Buffer,
                                  CurrentName->VersionString.Length ))) {

                Match = FALSE;
            }
        }
    }

    return Match;
}


ULONG
CdShortNameDirentOffset (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine is called to examine a name to see if the dirent offset string is contained.
    This consists of a tilde character followed by the offset represented as a hexadecimal
    characters.  We don't do any other checks to see if this is a short name.  We
    catch that later outside this routine.

Arguments:

    Name - This is the CdName to examine.

Return Value:

    ULONG - MAXULONG if there is no valid dirent offset string embedded, otherwise the
        convert the value to numeric form.

--*/

{
    ULONG ResultOffset = MAXULONG;
    ULONG RemainingByteCount = Name->Length;

    BOOLEAN FoundTilde = FALSE;

    PWCHAR NextWchar;

    PAGED_CODE();

    //
    //  Walk through the name until we either reach the end of the name
    //  or find a tilde character.
    //

    for (NextWchar = Name->Buffer;
         RemainingByteCount != 0;
         NextWchar += 1, RemainingByteCount -= sizeof( WCHAR )) {

        //
        //  Check if this is a dot.  Stop constructing any string if
        //  we found a dot.
        //

        if (*NextWchar == L'.') {

            break;
        }

        //
        //  If we already found a tilde then check this character as a
        //  valid character.  It must be a digit or A to F.
        //

        if (FoundTilde) {

            if ((*NextWchar < L'0') ||
                (*NextWchar > L'F') ||
                ((*NextWchar > L'9') && (*NextWchar < 'A'))) {

                ResultOffset = MAXULONG;
                break;
            }

            //
            //  Shift the result by 4 bits and add in this new character.
            //

            ResultOffset <<= 4;

            if (*NextWchar < L'A') {

                ResultOffset += *NextWchar - L'0';

            } else {

                ResultOffset += (*NextWchar - L'A') + 10;
            }

            continue;
        }

        //
        //  If this is a tilde then start building the dirent string.
        //

        if (*NextWchar == L'~') {

            FoundTilde = TRUE;
            ResultOffset = 0;
        }
    }

    return ResultOffset;
}


//
//  Local support routine
//

FSRTL_COMPARISON_RESULT
CdFullCompareNames (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING NameA,
    IN PUNICODE_STRING NameB
    )

/*++

Routine Description:

    This function compares two names as fast as possible.  Note that since
    this comparison is case sensitive we can do a direct memory comparison.

Arguments:

    NameA & NameB - The names to compare.

Return Value:

    COMPARISON - returns

        LessThan    if NameA < NameB lexicalgraphically,
        GreaterThan if NameA > NameB lexicalgraphically,
        EqualTo     if NameA is equal to NameB

--*/

{
    SIZE_T i;
    ULONG MinLength = NameA->Length;
    FSRTL_COMPARISON_RESULT Result = LessThan;

    PAGED_CODE();

    //
    //  Figure out the minimum of the two lengths
    //

    if (NameA->Length > NameB->Length) {

        MinLength = NameB->Length;
        Result = GreaterThan;

    } else if (NameA->Length == NameB->Length) {

        Result = EqualTo;
    }

    //
    //  Loop through looking at all of the characters in both strings
    //  testing for equalilty, less than, and greater than
    //

    i = RtlCompareMemory( NameA->Buffer, NameB->Buffer, MinLength );

    if (i < MinLength) {

        //
        //  We know the offset of the first character which is different.
        //

        return ((NameA->Buffer[ i / 2 ] < NameB->Buffer[ i / 2 ]) ?
                 LessThan :
                 GreaterThan);
    }

    //
    //  The names match up to the length of the shorter string.
    //  The shorter string lexically appears first.
    //

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\nodetype.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.  Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _CDNODETYPE_
#define _CDNODETYPE_

typedef CSHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                   ((NODE_TYPE_CODE)0x0000)

#define CDFS_NTC_DATA_HEADER            ((NODE_TYPE_CODE)0x0301)
#define CDFS_NTC_VCB                    ((NODE_TYPE_CODE)0x0302)
#define CDFS_NTC_FCB_PATH_TABLE         ((NODE_TYPE_CODE)0x0303)
#define CDFS_NTC_FCB_INDEX              ((NODE_TYPE_CODE)0x0304)
#define CDFS_NTC_FCB_DATA               ((NODE_TYPE_CODE)0x0305)
#define CDFS_NTC_FCB_NONPAGED           ((NODE_TYPE_CODE)0x0306)
#define CDFS_NTC_CCB                    ((NODE_TYPE_CODE)0x0307)
#define CDFS_NTC_IRP_CONTEXT            ((NODE_TYPE_CODE)0x0308)
#define CDFS_NTC_IRP_CONTEXT_LITE       ((NODE_TYPE_CODE)0x0309)

typedef CSHORT NODE_BYTE_SIZE;

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#ifndef NodeType
#define NodeType(P) ((P) != NULL ? (*((PNODE_TYPE_CODE)(P))) : NTC_UNDEFINED)
#endif
#ifndef SafeNodeType
#define SafeNodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))
#endif

//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded in it a source file id
//  (in the high word) and the line number of the bugcheck (in the low word).
//  The other values can be whatever the caller of the bugcheck routine deems
//  necessary.
//
//  Each individual file that calls bugcheck needs to have defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  CDFS_BUG_CHECK_ values defined below and then use CdBugCheck to bugcheck
//  the system.
//

#define CDFS_BUG_CHECK_ACCHKSUP          (0x00010000)
#define CDFS_BUG_CHECK_ALLOCSUP          (0x00020000)
#define CDFS_BUG_CHECK_CACHESUP          (0x00030000)
#define CDFS_BUG_CHECK_CDDATA            (0x00040000)
#define CDFS_BUG_CHECK_CDINIT            (0x00050000)
#define CDFS_BUG_CHECK_CLEANUP           (0x00060000)
#define CDFS_BUG_CHECK_CLOSE             (0x00070000)
#define CDFS_BUG_CHECK_CREATE            (0x00080000)
#define CDFS_BUG_CHECK_DEVCTRL           (0x00090000)
#define CDFS_BUG_CHECK_DEVIOSUP          (0x000a0000)
#define CDFS_BUG_CHECK_DIRCTRL           (0x000b0000)
#define CDFS_BUG_CHECK_DIRSUP            (0x000c0000)
#define CDFS_BUG_CHECK_FILEINFO          (0x000d0000)
#define CDFS_BUG_CHECK_FILOBSUP          (0x000e0000)
#define CDFS_BUG_CHECK_FSCTRL            (0x000f0000)
#define CDFS_BUG_CHECK_FSPDISP           (0x00100000)
#define CDFS_BUG_CHECK_LOCKCTRL          (0x00110000)
#define CDFS_BUG_CHECK_NAMESUP           (0x00120000)
#define CDFS_BUG_CHECK_PATHSUP           (0x00130000)
#define CDFS_BUG_CHECK_PNP               (0x00140000)
#define CDFS_BUG_CHECK_PREFXSUP          (0x00150000)
#define CDFS_BUG_CHECK_READ              (0x00160000)
#define CDFS_BUG_CHECK_RESRCSUP          (0x00170000)
#define CDFS_BUG_CHECK_STRUCSUP          (0x00180000)
#define CDFS_BUG_CHECK_TIMESUP           (0x00190000)
#define CDFS_BUG_CHECK_VERFYSUP          (0x001a0000)
#define CDFS_BUG_CHECK_VOLINFO           (0x001b0000)
#define CDFS_BUG_CHECK_WORKQUE           (0x001c0000)

#define CdBugCheck(A,B,C) { KeBugCheckEx(CDFS_FILE_SYSTEM, BugCheckFileId | __LINE__, A, B, C ); }

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\lockctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    LockCtrl.c

Abstract:

    This module implements the Lock Control routines for Cdfs called
    by the Fsd/Fsp dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_LOCKCTRL)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonLockControl)
#pragma alloc_text(PAGE, CdFastLock)
#pragma alloc_text(PAGE, CdFastUnlockAll)
#pragma alloc_text(PAGE, CdFastUnlockAllByKey)
#pragma alloc_text(PAGE, CdFastUnlockSingle)
#endif


NTSTATUS
CdCommonLockControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for Lock Control called by both the fsd and fsp
    threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Extract and decode the type of file object we're being asked to process
    //

    TypeOfOpen = CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb );

    //
    //  If the file is not a user file open then we reject the request
    //  as an invalid parameter
    //

    if (TypeOfOpen != UserFileOpen) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  We check whether we can proceed based on the state of the file oplocks.
    //  This call might post the irp for us.
    //

    Status = FsRtlCheckOplock( &Fcb->Oplock,
                               Irp,
                               IrpContext,
                               CdOplockComplete,
                               NULL );

    //
    //  If we don't get success then the oplock package completed the request.
    //

    if (Status != STATUS_SUCCESS) {

        return Status;
    }

    //
    //  Verify the Fcb.
    //

    CdVerifyFcbOperation( IrpContext, Fcb );

    //
    //  If we don't have a file lock, then get one now.
    //

    if (Fcb->FileLock == NULL) { CdCreateFileLock( IrpContext, Fcb, TRUE ); }

    //
    //  Now call the FsRtl routine to do the actual processing of the
    //  Lock request
    //

    Status = FsRtlProcessFileLock( Fcb->FileLock, Irp, NULL );

    //
    //  Set the flag indicating if Fast I/O is possible
    //

    CdLockFcb( IrpContext, Fcb );
    Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );
    CdUnlockFcb( IrpContext, Fcb );

    //
    //  Complete the request.
    //

    CdCompleteRequest( IrpContext, NULL, Status );
    return Status;
}


BOOLEAN
CdFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast lock call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    FailImmediately - Indicates if the request should fail immediately
        if the lock cannot be granted.

    ExclusiveLock - Indicates if this is a request for an exclusive or
        shared lock

    IoStatus - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;

    PFCB Fcb;
    TYPE_OF_OPEN TypeOfOpen;

    PAGED_CODE();

    ASSERT_FILE_OBJECT( FileObject );

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!CdVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    FsRtlEnterFileSystem();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_return( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !CdCreateFileLock( NULL, Fcb, FALSE )) {

            try_return( NOTHING );
        }

        //
        //  Now call the FsRtl routine to perform the lock request.
        //

        if (Results = FsRtlFastLock( Fcb->FileLock,
                                     FileObject,
                                     FileOffset,
                                     Length,
                                     ProcessId,
                                     Key,
                                     FailImmediately,
                                     ExclusiveLock,
                                     IoStatus,
                                     NULL,
                                     FALSE )) {

            //
            //  Set the flag indicating if Fast I/O is questionable.  We
            //  only change this flag if the current state is possible.
            //  Retest again after synchronizing on the header.
            //

            if (Fcb->IsFastIoPossible == FastIoIsPossible) {

                CdLockFcb( NULL, Fcb );
                Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );
                CdUnlockFcb( NULL, Fcb );
            }
        }

    try_exit:  NOTHING;
    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}


BOOLEAN
CdFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock single call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;

    PAGED_CODE();

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!CdVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    //
    //  If there is no lock then return immediately.
    //

    if (Fcb->FileLock == NULL) {

        IoStatus->Status = STATUS_RANGE_NOT_LOCKED;
        return TRUE;
    }

    FsRtlEnterFileSystem();

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_return( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !CdCreateFileLock( NULL, Fcb, FALSE )) {

            try_return( NOTHING );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockSingle( Fcb->FileLock,
                                                  FileObject,
                                                  FileOffset,
                                                  Length,
                                                  ProcessId,
                                                  Key,
                                                  NULL,
                                                  FALSE );

        //
        //  Set the flag indicating if Fast I/O is possible.  We are
        //  only concerned if there are no longer any filelocks on this
        //  file.
        //

        if (!FsRtlAreThereCurrentFileLocks( Fcb->FileLock ) &&
            (Fcb->IsFastIoPossible != FastIoIsPossible)) {

            CdLockFcb( IrpContext, Fcb );
            Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );
            CdUnlockFcb( IrpContext, Fcb );
        }

    try_exit:  NOTHING;
    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}


BOOLEAN
CdFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;

    PAGED_CODE();

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!CdVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    //
    //  If there is no lock then return immediately.
    //

    if (Fcb->FileLock == NULL) {

        IoStatus->Status = STATUS_RANGE_NOT_LOCKED;
        return TRUE;
    }

    FsRtlEnterFileSystem();

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_return( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !CdCreateFileLock( NULL, Fcb, FALSE )) {

            try_return( NOTHING );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAll( Fcb->FileLock,
                                               FileObject,
                                               ProcessId,
                                               NULL );


        //
        //  Set the flag indicating if Fast I/O is possible
        //

        CdLockFcb( IrpContext, Fcb );
        Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );
        CdUnlockFcb( IrpContext, Fcb );

    try_exit:  NOTHING;
    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}


BOOLEAN
CdFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all by key call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results = FALSE;
    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;

    PAGED_CODE();

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and
    //  make sure that is is only a user file open.
    //

    TypeOfOpen = CdFastDecodeFileObject( FileObject, &Fcb );

    if (TypeOfOpen != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        return TRUE;
    }

    //
    //  Only deal with 'good' Fcb's.
    //

    if (!CdVerifyFcbOperation( NULL, Fcb )) {

        return FALSE;
    }

    //
    //  If there is no lock then return immediately.
    //

    if (Fcb->FileLock == NULL) {

        IoStatus->Status = STATUS_RANGE_NOT_LOCKED;
        return TRUE;
    }

    FsRtlEnterFileSystem();

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if ((Fcb->Oplock != NULL) && !FsRtlOplockIsFastIoPossible( &Fcb->Oplock )) {

            try_return( NOTHING );
        }

        //
        //  If we don't have a file lock, then get one now.
        //

        if ((Fcb->FileLock == NULL) && !CdCreateFileLock( NULL, Fcb, FALSE )) {

            try_return( NOTHING );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAllByKey( Fcb->FileLock,
                                                    FileObject,
                                                    ProcessId,
                                                    Key,
                                                    NULL );


        //
        //  Set the flag indicating if Fast I/O is possible
        //

        CdLockFcb( IrpContext, Fcb );
        Fcb->IsFastIoPossible = CdIsFastIoPossible( Fcb );
        CdUnlockFcb( IrpContext, Fcb );

    try_exit:  NOTHING;
    } finally {

        FsRtlExitFileSystem();
    }

    return Results;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\prefxsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    PrefxSup.c

Abstract:

    This module implements the Cdfs Prefix support routines

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   07-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_PREFXSUP)

//
//  Local support routines.
//

PNAME_LINK
CdFindNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PUNICODE_STRING Name
    );

BOOLEAN
CdInsertNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PNAME_LINK NameLink
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdFindNameLink)
#pragma alloc_text(PAGE, CdFindPrefix)
#pragma alloc_text(PAGE, CdInsertNameLink)
#pragma alloc_text(PAGE, CdInsertPrefix)
#pragma alloc_text(PAGE, CdRemovePrefix)
#endif


VOID
CdInsertPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PCD_NAME Name,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN ShortNameMatch,
    IN PFCB ParentFcb
    )

/*++

Routine Description:

    This routine inserts the names in the given Lcb into the links for the
    parent.

Arguments:

    Fcb - This is the Fcb whose name is being inserted into the tree.

    Name - This is the name for the component.  The IgnoreCase flag tells
        us which entry this belongs to.

    IgnoreCase - Indicates if we should insert the case-insensitive name.

    ShortNameMatch - Indicates if this is the short name.

    ParentFcb - This is the ParentFcb.  The prefix tree is attached to this.

Return Value:

    None.

--*/

{
    ULONG PrefixFlags;
    PNAME_LINK NameLink;
    PPREFIX_ENTRY PrefixEntry;
    PRTL_SPLAY_LINKS *TreeRoot;

    PWCHAR NameBuffer;

    PAGED_CODE();

    //
    //  Check if we need to allocate a prefix entry for the short name.
    //  If we can't allocate one then fail quietly.  We don't have to
    //  insert the name.
    //

    PrefixEntry = &Fcb->FileNamePrefix;

    if (ShortNameMatch) {

        if (Fcb->ShortNamePrefix == NULL) {

            Fcb->ShortNamePrefix = ExAllocatePoolWithTag( CdPagedPool,
                                                          sizeof( PREFIX_ENTRY ),
                                                          TAG_PREFIX_ENTRY );

            if (Fcb->ShortNamePrefix == NULL) { return; }

            RtlZeroMemory( Fcb->ShortNamePrefix, sizeof( PREFIX_ENTRY ));
        }

        PrefixEntry = Fcb->ShortNamePrefix;
    }

    //
    //  Capture the local variables for the separate cases.
    //

    if (IgnoreCase) {

        PrefixFlags = PREFIX_FLAG_IGNORE_CASE_IN_TREE;
        NameLink = &PrefixEntry->IgnoreCaseName;
        TreeRoot = &ParentFcb->IgnoreCaseRoot;

    } else {

        PrefixFlags = PREFIX_FLAG_EXACT_CASE_IN_TREE;
        NameLink = &PrefixEntry->ExactCaseName;
        TreeRoot = &ParentFcb->ExactCaseRoot;
    }

    //
    //  If neither name is in the tree then check whether we have a buffer for this
    //  name
    //

    if (!FlagOn( PrefixEntry->PrefixFlags,
                 PREFIX_FLAG_EXACT_CASE_IN_TREE | PREFIX_FLAG_IGNORE_CASE_IN_TREE )) {

        //
        //  Allocate a new buffer if the embedded buffer is too small.
        //

        NameBuffer = PrefixEntry->FileNameBuffer;

        if (Name->FileName.Length > BYTE_COUNT_EMBEDDED_NAME) {

            NameBuffer = ExAllocatePoolWithTag( CdPagedPool,
                                                Name->FileName.Length * 2,
                                                TAG_PREFIX_NAME );

            //
            //  Exit if no name buffer.
            //

            if (NameBuffer == NULL) { return; }
        }

        //
        //  Split the buffer and fill in the separate components.
        //

        PrefixEntry->ExactCaseName.FileName.Buffer = NameBuffer;
        PrefixEntry->IgnoreCaseName.FileName.Buffer = Add2Ptr( NameBuffer,
                                                               Name->FileName.Length,
                                                               PWCHAR );

        PrefixEntry->IgnoreCaseName.FileName.MaximumLength =
        PrefixEntry->IgnoreCaseName.FileName.Length =
        PrefixEntry->ExactCaseName.FileName.MaximumLength =
        PrefixEntry->ExactCaseName.FileName.Length = Name->FileName.Length;
    }

    //
    //  Only insert the name if not already present.
    //

    if (!FlagOn( PrefixEntry->PrefixFlags, PrefixFlags )) {

        //
        //  Initialize the name in the prefix entry.
        //

        RtlCopyMemory( NameLink->FileName.Buffer,
                       Name->FileName.Buffer,
                       Name->FileName.Length );

        CdInsertNameLink( IrpContext,
                          TreeRoot,
                          NameLink );

        PrefixEntry->Fcb = Fcb;
        SetFlag( PrefixEntry->PrefixFlags, PrefixFlags );
    }

    return;
}


VOID
CdRemovePrefix (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to remove all of the previx entries of a
    given Fcb from its parent Fcb.

Arguments:

    Fcb - Fcb whose entries are to be removed.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Start with the short name prefix entry.
    //

    if (Fcb->ShortNamePrefix != NULL) {

        if (FlagOn( Fcb->ShortNamePrefix->PrefixFlags, PREFIX_FLAG_IGNORE_CASE_IN_TREE )) {

            Fcb->ParentFcb->IgnoreCaseRoot = RtlDelete( &Fcb->ShortNamePrefix->IgnoreCaseName.Links );
        }

        if (FlagOn( Fcb->ShortNamePrefix->PrefixFlags, PREFIX_FLAG_EXACT_CASE_IN_TREE )) {

            Fcb->ParentFcb->ExactCaseRoot = RtlDelete( &Fcb->ShortNamePrefix->ExactCaseName.Links );
        }

        ClearFlag( Fcb->ShortNamePrefix->PrefixFlags,
                   PREFIX_FLAG_IGNORE_CASE_IN_TREE | PREFIX_FLAG_EXACT_CASE_IN_TREE );
    }

    //
    //  Now do the long name prefix entries.
    //

    if (FlagOn( Fcb->FileNamePrefix.PrefixFlags, PREFIX_FLAG_IGNORE_CASE_IN_TREE )) {

        Fcb->ParentFcb->IgnoreCaseRoot = RtlDelete( &Fcb->FileNamePrefix.IgnoreCaseName.Links );
    }

    if (FlagOn( Fcb->FileNamePrefix.PrefixFlags, PREFIX_FLAG_EXACT_CASE_IN_TREE )) {

        Fcb->ParentFcb->ExactCaseRoot = RtlDelete( &Fcb->FileNamePrefix.ExactCaseName.Links );
    }

    ClearFlag( Fcb->FileNamePrefix.PrefixFlags,
               PREFIX_FLAG_IGNORE_CASE_IN_TREE | PREFIX_FLAG_EXACT_CASE_IN_TREE );

    //
    //  Deallocate any buffer we may have allocated.
    //

    if ((Fcb->FileNamePrefix.ExactCaseName.FileName.Buffer != (PWCHAR) &Fcb->FileNamePrefix.FileNameBuffer) &&
        (Fcb->FileNamePrefix.ExactCaseName.FileName.Buffer != NULL)) {

        CdFreePool( &Fcb->FileNamePrefix.ExactCaseName.FileName.Buffer );
        Fcb->FileNamePrefix.ExactCaseName.FileName.Buffer = NULL;
    }

    return;
}


VOID
CdFindPrefix (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PFCB *CurrentFcb,
    IN OUT PUNICODE_STRING RemainingName,
    IN BOOLEAN IgnoreCase
    )

/*++

Routine Description:

    This routine begins from the given CurrentFcb and walks through all of
    components of the name looking for the longest match in the prefix
    splay trees.  The search is relative to the starting Fcb so the
    full name may not begin with a '\'.  On return this routine will
    update Current Fcb with the lowest point it has travelled in the
    tree.  It will also hold only that resource on return and it must
    hold that resource.

Arguments:

    CurrentFcb - Address to store the lowest Fcb we find on this search.
        On return we will have acquired this Fcb.  On entry this is the
        Fcb to examine.

    RemainingName - Supplies a buffer to store the exact case of the name being
        searched for.  Initially will contain the upcase name based on the
        IgnoreCase flag.

    IgnoreCase - Indicates if we are doing a case-insensitive compare.

Return Value:

    None

--*/

{
    UNICODE_STRING LocalRemainingName;

    UNICODE_STRING FinalName;

    PNAME_LINK NameLink;
    PPREFIX_ENTRY PrefixEntry;

    PAGED_CODE();

    //
    //  Make a local copy of the input strings.
    //

    LocalRemainingName = *RemainingName;

    //
    //  Loop until we find the longest matching prefix.
    //

    while (TRUE) {

        //
        //  If there are no characters left or we are not at an IndexFcb then
        //  return immediately.
        //

        if ((LocalRemainingName.Length == 0) ||
            (SafeNodeType( *CurrentFcb ) != CDFS_NTC_FCB_INDEX)) {

            return;
        }

        //
        //  Split off the next component from the name.
        //

        CdDissectName( IrpContext,
                       &LocalRemainingName,
                       &FinalName );

        //
        //  Check if this name is in the splay tree for this Scb.
        //

        if (IgnoreCase) {

            NameLink = CdFindNameLink( IrpContext,
                                       &(*CurrentFcb)->IgnoreCaseRoot,
                                       &FinalName );

            //
            //  Get the prefix entry from this NameLink.  Don't access any
            //  fields within it until we verify we have a name link.
            //

            PrefixEntry = (PPREFIX_ENTRY) CONTAINING_RECORD( NameLink,
                                                             PREFIX_ENTRY,
                                                             IgnoreCaseName );

        } else {

            NameLink = CdFindNameLink( IrpContext,
                                       &(*CurrentFcb)->ExactCaseRoot,
                                       &FinalName );

            PrefixEntry = (PPREFIX_ENTRY) CONTAINING_RECORD( NameLink,
                                                             PREFIX_ENTRY,
                                                             ExactCaseName );
        }

        //
        //  If we didn't find a match then exit.
        //

        if (NameLink == NULL) { return; }

        //
        //  If this is a case-insensitive match then copy the exact case of the name into
        //  the input buffer.
        //

        if (IgnoreCase) {

            RtlCopyMemory( FinalName.Buffer,
                           PrefixEntry->ExactCaseName.FileName.Buffer,
                           PrefixEntry->ExactCaseName.FileName.Length );
        }

        //
        //  Update the caller's remaining name string to reflect the fact that we found
        //  a match.
        //

        *RemainingName = LocalRemainingName;

        //
        //  Move down to the next component in the tree.  Acquire without waiting.
        //  If this fails then lock the Fcb to reference this Fcb and then drop
        //  the parent and acquire the child.
        //

        if (!CdAcquireFcbExclusive( IrpContext, PrefixEntry->Fcb, TRUE )) {

            //
            //  If we can't wait then raise CANT_WAIT.
            //

            if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

                CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            CdLockVcb( IrpContext, IrpContext->Vcb );
            PrefixEntry->Fcb->FcbReference += 1;
            CdUnlockVcb( IrpContext, IrpContext->Vcb );

            CdReleaseFcb( IrpContext, *CurrentFcb );
            CdAcquireFcbExclusive( IrpContext, PrefixEntry->Fcb, FALSE );

            CdLockVcb( IrpContext, IrpContext->Vcb );
            PrefixEntry->Fcb->FcbReference -= 1;
            CdUnlockVcb( IrpContext, IrpContext->Vcb );

        } else {

            CdReleaseFcb( IrpContext, *CurrentFcb );
        }

        *CurrentFcb = PrefixEntry->Fcb;
    }
}


//
//  Local support routine
//

PNAME_LINK
CdFindNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    This routine searches through a splay link tree looking for a match for the
    input name.  If we find the corresponding name we will rebalance the
    tree.

Arguments:

    RootNode - Supplies the parent to search.

    Name - This is the name to search for.  Note if we are doing a case
        insensitive search the name would have been upcased already.

Return Value:

    PNAME_LINK - The name link found or NULL if there is no match.

--*/

{
    FSRTL_COMPARISON_RESULT Comparison;
    PNAME_LINK Node;
    PRTL_SPLAY_LINKS Links;

    PAGED_CODE();

    Links = *RootNode;

    while (Links != NULL) {

        Node = CONTAINING_RECORD( Links, NAME_LINK, Links );

        //
        //  Compare the prefix in the tree with the full name
        //

        Comparison = CdFullCompareNames( IrpContext, &Node->FileName, Name );

        //
        //  See if they don't match
        //

        if (Comparison == GreaterThan) {

            //
            //  The prefix is greater than the full name
            //  so we go down the left child
            //

            Links = RtlLeftChild( Links );

            //
            //  And continue searching down this tree
            //

        } else if (Comparison == LessThan) {

            //
            //  The prefix is less than the full name
            //  so we go down the right child
            //

            Links = RtlRightChild( Links );

            //
            //  And continue searching down this tree
            //

        } else {

            //
            //  We found it.
            //
            //  Splay the tree and save the new root.
            //

            *RootNode = RtlSplay( Links );

            return Node;
        }
    }

    //
    //  We didn't find the Link.
    //

    return NULL;
}


//
//  Local support routine
//

BOOLEAN
CdInsertNameLink (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PNAME_LINK NameLink
    )

/*++

Routine Description:

    This routine will insert a name in the splay tree pointed to
    by RootNode.

    The name could already exist in this tree for a case-insensitive tree.
    In that case we simply return FALSE and do nothing.

Arguments:

    RootNode - Supplies a pointer to the table.

    NameLink - Contains the new link to enter.

Return Value:

    BOOLEAN - TRUE if the name is inserted, FALSE otherwise.

--*/

{
    FSRTL_COMPARISON_RESULT Comparison;
    PNAME_LINK Node;

    PAGED_CODE();

    RtlInitializeSplayLinks( &NameLink->Links );

    //
    //  If we are the first entry in the tree, just become the root.
    //

    if (*RootNode == NULL) {

        *RootNode = &NameLink->Links;

        return TRUE;
    }

    Node = CONTAINING_RECORD( *RootNode, NAME_LINK, Links );

    while (TRUE) {

        //
        //  Compare the prefix in the tree with the prefix we want
        //  to insert.
        //

        Comparison = CdFullCompareNames( IrpContext, &Node->FileName, &NameLink->FileName );

        //
        //  If we found the entry, return immediately.
        //

        if (Comparison == EqualTo) { return FALSE; }

        //
        //  If the tree prefix is greater than the new prefix then
        //  we go down the left subtree
        //

        if (Comparison == GreaterThan) {

            //
            //  We want to go down the left subtree, first check to see
            //  if we have a left subtree
            //

            if (RtlLeftChild( &Node->Links ) == NULL) {

                //
                //  there isn't a left child so we insert ourselves as the
                //  new left child
                //

                RtlInsertAsLeftChild( &Node->Links, &NameLink->Links );

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a left child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlLeftChild( &Node->Links ),
                                          NAME_LINK,
                                          Links );
            }

        } else {

            //
            //  The tree prefix is either less than or a proper prefix
            //  of the new string.  We treat both cases as less than when
            //  we do insert.  So we want to go down the right subtree,
            //  first check to see if we have a right subtree
            //

            if (RtlRightChild( &Node->Links ) == NULL) {

                //
                //  These isn't a right child so we insert ourselves as the
                //  new right child
                //

                RtlInsertAsRightChild( &Node->Links, &NameLink->Links );

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a right child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlRightChild( &Node->Links ),
                                          NAME_LINK,
                                          Links );
            }
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\pathsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    PathSup.c

Abstract:

    This module implements the Path Table support routines for Cdfs.

    The path table on a CDROM is a condensed summary of the entire
    directory structure.  It is stored on a number of contiguous sectors
    on the disk.  Each directory on the disk has an entry in the path
    table.  The entries are aligned on USHORT boundaries and MAY span
    sector boundaries.  The entries are stored as a breadth-first search.

    The first entry in the table contains the entry for the root.  The
    next entries will consist of the contents of the root directory.  The
    next entries will consist of the all the directories at the next level
    of the tree.  The children of a given directory will be grouped together.

    The directories are assigned ordinal numbers based on their position in
    the path table.  The root dirctory is assigned ordinal value 1.

    Path table sectors:

      Ordinal     1        2        3             4       5        6
                                         +-----------+
                                         | Spanning  |
                                         | Sectors   |
              +----------------------------+  +------------------------+
              |        |        |        | |  |      |         |       |
      DirName |  \     |   a    |    b   |c|  |   c  |    d    |   e   |
              |        |        |        | |  |      |         |       |
      Parent #|  1     |   1    |    1   | |  |   2  |    2    |   3   |
              +----------------------------+  +------------------------+

    Directory Tree:

                                            \ (root)

                                          /   \
                                         /     \
                                        a       b

                                      /   \       \
                                     /     \       \
                                    c       d       e

    Path Table Entries:

        - Position scan at known offset in the path table.  Path Entry at
            this offset must exist and is known to be valid.  Used when
            scanning for the children of a given directory.

        - Position scan at known offset in the path table.  Path Entry is
            known to start at this location but the bounds must be checked
            for validity.

        - Move to next path entry in the table.

        - Update a common path entry structure with the details of the
            on-disk structure.  This is used to smooth out the differences
            in the on-disk structures.

        - Update the filename in the in-memory path entry with the bytes
            off the disk.  For Joliet disks we will have
            to convert to little endian.  We assume that directories
            don't have version numbers.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_PATHSUP)

//
//  Local macros
//

//
//  PRAW_PATH_ENTRY
//  CdRawPathEntry (
//      IN PIRP_CONTEXT IrpContext,
//      IN PPATH_ENUM_CONTEXT PathContext
//      );
//

#define CdRawPathEntry(IC, PC)      \
    Add2Ptr( (PC)->Data, (PC)->DataOffset, PRAW_PATH_ENTRY )

//
//  Local support routines
//

VOID
CdMapPathTableBlock (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG BaseOffset,
    IN OUT PPATH_ENUM_CONTEXT PathContext
    );

BOOLEAN
CdUpdatePathEntryFromRawPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG Ordinal,
    IN BOOLEAN VerifyBounds,
    IN PPATH_ENUM_CONTEXT PathContext,
    OUT PPATH_ENTRY PathEntry
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdFindPathEntry)
#pragma alloc_text(PAGE, CdLookupPathEntry)
#pragma alloc_text(PAGE, CdLookupNextPathEntry)
#pragma alloc_text(PAGE, CdMapPathTableBlock)
#pragma alloc_text(PAGE, CdUpdatePathEntryFromRawPathEntry)
#pragma alloc_text(PAGE, CdUpdatePathEntryName)
#endif


VOID
CdLookupPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG PathEntryOffset,
    IN ULONG Ordinal,
    IN BOOLEAN VerifyBounds,
    IN OUT PCOMPOUND_PATH_ENTRY CompoundPathEntry
    )

/*++

Routine Description:

    This routine is called to initiate a walk through a path table.  We are
    looking for a path table entry at location PathEntryOffset.

Arguments:

    PathEntryOffset - This is our target point in the Path Table.  We know that
        a path entry must begin at this point although we may have to verify
        the bounds.

    Ordinal - Ordinal number for the directory at the PathEntryOffset above.

    VerifyBounds - Indicates whether we need to check the validity of
        this entry.

    CompoundPathEntry - PathEnumeration context and in-memory path entry.  This
        has been initialized outside of this call.

Return Value:

    None.

--*/

{
    PPATH_ENUM_CONTEXT PathContext = &CompoundPathEntry->PathContext;
    LONGLONG CurrentBaseOffset;

    PAGED_CODE();

    //
    //  Compute the starting base and starting path table offset.
    //

    CurrentBaseOffset = SectorTruncate( PathEntryOffset );

    //
    //  Map the next block in the Path Table.
    //

    CdMapPathTableBlock( IrpContext,
                         IrpContext->Vcb->PathTableFcb,
                         CurrentBaseOffset,
                         PathContext );

    //
    //  Set up our current offset into the Path Context.
    //

    PathContext->DataOffset = PathEntryOffset - PathContext->BaseOffset;

    //
    //  Update the in-memory structure for this path entry.
    //

    (VOID) CdUpdatePathEntryFromRawPathEntry( IrpContext,
                                              Ordinal,
                                              VerifyBounds,
                                              &CompoundPathEntry->PathContext,
                                              &CompoundPathEntry->PathEntry );
}


BOOLEAN
CdLookupNextPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PPATH_ENUM_CONTEXT PathContext,
    IN OUT PPATH_ENTRY PathEntry
    )

/*++

Routine Description:

    This routine is called to move to the next path table entry.  We know
    the offset and the length of the current entry.  We start by computing
    the offset of the next entry and determine if it is contained in the
    table.  Then we check to see if we need to move to the next sector in
    the path table.  We always map two sectors at a time so we don't
    have to deal with any path entries which span sectors.  We move to
    the next sector if we are in the second sector of the current mapped
    data block.

    We look up the next entry and update the path entry structure with
    the values out of the raw sector but don't update the CdName structure.

Arguments:

    PathContext - Enumeration context for this scan of the path table.

    PathEntry - In-memory representation of the on-disk path table entry.

Return Value:

    BOOLEAN - TRUE if another entry is found, FALSE otherwise.
        This routine may raise on error.

--*/

{
    LONGLONG CurrentBaseOffset;

    PAGED_CODE();

    //
    //  Get the offset of the next path entry within the current
    //  data block.
    //

    PathContext->DataOffset += PathEntry->PathEntryLength;

    //
    //  If we are in the last data block then check if we are beyond the
    //  end of the file.
    //

    if (PathContext->LastDataBlock) {

        if (PathContext->DataOffset >= PathContext->DataLength) {

            return FALSE;
        }

    //
    //  If we are not in the last data block of the path table and
    //  this offset is in the second sector then move to the next
    //  data block.
    //

    } else if (PathContext->DataOffset >= SECTOR_SIZE) {

        CurrentBaseOffset = PathContext->BaseOffset + SECTOR_SIZE;

        CdMapPathTableBlock( IrpContext,
                             IrpContext->Vcb->PathTableFcb,
                             CurrentBaseOffset,
                             PathContext );

        //
        //  Set up our current offset into the Path Context.
        //

        PathContext->DataOffset -= SECTOR_SIZE;
    }

    //
    //  Now update the path entry with the values from the on-disk
    //  structure.
    //
        
    return CdUpdatePathEntryFromRawPathEntry( IrpContext,
                                              PathEntry->Ordinal + 1,
                                              TRUE,
                                              PathContext,
                                              PathEntry );
}


BOOLEAN
CdFindPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB ParentFcb,
    IN PCD_NAME DirName,
    IN BOOLEAN IgnoreCase,
    IN OUT PCOMPOUND_PATH_ENTRY CompoundPathEntry
    )

/*++

Routine Description:

    This routine will walk through the path table looking for a matching entry for DirName
    among the child directories of the ParentFcb.

Arguments:

    ParentFcb - This is the directory we are examining.  We know the ordinal and path table
        offset for this directory in the path table.  If this is the first scan for this
        Fcb we will update the first child offset for this directory in the path table.

    DirName - This is the name we are searching for.  This name will not contain wildcard
        characters.  The name will also not have a version string.

    IgnoreCase - Indicates if this search is exact or ignore case.

    CompoundPathEntry - Complete path table enumeration structure.  We will have initialized
        it for the search on entry.  This will be positioned at the matching name if found.

Return Value:

    BOOLEAN - TRUE if matching entry found, FALSE otherwise.

--*/

{
    BOOLEAN Found = FALSE;
    BOOLEAN UpdateChildOffset = TRUE;

    ULONG StartingOffset;
    ULONG StartingOrdinal;

    PAGED_CODE();

    //
    //  Position ourselves at either the first child or at the directory itself.
    //  Lock the Fcb to get this value and remember whether to update with the first
    //  child.
    //

    StartingOffset = CdQueryFidPathTableOffset( ParentFcb->FileId );
    StartingOrdinal = ParentFcb->Ordinal;

	//
	//  ISO 9660 9.4.4 restricts the backpointer from child to parent in a
	//  pathtable entry to 16bits. Although we internally store ordinals
	//  as 32bit values, it is impossible to search for the children of a
	//  directory whose ordinal value is greater than MAXUSHORT. Media that
	//  could induce such a search is illegal.
	//
	//  Note that it is not illegal to have more than MAXUSHORT directories.
	//

	if (ParentFcb->Ordinal > MAXUSHORT) {

		CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
	}

    CdLockFcb( IrpContext, ParentFcb );

    if (ParentFcb->ChildPathTableOffset != 0) {

        StartingOffset = ParentFcb->ChildPathTableOffset;
        StartingOrdinal = ParentFcb->ChildOrdinal;
        UpdateChildOffset = FALSE;

    } else if (ParentFcb == ParentFcb->Vcb->RootIndexFcb) {

        UpdateChildOffset = FALSE;
    }

    CdUnlockFcb( IrpContext, ParentFcb );

    CdLookupPathEntry( IrpContext, StartingOffset, StartingOrdinal, FALSE, CompoundPathEntry );

    //
    //  Loop until we find a match or are beyond the children for this directory.
    //

    do {

        //
        //  If we are beyond this directory then return FALSE.
        //

        if (CompoundPathEntry->PathEntry.ParentOrdinal > ParentFcb->Ordinal) {

            //
            //  Update the Fcb with the offsets for the children in the path table.
            //

            if (UpdateChildOffset) {

                CdLockFcb( IrpContext, ParentFcb );

                ParentFcb->ChildPathTableOffset = StartingOffset;
                ParentFcb->ChildOrdinal = StartingOrdinal;

                CdUnlockFcb( IrpContext, ParentFcb );
            }

            break;
        }

        //
        //  If we are within the children of this directory then check for a match.
        //

        if (CompoundPathEntry->PathEntry.ParentOrdinal == ParentFcb->Ordinal) {

            //
            //  Update the child offset if not yet done.
            //

            if (UpdateChildOffset) {

                CdLockFcb( IrpContext, ParentFcb );

                ParentFcb->ChildPathTableOffset = CompoundPathEntry->PathEntry.PathTableOffset;
                ParentFcb->ChildOrdinal = CompoundPathEntry->PathEntry.Ordinal;

                CdUnlockFcb( IrpContext, ParentFcb );

                UpdateChildOffset = FALSE;
            }

            //
            //  Update the name in the path entry.
            //

            CdUpdatePathEntryName( IrpContext, &CompoundPathEntry->PathEntry, IgnoreCase );

            //
            //  Now compare the names for an exact match.
            //

            if (CdIsNameInExpression( IrpContext,
                                      &CompoundPathEntry->PathEntry.CdCaseDirName,
                                      DirName,
                                      0,
                                      FALSE )) {

                //
                //  Let our caller know we have a match.
                //

                Found = TRUE;
                break;
            }
        }

        //
        //  Go to the next entry in the path table.  Remember the current position
        //  in the event we update the Fcb.
        //

        StartingOffset = CompoundPathEntry->PathEntry.PathTableOffset;
        StartingOrdinal = CompoundPathEntry->PathEntry.Ordinal;

    } while (CdLookupNextPathEntry( IrpContext,
                                    &CompoundPathEntry->PathContext,
                                    &CompoundPathEntry->PathEntry ));

    return Found;
}


//
//  Local support routine
//

VOID
CdMapPathTableBlock (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN LONGLONG BaseOffset,
    IN OUT PPATH_ENUM_CONTEXT PathContext
    )

/*++

Routine Description:

    This routine is called to map (or allocate and copy) the next
    data block in the path table.  We check if the next block will
    span a view boundary and allocate an auxilary buffer in that case.

Arguments:

    Fcb - This is the Fcb for the Path Table.

    BaseOffset - Offset of the first sector to map.  This will be on a
        sector boundary.

    PathContext - Enumeration context to update in this routine.

Return Value:

    None.

--*/

{
    ULONG CurrentLength;
    ULONG SectorSize;
    ULONG DataOffset;
    ULONG PassCount;
    PVOID Sector;

    PAGED_CODE();

    //
    //  Map the new block and set the enumeration context to this
    //  point.  Allocate an auxilary buffer if necessary.
    //

    CurrentLength = 2 * SECTOR_SIZE;

    if (CurrentLength >= (ULONG) (Fcb->FileSize.QuadPart - BaseOffset)) {

        CurrentLength = (ULONG) (Fcb->FileSize.QuadPart - BaseOffset);

        //
        //  We know this is the last data block for this
        //  path table.
        //

        PathContext->LastDataBlock = TRUE;
    }

    //
    //  Set context values.
    //

    PathContext->BaseOffset = (ULONG) BaseOffset;
    PathContext->DataLength = CurrentLength;

    //
    //  Drop the previous sector's mapping
    //

    CdUnpinData( IrpContext, &PathContext->Bcb );

    //
    //  Check if spanning a view section.  The following must
    //  be true before we take this step.
    //
    //      Data length is more than one sector.
    //      Starting offset must be one sector before the
    //          cache manager VACB boundary.
    //

    if ((CurrentLength > SECTOR_SIZE) &&
        (FlagOn( ((ULONG) BaseOffset), VACB_MAPPING_MASK ) == LAST_VACB_SECTOR_OFFSET )) {

        //
        //  Map each sector individually and store into an auxilary
        //  buffer.
        //

        SectorSize = SECTOR_SIZE;
        DataOffset = 0;
        PassCount = 2;

        PathContext->Data = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                      CurrentLength,
                                                      TAG_SPANNING_PATH_TABLE );
        PathContext->AllocatedData = TRUE;

        while (PassCount--) {

            CcMapData( Fcb->FileObject,
                       (PLARGE_INTEGER) &BaseOffset,
                       SectorSize,
                       TRUE,
                       &PathContext->Bcb,
                       &Sector );

            RtlCopyMemory( Add2Ptr( PathContext->Data, DataOffset, PVOID ),
                           Sector,
                           SectorSize );

            CdUnpinData( IrpContext, &PathContext->Bcb );

            BaseOffset += SECTOR_SIZE;
            SectorSize = CurrentLength - SECTOR_SIZE;
            DataOffset = SECTOR_SIZE;
        }

    //
    //  Otherwise we can just map the data into the cache.
    //

    } else {

        //
        //  There is a slight chance that we have allocated an
        //  auxilary buffer on the previous sector.
        //

        if (PathContext->AllocatedData) {

            CdFreePool( &PathContext->Data );
            PathContext->AllocatedData = FALSE;
        }

        CcMapData( Fcb->FileObject,
                   (PLARGE_INTEGER) &BaseOffset,
                   CurrentLength,
                   TRUE,
                   &PathContext->Bcb,
                   &PathContext->Data );
    }

    return;
}


//
//  Local support routine
//

BOOLEAN
CdUpdatePathEntryFromRawPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN ULONG Ordinal,
    IN BOOLEAN VerifyBounds,
    IN PPATH_ENUM_CONTEXT PathContext,
    OUT PPATH_ENTRY PathEntry
    )

/*++

Routine Description:

    This routine is called to update the in-memory Path Entry from the on-disk
    path entry.  We also do a careful check of the bounds if requested and we
    are in the last data block of the path table.

Arguments:

    Ordinal - Ordinal number for this directory.

    VerifyBounds - Check that the current raw Path Entry actually fits
        within the data block.

    PathContext - Current path table enumeration context.

    PathEntry - Pointer to the in-memory path entry structure.

Return Value:

    TRUE  if updated ok,  
    FALSE if we've hit the end of the pathtable - zero name length && PT size is a multiple
          of blocksize.  This is a workaround for some Video CDs.  Win 9x works around this.

    This routine may raise.

--*/

{
    PRAW_PATH_ENTRY RawPathEntry = CdRawPathEntry( IrpContext, PathContext );
    ULONG RemainingDataLength;

    PAGED_CODE();
    
    //
    //  Check for a name length of zero.  This is the first byte of the record,
    //  and there must be at least one byte remaining in the buffer else we 
    //  wouldn't be here (caller would have spotted buffer end).
    //
    
    PathEntry->DirNameLen = CdRawPathIdLen( IrpContext, RawPathEntry );
    
    if (0 == PathEntry->DirNameLen) {

        //
        //  If we are in the last block,  and the path table size (ie last block) is a 
        //  multiple of block size,  then we will consider this the end of the path table
        //  rather than raising an error.  Workaround for NTI Cd Maker video CDs which
        //  round path table length to blocksize multiple.  In all other cases we consider
        //  a zero length name to be corruption.
        //
        
        if ( PathContext->LastDataBlock && 
             (0 == BlockOffset( IrpContext->Vcb, PathContext->DataLength)))  {
        
            return FALSE;
        }
        
        CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
    }

    //
    //  Check if we should verify the path entry.  If we are not in the last
    //  data block then there is nothing to check.
    //
    
    if (PathContext->LastDataBlock && VerifyBounds) {

        //
        //  Quick check to see if the maximum size is still available.  This
        //  will handle most cases and we don't need to access any of the
        //  fields.
        //

        RemainingDataLength = PathContext->DataLength - PathContext->DataOffset;

        if (RemainingDataLength < sizeof( RAW_PATH_ENTRY )) {

            //
            //  Make sure the remaining bytes hold the path table entries.
            //  Do the following checks.
            //
            //      - A minimal path table entry will fit (and then check)
            //      - This path table entry (with dir name) will fit.
            //

            if ((RemainingDataLength < MIN_RAW_PATH_ENTRY_LEN) ||
                (RemainingDataLength < (ULONG) (CdRawPathIdLen( IrpContext, RawPathEntry ) + MIN_RAW_PATH_ENTRY_LEN - 1))) {

                CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
            }
        }
    }

    //
    //  The ordinal number of this directory is passed in.
    //  Compute the path table offset of this entry.
    //

    PathEntry->Ordinal = Ordinal;
    PathEntry->PathTableOffset = PathContext->BaseOffset + PathContext->DataOffset;

    //
    //  We know we can safely access all of the fields of the raw path table at
    //  this point.
    
    //
    //  Bias the disk offset by the number of logical blocks
    //

    CopyUchar4( &PathEntry->DiskOffset, CdRawPathLoc( IrpContext, RawPathEntry ));

    PathEntry->DiskOffset += CdRawPathXar( IrpContext, RawPathEntry );

    CopyUchar2( &PathEntry->ParentOrdinal, &RawPathEntry->ParentNum );

    PathEntry->PathEntryLength = PathEntry->DirNameLen + MIN_RAW_PATH_ENTRY_LEN - 1;

    //
    //  Align the path entry length on a ushort boundary.
    //

    PathEntry->PathEntryLength = WordAlign( PathEntry->PathEntryLength );

    PathEntry->DirName = RawPathEntry->DirId;

    return TRUE;
}


//
//  Local support routine
//

VOID
CdUpdatePathEntryName (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PPATH_ENTRY PathEntry,
    IN BOOLEAN IgnoreCase
    )

/*++

Routine Description:

    This routine will store the directory name into the CdName in the
    path entry.  If this is a Joliet name then we will make sure we have
    an allocated buffer and need to convert from big endian to little
    endian.  We also correctly update the case name.  If this operation is ignore
    case then we need an auxilary buffer for the name.

    For an Ansi disk we can use the name from the disk for the exact case.  We only
    need to allocate a buffer for the ignore case name.  The on-disk representation of
    a Unicode name is useless for us.  In this case we will need a name buffer for
    both names.  We store a buffer in the PathEntry which can hold two 8.3 unicode
    names.  This means we will almost never need to allocate a buffer in the Ansi case
    (we only need one buffer and already have 48 characters).

Arguments:

    PathEntry - Pointer to a path entry structure.  We have already updated
        this path entry with the values from the raw path entry.

Return Value:

    None.

--*/

{
    ULONG Length;
    NTSTATUS Status;

    PAGED_CODE();

    //
    //  Check if this is a self entry.  We use a fixed string for this.
    //
    //      Self-Entry - Length is 1, value is 0.
    //

    if ((*PathEntry->DirName == 0) &&
        (PathEntry->DirNameLen == 1)) {

        //
        //  There should be no allocated buffers.
        //

        ASSERT( !FlagOn( PathEntry->Flags, PATH_ENTRY_FLAG_ALLOC_BUFFER ));

        //
        //  Now use one of the hard coded directory names.
        //

        PathEntry->CdDirName.FileName = CdUnicodeDirectoryNames[0];

        //
        //  Show that there is no version number.
        //

        PathEntry->CdDirName.VersionString.Length = 0;

        //
        //  The case name is identical.
        //

        PathEntry->CdCaseDirName = PathEntry->CdDirName;

        //
        //  Return now.
        //

        return;
    }

    //
    //  Compute how large a buffer we will need.  If this is an ignore
    //  case operation then we will want a double size buffer.  If the disk is not
    //  a Joliet disk then we might need two bytes for each byte in the name.
    //

    Length = PathEntry->DirNameLen;

    if (IgnoreCase) {

        Length *= 2;
    }

    if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_JOLIET )) {

        Length *= sizeof( WCHAR );
    }

    //
    //  Now decide if we need to allocate a new buffer.  We will if
    //  this name won't fit in the embedded name buffer and it is
    //  larger than the current allocated buffer.  We always use the
    //  allocated buffer if present.
    //
    //  If we haven't allocated a buffer then use the embedded buffer if the data
    //  will fit.  This is the typical case.
    //

    if (!FlagOn( PathEntry->Flags, PATH_ENTRY_FLAG_ALLOC_BUFFER ) &&
        (Length <= sizeof( PathEntry->NameBuffer ))) {

        PathEntry->CdDirName.FileName.MaximumLength = sizeof( PathEntry->NameBuffer );
        PathEntry->CdDirName.FileName.Buffer = PathEntry->NameBuffer;

    } else {

        //
        //  We need to use an allocated buffer.  Check if the current buffer
        //  is large enough.
        //

        if (Length > PathEntry->CdDirName.FileName.MaximumLength) {

            //
            //  Free any allocated buffer.
            //

            if (FlagOn( PathEntry->Flags, PATH_ENTRY_FLAG_ALLOC_BUFFER )) {

                CdFreePool( &PathEntry->CdDirName.FileName.Buffer );
                ClearFlag( PathEntry->Flags, PATH_ENTRY_FLAG_ALLOC_BUFFER );
            }

            PathEntry->CdDirName.FileName.Buffer = FsRtlAllocatePoolWithTag( CdPagedPool,
                                                                             Length,
                                                                             TAG_PATH_ENTRY_NAME );

            SetFlag( PathEntry->Flags, PATH_ENTRY_FLAG_ALLOC_BUFFER );

            PathEntry->CdDirName.FileName.MaximumLength = (USHORT) Length;
        }
    }

    //
    //  We now have a buffer for the name.  We need to either convert the on-disk bigendian
    //  to little endian or covert the name to Unicode.
    //

    if (!FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_JOLIET )) {

        Status = RtlOemToUnicodeN( PathEntry->CdDirName.FileName.Buffer,
                                   PathEntry->CdDirName.FileName.MaximumLength,
                                   &Length,
                                   PathEntry->DirName,
                                   PathEntry->DirNameLen );

        ASSERT( Status == STATUS_SUCCESS );
        PathEntry->CdDirName.FileName.Length = (USHORT) Length;

    } else {

        //
        //  Convert this string to little endian.
        //

        CdConvertBigToLittleEndian( IrpContext,
                                    PathEntry->DirName,
                                    PathEntry->DirNameLen,
                                    (PCHAR) PathEntry->CdDirName.FileName.Buffer );

        PathEntry->CdDirName.FileName.Length = (USHORT) PathEntry->DirNameLen;
    }

    //
    //  There is no version string.
    //

    PathEntry->CdDirName.VersionString.Length =
    PathEntry->CdCaseDirName.VersionString.Length = 0;

    //
    //  If the name string ends with a period then knock off the last
    //  character.
    //

    if (PathEntry->CdDirName.FileName.Buffer[(PathEntry->CdDirName.FileName.Length - sizeof( WCHAR )) / 2] == L'.') {

        //
        //  Shrink the filename length.
        //

        PathEntry->CdDirName.FileName.Length -= sizeof( WCHAR );
    }

    //
    //  Update the case name buffer if necessary.  If this is an exact case
    //  operation then just copy the exact case string.
    //

    if (IgnoreCase) {

        PathEntry->CdCaseDirName.FileName.Buffer = Add2Ptr( PathEntry->CdDirName.FileName.Buffer,
                                                            PathEntry->CdDirName.FileName.MaximumLength / 2,
                                                            PWCHAR);

        PathEntry->CdCaseDirName.FileName.MaximumLength = PathEntry->CdDirName.FileName.MaximumLength / 2;

        CdUpcaseName( IrpContext,
                      &PathEntry->CdDirName,
                      &PathEntry->CdCaseDirName );

    } else {

        PathEntry->CdCaseDirName = PathEntry->CdDirName;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\read.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Read.c

Abstract:

    This module implements the File Read routine for Read called by the
    Fsd/Fsp dispatch drivers.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_READ)

//
//  VOID
//  SafeZeroMemory (
//      IN PUCHAR At,
//      IN ULONG ByteCount
//      );
//

//
//  This macro just puts a nice little try-except around RtlZeroMemory
//

#define SafeZeroMemory(IC,AT,BYTE_COUNT) {                  \
    try {                                                   \
        RtlZeroMemory( (AT), (BYTE_COUNT) );                \
    } except( EXCEPTION_EXECUTE_HANDLER ) {                 \
         CdRaiseStatus( IC, STATUS_INVALID_USER_BUFFER );   \
    }                                                       \
}

//
// Read ahead amount used for normal data files
//

#define READ_AHEAD_GRANULARITY           (0x10000)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonRead)
#endif


NTSTATUS
CdCommonRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common entry point for NtReadFile calls.  For synchronous requests,
    CommonRead will complete the request in the current thread.  If not
    synchronous the request will be passed to the Fsp if there is a need to
    block.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The result of this operation.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN Wait;
    ULONG PagingIo;
    ULONG SynchronousIo;
    ULONG NonCachedIo;
    PVOID UserBuffer;

    LONGLONG StartingOffset;
    LONGLONG ByteRange;
    ULONG ByteCount;
    ULONG ReadByteCount;
    ULONG OriginalByteCount;

    PVOID SystemBuffer;

    BOOLEAN ReleaseFile = TRUE;

    CD_IO_CONTEXT LocalIoContext;

    PAGED_CODE();

    //
    //  If this is a zero length read then return SUCCESS immediately.
    //

    if (IrpSp->Parameters.Read.Length == 0) {

        CdCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  Decode the file object and verify we support read on this.  It
    //  must be a user file, stream file or volume file (for a data disk).
    //

    TypeOfOpen = CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb );

    if ((TypeOfOpen == UnopenedFileObject) ||
        (TypeOfOpen == UserDirectoryOpen)) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_DEVICE_REQUEST );
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    //  Examine our input parameters to determine if this is noncached and/or
    //  a paging io operation.
    //

    Wait = BooleanFlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
    PagingIo = FlagOn( Irp->Flags, IRP_PAGING_IO );
    NonCachedIo = FlagOn( Irp->Flags, IRP_NOCACHE );
    SynchronousIo = FlagOn( IrpSp->FileObject->Flags, FO_SYNCHRONOUS_IO );


    //
    //  Extract the range of the Io.
    //

    StartingOffset = IrpSp->Parameters.Read.ByteOffset.QuadPart;
    OriginalByteCount = ByteCount = IrpSp->Parameters.Read.Length;

    ByteRange = StartingOffset + ByteCount;

    //
    //  Make sure that Dasd access is always non-cached.
    //

    if (TypeOfOpen == UserVolumeOpen) {

        NonCachedIo = TRUE;
    }

    //
    //  Acquire the file shared to perform the read.  If we are doing paging IO,
    //  it may be the case that we would have a deadlock imminent because we may
    //  block on shared access, so starve out any exclusive waiters.  This requires
    //  a degree of caution - we believe that any paging IO bursts will recede and
    //  allow the exclusive waiter in.
    //

    if (PagingIo) {

        CdAcquireFileSharedStarveExclusive( IrpContext, Fcb );
    
    } else {
        
        CdAcquireFileShared( IrpContext, Fcb );
    }

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Fcb.  Allow reads if this is a DASD handle that is 
        //  dismounting the volume.
        //

        if ((TypeOfOpen != UserVolumeOpen) || (NULL == Ccb) ||
            !FlagOn( Ccb->Flags, CCB_FLAG_DISMOUNT_ON_CLOSE))  {
        
            CdVerifyFcbOperation( IrpContext, Fcb );
        }

        //
        //  If this is a non-cached then check whether we need to post this
        //  request if this thread can't block.
        //

        if (!Wait && NonCachedIo) {

            //
            //  XA requests must always be waitable.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_RAWSECTOR_MASK )) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );
                try_return( Status = STATUS_CANT_WAIT );
            }
        }

        //
        //  If this is a user request then verify the oplock and filelock state.
        //

        if (TypeOfOpen == UserFileOpen) {

            //
            //  We check whether we can proceed
            //  based on the state of the file oplocks.
            //

            Status = FsRtlCheckOplock( &Fcb->Oplock,
                                       Irp,
                                       IrpContext,
                                       CdOplockComplete,
                                       CdPrePostIrp );

            //
            //  If the result is not STATUS_SUCCESS then the Irp was completed
            //  elsewhere.
            //

            if (Status != STATUS_SUCCESS) {

                Irp = NULL;
                IrpContext = NULL;

                try_return( NOTHING );
            }

            if (!PagingIo &&
                (Fcb->FileLock != NULL) &&
                !FsRtlCheckLockForReadAccess( Fcb->FileLock, Irp )) {

                try_return( Status = STATUS_FILE_LOCK_CONFLICT );
            }
        }

        //
        //  Complete the request if it begins beyond the end of file.
        //

        if (StartingOffset >= Fcb->FileSize.QuadPart) {

            try_return( Status = STATUS_END_OF_FILE );
        }

        //
        //  Truncate the read if it extends beyond the end of the file.
        //

        if (ByteRange > Fcb->FileSize.QuadPart) {

            ByteCount = (ULONG) (Fcb->FileSize.QuadPart - StartingOffset);
            ByteRange = Fcb->FileSize.QuadPart;
        }

        //
        //  Handle the non-cached read first.
        //

        if (NonCachedIo) {

            //
            //  If we have an unaligned transfer then post this request if
            //  we can't wait.  Unaligned means that the starting offset
            //  is not on a sector boundary or the read is not integral
            //  sectors.
            //

            ReadByteCount = BlockAlign( Fcb->Vcb, ByteCount );

            if (SectorOffset( StartingOffset ) ||
                SectorOffset( ReadByteCount ) ||
                (ReadByteCount > OriginalByteCount)) {

                if (!Wait) {

                    CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
                }

                //
                //  Make sure we don't overwrite the buffer.
                //

                ReadByteCount = ByteCount;
            }

            //
            //  Initialize the IoContext for the read.
            //  If there is a context pointer, we need to make sure it was
            //  allocated and not a stale stack pointer.
            //

            if (IrpContext->IoContext == NULL ||
                !FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO )) {

                //
                //  If we can wait, use the context on the stack.  Otherwise
                //  we need to allocate one.
                //

                if (Wait) {

                    IrpContext->IoContext = &LocalIoContext;
                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );

                } else {

                    IrpContext->IoContext = CdAllocateIoContext();
                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );
                }
            }

            RtlZeroMemory( IrpContext->IoContext, sizeof( CD_IO_CONTEXT ));

            //
            //  Store whether we allocated this context structure in the structure
            //  itself.
            //

            IrpContext->IoContext->AllocatedContext =
                BooleanFlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO );

            if (Wait) {

                KeInitializeEvent( &IrpContext->IoContext->SyncEvent,
                                   NotificationEvent,
                                   FALSE );

            } else {

                IrpContext->IoContext->ResourceThreadId = ExGetCurrentResourceThread();
                IrpContext->IoContext->Resource = Fcb->Resource;
                IrpContext->IoContext->RequestedByteCount = ByteCount;
            }

            Irp->IoStatus.Information = ReadByteCount;

            //
            //  Call one of the NonCacheIo routines to perform the actual
            //  read.
            //

            if (FlagOn( Fcb->FcbState, FCB_STATE_RAWSECTOR_MASK )) {

                Status = CdNonCachedXARead( IrpContext, Fcb, StartingOffset, ReadByteCount );

            } else {

                Status = CdNonCachedRead( IrpContext, Fcb, StartingOffset, ReadByteCount );
            }

            //
            //  Don't complete this request now if STATUS_PENDING was returned.
            //

            if (Status == STATUS_PENDING) {

                Irp = NULL;
                ReleaseFile = FALSE;

            //
            //  Test is we should zero part of the buffer or update the
            //  synchronous file position.
            //

            } else {

                //
                //  Convert any unknown error code to IO_ERROR.
                //

                if (!NT_SUCCESS( Status )) {

                    //
                    //  Set the information field to zero.
                    //

                    Irp->IoStatus.Information = 0;

                    //
                    //  Raise if this is a user induced error.
                    //

                    if (IoIsErrorUserInduced( Status )) {

                        CdRaiseStatus( IrpContext, Status );
                    }

                    Status = FsRtlNormalizeNtstatus( Status, STATUS_UNEXPECTED_IO_ERROR );

                //
                //  Check if there is any portion of the user's buffer to zero.
                //

                } else if (ReadByteCount != ByteCount) {

                    CdMapUserBuffer( IrpContext, &UserBuffer);
                    
                    SafeZeroMemory( IrpContext,
                                    Add2Ptr( UserBuffer,
                                             ByteCount,
                                             PVOID ),
                                    ReadByteCount - ByteCount );

                    Irp->IoStatus.Information = ByteCount;
                }

                //
                //  Update the file position if this is a synchronous request.
                //

                if (SynchronousIo && !PagingIo && NT_SUCCESS( Status )) {

                    IrpSp->FileObject->CurrentByteOffset.QuadPart = ByteRange;
                }
            }

            try_return( NOTHING );
        }

        //
        //  Handle the cached case.  Start by initializing the private
        //  cache map.
        //

        if (IrpSp->FileObject->PrivateCacheMap == NULL) {

            //
            //  Now initialize the cache map.
            //

            CcInitializeCacheMap( IrpSp->FileObject,
                                  (PCC_FILE_SIZES) &Fcb->AllocationSize,
                                  FALSE,
                                  &CdData.CacheManagerCallbacks,
                                  Fcb );

            CcSetReadAheadGranularity( IrpSp->FileObject, READ_AHEAD_GRANULARITY );
        }

        //
        //  Read from the cache if this is not an Mdl read.
        //

        if (!FlagOn( IrpContext->MinorFunction, IRP_MN_MDL )) {

            //
            // If we are in the Fsp now because we had to wait earlier,
            // we must map the user buffer, otherwise we can use the
            // user's buffer directly.
            //

            CdMapUserBuffer( IrpContext, &SystemBuffer );

            //
            // Now try to do the copy.
            //

            if (!CcCopyRead( IrpSp->FileObject,
                             (PLARGE_INTEGER) &StartingOffset,
                             ByteCount,
                             Wait,
                             SystemBuffer,
                             &Irp->IoStatus )) {

                try_return( Status = STATUS_CANT_WAIT );
            }

            //
            //  If the call didn't succeed, raise the error status
            //

            if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                CdNormalizeAndRaiseStatus( IrpContext, Irp->IoStatus.Status );
            }

        //
        //  Otherwise perform the MdlRead operation.
        //

        } else {

            CcMdlRead( IrpSp->FileObject,
                       (PLARGE_INTEGER) &StartingOffset,
                       ByteCount,
                       &Irp->MdlAddress,
                       &Irp->IoStatus );

            Status = Irp->IoStatus.Status;
        }

        //
        //  Update the current file position in the user file object.
        //

        if (SynchronousIo && !PagingIo && NT_SUCCESS( Status )) {

            IrpSp->FileObject->CurrentByteOffset.QuadPart = ByteRange;
        }

    try_exit:  NOTHING;
    } finally {

        //
        //  Release the Fcb.
        //

        if (ReleaseFile) {

            CdReleaseFile( IrpContext, Fcb );
        }
    }

    //
    //  Post the request if we got CANT_WAIT.
    //

    if (Status == STATUS_CANT_WAIT) {

        Status = CdFsdPostRequest( IrpContext, Irp );

    //
    //  Otherwise complete the request.
    //

    } else {

        CdCompleteRequest( IrpContext, Irp, Status );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\pnp.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    Pnp.c

Abstract:

    This module implements the Plug and Play routines for CDFS called by
    the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     23-Jul-1997

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_PNP)

NTSTATUS
CdPnpQueryRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
CdPnpRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
CdPnpSurpriseRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
CdPnpCancelRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
CdPnpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonPnp)
#pragma alloc_text(PAGE, CdPnpCancelRemove)
#pragma alloc_text(PAGE, CdPnpQueryRemove)
#pragma alloc_text(PAGE, CdPnpRemove)
#pragma alloc_text(PAGE, CdPnpSurpriseRemove)
#endif


NTSTATUS
CdCommonPnp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing PnP operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    BOOLEAN PassThrough = FALSE;
    
    PIO_STACK_LOCATION IrpSp;

    PVOLUME_DEVICE_OBJECT OurDeviceObject;
    PVCB Vcb;

    //
    //  Get the current Irp stack location.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Find our Vcb.  This is tricky since we have no file object in the Irp.
    //

    OurDeviceObject = (PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject;

    //
    //  IO holds a handle reference on our VDO and holds the device lock, which 
    //  syncs us against mounts/verifies.  However we hold no reference on the 
    //  volume, which may already have been torn down (and the Vpb freed), for 
    //  example by a force dismount. Check for this condition. We must hold this
    //  lock until the pnp worker functions take additional locks/refs on the Vcb.
    //

    CdAcquireCdData( IrpContext);
    
    //
    //  Make sure this device object really is big enough to be a volume device
    //  object.  If it isn't, we need to get out before we try to reference some
    //  field that takes us past the end of an ordinary device object.    
    //
    
    if (OurDeviceObject->DeviceObject.Size != sizeof(VOLUME_DEVICE_OBJECT) ||
        NodeType( &OurDeviceObject->Vcb ) != CDFS_NTC_VCB) {
        
        //
        //  We were called with something we don't understand.
        //
        
        Status = STATUS_INVALID_PARAMETER;
        CdReleaseCdData( IrpContext);
        CdCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Force all PnP operations to be synchronous.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    Vcb = &OurDeviceObject->Vcb;

    //
    //  Check that the Vcb hasn't already been deleted.  If so,  just pass the
    //  request through to the driver below,  we don't need to do anything.
    //
    
    if (NULL == Vcb->Vpb) {

        PassThrough = TRUE;
    }
    else {

        //
        //  Case on the minor code.
        //
        
        switch ( IrpSp->MinorFunction ) {

            case IRP_MN_QUERY_REMOVE_DEVICE:
                
                Status = CdPnpQueryRemove( IrpContext, Irp, Vcb );
                break;
            
            case IRP_MN_SURPRISE_REMOVAL:
            
                Status = CdPnpSurpriseRemove( IrpContext, Irp, Vcb );
                break;

            case IRP_MN_REMOVE_DEVICE:

                Status = CdPnpRemove( IrpContext, Irp, Vcb );
                break;

            case IRP_MN_CANCEL_REMOVE_DEVICE:
        
                Status = CdPnpCancelRemove( IrpContext, Irp, Vcb );
                break;

            default:

                PassThrough = TRUE;
                break;
        }
    }

    if (PassThrough) {

        CdReleaseCdData( IrpContext);

        //
        //  Just pass the IRP on.  As we do not need to be in the
        //  way on return, ellide ourselves out of the stack.
        //
        
        IoSkipCurrentIrpStackLocation( Irp );

        Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);
        
        //
        //  Cleanup our Irp Context.  The driver has completed the Irp.
        //
    
        CdCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
    }
        
    return Status;
}


NTSTATUS
CdPnpQueryRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP query remove operation.  The filesystem
    is responsible for answering whether there are any reasons it sees
    that the volume can not go away (and the device removed).  Initiation
    of the dismount begins when we answer yes to this question.
    
    Query will be followed by a Cancel or Remove.

Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being queried.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbPresent = TRUE;

    ASSERT_EXCLUSIVE_CDDATA;

    //
    //  Having said yes to a QUERY, any communication with the
    //  underlying storage stack is undefined (and may block)
    //  until the bounding CANCEL or REMOVE is sent.
    //
    //  Acquire the global resource so that we can try to vaporize the volume, 
    //  and the vcb resource itself.
    //

    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  Drop a reference on the Vcb to keep it around after we drop the locks.
    //
    
    CdLockVcb( IrpContext, Vcb);
    Vcb->VcbReference += 1;
    CdUnlockVcb( IrpContext, Vcb);
    
    CdReleaseCdData( IrpContext);

    Status = CdLockVolumeInternal( IrpContext, Vcb, NULL );

    //
    //  Reacquire the global lock,  which means dropping the Vcb resource.
    //
    
    CdReleaseVcb( IrpContext, Vcb );
    
    CdAcquireCdData( IrpContext );
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  Remove our extra reference.
    //
    
    CdLockVcb( IrpContext, Vcb);
    Vcb->VcbReference -= 1;
    CdUnlockVcb( IrpContext, Vcb);
    
    if (NT_SUCCESS( Status )) {

        //
        //  We need to pass this down before starting the dismount, which
        //  could disconnect us immediately from the stack.
        //
        
        //
        //  Get the next stack location, and copy over the stack location
        //

        IoCopyCurrentIrpStackLocationToNext( Irp );

        //
        //  Set up the completion routine
        //
    
        KeInitializeEvent( &Event, NotificationEvent, FALSE );
        IoSetCompletionRoutine( Irp,
                                CdPnpCompletionRoutine,
                                &Event,
                                TRUE,
                                TRUE,
                                TRUE );

        //
        //  Send the request and wait.
        //

        Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

        if (Status == STATUS_PENDING) {

            KeWaitForSingleObject( &Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL );

            Status = Irp->IoStatus.Status;
        }

        //
        //  Now if no one below us failed already, initiate the dismount
        //  on this volume, make it go away.  PnP needs to see our internal
        //  streams close and drop their references to the target device.
        //
        //  Since we were able to lock the volume, we are guaranteed to
        //  move this volume into dismount state and disconnect it from
        //  the underlying storage stack.  The force on our part is actually
        //  unnecesary, though complete.
        //
        //  What is not strictly guaranteed, though, is that the closes
        //  for the metadata streams take effect synchronously underneath
        //  of this call.  This would leave references on the target device
        //  even though we are disconnected!
        //

        if (NT_SUCCESS( Status )) {
            
            VcbPresent = CdCheckForDismount( IrpContext, Vcb, TRUE );
    
            ASSERT( !VcbPresent || Vcb->VcbCondition == VcbDismountInProgress );
        }

        //
        //  Note: Normally everything will complete and the internal streams will 
        //  vaporise.  However there is some code in the system which drops additional
        //  references on fileobjects,  including our internal stream file objects,
        //  for (WMI) tracing purposes.  If that happens to run concurrently with our
        //  teardown, our internal streams will not vaporise until those references
        //  are removed.  So it's possible that the volume still remains at this 
        //  point.  The pnp query remove will fail due to our references on the device.
        //  To be cleaner we will return an error here.  We could pend the pnp
        //  IRP until the volume goes away, but since we don't know when that will
        //  be, and this is a very rare case, we'll just fail the query.
        //
        //  The reason this is the case is that handles/fileobjects place a reference
        //  on the device objects they overly.  In the filesystem case, these references
        //  are on our target devices.  PnP correcly thinks that if references remain
        //  on the device objects in the stack that someone has a handle, and that this
        //  counts as a reason to not succeed the query - even though every interrogated
        //  driver thinks that it is OK.
        //

        if (NT_SUCCESS( Status) && VcbPresent && (Vcb->VcbReference != 0)) {

            Status = STATUS_DEVICE_BUSY;
        }
    }
    
    //
    //  Release the Vcb if it could still remain.
    //
    
    if (VcbPresent) {

        CdReleaseVcb( IrpContext, Vcb );
    }

    CdReleaseCdData( IrpContext );
    
    //
    //  Cleanup our IrpContext and complete the IRP if neccesary.
    //

    CdCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
CdPnpRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP remove operation.  This is our notification
    that the underlying storage device for the volume we have is gone, and
    an excellent indication that the volume will never reappear. The filesystem
    is responsible for initiation or completion the dismount.

Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbPresent = TRUE;

    ASSERT_EXCLUSIVE_CDDATA;

    //
    //  REMOVE - a storage device is now gone.  We either got
    //  QUERY'd and said yes OR got a SURPRISE OR a storage
    //  stack failed to spin back up from a sleep/stop state
    //  (the only case in which this will be the first warning).
    //
    //  Note that it is entirely unlikely that we will be around
    //  for a REMOVE in the first two cases, as we try to intiate
    //  dismount.
    //
    
    //
    //  Acquire the global resource so that we can try to vaporize
    //  the volume, and the vcb resource itself.
    //
        
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  The device will be going away.  Remove our lock and find
    //  out if we ever had one in the first place.
    //

    Status = CdUnlockVolumeInternal( IrpContext, Vcb, NULL );

    //
    //  If the volume had not been locked, we must invalidate the
    //  volume to ensure it goes away properly.  The remove will
    //  succeed.
    //

    if (!NT_SUCCESS( Status )) {

        CdLockVcb( IrpContext, Vcb );
        
        if (Vcb->VcbCondition != VcbDismountInProgress) {
            
            CdUpdateVcbCondition( Vcb, VcbInvalid);
        }
        
        CdUnlockVcb( IrpContext, Vcb );
        
        Status = STATUS_SUCCESS;
    }
    
    //
    //  We need to pass this down before starting the dismount, which
    //  could disconnect us immediately from the stack.
    //
    
    //
    //  Get the next stack location, and copy over the stack location
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    //  Set up the completion routine
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    IoSetCompletionRoutine( Irp,
                            CdPnpCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request and wait.
    //

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject( &Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        Status = Irp->IoStatus.Status;
    }

    //
    //  Now make our dismount happen.  This may not vaporize the
    //  Vcb, of course, since there could be any number of handles
    //  outstanding if we were not preceeded by a QUERY.
    //
    //  PnP will take care of disconnecting this stack if we
    //  couldn't get off of it immediately.
    //

 
    VcbPresent = CdCheckForDismount( IrpContext, Vcb, TRUE );

    //
    //  Release the Vcb if it could still remain.
    //
    
    if (VcbPresent) {

        CdReleaseVcb( IrpContext, Vcb );
    }

    CdReleaseCdData( IrpContext );
    
    //
    //  Cleanup our IrpContext and complete the IRP.
    //

    CdCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
CdPnpSurpriseRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP surprise remove operation.  This is another
    type of notification that the underlying storage device for the volume we
    have is gone, and is excellent indication that the volume will never reappear.
    The filesystem is responsible for initiation or completion the dismount.
    
    For the most part, only "real" drivers care about the distinction of a
    surprise remove, which is a result of our noticing that a user (usually)
    physically reached into the machine and pulled something out.
    
    Surprise will be followed by a Remove when all references have been shut down.

Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbPresent = TRUE;

    ASSERT_EXCLUSIVE_CDDATA;
    
    //
    //  SURPRISE - a device was physically yanked away without
    //  any warning.  This means external forces.
    //
    
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );
        
    //
    //  Invalidate the volume right now.
    //
    //  The intent here is to make every subsequent operation
    //  on the volume fail and grease the rails toward dismount.
    //  By definition there is no going back from a SURPRISE.
    //
        
    CdLockVcb( IrpContext, Vcb );
    
    if (Vcb->VcbCondition != VcbDismountInProgress) {
        
        CdUpdateVcbCondition( Vcb, VcbInvalid);
    }
    
    CdUnlockVcb( IrpContext, Vcb );
    
    //
    //  We need to pass this down before starting the dismount, which
    //  could disconnect us immediately from the stack.
    //
    
    //
    //  Get the next stack location, and copy over the stack location
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    //  Set up the completion routine
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    IoSetCompletionRoutine( Irp,
                            CdPnpCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request and wait.
    //

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject( &Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        Status = Irp->IoStatus.Status;
    }
    
    //
    //  Now make our dismount happen.  This may not vaporize the
    //  Vcb, of course, since there could be any number of handles
    //  outstanding since this is an out of band notification.
    //

        
    VcbPresent = CdCheckForDismount( IrpContext, Vcb, TRUE );
    
    //
    //  Release the Vcb if it could still remain.
    //
    
    if (VcbPresent) {

        CdReleaseVcb( IrpContext, Vcb );
    }

    CdReleaseCdData( IrpContext );
    
    //
    //  Cleanup our IrpContext and complete the IRP.
    //

    CdCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
CdPnpCancelRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP cancel remove operation.  This is our
    notification that a previously proposed remove (query) was eventually
    vetoed by a component.  The filesystem is responsible for cleaning up
    and getting ready for more IO.
    
Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    ASSERT_EXCLUSIVE_CDDATA;

    //
    //  CANCEL - a previous QUERY has been rescinded as a result
    //  of someone vetoing.  Since PnP cannot figure out who may
    //  have gotten the QUERY (think about it: stacked drivers),
    //  we must expect to deal with getting a CANCEL without having
    //  seen the QUERY.
    //
    //  For CDFS, this is quite easy.  In fact, we can't get a
    //  CANCEL if the underlying drivers succeeded the QUERY since
    //  we disconnect the Vpb on our dismount initiation.  This is
    //  actually pretty important because if PnP could get to us
    //  after the disconnect we'd be thoroughly unsynchronized
    //  with respect to the Vcb getting torn apart - merely referencing
    //  the volume device object is insufficient to keep us intact.
    //
    
    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );
    CdReleaseCdData( IrpContext);

    //
    //  Unlock the volume.  This is benign if we never had seen
    //  a QUERY.
    //

    (VOID) CdUnlockVolumeInternal( IrpContext, Vcb, NULL );

    CdReleaseVcb( IrpContext, Vcb );

    //
    //  Send the request.  The underlying driver will complete the
    //  IRP.  Since we don't need to be in the way, simply ellide
    //  ourselves out of the IRP stack.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    CdCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdPnpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )
{
    PKEVENT Event = (PKEVENT) Contxt;

    KeSetEvent( Event, 0, FALSE );

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Contxt );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\resrcsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    ResrcSup.c

Abstract:

    This module implements the Cdfs Resource acquisition routines

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_RESRCSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdAcquireForCache)
#pragma alloc_text(PAGE, CdAcquireForCreateSection)
#pragma alloc_text(PAGE, CdAcquireResource)
#pragma alloc_text(PAGE, CdNoopAcquire)
#pragma alloc_text(PAGE, CdNoopRelease)
#pragma alloc_text(PAGE, CdReleaseForCreateSection)
#pragma alloc_text(PAGE, CdReleaseFromCache)
#endif


BOOLEAN
CdAcquireResource (
    IN PIRP_CONTEXT IrpContext,
    IN PERESOURCE Resource,
    IN BOOLEAN IgnoreWait,
    IN TYPE_OF_ACQUIRE Type
    )

/*++

Routine Description:

    This is the single routine used to acquire file system resources.  It
    looks at the IgnoreWait flag to determine whether to try to acquire the
    resource without waiting.  Returning TRUE/FALSE to indicate success or
    failure.  Otherwise it is driven by the WAIT flag in the IrpContext and
    will raise CANT_WAIT on a failure.

Arguments:

    Resource - This is the resource to try and acquire.

    IgnoreWait - If TRUE then this routine will not wait to acquire the
        resource and will return a boolean indicating whether the resource was
        acquired.  Otherwise we use the flag in the IrpContext and raise
        if the resource is not acquired.

    Type - Indicates how we should try to get the resource.

Return Value:

    BOOLEAN - TRUE if the resource is acquired.  FALSE if not acquired and
        IgnoreWait is specified.  Otherwise we raise CANT_WAIT.

--*/

{
    BOOLEAN Wait = FALSE;
    BOOLEAN Acquired;
    PAGED_CODE();

    //
    //  We look first at the IgnoreWait flag, next at the flag in the Irp
    //  Context to decide how to acquire this resource.
    //

    if (!IgnoreWait && FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT )) {

        Wait = TRUE;
    }

    //
    //  Attempt to acquire the resource either shared or exclusively.
    //

    switch (Type) {
        case AcquireExclusive:
        
            Acquired = ExAcquireResourceExclusiveLite( Resource, Wait );
            break;

        case AcquireShared:
            
            Acquired = ExAcquireResourceSharedLite( Resource, Wait );
            break;

        case AcquireSharedStarveExclusive:
            
            Acquired = ExAcquireSharedStarveExclusive( Resource, Wait );
            break;

        default:
        	Acquired = FALSE;
            ASSERT( FALSE );
    }

    //
    //  If not acquired and the user didn't specifiy IgnoreWait then
    //  raise CANT_WAIT.
    //

    if (!Acquired && !IgnoreWait) {

        CdRaiseStatus( IrpContext, STATUS_CANT_WAIT );
    }

    return Acquired;
}


BOOLEAN
CdAcquireForCache (
    IN PFCB Fcb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer for synchronization.

Arguments:

    Fcb -  The pointer supplied as context to the cache initialization
           routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT(IoGetTopLevelIrp() == NULL);
    IoSetTopLevelIrp((PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);

    return ExAcquireResourceSharedLite( Fcb->Resource, Wait );
}


VOID
CdReleaseFromCache (
    IN PFCB Fcb
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a virtual file.  It is subsequently called by the Lazy Writer to release
    a resource acquired above.

Arguments:

    Fcb -  The pointer supplied as context to the cache initialization
           routine.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT(IoGetTopLevelIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);
    IoSetTopLevelIrp( NULL );
    
    ExReleaseResourceLite( Fcb->Resource );
}


BOOLEAN
CdNoopAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    Fcb - The Fcb/Vcb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    TRUE

--*/

{
    PAGED_CODE();
    return TRUE;
}


VOID
CdNoopRelease (
    IN PVOID Fcb
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    Fcb - The Fcb/Vcb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/

{
    PAGED_CODE();
}


VOID
CdAcquireForCreateSection (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This is the callback routine for MM to use to acquire the file exclusively.

Arguments:

    FileObject - File object for a Cdfs stream.

Return Value:

    None

--*/

{
    PAGED_CODE();

    
    //
    //  Get the Fcb resource exclusively.
    //

    ExAcquireResourceExclusiveLite( &((PFCB) FileObject->FsContext)->FcbNonpaged->FcbResource,
                                TRUE );
                                
    //
    //  Take the File resource shared.  We need this later on when MM calls 
    //  QueryStandardInfo to get the file size.  
    //
    //  If we don't use StarveExclusive,  then we can get wedged behind an 
    //  exclusive waiter who is waiting on someone else holding it shared in the 
    //  read->initializecachemap path (which calls createsection) who is in turn 
    //  waiting on us to finish the create section.
    //

    ExAcquireSharedStarveExclusive( ((PFCB) FileObject->FsContext)->Resource,
                                    TRUE );
}


VOID
CdReleaseForCreateSection (
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This is the callback routine for MM to use to release a file acquired with
    the AcquireForCreateSection call above.

Arguments:

    FileObject - File object for a Cdfs stream.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Release the resources.
    //

    ExReleaseResourceLite( &((PFCB) FileObject->FsContext)->FcbNonpaged->FcbResource );
    ExReleaseResourceLite( ((PFCB) FileObject->FsContext)->Resource);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\volinfo.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    VolInfo.c

Abstract:

    This module implements the volume information routines for Cdfs called by
    the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_VOLINFO)

//
//  Local support routines
//

NTSTATUS
CdQueryFsVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
CdQueryFsSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
CdQueryFsDeviceInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
CdQueryFsAttributeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdCommonQueryVolInfo)
#pragma alloc_text(PAGE, CdQueryFsAttributeInfo)
#pragma alloc_text(PAGE, CdQueryFsDeviceInfo)
#pragma alloc_text(PAGE, CdQueryFsSizeInfo)
#pragma alloc_text(PAGE, CdQueryFsVolumeInfo)
#endif


NTSTATUS
CdCommonQueryVolInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying volume information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    ULONG Length;

    TYPE_OF_OPEN TypeOfOpen;
    PFCB Fcb;
    PCCB Ccb;

    PAGED_CODE();

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryVolume.Length;

    //
    //  Decode the file object and fail if this an unopened file object.
    //

    TypeOfOpen = CdDecodeFileObject( IrpContext, IrpSp->FileObject, &Fcb, &Ccb );

    if (TypeOfOpen == UnopenedFileObject) {

        CdCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire the Vcb for this volume.
    //

    CdAcquireVcbShared( IrpContext, Fcb->Vcb, FALSE );

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Verify the Vcb.
        //

        CdVerifyVcb( IrpContext, Fcb->Vcb );

        //
        //  Based on the information class we'll do different actions.  Each
        //  of the procedures that we're calling fills up the output buffer
        //  if possible and returns true if it successfully filled the buffer
        //  and false if it couldn't wait for any I/O to complete.
        //

        switch (IrpSp->Parameters.QueryVolume.FsInformationClass) {

        case FileFsSizeInformation:

            Status = CdQueryFsSizeInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;

        case FileFsVolumeInformation:

            Status = CdQueryFsVolumeInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;

        case FileFsDeviceInformation:

            Status = CdQueryFsDeviceInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;

        case FileFsAttributeInformation:

            Status = CdQueryFsAttributeInfo( IrpContext, Fcb->Vcb, Irp->AssociatedIrp.SystemBuffer, &Length );
            break;
        }

        //
        //  Set the information field to the number of bytes actually filled in
        //

        Irp->IoStatus.Information = IrpSp->Parameters.QueryVolume.Length - Length;

    } finally {

        //
        //  Release the Vcb.
        //

        CdReleaseVcb( IrpContext, Fcb->Vcb );
    }

    //
    //  Complete the request if we didn't raise.
    //

    CdCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdQueryFsVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume info call

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ULONG BytesToCopy;

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Fill in the data from the Vcb.
    //

    Buffer->VolumeCreationTime = *((PLARGE_INTEGER) &Vcb->VolumeDasdFcb->CreationTime);
    Buffer->VolumeSerialNumber = Vcb->Vpb->SerialNumber;

    Buffer->SupportsObjects = FALSE;

    *Length -= FIELD_OFFSET( FILE_FS_VOLUME_INFORMATION, VolumeLabel[0] );

    //
    //  Check if the buffer we're given is long enough
    //

    if (*Length >= (ULONG) Vcb->Vpb->VolumeLabelLength) {

        BytesToCopy = Vcb->Vpb->VolumeLabelLength;

    } else {

        BytesToCopy = *Length;

        Status = STATUS_BUFFER_OVERFLOW;
    }

    //
    //  Copy over what we can of the volume label, and adjust *Length
    //

    Buffer->VolumeLabelLength = BytesToCopy;

    if (BytesToCopy) {

        RtlCopyMemory( &Buffer->VolumeLabel[0],
                       &Vcb->Vpb->VolumeLabel[0],
                       BytesToCopy );
    }

    *Length -= BytesToCopy;

    //
    //  Set our status and return to our caller
    //

    return Status;
}


//
//  Local support routine
//

NTSTATUS
CdQueryFsSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume size call.

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    PAGED_CODE();

    //
    //  Fill in the output buffer.
    //

    Buffer->TotalAllocationUnits.QuadPart = LlSectorsFromBytes( Vcb->VolumeDasdFcb->AllocationSize.QuadPart );

    Buffer->AvailableAllocationUnits.QuadPart = 0;
    Buffer->SectorsPerAllocationUnit = 1;
    Buffer->BytesPerSector = SECTOR_SIZE;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof( FILE_FS_SIZE_INFORMATION );

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
CdQueryFsDeviceInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume device call.

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    PAGED_CODE();

    //
    //  Update the output buffer.
    //

    Buffer->Characteristics = Vcb->TargetDeviceObject->Characteristics;
    Buffer->DeviceType = FILE_DEVICE_CD_ROM;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof( FILE_FS_DEVICE_INFORMATION );

    //
    //  And return success to our caller
    //

    return STATUS_SUCCESS;
}


//
//  Local support routine
//

NTSTATUS
CdQueryFsAttributeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume attribute call.

Arguments:

    Vcb - Vcb for this volume.

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ULONG BytesToCopy;

    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  Fill out the fixed portion of the buffer.
    //

    Buffer->FileSystemAttributes = FILE_CASE_SENSITIVE_SEARCH |
				   FILE_READ_ONLY_VOLUME;

    if (FlagOn( IrpContext->Vcb->VcbState, VCB_STATE_JOLIET )) {

        SetFlag( Buffer->FileSystemAttributes, FILE_UNICODE_ON_DISK );

        Buffer->MaximumComponentNameLength = 110;

    } else {

        Buffer->MaximumComponentNameLength = 221;
    }

    *Length -= FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName );

    //
    //  Make sure we can copy full unicode characters.
    //

    ClearFlag( *Length, 1 );

    //
    //  Determine how much of the file system name will fit.
    //

    if (*Length >= 8) {

        BytesToCopy = 8;

    } else {

        BytesToCopy = *Length;
        Status = STATUS_BUFFER_OVERFLOW;
    }

    *Length -= BytesToCopy;

    //
    //  Do the file system name.
    //

    Buffer->FileSystemNameLength = BytesToCopy;

    RtlCopyMemory( &Buffer->FileSystemName[0], L"CDFS", BytesToCopy );

    //
    //  And return to our caller
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\verfysup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    VerfySup.c

Abstract:

    This module implements the Cdfs Verification routines.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_VERFYSUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdVerifyFcbOperation)
#pragma alloc_text(PAGE, CdVerifyVcb)
#endif


NTSTATUS
CdPerformVerify (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT DeviceToVerify
    )

/*++

Routine Description:

    This routines performs an IoVerifyVolume operation and takes the
    appropriate action.  If the verify is successful then we send the originating
    Irp off to an Ex Worker Thread.  This routine is called from the exception handler.

    No file system resources are held when this routine is called.

Arguments:

    Irp - The irp to send off after all is well and done.

    Device - The real device needing verification.

Return Value:

    None.

--*/

{
    PVCB Vcb;
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Check if this Irp has a status of Verify required and if it does
    //  then call the I/O system to do a verify.
    //
    //  Skip the IoVerifyVolume if this is a mount or verify request
    //  itself.  Trying a recursive mount will cause a deadlock with
    //  the DeviceObject->DeviceLock.
    //

    if ((IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
        ((IrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME) ||
         (IrpContext->MinorFunction == IRP_MN_VERIFY_VOLUME))) {

        return CdFsdPostRequest( IrpContext, Irp );
    }

    //
    //  Extract a pointer to the Vcb from the VolumeDeviceObject.
    //  Note that since we have specifically excluded mount,
    //  requests, we know that IrpSp->DeviceObject is indeed a
    //  volume device object.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    Vcb = &CONTAINING_RECORD( IrpSp->DeviceObject,
                              VOLUME_DEVICE_OBJECT,
                              DeviceObject )->Vcb;
    try {

        //
        //  Send down the verify FSCTL.  Note that this is sent to the
        //  currently mounted volume,  which may not be this one.
        //
        //  We will allow Raw to mount this volume if we were doing a
        //  an absolute DASD open.
        //

        Status = IoVerifyVolume( DeviceToVerify, CdOperationIsDasdOpen( IrpContext));

        //
        //  Acquire the Vcb so we're working with a stable VcbCondition.
        //
        
        CdAcquireVcbShared( IrpContext, Vcb, FALSE);
        
        //
        //  If the verify operation completed it will return
        //  either STATUS_SUCCESS or STATUS_WRONG_VOLUME, exactly.
        //
        //  If CdVerifyVolume encountered an error during
        //  processing, it will return that error.  If we got
        //  STATUS_WRONG_VOLUME from the verify, and our volume
        //  is now mounted, commute the status to STATUS_SUCCESS.
        //

        if ((Status == STATUS_WRONG_VOLUME) &&
            (Vcb->VcbCondition == VcbMounted)) {

            Status = STATUS_SUCCESS;
        }
        else if ((STATUS_SUCCESS == Status) && (Vcb->VcbCondition != VcbMounted))  {

            //
            //  If the verify succeeded,  but our volume is not mounted,
            //  then some other volume is on the device. 
            //

            Status = STATUS_WRONG_VOLUME;
        } 
        
        //
        //  Do a quick unprotected check here.  The routine will do
        //  a safe check.  After here we can release the resource.
        //  Note that if the volume really went away, we will be taking
        //  the Reparse path.
        //

        //
        //  If the device might need to go away then call our dismount routine.
        //

        if (((Vcb->VcbCondition == VcbNotMounted) ||
             (Vcb->VcbCondition == VcbInvalid) ||
             (Vcb->VcbCondition == VcbDismountInProgress)) &&
            (Vcb->VcbReference <= CDFS_RESIDUAL_REFERENCE)) {

            CdReleaseVcb( IrpContext, Vcb);

            CdAcquireCdData( IrpContext );
            CdCheckForDismount( IrpContext, Vcb, FALSE );
            CdReleaseCdData( IrpContext );
        }
        else {

            CdReleaseVcb( IrpContext, Vcb);
        }

        //
        //  If this is a create and the verify succeeded then complete the
        //  request with a REPARSE status.
        //

        if ((IrpContext->MajorFunction == IRP_MJ_CREATE) &&
            (IrpSp->FileObject->RelatedFileObject == NULL) &&
            ((Status == STATUS_SUCCESS) || (Status == STATUS_WRONG_VOLUME))) {

            Irp->IoStatus.Information = IO_REMOUNT;

            CdCompleteRequest( IrpContext, Irp, STATUS_REPARSE );
            Status = STATUS_REPARSE;
            Irp = NULL;
            IrpContext = NULL;

        //
        //  If there is still an error to process then call the Io system
        //  for a popup.
        //

        } else if ((Irp != NULL) && !NT_SUCCESS( Status )) {

            //
            //  Fill in the device object if required.
            //
            
            if (IoIsErrorUserInduced( Status ) ) {

                IoSetHardErrorOrVerifyDevice( Irp, DeviceToVerify );
            }

            CdNormalizeAndRaiseStatus( IrpContext, Status );
        }

        //
        //  If there is still an Irp, send it off to an Ex Worker thread.
        //

        if (IrpContext != NULL) {

            Status = CdFsdPostRequest( IrpContext, Irp );
        }

    } except(CdExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the verify or raised
        //  an error ourselves.  So we'll abort the I/O request with
        //  the error status that we get back from the execption code.
        //

        Status = CdProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    return Status;
}


BOOLEAN
CdCheckForDismount (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN Force
    )

/*++

Routine Description:

    This routine is called to check if a volume is ready for dismount.  This
    occurs when only file system references are left on the volume.

    If the dismount is not currently underway and the user reference count
    has gone to zero then we can begin the dismount.

    If the dismount is in progress and there are no references left on the
    volume (we check the Vpb for outstanding references as well to catch
    any create calls dispatched to the file system) then we can delete
    the Vcb.

Arguments:

    Vcb - Vcb for the volume to try to dismount.
    
    Force - Whether we will force this volume to be dismounted.

Return Value:

    BOOLEAN - True if the Vcb was not gone by the time this function finished,
        False if it was deleted.
        
    This is only a trustworthy indication to the caller if it had the vcb
    exclusive itself.

--*/

{
    BOOLEAN UnlockVcb = TRUE;
    BOOLEAN VcbPresent = TRUE;
    KIRQL SavedIrql;

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_VCB( Vcb );

    ASSERT_EXCLUSIVE_CDDATA;

    //
    //  Acquire and lock this Vcb to check the dismount state.
    //

    CdAcquireVcbExclusive( IrpContext, Vcb, FALSE );

    //
    //  Lets get rid of any pending closes for this volume.
    //

    CdFspClose( Vcb );

    CdLockVcb( IrpContext, Vcb );

    //
    //  If the dismount is not already underway then check if the
    //  user reference count has gone to zero or we are being forced
    //  to disconnect.  If so start the teardown on the Vcb.
    //

    if (Vcb->VcbCondition != VcbDismountInProgress) {

        if (Vcb->VcbUserReference <= CDFS_RESIDUAL_USER_REFERENCE || Force) {

            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;
            VcbPresent = CdDismountVcb( IrpContext, Vcb );
        }

    //
    //  If the teardown is underway and there are absolutely no references
    //  remaining then delete the Vcb.  References here include the
    //  references in the Vcb and Vpb.
    //

    } else if (Vcb->VcbReference == 0) {

        IoAcquireVpbSpinLock( &SavedIrql );

        //
        //  If there are no file objects and no reference counts in the
        //  Vpb we can delete the Vcb.  Don't forget that we have the
        //  last reference in the Vpb.
        //

        if (Vcb->Vpb->ReferenceCount == 1) {

            IoReleaseVpbSpinLock( SavedIrql );
            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;
            CdDeleteVcb( IrpContext, Vcb );
            VcbPresent = FALSE;

        } else {

            IoReleaseVpbSpinLock( SavedIrql );
        }
    }

    //
    //  Unlock the Vcb if still held.
    //

    if (UnlockVcb) {

        CdUnlockVcb( IrpContext, Vcb );
    }

    //
    //  Release any resources still acquired.
    //

    if (VcbPresent) {

        CdReleaseVcb( IrpContext, Vcb );
    }

    return VcbPresent;
}


BOOLEAN
CdMarkDevForVerifyIfVcbMounted(
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine checks to see if the specified Vcb is currently mounted on
    the device or not.  If it is,  it sets the verify flag on the device, if
    not then the state is noted in the Vcb.

Arguments:

    Vcb - This is the volume to check.

Return Value:

    TRUE if the device has been marked for verify here,  FALSE otherwise.

--*/

{
    BOOLEAN Marked = FALSE;
    KIRQL SavedIrql;

    IoAcquireVpbSpinLock( &SavedIrql );
    
    if (Vcb->Vpb->RealDevice->Vpb == Vcb->Vpb)  {

        CdMarkRealDevForVerify( Vcb->Vpb->RealDevice);
        Marked = TRUE;
    }
    else {

        //
        //  Flag this to avoid the VPB spinlock in future passes.
        //
        
        SetFlag( Vcb->VcbState, VCB_STATE_VPB_NOT_ON_DEVICE);
    }
    
    IoReleaseVpbSpinLock( SavedIrql );

    return Marked;
}


VOID
CdVerifyVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine checks that the current Vcb is valid and currently mounted
    on the device.  It will raise on an error condition.

    We check whether the volume needs verification and the current state
    of the Vcb.

Arguments:

    Vcb - This is the volume to verify.

Return Value:

    None

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    IO_STATUS_BLOCK Iosb;
    ULONG MediaChangeCount = 0;
    BOOLEAN ForceVerify = FALSE;
    BOOLEAN DevMarkedForVerify;
    KIRQL SavedIrql;

    PAGED_CODE();

    //
    //  Fail immediately if the volume is in the progress of being dismounted
    //  or has been marked invalid.
    //

    if ((Vcb->VcbCondition == VcbInvalid) ||
        ((Vcb->VcbCondition == VcbDismountInProgress) && 
         (IrpContext->MajorFunction != IRP_MJ_CREATE))) {

        CdRaiseStatus( IrpContext, STATUS_FILE_INVALID );
    }
    
    if (FlagOn( Vcb->VcbState, VCB_STATE_REMOVABLE_MEDIA ))  {
        
        //
        //  Capture the real device verify state.
        //
        
        DevMarkedForVerify = CdRealDevNeedsVerify( Vcb->Vpb->RealDevice);

        //
        //  If the media is removable and the verify volume flag in the
        //  device object is not set then we want to ping the device
        //  to see if it needs to be verified.
        //

        if (Vcb->VcbCondition != VcbMountInProgress) {

            Status = CdPerformDevIoCtrl( IrpContext,
                                         IOCTL_CDROM_CHECK_VERIFY,
                                         Vcb->TargetDeviceObject,
                                         &MediaChangeCount,
                                         sizeof(ULONG),
                                         FALSE,
                                         FALSE,
                                         &Iosb );

            if (Iosb.Information != sizeof(ULONG)) {
        
                //
                //  Be safe about the count in case the driver didn't fill it in
                //
        
                MediaChangeCount = 0;
            }

            //
            //  There are four cases when we want to do a verify.  These are the
            //  first three.
            //
            //  1. We are mounted,  and the device has become empty
            //  2. The device has returned verify required (=> DO_VERIFY_VOL flag is
            //     set, but could be due to hardware condition)
            //  3. Media change count doesn't match the one in the Vcb
            //
            
            if (((Vcb->VcbCondition == VcbMounted) &&
                 CdIsRawDevice( IrpContext, Status )) 
                ||
                (Status == STATUS_VERIFY_REQUIRED)
                ||
                (NT_SUCCESS(Status) &&
                 (Vcb->MediaChangeCount != MediaChangeCount))) {

                //
                //  If we are currently the volume on the device then it is our
                //  responsibility to set the verify flag.  If we're not on the device,
                //  then we shouldn't touch the flag.
                //

                if (!FlagOn( Vcb->VcbState, VCB_STATE_VPB_NOT_ON_DEVICE) &&
                    !DevMarkedForVerify)  {

                     DevMarkedForVerify = CdMarkDevForVerifyIfVcbMounted( Vcb);
                }

                ForceVerify = TRUE;

                //
                //  NOTE that we no longer update the media change count here. We
                //  do so only when we've actually completed a verify at a particular
                //  change count value.
                //
            } 
        }

        //
        //  This is the 4th verify case.
        //
        //  We ALWAYS force CREATE requests on unmounted volumes through the 
        //  verify path.  These requests could have been in limbo between
        //  IoCheckMountedVpb and us when a verify/mount took place and caused
        //  a completely different fs/volume to be mounted.  In this case the
        //  checks above may not have caught the condition,  since we may already
        //  have verified (wrong volume) and decided that we have nothing to do.
        //  We want the requests to be re routed to the currently mounted volume,
        //  since they were directed at the 'drive',  not our volume.
        //

        if (NT_SUCCESS( Status) && !ForceVerify && 
            (IrpContext->MajorFunction == IRP_MJ_CREATE))  {

            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( IrpContext->Irp);

            ForceVerify = (IrpSp->FileObject->RelatedFileObject == NULL) &&
                          ((Vcb->VcbCondition == VcbDismountInProgress) ||
                           (Vcb->VcbCondition == VcbNotMounted));

            //
            //  Note that we don't touch the device verify flag here.  It required
            //  it would have been caught and set by the first set of checks.
            //
        }

        //
        //  Raise the verify / error if neccessary.
        //
        
        if (ForceVerify || !NT_SUCCESS( Status)) {

            IoSetHardErrorOrVerifyDevice( IrpContext->Irp,
                                          Vcb->Vpb->RealDevice );
           
            CdRaiseStatus( IrpContext, ForceVerify ? STATUS_VERIFY_REQUIRED : Status);
        }
    }

    //
    //  Based on the condition of the Vcb we'll either return to our
    //  caller or raise an error condition
    //

    switch (Vcb->VcbCondition) {

    case VcbNotMounted:

        IoSetHardErrorOrVerifyDevice( IrpContext->Irp, Vcb->Vpb->RealDevice );

        CdRaiseStatus( IrpContext, STATUS_WRONG_VOLUME );
        break;

    case VcbInvalid:
    case VcbDismountInProgress :

        CdRaiseStatus( IrpContext, STATUS_FILE_INVALID );
        break;
    }
}


BOOLEAN
CdVerifyFcbOperation (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to verify that the state of the Fcb is valid
    to allow the current operation to continue.  We use the state of the
    Vcb, target device and type of operation to determine this.

Arguments:

    IrpContext - IrpContext for the request.  If not present then we
        were called from the fast IO path.

    Fcb - Fcb to perform the request on.

Return Value:

    BOOLEAN - TRUE if the request can continue, FALSE otherwise.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PVCB Vcb = Fcb->Vcb;
    PDEVICE_OBJECT RealDevice = Vcb->Vpb->RealDevice;
    PIRP Irp;

    PAGED_CODE();
    
    //
    //  Check that the fileobject has not been cleaned up.
    //
    
    if ( ARGUMENT_PRESENT( IrpContext ))  {

        PFILE_OBJECT FileObject;

        Irp = IrpContext->Irp;
        FileObject = IoGetCurrentIrpStackLocation( Irp)->FileObject;
        
        if ( FileObject && FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE))  {

            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  Following FAT,  we allow certain operations even on cleaned up
            //  file objects.  Everything else,  we fail.
            //
            
            if ( (FlagOn(Irp->Flags, IRP_PAGING_IO)) ||
                 (IrpSp->MajorFunction == IRP_MJ_CLOSE ) ||
                 (IrpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION) ||
                 ( (IrpSp->MajorFunction == IRP_MJ_READ) &&
                   FlagOn(IrpSp->MinorFunction, IRP_MN_COMPLETE) ) ) {

                NOTHING;

            } else {

                CdRaiseStatus( IrpContext, STATUS_FILE_CLOSED );
            }
        }
    }

    //
    //  Fail immediately if the volume is in the progress of being dismounted
    //  or has been marked invalid.
    //

    if ((Vcb->VcbCondition == VcbInvalid) ||
        (Vcb->VcbCondition == VcbDismountInProgress)) {

        if (ARGUMENT_PRESENT( IrpContext )) {

            CdRaiseStatus( IrpContext, STATUS_FILE_INVALID );
        }

        return FALSE;
    }

    //
    //  Always fail if the volume needs to be verified.
    //

    if (CdRealDevNeedsVerify( RealDevice)) {

        if (ARGUMENT_PRESENT( IrpContext )) {

            IoSetHardErrorOrVerifyDevice( IrpContext->Irp,
                                          RealDevice );

            CdRaiseStatus( IrpContext, STATUS_VERIFY_REQUIRED );
        }

        return FALSE;

    //
    //
    //  All operations are allowed on mounted.
    //

    } else if ((Vcb->VcbCondition == VcbMounted) ||
               (Vcb->VcbCondition == VcbMountInProgress)) {

        return TRUE;

    //
    //  Fail all requests for fast Io on other Vcb conditions.
    //

    } else if (!ARGUMENT_PRESENT( IrpContext )) {

        return FALSE;

    //
    //  The remaining case is VcbNotMounted.
    //  Mark the device to be verified and raise WRONG_VOLUME.
    //

    } else if (Vcb->VcbCondition == VcbNotMounted) {

        if (ARGUMENT_PRESENT( IrpContext )) {

            IoSetHardErrorOrVerifyDevice( IrpContext->Irp, RealDevice );
            CdRaiseStatus( IrpContext, STATUS_WRONG_VOLUME );
        }

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
CdDismountVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine is called when all of the user references to a volume are
    gone.  We will initiate all of the teardown any system resources.

    If all of the references to this volume are gone at the end of this routine
    then we will complete the teardown of this Vcb and mark the current Vpb
    as not mounted.  Otherwise we will allocated a new Vpb for this device
    and keep the current Vpb attached to the Vcb.

Arguments:

    Vcb - Vcb for the volume to dismount.

Return Value:

    BOOLEAN - TRUE if we didn't delete the Vcb, FALSE otherwise.

--*/

{
    PVPB OldVpb;
    BOOLEAN VcbPresent = TRUE;
    KIRQL SavedIrql;

    BOOLEAN FinalReference;

    ASSERT_EXCLUSIVE_CDDATA;
    ASSERT_EXCLUSIVE_VCB( Vcb );

    CdLockVcb( IrpContext, Vcb );

    //
    //  We should only take this path once.
    //

    ASSERT( Vcb->VcbCondition != VcbDismountInProgress );

    //
    //  Mark the Vcb as DismountInProgress.
    //

    Vcb->VcbCondition = VcbDismountInProgress;

    if (Vcb->XASector != NULL) {

        CdFreePool( &Vcb->XASector );
        Vcb->XASector = 0;
        Vcb->XADiskOffset = 0;
    }

    //
    //  Remove our reference to the internal Fcb's.  The Fcb's will then
    //  be removed in the purge path below.
    //

    if (Vcb->RootIndexFcb != NULL) {

        Vcb->RootIndexFcb->FcbReference -= 1;
        Vcb->RootIndexFcb->FcbUserReference -= 1;
    }

    if (Vcb->PathTableFcb != NULL) {

        Vcb->PathTableFcb->FcbReference -= 1;
        Vcb->PathTableFcb->FcbUserReference -= 1;
    }

    if (Vcb->VolumeDasdFcb != NULL) {

        Vcb->VolumeDasdFcb->FcbReference -= 1;
        Vcb->VolumeDasdFcb->FcbUserReference -= 1;
    }

    CdUnlockVcb( IrpContext, Vcb );

    //
    //  Purge the volume.
    //

    CdPurgeVolume( IrpContext, Vcb, TRUE );

    //
    //  Empty the delayed and async close queues.
    //

    CdFspClose( Vcb );

    OldVpb = Vcb->Vpb;

    //
    //  Remove the mount volume reference.
    //

    CdLockVcb( IrpContext, Vcb );
    Vcb->VcbReference -= 1;

    //
    //  Acquire the Vpb spinlock to check for Vpb references.
    //

    IoAcquireVpbSpinLock( &SavedIrql );

    //
    //  Remember if this is the last reference on this Vcb.  We incremented
    //  the count on the Vpb earlier so we get one last crack it.  If our
    //  reference has gone to zero but the vpb reference count is greater
    //  than zero then the Io system will be responsible for deleting the
    //  Vpb.
    //

    FinalReference = (BOOLEAN) ((Vcb->VcbReference == 0) &&
                                (OldVpb->ReferenceCount == 1));

    //
    //  There is a reference count in the Vpb and in the Vcb.  We have
    //  incremented the reference count in the Vpb to make sure that
    //  we have last crack at it.  If this is a failed mount then we
    //  want to return the Vpb to the IO system to use for the next
    //  mount request.
    //

    if (OldVpb->RealDevice->Vpb == OldVpb) {

        //
        //  If not the final reference then swap out the Vpb.  We must
        //  preserve the REMOVE_PENDING flag so that the device is
        //  not remounted in the middle of a PnP remove operation.
        //

        if (!FinalReference) {

            ASSERT( Vcb->SwapVpb != NULL );

            Vcb->SwapVpb->Type = IO_TYPE_VPB;
            Vcb->SwapVpb->Size = sizeof( VPB );
            Vcb->SwapVpb->RealDevice = OldVpb->RealDevice;

            Vcb->SwapVpb->RealDevice->Vpb = Vcb->SwapVpb;

            Vcb->SwapVpb->Flags = FlagOn( OldVpb->Flags, VPB_REMOVE_PENDING );

            IoReleaseVpbSpinLock( SavedIrql );

            //
            //  Indicate we used up the swap.
            //

            Vcb->SwapVpb = NULL;            

            CdUnlockVcb( IrpContext, Vcb );

        //
        //  We want to leave the Vpb for the IO system.  Mark it
        //  as being not mounted.  Go ahead and delete the Vcb as
        //  well.
        //

        } else {

            //
            //  Make sure to remove the last reference on the Vpb.
            //

            OldVpb->ReferenceCount -= 1;

            OldVpb->DeviceObject = NULL;
            ClearFlag( Vcb->Vpb->Flags, VPB_MOUNTED );
            ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED );

            //
            //  Clear the Vpb flag so we know not to delete it.
            //

            Vcb->Vpb = NULL;

            IoReleaseVpbSpinLock( SavedIrql );
            CdUnlockVcb( IrpContext, Vcb );
            CdDeleteVcb( IrpContext, Vcb );
            VcbPresent = FALSE;
        }

    //
    //  Someone has already swapped in a new Vpb.  If this is the final reference
    //  then the file system is responsible for deleting the Vpb.
    //

    } else if (FinalReference) {

        //
        //  Make sure to remove the last reference on the Vpb.
        //

        OldVpb->ReferenceCount -= 1;

        IoReleaseVpbSpinLock( SavedIrql );
        CdUnlockVcb( IrpContext, Vcb );
        CdDeleteVcb( IrpContext, Vcb );
        VcbPresent = FALSE;

    //
    //  The current Vpb is no longer the Vpb for the device (the IO system
    //  has already allocated a new one).  We leave our reference in the
    //  Vpb and will be responsible for deleting it at a later time.
    //

    } else {

        IoReleaseVpbSpinLock( SavedIrql );
        CdUnlockVcb( IrpContext, Vcb );
    }

    //
    //  Let our caller know whether the Vcb is still present.
    //

    return VcbPresent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\strucsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    StrucSup.c

Abstract:

    This module implements the Cdfs in-memory data structure manipulation
    routines

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_STRUCSUP)

//
//  Local macros
//

//
//  PFCB
//  CdAllocateFcbData (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdDeallocateFcbData (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  PFCB
//  CdAllocateFcbIndex (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdDeallocateFcbIndex (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  PFCB_NONPAGED
//  CdAllocateFcbNonpaged (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdDeallocateFcbNonpaged (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB_NONPAGED FcbNonpaged
//      );
//
//  PCCB
//  CdAllocateCcb (
//      IN PIRP_CONTEXT IrpContext
//      );
//
//  VOID
//  CdDeallocateCcb (
//      IN PIRP_CONTEXT IrpContext,
//      IN PCCB Ccb
//      );
//

#define CdAllocateFcbData(IC) \
    FsRtlAllocatePoolWithTag( CdPagedPool, SIZEOF_FCB_DATA, TAG_FCB_DATA )

#define CdDeallocateFcbData(IC,F) \
    CdFreePool( &(F) )

#define CdAllocateFcbIndex(IC) \
    FsRtlAllocatePoolWithTag( CdPagedPool, SIZEOF_FCB_INDEX, TAG_FCB_INDEX )

#define CdDeallocateFcbIndex(IC,F) \
    CdFreePool( &(F) )

#define CdAllocateFcbNonpaged(IC) \
    ExAllocatePoolWithTag( CdNonPagedPool, sizeof( FCB_NONPAGED ), TAG_FCB_NONPAGED )

#define CdDeallocateFcbNonpaged(IC,FNP) \
    CdFreePool( &(FNP) )

#define CdAllocateCcb(IC) \
    FsRtlAllocatePoolWithTag( CdPagedPool, sizeof( CCB ), TAG_CCB )

#define CdDeallocateCcb(IC,C) \
    CdFreePool( &(C) )

//
//  Local structures
//

typedef struct _FCB_TABLE_ELEMENT {

    FILE_ID FileId;
    PFCB Fcb;

} FCB_TABLE_ELEMENT, *PFCB_TABLE_ELEMENT;

//
//  Local macros
//

//
//  VOID
//  CdInsertFcbTable (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//
//  VOID
//  CdDeleteFcbTable (
//      IN PIRP_CONTEXT IrpContext,
//      IN PFCB Fcb
//      );
//


#define CdInsertFcbTable(IC,F) {                                    \
    FCB_TABLE_ELEMENT _Key;                                         \
    _Key.Fcb = (F);                                                 \
    _Key.FileId = (F)->FileId;                                      \
    RtlInsertElementGenericTable( &(F)->Vcb->FcbTable,              \
                                  &_Key,                            \
                                  sizeof( FCB_TABLE_ELEMENT ),      \
                                  NULL );                           \
}

#define CdDeleteFcbTable(IC,F) {                                    \
    FCB_TABLE_ELEMENT _Key;                                         \
    _Key.FileId = (F)->FileId;                                      \
    RtlDeleteElementGenericTable( &(F)->Vcb->FcbTable, &_Key );     \
}

//
//  Local support routines
//

VOID
CdDeleteFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

PFCB_NONPAGED
CdCreateFcbNonpaged (
    IN PIRP_CONTEXT IrpContext
    );

VOID
CdDeleteFcbNonpaged (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB_NONPAGED FcbNonpaged
    );

RTL_GENERIC_COMPARE_RESULTS
CdFcbTableCompare (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID Fid1,
    IN PVOID Fid2
    );

PVOID
CdAllocateFcbTable (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN CLONG ByteSize
    );

VOID
CdDeallocateFcbTable (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID Buffer
    );

ULONG
CdTocSerial (
    IN PIRP_CONTEXT IrpContext,
    IN PCDROM_TOC CdromToc
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdAllocateFcbTable)
#pragma alloc_text(PAGE, CdCleanupIrpContext)
#pragma alloc_text(PAGE, CdCreateCcb)
#pragma alloc_text(PAGE, CdCreateFcb)
#pragma alloc_text(PAGE, CdCreateFcbNonpaged)
#pragma alloc_text(PAGE, CdCreateFileLock)
#pragma alloc_text(PAGE, CdCreateIrpContext)
#pragma alloc_text(PAGE, CdDeallocateFcbTable)
#pragma alloc_text(PAGE, CdDeleteCcb)
#pragma alloc_text(PAGE, CdDeleteFcb)
#pragma alloc_text(PAGE, CdDeleteFcbNonpaged)
#pragma alloc_text(PAGE, CdDeleteFileLock)
#pragma alloc_text(PAGE, CdDeleteVcb)
#pragma alloc_text(PAGE, CdFcbTableCompare)
#pragma alloc_text(PAGE, CdGetNextFcb)
#pragma alloc_text(PAGE, CdInitializeFcbFromFileContext)
#pragma alloc_text(PAGE, CdInitializeFcbFromPathEntry)
#pragma alloc_text(PAGE, CdInitializeStackIrpContext)
#pragma alloc_text(PAGE, CdInitializeVcb)
#pragma alloc_text(PAGE, CdLookupFcbTable)
#pragma alloc_text(PAGE, CdProcessToc)
#pragma alloc_text(PAGE, CdTeardownStructures)
#pragma alloc_text(PAGE, CdTocSerial)
#pragma alloc_text(PAGE, CdUpdateVcbFromVolDescriptor)
#endif


VOID
CdInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb,
    IN PCDROM_TOC CdromToc,
    IN ULONG TocLength,
    IN ULONG TocTrackCount,
    IN ULONG TocDiskFlags,
    IN ULONG BlockFactor,
    IN ULONG MediaChangeCount
    )

/*++

Routine Description:

    This routine initializes and inserts a new Vcb record into the in-memory
    data structure.  The Vcb record "hangs" off the end of the Volume device
    object and must be allocated by our caller.

Arguments:

    Vcb - Supplies the address of the Vcb record being initialized.

    TargetDeviceObject - Supplies the address of the target device object to
        associate with the Vcb record.

    Vpb - Supplies the address of the Vpb to associate with the Vcb record.

    CdromToc - Buffer to hold table of contents.  NULL if TOC command not
        supported.

    TocLength - Byte count length of TOC.  We use this as the TOC length to
        return on a user query.

    TocTrackCount - Count of tracks in TOC.  Used to create pseudo files for
        audio disks.

    TocDiskFlags - Flag field to indicate the type of tracks on the disk.

    BlockFactor - Used to decode any multi-session information.

    MediaChangeCount - Initial media change count of the target device

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  We start by first zeroing out all of the VCB, this will guarantee
    //  that any stale data is wiped clean.
    //

    RtlZeroMemory( Vcb, sizeof( VCB ));

    //
    //  Set the proper node type code and node byte size.
    //

    Vcb->NodeTypeCode = CDFS_NTC_VCB;
    Vcb->NodeByteSize = sizeof( VCB );

    //
    //  Initialize the DirNotify structs.  FsRtlNotifyInitializeSync can raise.
    //

    InitializeListHead( &Vcb->DirNotifyList );
    FsRtlNotifyInitializeSync( &Vcb->NotifySync );
    
    //
    //  Pick up a VPB right now so we know we can pull this filesystem stack
    //  off of the storage stack on demand.  This can raise - if it does,  
    //  uninitialize the notify structures before returning.
    //
    
    try  {

        Vcb->SwapVpb = FsRtlAllocatePoolWithTag( NonPagedPool,
                                                 sizeof( VPB ),
                                                 TAG_VPB );
    }
    finally {

        if (AbnormalTermination())  {
        
            FsRtlNotifyUninitializeSync( &Vcb->NotifySync );
        }
    }

    //
    //  Nothing beyond this point should raise.
    //

    RtlZeroMemory( Vcb->SwapVpb, sizeof( VPB ) );
    
    //
    //  Initialize the resource variable for the Vcb and files.
    //

    ExInitializeResourceLite( &Vcb->VcbResource );
    ExInitializeResourceLite( &Vcb->FileResource );
    ExInitializeFastMutex( &Vcb->VcbMutex );

    //
    //  Insert this Vcb record on the CdData.VcbQueue.
    //

    InsertHeadList( &CdData.VcbQueue, &Vcb->VcbLinks );

    //
    //  Set the Target Device Object and Vpb fields, referencing the
    //  Target device for the mount.
    //

    ObReferenceObject( TargetDeviceObject );
    Vcb->TargetDeviceObject = TargetDeviceObject;
    Vcb->Vpb = Vpb;

    //
    //  Set the removable media flag based on the real device's
    //  characteristics
    //

    if (FlagOn( Vpb->RealDevice->Characteristics, FILE_REMOVABLE_MEDIA )) {

        SetFlag( Vcb->VcbState, VCB_STATE_REMOVABLE_MEDIA );
    }

    //
    //  Initialize the generic Fcb Table.
    //

    RtlInitializeGenericTable( &Vcb->FcbTable,
                               (PRTL_GENERIC_COMPARE_ROUTINE) CdFcbTableCompare,
                               (PRTL_GENERIC_ALLOCATE_ROUTINE) CdAllocateFcbTable,
                               (PRTL_GENERIC_FREE_ROUTINE) CdDeallocateFcbTable,
                               NULL );

    //
    //  Show that we have a mount in progress.
    //

    CdUpdateVcbCondition( Vcb, VcbMountInProgress);

    //
    //  Refererence the Vcb for two reasons.  The first is a reference
    //  that prevents the Vcb from going away on the last close unless
    //  dismount has already occurred.  The second is to make sure
    //  we don't go into the dismount path on any error during mount
    //  until we get to the Mount cleanup.
    //

    Vcb->VcbReference = 1 + CDFS_RESIDUAL_REFERENCE;

    //
    //  Update the TOC information in the Vcb.
    //

    Vcb->CdromToc = CdromToc;
    Vcb->TocLength = TocLength;
    Vcb->TrackCount = TocTrackCount;
    Vcb->DiskFlags = TocDiskFlags;

    //
    //  If this disk contains audio tracks only then set the audio flag.
    //

    if (TocDiskFlags == CDROM_DISK_AUDIO_TRACK) {

        SetFlag( Vcb->VcbState, VCB_STATE_AUDIO_DISK | VCB_STATE_CDXA );
    }

    //
    //  Set the block factor.
    //

    Vcb->BlockFactor = BlockFactor;

    //
    //  Set the media change count on the device
    //

    CdUpdateMediaChangeCount( Vcb, MediaChangeCount);
}


VOID
CdUpdateVcbFromVolDescriptor (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PCHAR RawIsoVd OPTIONAL
    )

/*++

Routine Description:

    This routine is called to perform the final initialization of a Vcb from the
    volume descriptor on the disk.

Arguments:

    Vcb - Vcb for the volume being mounted.  We have already set the flags for the
        type of descriptor.

    RawIsoVd - If specified this is the volume descriptor to use to mount the
        volume.  Not specified for a raw disk.

Return Value:

    None

--*/

{
    ULONG Shift;
    ULONG StartingBlock;
    ULONG ByteCount;

    LONGLONG FileId = 0;

    PRAW_DIRENT RawDirent;
    PATH_ENTRY PathEntry;
    PCD_MCB_ENTRY McbEntry;

    BOOLEAN UnlockVcb = FALSE;

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    try {

        //
        //  Copy the block size and compute the various block masks.
        //  Block size must not be larger than the sector size.  We will
        //  use a default of the CD physical sector size if we are not
        //  on a data-full disc.
        //
        //  This must always be set.
        //

        Vcb->BlockSize = ( ARGUMENT_PRESENT( RawIsoVd ) ?
                            CdRvdBlkSz( RawIsoVd, Vcb->VcbState ) :
                            SECTOR_SIZE );

        //
        //  We no longer accept media where blocksize != sector size.
        //
        
        if (Vcb->BlockSize != SECTOR_SIZE)  {

            CdRaiseStatus( IrpContext, STATUS_DISK_CORRUPT_ERROR );
        }

        Vcb->BlocksPerSector = SECTOR_SIZE / Vcb->BlockSize;
        Vcb->BlockMask = Vcb->BlockSize - 1;
        Vcb->BlockInverseMask = ~Vcb->BlockMask;
     
        Vcb->BlockToSectorShift = 0;
        Vcb->BlockToByteShift = SECTOR_SHIFT;

        //
        //  If there is a volume descriptor then do the internal Fcb's and
        //  other Vcb fields.
        //

        if (ARGUMENT_PRESENT( RawIsoVd )) {

            //
            //  Create the path table Fcb and refererence it and the Vcb.
            //

            CdLockVcb( IrpContext, Vcb );
            UnlockVcb = TRUE;

            Vcb->PathTableFcb = CdCreateFcb( IrpContext,
                                             *((PFILE_ID) &FileId),
                                             CDFS_NTC_FCB_PATH_TABLE,
                                             NULL );

            CdIncrementReferenceCounts( IrpContext, Vcb->PathTableFcb, 1, 1 );
            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;

            //
            //  Compute the stream offset and size of this path table.
            //

            StartingBlock = CdRvdPtLoc( RawIsoVd, Vcb->VcbState );

            ByteCount = CdRvdPtSz( RawIsoVd, Vcb->VcbState );

            Vcb->PathTableFcb->StreamOffset = BytesFromBlocks( Vcb,
                                                               SectorBlockOffset( Vcb, StartingBlock ));

            Vcb->PathTableFcb->FileSize.QuadPart = (LONGLONG) (Vcb->PathTableFcb->StreamOffset +
                                                               ByteCount);

            Vcb->PathTableFcb->ValidDataLength.QuadPart = Vcb->PathTableFcb->FileSize.QuadPart;

            Vcb->PathTableFcb->AllocationSize.QuadPart = LlSectorAlign( Vcb->PathTableFcb->FileSize.QuadPart );

            //
            //  Now add the mapping information.
            //

            CdLockFcb( IrpContext, Vcb->PathTableFcb );

            CdAddInitialAllocation( IrpContext,
                                    Vcb->PathTableFcb,
                                    StartingBlock,
                                    Vcb->PathTableFcb->AllocationSize.QuadPart );

            CdUnlockFcb( IrpContext, Vcb->PathTableFcb );

            //
            //  Point to the file resource.
            //

            Vcb->PathTableFcb->Resource = &Vcb->FileResource;

            //
            //  Mark the Fcb as initialized and create the stream file for this.
            //

            SetFlag( Vcb->PathTableFcb->FcbState, FCB_STATE_INITIALIZED );

            CdCreateInternalStream( IrpContext, Vcb, Vcb->PathTableFcb );

            //
            //  Create the root index and reference it in the Vcb.
            //

            CdLockVcb( IrpContext, Vcb );
            UnlockVcb = TRUE;
            Vcb->RootIndexFcb = CdCreateFcb( IrpContext,
                                             *((PFILE_ID) &FileId),
                                             CDFS_NTC_FCB_INDEX,
                                             NULL );

            CdIncrementReferenceCounts( IrpContext, Vcb->RootIndexFcb, 1, 1 );
            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;

            //
            //  Create the File id by hand for this Fcb.
            //

            CdSetFidPathTableOffset( Vcb->RootIndexFcb->FileId, Vcb->PathTableFcb->StreamOffset );
            CdFidSetDirectory( Vcb->RootIndexFcb->FileId );

            //
            //  Create a pseudo path table entry so we can call the initialization
            //  routine for the directory.
            //

            RawDirent = (PRAW_DIRENT) CdRvdDirent( RawIsoVd, Vcb->VcbState );

            CopyUchar4( &PathEntry.DiskOffset, RawDirent->FileLoc );

            PathEntry.DiskOffset += RawDirent->XarLen;
            PathEntry.Ordinal = 1;
            PathEntry.PathTableOffset = Vcb->PathTableFcb->StreamOffset;

            CdInitializeFcbFromPathEntry( IrpContext,
                                          Vcb->RootIndexFcb,
                                          NULL,
                                          &PathEntry );

            //
            //  Create the stream file for the root directory.
            //

            CdCreateInternalStream( IrpContext, Vcb, Vcb->RootIndexFcb );

            //
            //  Now do the volume dasd Fcb.  Create this and reference it in the
            //  Vcb.
            //

            CdLockVcb( IrpContext, Vcb );
            UnlockVcb = TRUE;

            Vcb->VolumeDasdFcb = CdCreateFcb( IrpContext,
                                              *((PFILE_ID) &FileId),
                                              CDFS_NTC_FCB_DATA,
                                              NULL );

            CdIncrementReferenceCounts( IrpContext, Vcb->VolumeDasdFcb, 1, 1 );
            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;

            //
            //  The file size is the full disk.
            //

            StartingBlock = CdRvdVolSz( RawIsoVd, Vcb->VcbState );

            Vcb->VolumeDasdFcb->FileSize.QuadPart = LlBytesFromBlocks( Vcb, StartingBlock );

            Vcb->VolumeDasdFcb->AllocationSize.QuadPart =
            Vcb->VolumeDasdFcb->ValidDataLength.QuadPart = Vcb->VolumeDasdFcb->FileSize.QuadPart;

            //
            //  Now add the extent representing the volume 'by hand'.
            //

            CdLockFcb( IrpContext, Vcb->VolumeDasdFcb );

            McbEntry = Vcb->VolumeDasdFcb->Mcb.McbArray;

            McbEntry->FileOffset = 
            McbEntry->DiskOffset = 0;
            
            McbEntry->ByteCount = Vcb->VolumeDasdFcb->AllocationSize.QuadPart;
            
            McbEntry->DataBlockByteCount =
            McbEntry->TotalBlockByteCount = McbEntry->ByteCount;
            
            Vcb->VolumeDasdFcb->Mcb.CurrentEntryCount = 1;
    
            CdUnlockFcb( IrpContext, Vcb->VolumeDasdFcb );

            //
            //  Point to the file resource.
            //

            Vcb->VolumeDasdFcb->Resource = &Vcb->FileResource;

            Vcb->VolumeDasdFcb->FileAttributes = FILE_ATTRIBUTE_READONLY;

            //
            //  Mark the Fcb as initialized.
            //

            SetFlag( Vcb->VolumeDasdFcb->FcbState, FCB_STATE_INITIALIZED );

            //
            //  Check and see if this is an XA disk.
            //

            if (FlagOn( Vcb->VcbState, VCB_STATE_ISO | VCB_STATE_JOLIET)
                && RtlEqualMemory( CdXaId,
                                   Add2Ptr( RawIsoVd, 0x400, PCHAR ),
                                   8 )) {

                SetFlag( Vcb->VcbState, VCB_STATE_CDXA );
            }

        //
        //  If this is a music disk then we want to mock this disk to make it
        //  look like ISO disk.  We will create a pseudo root directory in
        //  that case.
        //

        } else if (FlagOn( Vcb->VcbState, VCB_STATE_AUDIO_DISK )) {

            ULONG RootDirectorySize;

            //
            //  Create the path table Fcb and refererence it and the Vcb.
            //

            CdLockVcb( IrpContext, Vcb );
            UnlockVcb = TRUE;

            Vcb->PathTableFcb = CdCreateFcb( IrpContext,
                                             *((PFILE_ID) &FileId),
                                             CDFS_NTC_FCB_PATH_TABLE,
                                             NULL );

            CdIncrementReferenceCounts( IrpContext, Vcb->PathTableFcb, 1, 1 );
            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;

            //
            //  We only create a pseudo entry for the root.
            //

            Vcb->PathTableFcb->FileSize.QuadPart = (LONGLONG) (FIELD_OFFSET( RAW_PATH_ISO, DirId ) + 2);

            Vcb->PathTableFcb->ValidDataLength.QuadPart = Vcb->PathTableFcb->FileSize.QuadPart;

            Vcb->PathTableFcb->AllocationSize.QuadPart = LlSectorAlign( Vcb->PathTableFcb->FileSize.QuadPart );

            //
            //  Point to the file resource.
            //

            Vcb->PathTableFcb->Resource = &Vcb->FileResource;

            //
            //  Mark the Fcb as initialized and create the stream file for this.
            //

            SetFlag( Vcb->PathTableFcb->FcbState, FCB_STATE_INITIALIZED );

            CdCreateInternalStream( IrpContext, Vcb, Vcb->PathTableFcb );

            //
            //  Create the root index and reference it in the Vcb.
            //

            CdLockVcb( IrpContext, Vcb );
            UnlockVcb = TRUE;
            Vcb->RootIndexFcb = CdCreateFcb( IrpContext,
                                             *((PFILE_ID) &FileId),
                                             CDFS_NTC_FCB_INDEX,
                                             NULL );

            CdIncrementReferenceCounts( IrpContext, Vcb->RootIndexFcb, 1, 1 );
            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;

            //
            //  Create the File id by hand for this Fcb.
            //

            CdSetFidPathTableOffset( Vcb->RootIndexFcb->FileId, Vcb->PathTableFcb->StreamOffset );
            CdFidSetDirectory( Vcb->RootIndexFcb->FileId );

            //
            //  Create a pseudo path table entry so we can call the initialization
            //  routine for the directory.
            //

            RtlZeroMemory( &PathEntry, sizeof( PATH_ENTRY ));


            PathEntry.Ordinal = 1;
            PathEntry.PathTableOffset = Vcb->PathTableFcb->StreamOffset;

            CdInitializeFcbFromPathEntry( IrpContext,
                                          Vcb->RootIndexFcb,
                                          NULL,
                                          &PathEntry );

            //
            //  Set the sizes by hand for this Fcb.  It should have an entry for each track plus an
            //  entry for the root and parent.
            //

            RootDirectorySize = (Vcb->TrackCount + 2) * CdAudioDirentSize;
            RootDirectorySize = SectorAlign( RootDirectorySize );

            Vcb->RootIndexFcb->AllocationSize.QuadPart =
            Vcb->RootIndexFcb->ValidDataLength.QuadPart =
            Vcb->RootIndexFcb->FileSize.QuadPart = RootDirectorySize;

            SetFlag( Vcb->RootIndexFcb->FcbState, FCB_STATE_INITIALIZED );

            //
            //  Create the stream file for the root directory.
            //

            CdCreateInternalStream( IrpContext, Vcb, Vcb->RootIndexFcb );

            //
            //  Now do the volume dasd Fcb.  Create this and reference it in the
            //  Vcb.
            //

            CdLockVcb( IrpContext, Vcb );
            UnlockVcb = TRUE;

            Vcb->VolumeDasdFcb = CdCreateFcb( IrpContext,
                                              *((PFILE_ID) &FileId),
                                              CDFS_NTC_FCB_DATA,
                                              NULL );

            CdIncrementReferenceCounts( IrpContext, Vcb->VolumeDasdFcb, 1, 1 );
            CdUnlockVcb( IrpContext, Vcb );
            UnlockVcb = FALSE;

            //
            //  We won't allow raw reads on this Fcb so leave the size at
            //  zero.
            //

            //
            //  Point to the file resource.
            //

            Vcb->VolumeDasdFcb->Resource = &Vcb->FileResource;

            Vcb->VolumeDasdFcb->FileAttributes = FILE_ATTRIBUTE_READONLY;

            //
            //  Mark the Fcb as initialized.
            //

            SetFlag( Vcb->VolumeDasdFcb->FcbState, FCB_STATE_INITIALIZED );

            //
            //  We will store a hard-coded name in the Vpb and use the toc as
            //  the serial number.
            //

            Vcb->Vpb->VolumeLabelLength = CdAudioLabelLength;

            RtlCopyMemory( Vcb->Vpb->VolumeLabel,
                           CdAudioLabel,
                           CdAudioLabelLength );

            //
            //  Find the serial number for the audio disk.
            //

            Vcb->Vpb->SerialNumber = CdTocSerial( IrpContext, Vcb->CdromToc );

            //
            //  Set the ISO bit so we know how to treat the names.
            //

            SetFlag( Vcb->VcbState, VCB_STATE_ISO );
        }
        
    } finally {

        if (UnlockVcb) { CdUnlockVcb( IrpContext, Vcb ); }
    }
}


VOID
CdDeleteVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb
    )

/*++

Routine Description:

    This routine is called to delete a Vcb which failed mount or has been
    dismounted.  The dismount code should have already removed all of the
    open Fcb's.  We do nothing here but clean up other auxilary structures.

Arguments:

    Vcb - Vcb to delete.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ASSERT_EXCLUSIVE_CDDATA;
    ASSERT_EXCLUSIVE_VCB( Vcb );

    //
    //  Chuck the backpocket Vpb we kept just in case.
    //

    if (Vcb->SwapVpb) {

        CdFreePool( &Vcb->SwapVpb );
    }
    
    //
    //  If there is a Vpb then we must delete it ourselves.
    //

    if (Vcb->Vpb != NULL) {

        CdFreePool( &Vcb->Vpb );
    }

    //
    //  Dereference our target if we haven't already done so.
    //

    if (Vcb->TargetDeviceObject != NULL) {
    
        ObDereferenceObject( Vcb->TargetDeviceObject );
    }

    //
    //  Delete the XA Sector if allocated.
    //

    if (Vcb->XASector != NULL) {

        CdFreePool( &Vcb->XASector );
    }

    //
    //  Remove this entry from the global queue.
    //

    RemoveEntryList( &Vcb->VcbLinks );

    //
    //  Delete the Vcb and File resources.
    //

    ExDeleteResourceLite( &Vcb->VcbResource );
    ExDeleteResourceLite( &Vcb->FileResource );

    //
    //  Delete the TOC if present.
    //

    if (Vcb->CdromToc != NULL) {

        CdFreePool( &Vcb->CdromToc );
    }

    //
    //  Uninitialize the notify structures.
    //

    if (Vcb->NotifySync != NULL) {

        FsRtlNotifyUninitializeSync( &Vcb->NotifySync );
    }

    //
    //  Now delete the volume device object.
    //

    IoDeleteDevice( (PDEVICE_OBJECT) CONTAINING_RECORD( Vcb,
                                                        VOLUME_DEVICE_OBJECT,
                                                        Vcb ));

    return;
}


PFCB
CdCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN FILE_ID FileId,
    IN NODE_TYPE_CODE NodeTypeCode,
    OUT PBOOLEAN FcbExisted OPTIONAL
    )

/*++

Routine Description:

    This routine is called to find the Fcb for the given FileId.  We will
    look this up first in the Fcb table and if not found we will create
    an Fcb.  We don't initialize it or insert it into the FcbTable in this
    routine.

    This routine is called while the Vcb is locked.

Arguments:

    FileId - This is the Id for the target Fcb.

    NodeTypeCode - Node type for this Fcb if we need to create.

    FcbExisted - If specified, we store whether the Fcb existed.

Return Value:

    PFCB - The Fcb found in the table or created if needed.

--*/

{
    PFCB NewFcb;
    BOOLEAN LocalFcbExisted;

    PAGED_CODE();

    //
    //  Use the local boolean if one was not passed in.
    //

    if (!ARGUMENT_PRESENT( FcbExisted )) {

        FcbExisted = &LocalFcbExisted;
    }

    //
    //  Maybe this is already in the table.
    //

    NewFcb = CdLookupFcbTable( IrpContext, IrpContext->Vcb, FileId );

    //
    //  If not then create the Fcb is requested by our caller.
    //

    if (NewFcb == NULL) {

        //
        //  Allocate and initialize the structure depending on the
        //  type code.
        //

        switch (NodeTypeCode) {

        case CDFS_NTC_FCB_PATH_TABLE:
        case CDFS_NTC_FCB_INDEX:

            NewFcb = CdAllocateFcbIndex( IrpContext );

            RtlZeroMemory( NewFcb, SIZEOF_FCB_INDEX );

            NewFcb->NodeByteSize = SIZEOF_FCB_INDEX;

            InitializeListHead( &NewFcb->FcbQueue );

            break;

        case CDFS_NTC_FCB_DATA :

            NewFcb = CdAllocateFcbData( IrpContext );

            RtlZeroMemory( NewFcb, SIZEOF_FCB_DATA );

            NewFcb->NodeByteSize = SIZEOF_FCB_DATA;

            break;

        default:

            CdBugCheck( 0, 0, 0 );
        }

        //
        //  Now do the common initialization.
        //

        NewFcb->NodeTypeCode = NodeTypeCode;

        NewFcb->Vcb = IrpContext->Vcb;
        NewFcb->FileId = FileId;

        CdInitializeMcb( IrpContext, NewFcb );

        //
        //  Now create the non-paged section object.
        //

        NewFcb->FcbNonpaged = CdCreateFcbNonpaged( IrpContext );

        //
        //  Deallocate the Fcb and raise if the allocation failed.
        //

        if (NewFcb->FcbNonpaged == NULL) {

            CdFreePool( &NewFcb );

            CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        *FcbExisted = FALSE;

        //
        //  Initialize Advanced FCB Header fields
        //

        ExInitializeFastMutex( &NewFcb->FcbNonpaged->AdvancedFcbHeaderMutex );
        FsRtlSetupAdvancedHeader( &NewFcb->Header, 
                                  &NewFcb->FcbNonpaged->AdvancedFcbHeaderMutex );
    } else {

        *FcbExisted = TRUE;
    }

    return NewFcb;
}


VOID
CdInitializeFcbFromPathEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB ParentFcb OPTIONAL,
    IN PPATH_ENTRY PathEntry
    )

/*++

Routine Description:

    This routine is called to initialize an Fcb for a directory from
    the path entry.  Since we only have a starting point for the directory,
    not the length, we can only speculate on the sizes.

    The general initialization is performed in CdCreateFcb.

Arguments:

    Fcb - Newly created Fcb for this stream.

    ParentFcb - Parent Fcb for this stream.  It may not be present.

    PathEntry - PathEntry for this Fcb in the Path Table.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Fill in the Index specific fields of the Fcb.
    //

    Fcb->StreamOffset = BytesFromBlocks( Fcb->Vcb,
                                         SectorBlockOffset( Fcb->Vcb, PathEntry->DiskOffset ));

    Fcb->Ordinal = PathEntry->Ordinal;

    //
    //  Initialize the common header in the Fcb.  The node type is already
    //  present.
    //

    Fcb->Resource = &Fcb->Vcb->FileResource;

    //
    //  Always set the sizes to one sector until we read the self-entry.
    //

    Fcb->AllocationSize.QuadPart =
    Fcb->FileSize.QuadPart =
    Fcb->ValidDataLength.QuadPart = SECTOR_SIZE;

    CdAddInitialAllocation( IrpContext,
                            Fcb,
                            PathEntry->DiskOffset,
                            SECTOR_SIZE );
    //
    //  State flags for this Fcb.
    //

    SetFlag( Fcb->FileAttributes,
             FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_DIRECTORY );

    //
    //  Link into the other in-memory structures and into the Fcb table.
    //

    if (ParentFcb != NULL) {

        Fcb->ParentFcb = ParentFcb;

        InsertTailList( &ParentFcb->FcbQueue, &Fcb->FcbLinks );

        CdIncrementReferenceCounts( IrpContext, ParentFcb, 1, 1 );
    }

    CdInsertFcbTable( IrpContext, Fcb );
    SetFlag( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE );

    return;
}


VOID
CdInitializeFcbFromFileContext (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB ParentFcb,
    IN PFILE_ENUM_CONTEXT FileContext
    )

/*++

Routine Description:

    This routine is called to initialize an Fcb for a file from
    the file context.  We have looked up all of the dirents for this
    stream and have the full file size.  We will load the all of the allocation
    for the file into the Mcb now.

    The general initialization is performed in CdCreateFcb.

Arguments:

    Fcb - Newly created Fcb for this stream.

    ParentFcb - Parent Fcb for this stream.

    FileContext - FileContext for the file.

Return Value:

    None

--*/

{
    PDIRENT ThisDirent = &FileContext->InitialDirent->Dirent;
    PCOMPOUND_DIRENT CurrentCompoundDirent;

    LONGLONG CurrentFileOffset;
    ULONG CurrentMcbEntryOffset;

    PAGED_CODE();

    //
    //  Use a try-finally to facilitate cleanup.
    //

    CdLockFcb( IrpContext, Fcb );

    try {

        //
        //  Initialize the common header in the Fcb.  The node type is already
        //  present.
        //

        Fcb->Resource = &IrpContext->Vcb->FileResource;

        //
        //  Allocation occurs in block-sized units.
        //

        Fcb->FileSize.QuadPart =
        Fcb->ValidDataLength.QuadPart = FileContext->FileSize;

        Fcb->AllocationSize.QuadPart = LlBlockAlign( Fcb->Vcb, FileContext->FileSize );

        //
        //  Set the flags from the dirent.  We always start with the read-only bit.
        //

        SetFlag( Fcb->FileAttributes, FILE_ATTRIBUTE_READONLY );
        if (FlagOn( ThisDirent->DirentFlags, CD_ATTRIBUTE_HIDDEN )) {

            SetFlag( Fcb->FileAttributes, FILE_ATTRIBUTE_HIDDEN );
        }

        //
        //  Convert the time to NT time.
        //

        CdConvertCdTimeToNtTime( IrpContext,
                                 ThisDirent->CdTime,
                                 (PLARGE_INTEGER) &Fcb->CreationTime );

        //
        //  Set the flag indicating the type of extent.
        //

        if (ThisDirent->ExtentType != Form1Data) {

            if (ThisDirent->ExtentType == Mode2Form2Data) {

                SetFlag( Fcb->FcbState, FCB_STATE_MODE2FORM2_FILE );

            } else {

                SetFlag( Fcb->FcbState, FCB_STATE_DA_FILE );
            }

            Fcb->XAAttributes = ThisDirent->XAAttributes;
            Fcb->XAFileNumber = ThisDirent->XAFileNumber;
        }

        //
        //  Read through all of the dirents for the file until we find the last
        //  and add the allocation into the Mcb.
        //

        CurrentCompoundDirent = FileContext->InitialDirent;
        CurrentFileOffset = 0;
        CurrentMcbEntryOffset = 0;

        while (TRUE) {

            CdAddAllocationFromDirent( IrpContext,
                                       Fcb,
                                       CurrentMcbEntryOffset,
                                       CurrentFileOffset,
                                       &CurrentCompoundDirent->Dirent );

            //
            //  Break out if we are at the last dirent.
            //

            if (!FlagOn( CurrentCompoundDirent->Dirent.DirentFlags, CD_ATTRIBUTE_MULTI )) {

                break;
            }

            CurrentFileOffset += CurrentCompoundDirent->Dirent.DataLength;
            CurrentMcbEntryOffset += 1;

            //
            //  We better be able to find the next dirent.
            //

            if (!CdLookupNextDirent( IrpContext,
                                     ParentFcb,
                                     &CurrentCompoundDirent->DirContext,
                                     &FileContext->CurrentDirent->DirContext )) {

                CdRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
            }

            CurrentCompoundDirent = FileContext->CurrentDirent;

            CdUpdateDirentFromRawDirent( IrpContext,
                                         ParentFcb,
                                         &CurrentCompoundDirent->DirContext,
                                         &CurrentCompoundDirent->Dirent );
        }

        //
        //  Show that the Fcb is initialized.
        //

        SetFlag( Fcb->FcbState, FCB_STATE_INITIALIZED );

        //
        //  Link into the other in-memory structures and into the Fcb table.
        //

        Fcb->ParentFcb = ParentFcb;

        InsertTailList( &ParentFcb->FcbQueue, &Fcb->FcbLinks );

        CdIncrementReferenceCounts( IrpContext, ParentFcb, 1, 1 );

        CdInsertFcbTable( IrpContext, Fcb );
        SetFlag( Fcb->FcbState, FCB_STATE_IN_FCB_TABLE );

    } finally {

        CdUnlockFcb( IrpContext, Fcb );
    }

    return;
}


PCCB
CdCreateCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN ULONG Flags
    )

/*++

Routine Description:

    This routine is called to allocate and initialize the Ccb structure.

Arguments:

    Fcb - This is the Fcb for the file being opened.

    Flags - User flags to set in this Ccb.

Return Value:

    PCCB - Pointer to the created Ccb.

--*/

{
    PCCB NewCcb;
    PAGED_CODE();

    //
    //  Allocate and initialize the structure.
    //

    NewCcb = CdAllocateCcb( IrpContext );

    RtlZeroMemory( NewCcb, sizeof( CCB ));

    //
    //  Set the proper node type code and node byte size
    //

    NewCcb->NodeTypeCode = CDFS_NTC_CCB;
    NewCcb->NodeByteSize = sizeof( CCB );

    //
    //  Set the initial value for the flags and Fcb
    //

    NewCcb->Flags = Flags;
    NewCcb->Fcb = Fcb;

    return NewCcb;
}


VOID
CdDeleteCcb (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb
    )
/*++

Routine Description:

    This routine is called to cleanup and deallocate a Ccb structure.

Arguments:

    Ccb - This is the Ccb to delete.

Return Value:

    None

--*/

{
    PAGED_CODE();

    if (Ccb->SearchExpression.FileName.Buffer != NULL) {

        CdFreePool( &Ccb->SearchExpression.FileName.Buffer );
    }

    CdDeallocateCcb( IrpContext, Ccb );
    return;
}


BOOLEAN
CdCreateFileLock (
    IN PIRP_CONTEXT IrpContext OPTIONAL,
    IN PFCB Fcb,
    IN BOOLEAN RaiseOnError
    )

/*++

Routine Description:

    This routine is called when we want to attach a file lock structure to the
    given Fcb.  It is possible the file lock is already attached.

    This routine is sometimes called from the fast path and sometimes in the
    Irp-based path.  We don't want to raise in the fast path, just return FALSE.

Arguments:

    Fcb - This is the Fcb to create the file lock for.

    RaiseOnError - If TRUE, we will raise on an allocation failure.  Otherwise we
        return FALSE on an allocation failure.

Return Value:

    BOOLEAN - TRUE if the Fcb has a filelock, FALSE otherwise.

--*/

{
    BOOLEAN Result = TRUE;
    PFILE_LOCK FileLock;

    PAGED_CODE();

    //
    //  Lock the Fcb and check if there is really any work to do.
    //

    CdLockFcb( IrpContext, Fcb );

    if (Fcb->FileLock != NULL) {

        CdUnlockFcb( IrpContext, Fcb );
        return TRUE;
    }

    Fcb->FileLock = FileLock =
        FsRtlAllocateFileLock( NULL, NULL );

    CdUnlockFcb( IrpContext, Fcb );

    //
    //  Return or raise as appropriate.
    //

    if (FileLock == NULL) {
         
        if (RaiseOnError) {

            ASSERT( ARGUMENT_PRESENT( IrpContext ));

            CdRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
        }

        Result = FALSE;
    }

    return Result;
}


PIRP_CONTEXT
CdCreateIrpContext (
    IN PIRP Irp,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This routine is called to initialize an IrpContext for the current
    CDFS request.  We allocate the structure and then initialize it from
    the given Irp.

Arguments:

    Irp - Irp for this request.

    Wait - TRUE if this request is synchronous, FALSE otherwise.

Return Value:

    PIRP_CONTEXT - Allocated IrpContext.

--*/

{
    PIRP_CONTEXT NewIrpContext = NULL;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  The only operations a filesystem device object should ever receive
    //  are create/teardown of fsdo handles and operations which do not
    //  occur in the context of fileobjects (i.e., mount).
    //

    if (IrpSp->DeviceObject == CdData.FileSystemDeviceObject) {

        if (IrpSp->FileObject != NULL &&
            IrpSp->MajorFunction != IRP_MJ_CREATE &&
            IrpSp->MajorFunction != IRP_MJ_CLEANUP &&
            IrpSp->MajorFunction != IRP_MJ_CLOSE) {

            ExRaiseStatus( STATUS_INVALID_DEVICE_REQUEST );
        }

        ASSERT( IrpSp->FileObject != NULL ||
                
                (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
                 IrpSp->MinorFunction == IRP_MN_USER_FS_REQUEST &&
                 IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_INVALIDATE_VOLUMES) ||
                
                (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
                 IrpSp->MinorFunction == IRP_MN_MOUNT_VOLUME ) ||

                IrpSp->MajorFunction == IRP_MJ_SHUTDOWN );
    }

    //
    //  Look in our lookaside list for an IrpContext.
    //

    if (CdData.IrpContextDepth) {

        CdLockCdData();
        NewIrpContext = (PIRP_CONTEXT) PopEntryList( &CdData.IrpContextList );
        if (NewIrpContext != NULL) {

            CdData.IrpContextDepth--;
        }

        CdUnlockCdData();
    }

    if (NewIrpContext == NULL) {

        //
        //  We didn't get it from our private list so allocate it from pool.
        //

        NewIrpContext = FsRtlAllocatePoolWithTag( NonPagedPool, sizeof( IRP_CONTEXT ), TAG_IRP_CONTEXT );
    }

    RtlZeroMemory( NewIrpContext, sizeof( IRP_CONTEXT ));

    //
    //  Set the proper node type code and node byte size
    //

    NewIrpContext->NodeTypeCode = CDFS_NTC_IRP_CONTEXT;
    NewIrpContext->NodeByteSize = sizeof( IRP_CONTEXT );

    //
    //  Set the originating Irp field
    //

    NewIrpContext->Irp = Irp;

    //
    //  Copy RealDevice for workque algorithms.  We will update this in the Mount or
    //  Verify since they have no file objects to use here.
    //

    if (IrpSp->FileObject != NULL) {

        NewIrpContext->RealDevice = IrpSp->FileObject->DeviceObject;
    }

    //
    //  Locate the volume device object and Vcb that we are trying to access.
    //  This may be our filesystem device object.  In that case don't initialize
    //  the Vcb field.
    //

    if (IrpSp->DeviceObject != CdData.FileSystemDeviceObject) {

        NewIrpContext->Vcb =  &((PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject)->Vcb;
    
    }

    //
    //  Major/Minor Function codes
    //

    NewIrpContext->MajorFunction = IrpSp->MajorFunction;
    NewIrpContext->MinorFunction = IrpSp->MinorFunction;

    //
    //  Set the wait parameter
    //

    if (Wait) {

        SetFlag( NewIrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    } else {

        SetFlag( NewIrpContext->Flags, IRP_CONTEXT_FLAG_FORCE_POST );
    }

    //
    //  return and tell the caller
    //

    return NewIrpContext;
}


VOID
CdCleanupIrpContext (
    IN PIRP_CONTEXT IrpContext,
    IN BOOLEAN Post
    )

/*++

Routine Description:

    This routine is called to cleanup and possibly deallocate the Irp Context.
    If the request is being posted or this Irp Context is possibly on the
    stack then we only cleanup any auxilary structures.

Arguments:

    Post - TRUE if we are posting this request, FALSE if we are deleting
        or retrying this in the current thread.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    //  If we aren't doing more processing then deallocate this as appropriate.
    //

    if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING)) {

        //
        //  If this context is the top level CDFS context then we need to
        //  restore the top level thread context.
        //

        if (IrpContext->ThreadContext != NULL) {

            CdRestoreThreadContext( IrpContext );
        }

        //
        //  Deallocate the Io context if allocated.
        //

        if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ALLOC_IO )) {

            CdFreeIoContext( IrpContext->IoContext );
        }

        //
        //  Deallocate the IrpContext if not from the stack.
        //

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_ON_STACK )) {

            if (CdData.IrpContextDepth < CdData.IrpContextMaxDepth) {

                CdLockCdData();

                PushEntryList( &CdData.IrpContextList, (PSINGLE_LIST_ENTRY) IrpContext );
                CdData.IrpContextDepth++;

                CdUnlockCdData();

            } else {

                //
                //  We couldn't add this to our lookaside list so free it to
                //  pool.
                //

                CdFreePool( &IrpContext );
            }
        }

    //
    //  Clear the appropriate flags.
    //

    } else if (Post) {

        //
        //  If this context is the top level CDFS context then we need to
        //  restore the top level thread context.
        //

        if (IrpContext->ThreadContext != NULL) {

            CdRestoreThreadContext( IrpContext );
        }

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAGS_CLEAR_ON_POST );

    } else {

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAGS_CLEAR_ON_RETRY );
    }

    return;
}


VOID
CdInitializeStackIrpContext (
    OUT PIRP_CONTEXT IrpContext,
    IN PIRP_CONTEXT_LITE IrpContextLite
    )

/*++

Routine Description:

    This routine is called to initialize an IrpContext for the current
    CDFS request.  The IrpContext is on the stack and we need to initialize
    it for the current request.  The request is a close operation.

Arguments:

    IrpContext - IrpContext to initialize.

    IrpContextLite - Structure containing the details of this request.

Return Value:

    None

--*/

{
    PAGED_CODE();

    //
    //  Zero and then initialize the structure.
    //

    RtlZeroMemory( IrpContext, sizeof( IRP_CONTEXT ));

    //
    //  Set the proper node type code and node byte size
    //

    IrpContext->NodeTypeCode = CDFS_NTC_IRP_CONTEXT;
    IrpContext->NodeByteSize = sizeof( IRP_CONTEXT );

    //
    //  Note that this is from the stack.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_ON_STACK );

    //
    //  Copy RealDevice for workque algorithms.
    //

    IrpContext->RealDevice = IrpContextLite->RealDevice;

    //
    //  The Vcb is found in the Fcb.
    //

    IrpContext->Vcb = IrpContextLite->Fcb->Vcb;

    //
    //  Major/Minor Function codes
    //

    IrpContext->MajorFunction = IRP_MJ_CLOSE;

    //
    //  Set the wait parameter
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    return;
}


VOID
CdTeardownStructures (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB StartingFcb,
    OUT PBOOLEAN RemovedStartingFcb
    )

/*++

Routine Description:

    This routine is used to walk from some starting point in the Fcb tree towards
    the root.  It will remove the Fcb and continue walking up the tree until
    it finds a point where we can't remove an Fcb.

    We look at the following fields in the Fcb to determine whether we can
    remove this.

        1 - Handle count must be zero.
        2 - If directory then only the only reference can be for a stream file.
        3 - Reference count must either be zero or go to zero here.

    We return immediately if we are recursively entering this routine.

Arguments:

    StartingFcb - This is the Fcb node in the tree to begin with.  This Fcb
        must currently be acquired exclusively.

    RemovedStartingFcb - Address to store whether we removed the starting Fcb.

Return Value:

    None

--*/

{
    PVCB Vcb = StartingFcb->Vcb;
    PFCB CurrentFcb = StartingFcb;
    BOOLEAN AcquiredCurrentFcb = FALSE;
    PFCB ParentFcb;

    PAGED_CODE();

    *RemovedStartingFcb = FALSE;

    //
    //  If this is a recursive call to TearDownStructures we return immediately
    //  doing no operation.
    //

    if (FlagOn( IrpContext->TopLevel->Flags, IRP_CONTEXT_FLAG_IN_TEARDOWN )) {

        return;
    }

    SetFlag( IrpContext->TopLevel->Flags, IRP_CONTEXT_FLAG_IN_TEARDOWN );

    //
    //  Use a try-finally to safely clear the top-level field.
    //

    try {

        //
        //  Loop until we find an Fcb we can't remove.
        //

        do {

            //
            //  See if there is an internal stream we should delete.
            //  Only do this if it is the last reference on the Fcb.
            //

            if ((SafeNodeType( CurrentFcb ) != CDFS_NTC_FCB_DATA) &&
                (CurrentFcb->FcbUserReference == 0) &&
                (CurrentFcb->FileObject != NULL)) {

                //
                //  Go ahead and delete the stream file object.
                //

                CdDeleteInternalStream( IrpContext, CurrentFcb );
            }

            //
            //  If the reference count is non-zero then break.
            //

            if (CurrentFcb->FcbReference != 0) {

                break;
            }

            //
            //  It looks like we have a candidate for removal here.  We
            //  will need to acquire the parent, if present, in order to
            //  remove this from the parent prefix table.
            //

            ParentFcb = CurrentFcb->ParentFcb;

            if (ParentFcb != NULL) {

                CdAcquireFcbExclusive( IrpContext, ParentFcb, FALSE );
            }

            //
            //  Now lock the vcb.
            //

            CdLockVcb( IrpContext, Vcb );

            //
            //  Final check to see if the reference count is still zero.
            //

            if (CurrentFcb->FcbReference != 0) {

                CdUnlockVcb( IrpContext, Vcb );

                if (ParentFcb != NULL) {

                    CdReleaseFcb( IrpContext, ParentFcb );
                }

                break;
            }

            //
            //  If there is a parent then do the necessary cleanup for the parent.
            //

            if (ParentFcb != NULL) {

                CdRemovePrefix( IrpContext, CurrentFcb );
                RemoveEntryList( &CurrentFcb->FcbLinks );

                CdDecrementReferenceCounts( IrpContext, ParentFcb, 1, 1 );
            }

            if (FlagOn( CurrentFcb->FcbState, FCB_STATE_IN_FCB_TABLE )) {

                CdDeleteFcbTable( IrpContext, CurrentFcb );
                ClearFlag( CurrentFcb->FcbState, FCB_STATE_IN_FCB_TABLE );

            }

            //
            //  Unlock the Vcb but hold the parent in order to walk up
            //  the tree.
            //

            CdUnlockVcb( IrpContext, Vcb );
            CdDeleteFcb( IrpContext, CurrentFcb );

            //
            //  Move to the parent Fcb.
            //

            CurrentFcb = ParentFcb;
            AcquiredCurrentFcb = TRUE;

        } while (CurrentFcb != NULL);

    } finally {

        //
        //  Release the current Fcb if we have acquired it.
        //

        if (AcquiredCurrentFcb && (CurrentFcb != NULL)) {

            CdReleaseFcb( IrpContext, CurrentFcb );
        }

        //
        //  Clear the teardown flag.
        //

        ClearFlag( IrpContext->TopLevel->Flags, IRP_CONTEXT_FLAG_IN_TEARDOWN );
    }

    *RemovedStartingFcb = (CurrentFcb != StartingFcb);
    return;
}


PFCB
CdLookupFcbTable (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FILE_ID FileId
    )

/*++

Routine Description:

    This routine will look through the Fcb table looking for a matching
    entry.

Arguments:

    Vcb - Vcb for this volume.

    FileId - This is the key value to use for the search.

Return Value:

    PFCB - A pointer to the matching entry or NULL otherwise.

--*/

{
    FCB_TABLE_ELEMENT Key;
    PFCB_TABLE_ELEMENT Hit;
    PFCB ReturnFcb = NULL;

    PAGED_CODE();

    Key.FileId = FileId;

    Hit = (PFCB_TABLE_ELEMENT) RtlLookupElementGenericTable( &Vcb->FcbTable, &Key );

    if (Hit != NULL) {

        ReturnFcb = Hit->Fcb;
    }

    return ReturnFcb;

    UNREFERENCED_PARAMETER( IrpContext );
}


PFCB
CdGetNextFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PVOID *RestartKey
    )

/*++

Routine Description:

    This routine will enumerate through all of the Fcb's in the Fcb table.

Arguments:

    Vcb - Vcb for this volume.

    RestartKey - This value is used by the table package to maintain
        its position in the enumeration.  It is initialized to NULL
        for the first search.

Return Value:

    PFCB - A pointer to the next fcb or NULL if the enumeration is
        completed

--*/

{
    PFCB Fcb;

    PAGED_CODE();

    Fcb = (PFCB) RtlEnumerateGenericTableWithoutSplaying( &Vcb->FcbTable, RestartKey );

    if (Fcb != NULL) {

        Fcb = ((PFCB_TABLE_ELEMENT)(Fcb))->Fcb;
    }

    return Fcb;
}


NTSTATUS
CdProcessToc (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PCDROM_TOC CdromToc,
    IN OUT PULONG Length,
    OUT PULONG TrackCount,
    OUT PULONG DiskFlags
    )

/*++

Routine Description:

    This routine is called to verify and process the TOC for this disk.
    We hide a data track for a CD+ volume.

Arguments:

    TargetDeviceObject - Device object to send TOC request to.

    CdromToc - Pointer to TOC structure.

    Length - On input this is the length of the TOC.  On return is the TOC
        length we will show to the user.

    TrackCount - This is the count of tracks for the TOC.  We use this
        when creating a pseudo directory for a music disk.

    DiskFlags - We return flags indicating what we know about this disk.

Return Value:

    NTSTATUS - The result of trying to read the TOC.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    ULONG CurrentTrack;
    ULONG LocalTrackCount;
    ULONG LocalTocLength;

    union {

        UCHAR BigEndian[2];
        USHORT Length;

    } BiasedTocLength;

    PTRACK_DATA Track;

    PAGED_CODE();

    //
    //  Go ahead and read the table of contents
    //

    Status = CdPerformDevIoCtrl( IrpContext,
                                 IOCTL_CDROM_READ_TOC,
                                 TargetDeviceObject,
                                 CdromToc,
                                 sizeof( CDROM_TOC ),
                                 FALSE,
                                 TRUE,
                                 &Iosb );

    //
    //  Nothing to process if this request fails.
    //

    if (Status != STATUS_SUCCESS) {

        return Status;
    }

    //
    //  Get the number of tracks and stated size of this structure.
    //

    CurrentTrack = 0;
    LocalTrackCount = CdromToc->LastTrack - CdromToc->FirstTrack + 1;
    LocalTocLength = PtrOffset( CdromToc, &CdromToc->TrackData[LocalTrackCount + 1] );

    //
    //  Get out if there is an immediate problem with the TOC.
    //

    if ((LocalTocLength > Iosb.Information) ||
        (CdromToc->FirstTrack > CdromToc->LastTrack)) {

        Status = STATUS_DISK_CORRUPT_ERROR;
        return Status;
    }

    //
    //  Walk through the individual tracks.  Stop at the first data track after
    //  any lead-in audio tracks.
    //

    do {

        //
        //  Get the next track.
        //

        Track = &CdromToc->TrackData[CurrentTrack];

        //
        //  If this is a data track then check if we have only seen audio tracks
        //  to this point.
        //

        if (FlagOn( Track->Control, TOC_DATA_TRACK )) {

            //
            //  If we have only seen audio tracks then assume this is a
            //  CD+ disk.  Hide the current data track and only return
            //  the previous audio tracks.  Set the disk type to be mixed
            //  data/audio.
            //

            if (FlagOn( *DiskFlags, CDROM_DISK_AUDIO_TRACK ) &&
                !FlagOn( *DiskFlags, CDROM_DISK_DATA_TRACK )) {

                //
                //  Remove one track from the TOC.
                //

                CdromToc->LastTrack -= 1;

                //
                //  Knock 2.5 minutes off the current track to
                //  hide the final leadin.
                //

                Track->Address[1] -= 2;
                Track->Address[2] += 30;

                if (Track->Address[2] < 60) {

                    Track->Address[1] -= 1;

                } else {

                    Track->Address[2] -= 60;
                }

                Track->TrackNumber = TOC_LAST_TRACK;

                //
                //  Set the disk type to mixed data/audio.
                //

                SetFlag( *DiskFlags, CDROM_DISK_DATA_TRACK );

                break;
            }

            //
            //  Set the flag to indicate data tracks present.
            //

            SetFlag( *DiskFlags, CDROM_DISK_DATA_TRACK );

        //
        //  If this is a audio track then set the flag indicating audio
        //  tracks.
        //

        } else {

            SetFlag( *DiskFlags, CDROM_DISK_AUDIO_TRACK );
        }

        //
        //  Set our index for the next track.
        //

        CurrentTrack += 1;

    } while (CurrentTrack < LocalTrackCount);

    //
    //  Set the length to point just past the last track we looked at.
    //

    *TrackCount = CurrentTrack;
    *Length = PtrOffset( CdromToc, &CdromToc->TrackData[CurrentTrack + 1] );
    BiasedTocLength.Length = (USHORT) *Length - 2;

    CdromToc->Length[0] = BiasedTocLength.BigEndian[1];
    CdromToc->Length[1] = BiasedTocLength.BigEndian[0];

    return Status;
}


//
//  Local support routine
//

VOID
CdDeleteFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called to cleanup and deallocate an Fcb.  We know there
    are no references remaining.  We cleanup any auxilary structures and
    deallocate this Fcb.

Arguments:

    Fcb - This is the Fcb to deallcoate.

Return Value:

    None

--*/

{
    PVCB Vcb = NULL;
    PAGED_CODE();

    //
    //  Sanity check the counts.
    //

    ASSERT( Fcb->FcbCleanup == 0 );
    ASSERT( Fcb->FcbReference == 0 );

    //
    //  Release any Filter Context structures associated with this FCB
    //

    FsRtlTeardownPerStreamContexts( &Fcb->Header );

    //
    //  Start with the common structures.
    //

    CdUninitializeMcb( IrpContext, Fcb );

    CdDeleteFcbNonpaged( IrpContext, Fcb->FcbNonpaged );

    //
    //  Check if we need to deallocate the prefix name buffer.
    //

    if ((Fcb->FileNamePrefix.ExactCaseName.FileName.Buffer != (PWCHAR) Fcb->FileNamePrefix.FileNameBuffer) &&
        (Fcb->FileNamePrefix.ExactCaseName.FileName.Buffer != NULL)) {

        CdFreePool( &Fcb->FileNamePrefix.ExactCaseName.FileName.Buffer );
    }

    //
    //  Now look at the short name prefix.
    //

    if (Fcb->ShortNamePrefix != NULL) {

        CdFreePool( &Fcb->ShortNamePrefix );
    }

    //
    //  Now do the type specific structures.
    //

    switch (Fcb->NodeTypeCode) {

    case CDFS_NTC_FCB_PATH_TABLE:
    case CDFS_NTC_FCB_INDEX:

        ASSERT( Fcb->FileObject == NULL );
        ASSERT( IsListEmpty( &Fcb->FcbQueue ));

        if (Fcb == Fcb->Vcb->RootIndexFcb) {

            Vcb = Fcb->Vcb;
            Vcb->RootIndexFcb = NULL;

        } else if (Fcb == Fcb->Vcb->PathTableFcb) {

            Vcb = Fcb->Vcb;
            Vcb->PathTableFcb = NULL;
        }

        CdDeallocateFcbIndex( IrpContext, Fcb );
        break;

    case CDFS_NTC_FCB_DATA :

        if (Fcb->FileLock != NULL) {

            FsRtlFreeFileLock( Fcb->FileLock );
        }

        FsRtlUninitializeOplock( &Fcb->Oplock );

        if (Fcb == Fcb->Vcb->VolumeDasdFcb) {

            Vcb = Fcb->Vcb;
            Vcb->VolumeDasdFcb = NULL;
        }

        CdDeallocateFcbData( IrpContext, Fcb );
    }

    //
    //  Decrement the Vcb reference count if this is a system
    //  Fcb.
    //

    if (Vcb != NULL) {

        InterlockedDecrement( &Vcb->VcbReference );
        InterlockedDecrement( &Vcb->VcbUserReference );
    }

    return;
}


//
//  Local support routine
//

PFCB_NONPAGED
CdCreateFcbNonpaged (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine is called to create and initialize the non-paged portion
    of an Fcb.

Arguments:

Return Value:

    PFCB_NONPAGED - Pointer to the created nonpaged Fcb.  NULL if not created.

--*/

{
    PFCB_NONPAGED FcbNonpaged;

    PAGED_CODE();

    //
    //  Allocate the non-paged pool and initialize the various
    //  synchronization objects.
    //

    FcbNonpaged = CdAllocateFcbNonpaged( IrpContext );

    if (FcbNonpaged != NULL) {

        RtlZeroMemory( FcbNonpaged, sizeof( FCB_NONPAGED ));

        FcbNonpaged->NodeTypeCode = CDFS_NTC_FCB_NONPAGED;
        FcbNonpaged->NodeByteSize = sizeof( FCB_NONPAGED );

        ExInitializeResourceLite( &FcbNonpaged->FcbResource );
        ExInitializeFastMutex( &FcbNonpaged->FcbMutex );
    }

    return FcbNonpaged;
}


//
//  Local support routine
//

VOID
CdDeleteFcbNonpaged (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB_NONPAGED FcbNonpaged
    )

/*++

Routine Description:

    This routine is called to cleanup the non-paged portion of an Fcb.

Arguments:

    FcbNonpaged - Structure to clean up.

Return Value:

    None

--*/

{
    PAGED_CODE();

    ExDeleteResourceLite( &FcbNonpaged->FcbResource );

    CdDeallocateFcbNonpaged( IrpContext, FcbNonpaged );

    return;
}


//
//  Local support routine
//

RTL_GENERIC_COMPARE_RESULTS
CdFcbTableCompare (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID Fid1,
    IN PVOID Fid2
    )

/*++

Routine Description:

    This routine is the Cdfs compare routine called by the generic table package.
    If will compare the two File Id values and return a comparison result.

Arguments:

    FcbTable - This is the table being searched.

    Fid1 - First key value.

    Fid2 - Second key value.

Return Value:

    RTL_GENERIC_COMPARE_RESULTS - The results of comparing the two
        input structures

--*/

{
    FILE_ID Id1, Id2;
    PAGED_CODE();

    Id1 = *((FILE_ID UNALIGNED *) Fid1);
    Id2 = *((FILE_ID UNALIGNED *) Fid2);

    if (Id1.QuadPart < Id2.QuadPart) {

        return GenericLessThan;

    } else if (Id1.QuadPart > Id2.QuadPart) {

        return GenericGreaterThan;

    } else {

        return GenericEqual;
    }

    UNREFERENCED_PARAMETER( FcbTable );
}


//
//  Local support routine
//

PVOID
CdAllocateFcbTable (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN CLONG ByteSize
    )

/*++

Routine Description:

    This is a generic table support routine to allocate memory

Arguments:

    FcbTable - Supplies the generic table being used

    ByteSize - Supplies the number of bytes to allocate

Return Value:

    PVOID - Returns a pointer to the allocated data

--*/

{
    PAGED_CODE();

    return( FsRtlAllocatePoolWithTag( CdPagedPool, ByteSize, TAG_FCB_TABLE ));
}


//
//  Local support routine
//

VOID
CdDeallocateFcbTable (
    IN PRTL_GENERIC_TABLE FcbTable,
    IN PVOID Buffer
    )

/*++

Routine Description:

    This is a generic table support routine that deallocates memory

Arguments:

    FcbTable - Supplies the generic table being used

    Buffer - Supplies the buffer being deallocated

Return Value:

    None.

--*/

{
    PAGED_CODE();

    CdFreePool( &Buffer );

    UNREFERENCED_PARAMETER( FcbTable );
}


//
//  Local support routine
//

ULONG
CdTocSerial (
    IN PIRP_CONTEXT IrpContext,
    IN PCDROM_TOC CdromToc
    )

/*++

Routine Description:

    This routine is called to generate a serial number for an audio disk.
    The number is based on the starting positions of the tracks.
    The following algorithm is used.

    If the number of tracks is <= 2 then initialize the serial number to the
    leadout block number.

    Then add the starting address of each track (use 0x00mmssff format).

Arguments:

    CdromToc - Valid table of contents to use for track information.

Return Value:

    ULONG - 32 bit serial number based on TOC.

--*/

{
    ULONG SerialNumber = 0;
    PTRACK_DATA ThisTrack;
    PTRACK_DATA LastTrack;

    PAGED_CODE();

    //
    //  Check if there are two tracks or fewer.
    //

    LastTrack = &CdromToc->TrackData[ CdromToc->LastTrack - CdromToc->FirstTrack + 1];
    ThisTrack = &CdromToc->TrackData[0];

    if (CdromToc->LastTrack - CdromToc->FirstTrack <= 1) {

        SerialNumber = (((LastTrack->Address[1] * 60) + LastTrack->Address[2]) * 75) + LastTrack->Address[3];

        SerialNumber -= (((ThisTrack->Address[1] * 60) + ThisTrack->Address[2]) * 75) + ThisTrack->Address[3];
    }

    //
    //  Now find the starting offset of each track and add to the serial number.
    //

    while (ThisTrack != LastTrack) {

        SerialNumber += (ThisTrack->Address[1] << 16);
        SerialNumber += (ThisTrack->Address[2] << 8);
        SerialNumber += ThisTrack->Address[3];
        ThisTrack += 1;
    }

    return SerialNumber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\cdfs\workque.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    WorkQue.c

Abstract:

    This module implements the Work queue routines for the Cdfs File
    system.

// @@BEGIN_DDKSPLIT

Author:

    Brian Andrew    [BrianAn]   01-July-1995

Revision History:

// @@END_DDKSPLIT

--*/

#include "CdProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (CDFS_BUG_CHECK_WORKQUE)

//
//  The following constant is the maximum number of ExWorkerThreads that we
//  will allow to be servicing a particular target device at any one time.
//

#define FSP_PER_DEVICE_THRESHOLD         (2)

//
//  Local support routines
//

VOID
CdAddToWorkque (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, CdFsdPostRequest)
#pragma alloc_text(PAGE, CdOplockComplete)
#pragma alloc_text(PAGE, CdPrePostIrp)
#endif


NTSTATUS
CdFsdPostRequest (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine enqueues the request packet specified by IrpContext to the
    work queue associated with the FileSystemDeviceObject.  This is a FSD
    routine.

Arguments:

    IrpContext - Pointer to the IrpContext to be queued to the Fsp.

    Irp - I/O Request Packet.

Return Value:

    STATUS_PENDING

--*/

{
    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Posting is a three step operation.  First lock down any buffers
    //  in the Irp.  Next cleanup the IrpContext for the post and finally
    //  add this to a workque.
    //

    CdPrePostIrp( IrpContext, Irp );

    CdAddToWorkque( IrpContext, Irp );

    //
    //  And return to our caller
    //

    return STATUS_PENDING;
}


VOID
CdPrePostIrp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs any neccessary work before STATUS_PENDING is
    returned with the Fsd thread.  This routine is called within the
    filesystem and by the oplock package.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );
    BOOLEAN RemovedFcb;

    PAGED_CODE();

    ASSERT_IRP_CONTEXT( IrpContext );
    ASSERT_IRP( Irp );

    //
    //  Case on the type of the operation.
    //

    switch (IrpContext->MajorFunction) {

    case IRP_MJ_CREATE :

        //
        //  If called from the oplock package then there is an
        //  Fcb to possibly teardown.  We will call the teardown
        //  routine and release the Fcb if still present.  The cleanup
        //  code in create will know not to release this Fcb because
        //  we will clear the pointer.
        //

        if ((IrpContext->TeardownFcb != NULL) &&
            *(IrpContext->TeardownFcb) != NULL) {

            CdTeardownStructures( IrpContext, *(IrpContext->TeardownFcb), &RemovedFcb );

            if (!RemovedFcb) {

                CdReleaseFcb( IrpContext, *(IrpContext->TeardownFcb) );
            }

            *(IrpContext->TeardownFcb) = NULL;
            IrpContext->TeardownFcb = NULL;
        }

        break;

    //
    //  We need to lock the user's buffer, unless this is an MDL-read,
    //  in which case there is no user buffer.
    //

    case IRP_MJ_READ :

        if (!FlagOn( IrpContext->MinorFunction, IRP_MN_MDL )) {

            CdLockUserBuffer( IrpContext, IrpSp->Parameters.Read.Length );
        }

        break;

    //
    //  We also need to check whether this is a query file operation.
    //

    case IRP_MJ_DIRECTORY_CONTROL :

        if (IrpContext->MinorFunction == IRP_MN_QUERY_DIRECTORY) {

            CdLockUserBuffer( IrpContext, IrpSp->Parameters.QueryDirectory.Length );
        }

        break;
    }

    //
    //  Cleanup the IrpContext for the post.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_MORE_PROCESSING );
    CdCleanupIrpContext( IrpContext, TRUE );

    //
    //  Mark the Irp to show that we've already returned pending to the user.
    //

    IoMarkIrpPending( Irp );

    return;
}


VOID
CdOplockComplete (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the oplock package when an oplock break has
    completed, allowing an Irp to resume execution.  If the status in
    the Irp is STATUS_SUCCESS, then we queue the Irp to the Fsp queue.
    Otherwise we complete the Irp with the status in the Irp.

    If we are completing due to an error then check if there is any
    cleanup to do.

Arguments:

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    BOOLEAN RemovedFcb;

    PAGED_CODE();

    //
    //  Check on the return value in the Irp.  If success then we
    //  are to post this request.
    //

    if (Irp->IoStatus.Status == STATUS_SUCCESS) {

        //
        //  Check if there is any cleanup work to do.
        //

        switch (IrpContext->MajorFunction) {

        case IRP_MJ_CREATE :

            //
            //  If called from the oplock package then there is an
            //  Fcb to possibly teardown.  We will call the teardown
            //  routine and release the Fcb if still present.  The cleanup
            //  code in create will know not to release this Fcb because
            //  we will clear the pointer.
            //

            if (IrpContext->TeardownFcb != NULL) {

                CdTeardownStructures( IrpContext, *(IrpContext->TeardownFcb), &RemovedFcb );

                if (!RemovedFcb) {

                    CdReleaseFcb( IrpContext, *(IrpContext->TeardownFcb) );
                }

                *(IrpContext->TeardownFcb) = NULL;
                IrpContext->TeardownFcb = NULL;
            }

            break;
        }

        //
        //  Insert the Irp context in the workqueue.
        //

        CdAddToWorkque( IrpContext, Irp );

    //
    //  Otherwise complete the request.
    //

    } else {

        CdCompleteRequest( IrpContext, Irp, Irp->IoStatus.Status );
    }

    return;
}


//
//  Local support routine
//

VOID
CdAddToWorkque (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to acually store the posted Irp to the Fsp
    workque.

Arguments:

    IrpContext - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    PVOLUME_DEVICE_OBJECT Vdo;
    KIRQL SavedIrql;
    PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Check if this request has an associated file object, and thus volume
    //  device object.
    //

    if (IrpSp->FileObject != NULL) {


        Vdo = CONTAINING_RECORD( IrpSp->DeviceObject,
                                 VOLUME_DEVICE_OBJECT,
                                 DeviceObject );

        //
        //  Check to see if this request should be sent to the overflow
        //  queue.  If not, then send it off to an exworker thread.
        //

        KeAcquireSpinLock( &Vdo->OverflowQueueSpinLock, &SavedIrql );

        if (Vdo->PostedRequestCount > FSP_PER_DEVICE_THRESHOLD) {

            //
            //  We cannot currently respond to this IRP so we'll just enqueue it
            //  to the overflow queue on the volume.
            //

            InsertTailList( &Vdo->OverflowQueue,
                            &IrpContext->WorkQueueItem.List );

            Vdo->OverflowQueueCount += 1;

            KeReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );

            return;

        } else {

            //
            //  We are going to send this Irp to an ex worker thread so up
            //  the count.
            //

            Vdo->PostedRequestCount += 1;

            KeReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );
        }
    }

    //
    //  Send it off.....
    //

    ExInitializeWorkItem( &IrpContext->WorkQueueItem,
                          CdFspDispatch,
                          IrpContext );

    ExQueueWorkItem( &IrpContext->WorkQueueItem, CriticalWorkQueue );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\efs\control.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   control.c

Abstract:

   This module contains the code to handle the IRP MajorFunctions of
   IRP_MJ_DEVICE_CONTROL and IRP_MJ_FILE_SYSTEM_CONTROL. The code will
   be responsible for correctly setting these IRP's with any necessary
   information and passing them along. Any other support routine which are
   directly releated (such as completion routines) to these operations can
   be found in this module.

Author:

    Robert Gu (robertg) 29-Oct-1996

Environment:

    Kernel mode


Revision History:


--*/

#include "efs.h"
#include "efsrtl.h"
#include "efsext.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, EFSFsControl)
#endif


NTSTATUS
EFSFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    PIO_STACK_LOCATION nextIrpSp;
    PDEVICE_OBJECT deviceObject;
    PKEVENT finishEvent;

    PAGED_CODE();

    if ( (irpSp->MinorFunction == IRP_MN_USER_FS_REQUEST) &&
                    (irpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_SET_COMPRESSION) &&
                    ( (irpSp->Parameters.FileSystemControl.InputBufferLength >= sizeof (USHORT)) && 
                      (*(PUSHORT)(Irp->AssociatedIrp.SystemBuffer) != 0 /*COMPRESSION_FORMAT_NONE*/)
                    )
                  ){
        //
        // Compression on encrypted file is not allowed.
        // Check if the file is encrypted or not
        //
        ULONG inputDataLength;
        UCHAR *inputDataBuffer, *outputDataBuffer;
        ULONG outputDataLength;
        KEVENT event;
        IO_STATUS_BLOCK ioStatus;
        PIRP fsCtlIrp;
        PIO_STACK_LOCATION fsCtlIrpSp;

        inputDataLength = FIELD_OFFSET(FSCTL_INPUT, EfsFsData[0]) +
                          FIELD_OFFSET(GENERAL_FS_DATA, EfsData[0]);

        inputDataBuffer = ExAllocatePoolWithTag(
                    PagedPool,
                    inputDataLength,
                    'msfE'
                    );

        //
        // The size of output data buffer is not important. We don't
        // care the content. We just need to know the $EFS exists.
        //

        outputDataLength = 1024;
        outputDataBuffer = ExAllocatePoolWithTag(
                    PagedPool,
                    outputDataLength,
                    'msfE'
                    );

        if ( ( NULL == inputDataBuffer ) || ( NULL == outputDataBuffer ) ){

            //
            // Out of memory
            //

            if ( inputDataBuffer ){

                ExFreePool( inputDataBuffer );

            }
            if ( outputDataBuffer ){

                ExFreePool( outputDataBuffer );

            }

            return STATUS_INSUFFICIENT_RESOURCES;
        }


        ((PFSCTL_INPUT)inputDataBuffer)->EfsFsCode = EFS_GET_ATTRIBUTE;

        RtlCopyMemory(
            &(((PFSCTL_INPUT)inputDataBuffer)->EfsFsData[0]),
            &(EfsData.SessionKey),
            DES_KEYSIZE
            );

        RtlCopyMemory(
            &(((PFSCTL_INPUT)inputDataBuffer)->EfsFsData[0]) + DES_KEYSIZE + 2 * sizeof( ULONG ),
            &(((PFSCTL_INPUT)inputDataBuffer)->EfsFsData[0]),
            DES_KEYSIZE + 2 * sizeof( ULONG )
            );

        //
        // Encrypt our Input data
        //
        EfsEncryptKeyFsData(
            inputDataBuffer,
            inputDataLength,
            sizeof(ULONG),
            EFS_FSCTL_HEADER_LENGTH + DES_KEYSIZE + 2 * sizeof( ULONG ),
            DES_KEYSIZE + 2 * sizeof( ULONG )
            );

        //
        // Prepare a FSCTL IRP
        //
        KeInitializeEvent( &event, SynchronizationEvent, FALSE);

        fsCtlIrp = IoBuildDeviceIoControlRequest( FSCTL_ENCRYPTION_FSCTL_IO,
                                             DeviceObject,
                                             inputDataBuffer,
                                             inputDataLength,
                                             outputDataBuffer,
                                             outputDataLength,
                                             FALSE,
                                             &event,
                                             &ioStatus
                                             );
        if ( fsCtlIrp ) {

            fsCtlIrpSp = IoGetNextIrpStackLocation( fsCtlIrp );
            fsCtlIrpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
            fsCtlIrpSp->MinorFunction = IRP_MN_USER_FS_REQUEST;
            fsCtlIrpSp->FileObject = irpSp->FileObject;

            status = IoCallDriver( DeviceObject, fsCtlIrp);
            if (status == STATUS_PENDING) {

                status = KeWaitForSingleObject( &event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       (PLARGE_INTEGER) NULL );
                status = ioStatus.Status;
            }

            ExFreePool( inputDataBuffer );
            ExFreePool( outputDataBuffer );

            if ( NT_SUCCESS(status) || ( STATUS_BUFFER_TOO_SMALL == status) ){
                //
                // $EFS exist, encrypted file. Deny compression
                //

                return STATUS_INVALID_DEVICE_REQUEST;
            }

        } else {
            //
            // Failed allocate IRP
            //

            ExFreePool( inputDataBuffer );
            ExFreePool( outputDataBuffer );

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        //
        // Compression allowed. Simply pass this file system control request through.
        //

        status = STATUS_SUCCESS;

    } else {

        //
        // Simply pass this file system control request through.
        //

        status = STATUS_SUCCESS;

    }

    //
    // Any special processing has been completed, so simply pass the request
    // along to the next driver.
    //

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\efs\efs.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Abstract:

   This module contains the common header information for the EFS
   file system filter driver.

Author:

   Robert Gu (robertg)  29-Oct-1996

Enviroment:

   Kernel Mode Only

Revision History:

--*/
#ifndef EFS_H
#define EFS_H

#include "ntifs.h"

//
// BYTE is required by des.h
// PBYTE is required by des3.h
//
typedef unsigned char  BYTE;
typedef unsigned long  DWORD;
typedef unsigned char  *PBYTE; 

#include "fipsapi.h"
//#include "des.h"
//#include "tripldes.h"
#include "aes.h"
#include "ntfsexp.h"
#include "efsstruc.h"

#if DBG

#define EFSTRACEALL     0x00000001
#define EFSTRACELIGHT   0x00000002
#define EFSTRACEMED     0x00000004
#define EFSSTOPALL      0x00000010
#define EFSSTOPLIGHT    0x00000020
#define EFSSTOPMED      0x00000040

#endif // DBG

#ifndef CALG_DES
//
// Definition from sdk\inc\wincrypt.h
// Including wincrypt.h causes too much work.
//
#define ALG_CLASS_DATA_ENCRYPT          (3 << 13)
#define ALG_TYPE_BLOCK                  (3 << 9)
#define ALG_SID_DES                     1
#define ALG_SID_3DES                    3
#define ALG_SID_DESX                    4
#define ALG_SID_AES_256                 16
#define ALG_SID_AES                     17
#define CALG_DES                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_DES)
#define CALG_DESX               (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_DESX)
#define CALG_3DES               (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_3DES)
#define CALG_AES_256            (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES_256)
#define CALG_AES                (ALG_CLASS_DATA_ENCRYPT|ALG_TYPE_BLOCK|ALG_SID_AES)

#endif


//
// Define the device extension structure for this driver's extensions.
//

#define EFSFILTER_DEVICE_TYPE   0x1309

#define EFS_EVENTDEPTH     3
#define EFS_CONTEXTDEPTH   5
#define EFS_KEYDEPTH       30
#define EFS_ALGDEPTH       3

//
// Define the constants used in Open Cache
//

#define DefaultTimeExpirePeriod    5 * 10000000  // 5 seconds
#define MINCACHEPERIOD             2
#define MAXCACHEPERIOD             30
#define EFS_CACHEDEPTH  5

#define EFS_STREAM_NORMAL 0
#define EFS_STREAM_TRANSITION 1
#define EFS_STRNAME_LENGTH  6
#define EFS_FSCTL_HEADER_LENGTH 3 * sizeof( ULONG )

//
// Define test MACRO
//


#define CheckValidKeyBlock(PContext, Msg)

/*
#define CheckValidKeyBlock(PContext, Msg)    {                            \
    if (PContext) {                                                       \
       if (((PKEY_BLOB) PContext)->KeyLength != DESX_KEY_BLOB_LENGTH){    \
          DbgPrint(Msg);                                                  \
       }                                                                  \
       ASSERT(((PKEY_BLOB) PContext)->KeyLength == DESX_KEY_BLOB_LENGTH); \
    }                                                                     \
}
*/


#define FreeMemoryBlock(PContext) {                      \
    RtlSecureZeroMemory(&(((PKEY_BLOB)(*PContext))->Key[0]), ((PKEY_BLOB)(*PContext))->KeyLength - KEYBLOB_HEAD_LENGTH); \
    ExFreeToNPagedLookasideList(((PKEY_BLOB)(*PContext))->MemSource, *PContext);   \
    *PContext = NULL;                                    \
}

/*
#define FreeMemoryBlock(PContext) {                      \
    PNPAGED_LOOKASIDE_LIST MemSource;                    \
    MemSource = ((PKEY_BLOB)(*PContext))->MemSource;     \
    RtlFillMemory(*PContext, DESX_KEY_BLOB_LENGTH, 0x45);\
    ExFreeToNPagedLookasideList(MemSource, *PContext);   \
    *PContext = NULL;                                    \
}
*/


typedef CSHORT NODE_TYPE_CODE, *PNODE_TYPE_CODE;
typedef CSHORT NODE_BYTE_SIZE, *PNODE_BYTE_SIZE;

#define NTC_UNDEFINED                  ((NODE_TYPE_CODE)0x0000)
#define EFS_NTC_DATA_HEADER            ((NODE_TYPE_CODE)0x0E04)


#define KEYBLOB_HEAD_LENGTH  (2 * sizeof(ULONG) + sizeof(PNPAGED_LOOKASIDE_LIST))
#define DES_KEY_BLOB_LENGTH  (KEYBLOB_HEAD_LENGTH  + DES_TABLESIZE)
#define DESX_KEY_BLOB_LENGTH  (KEYBLOB_HEAD_LENGTH + DESX_TABLESIZE)
#define DES3_KEY_BLOB_LENGTH  (KEYBLOB_HEAD_LENGTH + DES3_TABLESIZE)
#define AES_KEY_BLOB_LENGTH_256   (KEYBLOB_HEAD_LENGTH + AES_TABLESIZE_256)

//
// EFS device object extension
//

typedef struct _DEVICE_EXTENSION {
    CSHORT Type;
    CSHORT Size;
    PDEVICE_OBJECT FileSystemDeviceObject;
    PDEVICE_OBJECT RealDeviceObject;
    BOOLEAN Attached;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// EFS context block. Attached to CREATE Irp
//

typedef struct _EFS_CONTEXT {

    //
    // Status information
    //

    ULONG   Status;
    ULONG   Flags;

    PVOID   EfsStreamData;

    KEVENT  FinishEvent;



} EFS_CONTEXT, *PEFS_CONTEXT;

//
// The keyBlob.
//

typedef struct _KEY_BLOB {

    ULONG   KeyLength;

    //
    // Indicate what kind of encryption used
    //

    ULONG   AlgorithmID;

    //
    // Where the memory comes from
    //

    PNPAGED_LOOKASIDE_LIST MemSource;
    UCHAR   Key[1];

} KEY_BLOB, *PKEY_BLOB;

typedef struct _KEY_BLOB_RAMPOOL {

    ULONG   AlgorithmID;
    PNPAGED_LOOKASIDE_LIST MemSourceList;
    LIST_ENTRY MemSourceChain;

}  KEY_BLOB_RAMPOOL, *PKEY_BLOB_RAMPOOL;

//
//   EFS Open Cache Node
//

typedef struct _OPEN_CACHE {

    GUID    EfsId;
    PTOKEN_USER    UserId;
    LARGE_INTEGER TimeStamp;
    LIST_ENTRY CacheChain;

}  OPEN_CACHE, *POPEN_CACHE;

//
//  The EFS_DATA keeps global data in the EFS file system in-memory
//  This structure must be allocated from non-paged pool.
//
typedef struct _EFS_DATA {

    //
    //  The type and size of this record (must be EFS_NTC_DATA_HEADER)
    //

    NODE_TYPE_CODE NodeTypeCode;
    NODE_BYTE_SIZE NodeByteSize;
    DWORD          EfsDriverCacheLength;  // Cache valid length 2 - 30 seconds       

    //
    // A Lookaside List for event object
    // The event object are used in synchronization.
    //
    NPAGED_LOOKASIDE_LIST EfsEventPool;

    //
    // A Lookaside List for EFS context
    // The EFS context is used in Create Irp.
    //
    NPAGED_LOOKASIDE_LIST EfsContextPool;


    //
    //  A lookaside list for open operation cache
    //
    PAGED_LOOKASIDE_LIST EfsOpenCachePool;

    LIST_ENTRY EfsOpenCacheList;
    FAST_MUTEX EfsOpenCacheMutex;

    //
    // Lookaside Lists for key blob
    //

    LIST_ENTRY EfsKeyLookAsideList;
    FAST_MUTEX EfsKeyBlobMemSrcMutex;
    PAGED_LOOKASIDE_LIST EfsMemSourceItem;
    NPAGED_LOOKASIDE_LIST EfsLookAside;

    //
    // Session key.
    // Used to decrypt the FSCTL input buffer.
    //
    UCHAR  SessionKey[DES_KEYSIZE];
    UCHAR  SessionDesTable[DES_TABLESIZE];
    PRKPROCESS LsaProcess;

    //
    // Flag indicate EFS is ready
    //
    BOOLEAN EfsInitialized;
    BOOLEAN AllocMaxBuffer;
    HANDLE  InitEventHandle;

    //PDEVICE_OBJECT      FipsDeviceObject;
    PFILE_OBJECT        FipsFileObject;
    FIPS_FUNCTION_TABLE FipsFunctionTable;

    //
    // Efs special attribute name
    //
    UNICODE_STRING EfsName;

} EFS_DATA, *PEFS_DATA;

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

//#ifndef BooleanFlagOn
//#define BooleanFlagOn(F,SF) (    \
//    (BOOLEAN)(((F) & (SF)) != 0) \
//)
//#endif

//#ifndef SetFlag
//#define SetFlag(Flags,SingleFlag) { \
//    (Flags) |= (SingleFlag);        \
//}
//#endif

//#ifndef ClearFlag
//#define ClearFlag(Flags,SingleFlag) { \
//    (Flags) &= ~(SingleFlag);         \
//}
//#endif

//
// Function prototypes
//

//
// Define driver entry routine.
//

NTSTATUS
EfsInitialization(
    void
    );

NTSTATUS
EFSCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    );

DWORD
GetKeyBlobLength(
    ULONG AlgID
    );

PKEY_BLOB
GetKeyBlobBuffer(
    ULONG AlgID
    );

BOOLEAN
SetKeyTable(
    PKEY_BLOB   KeyBlob,
    PEFS_KEY    EfsKey
    );

NTSTATUS
EFSFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
EFSPostCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PEFS_CONTEXT EfsContext,
    IN ULONG OpenType
    );

NTSTATUS
EFSFilePostCreate(
    IN PDEVICE_OBJECT VolDo,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN NTSTATUS Status,
    IN OUT PVOID *PCreateContext
    );

VOID
EfsGetSessionKey(
    IN PVOID StartContext
    );

BOOLEAN
EfsInitFips(
    VOID
    );


NTKERNELAPI
NTSTATUS
PsLookupProcessByProcessId(
    IN HANDLE ProcessId,
    OUT PEPROCESS *Process
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\efs\efs.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   efs.c

Abstract:

    This module contains the code that implements the EFS
    file system filter driver.

Author:

    Robert Gu (robertg) 29-Oct-1996

Environment:

    Kernel mode


Revision History:


--*/

#include "efs.h"
#include "efsrtl.h"


#define BUFFER_SIZE 1024
#define BUFFER_REG_VAL L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\NTFS\\EFS\\Parameters"
#define MAX_ALLOC_BUFFER L"MaximumBlob"
#define EFS_KERNEL_CACHE_PERIOD L"EFSKCACHEPERIOD"

//
// Global storage for this file system filter driver.
//
EFS_DATA EfsData;
WORK_QUEUE_ITEM EfsShutdownCleanupWorkItem;

//
// $EFS stream name
//
WCHAR   AttrName[5] = L"$EFS";

#if DBG

ULONG EFSDebug = 0;

#endif

ENCRYPTION_CALL_BACK EFSCallBackTable = {
    ENCRYPTION_CURRENT_INTERFACE_VERSION,
    ENCRYPTION_ALL_STREAMS,
    EfsOpenFile,
    NULL,
    EFSFilePostCreate,
    EfsFileControl,
    EfsFileControl,
    EFSFsControl,
    EfsRead,
    EfsWrite,
    EfsFreeContext
    };

VOID
EfspShutdownCleanup(
    IN PVOID Parameter
    );

//
// Assign text sections for each routine.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, EfspShutdownCleanup)
#pragma alloc_text(PAGE, EfsInitialization)
#pragma alloc_text(PAGE, EfsGetSessionKey)
#pragma alloc_text(PAGE, GetKeyBlobLength)
#pragma alloc_text(PAGE, GetKeyBlobBuffer)
#pragma alloc_text(PAGE, SetKeyTable)
#pragma alloc_text(PAGE, EfsInitFips)
#endif


VOID
EfspShutdownCleanup(
    IN PVOID Parameter
    )
{
    PEPROCESS LsaProcess;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(Parameter);
    
    if (EfsData.LsaProcess) {
        LsaProcess = EfsData.LsaProcess;
        EfsData.LsaProcess = NULL;
        ObDereferenceObject(LsaProcess);
    }
}


NTSTATUS
EfsInitialization(
    void
    )

/*++

Routine Description:

    This is the initialization routine for the general purpose file system
    filter driver.  This routine creates the device object that represents this
    driver in the system and registers it for watching all file systems that
    register or unregister themselves as active file systems.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/

{
    UNICODE_STRING nameString;
    PDEVICE_EXTENSION deviceExtension;
    PFILE_OBJECT fileObject;
    NTSTATUS status;
    HANDLE threadHdl;
    ULONG i;
    OBJECT_ATTRIBUTES objAttr;
    UNICODE_STRING efsInitEventName;
    UNICODE_STRING efsBufValue;
    ULONG  resultLength;
    PKEY_VALUE_PARTIAL_INFORMATION pPartialValue = NULL;
    HANDLE efsKey;
    EFS_INIT_DATAEXG InitDataFromSrv;

    PAGED_CODE();

    //
    // Mark our global data record
    //

    EfsData.AllocMaxBuffer = FALSE;
    EfsData.FipsFileObject = NULL;
    EfsData.FipsFunctionTable.Fips3Des = NULL;
    EfsData.FipsFunctionTable.Fips3Des3Key = NULL;
    EfsData.EfsDriverCacheLength = DefaultTimeExpirePeriod;

    RtlInitUnicodeString( &efsBufValue, BUFFER_REG_VAL );

    InitializeObjectAttributes(
        &objAttr,
        &efsBufValue,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    status = ZwOpenKey(
        &efsKey,
        KEY_READ,
        &objAttr);

    if (NT_SUCCESS(status)) {

        pPartialValue = (PKEY_VALUE_PARTIAL_INFORMATION)ExAllocatePool(NonPagedPool, BUFFER_SIZE);
        if (pPartialValue) {
            RtlInitUnicodeString(&efsBufValue, MAX_ALLOC_BUFFER);
        
            status = ZwQueryValueKey(
                        efsKey,
                        &efsBufValue,
                        KeyValuePartialInformation,
                        (PVOID)pPartialValue,
                        BUFFER_SIZE,
                        &resultLength
                        );
        
            if (NT_SUCCESS(status)) {
                ASSERT(pPartialValue->Type == REG_DWORD);
                if (*((PLONG)&(pPartialValue->Data))){
                    EfsData.AllocMaxBuffer = TRUE;
                }
            }

            RtlInitUnicodeString(&efsBufValue, EFS_KERNEL_CACHE_PERIOD);
        
            status = ZwQueryValueKey(
                        efsKey,
                        &efsBufValue,
                        KeyValuePartialInformation,
                        (PVOID)pPartialValue,
                        BUFFER_SIZE,
                        &resultLength
                        );
        
            if (NT_SUCCESS(status)) {
                ASSERT(pPartialValue->Type == REG_DWORD);
                if (((*((DWORD *)&(pPartialValue->Data))) >= MINCACHEPERIOD) && 
                    ((*((DWORD *)&(pPartialValue->Data))) <= MAXCACHEPERIOD)){
                    EfsData.EfsDriverCacheLength = *((DWORD *)&(pPartialValue->Data));
                    EfsData.EfsDriverCacheLength *= 10000000;
                }
            }
            ExFreePool(pPartialValue);
        }
        ZwClose(efsKey);
    }
    
    EfsData.NodeTypeCode = EFS_NTC_DATA_HEADER;
    EfsData.NodeByteSize = sizeof( EFS_DATA );
    EfsData.EfsInitialized = FALSE;
    EfsData.InitEventHandle = NULL;
    EfsData.LsaProcess = NULL;

    //
    // Initialize global data structures.
    //

    ExInitializeWorkItem( &EfsShutdownCleanupWorkItem,
                          &EfspShutdownCleanup,
                          NULL );
    status = PoQueueShutdownWorkItem( &EfsShutdownCleanupWorkItem );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    InitializeListHead( &(EfsData.EfsOpenCacheList) );
    InitializeListHead( &(EfsData.EfsKeyLookAsideList) );
    ExInitializeFastMutex( &(EfsData.EfsKeyBlobMemSrcMutex) );
    ExInitializeFastMutex( &(EfsData.EfsOpenCacheMutex) );

    //
    // Initialize the event lookaside list
    //

    ExInitializeNPagedLookasideList(&(EfsData.EfsEventPool),
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(KEVENT),
                                    'levE',
                                    EFS_EVENTDEPTH
                                    );

    //
    // Try to allocate at least one event in the list. This one will be used for
    // sure later.
    //

    {
        PVOID pTryEvent;

        pTryEvent = ExAllocateFromNPagedLookasideList(&(EfsData.EfsEventPool));
        if ( NULL == pTryEvent ){
            //
            // Free previously allocated memory
            //

            ExDeleteNPagedLookasideList(&(EfsData.EfsEventPool));
            return STATUS_NO_MEMORY;
        }
        ExFreeToNPagedLookasideList(&(EfsData.EfsEventPool), pTryEvent);
    }

    //
    // Initialize the context lookaside list
    //

    ExInitializeNPagedLookasideList(&(EfsData.EfsContextPool),
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(EFS_CONTEXT),
                                    'nocE',
                                    EFS_CONTEXTDEPTH
                                    );

    //
    //  Initialize the cache lookaside list
    //

    ExInitializePagedLookasideList(&(EfsData.EfsOpenCachePool),
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(OPEN_CACHE),
                                    'hcoE',
                                    EFS_CACHEDEPTH
                                    );

    ExInitializePagedLookasideList(&(EfsData.EfsMemSourceItem),
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(KEY_BLOB_RAMPOOL),
                                    'msfE',
                                    EFS_ALGDEPTH
                                    );

    ExInitializeNPagedLookasideList(&(EfsData.EfsLookAside),
                                    NULL,
                                    NULL,
                                    0,
                                    sizeof(NPAGED_LOOKASIDE_LIST),
                                    'msfE',
                                    EFS_ALGDEPTH
                                    );

    status = NtOfsRegisterCallBacks( Encryption, &EFSCallBackTable );
    if (!NT_SUCCESS(status)) {

        //
        // Register callback failed
        //

        ExDeleteNPagedLookasideList(&(EfsData.EfsEventPool));
        ExDeleteNPagedLookasideList(&(EfsData.EfsContextPool));
        ExDeletePagedLookasideList(&(EfsData.EfsOpenCachePool));
        ExDeletePagedLookasideList(&(EfsData.EfsMemSourceItem));
        ExDeleteNPagedLookasideList(&(EfsData.EfsLookAside));
        return status;
    }

    RtlInitUnicodeString(&(EfsData.EfsName), &AttrName[0]);

    //
    //  Create an event
    //

    RtlInitUnicodeString( &efsInitEventName, L"\\EFSInitEvent" );

    InitializeObjectAttributes(
        &objAttr,
        &efsInitEventName,
        0,
        NULL,
        NULL
        );

    //
    // Try to create an event. If the event was not created, the EFS
    // server is not loaded yet. We will create a thread waiting for
    // EFS server to be loaded. If the event was already created, we
    // will just go ahead and get the session key from the EFS server.
    //

    status = ZwCreateEvent(
                 &(EfsData.InitEventHandle),
                 EVENT_MODIFY_STATE,
                 &objAttr,
                 NotificationEvent,
                 FALSE
                 );

    if (!NT_SUCCESS(status)) {

        if ( STATUS_OBJECT_NAME_COLLISION == status ){

            //
            // EFS server has been loaded. This is the normal case.
            // Call server to get the session key.
            //

            status = GenerateSessionKey(
                         &InitDataFromSrv
                         );


            if (NT_SUCCESS( status )) {

                //
                //  Set session key
                //

                RtlCopyMemory( &(EfsData.SessionKey[0]), InitDataFromSrv.Key, DES_KEYSIZE );
                deskey( (DESTable*)&(EfsData.SessionDesTable[0]),
                        &(EfsData.SessionKey[0]));

                status = PsLookupProcessByProcessId(
                                    InitDataFromSrv.LsaProcessID,
                                    &(EfsData.LsaProcess)
                                    );
                RtlSecureZeroMemory(&InitDataFromSrv, sizeof(EFS_INIT_DATAEXG));

                if (NT_SUCCESS( status )) {
                    EfsData.EfsInitialized = TRUE;
                    if ( PsGetCurrentProcess() != EfsData.LsaProcess ){

                        KAPC_STATE  ApcState;

                        KeStackAttachProcess (
                            EfsData.LsaProcess,
                            &ApcState
                            );
                        InitSecurityInterface();
                        KeUnstackDetachProcess(&ApcState);
                    } else {
                        InitSecurityInterface();
                    }
                    EfsInitFips();
                } else {
#if DBG

                    if ( (EFSTRACEALL | EFSTRACELIGHT) & EFSDebug ){

                        DbgPrint("PsLookupProcessByProcessId failed, status = %x\n",status);

                    }

#endif
                    //
                    // Failed to get the process pointer
                    //

                    ExDeleteNPagedLookasideList(&(EfsData.EfsEventPool));
                    ExDeleteNPagedLookasideList(&(EfsData.EfsContextPool));
                    ExDeletePagedLookasideList(&(EfsData.EfsOpenCachePool));
                    ExDeletePagedLookasideList(&(EfsData.EfsMemSourceItem));
                    ExDeleteNPagedLookasideList(&(EfsData.EfsLookAside));

                }

            } else {

#if DBG

                if ( (EFSTRACEALL | EFSTRACELIGHT) & EFSDebug ){

                    DbgPrint("GenerateSessionKey failed, status = %x\n",status);

                }

#endif
                //
                // Failed to get the session key
                //

                ExDeleteNPagedLookasideList(&(EfsData.EfsEventPool));
                ExDeleteNPagedLookasideList(&(EfsData.EfsContextPool));
                ExDeletePagedLookasideList(&(EfsData.EfsOpenCachePool));
                ExDeletePagedLookasideList(&(EfsData.EfsMemSourceItem));
                ExDeleteNPagedLookasideList(&(EfsData.EfsLookAside));

            }


        } else {

            //
            // Unexpected error occured. EFS cannot be loaded
            //

#if DBG

            if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
                DbgPrint("EFSFILTER: Efs init event creation failed.%x\n", status);
            }

#endif
            ExDeleteNPagedLookasideList(&(EfsData.EfsEventPool));
            ExDeleteNPagedLookasideList(&(EfsData.EfsContextPool));
            ExDeletePagedLookasideList(&(EfsData.EfsOpenCachePool));
            ExDeletePagedLookasideList(&(EfsData.EfsMemSourceItem));
            ExDeleteNPagedLookasideList(&(EfsData.EfsLookAside));

        }

    } else {

        //
        // The server is not ready yet.
        // Create a thread and wait for the server in that thread
        //

        status = PsCreateSystemThread(
                                &threadHdl,
                                GENERIC_ALL,
                                NULL,
                                NULL,
                                NULL,
                                EfsGetSessionKey,
                                NULL
                                );

        if ( NT_SUCCESS( status ) ){

            ZwClose( threadHdl );

        } else {

            ExDeleteNPagedLookasideList(&(EfsData.EfsEventPool));
            ExDeleteNPagedLookasideList(&(EfsData.EfsContextPool));
            ExDeletePagedLookasideList(&(EfsData.EfsOpenCachePool));
            ExDeletePagedLookasideList(&(EfsData.EfsMemSourceItem));
            ExDeleteNPagedLookasideList(&(EfsData.EfsLookAside));

        }
    }

    return status;
}

VOID
EfsUninitialization(
    VOID
    )
{
    PLIST_ENTRY              pLink;
    PKEY_BLOB_RAMPOOL        pTmpItem;
    PNPAGED_LOOKASIDE_LIST   MemSrcList;

    while (!IsListEmpty (&EfsData.EfsKeyLookAsideList)) {
        pLink = RemoveHeadList (&EfsData.EfsKeyLookAsideList);
        pTmpItem = CONTAINING_RECORD(pLink, KEY_BLOB_RAMPOOL, MemSourceChain);
        MemSrcList = pTmpItem->MemSourceList;

        ExDeleteNPagedLookasideList(MemSrcList);
        ExFreeToNPagedLookasideList(&(EfsData.EfsLookAside), MemSrcList );
        ExFreeToPagedLookasideList(&(EfsData.EfsMemSourceItem), pTmpItem );
    }
    ExDeleteNPagedLookasideList(&(EfsData.EfsEventPool));
    ExDeleteNPagedLookasideList(&(EfsData.EfsContextPool));
    ExDeletePagedLookasideList(&(EfsData.EfsOpenCachePool));
    ExDeletePagedLookasideList(&(EfsData.EfsMemSourceItem));
    ExDeleteNPagedLookasideList(&(EfsData.EfsLookAside));
    if (EfsData.FipsFileObject) {
        ObDereferenceObject(EfsData.FipsFileObject);
        EfsData.FipsFileObject = NULL;
    }
}

VOID
EfsGetSessionKey(
    IN PVOID StartContext
    )

/*++

Routine Description:

    This routine is invoked in DriverEntry. It runs in a seperate thread.

    The purpose of this routine is to wait for the EFS server. And Get the session key.

Arguments:

    StartContext - Start context of the thread.

Return Value:

    None.

--*/

{

    SECURITY_DESCRIPTOR efsInitEventSecurityDescriptor;
    NTSTATUS status;
    EFS_INIT_DATAEXG InitDataFromSrv;

#if DBG

    if ( EFSTRACEALL & EFSDebug ){
        DbgPrint( "EFSFILTER: Thread started. %x\n", EfsData.NodeTypeCode );
    }

#endif


    status = ZwWaitForSingleObject (
                            EfsData.InitEventHandle,
                            FALSE,
                            (PLARGE_INTEGER)NULL
                            );

    ZwClose( EfsData.InitEventHandle );

    //
    //  Call server to get the session key
    //


    status = GenerateSessionKey(
                 &InitDataFromSrv
                 );


    if (!NT_SUCCESS( status )) {

#if DBG

        if ( (EFSTRACEALL | EFSTRACELIGHT) & EFSDebug ){

            DbgPrint("GenerateSessionKey failed, status = %x\n",status);

        }

#endif

         return;
    }

    //
    //  Set session key
    //

    RtlCopyMemory( &(EfsData.SessionKey[0]), InitDataFromSrv.Key, DES_KEYSIZE );
    deskey( (DESTable*)&(EfsData.SessionDesTable[0]),
            &(EfsData.SessionKey[0]));

    status = PsLookupProcessByProcessId(
                        InitDataFromSrv.LsaProcessID,
                        &(EfsData.LsaProcess)
                        );

    RtlSecureZeroMemory(&InitDataFromSrv, sizeof(EFS_INIT_DATAEXG));

    if (NT_SUCCESS( status )) {

        EfsData.EfsInitialized = TRUE;
        if ( PsGetCurrentProcess() != EfsData.LsaProcess ){
            KAPC_STATE  ApcState;

            //KeAttachProcess(EfsData.LsaProcess);
            KeStackAttachProcess (
                EfsData.LsaProcess,
                &ApcState
                );
            InitSecurityInterface();
            //KeDetachProcess();
            KeUnstackDetachProcess(&ApcState);
        } else {
            InitSecurityInterface();
        }

        EfsInitFips();

    } else {

#if DBG

        if ( (EFSTRACEALL | EFSTRACELIGHT) & EFSDebug ){

            DbgPrint("PsLookupProcessByProcessId failed, status = %x\n",status);

        }

#endif

    }

    return;
}

ULONG GetKeyBlobLength(
    ULONG AlgID
    )
{
    if (EfsData.AllocMaxBuffer) {
        return AES_KEY_BLOB_LENGTH_256;
    }
    switch (AlgID){
        case CALG_DESX:
            return DESX_KEY_BLOB_LENGTH;
        case CALG_3DES:
            return DES3_KEY_BLOB_LENGTH;
        case CALG_AES_256:
            return AES_KEY_BLOB_LENGTH_256;
        case CALG_DES:
        default:
            return DES_KEY_BLOB_LENGTH;
    }
    return 0;
}

PKEY_BLOB
GetKeyBlobBuffer(
    ULONG AlgID
    )
{

    PNPAGED_LOOKASIDE_LIST   MemSrcList = NULL;
    PKEY_BLOB_RAMPOOL   KeyBlobPoolListItem = NULL;
    PKEY_BLOB_RAMPOOL   pTmpItem = NULL;
    ULONG KeyBlobLength;
    PLIST_ENTRY pLink = NULL;
    PKEY_BLOB NewKeyBlob;

    KeyBlobLength = GetKeyBlobLength(AlgID);

    if (!KeyBlobLength){
        ASSERT(KeyBlobLength);
        return NULL;
    }

    ExAcquireFastMutex( &(EfsData.EfsKeyBlobMemSrcMutex));
    for (pLink = EfsData.EfsKeyLookAsideList.Flink; pLink != &(EfsData.EfsKeyLookAsideList); pLink = pLink->Flink) {
        pTmpItem = CONTAINING_RECORD(pLink, KEY_BLOB_RAMPOOL, MemSourceChain);
        if (pTmpItem->AlgorithmID == AlgID) {

            //
            // The lookaside list already exists
            //

            MemSrcList = pTmpItem->MemSourceList;
            break;
        }
    }
    ExReleaseFastMutex(  &(EfsData.EfsKeyBlobMemSrcMutex) );

    if ( MemSrcList == NULL ) {

        //
        // No lookaside for this type of key. Go and create one item.
        //

        MemSrcList = (PNPAGED_LOOKASIDE_LIST)ExAllocateFromNPagedLookasideList(&(EfsData.EfsLookAside));
        KeyBlobPoolListItem = (PKEY_BLOB_RAMPOOL) ExAllocateFromPagedLookasideList(&(EfsData.EfsMemSourceItem));
        if ( (NULL == MemSrcList) || (NULL == KeyBlobPoolListItem) ){
            if (MemSrcList) {
                ExFreeToNPagedLookasideList(&(EfsData.EfsLookAside), MemSrcList );
            }
            if (KeyBlobPoolListItem){
                ExFreeToPagedLookasideList(&(EfsData.EfsMemSourceItem), KeyBlobPoolListItem );
            }
            return NULL;
        }

        RtlZeroMemory( KeyBlobPoolListItem, sizeof( KEY_BLOB_RAMPOOL ) );
        KeyBlobPoolListItem->MemSourceList = MemSrcList;
        KeyBlobPoolListItem->AlgorithmID = AlgID;

        ExInitializeNPagedLookasideList(
                MemSrcList,
                NULL,
                NULL,
                0,
                KeyBlobLength,
                'msfE',
                EFS_KEYDEPTH
                );

        ExAcquireFastMutex( &(EfsData.EfsKeyBlobMemSrcMutex));
        InsertHeadList( &(EfsData.EfsKeyLookAsideList), &(KeyBlobPoolListItem->MemSourceChain));
        ExReleaseFastMutex(  &(EfsData.EfsKeyBlobMemSrcMutex) );
    }

    //
    // Allocate the Key Blob
    //

    NewKeyBlob = (PKEY_BLOB)ExAllocateFromNPagedLookasideList(MemSrcList);

    if (NewKeyBlob){
        NewKeyBlob->AlgorithmID = AlgID;
        NewKeyBlob->KeyLength = KeyBlobLength;
        NewKeyBlob->MemSource = MemSrcList;
    }
    return NewKeyBlob;

}

BOOLEAN
SetKeyTable(
    PKEY_BLOB   KeyBlob,
    PEFS_KEY    EfsKey
    )
{

    char DesXTmpKey[DESX_KEYSIZE];

    switch ( EfsKey->Algorithm ){
        case CALG_3DES:
            if (EfsData.AllocMaxBuffer) {
                RtlZeroMemory( &(KeyBlob->Key[0]) + DES3_TABLESIZE, KeyBlob->KeyLength - DES3_KEY_BLOB_LENGTH);
            }
            if (EfsData.FipsFunctionTable.Fips3Des3Key) {
                EfsData.FipsFunctionTable.Fips3Des3Key(
                    (DES3TABLE*) &(KeyBlob->Key[0]), 
                    ((char *)EfsKey) + sizeof ( EFS_KEY )
                    );
            } else {
                return FALSE;
            }
            //tripledes3key(
            //    (DES3TABLE*) &(KeyBlob->Key[0]), 
            //    ((char *)EfsKey) + sizeof ( EFS_KEY )
            //    );
            break;
        case CALG_DESX:
            //
            // Flush the non used area.
            //

            if (EfsData.AllocMaxBuffer) {
                RtlZeroMemory( &(KeyBlob->Key[0]) + DESX_TABLESIZE, KeyBlob->KeyLength - DESX_KEY_BLOB_LENGTH);
            }
            desexpand128to192(
                ((char *)EfsKey) + sizeof ( EFS_KEY ),
                DesXTmpKey
                );

            desxkey(
                (DESXTable*) &(KeyBlob->Key[0]),
                DesXTmpKey
                );
            break;

        case CALG_AES_256:
            aeskey(
                (AESTable*) &(KeyBlob->Key[0]),
                ((char *)EfsKey) + sizeof ( EFS_KEY ),
                AES_ROUNDS_256
                );
            break;

        case CALG_DES:
        default:
            if (EfsData.AllocMaxBuffer) {
                RtlZeroMemory( &(KeyBlob->Key[0]) + DES_TABLESIZE, KeyBlob->KeyLength - DES_KEY_BLOB_LENGTH);
            }
            deskey(
                (DESTable*) &(KeyBlob->Key[0]),
                ((char *)EfsKey) + sizeof ( EFS_KEY )
                );
            break;
    }
    return TRUE;
}


BOOLEAN
EfsInitFips(VOID)
/*++

Routine Description:

	Initialize the FIPS library table.

Arguments:

Return Value:

    TRUE/FALSE.

--*/
{
    UNICODE_STRING  deviceName;
    NTSTATUS        status;
    PDEVICE_OBJECT  pDeviceObject;
    // PFILE_OBJECT    pFileObject = NULL;
    PIRP            pIrp;
    IO_STATUS_BLOCK IoStatusBlock;

    PAGED_CODE();

    RtlInitUnicodeString(&deviceName, FIPS_DEVICE_NAME);

    //
    // Get the file and device objects for FIPS.
    //

    status = IoGetDeviceObjectPointer(  &deviceName,
                                        FILE_ALL_ACCESS,
                                        &EfsData.FipsFileObject,
                                        &pDeviceObject);

    if (status != STATUS_SUCCESS) {
        return  FALSE;
    }
    
    //
    // Build the request to send to FIPS to get library table.
    //
    pIrp = IoBuildDeviceIoControlRequest(   IOCTL_FIPS_GET_FUNCTION_TABLE,
                                            pDeviceObject,
                                            NULL,
                                            0,
                                            &EfsData.FipsFunctionTable,
                                            sizeof(FIPS_FUNCTION_TABLE),
                                            FALSE,
                                            NULL,
                                            &IoStatusBlock
                                            );
    
    if (pIrp == NULL) {
#if DBG
        DbgPrint("EfsInitFips: IoBuildDeviceIoControlRequest IOCTL_FIPS_GET_FUNCTION_TABLE failed.\n");
#endif
        ObDereferenceObject(EfsData.FipsFileObject);
        EfsData.FipsFileObject = NULL;
        return  FALSE;
    }
    
    status = IoCallDriver(pDeviceObject, pIrp);
    
    if (status != STATUS_SUCCESS) {
        ObDereferenceObject(EfsData.FipsFileObject);
        EfsData.FipsFileObject = NULL;
#if DBG
        DbgPrint("EfsInitFips: IoCallDriver failed, status = %x\n",status);
#endif
        return  FALSE;
    }
    
    return  TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\efs\create.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   create.c

Abstract:

   This module will handle the IRP_MJ_CREATE (and all associated support
   routines) requests.

Author:

    Robert Gu (robertg) 29-Oct-1996
Environment:

   Kernel Mode Only

Revision History:

--*/

#include "efs.h"
#include "efsrtl.h"
#include "efsext.h"


#ifdef ALLOC_PRAGMA
//
// cannot make this code paged because of calls to
// virtual memory functions.
//
//#pragma alloc_text(PAGE, EFSFilePostCreate)
//#pragma alloc_text(PAGE, EFSPostCreate)
//
#endif


NTSTATUS
EFSFilePostCreate(
    IN PDEVICE_OBJECT VolDo,
    IN PIRP Irp,
    IN PFILE_OBJECT FileObject,
    IN NTSTATUS Status,
    IN OUT PVOID *PCreateContext
    )
{
    PEFS_CONTEXT    pEfsContext;
    KIRQL savedIrql;
    NTSTATUS EfsStatus = STATUS_SUCCESS;


    PAGED_CODE();

    if (!PCreateContext) {
        return Status;
    }

    pEfsContext = *PCreateContext;

    if (( NT_SUCCESS( Status ) && (Status != STATUS_PENDING) && (Status != STATUS_REPARSE))
        && pEfsContext){

        if ( NO_FURTHER_PROCESSING != pEfsContext->Status ){

            PIO_STACK_LOCATION irpSp;

            irpSp = IoGetCurrentIrpStackLocation( Irp );


#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){

        DbgPrint( " EFSFILTER: Begin post create. \n" );

    }
#endif

            if ((pEfsContext->EfsStreamData) &&
                   (EFS_STREAM_TRANSITION == ((PEFS_STREAM)(pEfsContext->EfsStreamData))->Status)) {

                PSID    SystemSid;
                SID_IDENTIFIER_AUTHORITY    IdentifierAuthority = SECURITY_NT_AUTHORITY;

                //
                // $EFS indicates transition state.
                // Only the system can open it
                //

                SystemSid = ExAllocatePoolWithTag(
                                        PagedPool,
                                        RtlLengthRequiredSid(1),
                                        'msfE'
                                        );

                if ( SystemSid ){

                    EfsStatus = RtlInitializeSid( SystemSid, &IdentifierAuthority, (UCHAR) 1 );

                    if ( NT_SUCCESS(EfsStatus) ){

                        PACCESS_TOKEN accessToken = NULL;
                        PTOKEN_USER UserId = NULL;

                        *(RtlSubAuthoritySid(SystemSid, 0 )) = SECURITY_LOCAL_SYSTEM_RID;

                        //
                        // We got the system SID. Now try to get the caller's SID.
                        //

                        accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken;
                        if(!accessToken) {
                            accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.PrimaryToken;
                        }
                        if ( accessToken ){

                            //
                            // Get User ID
                            //

                            EfsStatus = SeQueryInformationToken(
                                accessToken,
                                TokenUser,
                                &UserId
                            );

                            if ( NT_SUCCESS(EfsStatus) ){

                                //
                                // Got the user SID
                                //

                                if ( !RtlEqualSid ( SystemSid, UserId->User.Sid) ) {

                                    EfsStatus = STATUS_ACCESS_DENIED;

                                }
                            }

                            ExFreePool( UserId );

                        } else {
                            //
                            // Cannot get the user token
                            //

                            EfsStatus = STATUS_ACCESS_DENIED;

                        }

                    }

                    ExFreePool( SystemSid );

                } else {

                    EfsStatus = STATUS_INSUFFICIENT_RESOURCES;

                }

            } else {
                //
                // $EFS in normal status
                // Set Key Blob and/or write $EFS
                //
                // Legacy problem, The fourth parameter of EfsPostCreate (OpenType)
                // was used to indicate a recovery open. The design was changed. Now
                // this parameter is not used. It is not worth to take out the parameter
                // now. This will need to change several modules, EFS.SYS, KSECDD.SYS
                // SEcur32.lib and LSASRV.DLL. We might just leave it as reserved for future use.
                // To speed up a little bit, pass in 0.
                //

                EfsStatus = EFSPostCreate(
                                VolDo,
                                Irp,
                                pEfsContext,
                                0
                                );

            }
        }

    }

    if (pEfsContext){

        //
        // Release memory if necessary
        //

        *PCreateContext = NULL;
        if ( pEfsContext->EfsStreamData ) {

            ExFreePool(pEfsContext->EfsStreamData);
            pEfsContext->EfsStreamData = NULL;

        }

        ExFreeToNPagedLookasideList(&(EfsData.EfsContextPool), pEfsContext );
    }

    if (!NT_SUCCESS(EfsStatus)) {
        return EfsStatus;
    }

    return Status; // If EFS operation succeeded, just return the original status code.

}



NTSTATUS
EFSPostCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PEFS_CONTEXT EfsContext,
    IN ULONG OpenType
    )

/*++

Routine Description:

    This function calls the EFS server to get FEK, $EFS, set Key Blob and or write $EFS.

    We could not use user's space to talk to LSA so we need to attach to LSA to allocate

    memory in LSA space. We could cause APC dead lock if we call LSA while attached to LSA.

    We need to detach before calling LSA and reattach to get data back from LSA.

Arguments:

    DeviceObject - Pointer to the target device object.

    Irp - Pointer to the I/O Request Packet that represents the operation.

    EfsContext - A context block associated with the file object.

    OpenType - File create(open) option

    IrpContext - NTFS internal data

    FileHdl - NTFS internal data

    AttributeHandle - NTFS internal data


--*/
{
    PEFS_KEY fek = NULL;
    PEFS_DATA_STREAM_HEADER efsStream = NULL;
    PVOID currentEfsStream = NULL;
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    PVOID bufferBase = NULL;
    ULONG currentEfsStreamLength = 0;
    ULONG bufferLength;
    SIZE_T regionSize = 0;
    PACCESS_TOKEN accessToken = NULL;
    PTOKEN_USER UserId = NULL;
    GUID *EfsId = NULL;
    HANDLE  CrntProcess = NULL;
    BOOLEAN ProcessAttached = FALSE;
    BOOLEAN ProcessNeedAttach = FALSE;
    SECURITY_IMPERSONATION_LEVEL  ImpersonationLevel = SecurityImpersonation;
    KAPC_STATE  ApcState;
/*
    PIO_SECURITY_CONTEXT sContext;
    sContext = irpSp->Parameters.Create.SecurityContext;
    DbgPrint( "\n PostCreate: Desired Access %x\n", sContext->DesiredAccess );
    DbgPrint( "\n PostCreate: Orginal Desired Access %x\n", sContext->AccessState->OriginalDesiredAccess );
    DbgPrint( "\n PostCreate: PrevGrant Access %x\n", sContext->AccessState->PreviouslyGrantedAccess );
    DbgPrint( "\n PostCreate: Remaining Desired Access %x\n", sContext->AccessState->RemainingDesiredAccess );
*/
    //
    //  Check if we can use the cache to verify the open
    //

    if ( !(EfsContext->Status & NO_OPEN_CACHE_CHECK) ){

        if ( irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken ){
            accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken;
            ImpersonationLevel = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ImpersonationLevel;
        } else {
            accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.PrimaryToken;
        }

        if ( accessToken ){

            //
            // Get User ID
            //

            status = SeQueryInformationToken(
                accessToken,
                TokenUser,
                &UserId
            );

            if ( NT_SUCCESS(status) ){

                if ( EfsFindInCache(
                        &((( PEFS_DATA_STREAM_HEADER ) EfsContext->EfsStreamData)->EfsId),
                        UserId
                        )) {

                    ExFreePool( UserId );
#if DBG
    if ( (EFSTRACEALL ) & EFSDebug ){
        DbgPrint( " EFS:Open with cache. \n" );
    }
#endif
                    return ( STATUS_SUCCESS );
                }
            }

            //
            //  UserId will be freed later
            //

        }

        //
        //  Check cache failure should not block the normal operations
        //

        status = STATUS_SUCCESS;
    }

    //
    // Clear the cache bit
    //

    EfsContext->Status &= ~NO_OPEN_CACHE_CHECK;

    //
    // Check if it is ACCESS_ATTRIBUTE ONLY
    //

    if ( !( irpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess &
            ( FILE_APPEND_DATA | FILE_READ_DATA | FILE_WRITE_DATA | FILE_EXECUTE )) &&
          ( EfsContext->Status & TURN_ON_ENCRYPTION_BIT ) &&
          ( !(EfsContext->Status & (NEW_FILE_EFS_REQUIRED | NEW_DIR_EFS_REQUIRED)))){

        //
        //  A new stream is to be created without data access required. We might not
        //  have the keys to decrypt the $EFS. We just need to turn on the bit here.
        //  Changed the real action required.
        //  Free the memory not required by this action.
        //
#if DBG
    if ( (EFSTRACEALL ) & EFSDebug ){
        DbgPrint( " EFS:Open accessing attr only. \n" );
    }
#endif

        if (EfsContext->EfsStreamData){
            ExFreePool(EfsContext->EfsStreamData);
            EfsContext->EfsStreamData = NULL;
        }
        EfsContext->Status = TURN_ON_ENCRYPTION_BIT | TURN_ON_BIT_ONLY ;

    } else if ( !(EfsContext->Status & TURN_ON_BIT_ONLY) ) {

        if (accessToken == NULL){
            if ( irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken ){
                accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken;
                ImpersonationLevel = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ImpersonationLevel;
            } else {
                accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.PrimaryToken;
            }

            //
            // Get User ID
            //

            status = SeQueryInformationToken(
                accessToken,
                TokenUser,
                &UserId
                );

            if (!NT_SUCCESS(status)) {

               //
               // Do not refresh the cache
               //

               UserId = NULL;
               status = STATUS_SUCCESS;
            }

        }

        //
        // Allocate virtual memory.
        // Move the $EFS to virtual memory, LPC requires this.
        //

        if ( PsGetCurrentProcess() != EfsData.LsaProcess ){

            ProcessNeedAttach = TRUE;

            status = ObReferenceObjectByPointer(
                        EfsData.LsaProcess,
                        0,
                        NULL,
                        KernelMode);

            if ( NT_SUCCESS(status) ) {
                KeStackAttachProcess (
                    EfsData.LsaProcess,
                    &ApcState
                    );
                ProcessAttached = TRUE;
            }

        }

        CrntProcess = NtCurrentProcess();

        if ( NT_SUCCESS(status) ) {
            if (EfsContext->EfsStreamData){
                regionSize = currentEfsStreamLength = * (ULONG*)(EfsContext->EfsStreamData);

                status = ZwAllocateVirtualMemory(
                            CrntProcess,
                            (PVOID *) &currentEfsStream,
                            0,
                            &regionSize,
                            MEM_COMMIT,
                            PAGE_READWRITE
                            );
            }
        }
    }

    if ( NT_SUCCESS(status) ){

        BOOLEAN OldCopyOnOpen;
        BOOLEAN OldEffectiveOnly;
        SECURITY_IMPERSONATION_LEVEL OldImpersonationLevel;
        PACCESS_TOKEN OldClientToken;


        OldClientToken = PsReferenceImpersonationToken(
                            PsGetCurrentThread(),
                            &OldCopyOnOpen,
                            &OldEffectiveOnly,
                            &OldImpersonationLevel
                            );

        if ( EfsContext->Status  != (TURN_ON_ENCRYPTION_BIT | TURN_ON_BIT_ONLY)  &&
                ( NULL != currentEfsStream) ){

            RtlCopyMemory(
                    currentEfsStream,
                    EfsContext->EfsStreamData,
                    currentEfsStreamLength
                    );

            //
            // Free the memory first to increase chance of getting new memory
            //

            ExFreePool(EfsContext->EfsStreamData);
            EfsContext->EfsStreamData = NULL;
        }

        //
        // Detach process before calling user mode
        //

        if (ProcessAttached){
            KeUnstackDetachProcess(&ApcState);
            ProcessAttached = FALSE;
        }

        switch ( EfsContext->Status & ACTION_REQUIRED){
            case VERIFY_USER_REQUIRED:

                status = PsImpersonateClient(
                            PsGetCurrentThread(),
                            accessToken,
                            TRUE,
                            TRUE,
                            ImpersonationLevel
                            );

                //
                // Call service to verify the user
                //

                if (NT_SUCCESS(status)) {
                    status = EfsDecryptFek(
                        &fek,
                        (PEFS_DATA_STREAM_HEADER) currentEfsStream,
                        currentEfsStreamLength,
                        OpenType,
                        &efsStream,
                        &bufferBase,
                        &bufferLength
                        );
    
                    if ( OldClientToken ) {
                        PsImpersonateClient(
                            PsGetCurrentThread(),
                            OldClientToken,
                            OldCopyOnOpen,
                            OldEffectiveOnly,
                            OldImpersonationLevel
                            );
                        PsDereferenceImpersonationToken(OldClientToken);
                    } else {
                        PsRevertToSelf( );
                    }
                } else {

                    //
                    // Impersonation failed
                    //

                    if ( OldClientToken ) {
                        PsDereferenceImpersonationToken(OldClientToken);
                    }


                }

                break;

            case NEW_FILE_EFS_REQUIRED:
                //
                // Call service to get new FEK, $EFS
                //

                if (EfsContext->Flags & SYSTEM_IS_READONLY) {
                    ASSERT(FALSE);
                    status = STATUS_MEDIA_WRITE_PROTECTED;
                    if ( OldClientToken ) {
                        PsDereferenceImpersonationToken(OldClientToken);
                    }
                    break;
                }

                status = PsImpersonateClient(
                            PsGetCurrentThread(),
                            accessToken,
                            TRUE,
                            TRUE,
                            ImpersonationLevel
                            );


                if (NT_SUCCESS(status)) {

                    status = EfsGenerateKey(
                                  &fek,
                                  &efsStream,
                                  (PEFS_DATA_STREAM_HEADER) currentEfsStream,
                                  currentEfsStreamLength,
                                  &bufferBase,
                                  &bufferLength
                                  );
                    
                    if ( OldClientToken ) {
                       PsImpersonateClient(
                           PsGetCurrentThread(),
                           OldClientToken,
                           OldCopyOnOpen,
                           OldEffectiveOnly,
                           OldImpersonationLevel
                           );
                       PsDereferenceImpersonationToken(OldClientToken);
                    } else {
                        PsRevertToSelf( );
                    }

                } else {

                    //
                    // Impersonation failed
                    //

                    if ( OldClientToken ) {
                        PsDereferenceImpersonationToken(OldClientToken);
                    }

                }
                break;

            case NEW_DIR_EFS_REQUIRED:
                //
                // Call service to get new $EFS
                //

                if (EfsContext->Flags & SYSTEM_IS_READONLY) {
                    ASSERT(FALSE);
                    status = STATUS_MEDIA_WRITE_PROTECTED;
                    if ( OldClientToken ) {
                        PsDereferenceImpersonationToken(OldClientToken);
                    }
                    break;
                }

                status = PsImpersonateClient(
                            PsGetCurrentThread(),
                            accessToken,
                            TRUE,
                            TRUE,
                            ImpersonationLevel
                            );

                if (NT_SUCCESS(status)) {
                    status = GenerateDirEfs(
                                  (PEFS_DATA_STREAM_HEADER) currentEfsStream,
                                  currentEfsStreamLength,
                                  &efsStream,
                                  &bufferBase,
                                  &bufferLength
                                  );
    
                    if ( OldClientToken ) {
                        PsImpersonateClient(
                            PsGetCurrentThread(),
                            OldClientToken,
                            OldCopyOnOpen,
                            OldEffectiveOnly,
                            OldImpersonationLevel
                            );
                        PsDereferenceImpersonationToken(OldClientToken);
                    } else {
                        PsRevertToSelf( );
                    }
                } else {

                    //
                    // Impersonation failed
                    //

                    if ( OldClientToken ) {
                        PsDereferenceImpersonationToken(OldClientToken);
                    }

                }
                break;

            case TURN_ON_BIT_ONLY:
                //
                // Fall through intended
                //

            default:

                if ( OldClientToken ) {
                    PsDereferenceImpersonationToken(OldClientToken);
                }

                break;
        }


        if ( ProcessNeedAttach ){

            KeStackAttachProcess (
                EfsData.LsaProcess,
                &ApcState
                );
            ProcessAttached = TRUE;

        }

        if (fek && (fek->Algorithm == CALG_3DES) && !EfsData.FipsFunctionTable.Fips3Des3Key ) {

            //
            // User requested 3des but fips is not available, quit.
            //


            if (bufferBase){
    
                SIZE_T bufferSize;
    
                bufferSize = bufferLength;
                ZwFreeVirtualMemory(
                    CrntProcess,
                    &bufferBase,
                    &bufferSize,
                    MEM_RELEASE
                    );
    
            }
            status = STATUS_ACCESS_DENIED;
        }

        if ( NT_SUCCESS(status) ){

            KEVENT event;
            IO_STATUS_BLOCK ioStatus;
            PIRP fsCtlIrp;
            PIO_STACK_LOCATION fsCtlIrpSp;
            ULONG inputDataLength;
            ULONG actionType;
            ULONG usingCurrentEfs;
            ULONG FsCode;
            PULONG pUlong;

            //
            // We got our FEK, $EFS. Set it with a FSCTL
            // Prepare the input data buffer first
            //

            switch ( EfsContext->Status & ACTION_REQUIRED ){
                case VERIFY_USER_REQUIRED:

                    EfsId =  ExAllocatePoolWithTag(
                                PagedPool,
                                sizeof (GUID),
                                'msfE'
                                );

                    if ( EfsId ){
                        RtlCopyMemory(
                            EfsId,
                            &(((PEFS_DATA_STREAM_HEADER) currentEfsStream)->EfsId),
                            sizeof( GUID ) );
                    }

                    //
                    // Free memory first
                    //
                    ZwFreeVirtualMemory(
                        CrntProcess,
                        &currentEfsStream,
                        &regionSize,
                        MEM_RELEASE
                        );

                    //
                    // Prepare input data buffer
                    //

                    inputDataLength = EFS_FSCTL_HEADER_LENGTH + 2 * EFS_KEY_SIZE( fek );

                    actionType = SET_EFS_KEYBLOB;

                    if ( efsStream && !(EfsContext->Flags & SYSTEM_IS_READONLY)){
                        //
                        // $EFS updated
                        //

                        inputDataLength += *(ULONG *)efsStream;
                        actionType |= WRITE_EFS_ATTRIBUTE;
                    }

                    currentEfsStream = ExAllocatePoolWithTag(
                                PagedPool,
                                inputDataLength,
                                'msfE'
                                );

                    //
                    // Deal with out of memory here
                    //
                    if ( NULL == currentEfsStream ){

                        //
                        // Out of memory
                        //

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;

                    }

                    pUlong = (ULONG *) currentEfsStream;
                    *pUlong = ((PFSCTL_INPUT)currentEfsStream)->CipherSubCode
                                = actionType;

                    ((PFSCTL_INPUT)currentEfsStream)->EfsFsCode = EFS_SET_ATTRIBUTE;

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH,
                        fek,
                        EFS_KEY_SIZE( fek )
                        );

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH
                            + EFS_KEY_SIZE( fek ),
                        fek,
                        EFS_KEY_SIZE( fek )
                        );

                    if ( efsStream && !(EfsContext->Flags & SYSTEM_IS_READONLY)){

                        RtlCopyMemory(
                            ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH
                                + 2 * EFS_KEY_SIZE( fek ),
                            efsStream,
                            *(ULONG *)efsStream
                            );

                    }

                    //
                    // Encrypt our Input data
                    //
                    EfsEncryptKeyFsData(
                        currentEfsStream,
                        inputDataLength,
                        sizeof(ULONG),
                        EFS_FSCTL_HEADER_LENGTH + EFS_KEY_SIZE( fek ),
                        EFS_KEY_SIZE( fek )
                        );

                    //
                    // Let's clear the plain FEK
                    //

                    RtlSecureZeroMemory(EFS_KEY_DATA(fek), fek->KeyLength);

                    break;

                case NEW_FILE_EFS_REQUIRED:

                    EfsId =  ExAllocatePoolWithTag(
                                PagedPool,
                                sizeof (GUID),
                                'msfE'
                                );

                    if ( EfsId ){
                        RtlCopyMemory(
                            EfsId,
                            &(efsStream->EfsId),
                            sizeof( GUID ) );
                    }

                    //
                    // Free memory first
                    //

                    if ( currentEfsStream ){
                        ZwFreeVirtualMemory(
                            CrntProcess,
                            &currentEfsStream,
                            &regionSize,
                            MEM_RELEASE
                            );
                    }

                    //
                    // Prepare input data buffer
                    //

                    inputDataLength = EFS_FSCTL_HEADER_LENGTH
                                      + 2 * EFS_KEY_SIZE( fek )
                                      + *(ULONG *)efsStream;

                    currentEfsStream = ExAllocatePoolWithTag(
                                PagedPool,
                                inputDataLength,
                                'msfE'
                                );

                    //
                    // Deal with out of memory here
                    //
                    if ( NULL == currentEfsStream ){

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;

                    }

                    pUlong = (ULONG *) currentEfsStream;
                    *pUlong = ((PFSCTL_INPUT)currentEfsStream)->CipherSubCode
                                            = WRITE_EFS_ATTRIBUTE | SET_EFS_KEYBLOB;

                    ((PFSCTL_INPUT)currentEfsStream)->EfsFsCode = EFS_SET_ATTRIBUTE;

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH,
                        fek,
                        EFS_KEY_SIZE( fek )
                        );

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH
                            + EFS_KEY_SIZE( fek ),
                        fek,
                        EFS_KEY_SIZE( fek )
                        );

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH
                            + 2 *  EFS_KEY_SIZE( fek ) ,
                        efsStream,
                        *(ULONG *)efsStream
                        );

                    //
                    // Encrypt our Input data
                    //
                    EfsEncryptKeyFsData(
                        currentEfsStream,
                        inputDataLength,
                        sizeof(ULONG),
                        EFS_FSCTL_HEADER_LENGTH + EFS_KEY_SIZE( fek ),
                        EFS_KEY_SIZE( fek )
                        );

                    //
                    // Let's clear the plain FEK
                    //

                    RtlSecureZeroMemory(EFS_KEY_DATA(fek), fek->KeyLength);

                    break;

                case NEW_DIR_EFS_REQUIRED:
                    //
                    // Prepare input data buffer
                    //

                    inputDataLength = EFS_FSCTL_HEADER_LENGTH
                                      + 2 * ( sizeof( EFS_KEY ) + DES_KEYSIZE );

                    if ( NULL == efsStream ){

                        //
                        // New directory will inherit the parent $EFS
                        //

                        usingCurrentEfs = TRUE;
                        inputDataLength += currentEfsStreamLength;
                        efsStream = currentEfsStream;

                    } else {

                        //
                        // New $EFS generated. Not in ver 1.0
                        //

                        usingCurrentEfs = FALSE;
                        inputDataLength += *(ULONG *)efsStream;

                        //
                        // Free memory first
                        //

                        if (currentEfsStream){
                            ZwFreeVirtualMemory(
                                CrntProcess,
                                &currentEfsStream,
                                &regionSize,
                                MEM_RELEASE
                                );
                        }

                    }

                    currentEfsStream = ExAllocatePoolWithTag(
                                PagedPool,
                                inputDataLength,
                                'msfE'
                                );

                    //
                    // Deal with out of memory here
                    //
                    if ( NULL == currentEfsStream ){

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;

                    }

                    pUlong = (ULONG *) currentEfsStream;
                    *pUlong = ((PFSCTL_INPUT)currentEfsStream)->CipherSubCode
                                = WRITE_EFS_ATTRIBUTE;

                    ((PFSCTL_INPUT)currentEfsStream)->EfsFsCode = EFS_SET_ATTRIBUTE;

                    //
                    // Make up an false FEK with session key
                    //

                    ((PEFS_KEY)&(((PFSCTL_INPUT)currentEfsStream)->EfsFsData[0]))->KeyLength
                            = DES_KEYSIZE;

                    ((PEFS_KEY)&(((PFSCTL_INPUT)currentEfsStream)->EfsFsData[0]))->Algorithm
                            = CALG_DES;

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH + sizeof ( EFS_KEY ),
                        &(EfsData.SessionKey),
                        DES_KEYSIZE
                        );

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH
                            + DES_KEYSIZE + sizeof ( EFS_KEY ) ,
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH,
                        DES_KEYSIZE + sizeof ( EFS_KEY )
                        );

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH
                            + 2 * ( sizeof ( EFS_KEY ) + DES_KEYSIZE) ,
                        efsStream,
                        *(ULONG *)efsStream
                        );

                    if ( usingCurrentEfs && efsStream ) {

                        //
                        // Free memory
                        //

                        ZwFreeVirtualMemory(
                            CrntProcess,
                            &efsStream,
                            &regionSize,
                            MEM_RELEASE
                            );

                    }

                    //
                    // Encrypt our Input data
                    //
                    EfsEncryptKeyFsData(
                        currentEfsStream,
                        inputDataLength,
                        sizeof(ULONG),
                        EFS_FSCTL_HEADER_LENGTH + DES_KEYSIZE + sizeof ( EFS_KEY ),
                        DES_KEYSIZE + sizeof ( EFS_KEY )
                        );

                    break;

                case TURN_ON_BIT_ONLY:

                    //
                    // Prepare input data buffer
                    //

                    inputDataLength = EFS_FSCTL_HEADER_LENGTH
                                      + 2 * ( sizeof( EFS_KEY ) + DES_KEYSIZE );

                    currentEfsStream = ExAllocatePoolWithTag(
                                PagedPool,
                                inputDataLength,
                                'msfE'
                                );

                    //
                    // Deal with out of memory here
                    //
                    if ( NULL == currentEfsStream ){

                        status = STATUS_INSUFFICIENT_RESOURCES;
                        break;

                    }

                    ((PFSCTL_INPUT)currentEfsStream)->CipherSubCode = 0;
                    ((PFSCTL_INPUT)currentEfsStream)->EfsFsCode = EFS_SET_ATTRIBUTE;

                    //
                    // Make up an false FEK with session key
                    //

                    ((PEFS_KEY)&(((PFSCTL_INPUT)currentEfsStream)->EfsFsData[0]))->KeyLength
                            = DES_KEYSIZE;

                    ((PEFS_KEY)&(((PFSCTL_INPUT)currentEfsStream)->EfsFsData[0]))->Algorithm
                            = CALG_DES;

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH + sizeof ( EFS_KEY ),
                        &(EfsData.SessionKey),
                        DES_KEYSIZE
                        );

                    RtlCopyMemory(
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH
                            + DES_KEYSIZE + sizeof ( EFS_KEY ) ,
                        ((PUCHAR) currentEfsStream) + EFS_FSCTL_HEADER_LENGTH,
                        DES_KEYSIZE + sizeof ( EFS_KEY )
                        );

                    //
                    // Encrypt our Input data
                    //
                    EfsEncryptKeyFsData(
                        currentEfsStream,
                        inputDataLength,
                        sizeof(ULONG),
                        EFS_FSCTL_HEADER_LENGTH + DES_KEYSIZE + sizeof ( EFS_KEY ),
                        DES_KEYSIZE + sizeof ( EFS_KEY )
                        );

                default:
                    break;
            }

            //
            // Free the memory from the EFS server
            //

            if (bufferBase){

                SIZE_T bufferSize;

                bufferSize = bufferLength;
                ZwFreeVirtualMemory(
                    CrntProcess,
                    &bufferBase,
                    &bufferSize,
                    MEM_RELEASE
                    );

            }

            if (ProcessAttached){
                KeUnstackDetachProcess(&ApcState);
                ObDereferenceObject(EfsData.LsaProcess);
                ProcessAttached = FALSE;
            }

            if ( NT_SUCCESS(status) ){


                //
                // Prepare a FSCTL IRP
                //
                KeInitializeEvent( &event, SynchronizationEvent, FALSE);

                if ( EfsContext->Status & TURN_ON_ENCRYPTION_BIT ) {
                    FsCode = FSCTL_SET_ENCRYPTION;
                    *(ULONG *) currentEfsStream = EFS_ENCRYPT_STREAM;
                } else {
                    FsCode = FSCTL_ENCRYPTION_FSCTL_IO;
                }

                fsCtlIrp = IoBuildDeviceIoControlRequest( FsCode,
                                                     DeviceObject,
                                                     currentEfsStream,
                                                     inputDataLength,
                                                     NULL,
                                                     0,
                                                     FALSE,
                                                     &event,
                                                     &ioStatus
                                                     );
                if ( fsCtlIrp ) {

                    fsCtlIrpSp = IoGetNextIrpStackLocation( fsCtlIrp );
                    fsCtlIrpSp->MajorFunction = IRP_MJ_FILE_SYSTEM_CONTROL;
                    fsCtlIrpSp->MinorFunction = IRP_MN_USER_FS_REQUEST;
                    fsCtlIrpSp->FileObject = irpSp->FileObject;

                    status = IoCallDriver( DeviceObject, fsCtlIrp);
                    if (status == STATUS_PENDING) {

                        status = KeWaitForSingleObject( &event,
                                               Executive,
                                               KernelMode,
                                               FALSE,
                                               (PLARGE_INTEGER) NULL );
                        status = ioStatus.Status;
                    }

                    if ( !NT_SUCCESS(status) ){
                        //
                        // Write EFS and set Key Blob failed. Failed the create
                        //

                        status = STATUS_ACCESS_DENIED;

                    } else {

                        //
                        //  Refresh the cache
                        //

                        if ( EfsId ){
                            if ( !accessToken ){

                                if ( irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken ){
                                    accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken;
                                } else {
                                    accessToken = irpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.PrimaryToken;
                                }

                                if ( accessToken ){

                                    //
                                    // Get User ID
                                    //

                                    status = SeQueryInformationToken(
                                                accessToken,
                                                TokenUser,
                                                &UserId
                                    );
                                }
                            }

                            if (UserId && NT_SUCCESS(status)){

                                status = EfsRefreshCache(
                                            EfsId,
                                            UserId
                                            );

                                if (NT_SUCCESS(status)){

                                    //
                                    // Cache set successfully.
                                    // UserId should not be deleted in this routine.
                                    //

                                    UserId = NULL;
                                }
                            }

                            //
                            //  Cache should not affect the normal operations
                            //

                            status = STATUS_SUCCESS;
                        }
                    }
                } else {
                    //
                    // Failed allocate IRP
                    //

                   status = STATUS_INSUFFICIENT_RESOURCES;

                }

                ExFreePool( currentEfsStream );

            } else {

                //
                // Failed allocating memory for currentEfsStream
                // Use the status returned.
                //

            }
        } else {
            //
            // Failed on calling EFS server.
            // Because of the down level support, we cannot return the new error status code.
            //

            status = STATUS_ACCESS_DENIED;

            ZwFreeVirtualMemory(
                CrntProcess,
                &currentEfsStream,
                &regionSize,
                MEM_RELEASE
                );

            if (ProcessAttached){
                KeUnstackDetachProcess(&ApcState);
                ObDereferenceObject(EfsData.LsaProcess);
                ProcessAttached = FALSE;
            }

        }

    } else {
        //
        // Allocate virtual memory failed. Use the status returned.
        //

        if (ProcessAttached){
            KeUnstackDetachProcess(&ApcState);
            ObDereferenceObject(EfsData.LsaProcess);
            ProcessAttached = FALSE;
        }

    }

    if ( UserId ){

        ExFreePool( UserId );

    }

    if ( EfsId ){

        ExFreePool( EfsId );

    }

    return status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\efs\efsrtl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   efsrtl.c

Abstract:

    This module contains the code that implements the EFS
    call back routines.

Author:

    Robert Gu (robertg) 08-Dec-1996

Environment:

    Kernel mode


Revision History:


--*/

#include "efsrtl.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, EfsEncryptKeyFsData)
#pragma alloc_text(PAGE, EfsOpenFile)
#pragma alloc_text(PAGE, EfsFileControl)
#pragma alloc_text(PAGE, EfsRead)
#pragma alloc_text(PAGE, EfsWrite)
#pragma alloc_text(PAGE, EfsFreeContext)
#pragma alloc_text(PAGE, EfsMountVolumn)
#pragma alloc_text(PAGE, EfsDismountVolumn)
#pragma alloc_text(PAGE, EfsDismountVolumn)
#endif


VOID
EfsEncryptKeyFsData(
    IN PVOID DataBuffer,
    IN ULONG DataLength,
    IN ULONG DataEncOffset,
    IN ULONG RefdataEncOffset,
    IN ULONG RefdataEncLength
    )
/*++

Routine Description:

    This is called by EFS driver to prepare a FSCTL input data buffer.
    The result data will be in the format of
    SUB-CODE plain text, [FSCTL_CODE, SUB-CODE, refdata, [refdata]sk, $EFS]sk

Arguments:

    DataBuffer  -- Point to a buffer holding the FSCTL input data.

    DataLength  -- Input data length.

    DataEncOffset -- The offset of the first byte to be encrypted.

    RefdataEncOffset -- The offset of the first reference byte to be encrypted.
                        Second round encryption.

    RefdataEncLength -- The length of the refdata.

Return Value:

    No.

--*/
{

    LONG bytesToBeEnc;
    PUCHAR pWorkData;
    ULONG encryptionRound;

    PAGED_CODE();

    //
    // Data to be encrypted must be in the blocks of DES_BLOCKLEN
    //

    ASSERT( ((DataLength - DataEncOffset) % DES_BLOCKLEN) == 0 );
    ASSERT( (RefdataEncLength % DES_BLOCKLEN) == 0 );

    //
    // Encrypt the reference data first. Reference data is the data we used to
    // verify the caller. The data can be in the form FEK or sessionKey or
    // sessionKey plus some changeable data
    //

    pWorkData = ((PUCHAR)DataBuffer) + RefdataEncOffset;
    bytesToBeEnc = (LONG) RefdataEncLength;
    encryptionRound = 1;

    do {

        while ( bytesToBeEnc > 0 ) {

            //
            // Encrypt data with DES
            //

            des( pWorkData,
                 pWorkData,
                 &(EfsData.SessionDesTable[0]),
                 ENCRYPT
               );

            pWorkData += DES_BLOCKLEN;
            bytesToBeEnc -= DES_BLOCKLEN;

        }

        //
        // Then encrypt the whole data except the header bytes.
        //

        pWorkData = ((PUCHAR)DataBuffer) + DataEncOffset;
        bytesToBeEnc = (LONG) (DataLength - DataEncOffset);
        encryptionRound++;

    } while ( encryptionRound < 3 );

    return;

}

NTSTATUS
EfsOpenFile(
    IN OBJECT_HANDLE FileHdl,
    IN OBJECT_HANDLE ParentDir OPTIONAL,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG FileDirFlag,
    IN ULONG SystemState,
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT VolDo,
    IN PVOID PfileKeyContext,
    IN OUT PVOID *PContext,
    IN OUT PULONG PContextLength,
    IN OUT PVOID *PCreateContext,
    IN OUT PBOOLEAN Reserved
    )
/*++

Routine Description:

    This is a call back routine. It will be called back by file system when
    an encrypted file is opened or a new file under encrypted directory is
    created.

Arguments:

    FileHdl  -- An object handle of the file

    ParentDir - An object handle of the parent. Can be null for create file in
                root directory. It will be used by EFS only a new file is created.

    IrpSp -- Irp Stack Location pointer.

    FileDirFlag  -- Indicating the status of the parent of the stream, may have four values,
                    FILE_NEW, FILE_EXISTING, DIRECTORY_NEW and DIRECTORY_EXISTING and the
                    status of the stream itself.

    IrpContext - Used in NtOfsCreateAttributeEx().

    VolDo - A pointer to the volumn device object.

    PContext - Not used by EFS.

    PContextLength - Not used by EFS.

Return Value:

    Result of the operation.
    File system should fail the CREATE IRP if fail code returned.

--*/
{

    NTSTATUS ntStatus = STATUS_SUCCESS;
    PEFS_CONTEXT    pEFSContext;
    ULONG   efsLength;
    PVOID   efsStreamData;
    ULONG   information = 0;
    IN PFILE_OBJECT fileObject = IrpSp->FileObject;
/*
    PIO_SECURITY_CONTEXT sContext;
    sContext = IrpSp->Parameters.Create.SecurityContext;
    DbgPrint( "\n Create: Desired Access %x\n", sContext->DesiredAccess );
    DbgPrint( "\n Create: Original Desired Access %x\n", sContext->AccessState->OriginalDesiredAccess );
    DbgPrint( "\n Create: PrevGrant Access %x\n", sContext->AccessState->PreviouslyGrantedAccess );
    DbgPrint( "\n Create: Remaining Desired Access %x\n", sContext->AccessState->RemainingDesiredAccess );
*/
    PAGED_CODE();

    //
    // If read/write data is not required, we will always succeed the call.
    // Treadted as plain text file. No encryption/decryption will be involved.
    //

    CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsOpenFile() in.\n");
#if DBG

    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( "\n EFSFILTER: ******  EFS RTL CREATE ****** \n" );
        DbgPrint( "EFSFILTER: FileDir %x\n", FileDirFlag );
        DbgPrint( "EFSFILTER: Access %x\n", IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess );
    }
#endif

    if ( FALSE == EfsData.EfsInitialized ){

        //
        // Not initialized yet.
        //

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ( (IrpSp->Parameters.Create.FileAttributes & FILE_ATTRIBUTE_SYSTEM) &&
         ( FileDirFlag & (FILE_NEW | DIRECTORY_NEW) )){

        //
        // Do not encrypt SYSTEM File if creating new file
        //

        return STATUS_SUCCESS;
    }

    if ( (IrpSp->Parameters.Create.FileAttributes & FILE_ATTRIBUTE_ENCRYPTED) &&
         ((FileDirFlag & EXISTING_FILE_ENCRYPTED) == 0) &&
         ((FileDirFlag & (FILE_NEW | DIRECTORY_NEW) ) == 0)){

        //
        // Do not encrypt a stream if the file is not encrypted
        //

        return STATUS_SUCCESS;
    }

    if ( (FileDirFlag & (FILE_EXISTING | DIRECTORY_EXISTING)) &&
         !( FileDirFlag & STREAM_NEW ) &&
         !( IrpSp->Parameters.Create.SecurityContext->AccessState->PreviouslyGrantedAccess &
           ( FILE_APPEND_DATA | FILE_READ_DATA | FILE_WRITE_DATA | FILE_EXECUTE ))
       ) {

        return STATUS_SUCCESS;

    }

    //
    // Allocate the EFS context block
    //

    *PCreateContext =  (PEFS_CONTEXT)ExAllocateFromNPagedLookasideList(&(EfsData.EfsContextPool));
    if ( NULL == *PCreateContext){
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    pEFSContext = (PEFS_CONTEXT)*PCreateContext;

    //
    // Set initial status value and initialize the event
    //

    RtlZeroMemory( pEFSContext, sizeof( EFS_CONTEXT ) );
    pEFSContext->Status = NO_FURTHER_PROCESSING;
    pEFSContext->Flags = SystemState;
    KeInitializeEvent(&( pEFSContext->FinishEvent ), SynchronizationEvent, FALSE);

    switch (FileDirFlag & FILE_DIR_TYPE) {

        case FILE_EXISTING:

            //
            // An existing file. Either a new stream created or
            // an existing stream opened
            // The user must be verified.
            // Trying to open $EFS on the file.
            //
#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( " EFSFILTER: ******  File Existed ****** \n" );
    }
#endif
            try{

                ntStatus = EfsReadEfsData(
                                    FileHdl,
                                    IrpContext,
                                    &efsStreamData,
                                    &efsLength,
                                    &information
                                    );
            } finally {
                if (AbnormalTermination()) {
                    ExFreeToNPagedLookasideList(&(EfsData.EfsContextPool), pEFSContext );
                    *PCreateContext = NULL;
                }
            }

            if ( EFS_READ_SUCCESSFUL == information ){

#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){

        DbgPrint( " EFSFILTER: ******  $EFS Existed ****** \n" );

    }
#endif

                //
                // Check if multi-stream.
                //

                if ( PfileKeyContext && SkipCheckStream(IrpSp, efsStreamData)) {

                    //
                    // Skip calling the user mode code
                    //

                    ExFreePool(efsStreamData);
                    efsStreamData = NULL;

                    if ( NULL == *PContext ) {
                        *PContext = GetKeyBlobBuffer(((PKEY_BLOB)PfileKeyContext)->AlgorithmID);
                        if (*PContext) {

                            *PContextLength = ((PKEY_BLOB) *PContext)->KeyLength;
                            RtlCopyMemory( *PContext, PfileKeyContext, ((PKEY_BLOB)PfileKeyContext)->KeyLength );

                        } else {

                            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                            ExFreeToNPagedLookasideList(&(EfsData.EfsContextPool), pEFSContext );
                            *PCreateContext = NULL;

                        }
                    }

                    if (*PContext) {
                        if ( FileDirFlag & STREAM_NEW ){

                            //
                            // New stream, we need to turn on the bit
                            //

#if DBG
    if ( EFSTRACEALL & EFSDebug ){
      DbgPrint("Cache New Named String\n");
    }
#endif
                            pEFSContext->Status = TURN_ON_ENCRYPTION_BIT | TURN_ON_BIT_ONLY | NO_OPEN_CACHE_CHECK;

                        } else {

                            //
                            // Open existing stream, no further actions required.
                            //
#if DBG
    if ( EFSTRACEALL & EFSDebug ){
      DbgPrint("Cache Existing Named String\n");
    }
#endif
                            ExFreeToNPagedLookasideList(&(EfsData.EfsContextPool), pEFSContext );
                            *PCreateContext = NULL;
                            ntStatus = STATUS_SUCCESS;
                        }
                    }

                } else {

                    //
                    // Set the pointers in context block
                    //
                    pEFSContext->EfsStreamData = efsStreamData;
                    pEFSContext->Status = VERIFY_USER_REQUIRED;

                    if ( NULL == *PContext ) {

                        //
                        //  Do not check open cache. We need the key blob.
                        //

                        pEFSContext->Status |= NO_OPEN_CACHE_CHECK;
                    }

                    if ( FileDirFlag & STREAM_NEW ) {
#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( " EFSFILTER: ****** File Existed & Stream New ****** \n" );
    }
#endif
                        pEFSContext->Status |= TURN_ON_ENCRYPTION_BIT;
                    }
                }

            }

            //
            // If EFS_READ_SUCCESSFUL != information
            // ntStatus might still be STATUS_SUCCESS which means it is not
            // encrypted by EFS and we succeeded call.
            // Should we fail the call?
            //

            break;

        case FILE_NEW:

            //
            // A new file created
            // New FEK, DDF, DRF needed
            // Trying to open $EFS on the parent directory
            //

#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( " EFSFILTER: ******  File New ****** \n" );
    }
#endif
            try {
                ntStatus = EfsReadEfsData(
                                    ParentDir,
                                    IrpContext,
                                    &efsStreamData,
                                    &efsLength,
                                    &information
                                    );
            } finally {
                if (AbnormalTermination()) {
                    ExFreeToNPagedLookasideList(&(EfsData.EfsContextPool), pEFSContext );
                    *PCreateContext = NULL;
                }
            }

            if ( EFS_READ_SUCCESSFUL == information ){

#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){

        DbgPrint( " EFSFILTER: ****** Parent $EFS Existed ****** \n" );

    }
#endif
                //
                // Set the pointers in context block
                //
                pEFSContext->EfsStreamData = efsStreamData;
                pEFSContext->Status = NEW_FILE_EFS_REQUIRED |
                                      TURN_ON_ENCRYPTION_BIT |
                                      NO_OPEN_CACHE_CHECK;

            } else if ( OPEN_EFS_FAIL == information ) {
                pEFSContext->EfsStreamData = NULL;
                pEFSContext->Status = NEW_FILE_EFS_REQUIRED |
                                      TURN_ON_ENCRYPTION_BIT |
                                      NO_OPEN_CACHE_CHECK;
                ntStatus =  STATUS_SUCCESS;
            }

            //
            // If EFS_READ_SUCCESSFUL != information
            // ntStatus might still be STATUS_SUCCESS which means it is not
            // encrypted by EFS and we succeeded call.
            // Should we fail the call?
            //

            break;

        case DIRECTORY_NEW:

#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( " EFSFILTER: ****** Directory New ****** \n" );
    }
#endif
            //
            // A new directory created
            // New Public keys needed
            // Trying to open $EFS on the parent directory
            //

            try {

                ntStatus = EfsReadEfsData(
                                    ParentDir,
                                    IrpContext,
                                    &efsStreamData,
                                    &efsLength,
                                    &information
                                    );

            } finally {
                if (AbnormalTermination()) {
                    ExFreeToNPagedLookasideList(&(EfsData.EfsContextPool), pEFSContext );
                    *PCreateContext = NULL;
                }
            }

            if ( EFS_READ_SUCCESSFUL == information ){

#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( " EFSFILTER: ****** Parent $EFS Existed ****** \n" );
    }
#endif

                //
                // Set the pointers in context block
                //
                pEFSContext->EfsStreamData = efsStreamData;
                pEFSContext->Status = NEW_DIR_EFS_REQUIRED |
                                      TURN_ON_ENCRYPTION_BIT |
                                      NO_OPEN_CACHE_CHECK;

            } else if ( OPEN_EFS_FAIL == information ) {
                pEFSContext->EfsStreamData = NULL;
                pEFSContext->Status = NEW_DIR_EFS_REQUIRED |
                                      TURN_ON_ENCRYPTION_BIT |
                                      NO_OPEN_CACHE_CHECK;
                ntStatus =  STATUS_SUCCESS;
            }


            //
            // If EFS_READ_SUCCESSFUL != information
            // ntStatus might still be STATUS_SUCCESS which means it is not
            // encrypted by EFS and we succeeded call.
            // Should we fail the call?
            //

            break;

        case DIRECTORY_EXISTING:

#if DBG
    if ( EFSTRACEALL & EFSDebug ){
        DbgPrint( " EFSFILTER: ****** Directory Existed ****** \n" );
    }
#endif
            //
            // An existing directory. Either a new stream created or
            // an existing stream opened
            // We do not encrypt data stream for Directory. Ignore this.
            //

        default:

            break;

    }

    CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsOpenFile() Out.\n");
    return ntStatus;
}

NTSTATUS
EfsFileControl(
    IN PVOID PInputBuffer,
    IN ULONG InputDataLength,
    OUT PVOID POutputBuffer OPTIONAL,
    IN OUT PULONG POutputBufferLength,
    IN ULONG EncryptionFlag,
    IN ULONG AccessFlag,
    IN ULONG SystemState,
    IN ULONG FsControlCode,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT VolDo,
    IN ATTRIBUTE_HANDLE StreamHdl,
    IN OUT PVOID *PContext,
    IN OUT PULONG PContextLength
    )
/*++

Routine Description:

    This is a call back routine. It will be called back by file system to
    support EFS's FSCTL APIs

Arguments:

    PInputBuffer - Pointer to the input data buffer. The first 4 bytes are
                  for information to Ntfs or some other drivers only. The EFS related
                  data are encrypted in the following bytes. The first 4 encrypted
                  bytes are subfunction code in the form of EFS_XXX. General package
                  looks like this,
                  Subcode plain text, EFS subfunction code, EFS subcode cipher text, FSCTL specific data.

    InputDataLength - The length of the input data buffer.

    POutputBuffer - Pointer to the output data buffer.

    POutputBufferLength - The length of the output data.

    EncryptionFlag - Indicating if this stream is encrypted or not.

    AccessFlag - Indicating the desired access when the stream is opened.

    FsControlCode - Indicating what FSCTL was originally called.

    FileHdl - Used to access the $EFS.

    IrpContext - Irp context used to call NtOfsCreateAttributeEx().

    VolDo - A pointer to the volumn device object.

    StreamHdl - Stream to be worked on.

    PContext - BLOB(key) for READ or WRITE later.

    PContextLength - The length of the context.

Return Value:

    STATUS_SUCCESS for successful operation.

--*/
{

    ULONG functionCode;
    ULONG bytesSame;
    ULONG efsLength;
    ULONG workOffset;
    ULONG information=0;
    ULONG dataFlushLength = FIELD_OFFSET(GENERAL_FS_DATA, EfsData[0]);
    PUCHAR pCmdContext = NULL;
    PVOID efsStreamData = NULL;
    NTSTATUS ntStatus;
    ATTRIBUTE_HANDLE  attribute;
    BOOLEAN verifyInput;

    PAGED_CODE();

    CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsFileControl() in.\n");
#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( "\n EFSFILTER: ******  EFS RTL FSCTL ****** \n" );
    }
#endif

    if ( (NULL == PInputBuffer) || ( FALSE == EfsData.EfsInitialized )){
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Input data is encrypted by DES with sessionKey.
    // As long as we do not change the algorithm for the input data
    // We need guarantee the data length is in multiple of DES block size.
    // The first four bytes is always in plain text intended to hold the data
    // the NTFS is interested in.
    // The general format of input data is,
    // Sub-code plain text, [FsCode, Sub-code cipher text, [FsData]]sk
    //

    if ((InputDataLength < (ULONG)(FIELD_OFFSET(FSCTL_INPUT, EfsFsData[0]) + FIELD_OFFSET(GENERAL_FS_DATA, EfsData[0]))) || ((( InputDataLength - sizeof( ULONG )) % DES_BLOCKLEN ) != 0)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    pCmdContext = ExAllocatePoolWithTag(
                                PagedPool,
                                InputDataLength,
                                'csfE'
                                );

    if ( NULL == pCmdContext ){

        return STATUS_INSUFFICIENT_RESOURCES;

    }

    //
    // Decrypt FSCTL input buffer. No CBC is used.
    //

    try {
        RtlCopyMemory( pCmdContext, PInputBuffer, InputDataLength );
    } except (EXCEPTION_EXECUTE_HANDLER) {
        ntStatus = GetExceptionCode();
        ExFreePool( pCmdContext );
        if (FsRtlIsNtstatusExpected( ntStatus)) {
            return ntStatus;
        } else {
            return STATUS_INVALID_USER_BUFFER;
        }
    }

    workOffset = sizeof( ULONG );
    while ( workOffset < InputDataLength ){

        des( pCmdContext + workOffset,
             pCmdContext + workOffset,
             &(EfsData.SessionDesTable[0]),
             DECRYPT
           );

        workOffset += DES_BLOCKLEN;
    }

    functionCode = ((PFSCTL_INPUT)pCmdContext)->EfsFsCode;

#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){
        DbgPrint( "\n EFSFILTER: EFS RTL FSCTL=%x \n", functionCode);
    }
#endif

    //
    // Check the codes match for set encrypt and decrypt to guard the integrity
    // of the encryption status. The NTFS is going to set/clear the bits. We really
    // want to make sure the FSCTL is issued by the right module.
    //

    if ( FSCTL_SET_ENCRYPTION == FsControlCode){
        if (SystemState & SYSTEM_IS_READONLY) {

            //
            // This could be issued from right components
            //

            RtlSecureZeroMemory(&(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]), dataFlushLength);
            ExFreePool( pCmdContext );
            return STATUS_MEDIA_WRITE_PROTECTED;
        }
        if ( EFS_SET_ENCRYPT == functionCode ){
            if ( ((PFSCTL_INPUT)pCmdContext)->PlainSubCode !=
                 (((PFSCTL_INPUT)pCmdContext)->CipherSubCode & ~EFS_FSCTL_ON_DIR ) ){

                ExFreePool( pCmdContext );
                return STATUS_INVALID_DEVICE_REQUEST;

            }
        } else if ( (EFS_SET_ATTRIBUTE != functionCode) &&
                    (EFS_OVERWRITE_ATTRIBUTE != functionCode) ){

             ExFreePool( pCmdContext );
             return STATUS_INVALID_DEVICE_REQUEST;

        }
     }

    switch ( functionCode ){

        case EFS_SET_ATTRIBUTE:

            //
            // Write $EFS and/or set key Blob
            // subCode is a bit mask for the combination of write $EFS and set blob
            // [FsData] = FEK, [FEK]sk, [$EFS]
            //     FEK == sessionKey when set key Blob is not required
            //
            // We cannot check access rights here. This call will be made if the
            // user creates a new file and without any access requirement. We
            // still want to setup FEK inside this call.
            //

            if ( !EfsVerifyKeyFsData(
                        &(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]),
                        InputDataLength) ){

                //
                // Input data format error. Could be issued from attacker.
                //

                ExFreePool( pCmdContext );
                return STATUS_INVALID_PARAMETER;

            }

            try {
                ntStatus = SetEfsData(
                            pCmdContext,
                            InputDataLength,
                            SystemState,
                            FileHdl,
                            IrpContext,
                            PContext,
                            PContextLength
                            );
            } finally {

                dataFlushLength = 2 * (EFS_KEY_SIZE((PEFS_KEY) &(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0])));
                RtlSecureZeroMemory(&(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]), dataFlushLength);
                ExFreePool( pCmdContext );

            }
            CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsFileControl() Out 1.\n");
            return ntStatus;

        case EFS_SET_ENCRYPT:

            if ( !( AccessFlag & ( READ_DATA_ACCESS | WRITE_DATA_ACCESS ))){

                //
                // Check access flag. Could be called by an attacker.
                //

                ExFreePool( pCmdContext );
                return STATUS_ACCESS_DENIED;

            }

            try {
                ntStatus = EfsSetEncrypt(
                                pCmdContext,
                                InputDataLength,
                                EncryptionFlag,
                                FileHdl,
                                IrpContext,
                                PContext,
                                PContextLength
                                );
            } finally {

                //
                // Memory should have been zeroed in EfsSetEncrypt. 
                //

                ExFreePool( pCmdContext );
            }

            CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsFileControl() Out 2.\n");
            return ntStatus;

        case EFS_GET_ATTRIBUTE:

            //
            // Provide read access to $EFS for EFS service
            // Verify the input data format first.
            //

            try {
                if ( (NULL == POutputBuffer) ||
                      (*POutputBufferLength < sizeof(ULONG)) ||
                     !EfsVerifyGeneralFsData(
                            &(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]),
                            InputDataLength)){

                    ExFreePool( pCmdContext );
                    return STATUS_INVALID_PARAMETER;

                }
            } except(EXCEPTION_EXECUTE_HANDLER) {
                ntStatus = GetExceptionCode();
                ExFreePool( pCmdContext );
                if (FsRtlIsNtstatusExpected( ntStatus)) {
                    return ntStatus;
                } else {
                    return STATUS_INVALID_USER_BUFFER;
                }
            }

            if ( !(EncryptionFlag &  STREAM_ENCRYPTED) ){

                RtlSecureZeroMemory(&(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]), dataFlushLength);
                ExFreePool( pCmdContext );
                return STATUS_INVALID_DEVICE_REQUEST;

            }

            //
            // Try to read an existing $EFS
            //

            try {
                ntStatus = EfsReadEfsData(
                                    FileHdl,
                                    IrpContext,
                                    &efsStreamData,
                                    &efsLength,
                                    &information
                                    );
            } finally {

                //
                // Zero pCmdContext. This is not needed if the the input format data
                // is not good as in the above error cases, which means some is trying
                // to attack us.
                //

                RtlSecureZeroMemory(&(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]), dataFlushLength);
                ExFreePool( pCmdContext );
                pCmdContext = NULL;

            }

            if ( EFS_READ_SUCCESSFUL == information ){

                //
                // Everything is OK. We do not check user ID here,
                // we suppose that has been checked by the service.
                //

                try {
                    ntStatus = STATUS_SUCCESS;
                    if ( efsLength > *POutputBufferLength ) {

                        * (ULONG *) POutputBuffer = efsLength;
                        *POutputBufferLength = sizeof(ULONG);
                        ExFreePool( efsStreamData );
                        return STATUS_BUFFER_TOO_SMALL;

                    }

                    RtlCopyMemory(POutputBuffer, efsStreamData, efsLength);
                    *POutputBufferLength = efsLength;
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    ntStatus = GetExceptionCode();
                    if (!FsRtlIsNtstatusExpected( ntStatus)) {
                        ntStatus = STATUS_INVALID_USER_BUFFER;
                    }
                }

                ExFreePool( efsStreamData );
                return ntStatus;

            } else if ( ( OPEN_EFS_FAIL == information ) ||
                            ( EFS_FORMAT_ERROR == information ) ) {

                //
                // EFS does not exist or not encrypted by the EFS ?
                //

                ntStatus =  STATUS_INVALID_DEVICE_REQUEST;

            }


            //
            // Other error while opening $EFS
            //

            return ntStatus;

        case EFS_DEL_ATTRIBUTE:

            if (SystemState & SYSTEM_IS_READONLY) {
                RtlSecureZeroMemory(&(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]), dataFlushLength);
                ExFreePool( pCmdContext );
                return STATUS_MEDIA_WRITE_PROTECTED;
            }
            if ( !( AccessFlag & WRITE_DATA_ACCESS )){

                //
                // Check access flag
                //

                RtlSecureZeroMemory(&(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]), dataFlushLength);
                ExFreePool( pCmdContext );
                return STATUS_ACCESS_DENIED;

            }

            //
            // Delete $EFS after all the stream has been decrypted.
            //

            if ( EncryptionFlag ){

                //
                // Stream has not been decrypted
                //

                RtlSecureZeroMemory(&(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]), dataFlushLength);
                ExFreePool( pCmdContext );
                return STATUS_INVALID_DEVICE_REQUEST;

            }

            //
            // [FsData] = SessionKey, Handle, Handle, [SessionKey, Handle, Handle]sk
            // Verify the FsData format.
            //

            if ( !EfsVerifyGeneralFsData(
                        &(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]),
                        InputDataLength) ){

                //
                // Input data format error. No need to zero attacker provided pCmdContext block. 
                //

                ExFreePool( pCmdContext );
                return STATUS_INVALID_PARAMETER;

            }

            //
            // Delete the $EFS stream
            //

            try {
                ntStatus = EfsDeleteEfsData( FileHdl, IrpContext );
            } finally {
                RtlSecureZeroMemory(&(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]), dataFlushLength);
                ExFreePool( pCmdContext );
            }

            return ntStatus;

        case EFS_ENCRYPT_DONE:

            //
            // Change the transition state of $EFS to normal state
            // Fall through intended.
            //
#if DBG
    if ( EFSTRACEALL & EFSDebug ){
        DbgPrint( "\n EFSFILTER: Encryption Done %x\n", functionCode );
    }
#endif

        case EFS_DECRYPT_BEGIN:

            if (SystemState & SYSTEM_IS_READONLY) {
                ExFreePool( pCmdContext );
                return STATUS_MEDIA_WRITE_PROTECTED;
            }
            if ( !( AccessFlag & WRITE_DATA_ACCESS )){

                //
                // Check access flag
                //

                ExFreePool( pCmdContext );
                return STATUS_ACCESS_DENIED;

            }

            //
            // Mark the transition state of $EFS
            //

            try {
                ntStatus = EfsModifyEfsState(
                                functionCode,
                                pCmdContext,
                                InputDataLength,
                                FileHdl,
                                IrpContext
                                );
            } finally {

                RtlSecureZeroMemory(&(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]), dataFlushLength);
                ExFreePool( pCmdContext );

            }

            return ntStatus;

    case EFS_OVERWRITE_ATTRIBUTE:

            
            if ( ((PFSCTL_INPUT)pCmdContext)->CipherSubCode & SET_EFS_KEYBLOB ){

                //
                // FEK, [FEK]sk, [$EFS]
                //

                dataFlushLength = 2 * (EFS_KEY_SIZE((PEFS_KEY) &(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0])));

            } else {

                //
                // SessionKey, Handle, Handle, [SessionKey, Handle, Handle]sk
                //

                dataFlushLength = FIELD_OFFSET(GENERAL_FS_DATA, EfsData[0]);

            }

            if ( !( AccessFlag &
                   ( WRITE_DATA_ACCESS |
                     RESTORE_ACCESS ))){

                //
                // Check access flag
                //

                RtlSecureZeroMemory(&(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]), dataFlushLength);
                ExFreePool( pCmdContext );
                return STATUS_ACCESS_DENIED;

            }

            //
            // Mostly used in import
            // Overwrite $EFS and/or set key Blob
            // subCode is a bit mask for the combination of write $EFS and set blob
            //

            if ( ((PFSCTL_INPUT)pCmdContext)->CipherSubCode & SET_EFS_KEYBLOB ){

                verifyInput = EfsVerifyKeyFsData(
                                            &(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]),
                                            InputDataLength
                                            );

            } else {

                verifyInput = EfsVerifyGeneralFsData(
                                            &(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]),
                                            InputDataLength
                                            );

            }

            if ( !verifyInput ){

                //
                // Input data format error. No need to zero attacker provided memory.
                //

                ExFreePool( pCmdContext );
                return STATUS_INVALID_PARAMETER;

            }

            try {
                ntStatus = SetEfsData(
                            pCmdContext,
                            InputDataLength,
                            SystemState,
                            FileHdl,
                            IrpContext,
                            PContext,
                            PContextLength
                            );
            } finally {

                RtlSecureZeroMemory(&(((PFSCTL_INPUT)pCmdContext)->EfsFsData[0]), dataFlushLength);
                ExFreePool( pCmdContext );

            }
            CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsFileControl() Out 3.\n");
            return ntStatus;

        default:
//            ASSERT (FALSE);
            ExFreePool( pCmdContext );
            return STATUS_INVALID_DEVICE_REQUEST;
    }
    CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsFileControl() Out 4.\n");
}


NTSTATUS
EfsRead(
    IN OUT PUCHAR InOutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PVOID Context
    )
/*++

Routine Description:

    This is a call back routine. It will be called back by file system and
    decrypt the data in the buffer provided by the file system.

Arguments:

    InOutBuffer - Pointer to the data block to be decrypted.

    Offset - Pointer to the offset of the block in the file. Relative to the
             beginning of the file.

    BufferSize - Length of the data block.

    Context - Information needed to decrypt the file. Passed to the file
              system on EfsOpenFile()

Return Value:

    This routine will not cause error. Unless the memory passed in is not
    valid. In that case, memory flush will occur.

--*/
{
    ULONGLONG chainBlockIV[2];
    PUCHAR pWorkBuffer = InOutBuffer;
    EfsDecFunc  pDecryptFunc;


    PAGED_CODE();

#if DBG
    if ( EFSTRACEALL & EFSDebug ){
        DbgPrint( "\n EFSFILTER: READ Bytes = %x, Offset = %x\n", BufferSize,  Offset->QuadPart);
    }
#endif

    //
    // Data length should be in multiple of the chunk (512 Bytes)
    // Data offset (relative to the begining of the stream) should
    // Start at chunk boundary
    //

    CheckValidKeyBlock(Context,"Please contact RobertG if you see this. EfsRead() in.\n");
    ASSERT (BufferSize % CHUNK_SIZE == 0);
    ASSERT (Offset->QuadPart % CHUNK_SIZE == 0);


    switch (((PKEY_BLOB)Context)->AlgorithmID){

        case CALG_3DES:
            chainBlockIV[0] = Offset->QuadPart + EFS_IV;
            pDecryptFunc = EFSDes3Dec;
            break;
        case CALG_DESX:
            chainBlockIV[0] = Offset->QuadPart + EFS_IV;
            pDecryptFunc = EFSDesXDec;
            break;
        case CALG_AES_256:
            chainBlockIV[0] = Offset->QuadPart + EFS_AES_IVL;
            chainBlockIV[1] = Offset->QuadPart + EFS_AES_IVH;
            pDecryptFunc = EFSAesDec;
            break;
        case CALG_DES:
        default:
            chainBlockIV[0] = Offset->QuadPart + EFS_IV;
            pDecryptFunc = EFSDesDec;
            break;
    }

    while ( BufferSize > 0 ){

        pDecryptFunc(pWorkBuffer,
                  (PUCHAR) &chainBlockIV[0],
                  (PKEY_BLOB) Context,
                  CHUNK_SIZE
                  );

        pWorkBuffer += CHUNK_SIZE;
        chainBlockIV[0] += CHUNK_SIZE;
        if (((PKEY_BLOB)Context)->AlgorithmID == CALG_AES_256) {
            chainBlockIV[1] += CHUNK_SIZE;
        }
        BufferSize -= CHUNK_SIZE;
    }

    CheckValidKeyBlock(Context,"Please contact RobertG if you see this. EfsRead() out.\n");
    return ( STATUS_SUCCESS );
}


NTSTATUS
EfsWrite(
    IN PUCHAR InBuffer,
    OUT PUCHAR OutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PUCHAR Context
    )
/*++

Routine Description:

    This is a call back routine. It will be called back by file system and
    encrypt the data in the buffer provided by the file system.

    Note: The input data buffer can only be touched once.

Arguments:

    InBuffer - Pointer to the data block to be encrypted.

    OutBuffer - Pointer to the data buffer to hold the encrypted data.

    Offset - Pointer to the offset of the block in the file. Relative to the
             beginning of the file.

    BufferSize - Length of the data block.

    Context - Information needed to decrypt the file. Passed to the file
              system on EfsOpenFile()

Return Value:

    This routine will not cause error. Unless the memory passed in is not
    valid. In that case, memory flush will occur.

--*/
{
    ULONGLONG chainBlockIV[2];
    PUCHAR pWorkInBuffer = InBuffer;
    PUCHAR pWorkOutBuffer = OutBuffer;
    EfsEncFunc  pEncryptFunc;


    PAGED_CODE();

    //
    // Data length should be in multiple of the chunk (512 Bytes)
    // Data offset (relative to the begining of the stream) should
    // Start at chunk boundary
    //

    CheckValidKeyBlock(Context,"Please contact RobertG if you see this. EfsWrite() in.\n");
    ASSERT (BufferSize % CHUNK_SIZE == 0);
    ASSERT (Offset->QuadPart % CHUNK_SIZE == 0);

#if DBG
    if ( EFSTRACEALL & EFSDebug ){
        DbgPrint( "\n EFSFILTER: WRITE Bytes = %x, Offset = %x\n", BufferSize,  Offset->QuadPart);
    }
#endif

    switch (((PKEY_BLOB)Context)->AlgorithmID){
        case CALG_3DES:
            chainBlockIV[0] = Offset->QuadPart + EFS_IV;
            pEncryptFunc = EFSDes3Enc;
            break;
        case CALG_DESX:
            chainBlockIV[0] = Offset->QuadPart + EFS_IV;
            pEncryptFunc = EFSDesXEnc;
            break;
        case CALG_AES_256:
            chainBlockIV[0] = Offset->QuadPart + EFS_AES_IVL;
            chainBlockIV[1] = Offset->QuadPart + EFS_AES_IVH;
            pEncryptFunc = EFSAesEnc;
            break;
        case CALG_DES:
        default:
            chainBlockIV[0] = Offset->QuadPart + EFS_IV;
            pEncryptFunc = EFSDesEnc;
            break;
    }

    while ( BufferSize > 0 ){
        pEncryptFunc(pWorkInBuffer,
                  pWorkOutBuffer,
                  (PUCHAR) &chainBlockIV,
                  (PKEY_BLOB)Context,
                  CHUNK_SIZE
                  );

        pWorkInBuffer += CHUNK_SIZE;
        pWorkOutBuffer += CHUNK_SIZE;
        chainBlockIV[0] += CHUNK_SIZE;
        if (((PKEY_BLOB)Context)->AlgorithmID == CALG_AES_256) {
            chainBlockIV[1] += CHUNK_SIZE;
        }
        BufferSize -= CHUNK_SIZE;
    }
    CheckValidKeyBlock(Context,"Please contact RobertG if you see this. EfsWrite() out.\n");
    return STATUS_SUCCESS;
}

VOID
EfsFreeContext(
    IN OUT PVOID *PContext
    )
/*++

Routine Description:

    This is a call back routine. It will be called back by file system to
    free the context block.

Arguments:

    PContext - Context block to be freed.

Return Value:

    This routine will not cause error. Unless the memory passed in is not
    valid.

--*/
{
    PAGED_CODE();

#if DBG
    if ( EFSTRACEALL & EFSDebug ){
        DbgPrint( " EFSFILTER: ******  Free Key ****** \n" );
    }
#endif

    CheckValidKeyBlock(*PContext,"Please contact RobertG if you see this. EfsFreeContext() in.\n");
    if (*PContext){
        FreeMemoryBlock(PContext);
    }

}

NTSTATUS
EfsMountVolumn(
    IN PDEVICE_OBJECT VolDo,
    IN PDEVICE_OBJECT RealDevice
    )
/*++

Routine Description:

    This is a call back routine. It will be called back by file system
    when a volumn needs to be attached

Arguments:

    VolDo - Volume device object
    RealDevice - Volume real device object

Return Value:

    The status of operation.

--*/
{
    PDEVICE_OBJECT fsfDeviceObject;
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

#if DBG
    if ( EFSTRACEALL & EFSDebug ){
        DbgPrint( "\n *****EFSFILTER:  RTL mount.***** \n" );
    }
#endif

    return STATUS_SUCCESS;

}

VOID
EfsDismountVolumn(
    IN PDEVICE_OBJECT VolDo
    )
/*++

Routine Description:

    This is a call back routine. It will be called back by file system
    when a volumn is dismounted

Arguments:

    VolDo - volumn's device object.

Return Value:

    No return value.

--*/
{
    PAGED_CODE();

#if DBG

    if ( EFSTRACEALL & EFSDebug ){

        DbgPrint( "EFSFILTER:  Dismount callback. \n" );

    }

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\efs\efsext.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Abstract:

   This module contains the common extern header information for the EFS
   file system filter driver.

Author:

   Robert Gu (robertg)  29-Oct-1996

Enviroment:

   Kernel Mode Only

Revision History:

--*/
#ifndef EFSEXT_H
#define EFSEXT_H

#include "efs.h"

//Global externals
extern EFS_DATA EfsData;

#if DBG

extern ULONG EFSDebug;

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\efs\efsrtlsp.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   efsrtlsp.c

Abstract:

   This module will provide EFS RTL support routines.

Author:

    Robert Gu (robertg) 20-Dec-1996
Environment:

   Kernel Mode Only

Revision History:

--*/

#include "efsrtl.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, EfsReadEfsData)
#pragma alloc_text(PAGE, EfsVerifyGeneralFsData)
#pragma alloc_text(PAGE, EfsVerifyKeyFsData)
#pragma alloc_text(PAGE, EfsDeleteEfsData)
#pragma alloc_text(PAGE, EfsSetEncrypt)
#pragma alloc_text(PAGE, EfsEncryptStream)
#pragma alloc_text(PAGE, EfsEncryptFile)
#pragma alloc_text(PAGE, EfsDecryptStream)
#pragma alloc_text(PAGE, EfsDecryptFile)
#pragma alloc_text(PAGE, EfsEncryptDir)
#pragma alloc_text(PAGE, EfsModifyEfsState)
#pragma alloc_text(PAGE, GetEfsStreamOffset)
#pragma alloc_text(PAGE, SetEfsData)
#pragma alloc_text(PAGE, EfsFindInCache)
#pragma alloc_text(PAGE, EfsRefreshCache)
#pragma alloc_text(PAGE, SkipCheckStream)
#endif


NTSTATUS
EfsReadEfsData(
       IN OBJECT_HANDLE FileHdl,
       IN PIRP_CONTEXT IrpContext,
       OUT PVOID   *EfsStreamData,
       OUT PULONG   PEfsStreamLength,
       OUT PULONG Information
       )
/*++

Routine Description:

    This is an internal support routine. The purpose is to reduce the code size.
    It is used to read $EFS data and set the context block.

Arguments:

    FileHdl  -- An object handle to access the attached $EFS

    IrpContext -- Used in NtOfsCreateAttributeEx().

    EfsStreamData -- Point to $EFS data read.

    Information -- Return the processing information

Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/
{
    NTSTATUS ntStatus;
    ATTRIBUTE_HANDLE  attribute = NULL;
    LONGLONG attriOffset;
    ULONG   efsLength;
    PVOID   efsMapBuffer = NULL;
    MAP_HANDLE efsMapHandle;

    PAGED_CODE();

    if (EfsStreamData) {
        *EfsStreamData = NULL;
    }

    try {

        ntStatus = NtOfsCreateAttributeEx(
                             IrpContext,
                             FileHdl,
                             EfsData.EfsName,
                             $LOGGED_UTILITY_STREAM,
                             OPEN_EXISTING,
                             TRUE,
                             &attribute
                             );

        if (NT_SUCCESS(ntStatus)){

                LONGLONG  attrLength;

                NtOfsInitializeMapHandle(&efsMapHandle);

                //
                // Prepare to map and read the $EFS data
                //

                attrLength = NtOfsQueryLength ( attribute );

                if (attrLength <= sizeof ( EFS_DATA_STREAM_HEADER ) ){

                    //
                    // Not our $EFS
                    //

                    NtOfsCloseAttribute(IrpContext, attribute);
                    *Information = EFS_FORMAT_ERROR;
                    ntStatus = STATUS_SUCCESS;

                    leave;

                }

                if ( attrLength > EFS_MAX_LENGTH) {

                    //
                    // EFS stream too long ( > 256K )
                    // We might support that in the future
                    // In that case, we need multiple map window
                    //

                    NtOfsCloseAttribute(IrpContext, attribute);
                    *Information = EFS_FORMAT_ERROR;
                    ntStatus = STATUS_SUCCESS;

                    leave;
                }

                attriOffset = 0;
                *PEfsStreamLength = efsLength = (ULONG) attrLength;

                NtOfsMapAttribute(
                        IrpContext,
                        attribute,
                        attriOffset,
                        efsLength,
                        &efsMapBuffer,
                        &efsMapHandle
                        );

                //
                // Double check the EFS
                //

                if ( efsLength != *(ULONG *)efsMapBuffer){

                    //
                    // Not our $EFS
                    //

                    NtOfsReleaseMap(IrpContext, &efsMapHandle);
                    NtOfsCloseAttribute(IrpContext, attribute);
                    *Information = EFS_FORMAT_ERROR;
                    ntStatus = STATUS_SUCCESS;

                    leave;
                }

                //
                // Allocate memory for $EFS
                //

                if ( EfsStreamData ){

                    //
                    // $EFS must be read
                    //

                    *EfsStreamData = ExAllocatePoolWithTag(
                                        PagedPool,
                                        efsLength,
                                        'msfE'
                                        );

                    if ( NULL == *EfsStreamData ){

                        NtOfsReleaseMap(IrpContext, &efsMapHandle);
                        NtOfsCloseAttribute(IrpContext, attribute);
                        *Information = OUT_OF_MEMORY;
                        ntStatus =  STATUS_INSUFFICIENT_RESOURCES;

                        leave;

                    }

                    RtlCopyMemory(*EfsStreamData, efsMapBuffer, efsLength);

                }

                NtOfsReleaseMap(IrpContext, &efsMapHandle);
                NtOfsCloseAttribute(IrpContext, attribute);

                *Information = EFS_READ_SUCCESSFUL;
                ntStatus = STATUS_SUCCESS;

        } else {

            //
            // Open failed. Not encrypted by EFS.
            //

            *Information = OPEN_EFS_FAIL;
            ntStatus = STATUS_SUCCESS;

        }
    } finally {

        if (AbnormalTermination()) {

            //
            //  Get the exception status
            //
    
            *Information = NTOFS_EXCEPTION;
    
            if (EfsStreamData && *EfsStreamData) {
                ExFreePool(*EfsStreamData);
                *EfsStreamData = NULL;
            }
            if (efsMapBuffer) {
                NtOfsReleaseMap(IrpContext, &efsMapHandle);
            }
            if (attribute) {
                NtOfsCloseAttribute(IrpContext, attribute);
            }
        }


    }

    return ntStatus;

}

BOOLEAN
EfsVerifyGeneralFsData(
    IN PUCHAR DataOffset,
    IN ULONG InputDataLength
    )
/*++

Routine Description:

    This is an internal support routine. The purpose is to verify the general
    FSCTL input data to see if it is sent by EFS component or not.

    General EFS data format is like the following,

    SessionKey, Handle, Handle, [SessionKey, Handle, Handle]sk

Arguments:

    DataOffset  -- Point to a buffer holding the FSCTL general data part.

    InputDataLength -- The length of the FSCTL input puffer

Return Value:

    TRUE if verified.

--*/
{

    ULONG bytesSame;
    ULONG minLength;

    PAGED_CODE();

    minLength = 4 * DES_BLOCKLEN + 3 * sizeof(ULONG);
    if (InputDataLength < minLength){
        return FALSE;
    }

    //
    // Decrypt the encrypted data part.
    //

    des( DataOffset + 2 * DES_BLOCKLEN,
         DataOffset + 2 * DES_BLOCKLEN,
         &(EfsData.SessionDesTable[0]),
         DECRYPT
       );

    des( DataOffset + 3 * DES_BLOCKLEN,
         DataOffset + 3 * DES_BLOCKLEN,
         &(EfsData.SessionDesTable[0]),
         DECRYPT
       );

    bytesSame = (ULONG)RtlCompareMemory(
                     DataOffset,
                     DataOffset + 2 * DES_BLOCKLEN,
                     2 * DES_BLOCKLEN
                    );

    if (( 2 * DES_BLOCKLEN ) != bytesSame ){

            //
            // Input data format error
            //

            return FALSE;

    }

    bytesSame = (ULONG)RtlCompareMemory(
                     DataOffset,
                     &(EfsData.SessionKey[0]),
                     DES_KEYSIZE
                    );

    if ( DES_KEYSIZE != bytesSame ){

        //
        // Input data is not set by EFS component.
        // The session key does not match.
        //

        return FALSE;

    }

    return TRUE;

}

BOOLEAN
EfsVerifyKeyFsData(
    IN PUCHAR DataOffset,
    IN ULONG InputDataLength
    )
/*++

Routine Description:

    This is an internal support routine. The purpose is to verify the
    FSCTL input data with FEK encrypted to see if it is sent by EFS
    component or not.

    Key EFS data format is like the following,

    FEK, [FEK]sk, [$EFS]

Arguments:

    DataOffset  -- Point to a buffer holding the FSCTL general data part.

    InputDataLength -- The length of the FSCTL input puffer

Return Value:

    TRUE if verified.

--*/
{

    ULONG bytesSame;
    LONG encLength;
    PUCHAR encBuffer;

    PAGED_CODE();

    encLength = EFS_KEY_SIZE( ((PEFS_KEY)DataOffset) );

    if  ( (InputDataLength < (2 * encLength + 3 * sizeof(ULONG))) ||
          (0 != ( encLength % DES_BLOCKLEN )) ||
          ( encLength <= 0 )){
        return FALSE;
    }

    //
    // Decrypt the encrypted data part.
    //

    encBuffer = DataOffset + encLength;

    while ( encLength > 0 ){

        des( encBuffer,
             encBuffer,
             &(EfsData.SessionDesTable[0]),
             DECRYPT 
           );

        encBuffer += DES_BLOCKLEN;
        encLength -= DES_BLOCKLEN;

    }

    //
    //  Compare the two parts.
    //

    encLength = EFS_KEY_SIZE( ((PEFS_KEY)DataOffset) );
    bytesSame = (ULONG)RtlCompareMemory(
                     DataOffset,
                     DataOffset + encLength,
                     encLength
                    );

    if ( ((ULONG) encLength) != bytesSame ){

            //
            // Input data format error
            //

            return FALSE;

    }

    return TRUE;

}

NTSTATUS
EfsDeleteEfsData(
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext
        )
/*++

Routine Description:

    This is an internal support routine. It deletes $EFS.

Arguments:

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/
{

    ATTRIBUTE_HANDLE  attribute = NULL;
    NTSTATUS ntStatus;

    PAGED_CODE();

    //
    // Delete the $EFS stream
    //

    try {
        ntStatus = NtOfsCreateAttributeEx(
                             IrpContext,
                             FileHdl,
                             EfsData.EfsName,
                             $LOGGED_UTILITY_STREAM,
                             OPEN_EXISTING,
                             TRUE,
                             &attribute
                             );

        if (NT_SUCCESS(ntStatus)){

            NtOfsDeleteAttribute( IrpContext, FileHdl, attribute );

        }
    } finally {

        if (attribute) {

            //
            // According to NTFS, we shouldn't get exception below.
            //

            NtOfsCloseAttribute(IrpContext, attribute);
        }
    }

    return ntStatus;
}



NTSTATUS
EfsSetEncrypt(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext,
        IN OUT PVOID *Context,
        IN OUT PULONG PContextLength
        )
/*++

Routine Description:

    This is an internal support routine. It process the call of
    FSCTL_SET_ENCRYPT.

Arguments:

    InputData -- Input data buffer of FSCTL.

    InputDataLength -- The length of input data.

    EncryptionFlag -- Indicating if this stream is encrypted or not.

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

    Context -- Blob(key) for READ or WRITE later.

    PContextLength -- Length og the key Blob

Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/
{

    PAGED_CODE();

    switch ( ((PFSCTL_INPUT)InputData)->CipherSubCode ){

        case EFS_ENCRYPT_STREAM:

            return EfsEncryptStream(
                            InputData,
                            InputDataLength,
                            EncryptionFlag,
                            FileHdl,
                            IrpContext,
                            Context,
                            PContextLength
                            );

        case EFS_ENCRYPT_FILE:

             return EfsEncryptFile(
                            InputData,
                            InputDataLength,
                            EncryptionFlag,
                            FileHdl,
                            IrpContext,
                            Context
                            );

        case EFS_DECRYPT_STREAM:

            return EfsDecryptStream(
                    InputData,
                    InputDataLength,
                    EncryptionFlag,
                    FileHdl,
                    IrpContext,
                    Context,
                    PContextLength
                    );

        case EFS_DECRYPT_FILE:
        case EFS_DECRYPT_DIRFILE:

            return EfsDecryptFile(
                    InputData,
                    InputDataLength,
                    FileHdl,
                    IrpContext
                    );

        case EFS_ENCRYPT_DIRSTR:

             return EfsEncryptDir(
                            InputData,
                            InputDataLength,
                            EncryptionFlag,
                            FileHdl,
                            IrpContext
                            );

            break;

        case EFS_DECRYPT_DIRSTR:

            //
            // EFS ignore this case.\
            //
            break;

        default:
            break;

    }
    return STATUS_SUCCESS;
}

NTSTATUS
EfsEncryptStream(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext,
        IN OUT PVOID *Context,
        IN OUT PULONG PContextLength
        )
/*++

Routine Description:

    This is an internal support routine. It process the call of
    FSCTL_SET_ENCRYPT for encrypting a stream. It verifies the caller
    and set the key Blob for the stream.

Arguments:

    InputData -- Input data buffer of FSCTL.

    InputDataLength -- The length of input data.

    EncryptionFlag - Indicating if this stream is encrypted or not.

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

    Context -- Blob(key) for READ or WRITE later.

    PContextLength -- Length of the key Blob


Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/
{

    ULONG efsLength;
    ULONG information;
    ULONG bytesSame;
    ULONG dataFlushLength = 0;
    PVOID efsStreamData = NULL;
    PVOID efsKeyBlob = NULL;
    PEFS_KEY    efsKey = NULL;
    NTSTATUS ntStatus;

    PAGED_CODE();

    if ( EncryptionFlag & STREAM_ENCRYPTED ) {

        //
        // Stream already encrypted. 
        //

        return STATUS_SUCCESS;
    }

    if ( *Context ){

        //
        // The key Blob is already set without the bit set first.
        // Not set by EFS
        //

        return STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // [FsData] = FEK, [FEK]sk, $EFS
    //

    if ( !EfsVerifyKeyFsData(
            &(((PFSCTL_INPUT)InputData)->EfsFsData[0]),
            InputDataLength) ){

        //
        // Input data format error
        //

        return STATUS_INVALID_PARAMETER;

    }

    dataFlushLength = 2 * (EFS_KEY_SIZE((PEFS_KEY) &(((PFSCTL_INPUT)InputData)->EfsFsData[0])));

    //
    // Try to read an existing $EFS
    //

    ntStatus = EfsReadEfsData(
                        FileHdl,
                        IrpContext,
                        &efsStreamData,
                        &efsLength,
                        &information
                        );

    if ( EFS_READ_SUCCESSFUL == information ){

        BOOLEAN continueProcess = TRUE;
        ULONG efsOffset;

        efsOffset = GetEfsStreamOffset( InputData );

        if ( 0 == (EncryptionFlag & FILE_ENCRYPTED) ){
            //
            // File is not encrypted, but $EFS exist. Invalid status.
            // May caused by a crash during the SET_ENCRYPT file call.
            //

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            continueProcess = FALSE;

        } else if ( efsLength != ( InputDataLength - efsOffset )) {
            //
            // $EFS stream length does not match
            //

            ntStatus = STATUS_INVALID_PARAMETER;
            continueProcess = FALSE;

        }

        if ( !continueProcess ) {

            RtlSecureZeroMemory(&(((PFSCTL_INPUT)InputData)->EfsFsData[0]), dataFlushLength);
            ExFreePool( efsStreamData );
            return ntStatus;

        }

        //
        // Got the $EFS. Now double check the match of the $EFS stream.
        // EFS use the same $EFS for all the stream within a file.
        // Skip comparing the length and status fields.
        //

        bytesSame = (ULONG)RtlCompareMemory(
                        (PUCHAR)efsStreamData + 2 * sizeof(ULONG),
                        InputData + efsOffset + 2 * sizeof(ULONG),
                        efsLength - 2 * sizeof(ULONG)
                        );

        ExFreePool( efsStreamData );

        if ( bytesSame != efsLength - 2 * sizeof(ULONG) ){

            //
            // The EFS are not the same length
            //

            RtlSecureZeroMemory(&(((PFSCTL_INPUT)InputData)->EfsFsData[0]), dataFlushLength);
            return STATUS_INVALID_PARAMETER;

        }

        efsKey = (PEFS_KEY)&(((PFSCTL_INPUT)InputData)->EfsFsData[0]);
        efsKeyBlob = GetKeyBlobBuffer(efsKey->Algorithm);
        if ( NULL == efsKeyBlob ){
            RtlSecureZeroMemory(efsKey, dataFlushLength);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        if (!SetKeyTable( efsKeyBlob, efsKey )){

            ExFreeToNPagedLookasideList(((PKEY_BLOB)efsKeyBlob)->MemSource, efsKeyBlob);

            //
            // We might be able to return a better error code if needed.
            // This is not in the CreateFile() path.
            //

            RtlSecureZeroMemory(efsKey, dataFlushLength);
            return STATUS_ACCESS_DENIED;
        }

        *Context = efsKeyBlob;
        *PContextLength = ((PKEY_BLOB)efsKeyBlob)->KeyLength;
        RtlSecureZeroMemory(efsKey, dataFlushLength);
        return STATUS_SUCCESS;

    }

    //
    // Try to encrypt a stream but the $EFS is not there.
    // EFS server will always call encrypt on a file first.
    //

    RtlSecureZeroMemory(&(((PFSCTL_INPUT)InputData)->EfsFsData[0]), dataFlushLength);
    return STATUS_INVALID_DEVICE_REQUEST;
}

NTSTATUS
EfsEncryptFile(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext,
        IN OUT PVOID *Context
        )
/*++

Routine Description:

    This is an internal support routine. It process the call of
    FSCTL_SET_ENCRYPT for encrypting a file. It does not deal with
    the stream, it only writes the initial $EFS and put the file in
    a transition status so that no one else can open the file.

Arguments:

    InputData -- Input data buffer of FSCTL.

    InputDataLength -- The length of input data.

    EncryptionFlag - Indicating if this stream is encrypted or not.

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

    Context - BLOB(key) for READ or WRITE later.


Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/
{

    ULONG efsLength;
    ULONG information;
    ULONG efsOffset;
    ULONG dataFlushLength = 0;
    PVOID efsStreamData = NULL;
    PVOID efsKeyBlob = NULL;
    NTSTATUS ntStatus;
    ATTRIBUTE_HANDLE  attribute = NULL;

    PAGED_CODE();

    if ( EncryptionFlag & FILE_ENCRYPTED ){

        //
        // File encrypted.
        //

        return STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // [FsData] = FEK, [FEK]sk, $EFS
    //

    if ( !EfsVerifyKeyFsData(
            &(((PFSCTL_INPUT)InputData)->EfsFsData[0]),
            InputDataLength) ){

        //
        // Input data format error
        //

        return STATUS_INVALID_PARAMETER;

    }

    dataFlushLength = 2 * (EFS_KEY_SIZE((PEFS_KEY) &(((PFSCTL_INPUT)InputData)->EfsFsData[0])));

    //
    // Allocate memory for $EFS
    // Create the $EFS, if there is one, overwrite it.
    //

    efsOffset = GetEfsStreamOffset( InputData );
    efsLength = InputDataLength - efsOffset;

    try {

        ntStatus = NtOfsCreateAttributeEx(
                         IrpContext,
                         FileHdl,
                         EfsData.EfsName,
                         $LOGGED_UTILITY_STREAM,
                         CREATE_NEW,
                         TRUE,
                         &attribute
                         );

#if DBG
    if ( (EFSTRACEALL | EFSTRACELIGHT ) & EFSDebug ){

        DbgPrint( "\n EFSFILTER: Create Attr. Status %x\n", ntStatus );

    }
#endif

        if (NT_SUCCESS(ntStatus)){

            LONGLONG    attriOffset = 0;
            LONGLONG    attriLength = (LONGLONG) efsLength;

            NtOfsSetLength(
                    IrpContext,
                    attribute,
                    attriLength
                    );

            //
            // Write the $EFS with transition status
            //

            *(PULONG)(InputData + efsOffset + sizeof(ULONG)) =
                    EFS_STREAM_TRANSITION;

            NtOfsPutData(
                    IrpContext,
                    attribute,
                    attriOffset,
                    efsLength,
                    InputData + efsOffset
                    );


            NtOfsFlushAttribute (IrpContext, attribute, FALSE);

        }
    } finally {

        if (attribute) {

            NtOfsCloseAttribute(IrpContext, attribute);

        }
    }

    RtlSecureZeroMemory(&(((PFSCTL_INPUT)InputData)->EfsFsData[0]), dataFlushLength);
    return ntStatus;
}

NTSTATUS
EfsDecryptStream(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext,
        IN OUT PVOID *Context,
        IN OUT PULONG PContextLength
        )
/*++

Routine Description:

    This is an internal support routine. It process the call of
    FSCTL_SET_ENCRYPT for decrypting a stream. It sets the key Blob to NULL.

Arguments:

    InputData -- Input data buffer of FSCTL.

    EncryptionFlag - Indicating if this stream is encrypted or not.

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

    Context -- Blob(key) for READ or WRITE later.

    PContextLength -- Length of the key Blob.

Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/

{
    ULONG efsLength;
    ULONG information;
    NTSTATUS ntStatus;

    PAGED_CODE();

    if ( 0 == (EncryptionFlag & STREAM_ENCRYPTED) ) {

        //
        // Stream already decrypted
        //

        return STATUS_SUCCESS;
    }

    if ( 0 == (EncryptionFlag & FILE_ENCRYPTED)){

        //
        // File decrypted but the stream is still encrypted.
        //

        return STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // [FsData] = SessionKey, Handle, Handle, [SessionKey, Handle, Handle]sk
    // Verify the FsData format.
    //

    if (!EfsVerifyGeneralFsData(
                &(((PFSCTL_INPUT)InputData)->EfsFsData[0]),
                InputDataLength)){

        return STATUS_INVALID_PARAMETER;

    }

    RtlSecureZeroMemory(&(((PFSCTL_INPUT)InputData)->EfsFsData[0]), FIELD_OFFSET(GENERAL_FS_DATA, EfsData[0]));
    //
    // Try to read an existing $EFS
    //

    ntStatus = EfsReadEfsData(
                        FileHdl,
                        IrpContext,
                        NULL,
                        &efsLength,
                        &information
                        );

    if ( EFS_READ_SUCCESSFUL == information ){

        //
        // Everything is OK. We do not check user ID here,
        // we suppose that has been checked during the Open path.
        // Clear the key Blob. The caller should flushed this
        // stream before the FSCTL is issued.
        //

        if ( *Context ){
            CheckValidKeyBlock(*Context,"Please contact RobertG if you see this line, efsrtlsp.c.\n");
            FreeMemoryBlock(Context);
            *PContextLength = 0;
        }

        return STATUS_SUCCESS;

    } else if ( ( OPEN_EFS_FAIL == information ) ||
                ( EFS_FORMAT_ERROR == information ) ) {

        //
        // EFS does not exist or not encrypted by the EFS ?
        //

        ntStatus =  STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // Other error while opening $EFS
    //

    return ntStatus;
}

NTSTATUS
EfsDecryptFile(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext
        )
/*++

Routine Description:

    This is an internal support routine. It process the call of
    FSCTL_SET_ENCRYPT for decrypting a file. It deletes the $EFS. NTFS
    will clear the bit if STATUS_SUCCESS returned.

Arguments:

    InputData -- Input data buffer of FSCTL.

    EncryptionFlag - Indicating if this stream is encrypted or not.

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

    Context - BLOB(key) for READ or WRITE later.


Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/

{
    ULONG efsLength;
    ULONG information;
    NTSTATUS ntStatus;

    PAGED_CODE();

    //
    // It is possible to have following situations,
    // File bit set but no $EFS. Crash inside this call last time.
    // File bit not set, $EFS exist. Crash inside EFS_ENCRYPT_FILE.
    //

    //
    // [FsData] = SessionKey, Handle, Handle, [SessionKey, Handle, Handle]sk
    // Verify the FsData format.
    //

    if (!EfsVerifyGeneralFsData(
            &(((PFSCTL_INPUT)InputData)->EfsFsData[0]),
            InputDataLength)){

        return STATUS_INVALID_PARAMETER;

    }

    RtlSecureZeroMemory(&(((PFSCTL_INPUT)InputData)->EfsFsData[0]), FIELD_OFFSET(GENERAL_FS_DATA, EfsData[0]));

    //
    // Try to read an existing $EFS
    //

    ntStatus = EfsReadEfsData(
                        FileHdl,
                        IrpContext,
                        NULL,
                        &efsLength,
                        &information
                        );

    if ( EFS_READ_SUCCESSFUL == information ){

        //
        // Everything is OK.
        //

        return ( EfsDeleteEfsData( FileHdl, IrpContext ) );

    } else if ( OPEN_EFS_FAIL == information ){

        //
        // Bit set, no $EFS. OK, NTFS will clear the bit.
        //

        return STATUS_SUCCESS;

    }

    return STATUS_INVALID_DEVICE_REQUEST;
}

NTSTATUS
EfsEncryptDir(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext
        )
/*++

Routine Description:

    This is an internal support routine. It process the call of
    FSCTL_SET_ENCRYPT for encrypting a directory. It writes initial $EFS.

Arguments:

    InputData -- Input data buffer of FSCTL.

    InputDataLength -- The length of input data.

    EncryptionFlag - Indicating if this stream is encrypted or not.

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

    Context - BLOB(key) for READ or WRITE later.


Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/
{

    ULONG efsLength;
    ULONG information;
    ULONG efsStreamOffset;
    PVOID efsStreamData = NULL;
    PVOID efsKeyBlob = NULL;
    NTSTATUS ntStatus;
    ATTRIBUTE_HANDLE  attribute = NULL;

    PAGED_CODE();

    if ( EncryptionFlag & STREAM_ENCRYPTED ){

        //
        // Dir string already encrypted.
        //

        return STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // [FsData] = SessionKey, Handle, Handle, [SessionKey, Handle, Handle]sk
    // Verify the FsData format.
    //

    if (!EfsVerifyGeneralFsData(
            &(((PFSCTL_INPUT)InputData)->EfsFsData[0]),
            InputDataLength)){

        return STATUS_INVALID_PARAMETER;

    }

    //
    // Allocate memory for $EFS
    // Create the $EFS, if there is one, overwrite it.
    //

    efsStreamOffset = FIELD_OFFSET( FSCTL_INPUT, EfsFsData[0] )
                      + FIELD_OFFSET( GENERAL_FS_DATA, EfsData[0]);

    efsLength = InputDataLength - efsStreamOffset;

    try {

        ntStatus = NtOfsCreateAttributeEx(
                         IrpContext,
                         FileHdl,
                         EfsData.EfsName,
                         $LOGGED_UTILITY_STREAM,
                         CREATE_NEW,
                         TRUE,
                         &attribute
                         );

        if (NT_SUCCESS(ntStatus)){

            LONGLONG    attriOffset = 0;
            LONGLONG    attriLength = (LONGLONG) efsLength;

            NtOfsSetLength(
                    IrpContext,
                    attribute,
                    attriLength
                    );

            //
            // Write the $EFS
            //

            NtOfsPutData(
                    IrpContext,
                    attribute,
                    attriOffset,
                    efsLength,
                    InputData + efsStreamOffset
                    );


            NtOfsFlushAttribute (IrpContext, attribute, FALSE);

        }
    } finally {

        if (attribute) {
            NtOfsCloseAttribute(IrpContext, attribute);
        }
    }

    RtlSecureZeroMemory(&(((PFSCTL_INPUT)InputData)->EfsFsData[0]), FIELD_OFFSET(GENERAL_FS_DATA, EfsData[0]));
    return ntStatus;
}

NTSTATUS
EfsModifyEfsState(
        IN ULONG FunctionCode,
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext
        )
/*++

Routine Description:

    This is an internal support routine. It modifies the state field of $EFS.

Arguments:

    FunctionCode -- EFS private code for FSCTL

    InputData -- Input data buffer of FSCTL.

    FileHdl  -- An object handle to access the attached $EFS.

    IrpContext -- Used in NtOfsCreateAttributeEx().

Return Value:

    Result of the operation.
    The value will be used to return to NTFS.

--*/
{
    NTSTATUS ntStatus;
    ATTRIBUTE_HANDLE  attribute = NULL;

    PAGED_CODE();

    //
    // [FsData] = SessionKey, Handle, Handle, [SessionKey, Handle, Handle]sk
    // Verify the FsData format.
    //

    if (!EfsVerifyGeneralFsData(
            &(((PFSCTL_INPUT)InputData)->EfsFsData[0]),
            InputDataLength)){

        return STATUS_INVALID_PARAMETER;

    }

    try {

        ntStatus = NtOfsCreateAttributeEx(
                         IrpContext,
                         FileHdl,
                         EfsData.EfsName,
                         $LOGGED_UTILITY_STREAM,
                         OPEN_EXISTING,
                         TRUE,
                         &attribute
                         );

        if (NT_SUCCESS(ntStatus)){

            ULONG   efsStatus = EFS_STREAM_NORMAL;

            if ( EFS_DECRYPT_BEGIN == FunctionCode ){

                 efsStatus = EFS_STREAM_TRANSITION;

            }

            //
            // Modify the status
            //

            NtOfsPutData(
                    IrpContext,
                    attribute,
                    (LONGLONG) &((( EFS_STREAM * ) 0)->Status),
                    sizeof( efsStatus ),
                    &efsStatus
                    );

            NtOfsFlushAttribute (IrpContext, attribute, FALSE);

        }
    } finally {

        if (attribute) {
            NtOfsCloseAttribute(IrpContext, attribute);
        }
    }

    return ntStatus;
}

ULONG
GetEfsStreamOffset(
        IN PUCHAR InputData
        )
/*++

Routine Description:

    This is an internal support routine. It calculates the offset of $EFS.

Arguments:

    InputData -- Input data buffer of FSCTL.
                 The format is always PSC, EfsCode, CSC, FEK, FEK, $EFS

Return Value:

    The offset of $EFS in InputData.

--*/
{

    ULONG efsOffset;

    efsOffset = FIELD_OFFSET( FSCTL_INPUT, EfsFsData[0]);
    efsOffset += 2 * EFS_KEY_SIZE( ((PEFS_KEY)(InputData + efsOffset)) );
    return efsOffset;

}

NTSTATUS
SetEfsData(
    PUCHAR InputData,
    IN ULONG InputDataLength,
    IN ULONG SystemState,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID *PContext,
    IN OUT PULONG PContextLength
    )
/*++

Routine Description:

    This is an internal support routine. It sets the $EFS to the file.

Arguments:

    InputData -- Input data buffer of FSCTL.

    InputDataLength -- Input data length.

    FileHdl -- Used to access the $EFS.

    IrpContext -- Used to access the $EFS.

    PContext -- BLOB(key) for READ or WRITE later.

    PContextLength - The length of the context.

Return Value:

    STATUS_SUCCESS or NT error
    InputData block will be zeroed by the caller.

--*/
{

    ULONG bytesSame;
    ULONG efsLength;
    PVOID efsStreamData = NULL;
    PVOID efsKeyBlob = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ATTRIBUTE_HANDLE  attribute = NULL;
    PEFS_KEY    efsKey;
    PNPAGED_LOOKASIDE_LIST tmpMemSrc;

    PAGED_CODE();

    if ( ((PFSCTL_INPUT)InputData)->CipherSubCode & SET_EFS_KEYBLOB ){

        //
        // Set the key blob is required
        //

        efsKey = (PEFS_KEY) &(((PFSCTL_INPUT)InputData)->EfsFsData[0]);
        efsKeyBlob = GetKeyBlobBuffer(efsKey->Algorithm);
        if ( NULL == efsKeyBlob ){

            return STATUS_INSUFFICIENT_RESOURCES;

        }

        if (!SetKeyTable(
                efsKeyBlob,
                (PEFS_KEY) &(((PFSCTL_INPUT)InputData)->EfsFsData[0])
                )){

            ExFreeToNPagedLookasideList(((PKEY_BLOB)efsKeyBlob)->MemSource, efsKeyBlob);
            return STATUS_ACCESS_DENIED;
        }

        if ( (((PFSCTL_INPUT)InputData)->EfsFsCode == EFS_SET_ATTRIBUTE ) &&
             *PContext ){

            bytesSame = (ULONG)RtlCompareMemory(
                             efsKeyBlob,
                             *PContext,
                             ((PKEY_BLOB)efsKeyBlob)->KeyLength
                            );

            RtlSecureZeroMemory(&(((PKEY_BLOB) efsKeyBlob)->Key[0]), 
                                ((PKEY_BLOB) efsKeyBlob)->KeyLength - KEYBLOB_HEAD_LENGTH
                                );
            ExFreeToNPagedLookasideList(((PKEY_BLOB)efsKeyBlob)->MemSource, efsKeyBlob);
            efsKeyBlob = NULL;

            if ( bytesSame != ((PKEY_BLOB)(*PContext))->KeyLength ) {

                //
                // The new key blob is not the same one as in the memory
                //

                return STATUS_INVALID_PARAMETER;

            }

        }

        //
        // Defer the setting of key blob until the $EFS is written
        // successfully.
        //

    }

    if ( ((PFSCTL_INPUT)InputData)->CipherSubCode & WRITE_EFS_ATTRIBUTE ){

        //
        // Write $EFS is required. Either create or overwrite the EFS
        //
        ULONG efsOffset;

        if (SystemState & SYSTEM_IS_READONLY) {
            if ( efsKeyBlob ){

                RtlSecureZeroMemory(&(((PKEY_BLOB) efsKeyBlob)->Key[0]), 
                                    ((PKEY_BLOB) efsKeyBlob)->KeyLength - KEYBLOB_HEAD_LENGTH
                                    );
                ExFreeToNPagedLookasideList(((PKEY_BLOB)efsKeyBlob)->MemSource, efsKeyBlob);

            }
            return STATUS_MEDIA_WRITE_PROTECTED;
        }

        if ( (((PFSCTL_INPUT)InputData)->EfsFsCode == EFS_SET_ATTRIBUTE ) ||
             (((PFSCTL_INPUT)InputData)->CipherSubCode & SET_EFS_KEYBLOB) ){

            efsOffset = GetEfsStreamOffset( InputData );

        } else {

            efsOffset = COMMON_FSCTL_HEADER_SIZE;

        }

        efsLength = InputDataLength - efsOffset;

        try {

            ntStatus = NtOfsCreateAttributeEx(
                             IrpContext,
                             FileHdl,
                             EfsData.EfsName,
                             $LOGGED_UTILITY_STREAM,
                             CREATE_OR_OPEN,
                             TRUE,
                             &attribute
                             );

            if (NT_SUCCESS(ntStatus)){

                LONGLONG    attriOffset = 0;
                LONGLONG    attriLength = (LONGLONG) efsLength;

                NtOfsSetLength(
                        IrpContext,
                        attribute,
                        attriLength
                        );

                NtOfsPutData(
                        IrpContext,
                        attribute,
                        attriOffset,
                        efsLength,
                        InputData + efsOffset
                        );


                NtOfsFlushAttribute (IrpContext, attribute, FALSE);

            } else {

                //
                // Create or Open $EFS fail
                //

                if ( efsKeyBlob ){

                    RtlSecureZeroMemory(&(((PKEY_BLOB) efsKeyBlob)->Key[0]), 
                                        ((PKEY_BLOB) efsKeyBlob)->KeyLength - KEYBLOB_HEAD_LENGTH
                                        );
                    ExFreeToNPagedLookasideList(((PKEY_BLOB)efsKeyBlob)->MemSource, efsKeyBlob);
                    efsKeyBlob = NULL;

                }

                leave;

            }
        } finally {

            if (AbnormalTermination()) {

                if ( efsKeyBlob ){
    
                    RtlSecureZeroMemory(&(((PKEY_BLOB) efsKeyBlob)->Key[0]), 
                                        ((PKEY_BLOB) efsKeyBlob)->KeyLength - KEYBLOB_HEAD_LENGTH
                                        );
                    ExFreeToNPagedLookasideList(((PKEY_BLOB)efsKeyBlob)->MemSource, efsKeyBlob);
                    efsKeyBlob = NULL;
    
                }

            }

            if (attribute) {

                NtOfsCloseAttribute(IrpContext, attribute);

            }
        }

    }

    if ( efsKeyBlob && (((PFSCTL_INPUT)InputData)->CipherSubCode & SET_EFS_KEYBLOB) ){

        if ( (((PFSCTL_INPUT)InputData)->EfsFsCode == EFS_SET_ATTRIBUTE ) &&
             ( *PContext == NULL ) ){

            //
            // Set the key blob
            //

            *PContext = efsKeyBlob;
            *PContextLength = ((PKEY_BLOB) efsKeyBlob)->KeyLength;

        } else if ( ((PFSCTL_INPUT)InputData)->EfsFsCode == EFS_OVERWRITE_ATTRIBUTE ) {

            //
            // Overwrite the key blob for legal import user
            //

            if ( *PContext == NULL){

                //
                //  The file was not encrypted
                //

                *PContext = efsKeyBlob;
                *PContextLength = ((PKEY_BLOB) efsKeyBlob)->KeyLength;

            } else {

                if ( ((PKEY_BLOB) efsKeyBlob)->KeyLength <= *PContextLength ){

                    tmpMemSrc = ((PKEY_BLOB)(*PContext))->MemSource;
                    RtlCopyMemory( *PContext, efsKeyBlob, ((PKEY_BLOB) efsKeyBlob)->KeyLength );
                    ((PKEY_BLOB)(*PContext))->MemSource = tmpMemSrc;

                    //
                    // Keep the original buffer length
                    //
                    if (((PKEY_BLOB) efsKeyBlob)->KeyLength < *PContextLength) {
                        ((PKEY_BLOB)(*PContext))->KeyLength = *PContextLength;
                        RtlZeroMemory((UCHAR *)(*PContext) + ((PKEY_BLOB) efsKeyBlob)->KeyLength,
                                      *PContextLength - ((PKEY_BLOB) efsKeyBlob)->KeyLength); 
                    }

                    
                }  else{

                    //
                    // We could not swap the key blob because the old blob might be in use. Deleting
                    // the old blob could bug check the system.
                    // This could be avoid if MaximumBlob is defined nonzero in the registry.
                    //

                    ntStatus = STATUS_EFS_ALG_BLOB_TOO_BIG;
                }

                //
                // Zero the key table
                //

                RtlSecureZeroMemory(&(((PKEY_BLOB) efsKeyBlob)->Key[0]), 
                                    ((PKEY_BLOB) efsKeyBlob)->KeyLength - KEYBLOB_HEAD_LENGTH
                                    );

                ExFreeToNPagedLookasideList(((PKEY_BLOB)efsKeyBlob)->MemSource, efsKeyBlob);

            }
       }

    }

    return ntStatus;
}

BOOLEAN
EfsFindInCache(
    IN GUID   *EfsId,
    IN PTOKEN_USER    UserId
    )
/*++

Routine Description:

    This routine will try to find the information in open cache.

Arguments:

    EfsId - $EFS ID.
    UserId - User ID

Return Value:

    TRUE, if match found in the cache and the time is not expired. ( 5 second )

--*/
{
    PLIST_ENTRY pListHead, pLink;
    POPEN_CACHE pOpenCache;
    LARGE_INTEGER crntTime;
    PSID    UserSid;

    PAGED_CODE();

    UserSid = UserId->User.Sid;
    KeQuerySystemTime( &crntTime );

    ExAcquireFastMutex( &(EfsData.EfsOpenCacheMutex) );

    if ( EfsData.EfsOpenCacheList.Flink == &(EfsData.EfsOpenCacheList) ) {

        //
        // list empty
        //

        ExReleaseFastMutex(  &(EfsData.EfsOpenCacheMutex)  );
        return FALSE;
    }
    for (pLink = EfsData.EfsOpenCacheList.Flink; pLink != &(EfsData.EfsOpenCacheList); pLink = pLink->Flink) {
        pOpenCache = CONTAINING_RECORD(pLink, OPEN_CACHE, CacheChain);

        ASSERT( pLink );
        ASSERT( pLink->Flink );

        if ( !memcmp( &(pOpenCache->EfsId), EfsId, sizeof(GUID)) &&
            (crntTime.QuadPart - pOpenCache->TimeStamp.QuadPart <= EfsData.EfsDriverCacheLength )  &&
            RtlEqualSid ( UserSid, pOpenCache->UserId->User.Sid)
             ) {

            ExReleaseFastMutex(  &(EfsData.EfsOpenCacheMutex)  );
            return TRUE;
        }

    }
    ExReleaseFastMutex(  &(EfsData.EfsOpenCacheMutex)  );

    return FALSE;
}

NTSTATUS
EfsRefreshCache(
    IN GUID   *EfsId,
    IN PTOKEN_USER    UserId
    )
/*++

Routine Description:

    This routine will set the latest open information in open cache. It will
    delete the the obsolete info. Cache is refreshed.

Arguments:

    EfsId - $EFS ID.
    UserId - User ID

Return Value:

    STATUS_SUCCESS if succeed.

--*/
{
    PLIST_ENTRY pListHead, pLink;
    POPEN_CACHE pOpenCache, pTmpCache;
    LARGE_INTEGER crntTime;

    KeQuerySystemTime( &crntTime );

    pOpenCache =   (POPEN_CACHE)ExAllocateFromPagedLookasideList(&(EfsData.EfsOpenCachePool));
    if ( NULL == pOpenCache){
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Init the node
    //

    RtlZeroMemory( pOpenCache, sizeof( OPEN_CACHE ) );
    RtlCopyMemory(  &(pOpenCache->EfsId), EfsId, sizeof( GUID ) );
    pOpenCache->UserId = UserId;
    pOpenCache->TimeStamp.QuadPart =  crntTime.QuadPart;

    ExAcquireFastMutex( &(EfsData.EfsOpenCacheMutex) );

    if ( EfsData.EfsOpenCacheList.Flink == &(EfsData.EfsOpenCacheList) ) {

        //
        // list empty
        //

        InsertHeadList(&( EfsData.EfsOpenCacheList ), &( pOpenCache->CacheChain ));

    } else {

        //
        // Search for expired one
        //

        pLink = EfsData.EfsOpenCacheList.Flink;
        while ( pLink != &(EfsData.EfsOpenCacheList) ){

            pTmpCache = CONTAINING_RECORD(pLink, OPEN_CACHE, CacheChain);

            ASSERT( pLink );
            ASSERT( pLink->Flink );

            pLink = pLink->Flink;
            if ( ( (crntTime.QuadPart - pTmpCache->TimeStamp.QuadPart) > EfsData.EfsDriverCacheLength ) ||
                !memcmp( &(pTmpCache->EfsId), EfsId, sizeof(GUID))
               ){

                //
                // Expired node. Delete it.
                //

                RemoveEntryList(&( pTmpCache->CacheChain ));
                ExFreePool( pTmpCache->UserId );
                ExFreeToPagedLookasideList(&(EfsData.EfsOpenCachePool), pTmpCache );

            }
        }

        InsertHeadList(&( EfsData.EfsOpenCacheList ), &( pOpenCache->CacheChain ));
    }

    ExReleaseFastMutex(  &(EfsData.EfsOpenCacheMutex)  );
    return STATUS_SUCCESS;
}

BOOLEAN
SkipCheckStream(
    IN PIO_STACK_LOCATION IrpSp,
    IN PVOID efsStreamData
    )
/*++

Routine Description:

    This routine will check if the related default data stream has just been opened
    or not.

Arguments:

    EfsId - $EFS ID.
    UserId - User ID

Return Value:

    TRUE if succeed.

--*/
{
    BOOLEAN     bRet = TRUE;
    PACCESS_TOKEN accessToken;
    NTSTATUS status;
    PTOKEN_USER UserId;

    PAGED_CODE();

    if ( IrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken ){
        accessToken = IrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.ClientToken;
    } else {
        accessToken = IrpSp->Parameters.Create.SecurityContext->AccessState->SubjectSecurityContext.PrimaryToken;
    }

    if (accessToken) {

        //
        // Get User ID
        //

        status = SeQueryInformationToken(
                    accessToken,
                    TokenUser,
                    &UserId
                    );

        if ( NT_SUCCESS(status) ){

            if ( EfsFindInCache(
                    &((( PEFS_DATA_STREAM_HEADER ) efsStreamData)->EfsId),
                    UserId
                    )) {

                bRet = TRUE;

            } else {

                bRet = FALSE;

            }

            ExFreePool( UserId );
        }
    } else {
        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\efs\efsrtl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Abstract:

   This module contains the common header information for the EFS

   DLL.

Author:

   Robert Gu (robertg)  08-Dec-1996

Enviroment:

   Kernel Mode Only

Revision History:

--*/
#ifndef EFSRTL_H
#define EFSRTL_H

#include "efs.h"
#include "efsext.h"

#define EFS_IV 0x169119629891ad13
#define EFS_AES_IVL 0x5816657be9161312
#define EFS_AES_IVH 0x1989adbe44918961


//#define ENCRYPT 0
//#define DECRYPT 1
#define CHUNK_SIZE  512
#define EFS_MAX_LENGTH  256*1024

//
// Status of EFS context.
//
// Processing Status
//


#define NO_FURTHER_PROCESSING   0x00000000
#define NEW_FILE_EFS_REQUIRED     0x00000001
#define NEW_DIR_EFS_REQUIRED      0x00000002
#define VERIFY_USER_REQUIRED       0x00000004
#define TURN_ON_BIT_ONLY               0x00000008
#define NO_OPEN_CACHE_CHECK       0x40000000
#define TURN_ON_ENCRYPTION_BIT   0x80000000
#define ACTION_REQUIRED         0x0fffffff

//
//
//

#define SYSTEM_IS_READONLY     0x00000001

//
// Error Status
//

#define CREATE_EFS_FAIL         0x00000100
#define OPEN_EFS_FAIL           0x00000200
#define WRITE_EFS_FAIL          0x00000400
#define OUT_OF_MEMORY           0x00000800
#define EFS_FORMAT_ERROR        0x00001000
#define NTOFS_EXCEPTION         0x00002000

//
// Information Status
//

#define EFS_READ_SUCCESSFUL     0x00010000

//
// Stream Create Status
//

#define STRING_NEW_OR_EXIST_MASK  0x000f0000
#define FILE_DIR_TYPE             0x0000000f

#define FILE_NEW                0x00000001
#define FILE_EXISTING           0x00000002
#define DIRECTORY_NEW           0x00000004
#define DIRECTORY_EXISTING      0x00000008
#define STREAM_NEW              0x00010000
#define STREAM_EXISTING         0x00020000

//
// Encryption flag
//

#define FILE_ENCRYPTED          0x00000002
#define STREAM_ENCRYPTED        0x00000001


//
// The EFS FSCTL Input data buffer.
//

typedef struct _FSCTL_INPUT {

    ULONG   PlainSubCode;
    ULONG   EfsFsCode;
    ULONG   CipherSubCode;
    UCHAR   EfsFsData[1];

} FSCTL_INPUT, *PFSCTL_INPUT;

typedef struct _GENERAL_FS_DATA {

    UCHAR   Sk1[DES_KEYSIZE];
    ULONG   Hdl1;
    ULONG   Hdl2;
    UCHAR   Sk2[DES_KEYSIZE];
    ULONG   Hdl3;
    ULONG   Hdl4;
    UCHAR   EfsData[1];

} GENERAL_FS_DATA, *PGENERAL_FS_DATA;

typedef struct _EFS_STREAM {

    ULONG   Length;
    ULONG   Status;
    UCHAR   Private[1];

} EFS_STREAM, *PEFS_STREAM;

//
// Function prototypes
//

typedef VOID ( * EfsEncFunc)(
        IN PUCHAR   InBuffer,
        OUT PUCHAR  OutBuffer,
        IN PUCHAR   IV,
        IN PKEY_BLOB   KeyBlob,
        IN LONG     Length
        );

typedef VOID ( * EfsDecFunc)(
        IN OUT PUCHAR   Buffer,
        IN PUCHAR   IV,
        IN PKEY_BLOB   KeyBlob,
        IN LONG     Length
        );

VOID
EFSDesEnc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EFSDesDec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EFSDesXEnc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EFSDesXDec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EFSDes3Enc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EFSDes3Dec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EFSAesEnc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EFSAesDec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    );

VOID
EfsEncryptKeyFsData(
    IN PVOID DataBuffer,
    IN ULONG DataLength,
    IN ULONG DataEncOffset,
    IN ULONG RefdataEncOffset,
    IN ULONG RefdataEncLength
    );

NTSTATUS
EfsOpenFile(
    IN OBJECT_HANDLE FileHdl,
    IN OBJECT_HANDLE ParentDir OPTIONAL,
    IN PIO_STACK_LOCATION IrpSp,
    IN ULONG FileDirFlag,
    IN ULONG SystemState,
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT VolDo,
    IN PVOID PfileKeyContext,
    IN OUT PVOID *PContext,
    IN OUT PULONG PContextLength,
    IN OUT PVOID *PCreateContext,
    IN OUT PBOOLEAN Reserved
    );

NTSTATUS
EfsFileControl(
    IN PVOID PInputBuffer,
    IN ULONG InputDataLength,
    OUT PVOID POutputBuffer OPTIONAL,
    IN OUT PULONG OutputBufferLength,
    IN ULONG EncryptionFlag,
    IN ULONG AccessFlag,
    IN ULONG SystemState,
    IN ULONG FsControlCode,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT VolDo,
    IN ATTRIBUTE_HANDLE Stream,
    IN OUT PVOID *PContext,
    IN OUT PULONG PContextLength
    );

NTSTATUS
EfsRead(
    IN OUT PUCHAR Buffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PVOID Context
    );

NTSTATUS
EfsWrite(
    IN PUCHAR InBuffer, //Do we need in and out buffer?
    OUT PUCHAR OutBuffer,
    IN PLARGE_INTEGER Offset,
    IN ULONG BufferSize,
    IN PUCHAR Context
    );

VOID
EfsFreeContext(
    IN OUT PVOID *PContext
    );

NTSTATUS
EfsMountVolumn(
    IN PDEVICE_OBJECT VolDo,
    IN PDEVICE_OBJECT RealDevice
    );

VOID
EfsDismountVolumn(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
EfsReadEfsData(
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    OUT PVOID   *EfsStreamData,
    OUT PULONG   PEfsStreamLength,
    OUT PULONG Information
    );

BOOLEAN
EfsVerifyGeneralFsData(
    IN PUCHAR DataOffset,
    IN ULONG InputDataLength
    );

BOOLEAN
EfsVerifyKeyFsData(
    IN PUCHAR DataOffset,
    IN ULONG InputDataLength
    );

NTSTATUS
EfsDeleteEfsData(
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
EfsSetEncrypt(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext,
        IN OUT PVOID *Context,
        IN OUT PULONG PContextLength
        );

NTSTATUS
EfsEncryptStream(
    IN PUCHAR InputData,
    IN ULONG InputDataLength,
    IN ULONG EncryptionFlag,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID *Context,
    IN OUT PULONG PContextLength
    );

NTSTATUS
EfsEncryptFile(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext,
        IN OUT PVOID *Context
        );

NTSTATUS
EfsDecryptStream(
    IN PUCHAR InputData,
    IN ULONG InputDataLength,
    IN ULONG EncryptionFlag,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID *Context,
    IN OUT PULONG PContextLength
    );

NTSTATUS
EfsDecryptFile(
    IN PUCHAR InputData,
    IN ULONG InputDataLength,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext
    );

NTSTATUS
EfsEncryptDir(
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN ULONG EncryptionFlag,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext
        );

NTSTATUS
EfsModifyEfsState(
        IN ULONG FunctionCode,
        IN PUCHAR InputData,
        IN ULONG InputDataLength,
        IN OBJECT_HANDLE FileHdl,
        IN PIRP_CONTEXT IrpContext
        );

ULONG
GetEfsStreamOffset(
        IN PUCHAR InputData
        );

NTSTATUS
SetEfsData(
    PUCHAR InputData,
    IN ULONG InputDataLength,
    IN ULONG SystemState,
    IN OBJECT_HANDLE FileHdl,
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVOID *PContext,
    IN OUT PULONG PContextLength
    );

BOOLEAN
EfsFindInCache(
    IN GUID   *EfsId,
    IN PTOKEN_USER    UserId
    );

NTSTATUS
EfsRefreshCache(
    IN GUID   *EfsId,
    IN PTOKEN_USER    UserId
    );

BOOLEAN
SkipCheckStream(
    IN PIO_STACK_LOCATION IrpSp,
    IN PVOID efsStreamData
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\efs\encrypt.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   encrypt.c

Abstract:

   This module will support data encryption and decryption

Author:

    Robert Gu (robertg) 08-Dec-1996
Environment:

   Kernel Mode Only

Revision History:

--*/


#include "efsrtl.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, EFSDesEnc)
#pragma alloc_text(PAGE, EFSDesDec)
#pragma alloc_text(PAGE, EFSDesXEnc)
#pragma alloc_text(PAGE, EFSDesXDec)
#pragma alloc_text(PAGE, EFSDes3Enc)
#pragma alloc_text(PAGE, EFSDes3Dec)
#pragma alloc_text(PAGE, EFSAesEnc)
#pragma alloc_text(PAGE, EFSAesDec)
#endif


VOID
EFSDesEnc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements DES CBC encryption. The DES is implemented by LIB
    function des().

Arguments:

    InBuffer - Pointer to the data buffer (encryption in place)
    IV - Initial chaining vector (DES_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % DES_BLOCKLEN = 0)

Note:

    Input buffer can only be touched once. This the requirement by the Ntfs & CC.

--*/
{
    ULONGLONG chainBlock;
    ULONGLONG tmpData;
    PUCHAR   KeyTable;

    PAGED_CODE();

    ASSERT (Length % DES_BLOCKLEN == 0);

    chainBlock = *(ULONGLONG *)IV;
    KeyTable = &(KeyBlob->Key[0]);
    while (Length > 0){

        //
        //  Block chaining
        //
        tmpData = *(ULONGLONG *)InBuffer;
        tmpData ^= chainBlock;

        //
        //  Call DES LIB to encrypt the DES_BLOCKLEN bytes
        //  We are using DECRYPT/ENCRYPT for real ENCRYPT/DECRYPT. This is for the backward
        //  compatiblity. The old definitions were reversed.
        //

        des( OutBuffer, (PUCHAR) &tmpData,  KeyTable, DECRYPT );
        chainBlock = *(ULONGLONG *)OutBuffer;
        Length -= DES_BLOCKLEN;
        InBuffer += DES_BLOCKLEN;
        OutBuffer += DES_BLOCKLEN;
    }
}

VOID
EFSDesDec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements DES CBC decryption. The DES is implemented by LIB
    function des().

Arguments:

    Buffer - Pointer to the data buffer (decryption in place)
    IV - Initial chaining vector (DES_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % DES_BLOCKLEN = 0)

--*/
{
    ULONGLONG chainBlock;
    PUCHAR  pBuffer;
    PUCHAR   KeyTable;

    PAGED_CODE();

    ASSERT (Length % DES_BLOCKLEN == 0);

    pBuffer = Buffer + Length - DES_BLOCKLEN;
    KeyTable = &(KeyBlob->Key[0]);

    while (pBuffer > Buffer){

        //
        //  Call DES LIB to decrypt the DES_BLOCKLEN bytes
        //  We are using DECRYPT/ENCRYPT for real ENCRYPT/DECRYPT. This is for the backward
        //  compatiblity. The old definitions were reversed.
        //

        des( pBuffer, pBuffer, KeyTable, ENCRYPT );

        //
        //  Undo the block chaining
        //

        chainBlock = *(ULONGLONG *)( pBuffer - DES_BLOCKLEN );
        *(ULONGLONG *)pBuffer ^= chainBlock;

        pBuffer -= DES_BLOCKLEN;
    }

    //
    // Now decrypt the first block
    //
    des( pBuffer, pBuffer, KeyTable, ENCRYPT );

    chainBlock = *(ULONGLONG *)IV;
    *(ULONGLONG *)pBuffer ^= chainBlock;
}

VOID
EFSDesXEnc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements DESX CBC encryption. The DESX is implemented by
    LIBRARY function desx().

Arguments:

    InBuffer - Pointer to the data buffer (encryption in place)
    IV - Initial chaining vector (DESX_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % DESX_BLOCKLEN = 0)

Note:

    Input buffer can only be touched once. This the requirement by the Ntfs & CC.

--*/
{
    ULONGLONG chainBlock;
    ULONGLONG tmpData;
    PUCHAR   KeyTable;

    PAGED_CODE();

    ASSERT (Length % DESX_BLOCKLEN == 0);

    chainBlock = *(ULONGLONG *)IV;
    KeyTable = &(KeyBlob->Key[0]);
    while (Length > 0){

        //
        //  Block chaining
        //
        tmpData = *(ULONGLONG *)InBuffer;
        tmpData ^= chainBlock;

        //
        //  Call LIB to encrypt the DESX_BLOCKLEN bytes
        //  We are using DECRYPT/ENCRYPT for real ENCRYPT/DECRYPT. This is for the backward
        //  compatiblity. The old definitions were reversed.
        //

        desx( OutBuffer, (PUCHAR) &tmpData,  KeyTable, DECRYPT );
        chainBlock = *(ULONGLONG *)OutBuffer;
        Length -= DESX_BLOCKLEN;
        InBuffer += DESX_BLOCKLEN;
        OutBuffer += DESX_BLOCKLEN;
    }
}

VOID
EFSDesXDec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements DESX CBC decryption. The DESX is implemented by
    LIBRARY function desx().

Arguments:

    Buffer - Pointer to the data buffer (decryption in place)
    IV - Initial chaining vector (DESX_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % DESX_BLOCKLEN = 0)

--*/
{
    ULONGLONG chainBlock;
    PUCHAR  pBuffer;
    PUCHAR   KeyTable;

    PAGED_CODE();

    ASSERT (Length % DESX_BLOCKLEN == 0);

    pBuffer = Buffer + Length - DESX_BLOCKLEN;
    KeyTable = &(KeyBlob->Key[0]);

    while (pBuffer > Buffer){

        //
        //  Call LIB to decrypt the DESX_BLOCKLEN bytes
        //  We are using DECRYPT/ENCRYPT for real ENCRYPT/DECRYPT. This is for the backward
        //  compatiblity. The old definitions were reversed.
        //

        desx( pBuffer, pBuffer, KeyTable, ENCRYPT );

        //
        //  Undo the block chaining
        //

        chainBlock = *(ULONGLONG *)( pBuffer - DESX_BLOCKLEN );
        *(ULONGLONG *)pBuffer ^= chainBlock;

        pBuffer -= DESX_BLOCKLEN;
    }

    //
    // Now decrypt the first block
    //
    desx( pBuffer, pBuffer, KeyTable, ENCRYPT );

    chainBlock = *(ULONGLONG *)IV;
    *(ULONGLONG *)pBuffer ^= chainBlock;
}

VOID
EFSDes3Enc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements DES3 CBC encryption. The DES3 is implemented by 
    LIBRARY function tripledes().

Arguments:

    InBuffer - Pointer to the data buffer (encryption in place)
    IV - Initial chaining vector (DES_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % DES_BLOCKLEN = 0)

Note:

    Input buffer can only be touched once. This the requirement by the Ntfs & CC.

--*/
{
    ULONGLONG chainBlock = *(ULONGLONG *)IV;
    ULONGLONG tmpData;
    PUCHAR   KeyTable;
   
    ASSERT (Length % DES_BLOCKLEN == 0);

    EfsData.FipsFunctionTable.FipsBlockCBC(        
        FIPS_CBC_3DES, 
        OutBuffer, 
        InBuffer,
        Length,
        &(KeyBlob->Key[0]), 
        ENCRYPT, 
        (PUCHAR) &chainBlock 
        );
}

VOID
EFSDes3Dec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements DES3 CBC decryption. The DES3 is implemented by 
    LIBRARY function tripledes().

Arguments:

    Buffer - Pointer to the data buffer (decryption in place)
    IV - Initial chaining vector (DES_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % DES_BLOCKLEN = 0)

--*/
{
    ULONGLONG ChainIV = *(ULONGLONG *)IV;
   
    ASSERT (Length % DESX_BLOCKLEN == 0);


    EfsData.FipsFunctionTable.FipsBlockCBC( 
        FIPS_CBC_3DES, 
        Buffer, 
        Buffer, 
        Length, 
        &(KeyBlob->Key[0]), 
        DECRYPT, 
        (PUCHAR) &ChainIV 
        );

}


VOID
EFSAesEnc(
    IN PUCHAR   InBuffer,
    OUT PUCHAR  OutBuffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements AES CBC encryption. The AES is implemented by
    LIBRARY function aes().

Arguments:

    InBuffer - Pointer to the data buffer (encryption in place)
    IV - Initial chaining vector (AES_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % AES_BLOCKLEN = 0)

Note:

    Input buffer can only be touched once. This the requirement by the Ntfs & CC.

--*/
{
    ULONGLONG chainBlock[2];
    ULONGLONG tmpData[2];
    PUCHAR   KeyTable;

    PAGED_CODE();

    ASSERT (Length % AES_BLOCKLEN == 0);

    chainBlock[0] = *(ULONGLONG *)IV;
    chainBlock[1] = *(ULONGLONG *)(IV+sizeof(ULONGLONG));
    KeyTable = &(KeyBlob->Key[0]);
    
    while (Length > 0){

        //
        //  Block chaining
        //
        tmpData[0] = *(ULONGLONG *)InBuffer;
        tmpData[1] = *(ULONGLONG *)(InBuffer+sizeof(ULONGLONG));
        tmpData[0] ^= chainBlock[0];
        tmpData[1] ^= chainBlock[1];

        aes256( OutBuffer, (PUCHAR) &tmpData[0],  KeyTable, ENCRYPT );

        chainBlock[0] = *(ULONGLONG *)OutBuffer;
        chainBlock[1] = *(ULONGLONG *)(OutBuffer+sizeof(ULONGLONG));
        Length -= AES_BLOCKLEN;
        InBuffer += AES_BLOCKLEN;
        OutBuffer += AES_BLOCKLEN;
    }
}

VOID
EFSAesDec(
    IN OUT PUCHAR   Buffer,
    IN PUCHAR   IV,
    IN PKEY_BLOB   KeyBlob,
    IN LONG     Length
    )
/*++

Routine Description:

    This routine implements DESX CBC decryption. The DESX is implemented by
    LIBRARY function desx().

Arguments:

    Buffer - Pointer to the data buffer (decryption in place)
    IV - Initial chaining vector (AES_BLOCKLEN bytes)
    KeyBlob - Set during the create or FSCTL
    Length - Length of the data in the buffer ( Length % AES_BLOCKLEN = 0)

--*/
{
    ULONGLONG chainBlock[2];
    PUCHAR  pBuffer;
    PUCHAR   KeyTable;

    PAGED_CODE();

    ASSERT (Length % AES_BLOCKLEN == 0);

    pBuffer = Buffer + Length - AES_BLOCKLEN;
    KeyTable = &(KeyBlob->Key[0]);

    while (pBuffer > Buffer){

        aes256( pBuffer, pBuffer, KeyTable, DECRYPT );


        //
        //  Undo the block chaining
        //

        chainBlock[0] = *(ULONGLONG *)( pBuffer - AES_BLOCKLEN );
        chainBlock[1] = *(ULONGLONG *)(pBuffer - sizeof(ULONGLONG));
        *(ULONGLONG *)pBuffer ^= chainBlock[0];
        *(ULONGLONG *)(pBuffer+sizeof(ULONGLONG)) ^= chainBlock[1];
        pBuffer -= AES_BLOCKLEN;
    }

    //
    // Now decrypt the first block
    //
    aes256( pBuffer, pBuffer, KeyTable, DECRYPT );

    *(ULONGLONG *)pBuffer ^= *(ULONGLONG *)IV;
    *(ULONGLONG *)(pBuffer+sizeof(ULONGLONG)) ^= *(ULONGLONG *)(IV+sizeof(ULONGLONG));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fastfat\acchksup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    AcChkSup.c

Abstract:

    This module implements the FAT access checking routine

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    12-Jun-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  Our debug trace level
//

#define Dbg                              (DEBUG_TRACE_ACCHKSUP)

NTSTATUS
FatCreateRestrictEveryoneToken(
    IN PACCESS_TOKEN Token,
    OUT PACCESS_TOKEN *RestrictedToken
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCheckFileAccess)
#pragma alloc_text(PAGE, FatCreateRestrictEveryoneToken)
#pragma alloc_text(PAGE, FatExplicitDeviceAccessGranted)
#endif


BOOLEAN
FatCheckFileAccess (
    PIRP_CONTEXT IrpContext,
    IN UCHAR DirentAttributes,
    IN PACCESS_MASK DesiredAccess
    )

/*++

Routine Description:

    This routine checks if a desired access is allowed to a file represented
    by the specified DirentAttriubutes.

Arguments:

    DirentAttributes - Supplies the Dirent attributes to check access for

    DesiredAccess - Supplies the desired access mask that we are checking for

Return Value:

    BOOLEAN - TRUE if access is allowed and FALSE otherwise

--*/

{
    BOOLEAN Result;

    DebugTrace(+1, Dbg, "FatCheckFileAccess\n", 0);
    DebugTrace( 0, Dbg, "DirentAttributes = %8lx\n", DirentAttributes);
    DebugTrace( 0, Dbg, "DesiredAccess    = %8lx\n", *DesiredAccess);

    //
    //  This procedures is programmed like a string of filters each
    //  filter checks to see if some access is allowed,  if it is not allowed
    //  the filter return FALSE to the user without further checks otherwise
    //  it moves on to the next filter.  The filter check is to check for
    //  desired access flags that are not allowed for a particular dirent
    //

    Result = TRUE;

    try {

        //
        //  Check for Volume ID or Device Dirents, these are not allowed user
        //  access at all
        //

        if (FlagOn(DirentAttributes, FAT_DIRENT_ATTR_VOLUME_ID) ||
            FlagOn(DirentAttributes, FAT_DIRENT_ATTR_DEVICE)) {

            DebugTrace(0, Dbg, "Cannot access volume id or device\n", 0);

            try_return( Result = FALSE );
        }

        //
        //  Check the desired access for the object - we only blackball that
        //  we do not understand.  The model of filesystems using ACLs is that
        //  they do not type the ACL to the object the ACL is on.  Permissions
        //  are not checked for consistency vs. the object type - dir/file.
        //

        if (FlagOn(*DesiredAccess, ~(DELETE |
                                     READ_CONTROL |
                                     WRITE_OWNER |
                                     WRITE_DAC |
                                     SYNCHRONIZE |
                                     ACCESS_SYSTEM_SECURITY |
                                     FILE_WRITE_DATA |
                                     FILE_READ_EA |
                                     FILE_WRITE_EA |
                                     FILE_READ_ATTRIBUTES |
                                     FILE_WRITE_ATTRIBUTES |
                                     FILE_LIST_DIRECTORY |
                                     FILE_TRAVERSE |
                                     FILE_DELETE_CHILD |
                                     FILE_APPEND_DATA))) {

            DebugTrace(0, Dbg, "Cannot open object\n", 0);

            try_return( Result = FALSE );
        }

        //
        //  Check for a read-only Dirent
        //

        if (FlagOn(DirentAttributes, FAT_DIRENT_ATTR_READ_ONLY)) {

            //
            //  Check the desired access for a read-only dirent.  AccessMask will contain
            //  the flags we're going to allow.
            //

            ACCESS_MASK AccessMask = DELETE | READ_CONTROL | WRITE_OWNER | WRITE_DAC |
                                    SYNCHRONIZE | ACCESS_SYSTEM_SECURITY | FILE_READ_DATA |
                                    FILE_READ_EA | FILE_WRITE_EA | FILE_READ_ATTRIBUTES |
                                    FILE_WRITE_ATTRIBUTES | FILE_EXECUTE | FILE_LIST_DIRECTORY |
                                    FILE_TRAVERSE;

            //
            //  If this is a subdirectory also allow add file/directory and delete.
            //
            
            if (FlagOn(DirentAttributes, FAT_DIRENT_ATTR_DIRECTORY)) {

                AccessMask |= FILE_ADD_SUBDIRECTORY | FILE_ADD_FILE | FILE_DELETE_CHILD;
            }
            
            if (FlagOn(*DesiredAccess, ~AccessMask)) {

                DebugTrace(0, Dbg, "Cannot open readonly\n", 0);

                try_return( Result = FALSE );
            }
        }

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatCheckFileAccess );

        DebugTrace(-1, Dbg, "FatCheckFileAccess -> %08lx\n", Result);
    }

    UNREFERENCED_PARAMETER( IrpContext );

    return Result;
}


NTSTATUS
FatExplicitDeviceAccessGranted (
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT DeviceObject,
    IN PACCESS_STATE AccessState,
    IN KPROCESSOR_MODE ProcessorMode
    )

/*++

Routine Description:

    This function asks whether the SID described in the input access state has
    been granted any explicit access to the given device object.  It does this
    by acquiring a token stripped of its ability to acquire access via the
    Everyone SID and re-doing the access check.

Arguments:

    DeviceObject - the device whose ACL will be checked
    
    AccessState - the access state describing the security context to be checked
    
    ProcessorMode - the mode this check should occur against

Return Value:

    NTSTATUS - Indicating whether explicit access was granted.

--*/

{
    NTSTATUS Status;
    BOOLEAN Result;

    PACCESS_TOKEN OriginalAccessToken;
    PACCESS_TOKEN RestrictedAccessToken;
    
    PACCESS_TOKEN *EffectiveToken;
    
    PRIVILEGE_SET PrivilegeSet;

    ACCESS_MASK GrantedAccess;

    //
    //  If the access state indicates that specific access other
    //  than traverse was acquired, either Everyone does have such
    //  access or explicit access was granted.  In both cases, we're
    //  happy to let this proceed.
    //

    if (AccessState->PreviouslyGrantedAccess & (SPECIFIC_RIGHTS_ALL ^
                                                FILE_TRAVERSE)) {

        return STATUS_SUCCESS;
    }

    //
    //  If the manage volume privilege is held, this also permits access.
    //

    PrivilegeSet.PrivilegeCount = 1;
    PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
    PrivilegeSet.Privilege[0].Luid = RtlConvertLongToLuid( SE_MANAGE_VOLUME_PRIVILEGE );
    PrivilegeSet.Privilege[0].Attributes = 0;

    if (SePrivilegeCheck( &PrivilegeSet,
                          &AccessState->SubjectSecurityContext,
                          ProcessorMode )) {

        return STATUS_SUCCESS;
    }

    //
    //  Capture the subject context as a prelude to everything below.
    //

    SeLockSubjectContext( &AccessState->SubjectSecurityContext );
    
    //
    //  Convert the token in the subject context into one which does not
    //  acquire access through the Everyone SID.
    //
    //  The logic for deciding which token is effective comes from
    //  SeQuerySubjectContextToken; since there is no natural way
    //  of getting a pointer to it, do it by hand.
    //
    
    if (ARGUMENT_PRESENT( AccessState->SubjectSecurityContext.ClientToken )) {
        EffectiveToken = &AccessState->SubjectSecurityContext.ClientToken;
    } else {
        EffectiveToken = &AccessState->SubjectSecurityContext.PrimaryToken;
    }

    OriginalAccessToken = *EffectiveToken;
    Status = FatCreateRestrictEveryoneToken( OriginalAccessToken, &RestrictedAccessToken );

    if (!NT_SUCCESS(Status)) {
        
        SeReleaseSubjectContext( &AccessState->SubjectSecurityContext );
        return Status;
    }

    //
    //  Now see if the resulting context has access to the device through
    //  its explicitly granted access.  We swap in our restricted token
    //  for this check as the effective client token.
    //

    *EffectiveToken = RestrictedAccessToken;

    Result = SeAccessCheck( DeviceObject->SecurityDescriptor,
                            &AccessState->SubjectSecurityContext,
                            FALSE,
                            AccessState->OriginalDesiredAccess,
                            0,
                            NULL,
                            IoGetFileObjectGenericMapping(),
                            ProcessorMode,
                            &GrantedAccess,
                            &Status );
    
    *EffectiveToken = OriginalAccessToken;
    
    //
    //  Cleanup and return.
    //

    SeUnlockSubjectContext( &AccessState->SubjectSecurityContext );
    ObDereferenceObject( RestrictedAccessToken );

    return Status;
}


NTSTATUS
FatCreateRestrictEveryoneToken (
    IN PACCESS_TOKEN Token,
    OUT PACCESS_TOKEN *RestrictedToken
    )

/*++

Routine Description:

    This function takes a token as the input and returns a new restricted token
    from which Everyone sid has been disabled.  The resulting token may be used
    to find out if access is available to a user-sid by explicit means.

Arguments:

    Token - Input token from which Everyone sid needs to be deactivated.

    RestrictedToken - Receives the the new restricted token.
        This must be released using ObDereferenceObject(*RestrictedToken);

Return Value:

    NTSTATUS - Returned by SeFilterToken.

--*/

{
    //
    // Array of sids to disable.
    //

    TOKEN_GROUPS SidsToDisable;

    NTSTATUS Status = STATUS_SUCCESS;

    //
    //  Restricted token will contain the original sids with one change:
    //  If Everyone sid is present in the token, it will be marked for DenyOnly.
    //

    *RestrictedToken = NULL;

    //
    //  Put Everyone sid in the array of sids to disable. This will mark it
    //  for SE_GROUP_USE_FOR_DENY_ONLY and it'll only be applicable for Deny aces.
    //

    SidsToDisable.GroupCount = 1;
    SidsToDisable.Groups[0].Attributes = 0;
    SidsToDisable.Groups[0].Sid = SeExports->SeWorldSid;

    Status = SeFilterToken(
                 Token,            // Token that needs to be restricted.
                 0,                // No flags
                 &SidsToDisable,   // Disable everyone sid
                 NULL,             // Do not create any restricted sids
                 NULL,             // Do not delete any privileges
                 RestrictedToken   // Restricted token
                 );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fastfat\allocsup.c ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    AllocSup.c

Abstract:

    This module implements the Allocation support routines for Fat.

// @@BEGIN_DDKSPLIT

Author:

    DavidGoebel     [DavidGoe]      31-Oct-90

Revision History:

    DavidGoebel     [DavidGoe]      31-Oct-90

        Add unwinding support.  Some steps had to be reordered, and whether
        operations cpuld fail carefully considered.  In particular, attention
        was paid to to the order of Mcb operations (see note below).



             #####     ##    #    #   ####   ######  #####
             #    #   #  #   ##   #  #    #  #       #    #
             #    #  #    #  # #  #  #       #####   #    #
             #    #  ######  #  # #  #  ###  #       #####
             #    #  #    #  #   ##  #    #  #       #   #
             #####   #    #  #    #   ####   ######  #    #
             ______________________________________________


            ++++++++++++++++++++++++++++++++++++++++++++++++++|
            |                                                 |
            | The unwinding aspects of this module depend on  |
            | operational details of the Mcb package.  Do not |
            | attempt to modify unwind procedures without     |
            | thoughoughly understanding the innerworkings of |
            | the Mcb package.                                |
            |                                                 |
            ++++++++++++++++++++++++++++++++++++++++++++++++++|


         #    #    ##    #####   #    #     #    #    #   ####
         #    #   #  #   #    #  ##   #     #    ##   #  #    #
         #    #  #    #  #    #  # #  #     #    # #  #  #
         # ## #  ######  #####   #  # #     #    #  # #  #  ###
         ##  ##  #    #  #   #   #   ##     #    #   ##  #    #
         #    #  #    #  #    #  #    #     #    #    #   ####
         ______________________________________________________
         
         
         There is also a suspect convention in use due to the way FAT32 was
         put into the allocator. We've got four distinct kinds of numbers
         you can see being used:
         
         - true volume cluster numbers, ranging from 2 to N
         - zero-based volume cluster numbers, ranging from 0 to N-2
         - window-relative "true" cluster numbers, ranging from 2 to 10001,
            the window size. this is because the hints/allocation within a window
            looks like unwindowed FAT12/16.
         - window-relative zero-based cluster numbers, ranging from 0 to ffff
         
         Make very sure you realize what kind of number you are looking at. This
         is where a bad +/-2 can come back to haunt you for years.

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_ALLOCSUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_ALLOCSUP)

#define FatMin(a, b)    ((a) < (b) ? (a) : (b))

//
//  This strucure is used by FatLookupFatEntry to remember a pinned page
//  of fat.
//

typedef struct _FAT_ENUMERATION_CONTEXT {

    VBO VboOfPinnedPage;
    PBCB Bcb;
    PVOID PinnedPage;

} FAT_ENUMERATION_CONTEXT, *PFAT_ENUMERATION_CONTEXT;

//
//  Local support routine prototypes
//

VOID
FatLookupFatEntry(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FatIndex,
    IN OUT PULONG FatEntry,
    IN OUT PFAT_ENUMERATION_CONTEXT Context
    );

VOID
FatSetFatRun(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG StartingFatIndex,
    IN ULONG ClusterCount,
    IN BOOLEAN ChainTogether
    );

UCHAR
FatLogOf(
    IN ULONG Value
    );

//
//  Note that the KdPrint below will ONLY fire when the assert does. Leave it
//  alone.
//

#if DBG
#define ASSERT_CURRENT_WINDOW_GOOD(VCB) {                                               \
    ULONG FreeClusterBitMapClear;                                                       \
    ASSERT( (VCB)->FreeClusterBitMap.Buffer != NULL );                                  \
    FreeClusterBitMapClear = RtlNumberOfClearBits(&(VCB)->FreeClusterBitMap);           \
    if ((VCB)->CurrentWindow->ClustersFree != FreeClusterBitMapClear) {                 \
        KdPrint(("FAT: ClustersFree %x h != FreeClusterBitMapClear %x h\n",             \
                 (VCB)->CurrentWindow->ClustersFree,                                    \
                 FreeClusterBitMapClear));                                              \
    }                                                                                   \
    ASSERT( (VCB)->CurrentWindow->ClustersFree == FreeClusterBitMapClear );             \
}
#else
#define ASSERT_CURRENT_WINDOW_GOOD(VCB)
#endif

//
//  The following macros provide a convenient way of hiding the details
//  of bitmap allocation schemes.
//


//
//  VOID
//  FatLockFreeClusterBitMap (
//      IN PVCB Vcb
//      );
//

#define FatLockFreeClusterBitMap(VCB) {                         \
    ASSERT(KeAreApcsDisabled());                                \
    ExAcquireFastMutexUnsafe( &(VCB)->FreeClusterBitMapMutex ); \
    ASSERT_CURRENT_WINDOW_GOOD(VCB)                             \
}

//
//  VOID
//  FatUnlockFreeClusterBitMap (
//      IN PVCB Vcb
//      );
//

#define FatUnlockFreeClusterBitMap(VCB) {                       \
    ASSERT_CURRENT_WINDOW_GOOD(VCB)                             \
    ASSERT(KeAreApcsDisabled());                                \
    ExReleaseFastMutexUnsafe( &(VCB)->FreeClusterBitMapMutex ); \
}

//
//  BOOLEAN
//  FatIsClusterFree (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN ULONG FatIndex
//      );
//

#define FatIsClusterFree(IRPCONTEXT,VCB,FAT_INDEX)                            \
    (RtlCheckBit(&(VCB)->FreeClusterBitMap,(FAT_INDEX)-2) == 0)

//
//  VOID
//  FatFreeClusters  (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN ULONG FatIndex,
//      IN ULONG ClusterCount
//      );
//

#define FatFreeClusters(IRPCONTEXT,VCB,FAT_INDEX,CLUSTER_COUNT) {             \
    if ((CLUSTER_COUNT) == 1) {                                               \
        FatSetFatEntry((IRPCONTEXT),(VCB),(FAT_INDEX),FAT_CLUSTER_AVAILABLE); \
    } else {                                                                  \
        FatSetFatRun((IRPCONTEXT),(VCB),(FAT_INDEX),(CLUSTER_COUNT),FALSE);   \
    }                                                                         \
}

//
//  VOID
//  FatAllocateClusters  (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN ULONG FatIndex,
//      IN ULONG ClusterCount
//      );
//

#define FatAllocateClusters(IRPCONTEXT,VCB,FAT_INDEX,CLUSTER_COUNT) {      \
    if ((CLUSTER_COUNT) == 1) {                                            \
        FatSetFatEntry((IRPCONTEXT),(VCB),(FAT_INDEX),FAT_CLUSTER_LAST);   \
    } else {                                                               \
        FatSetFatRun((IRPCONTEXT),(VCB),(FAT_INDEX),(CLUSTER_COUNT),TRUE); \
    }                                                                      \
}

//
//  VOID
//  FatUnreserveClusters  (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN ULONG FatIndex,
//      IN ULONG ClusterCount
//      );
//

#define FatUnreserveClusters(IRPCONTEXT,VCB,FAT_INDEX,CLUSTER_COUNT) {                      \
    ASSERT( (FAT_INDEX) + (CLUSTER_COUNT) - 2 <= (VCB)->FreeClusterBitMap.SizeOfBitMap );   \
    ASSERT( (FAT_INDEX) >= 2);                                                              \
    RtlClearBits(&(VCB)->FreeClusterBitMap,(FAT_INDEX)-2,(CLUSTER_COUNT));                  \
    if ((FAT_INDEX) < (VCB)->ClusterHint) {                                                 \
        (VCB)->ClusterHint = (FAT_INDEX);                                                   \
    }                                                                                       \
}

//
//  VOID
//  FatReserveClusters  (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN ULONG FatIndex,
//      IN ULONG ClusterCount
//      );
//
//  Handle wrapping the hint back to the front.
//

#define FatReserveClusters(IRPCONTEXT,VCB,FAT_INDEX,CLUSTER_COUNT) {                        \
    ULONG _AfterRun = (FAT_INDEX) + (CLUSTER_COUNT);                                        \
    ASSERT( (FAT_INDEX) + (CLUSTER_COUNT) - 2 <= (VCB)->FreeClusterBitMap.SizeOfBitMap );   \
    ASSERT( (FAT_INDEX) >= 2);                                                              \
    RtlSetBits(&(VCB)->FreeClusterBitMap,(FAT_INDEX)-2,(CLUSTER_COUNT));                    \
                                                                                            \
    if (_AfterRun - 2 >= (VCB)->FreeClusterBitMap.SizeOfBitMap) {                           \
        _AfterRun = 2;                                                                      \
    }                                                                                       \
    if (RtlCheckBit(&(VCB)->FreeClusterBitMap, _AfterRun - 2))  {                                   \
        (VCB)->ClusterHint = RtlFindClearBits( &(VCB)->FreeClusterBitMap, 1, _AfterRun - 2) + 2;    \
        if (1 == (VCB)->ClusterHint)  {                                                             \
            (VCB)->ClusterHint = 2;                                                         \
        }                                                                                   \
    }                                                                                       \
    else {                                                                                  \
        (VCB)->ClusterHint = _AfterRun;                                                     \
    }                                                                                       \
}

//
//  ULONG
//  FatFindFreeClusterRun (
//      IN PIRP_CONTEXT IrpContext,
//      IN PVCB Vcb,
//      IN ULONG ClusterCount,
//      IN ULONG AlternateClusterHint
//      );
//
//  Do a special check if only one cluster is desired.
//

#define FatFindFreeClusterRun(IRPCONTEXT,VCB,CLUSTER_COUNT,CLUSTER_HINT) ( \
    (CLUSTER_COUNT == 1) &&                                                \
    FatIsClusterFree((IRPCONTEXT), (VCB), (CLUSTER_HINT)) ?                \
        (CLUSTER_HINT) :                                                   \
        RtlFindClearBits( &(VCB)->FreeClusterBitMap,                       \
                          (CLUSTER_COUNT),                                 \
                          (CLUSTER_HINT) - 2) + 2                          \
)

//
//  FAT32: Define the maximum size of the FreeClusterBitMap to be the
//  maximum size of a FAT16 FAT.  If there are more clusters on the
//  volume than can be represented by this many bytes of bitmap, the
//  FAT will be split into "buckets", each of which does fit.
//
//  Note this count is in clusters/bits of bitmap.
//

#define MAX_CLUSTER_BITMAP_SIZE         (1 << 16)

//
//  Calculate the window a given cluster number is in.
//

#define FatWindowOfCluster(C)           (((C) - 2) / MAX_CLUSTER_BITMAP_SIZE)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatAddFileAllocation)
#pragma alloc_text(PAGE, FatAllocateDiskSpace)
#pragma alloc_text(PAGE, FatDeallocateDiskSpace)
#pragma alloc_text(PAGE, FatExamineFatEntries)
#pragma alloc_text(PAGE, FatInterpretClusterType)
#pragma alloc_text(PAGE, FatLogOf)
#pragma alloc_text(PAGE, FatLookupFatEntry)
#pragma alloc_text(PAGE, FatLookupFileAllocation)
#pragma alloc_text(PAGE, FatLookupFileAllocationSize)
#pragma alloc_text(PAGE, FatMergeAllocation)
#pragma alloc_text(PAGE, FatSetFatEntry)
#pragma alloc_text(PAGE, FatSetFatRun)
#pragma alloc_text(PAGE, FatSetupAllocationSupport)
#pragma alloc_text(PAGE, FatSplitAllocation)
#pragma alloc_text(PAGE, FatTearDownAllocationSupport)
#pragma alloc_text(PAGE, FatTruncateFileAllocation)
#endif


INLINE
ULONG
FatSelectBestWindow( 
    IN PVCB Vcb
    )
/*++

Routine Description:

    Choose a window to allocate clusters from.   Order of preference is:

    1.  First window with >50% free clusters
    2.  First empty window
    3.  Window with greatest number of free clusters.
        
Arguments:

    Vcb - Supplies the Vcb for the volume

Return Value:

    'Best window' number (index into Vcb->Windows[])

--*/
{
    ULONG i, Fave = 0;
    ULONG MaxFree = 0;
    ULONG FirstEmpty = -1;
    ULONG ClustersPerWindow = MAX_CLUSTER_BITMAP_SIZE;

    ASSERT( 1 != Vcb->NumberOfWindows);
    
    for (i = 0; i < Vcb->NumberOfWindows; i++) {

        if (Vcb->Windows[i].ClustersFree == ClustersPerWindow)  {
        
            if (-1 == FirstEmpty)  {
            
                //
                //  Keep note of the first empty window on the disc
                //
                
                FirstEmpty = i;
            }
        }
        else if (Vcb->Windows[i].ClustersFree > MaxFree)  {

            //
            //  This window has the most free clusters,  so far
            //
            
            MaxFree = Vcb->Windows[i].ClustersFree;
            Fave = i;

            //
            //  If this window has >50% free clusters,  then we will take it,
            //  so don't bother considering more windows.
            //
            
            if (MaxFree >= (ClustersPerWindow >> 1))  {
            
                break;
            }
        }
    }

    //
    //  If there were no windows with 50% or more freespace,  then select the
    //  first empty window on the disc,  if any - otherwise we'll just go with
    //  the one with the most free clusters.
    //
    
    if ((MaxFree < (ClustersPerWindow >> 1)) && (-1 != FirstEmpty))  {

        Fave = FirstEmpty;
    }

    return Fave;
}


VOID
FatSetupAllocationSupport (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine fills in the Allocation Support structure in the Vcb.
    Most entries are computed using fat.h macros supplied with data from
    the Bios Parameter Block.  The free cluster count, however, requires
    going to the Fat and actually counting free sectors.  At the same time
    the free cluster bit map is initalized.

Arguments:

    Vcb - Supplies the Vcb to fill in.

--*/

{
    ULONG BitMapSize;
    PVOID BitMapBuffer;
    ULONG BitIndex;

    PBCB Bcb;

    ULONG Page;
    ULONG Offset;
    ULONG FatIndexBitSize;
    ULONG ClustersDescribableByFat;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatSetupAllocationSupport\n", 0);
    DebugTrace( 0, Dbg, "  Vcb = %8lx\n", Vcb);

    //
    //  Compute a number of fields for Vcb.AllocationSupport
    //

    Vcb->AllocationSupport.RootDirectoryLbo = FatRootDirectoryLbo( &Vcb->Bpb );
    Vcb->AllocationSupport.RootDirectorySize = FatRootDirectorySize( &Vcb->Bpb );

    Vcb->AllocationSupport.FileAreaLbo = FatFileAreaLbo( &Vcb->Bpb );

    Vcb->AllocationSupport.NumberOfClusters = FatNumberOfClusters( &Vcb->Bpb );

    Vcb->AllocationSupport.FatIndexBitSize = FatIndexBitSize( &Vcb->Bpb );

    Vcb->AllocationSupport.LogOfBytesPerSector = FatLogOf(Vcb->Bpb.BytesPerSector);
    Vcb->AllocationSupport.LogOfBytesPerCluster = FatLogOf(FatBytesPerCluster( &Vcb->Bpb ));
    Vcb->AllocationSupport.NumberOfFreeClusters = 0;

    //
    //  Deal with a bug in DOS 5 format, if the Fat is not big enough to
    //  describe all the clusters on the disk, reduce this number.  We expect
    //  that fat32 volumes will not have this problem.
    //
    //  Turns out this was not a good assumption.  We have to do this always now.
    //

    ClustersDescribableByFat = ( ((FatIsFat32(Vcb)? Vcb->Bpb.LargeSectorsPerFat :
                                                    Vcb->Bpb.SectorsPerFat) *
                                  Vcb->Bpb.BytesPerSector * 8)
                                 / FatIndexBitSize(&Vcb->Bpb) ) - 2;

    if (Vcb->AllocationSupport.NumberOfClusters > ClustersDescribableByFat) {

        Vcb->AllocationSupport.NumberOfClusters = ClustersDescribableByFat;
    }

    //
    //  Extend the virtual volume file to include the Fat
    //

    {
        CC_FILE_SIZES FileSizes;

        FileSizes.AllocationSize.QuadPart =
        FileSizes.FileSize.QuadPart = (FatReservedBytes( &Vcb->Bpb ) +
                                       FatBytesPerFat( &Vcb->Bpb ));
        FileSizes.ValidDataLength = FatMaxLarge;

        if ( Vcb->VirtualVolumeFile->PrivateCacheMap == NULL ) {

            CcInitializeCacheMap( Vcb->VirtualVolumeFile,
                                  &FileSizes,
                                  TRUE,
                                  &FatData.CacheManagerNoOpCallbacks,
                                  Vcb );

        } else {

            CcSetFileSizes( Vcb->VirtualVolumeFile, &FileSizes );
        }
    }

    try {

        if (FatIsFat32(Vcb) &&
            Vcb->AllocationSupport.NumberOfClusters > MAX_CLUSTER_BITMAP_SIZE) {

            Vcb->NumberOfWindows = (Vcb->AllocationSupport.NumberOfClusters +
                                    MAX_CLUSTER_BITMAP_SIZE - 1) /
                                   MAX_CLUSTER_BITMAP_SIZE;

            BitMapSize = MAX_CLUSTER_BITMAP_SIZE;

        } else {

            Vcb->NumberOfWindows = 1;
            BitMapSize = Vcb->AllocationSupport.NumberOfClusters;
        }

        Vcb->Windows = FsRtlAllocatePoolWithTag( PagedPool,
                                                 Vcb->NumberOfWindows * sizeof(FAT_WINDOW),
                                                 TAG_FAT_WINDOW );

        RtlInitializeBitMap( &Vcb->FreeClusterBitMap,
                             NULL,
                             0 );

        //
        //  Chose a FAT window to begin operation in.
        //

        if (Vcb->NumberOfWindows > 1) {

            //
            //  Read the fat and count up free clusters.  We bias by the two reserved
            //  entries in the FAT.
            //

            FatExamineFatEntries( IrpContext, Vcb,
                                  2,
                                  Vcb->AllocationSupport.NumberOfClusters + 2 - 1,
                                  TRUE,
                                  NULL,
                                  NULL);


            //
            //  Pick a window to begin allocating from
            //

            Vcb->CurrentWindow = &Vcb->Windows[ FatSelectBestWindow( Vcb)];

        } else {

            Vcb->CurrentWindow = &Vcb->Windows[0];

            //
            //  Carefully bias ourselves by the two reserved entries in the FAT.
            //

            Vcb->CurrentWindow->FirstCluster = 2;
            Vcb->CurrentWindow->LastCluster = Vcb->AllocationSupport.NumberOfClusters + 2 - 1;
        }

        //
        //  Now transition to the FAT window we have chosen.
        //

        FatExamineFatEntries( IrpContext, Vcb,
                              0,
                              0,
                              FALSE,
                              Vcb->CurrentWindow,
                              NULL);

        //
        //  Now set the ClusterHint to the first free bit in our favorite
        //  window (except the ClusterHint is off by two).
        //

        Vcb->ClusterHint =
            (BitIndex = RtlFindClearBits( &Vcb->FreeClusterBitMap, 1, 0 )) != -1 ?
                BitIndex + 2 : 2;

    } finally {

        DebugUnwind( FatSetupAllocationSupport );

        //
        //  If we hit an exception, back out.
        //

        if (AbnormalTermination()) {

            FatTearDownAllocationSupport( IrpContext, Vcb );
        }
    }

    return;
}


VOID
FatTearDownAllocationSupport (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine prepares the volume for closing.  Specifically, we must
    release the free fat bit map buffer, and uninitialize the dirty fat
    Mcb.

Arguments:

    Vcb - Supplies the Vcb to fill in.

Return Value:

    VOID

--*/

{
    DebugTrace(+1, Dbg, "FatTearDownAllocationSupport\n", 0);
    DebugTrace( 0, Dbg, "  Vcb = %8lx\n", Vcb);

    PAGED_CODE();

    //
    //  If there are FAT buckets, free them.
    //

    if ( Vcb->Windows != NULL ) {

        ExFreePool( Vcb->Windows );
        Vcb->Windows = NULL;
    }

    //
    //  Free the memory associated with the free cluster bitmap.
    //

    if ( Vcb->FreeClusterBitMap.Buffer != NULL ) {

        ExFreePool( Vcb->FreeClusterBitMap.Buffer );

        //
        //  NULL this field as an flag.
        //

        Vcb->FreeClusterBitMap.Buffer = NULL;
    }

    //
    //  And remove all the runs in the dirty fat Mcb
    //

    FatRemoveMcbEntry( Vcb, &Vcb->DirtyFatMcb, 0, 0xFFFFFFFF );

    DebugTrace(-1, Dbg, "FatTearDownAllocationSupport -> (VOID)\n", 0);

    UNREFERENCED_PARAMETER( IrpContext );

    return;
}


VOID
FatLookupFileAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN VBO Vbo,
    OUT PLBO Lbo,
    OUT PULONG ByteCount,
    OUT PBOOLEAN Allocated,
    OUT PBOOLEAN EndOnMax,
    OUT PULONG Index
    )

/*++

Routine Description:

    This routine looks up the existing mapping of VBO to LBO for a
    file/directory.  The information it queries is either stored in the
    mcb field of the fcb/dcb or it is stored on in the fat table and
    needs to be retrieved and decoded, and updated in the mcb.

Arguments:

    FcbOrDcb - Supplies the Fcb/Dcb of the file/directory being queried

    Vbo - Supplies the VBO whose LBO we want returned

    Lbo - Receives the LBO corresponding to the input Vbo if one exists

    ByteCount - Receives the number of bytes within the run the run
                that correpond between the input vbo and output lbo.

    Allocated - Receives TRUE if the Vbo does have a corresponding Lbo
                and FALSE otherwise.

    EndOnMax - Receives TRUE if the run ends in the maximal FAT cluster,
                which results in a fractional bytecount.

    Index - Receives the Index of the run

--*/

{
    VBO CurrentVbo;
    LBO CurrentLbo;
    LBO PriorLbo;

    VBO FirstVboOfCurrentRun;
    LBO FirstLboOfCurrentRun;

    BOOLEAN LastCluster;
    ULONG Runs;

    PVCB Vcb;
    FAT_ENTRY FatEntry;
    ULONG BytesPerCluster;
    ULARGE_INTEGER BytesOnVolume;

    FAT_ENUMERATION_CONTEXT Context;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatLookupFileAllocation\n", 0);
    DebugTrace( 0, Dbg, "  FcbOrDcb  = %8lx\n", FcbOrDcb);
    DebugTrace( 0, Dbg, "  Vbo       = %8lx\n", Vbo);
    DebugTrace( 0, Dbg, "  Lbo       = %8lx\n", Lbo);
    DebugTrace( 0, Dbg, "  ByteCount = %8lx\n", ByteCount);
    DebugTrace( 0, Dbg, "  Allocated = %8lx\n", Allocated);

    Context.Bcb = NULL;

    Vcb = FcbOrDcb->Vcb;

    *EndOnMax = FALSE;

    //
    //  Check the trivial case that the mapping is already in our
    //  Mcb.
    //

    if ( FatLookupMcbEntry(Vcb, &FcbOrDcb->Mcb, Vbo, Lbo, ByteCount, Index) ) {

        *Allocated = TRUE;

        ASSERT( ByteCount != 0);

        //
        //  Detect the overflow case, trim and claim the condition.
        //

        if (Vbo + *ByteCount == 0) {

            *EndOnMax = TRUE;
        }

        DebugTrace( 0, Dbg, "Found run in Mcb.\n", 0);
        DebugTrace(-1, Dbg, "FatLookupFileAllocation -> (VOID)\n", 0);
        return;
    }

    //
    //  Initialize the Vcb, the cluster size, LastCluster, and
    //  FirstLboOfCurrentRun (to be used as an indication of the first
    //  iteration through the following while loop).
    //

    BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

    BytesOnVolume.QuadPart = UInt32x32To64( Vcb->AllocationSupport.NumberOfClusters, BytesPerCluster );

    LastCluster = FALSE;
    FirstLboOfCurrentRun = 0;

    //
    //  Discard the case that the request extends beyond the end of
    //  allocation.  Note that if the allocation size if not known
    //  AllocationSize is set to 0xffffffff.
    //

    if ( Vbo >= FcbOrDcb->Header.AllocationSize.LowPart ) {

        *Allocated = FALSE;

        DebugTrace( 0, Dbg, "Vbo beyond end of file.\n", 0);
        DebugTrace(-1, Dbg, "FatLookupFileAllocation -> (VOID)\n", 0);
        return;
    }

    //
    //  The Vbo is beyond the last Mcb entry.  So we adjust Current Vbo/Lbo
    //  and FatEntry to describe the beginning of the last entry in the Mcb.
    //  This is used as initialization for the following loop.
    //
    //  If the Mcb was empty, we start at the beginning of the file with
    //  CurrentVbo set to 0 to indicate a new run.
    //

    if (FatLookupLastMcbEntry( Vcb, &FcbOrDcb->Mcb, &CurrentVbo, &CurrentLbo, &Runs )) {

        DebugTrace( 0, Dbg, "Current Mcb size = %8lx.\n", CurrentVbo + 1);

        CurrentVbo -= (BytesPerCluster - 1);
        CurrentLbo -= (BytesPerCluster - 1);

        //
        //  Convert an index to a count.
        //

        Runs += 1;

    } else {

        DebugTrace( 0, Dbg, "Mcb empty.\n", 0);

        //
        //  Check for an FcbOrDcb that has no allocation
        //

        if (FcbOrDcb->FirstClusterOfFile == 0) {

            *Allocated = FALSE;

            DebugTrace( 0, Dbg, "File has no allocation.\n", 0);
            DebugTrace(-1, Dbg, "FatLookupFileAllocation -> (VOID)\n", 0);
            return;

        } else {

            CurrentVbo = 0;
            CurrentLbo = FatGetLboFromIndex( Vcb, FcbOrDcb->FirstClusterOfFile );
            FirstVboOfCurrentRun = CurrentVbo;
            FirstLboOfCurrentRun = CurrentLbo;

            Runs = 0;

            DebugTrace( 0, Dbg, "First Lbo of file = %8lx\n", CurrentLbo);
        }
    }

    //
    //  Now we know that we are looking up a valid Vbo, but it is
    //  not in the Mcb, which is a monotonically increasing list of
    //  Vbo's.  Thus we have to go to the Fat, and update
    //  the Mcb as we go.  We use a try-finally to unpin the page
    //  of fat hanging around.  Also we mark *Allocated = FALSE, so that
    //  the caller wont try to use the data if we hit an exception.
    //

    *Allocated = FALSE;

    try {

        FatEntry = (FAT_ENTRY)FatGetIndexFromLbo( Vcb, CurrentLbo );

        //
        //  ASSERT that CurrentVbo and CurrentLbo are now cluster alligned.
        //  The assumption here, is that only whole clusters of Vbos and Lbos
        //  are mapped in the Mcb.
        //

        ASSERT( ((CurrentLbo - Vcb->AllocationSupport.FileAreaLbo)
                                                    % BytesPerCluster == 0) &&
                (CurrentVbo % BytesPerCluster == 0) );

        //
        //  Starting from the first Vbo after the last Mcb entry, scan through
        //  the Fat looking for our Vbo. We continue through the Fat until we
        //  hit a noncontiguity beyond the desired Vbo, or the last cluster.
        //

        while ( !LastCluster ) {

            //
            //  Get the next fat entry, and update our Current variables.
            //

            FatLookupFatEntry( IrpContext, Vcb, FatEntry, &FatEntry, &Context );

            PriorLbo = CurrentLbo;
            CurrentLbo = FatGetLboFromIndex( Vcb, FatEntry );
            CurrentVbo += BytesPerCluster;

            switch ( FatInterpretClusterType( Vcb, FatEntry )) {

            //
            //  Check for a break in the Fat allocation chain.
            //

            case FatClusterAvailable:
            case FatClusterReserved:
            case FatClusterBad:

                DebugTrace( 0, Dbg, "Break in allocation chain, entry = %d\n", FatEntry);
                DebugTrace(-1, Dbg, "FatLookupFileAllocation -> Fat Corrupt.  Raise Status.\n", 0);

                FatPopUpFileCorrupt( IrpContext, FcbOrDcb );
                FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                break;

            //
            //  If this is the last cluster, we must update the Mcb and
            //  exit the loop.
            //

            case FatClusterLast:

                //
                //  Assert we know where the current run started.  If the
                //  Mcb was empty when we were called, thenFirstLboOfCurrentRun
                //  was set to the start of the file.  If the Mcb contained an
                //  entry, then FirstLboOfCurrentRun was set on the first
                //  iteration through the loop.  Thus if FirstLboOfCurrentRun
                //  is 0, then there was an Mcb entry and we are on our first
                //  iteration, meaing that the last cluster in the Mcb was
                //  really the last allocated cluster, but we checked Vbo
                //  against AllocationSize, and found it OK, thus AllocationSize
                //  must be too large.
                //
                //  Note that, when we finally arrive here, CurrentVbo is actually
                //  the first Vbo beyond the file allocation and CurrentLbo is
                //  meaningless.
                //

                DebugTrace( 0, Dbg, "Read last cluster of file.\n", 0);

                //
                //  Detect the case of the maximal file.  Note that this really isn't
                //  a proper Vbo - those are zero-based, and this is a one-based number.
                //  The maximal file, of 2^32 - 1 bytes, has a maximum byte offset of
                //  2^32 - 2.
                //
                //  Just so we don't get confused here.
                //

                if (CurrentVbo == 0) {

                    *EndOnMax = TRUE;
                    CurrentVbo -= 1;
                }

                LastCluster = TRUE;

                if (FirstLboOfCurrentRun != 0 ) {

                    DebugTrace( 0, Dbg, "Adding a run to the Mcb.\n", 0);
                    DebugTrace( 0, Dbg, "  Vbo    = %08lx.\n", FirstVboOfCurrentRun);
                    DebugTrace( 0, Dbg, "  Lbo    = %08lx.\n", FirstLboOfCurrentRun);
                    DebugTrace( 0, Dbg, "  Length = %08lx.\n", CurrentVbo - FirstVboOfCurrentRun);

                    (VOID)FatAddMcbEntry( Vcb,
                                          &FcbOrDcb->Mcb,
                                          FirstVboOfCurrentRun,
                                          FirstLboOfCurrentRun,
                                          CurrentVbo - FirstVboOfCurrentRun );

                    Runs += 1;
                }

                //
                //  Being at the end of allocation, make sure we have found
                //  the Vbo.  If we haven't, seeing as we checked VBO
                //  against AllocationSize, the real disk allocation is less
                //  than that of AllocationSize.  This comes about when the
                //  real allocation is not yet known, and AllocaitonSize
                //  contains MAXULONG.
                //
                //  KLUDGE! - If we were called by FatLookupFileAllocationSize
                //  Vbo is set to MAXULONG - 1, and AllocationSize to the lookup
                //  hint. Thus we merrily go along looking for a match that isn't
                //  there, but in the meantime building an Mcb.  If this is
                //  the case, fill in AllocationSize and return.
                //

                if ( Vbo == MAXULONG - 1 ) {

                    *Allocated = FALSE;
                    FcbOrDcb->Header.AllocationSize.QuadPart = CurrentVbo;

                    DebugTrace( 0, Dbg, "New file allocation size = %08lx.\n", CurrentVbo);
                    try_return ( NOTHING );
                }

                //
                //  We will lie ever so slightly if we really terminated on the
                //  maximal byte of a file.  It is really allocated.
                //

                if (Vbo >= CurrentVbo && !*EndOnMax) {

                    *Allocated = FALSE;
                    try_return ( NOTHING );
                }

                break;

            //
            //  This is a continuation in the chain.  If the run has a
            //  discontiguity at this point, update the Mcb, and if we are beyond
            //  the desired Vbo, this is the end of the run, so set LastCluster
            //  and exit the loop.
            //

            case FatClusterNext:

                //
                //  This is the loop check.  The Vbo must not be bigger than the size of
                //  the volume, and the Vbo must not have a) wrapped and b) not been at the
                //  very last cluster in the chain, for the case of the maximal file.
                //

                if ( CurrentVbo == 0 ||
                     (BytesOnVolume.HighPart == 0 && CurrentVbo > BytesOnVolume.LowPart)) {

                    FatPopUpFileCorrupt( IrpContext, FcbOrDcb );
                    FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                }

                if ( PriorLbo + BytesPerCluster != CurrentLbo ) {

                    //
                    //  Note that on the first time through the loop
                    //  (FirstLboOfCurrentRun == 0), we don't add the
                    //  run to the Mcb since it curresponds to the last
                    //  run already stored in the Mcb.
                    //

                    if ( FirstLboOfCurrentRun != 0 ) {

                        DebugTrace( 0, Dbg, "Adding a run to the Mcb.\n", 0);
                        DebugTrace( 0, Dbg, "  Vbo    = %08lx.\n", FirstVboOfCurrentRun);
                        DebugTrace( 0, Dbg, "  Lbo    = %08lx.\n", FirstLboOfCurrentRun);
                        DebugTrace( 0, Dbg, "  Length = %08lx.\n", CurrentVbo - FirstVboOfCurrentRun);

                        FatAddMcbEntry( Vcb,
                                        &FcbOrDcb->Mcb,
                                        FirstVboOfCurrentRun,
                                        FirstLboOfCurrentRun,
                                        CurrentVbo - FirstVboOfCurrentRun );

                        Runs += 1;
                    }

                    //
                    //  Since we are at a run boundry, with CurrentLbo and
                    //  CurrentVbo being the first cluster of the next run,
                    //  we see if the run we just added encompases the desired
                    //  Vbo, and if so exit.  Otherwise we set up two new
                    //  First*boOfCurrentRun, and continue.
                    //

                    if (CurrentVbo > Vbo) {

                        LastCluster = TRUE;

                    } else {

                        FirstVboOfCurrentRun = CurrentVbo;
                        FirstLboOfCurrentRun = CurrentLbo;
                    }
                }
                break;

            default:

                DebugTrace(0, Dbg, "Illegal Cluster Type.\n", FatEntry);

                FatBugCheck( 0, 0, 0 );

                break;

            } // switch()
        } // while()

        //
        //  Load up the return parameters.
        //
        //  On exit from the loop, Vbo still contains the desired Vbo, and
        //  CurrentVbo is the first byte after the run that contained the
        //  desired Vbo.
        //

        *Allocated = TRUE;

        *Lbo = FirstLboOfCurrentRun + (Vbo - FirstVboOfCurrentRun);

        *ByteCount = CurrentVbo - Vbo;

        if (ARGUMENT_PRESENT(Index)) {

            //
            //  Note that Runs only needs to be accurate with respect to where we
            //  ended.  Since partial-lookup cases will occur without exclusive
            //  synchronization, the Mcb itself may be much bigger by now.
            //

            *Index = Runs - 1;
        }

    try_exit: NOTHING;

    } finally {

        DebugUnwind( FatLookupFileAllocation );

        //
        //  We are done reading the Fat, so unpin the last page of fat
        //  that is hanging around
        //

        FatUnpinBcb( IrpContext, Context.Bcb );

        DebugTrace(-1, Dbg, "FatLookupFileAllocation -> (VOID)\n", 0);
    }

    return;
}


VOID
FatAddFileAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN ULONG DesiredAllocationSize
    )

/*++

Routine Description:

    This routine adds additional allocation to the specified file/directory.
    Additional allocation is added by appending clusters to the file/directory.

    If the file already has a sufficient allocation then this procedure
    is effectively a noop.

Arguments:

    FcbOrDcb - Supplies the Fcb/Dcb of the file/directory being modified.
               This parameter must not specify the root dcb.

    FileObject - If supplied inform the cache manager of the change.

    DesiredAllocationSize - Supplies the minimum size, in bytes, that we want
                            allocated to the file/directory.

--*/

{
    PVCB Vcb;
    LARGE_MCB NewMcb;
    PLARGE_MCB McbToCleanup = NULL;
    PDIRENT Dirent = NULL;
    ULONG NewAllocation;
    PBCB Bcb = NULL;
    BOOLEAN UnwindWeAllocatedDiskSpace = FALSE;
    BOOLEAN UnwindAllocationSizeSet = FALSE;
    BOOLEAN UnwindCacheManagerInformed = FALSE;
    BOOLEAN UnwindWeInitializedMcb = FALSE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatAddFileAllocation\n", 0);
    DebugTrace( 0, Dbg, "  FcbOrDcb  =             %8lx\n", FcbOrDcb);
    DebugTrace( 0, Dbg, "  DesiredAllocationSize = %8lx\n", DesiredAllocationSize);

    //
    //  If we haven't yet set the correct AllocationSize, do so.
    //

    if (FcbOrDcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT)  {

        FatLookupFileAllocationSize( IrpContext, FcbOrDcb );
    }

    //
    //  Check for the benign case that the desired allocation is already
    //  within the allocation size.
    //

    if (DesiredAllocationSize <= FcbOrDcb->Header.AllocationSize.LowPart) {

        DebugTrace(0, Dbg, "Desired size within current allocation.\n", 0);

        DebugTrace(-1, Dbg, "FatAddFileAllocation -> (VOID)\n", 0);
        return;
    }

    DebugTrace( 0, Dbg, "InitialAllocation = %08lx.\n", FcbOrDcb->Header.AllocationSize.LowPart);

    //
    //  Get a chunk of disk space that will fullfill our needs.  If there
    //  was no initial allocation, start from the hint in the Vcb, otherwise
    //  try to allocate from the cluster after the initial allocation.
    //
    //  If there was no initial allocation to the file, we can just use the
    //  Mcb in the FcbOrDcb, otherwise we have to use a new one, and merge
    //  it to the one in the FcbOrDcb.
    //

    Vcb = FcbOrDcb->Vcb;

    try {

        if (FcbOrDcb->Header.AllocationSize.LowPart == 0) {

            LBO FirstLboOfFile;

            ASSERT( FcbOrDcb->FcbCondition == FcbGood );
            
            FatGetDirentFromFcbOrDcb( IrpContext,
                                      FcbOrDcb,
                                      &Dirent,
                                      &Bcb );

            ASSERT( Bcb != NULL );

            //
            //  Set this dirty right now since this call can fail.
            //

            FatSetDirtyBcb( IrpContext, Bcb, Vcb, TRUE );


            FatAllocateDiskSpace( IrpContext,
                                  Vcb,
                                  0,
                                  &DesiredAllocationSize,
                                  FALSE,
                                  &FcbOrDcb->Mcb );

            UnwindWeAllocatedDiskSpace = TRUE;
            McbToCleanup = &FcbOrDcb->Mcb;

            //
            //  We have to update the dirent and FcbOrDcb copies of
            //  FirstClusterOfFile since before it was 0
            //

            FatLookupMcbEntry( FcbOrDcb->Vcb,
                               &FcbOrDcb->Mcb,
                               0,
                               &FirstLboOfFile,
                               (PULONG)NULL,
                               NULL );

            DebugTrace( 0, Dbg, "First Lbo of file will be %08lx.\n", FirstLboOfFile );

            FcbOrDcb->FirstClusterOfFile = FatGetIndexFromLbo( Vcb, FirstLboOfFile );

            Dirent->FirstClusterOfFile = (USHORT)FcbOrDcb->FirstClusterOfFile;

            if ( FatIsFat32(Vcb) ) {

                Dirent->FirstClusterOfFileHi = (USHORT)(FcbOrDcb->FirstClusterOfFile >> 16);
            }

            //
            //   Note the size of the allocation we need to tell the cache manager about.
            //

            NewAllocation = DesiredAllocationSize;

        } else {

            LBO LastAllocatedLbo;
            VBO DontCare;

            //
            //  Get the first cluster following the current allocation.  It is possible
            //  the Mcb is empty (or short, etc.) so we need to be slightly careful
            //  about making sure we don't lie with the hint.
            //

            (void)FatLookupLastMcbEntry( FcbOrDcb->Vcb, &FcbOrDcb->Mcb, &DontCare, &LastAllocatedLbo, NULL );

            //
            //  Try to get some disk space starting from there.
            //

            NewAllocation = DesiredAllocationSize - FcbOrDcb->Header.AllocationSize.LowPart;

            FsRtlInitializeLargeMcb( &NewMcb, PagedPool );
            UnwindWeInitializedMcb = TRUE;
            McbToCleanup = &NewMcb;

            FatAllocateDiskSpace( IrpContext,
                                  Vcb,
                                  (LastAllocatedLbo != ~0  ?
                                   FatGetIndexFromLbo(Vcb,LastAllocatedLbo + 1) :
                                   0),
                                  &NewAllocation,
                                  FALSE,
                                  &NewMcb );

            UnwindWeAllocatedDiskSpace = TRUE;
        }

        //
        //  Now that we increased the allocation of the file, mark it in the
        //  FcbOrDcb.  Carefully prepare to handle an inability to grow the cache
        //  structures.
        //

        FcbOrDcb->Header.AllocationSize.LowPart += NewAllocation;

        //
        //  Handle the maximal file case, where we may have just wrapped.  Note
        //  that this must be the precise boundary case wrap, i.e. by one byte,
        //  so that the new allocation is actually one byte "less" as far as we're
        //  concerned.  This is important for the extension case.
        //

        if (FcbOrDcb->Header.AllocationSize.LowPart == 0) {

            NewAllocation -= 1;
            FcbOrDcb->Header.AllocationSize.LowPart = 0xffffffff;
        }

        UnwindAllocationSizeSet = TRUE;

        //
        //  Inform the cache manager to increase the section size
        //

        if ( ARGUMENT_PRESENT(FileObject) && CcIsFileCached(FileObject) ) {

            CcSetFileSizes( FileObject,
                            (PCC_FILE_SIZES)&FcbOrDcb->Header.AllocationSize );
            UnwindCacheManagerInformed = TRUE;
        }

        //
        //  In the extension case, we have held off actually gluing the new
        //  allocation onto the file.  This simplifies exception cleanup since
        //  if it was already added and the section grow failed, we'd have to
        //  do extra work to unglue it.  This way, we can assume that if we
        //  raise the only thing we need to do is deallocate the disk space.
        //
        //  Merge the allocation now.
        //

        if (FcbOrDcb->Header.AllocationSize.LowPart != NewAllocation) {

            //
            //  Tack the new Mcb onto the end of the FcbOrDcb one.
            //

            FatMergeAllocation( IrpContext,
                                Vcb,
                                &FcbOrDcb->Mcb,
                                &NewMcb );
        }

    } finally {

        DebugUnwind( FatAddFileAllocation );

        //
        //  Give FlushFileBuffer/Cleanup a clue here, regardless of success/fail..
        //

        SetFlag(FcbOrDcb->FcbState, FCB_STATE_FLUSH_FAT);

        //
        //  If we were dogged trying to complete this operation, we need to go
        //  back various things out.
        //

        if (AbnormalTermination()) {

            //
            //  Pull off the allocation size we tried to add to this object if
            //  we failed to grow cache structures or Mcb structures.
            //

            if (UnwindAllocationSizeSet) {

                FcbOrDcb->Header.AllocationSize.LowPart -= NewAllocation;
            }

            if (UnwindCacheManagerInformed) {

                CcSetFileSizes( FileObject,
                                (PCC_FILE_SIZES)&FcbOrDcb->Header.AllocationSize );
            }

            //
            //  In the case of initial allocation, we used the Fcb's Mcb and have
            //  to clean that up as well as the FAT chain references.
            //

            if (FcbOrDcb->Header.AllocationSize.LowPart == 0) {

                if (Dirent != NULL) {

                    FcbOrDcb->FirstClusterOfFile = 0;
                    Dirent->FirstClusterOfFile = 0;

                    if ( FatIsFat32(Vcb) ) {

                        Dirent->FirstClusterOfFileHi = 0;
                    }
                }
            }

            //
            //  ... and drop the dirent Bcb if we got it.  Do it now
            //  so we can afford to take the exception if we have to.
            //

            FatUnpinBcb( IrpContext, Bcb );

            try {

                //
                //  Note this can re-raise.
                //

                if ( UnwindWeAllocatedDiskSpace ) {

                    FatDeallocateDiskSpace( IrpContext, Vcb, McbToCleanup );
                }

            } finally {

                //
                //  We always want to clean up the non-initial allocation temporary Mcb,
                //  otherwise we have the Fcb's Mcb and we just truncate it away.
                //

                if (UnwindWeInitializedMcb == TRUE) {

                    //
                    //  Note that we already know a raise is in progress.  No danger
                    //  of encountering the normal case code below and doing this again.
                    //

                    FsRtlUninitializeLargeMcb( McbToCleanup );

                } else {

                    if (McbToCleanup) {

                        FsRtlTruncateLargeMcb( McbToCleanup, 0 );
                    }
                }
            }
        }

        DebugTrace(-1, Dbg, "FatAddFileAllocation -> (VOID)\n", 0);
    }

    //
    //  Non-exceptional cleanup we always want to do.  In handling the re-raise possibilities
    //  during exceptions we had to make sure these two steps always happened there beforehand.
    //  So now we handle the usual case.
    //

    FatUnpinBcb( IrpContext, Bcb );

    if (UnwindWeInitializedMcb == TRUE) {

        FsRtlUninitializeLargeMcb( &NewMcb );
    }
}


VOID
FatTruncateFileAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN ULONG DesiredAllocationSize
    )

/*++

Routine Description:

    This routine truncates the allocation to the specified file/directory.

    If the file is already smaller than the indicated size then this procedure
    is effectively a noop.


Arguments:

    FcbOrDcb - Supplies the Fcb/Dcb of the file/directory being modified
               This parameter must not specify the root dcb.

    DesiredAllocationSize - Supplies the maximum size, in bytes, that we want
                            allocated to the file/directory.  It is rounded
                            up to the nearest cluster.

Return Value:

    VOID - TRUE if the operation completed and FALSE if it had to
        block but could not.

--*/

{
    PVCB Vcb;
    PBCB Bcb = NULL;
    LARGE_MCB RemainingMcb;
    ULONG BytesPerCluster;
    PDIRENT Dirent = NULL;
    BOOLEAN UpdatedDirent = FALSE;

    ULONG UnwindInitialAllocationSize;
    ULONG UnwindInitialFirstClusterOfFile;
    BOOLEAN UnwindWeAllocatedMcb = FALSE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatTruncateFileAllocation\n", 0);
    DebugTrace( 0, Dbg, "  FcbOrDcb  =             %8lx\n", FcbOrDcb);
    DebugTrace( 0, Dbg, "  DesiredAllocationSize = %8lx\n", DesiredAllocationSize);

    //
    //  If the Fcb isn't in good condition, we have no business whacking around on
    //  the disk after "its" clusters.
    //
    //  Inspired by a Prefix complaint.
    //
    
    ASSERT( FcbOrDcb->FcbCondition == FcbGood );

    //
    //  If we haven't yet set the correct AllocationSize, do so.
    //

    if (FcbOrDcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT)  {

        FatLookupFileAllocationSize( IrpContext, FcbOrDcb );
    }

    //
    //  Round up the Desired Allocation Size to the next cluster size
    //

    Vcb = FcbOrDcb->Vcb;

    BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

    //
    //  Note if the desired allocation is zero, to distinguish this from
    //  the wrap case below.
    //

    if (DesiredAllocationSize != 0) {

        DesiredAllocationSize = (DesiredAllocationSize + (BytesPerCluster - 1)) &
                                ~(BytesPerCluster - 1);
        //
        //  Check for the benign case that the file is already smaller than
        //  the desired truncation.  Note that if it wraps, then a) it was
        //  specifying an offset in the maximally allocatable cluster and
        //  b) we're not asking to extend the file, either.  So stop.
        //

        if (DesiredAllocationSize == 0 ||
            DesiredAllocationSize >= FcbOrDcb->Header.AllocationSize.LowPart) {

            DebugTrace(0, Dbg, "Desired size within current allocation.\n", 0);

            DebugTrace(-1, Dbg, "FatTruncateFileAllocation -> (VOID)\n", 0);
            return;
        }

    }

    UnwindInitialAllocationSize = FcbOrDcb->Header.AllocationSize.LowPart;
    UnwindInitialFirstClusterOfFile = FcbOrDcb->FirstClusterOfFile;

    //
    //  Update the FcbOrDcb allocation size.  If it is now zero, we have the
    //  additional task of modifying the FcbOrDcb and Dirent copies of
    //  FirstClusterInFile.
    //
    //  Note that we must pin the dirent before actually deallocating the
    //  disk space since, in unwind, it would not be possible to reallocate
    //  deallocated disk space as someone else may have reallocated it and
    //  may cause an exception when you try to get some more disk space.
    //  Thus FatDeallocateDiskSpace must be the final dangerous operation.
    //

    try {

        FcbOrDcb->Header.AllocationSize.QuadPart = DesiredAllocationSize;

        //
        //  Special case 0
        //

        if (DesiredAllocationSize == 0) {

            //
            //  We have to update the dirent and FcbOrDcb copies of
            //  FirstClusterOfFile since before it was 0
            //

            ASSERT( FcbOrDcb->FcbCondition == FcbGood );
            
            FatGetDirentFromFcbOrDcb( IrpContext, FcbOrDcb, &Dirent, &Bcb );

            ASSERT( Dirent && Bcb );

            Dirent->FirstClusterOfFile = 0;

            if (FatIsFat32(Vcb)) {

                Dirent->FirstClusterOfFileHi = 0;
            }

            FcbOrDcb->FirstClusterOfFile = 0;

            FatSetDirtyBcb( IrpContext, Bcb, Vcb, TRUE );
            UpdatedDirent = TRUE;

            FatDeallocateDiskSpace( IrpContext, Vcb, &FcbOrDcb->Mcb );

            FatRemoveMcbEntry( FcbOrDcb->Vcb, &FcbOrDcb->Mcb, 0, 0xFFFFFFFF );

        } else {

            //
            //  Split the existing allocation into two parts, one we will keep, and
            //  one we will deallocate.
            //

            FsRtlInitializeLargeMcb( &RemainingMcb, PagedPool );
            UnwindWeAllocatedMcb = TRUE;

            FatSplitAllocation( IrpContext,
                                Vcb,
                                &FcbOrDcb->Mcb,
                                DesiredAllocationSize,
                                &RemainingMcb );

            FatDeallocateDiskSpace( IrpContext, Vcb, &RemainingMcb );

            FsRtlUninitializeLargeMcb( &RemainingMcb );
        }

    } finally {

        DebugUnwind( FatTruncateFileAllocation );

        //
        //  Is this really the right backout strategy?  It would be nice if we could
        //  pretend the truncate worked if we knew that the file had gotten into
        //  a consistent state.  Leaving dangled clusters is probably quite preferable.
        //

        if ( AbnormalTermination() ) {

            FcbOrDcb->Header.AllocationSize.LowPart = UnwindInitialAllocationSize;

            if ( (DesiredAllocationSize == 0) && (Dirent != NULL)) {

                if (UpdatedDirent)  {

                    //
                    //  If the dirent has been updated ok and marked dirty,  then we
                    //  failed in deallocatediscspace,  and don't know what state
                    //  the on disc fat chain is in.  So we throw away the mcb,
                    //  and potentially loose a few clusters until the next
                    //  chkdsk.  The operation has succeeded,  but the exception
                    //  will still propogate.  5.1
                    //

                    FatRemoveMcbEntry( Vcb, &FcbOrDcb->Mcb, 0, 0xFFFFFFFF );
                    FcbOrDcb->Header.AllocationSize.QuadPart = 0;
                }
                else  {

                    Dirent->FirstClusterOfFile = (USHORT)UnwindInitialFirstClusterOfFile;

                    if ( FatIsFat32(Vcb) ) {

                        Dirent->FirstClusterOfFileHi =
                                (USHORT)(UnwindInitialFirstClusterOfFile >> 16);
                    }

                    FcbOrDcb->FirstClusterOfFile = UnwindInitialFirstClusterOfFile;
                }
            }

            if ( UnwindWeAllocatedMcb ) {

                FsRtlUninitializeLargeMcb( &RemainingMcb );
            }

            //
            //  Note that in the non zero truncation case,  we will also
            //  leak clusters.  However, apart from this, the in memory and on disc
            //  structures will agree.
        }

        FatUnpinBcb( IrpContext, Bcb );

        //
        //  Give FlushFileBuffer/Cleanup a clue here,  regardless of success/fail.
        //

        SetFlag(FcbOrDcb->FcbState, FCB_STATE_FLUSH_FAT);

        DebugTrace(-1, Dbg, "FatTruncateFileAllocation -> (VOID)\n", 0);
    }
}


VOID
FatLookupFileAllocationSize (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb
    )

/*++

Routine Description:

    This routine retrieves the current file allocatio size for the
    specified file/directory.

Arguments:

    FcbOrDcb - Supplies the Fcb/Dcb of the file/directory being modified

--*/

{
    LBO Lbo;
    ULONG ByteCount;
    BOOLEAN DontCare;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatLookupAllocationSize\n", 0);
    DebugTrace( 0, Dbg, "  FcbOrDcb  =      %8lx\n", FcbOrDcb);

    //
    //  We call FatLookupFileAllocation with Vbo of 0xffffffff - 1.
    //

    FatLookupFileAllocation( IrpContext,
                             FcbOrDcb,
                             MAXULONG - 1,
                             &Lbo,
                             &ByteCount,
                             &DontCare,
                             &DontCare,
                             NULL );

    //
    //  FileSize was set at Fcb creation time from the contents of the directory entry,
    //  and we are only now looking up the real length of the allocation chain.  If it
    //  cannot be contained, this is trash.  Probably more where that came from.
    //

    if (FcbOrDcb->Header.FileSize.LowPart > FcbOrDcb->Header.AllocationSize.LowPart) {

        FatPopUpFileCorrupt( IrpContext, FcbOrDcb );
        FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
    }

    DebugTrace(-1, Dbg, "FatLookupFileAllocationSize -> (VOID)\n", 0);
    return;
}


VOID
FatAllocateDiskSpace (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG AbsoluteClusterHint,
    IN PULONG ByteCount,
    IN BOOLEAN ExactMatchRequired,
    OUT PLARGE_MCB Mcb
    )

/*++

Routine Description:

    This procedure allocates additional disk space and builds an mcb
    representing the newly allocated space.  If the space cannot be
    allocated then this procedure raises an appropriate status.

    Searching starts from the hint index in the Vcb unless an alternative
    non-zero hint is given in AlternateClusterHint.  If we are using the
    hint field in the Vcb, it is set to the cluster following our allocation
    when we are done.

    Disk space can only be allocated in cluster units so this procedure
    will round up any byte count to the next cluster boundary.

    Pictorially what is done is the following (where ! denotes the end of
    the fat chain (i.e., FAT_CLUSTER_LAST)):


        Mcb (empty)

    becomes

        Mcb |--a--|--b--|--c--!

                            ^
        ByteCount ----------+

Arguments:

    Vcb - Supplies the VCB being modified

    AbsoluteClusterHint  - Supplies an alternate hint index to start the
                           search from.  If this is zero we use, and update,
                           the Vcb hint field.

    ByteCount - Supplies the number of bytes that we are requesting, and
                receives the number of bytes that we got.

    ExactMatchRequired - Caller should set this to TRUE if only the precise run requested
                 is acceptable.

    Mcb - Receives the MCB describing the newly allocated disk space.  The
          caller passes in an initialized Mcb that is filled in by this procedure.

 Return Value:

    TRUE  - Allocated ok
    FALSE - Failed to allocate exactly as requested (=> ExactMatchRequired was TRUE)

--*/

{
    UCHAR LogOfBytesPerCluster;
    ULONG BytesPerCluster;
    ULONG StartingCluster;
    ULONG ClusterCount;
    ULONG WindowRelativeHint;
#if DBG
    ULONG i;
    ULONG PreviousClear;
#endif

    PFAT_WINDOW Window;
    BOOLEAN Wait;
    BOOLEAN Result = TRUE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatAllocateDiskSpace\n", 0);
    DebugTrace( 0, Dbg, "  Vcb        = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  *ByteCount = %8lx\n", *ByteCount);
    DebugTrace( 0, Dbg, "  Mcb        = %8lx\n", Mcb);
    DebugTrace( 0, Dbg, "  Hint       = %8lx\n", AbsoluteClusterHint);

    ASSERT((AbsoluteClusterHint <= Vcb->AllocationSupport.NumberOfClusters + 2) && (1 != AbsoluteClusterHint));

    //
    //  Make sure byte count is not zero
    //

    if (*ByteCount == 0) {

        DebugTrace(0, Dbg, "Nothing to allocate.\n", 0);

        DebugTrace(-1, Dbg, "FatAllocateDiskSpace -> (VOID)\n", 0);
        return;
    }

    //
    //  Compute the cluster count based on the byte count, rounding up
    //  to the next cluster if there is any remainder.  Note that the
    //  pathalogical case BytesCount == 0 has been eliminated above.
    //

    LogOfBytesPerCluster = Vcb->AllocationSupport.LogOfBytesPerCluster;
    BytesPerCluster = 1 << LogOfBytesPerCluster;

    *ByteCount = (*ByteCount + (BytesPerCluster - 1))
                            & ~(BytesPerCluster - 1);

    //
    //  If ByteCount is NOW zero, then we were asked for the maximal
    //  filesize (or at least for bytes in the last allocatable sector).
    //

    if (*ByteCount == 0) {

        *ByteCount = 0xffffffff;
        ClusterCount =  1 << (32 - LogOfBytesPerCluster);

    } else {

        ClusterCount = (*ByteCount >> LogOfBytesPerCluster);
    }

    //
    //  Make sure there are enough free clusters to start with, and
    //  take them now so that nobody else takes them from us.  
    //

    ExAcquireResourceSharedLite(&Vcb->ChangeBitMapResource, TRUE);
    FatLockFreeClusterBitMap( Vcb );

    if (ClusterCount <= Vcb->AllocationSupport.NumberOfFreeClusters) {

        Vcb->AllocationSupport.NumberOfFreeClusters -= ClusterCount;

    } else {

        FatUnlockFreeClusterBitMap( Vcb );
        ExReleaseResourceLite(&Vcb->ChangeBitMapResource);

        DebugTrace(0, Dbg, "Disk Full.  Raise Status.\n", 0);
        FatRaiseStatus( IrpContext, STATUS_DISK_FULL );
    }

    //
    //  Did the caller supply a hint?
    //

    if ((0 != AbsoluteClusterHint) && (AbsoluteClusterHint < (Vcb->AllocationSupport.NumberOfClusters + 2)))  {

        if (Vcb->NumberOfWindows > 1)  {

            //
            //  If we're being called upon to allocate clusters outside the
            //  current window (which happens only via MoveFile), it's a problem.
            //  We address this by changing the current window to be the one which
            //  contains the alternate cluster hint.  Note that if the user's
            //  request would cross a window boundary, he doesn't really get what
            //  he wanted.
            //

            if (AbsoluteClusterHint < Vcb->CurrentWindow->FirstCluster ||
                AbsoluteClusterHint > Vcb->CurrentWindow->LastCluster) {

                ULONG BucketNum = FatWindowOfCluster( AbsoluteClusterHint );

                ASSERT( BucketNum < Vcb->NumberOfWindows);

                //
                //  Drop our shared lock on the ChangeBitMapResource,  and pick it up again
                //  exclusive in preparation for making the window swap.
                //
                
                FatUnlockFreeClusterBitMap(Vcb);    
                ExReleaseResourceLite(&Vcb->ChangeBitMapResource);
                ExAcquireResourceExclusiveLite(&Vcb->ChangeBitMapResource, TRUE);
                FatLockFreeClusterBitMap(Vcb);

                Window = &Vcb->Windows[BucketNum];

                //
                //  Again,  test the current window against the one we want - some other
                //  thread could have sneaked in behind our backs and kindly set it to the one 
                //  we need,  when we dropped and reacquired the ChangeBitMapResource above.
                //
                
                if (Window != Vcb->CurrentWindow)  {
                
                    try {

                        Wait = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
                        SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);

                        //
                        //  Change to the new window (update Vcb->CurrentWindow) and scan it
                        //  to build up a freespace bitmap etc.
                        //
                        
                        FatExamineFatEntries( IrpContext, Vcb,
                                              0,
                                              0,
                                              FALSE,
                                              Window,
                                              NULL);

                    } finally {

                        if (!Wait) {

                            ClearFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
                        }

                        if (AbnormalTermination()) {

                            //
                            //  We will have raised as a result of failing to pick up the
                            //  chunk of the FAT for this window move.  Release our resources
                            //  and return the cluster count to the volume.
                            //

                            Vcb->AllocationSupport.NumberOfFreeClusters += ClusterCount;

                            FatUnlockFreeClusterBitMap( Vcb );
                            ExReleaseResourceLite(&Vcb->ChangeBitMapResource);
                        }
                    }
                }
            }

            //
            //  Make the hint cluster number relative to the base of the current window...
            //
            //  Currentwindow->Firstcluster is baised by +2 already,  so we will lose the
            //  bias already in AbsoluteClusterHint.  Put it back....
            //

            WindowRelativeHint = AbsoluteClusterHint - Vcb->CurrentWindow->FirstCluster + 2;
        }
        else {

            //
            //  Only one 'window',  ie fat16/12.  No modification necessary.
            //

            WindowRelativeHint = AbsoluteClusterHint;
        }
    }
    else {

        //
        //  Either no hint supplied,  or it was out of range,  so grab one from the Vcb
        //
        //  NOTE: Clusterhint in the Vcb is not guaranteed to be set (may be -1)
        //
    
        WindowRelativeHint = Vcb->ClusterHint;
        AbsoluteClusterHint = 0;

        //
        //  Vcb hint may not have been initialized yet.  Force to valid cluster.
        //

        if (-1 == WindowRelativeHint)  {

            WindowRelativeHint = 2;
        }
    }

    ASSERT((WindowRelativeHint >= 2) && (WindowRelativeHint < Vcb->FreeClusterBitMap.SizeOfBitMap + 2));

    //
    //  Keep track of the window we're allocating from, so we can clean
    //  up correctly if the current window changes after we unlock the
    //  bitmap.
    //

    Window = Vcb->CurrentWindow;

    //
    //  Try to find a run of free clusters large enough for us.
    //

    StartingCluster = FatFindFreeClusterRun( IrpContext,
                                             Vcb,
                                             ClusterCount,
                                             WindowRelativeHint );
    //
    //  If the above call was successful, we can just update the fat
    //  and Mcb and exit.  Otherwise we have to look for smaller free
    //  runs.
    //
    //  This test is a bit funky. Note that the error return from
    //  RtlFindClearBits is -1, and adding two to that is 1.
    //

    if ((StartingCluster != 1) &&
        ((0 == AbsoluteClusterHint) || (StartingCluster == WindowRelativeHint))
    )  {

#if DBG
        PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );
#endif // DBG

        //
        //  Take the clusters we found, and unlock the bit map.
        //

        FatReserveClusters(IrpContext, Vcb, StartingCluster, ClusterCount);

        Window->ClustersFree -= ClusterCount;

        StartingCluster += Window->FirstCluster;
        StartingCluster -= 2;

        ASSERT( PreviousClear - ClusterCount == Window->ClustersFree );

        FatUnlockFreeClusterBitMap( Vcb );

        //
        //  Note that this call will never fail since there is always
        //  room for one entry in an empty Mcb.
        //

        FatAddMcbEntry( Vcb, Mcb,
                        0,
                        FatGetLboFromIndex( Vcb, StartingCluster ),
                        *ByteCount);
        try {

            //
            //  Update the fat.
            //

            FatAllocateClusters(IrpContext, Vcb,
                                StartingCluster,
                                ClusterCount);

        } finally {

            DebugUnwind( FatAllocateDiskSpace );

            //
            //  If the allocate clusters failed, remove the run from the Mcb,
            //  unreserve the clusters, and reset the free cluster count.
            //

            if (AbnormalTermination()) {

                FatRemoveMcbEntry( Vcb, Mcb, 0, *ByteCount );

                FatLockFreeClusterBitMap( Vcb );

                //  Only clear bits if the bitmap window is the same.

                if (Window == Vcb->CurrentWindow) {

                    //  Both values (startingcluster and window->firstcluster) are
                    //  already biased by 2,  so will cancel,  so we need to add in the 2 again.

                    FatUnreserveClusters( IrpContext, Vcb,
                                          StartingCluster - Window->FirstCluster + 2,
                                          ClusterCount );
                }

                Window->ClustersFree += ClusterCount;
                Vcb->AllocationSupport.NumberOfFreeClusters += ClusterCount;

                FatUnlockFreeClusterBitMap( Vcb );
            }

            ExReleaseResourceLite(&Vcb->ChangeBitMapResource);
        }

    } else {

        //
        //  Note that Index is a zero-based window-relative number.  When appropriate
        //  it'll get converted into a true cluster number and put in Cluster, which
        //  will be a volume relative true cluster number.
        //
        
        ULONG Index;
        ULONG Cluster;
        ULONG CurrentVbo;
        ULONG PriorLastCluster;
        ULONG BytesFound;

        ULONG ClustersFound = 0;
        ULONG ClustersRemaining;

        BOOLEAN LockedBitMap = FALSE;
        BOOLEAN SelectNextContigWindow = FALSE;

        //
        //  Drop our shared lock on the ChangeBitMapResource,  and pick it up again
        //  exclusive in preparation for making a window swap.
        //
        
        FatUnlockFreeClusterBitMap(Vcb);
        ExReleaseResourceLite(&Vcb->ChangeBitMapResource);
        ExAcquireResourceExclusiveLite(&Vcb->ChangeBitMapResource, TRUE);
        FatLockFreeClusterBitMap(Vcb);
        LockedBitMap = TRUE;

        try {

            if ( ExactMatchRequired && (1 == Vcb->NumberOfWindows))  {

                //
                //  Give up right now,  there are no more windows to search!  RtlFindClearBits
                //  searchs the whole bitmap,  so we would have found any contiguous run
                //  large enough.
                //

                try_leave( Result = FALSE);
            }

            //
            //  While the request is still incomplete, look for the largest
            //  run of free clusters, mark them taken, allocate the run in
            //  the Mcb and Fat, and if this isn't the first time through
            //  the loop link it to prior run on the fat.  The Mcb will
            //  coalesce automatically.
            //

            ClustersRemaining = ClusterCount;
            CurrentVbo = 0;
            PriorLastCluster = 0;

            while (ClustersRemaining != 0) {

                //
                //  If we just entered the loop, the bit map is already locked
                //

                if ( !LockedBitMap ) {

                    FatLockFreeClusterBitMap( Vcb );
                    LockedBitMap = TRUE;
                }

                //
                //  Find the largest run of free clusters.  If the run is
                //  bigger than we need, only use what we need.  Note that
                //  this will then be the last while() iteration.
                //

                // 12/3/95 - David Goebel: need to bias bitmap by 2 bits for the defrag
                // hooks and the below macro became impossible to do without in-line
                // procedures.
                //
                // ClustersFound = FatLongestFreeClusterRun( IrpContext, Vcb, &Index );

                ClustersFound = 0;

                if (!SelectNextContigWindow)  {

                    if ( 0 != WindowRelativeHint)  {

                        ULONG Desired = Vcb->FreeClusterBitMap.SizeOfBitMap - (WindowRelativeHint - 2);

                        //
                        //  We will try to allocate contiguously.  Try from the current hint the to
                        //  end of current window.  Don't try for more than we actually need.
                        //

                        if (Desired > ClustersRemaining)  {

                            Desired = ClustersRemaining;
                        }

                        if (RtlAreBitsClear(  &Vcb->FreeClusterBitMap,
                                              WindowRelativeHint - 2,
                                              Desired))
                        {
                            //
                            //  Clusters from hint->...windowend are free.  Take them.
                            //

                            Index = WindowRelativeHint - 2;
                            ClustersFound = Desired;

                            if (FatIsFat32(Vcb))  {

                                //
                                //  We're now up against the end of the current window,  so indicate that we
                                //  want the next window in the sequence next time around.  (If we're not up
                                //  against the end of the window,  then we got what we needed and won't be
                                //  coming around again anyway).
                                //

                                SelectNextContigWindow = TRUE;
                                WindowRelativeHint = 2;
                            }
                            else {

                                //
                                //  FAT 12/16 - we've run up against the end of the volume.  Clear the
                                //  hint,  since we now have no idea where to look.
                                //

                                WindowRelativeHint = 0;
                            }
#if DBG
                            PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );
#endif // DBG
                        }
                        else  {

                            if (ExactMatchRequired)  {

                                //
                                //  If our caller required an exact match,  then we're hosed.  Bail out now.
                                //

                                try_leave( Result = FALSE);
                            }

                            //
                            //  Hint failed,  drop back to pot luck
                            //

                            WindowRelativeHint = 0;
                        }
                    }

                    if ((0 == WindowRelativeHint) && (0 == ClustersFound)) {

                        if (ClustersRemaining <= Vcb->CurrentWindow->ClustersFree)  {
                        
                            //
                            //  The remaining allocation could be satisfied entirely from this 
                            //  window.  We will ask only for what we need,  to try and avoid
                            //  unnecessarily fragmenting large runs of space by always using 
                            //  (part of) the largest run we can find.  This call will return the
                            //  first run large enough.
                            //

                            Index = RtlFindClearBits( &Vcb->FreeClusterBitMap,  ClustersRemaining,  0);

                            if (-1 != Index)  {
                            
                                ClustersFound = ClustersRemaining;
                            }
                        }

                        if (0 == ClustersFound)  {
                            
                            //
                            //  Still nothing,  so just take the largest free run we can find.
                            //
                            
                            ClustersFound = RtlFindLongestRunClear( &Vcb->FreeClusterBitMap, &Index );
                            
                        }
#if DBG
                        PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );
#endif // DBG
                        if (ClustersFound >= ClustersRemaining) {

                            ClustersFound = ClustersRemaining;
                        }
                        else {

                            //
                            //  If we just ran up to the end of a window,  set up a hint that
                            //  we'd like the next consecutive window after this one. (FAT32 only)
                            //

                            if ( ((Index + ClustersFound) == Vcb->FreeClusterBitMap.SizeOfBitMap) &&
                                 FatIsFat32( Vcb)
                               )  {

                                SelectNextContigWindow = TRUE;
                                WindowRelativeHint = 2;
                            }
                        }
                    }
                }

                if (ClustersFound == 0) {

                    ULONG FaveWindow = 0;
                    BOOLEAN SelectedWindow;

                    //
                    //  If we found no free clusters on a single-window FAT,
                    //  there was a bad problem with the free cluster count.
                    //

                    if (1 == Vcb->NumberOfWindows) {

                        FatBugCheck( 0, 5, 0 );
                    }

                    //
                    //  Switch to a new bucket.  Possibly the next one if we're
                    //  currently on a roll (allocating contiguously)
                    //

                    SelectedWindow = FALSE;

                    if ( SelectNextContigWindow)  {

                        ULONG NextWindow;

                        NextWindow = (((ULONG)((PUCHAR)Vcb->CurrentWindow - (PUCHAR)Vcb->Windows)) / sizeof( FAT_WINDOW)) + 1;

                        if ((NextWindow < Vcb->NumberOfWindows) &&
                            ( Vcb->Windows[ NextWindow].ClustersFree > 0)
                           )  {

                            FaveWindow = NextWindow;
                            SelectedWindow = TRUE;                            
                        }
                        else  {

                            if (ExactMatchRequired)  {

                                //
                                //  Some dope tried to allocate a run past the end of the volume...
                                //

                                try_leave( Result = FALSE);
                            }

                            //
                            //  Give up on the contiguous allocation attempts
                            //

                            WindowRelativeHint = 0;
                        }

                        SelectNextContigWindow = FALSE;
                    }

                    if (!SelectedWindow)  {

                        //
                        //  Select a new window to begin allocating from
                        //
                        
                        FaveWindow = FatSelectBestWindow( Vcb);
                    }

                    //
                    //  By now we'd better have found a window with some free clusters
                    //

                    if (0 == Vcb->Windows[ FaveWindow].ClustersFree) {

                        FatBugCheck( 0, 5, 1 );
                    }

                    Wait = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
                    SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);

                    FatExamineFatEntries( IrpContext, Vcb,
                                          0,
                                          0,
                                          FALSE,
                                          &Vcb->Windows[FaveWindow],
                                          NULL);

                    if (!Wait) {

                        ClearFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
                    }

                    //
                    //  Now we'll just go around the loop again, having switched windows,
                    //  and allocate....
                    //
#if DBG
                    PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );
#endif //DBG
                }       // if (clustersfound == 0)
                else  {

                    //
                    //  Take the clusters we found, convert our index to a cluster number
                    //  and unlock the bit map.
                    //

                    Window = Vcb->CurrentWindow;

                    FatReserveClusters( IrpContext, Vcb, (Index + 2), ClustersFound );

                    Cluster = Index + Window->FirstCluster;
                    
                    Window->ClustersFree -= ClustersFound;
                    ASSERT( PreviousClear - ClustersFound == Window->ClustersFree );

                    FatUnlockFreeClusterBitMap( Vcb );
                    LockedBitMap = FALSE;

                    //
                    //  Add the newly alloced run to the Mcb.
                    //

                    BytesFound = ClustersFound << LogOfBytesPerCluster;

                    FatAddMcbEntry( Vcb, Mcb,
                                    CurrentVbo,
                                    FatGetLboFromIndex( Vcb, Cluster ),
                                    BytesFound );

                    //
                    //  Connect the last allocated run with this one, and allocate
                    //  this run on the Fat.
                    //

                    if (PriorLastCluster != 0) {

                        FatSetFatEntry( IrpContext,
                                        Vcb,
                                        PriorLastCluster,
                                        (FAT_ENTRY)Cluster );
                    }

                    //
                    //  Update the fat
                    //

                    FatAllocateClusters( IrpContext, Vcb, Cluster, ClustersFound );

                    //
                    //  Prepare for the next iteration.
                    //

                    CurrentVbo += BytesFound;
                    ClustersRemaining -= ClustersFound;
                    PriorLastCluster = Cluster + ClustersFound - 1;
                }
            }  // while (clustersremaining)

        } finally {

            DebugUnwind( FatAllocateDiskSpace );

            ExReleaseResourceLite(&Vcb->ChangeBitMapResource);

            //
            //  Is there any unwinding to do?
            //

            if ( AbnormalTermination() || (FALSE == Result)) {

                //
                //  Flag to the caller that they're getting nothing
                //

                *ByteCount = 0;

                //
                //  There are three places we could have taken this exception:
                //  when switching the window (FatExamineFatEntries), adding
                //  a found run to the Mcb (FatAddMcbEntry), or when writing
                //  the changes to the FAT (FatSetFatEntry).  In the first case
                //  we don't have anything to unwind before deallocation, and
                //  can detect this by seeing if we have the ClusterBitmap
                //  mutex out.

                if (!LockedBitMap) {

                    FatLockFreeClusterBitMap( Vcb );

                    //
                    //  In these cases, we have the possiblity that the FAT
                    //  window is still in place and we need to clear the bits.
                    //  If the Mcb entry isn't there (we raised trying to add
                    //  it), the effect of trying to remove it is a noop.
                    //

                    if (Window == Vcb->CurrentWindow) {

                        //
                        //  Cluster reservation works on cluster 2 based window-relative
                        //  numbers, so we must convert.  The subtraction will lose the
                        //  cluster 2 base, so bias the result.
                        //

                        FatUnreserveClusters( IrpContext, Vcb,
                                              (Cluster - Window->FirstCluster) + 2,
                                              ClustersFound );
                    }

                    //
                    //  Note that FatDeallocateDiskSpace will take care of adjusting
                    //  to account for the entries in the Mcb.  All we have to account
                    //  for is the last run that didn't make it.
                    //

                    Window->ClustersFree += ClustersFound;
                    Vcb->AllocationSupport.NumberOfFreeClusters += ClustersFound;

                    FatUnlockFreeClusterBitMap( Vcb );

                    FatRemoveMcbEntry( Vcb, Mcb, CurrentVbo, BytesFound );

                } else {

                    //
                    //  Just drop the mutex now - we didn't manage to do anything
                    //  that needs to be backed out.
                    //

                    FatUnlockFreeClusterBitMap( Vcb );
                }

                try {

                    //
                    //  Now we have tidied up, we are ready to just send the Mcb
                    //  off to deallocate disk space
                    //

                    FatDeallocateDiskSpace( IrpContext, Vcb, Mcb );

                } finally {

                    //
                    //  Now finally (really), remove all the entries from the mcb
                    //

                    FatRemoveMcbEntry( Vcb, Mcb, 0, 0xFFFFFFFF );
                }
            }

            DebugTrace(-1, Dbg, "FatAllocateDiskSpace -> (VOID)\n", 0);

        } // finally
    }

    return;
}


VOID
FatDeallocateDiskSpace (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PLARGE_MCB Mcb
    )

/*++

Routine Description:

    This procedure deallocates the disk space denoted by an input
    mcb.  Note that the input MCB does not need to necessarily describe
    a chain that ends with a FAT_CLUSTER_LAST entry.

    Pictorially what is done is the following

        Fat |--a--|--b--|--c--|
        Mcb |--a--|--b--|--c--|

    becomes

        Fat |--0--|--0--|--0--|
        Mcb |--a--|--b--|--c--|

Arguments:

    Vcb - Supplies the VCB being modified

    Mcb - Supplies the MCB describing the disk space to deallocate.  Note
          that Mcb is unchanged by this procedure.


Return Value:

    None.

--*/

{
    LBO Lbo;
    VBO Vbo;

    ULONG RunsInMcb;
    ULONG ByteCount;
    ULONG ClusterCount = 0;
    ULONG ClusterIndex = 0;
    ULONG McbIndex;

    UCHAR LogOfBytesPerCluster;

    PFAT_WINDOW Window;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatDeallocateDiskSpace\n", 0);
    DebugTrace( 0, Dbg, "  Vcb = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  Mcb = %8lx\n", Mcb);

    LogOfBytesPerCluster = Vcb->AllocationSupport.LogOfBytesPerCluster;

    RunsInMcb = FsRtlNumberOfRunsInLargeMcb( Mcb );

    if ( RunsInMcb == 0 ) {

        DebugTrace(-1, Dbg, "FatDeallocateDiskSpace -> (VOID)\n", 0);
        return;
    }

    try {

        //
        //  Run though the Mcb, freeing all the runs in the fat.
        //
        //  We do this in two steps (first update the fat, then the bitmap
        //  (which can't fail)) to prevent other people from taking clusters
        //  that we need to re-allocate in the event of unwind.
        //

        ExAcquireResourceSharedLite(&Vcb->ChangeBitMapResource, TRUE);

        RunsInMcb = FsRtlNumberOfRunsInLargeMcb( Mcb );

        for ( McbIndex = 0; McbIndex < RunsInMcb; McbIndex++ ) {

            FatGetNextMcbEntry( Vcb, Mcb, McbIndex, &Vbo, &Lbo, &ByteCount );

            //
            //  Assert that Fat files have no holes.
            //

            ASSERT( Lbo != 0 );

            //
            //  Write FAT_CLUSTER_AVAILABLE to each cluster in the run.
            //

            ClusterCount = ByteCount >> LogOfBytesPerCluster;
            ClusterIndex = FatGetIndexFromLbo( Vcb, Lbo );

            FatFreeClusters( IrpContext, Vcb, ClusterIndex, ClusterCount );
        }

        //
        //  From now on, nothing can go wrong .... (as in raise)
        //

        FatLockFreeClusterBitMap( Vcb );

        for ( McbIndex = 0; McbIndex < RunsInMcb; McbIndex++ ) {

            ULONG ClusterEnd;
            ULONG MyStart, MyLength, count;
#if DBG
            ULONG PreviousClear, i;
#endif

            FatGetNextMcbEntry( Vcb, Mcb, McbIndex, &Vbo, &Lbo, &ByteCount );

            //
            //  Mark the bits clear in the FreeClusterBitMap.
            //

            ClusterCount = ByteCount >> LogOfBytesPerCluster;
            ClusterIndex = FatGetIndexFromLbo( Vcb, Lbo );

            Window = Vcb->CurrentWindow;

            //
            //  If we've divided the bitmap, elide bitmap manipulation for
            //  runs that are outside the current bucket.
            //

            ClusterEnd = ClusterIndex + ClusterCount - 1;

            if (!(ClusterIndex > Window->LastCluster ||
                  ClusterEnd  < Window->FirstCluster)) {

                //
                //  The run being freed overlaps the current bucket, so we'll
                //  have to clear some bits.
                //

                if (ClusterIndex < Window->FirstCluster &&
                    ClusterEnd > Window->LastCluster) {

                    MyStart = Window->FirstCluster;
                    MyLength = Window->LastCluster - Window->FirstCluster + 1;

                } else if (ClusterIndex < Window->FirstCluster) {

                    MyStart = Window->FirstCluster;
                    MyLength = ClusterEnd - Window->FirstCluster + 1;

                } else {

                    //
                    //  The range being freed starts in the bucket, and may possibly
                    //  extend beyond the bucket.
                    //

                    MyStart = ClusterIndex;

                    if (ClusterEnd <= Window->LastCluster) {

                        MyLength = ClusterCount;

                    } else {

                        MyLength = Window->LastCluster - ClusterIndex + 1;
                    }
                }

                if (MyLength == 0) {

                    continue;
                }

#if DBG
                PreviousClear = RtlNumberOfClearBits( &Vcb->FreeClusterBitMap );


                //
                //  Verify that the Bits are all really set.
                //

                ASSERT( MyStart + MyLength - Window->FirstCluster <= Vcb->FreeClusterBitMap.SizeOfBitMap );

                for (i = 0; i < MyLength; i++) {

                    ASSERT( RtlCheckBit(&Vcb->FreeClusterBitMap,
                            MyStart - Window->FirstCluster + i) == 1 );
                }
#endif // DBG

                FatUnreserveClusters( IrpContext, Vcb,
                                      MyStart - Window->FirstCluster + 2,
                                      MyLength );
            }

            //
            //  Adjust the ClustersFree count for each bitmap window, even the ones
            //  that are not the current window.
            //

            if (FatIsFat32(Vcb)) {

                Window = &Vcb->Windows[FatWindowOfCluster( ClusterIndex )];

            } else {

                Window = &Vcb->Windows[0];
            }

            MyStart = ClusterIndex;

            for (MyLength = ClusterCount; MyLength > 0; MyLength -= count) {

                count = FatMin(Window->LastCluster - MyStart + 1, MyLength);
                Window->ClustersFree += count;

                //
                //  If this was not the last window this allocation spanned,
                //  advance to the next.
                //

                if (MyLength != count) {

                    Window++;
                    MyStart = Window->FirstCluster;
                }
            }

            //
            //  Deallocation is now complete.  Adjust the free cluster count.
            //

            Vcb->AllocationSupport.NumberOfFreeClusters += ClusterCount;
        }

#if DBG
        if (Vcb->CurrentWindow->ClustersFree !=
               RtlNumberOfClearBits(&Vcb->FreeClusterBitMap)) {

            DbgPrint("%x vs %x\n",  Vcb->CurrentWindow->ClustersFree,
                RtlNumberOfClearBits(&Vcb->FreeClusterBitMap));

            DbgPrint("%x for %x\n", ClusterIndex, ClusterCount);
        }
#endif

        FatUnlockFreeClusterBitMap( Vcb );


    } finally {

        DebugUnwind( FatDeallocateDiskSpace );

        //
        //  Is there any unwinding to do?
        //

        ExReleaseResourceLite(&Vcb->ChangeBitMapResource);

        if ( AbnormalTermination() ) {

            LBO LocalLbo;
            VBO LocalVbo;

            ULONG Index;
            ULONG Clusters;
            ULONG FatIndex;
            ULONG PriorLastIndex;

            //
            //  For each entry we already deallocated, reallocate it,
            //  chaining together as nessecary.  Note that we continue
            //  up to and including the last "for" iteration even though
            //  the SetFatRun could not have been successful.  This
            //  allows us a convienent way to re-link the final successful
            //  SetFatRun.
            //
            //  It is possible that the reason we got here will prevent us
            //  from succeeding in this operation.
            //

            PriorLastIndex = 0;

            for (Index = 0; Index <= McbIndex; Index++) {

                FatGetNextMcbEntry(Vcb, Mcb, Index, &LocalVbo, &LocalLbo, &ByteCount);

                FatIndex = FatGetIndexFromLbo( Vcb, LocalLbo );
                Clusters = ByteCount >> LogOfBytesPerCluster;

                //
                //  We must always restore the prior iteration's last
                //  entry, pointing it to the first cluster of this run.
                //

                if (PriorLastIndex != 0) {

                    FatSetFatEntry( IrpContext,
                                    Vcb,
                                    PriorLastIndex,
                                    (FAT_ENTRY)FatIndex );
                }

                //
                //  If this is not the last entry (the one that failed)
                //  then reallocate the disk space on the fat.
                //

                if ( Index < McbIndex ) {

                    FatAllocateClusters(IrpContext, Vcb, FatIndex, Clusters);

                    PriorLastIndex = FatIndex + Clusters - 1;
                }
            }
        }

        DebugTrace(-1, Dbg, "FatDeallocateDiskSpace -> (VOID)\n", 0);
    }

    return;
}


VOID
FatSplitAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PLARGE_MCB Mcb,
    IN VBO SplitAtVbo,
    OUT PLARGE_MCB RemainingMcb
    )

/*++

Routine Description:

    This procedure takes a single mcb and splits its allocation into
    two separate allocation units.  The separation must only be done
    on cluster boundaries, otherwise we bugcheck.

    On the disk this actually works by inserting a FAT_CLUSTER_LAST into
    the last index of the first part being split out.

    Pictorially what is done is the following (where ! denotes the end of
    the fat chain (i.e., FAT_CLUSTER_LAST)):


        Mcb          |--a--|--b--|--c--|--d--|--e--|--f--|

                                        ^
        SplitAtVbo ---------------------+

        RemainingMcb (empty)

    becomes

        Mcb          |--a--|--b--|--c--!


        RemainingMcb |--d--|--e--|--f--|

Arguments:

    Vcb - Supplies the VCB being modified

    Mcb - Supplies the MCB describing the allocation being split into
          two parts.  Upon return this Mcb now contains the first chain.

    SplitAtVbo - Supplies the VBO of the first byte for the second chain
                 that we creating.

    RemainingMcb - Receives the MCB describing the second chain of allocated
                   disk space.  The caller passes in an initialized Mcb that
                   is filled in by this procedure STARTING AT VBO 0.

Return Value:

    VOID - TRUE if the operation completed and FALSE if it had to
               block but could not.

--*/

{
    VBO SourceVbo;
    VBO TargetVbo;
    VBO DontCare;

    LBO Lbo;

    ULONG ByteCount;
    ULONG BytesPerCluster;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatSplitAllocation\n", 0);
    DebugTrace( 0, Dbg, "  Vcb          = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  Mcb          = %8lx\n", Mcb);
    DebugTrace( 0, Dbg, "  SplitAtVbo   = %8lx\n", SplitAtVbo);
    DebugTrace( 0, Dbg, "  RemainingMcb = %8lx\n", RemainingMcb);

    BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

    //
    //  Assert that the split point is cluster alligned
    //

    ASSERT( (SplitAtVbo & (BytesPerCluster - 1)) == 0 );

    //
    //  We should never be handed an empty source MCB and asked to split
    //  at a non zero point.
    //

    ASSERT( !((0 != SplitAtVbo) && (0 == FsRtlNumberOfRunsInLargeMcb( Mcb))));

    //
    //  Assert we were given an empty target Mcb.
    //

    //
    //  This assert is commented out to avoid hitting in the Ea error
    //  path.  In that case we will be using the same Mcb's to split the
    //  allocation that we used to merge them.  The target Mcb will contain
    //  the runs that the split will attempt to insert.
    //
    //
    //  ASSERT( FsRtlNumberOfRunsInMcb( RemainingMcb ) == 0 );
    //

    try {

        //
        //  Move the runs after SplitAtVbo from the souce to the target
        //

        SourceVbo = SplitAtVbo;
        TargetVbo = 0;

        while (FatLookupMcbEntry(Vcb, Mcb, SourceVbo, &Lbo, &ByteCount, NULL)) {

            FatAddMcbEntry( Vcb, RemainingMcb, TargetVbo, Lbo, ByteCount );

            FatRemoveMcbEntry( Vcb, Mcb, SourceVbo, ByteCount );

            TargetVbo += ByteCount;
            SourceVbo += ByteCount;

            //
            //  If SourceVbo overflows, we were actually snipping off the end
            //  of the maximal file ... and are now done.
            //

            if (SourceVbo == 0) {

                break;
            }
        }

        //
        //  Mark the last pre-split cluster as a FAT_LAST_CLUSTER
        //

        if ( SplitAtVbo != 0 ) {

            FatLookupLastMcbEntry( Vcb, Mcb, &DontCare, &Lbo, NULL );

            FatSetFatEntry( IrpContext,
                            Vcb,
                            FatGetIndexFromLbo( Vcb, Lbo ),
                            FAT_CLUSTER_LAST );
        }

    } finally {

        DebugUnwind( FatSplitAllocation );

        //
        //  If we got an exception, we must glue back together the Mcbs
        //

        if ( AbnormalTermination() ) {

            TargetVbo = SplitAtVbo;
            SourceVbo = 0;

            while (FatLookupMcbEntry(Vcb, RemainingMcb, SourceVbo, &Lbo, &ByteCount, NULL)) {

                FatAddMcbEntry( Vcb, Mcb, TargetVbo, Lbo, ByteCount );

                FatRemoveMcbEntry( Vcb, RemainingMcb, SourceVbo, ByteCount );

                TargetVbo += ByteCount;
                SourceVbo += ByteCount;
            }
        }

        DebugTrace(-1, Dbg, "FatSplitAllocation -> (VOID)\n", 0);
    }

    return;
}


VOID
FatMergeAllocation (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN OUT PLARGE_MCB Mcb,
    IN PLARGE_MCB SecondMcb
    )

/*++

Routine Description:

    This routine takes two separate allocations described by two MCBs and
    joins them together into one allocation.

    Pictorially what is done is the following (where ! denotes the end of
    the fat chain (i.e., FAT_CLUSTER_LAST)):


        Mcb       |--a--|--b--|--c--!

        SecondMcb |--d--|--e--|--f--|

    becomes

        Mcb       |--a--|--b--|--c--|--d--|--e--|--f--|

        SecondMcb |--d--|--e--|--f--|


Arguments:

    Vcb - Supplies the VCB being modified

    Mcb - Supplies the MCB of the first allocation that is being modified.
          Upon return this Mcb will also describe the newly enlarged
          allocation

    SecondMcb - Supplies the ZERO VBO BASED MCB of the second allocation
                that is being appended to the first allocation.  This
                procedure leaves SecondMcb unchanged.

Return Value:

    VOID - TRUE if the operation completed and FALSE if it had to
        block but could not.

--*/

{
    VBO SpliceVbo;
    LBO SpliceLbo;

    VBO SourceVbo;
    VBO TargetVbo;

    LBO Lbo;

    ULONG ByteCount;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatMergeAllocation\n", 0);
    DebugTrace( 0, Dbg, "  Vcb       = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  Mcb       = %8lx\n", Mcb);
    DebugTrace( 0, Dbg, "  SecondMcb = %8lx\n", SecondMcb);

    try {

        //
        //  Append the runs from SecondMcb to Mcb
        //

        (void)FatLookupLastMcbEntry( Vcb, Mcb, &SpliceVbo, &SpliceLbo, NULL );

        SourceVbo = 0;
        TargetVbo = SpliceVbo + 1;

        while (FatLookupMcbEntry(Vcb, SecondMcb, SourceVbo, &Lbo, &ByteCount, NULL)) {

            FatAddMcbEntry( Vcb, Mcb, TargetVbo, Lbo, ByteCount );

            SourceVbo += ByteCount;
            TargetVbo += ByteCount;
        }

        //
        //  Link the last pre-merge cluster to the first cluster of SecondMcb
        //

        FatLookupMcbEntry( Vcb, SecondMcb, 0, &Lbo, (PULONG)NULL, NULL );

        FatSetFatEntry( IrpContext,
                        Vcb,
                        FatGetIndexFromLbo( Vcb, SpliceLbo ),
                        (FAT_ENTRY)FatGetIndexFromLbo( Vcb, Lbo ) );

    } finally {

        DebugUnwind( FatMergeAllocation );

        //
        //  If we got an exception, we must remove the runs added to Mcb
        //

        if ( AbnormalTermination() ) {

            ULONG CutLength;

            if ((CutLength = TargetVbo - (SpliceVbo + 1)) != 0) {

                FatRemoveMcbEntry( Vcb, Mcb, SpliceVbo + 1, CutLength);
            }
        }

        DebugTrace(-1, Dbg, "FatMergeAllocation -> (VOID)\n", 0);
    }

    return;
}


//
//  Internal support routine
//

CLUSTER_TYPE
FatInterpretClusterType (
    IN PVCB Vcb,
    IN FAT_ENTRY Entry
    )

/*++

Routine Description:

    This procedure tells the caller how to interpret the input fat table
    entry.  It will indicate if the fat cluster is available, resereved,
    bad, the last one, or the another fat index.  This procedure can deal
    with both 12 and 16 bit fat.

Arguments:

    Vcb - Supplies the Vcb to examine, yields 12/16 bit info

    Entry - Supplies the fat entry to examine

Return Value:

    CLUSTER_TYPE - Is the type of the input Fat entry

--*/

{
    DebugTrace(+1, Dbg, "InterpretClusterType\n", 0);
    DebugTrace( 0, Dbg, "  Vcb   = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  Entry = %8lx\n", Entry);

    PAGED_CODE();

    switch(Vcb->AllocationSupport.FatIndexBitSize ) {
    case 32:
        Entry &= FAT32_ENTRY_MASK;
        break;

    case 12:
        ASSERT( Entry <= 0xfff );
        if (Entry >= 0x0ff0) {
            Entry |= 0x0FFFF000;
        }
        break;

    default:
    case 16:
        ASSERT( Entry <= 0xffff );
        if (Entry >= 0x0fff0) {
            Entry |= 0x0FFF0000;
        }
        break;
    }

    if (Entry == FAT_CLUSTER_AVAILABLE) {

        DebugTrace(-1, Dbg, "FatInterpretClusterType -> FatClusterAvailable\n", 0);

        return FatClusterAvailable;

    } else if (Entry < FAT_CLUSTER_RESERVED) {

        DebugTrace(-1, Dbg, "FatInterpretClusterType -> FatClusterNext\n", 0);

        return FatClusterNext;

    } else if (Entry < FAT_CLUSTER_BAD) {

        DebugTrace(-1, Dbg, "FatInterpretClusterType -> FatClusterReserved\n", 0);

        return FatClusterReserved;

    } else if (Entry == FAT_CLUSTER_BAD) {

        DebugTrace(-1, Dbg, "FatInterpretClusterType -> FatClusterBad\n", 0);

        return FatClusterBad;

    } else {

        DebugTrace(-1, Dbg, "FatInterpretClusterType -> FatClusterLast\n", 0);

        return FatClusterLast;
    }
}


//
//  Internal support routine
//

VOID
FatLookupFatEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FatIndex,
    IN OUT PULONG FatEntry,
    IN OUT PFAT_ENUMERATION_CONTEXT Context
    )

/*++

Routine Description:

    This routine takes an index into the fat and gives back the value
    in the Fat at this index.  At any given time, for a 16 bit fat, this
    routine allows only one page per volume of the fat to be pinned in
    memory.  For a 12 bit bit fat, the entire fat (max 6k) is pinned.  This
    extra layer of caching makes the vast majority of requests very
    fast.  The context for this caching stored in a structure in the Vcb.

Arguments:

    Vcb - Supplies the Vcb to examine, yields 12/16 bit info,
          fat access context, etc.

    FatIndex - Supplies the fat index to examine.

    FatEntry - Receives the fat entry pointed to by FatIndex.  Note that
               it must point to non-paged pool.

    Context - This structure keeps track of a page of pinned fat between calls.

--*/

{
    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatLookupFatEntry\n", 0);
    DebugTrace( 0, Dbg, "  Vcb      = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  FatIndex = %4x\n", FatIndex);
    DebugTrace( 0, Dbg, "  FatEntry = %8lx\n", FatEntry);

    //
    //  Make sure they gave us a valid fat index.
    //

    FatVerifyIndexIsValid(IrpContext, Vcb, FatIndex);

    //
    //  Case on 12 or 16 bit fats.
    //
    //  In the 12 bit case (mostly floppies) we always have the whole fat
    //  (max 6k bytes) pinned during allocation operations.  This is possibly
    //  a wee bit slower, but saves headaches over fat entries with 8 bits
    //  on one page, and 4 bits on the next.
    //
    //  The 16 bit case always keeps the last used page pinned until all
    //  operations are done and it is unpinned.
    //

    //
    //  DEAL WITH 12 BIT CASE
    //

    if (Vcb->AllocationSupport.FatIndexBitSize == 12) {

        //
        //  Check to see if the fat is already pinned, otherwise pin it.
        //

        if (Context->Bcb == NULL) {

            FatReadVolumeFile( IrpContext,
                               Vcb,
                               FatReservedBytes( &Vcb->Bpb ),
                               FatBytesPerFat( &Vcb->Bpb ),
                               &Context->Bcb,
                               &Context->PinnedPage );
        }

        //
        //  Load the return value.
        //


        FatLookup12BitEntry( Context->PinnedPage, FatIndex, FatEntry );

    } else if (Vcb->AllocationSupport.FatIndexBitSize == 32) {

        //
        //  DEAL WITH 32 BIT CASE
        //

        ULONG PageEntryOffset;
        ULONG OffsetIntoVolumeFile;

        //
        //  Initialize two local variables that help us.
        //
        OffsetIntoVolumeFile = FatReservedBytes(&Vcb->Bpb) + FatIndex * sizeof(FAT_ENTRY);
        PageEntryOffset = (OffsetIntoVolumeFile % PAGE_SIZE) / sizeof(FAT_ENTRY);

        //
        //  Check to see if we need to read in a new page of fat
        //

        if ((Context->Bcb == NULL) ||
            (OffsetIntoVolumeFile / PAGE_SIZE != Context->VboOfPinnedPage / PAGE_SIZE)) {

            //
            //  The entry wasn't in the pinned page, so must we unpin the current
            //  page (if any) and read in a new page.
            //

            FatUnpinBcb( IrpContext, Context->Bcb );

            FatReadVolumeFile( IrpContext,
                               Vcb,
                               OffsetIntoVolumeFile & ~(PAGE_SIZE - 1),
                               PAGE_SIZE,
                               &Context->Bcb,
                               &Context->PinnedPage );

            Context->VboOfPinnedPage = OffsetIntoVolumeFile & ~(PAGE_SIZE - 1);
        }

        //
        //  Grab the fat entry from the pinned page, and return
        //

        *FatEntry = ((PULONG)(Context->PinnedPage))[PageEntryOffset] & FAT32_ENTRY_MASK;

    } else {

        //
        //  DEAL WITH 16 BIT CASE
        //

        ULONG PageEntryOffset;
        ULONG OffsetIntoVolumeFile;

        //
        //  Initialize two local variables that help us.
        //

        OffsetIntoVolumeFile = FatReservedBytes(&Vcb->Bpb) + FatIndex * sizeof(USHORT);
        PageEntryOffset = (OffsetIntoVolumeFile % PAGE_SIZE) / sizeof(USHORT);

        //
        //  Check to see if we need to read in a new page of fat
        //

        if ((Context->Bcb == NULL) ||
            (OffsetIntoVolumeFile / PAGE_SIZE != Context->VboOfPinnedPage / PAGE_SIZE)) {

            //
            //  The entry wasn't in the pinned page, so must we unpin the current
            //  page (if any) and read in a new page.
            //

            FatUnpinBcb( IrpContext, Context->Bcb );

            FatReadVolumeFile( IrpContext,
                               Vcb,
                               OffsetIntoVolumeFile & ~(PAGE_SIZE - 1),
                               PAGE_SIZE,
                               &Context->Bcb,
                               &Context->PinnedPage );

            Context->VboOfPinnedPage = OffsetIntoVolumeFile & ~(PAGE_SIZE - 1);
        }

        //
        //  Grab the fat entry from the pinned page, and return
        //

        *FatEntry = ((PUSHORT)(Context->PinnedPage))[PageEntryOffset];
    }

    DebugTrace(-1, Dbg, "FatLookupFatEntry -> (VOID)\n", 0);
    return;
}


VOID
FatSetFatEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FatIndex,
    IN FAT_ENTRY FatEntry
    )

/*++

Routine Description:

    This routine takes an index into the fat and puts a value in the Fat
    at this index.  The routine special cases 12, 16 and 32 bit fats.  In
    all cases we go to the cache manager for a piece of the fat.

    We have a special form of this call for setting the DOS-style dirty bit.
    Unlike the dirty bit in the boot sector, we do not go to special effort
    to make sure that this hits the disk synchronously - if the system goes
    down in the window between the dirty bit being set in the boot sector
    and the FAT index zero dirty bit being lazy written, then life is tough.

    The only possible scenario is that Win9x may see what it thinks is a clean
    volume that really isn't (hopefully Memphis will pay attention to our dirty
    bit as well). The dirty bit will get out quickly, and if heavy activity is
    occurring, then the dirty bit should actually be there virtually all of the
    time since the act of cleaning the volume is the "rare" occurance.

    There are synchronization concerns that would crop up if we tried to make
    this synchronous. This thread may already own the Bcb shared for the first
    sector of the FAT (so we can't get it exclusive for a writethrough). This
    would require some more serious replumbing to work around than I want to
    consider at this time.

    We can and do, however, synchronously set the bit clean.

    At this point the reader should understand why the NT dirty bit is where it is.

Arguments:

    Vcb - Supplies the Vcb to examine, yields 12/16/32 bit info, etc.

    FatIndex - Supplies the destination fat index.

    FatEntry - Supplies the source fat entry.

--*/

{
    LBO Lbo;
    PBCB Bcb = NULL;
    ULONG SectorSize;
    ULONG OffsetIntoVolumeFile;
    ULONG WasWait = TRUE;
    BOOLEAN RegularOperation = TRUE;
    BOOLEAN CleaningOperation = FALSE;
    BOOLEAN ReleaseMutex = FALSE;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatSetFatEntry\n", 0);
    DebugTrace( 0, Dbg, "  Vcb      = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  FatIndex = %4x\n", FatIndex);
    DebugTrace( 0, Dbg, "  FatEntry = %4x\n", FatEntry);

    //
    //  Make sure they gave us a valid fat index if this isn't the special
    //  clean-bit modifying call.
    //

    if (FatIndex == FAT_DIRTY_BIT_INDEX) {

        //
        //  We are setting the clean bit state.  Of course, we could
        //  have corruption that would cause us to try to fiddle the
        //  reserved index - we guard against this by having the
        //  special entry values use the reserved high 4 bits that
        //  we know that we'll never try to set.
        //

        //
        //  We don't want to repin the FAT pages involved here.  Just
        //  let the lazy writer hit them when it can.
        //

        RegularOperation = FALSE;

        switch (FatEntry) {
            case FAT_CLEAN_VOLUME:
                FatEntry = FAT_CLEAN_ENTRY;
                CleaningOperation = TRUE;
                break;

            case FAT_DIRTY_VOLUME:
                switch (Vcb->AllocationSupport.FatIndexBitSize) {
                    case 12:
                        FatEntry = FAT12_DIRTY_ENTRY;
                        break;

                    case 32:
                        FatEntry = FAT32_DIRTY_ENTRY;
                        break;

                    default:
                        FatEntry = FAT16_DIRTY_ENTRY;
                        break;
                }
                break;

            default:
                FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                break;
        }

        //
        //  Disable dirtying semantics for the duration of this operation.  Force this
        //  operation to wait for the duration.
        //

        WasWait = FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT | IRP_CONTEXT_FLAG_DISABLE_DIRTY );

    } else {

        ASSERT( !(FatEntry & ~FAT32_ENTRY_MASK) );
        FatVerifyIndexIsValid(IrpContext, Vcb, FatIndex);
    }

    //
    //  Set Sector Size
    //

    SectorSize = 1 << Vcb->AllocationSupport.LogOfBytesPerSector;

    //
    //  Case on 12 or 16 bit fats.
    //
    //  In the 12 bit case (mostly floppies) we always have the whole fat
    //  (max 6k bytes) pinned during allocation operations.  This is possibly
    //  a wee bit slower, but saves headaches over fat entries with 8 bits
    //  on one page, and 4 bits on the next.
    //
    //  In the 16 bit case we only read the page that we need to set the fat
    //  entry.
    //

    //
    //  DEAL WITH 12 BIT CASE
    //

    try {

        if (Vcb->AllocationSupport.FatIndexBitSize == 12) {

            PVOID PinnedFat;

            //
            //  Make sure we have a valid entry
            //

            FatEntry &= 0xfff;

            //
            //  We read in the entire fat.  Note that using prepare write marks
            //  the bcb pre-dirty, so we don't have to do it explicitly.
            //

            OffsetIntoVolumeFile = FatReservedBytes( &Vcb->Bpb ) + FatIndex * 3 / 2;

            FatPrepareWriteVolumeFile( IrpContext,
                                       Vcb,
                                       FatReservedBytes( &Vcb->Bpb ),
                                       FatBytesPerFat( &Vcb->Bpb ),
                                       &Bcb,
                                       &PinnedFat,
                                       RegularOperation,
                                       FALSE );

            //
            //  Mark the sector(s) dirty in the DirtyFatMcb.  This call is
            //  complicated somewhat for the 12 bit case since a single
            //  entry write can span two sectors (and pages).
            //
            //  Get the Lbo for the sector where the entry starts, and add it to
            //  the dirty fat Mcb.
            //

            Lbo = OffsetIntoVolumeFile & ~(SectorSize - 1);

            FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb, (VBO) Lbo, Lbo, SectorSize);

            //
            //  If the entry started on the last byte of the sector, it continues
            //  to the next sector, so mark the next sector dirty as well.
            //
            //  Note that this entry will simply coalese with the last entry,
            //  so this operation cannot fail.  Also if we get this far, we have
            //  made it, so no unwinding will be needed.
            //

            if ( (OffsetIntoVolumeFile & (SectorSize - 1)) == (SectorSize - 1) ) {

                Lbo += SectorSize;

                FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb, (VBO) Lbo, Lbo, SectorSize );
            }

            //
            //  Store the entry into the fat; we need a little synchonization
            //  here and can't use a spinlock since the bytes might not be
            //  resident.
            //

            FatLockFreeClusterBitMap( Vcb );
            ReleaseMutex = TRUE;

            FatSet12BitEntry( PinnedFat, FatIndex, FatEntry );

            FatUnlockFreeClusterBitMap( Vcb );
            ReleaseMutex = FALSE;

        } else if (Vcb->AllocationSupport.FatIndexBitSize == 32) {

            //
            //  DEAL WITH 32 BIT CASE
            //

            PULONG PinnedFatEntry32;

            //
            //  Read in a new page of fat
            //

            OffsetIntoVolumeFile = FatReservedBytes( &Vcb->Bpb ) +
                                   FatIndex * sizeof( FAT_ENTRY );

            FatPrepareWriteVolumeFile( IrpContext,
                                       Vcb,
                                       OffsetIntoVolumeFile,
                                       sizeof(FAT_ENTRY),
                                       &Bcb,
                                       (PVOID *)&PinnedFatEntry32,
                                       RegularOperation,
                                       FALSE );
            //
            //  Mark the sector dirty in the DirtyFatMcb
            //

            Lbo = OffsetIntoVolumeFile & ~(SectorSize - 1);

            FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb, (VBO) Lbo, Lbo, SectorSize);

            //
            //  Store the FatEntry to the pinned page.
            //
            //  Preserve the reserved bits in FAT32 entries in the file heap.
            //

#ifdef ALPHA
            FatLockFreeClusterBitMap( Vcb );
            ReleaseMutex = TRUE;
#endif // ALPHA

            if (FatIndex != FAT_DIRTY_BIT_INDEX) {

                *PinnedFatEntry32 = ((*PinnedFatEntry32 & ~FAT32_ENTRY_MASK) | FatEntry);

            } else {

                *PinnedFatEntry32 = FatEntry;
            }

#ifdef ALPHA
            FatUnlockFreeClusterBitMap( Vcb );
            ReleaseMutex = FALSE;
#endif // ALPHA

        } else {

            //
            //  DEAL WITH 16 BIT CASE
            //

            PUSHORT PinnedFatEntry;

            //
            //  Read in a new page of fat
            //

            OffsetIntoVolumeFile = FatReservedBytes( &Vcb->Bpb ) +
                                   FatIndex * sizeof(USHORT);

            FatPrepareWriteVolumeFile( IrpContext,
                                       Vcb,
                                       OffsetIntoVolumeFile,
                                       sizeof(USHORT),
                                       &Bcb,
                                       (PVOID *)&PinnedFatEntry,
                                       RegularOperation,
                                       FALSE );
            //
            //  Mark the sector dirty in the DirtyFatMcb
            //

            Lbo = OffsetIntoVolumeFile & ~(SectorSize - 1);

            FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb, (VBO) Lbo, Lbo, SectorSize);

            //
            //  Store the FatEntry to the pinned page.
            //
            //  We need extra synchronization here for broken architectures
            //  like the ALPHA that don't support atomic 16 bit writes.
            //

#ifdef ALPHA
            FatLockFreeClusterBitMap( Vcb );
            ReleaseMutex = TRUE;
#endif // ALPHA

            *PinnedFatEntry = (USHORT)FatEntry;

#ifdef ALPHA
            FatUnlockFreeClusterBitMap( Vcb );
            ReleaseMutex = FALSE;
#endif // ALPHA
        }

    } finally {

        DebugUnwind( FatSetFatEntry );

        //
        //  Re-enable volume dirtying in case this was a dirty bit operation.
        //

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_DIRTY );

        //
        //  Make this operation asynchronous again if needed.
        //

        if (!WasWait) {

            ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
        }

        //
        //  If we still somehow have the Mutex, release it.
        //

        if (ReleaseMutex) {

            ASSERT( AbnormalTermination() );

            FatUnlockFreeClusterBitMap( Vcb );
        }

        //
        //  Unpin the Bcb.  For cleaning operations, we make this write-through.
        //

        if (CleaningOperation && Bcb) {

            IO_STATUS_BLOCK IgnoreStatus;

            CcRepinBcb( Bcb );
            CcUnpinData( Bcb );
            DbgDoit( IrpContext->PinCount -= 1 );
            CcUnpinRepinnedBcb( Bcb, TRUE, &IgnoreStatus );

        } else {

            FatUnpinBcb(IrpContext, Bcb);
        }

        DebugTrace(-1, Dbg, "FatSetFatEntry -> (VOID)\n", 0);
    }

    return;
}


//
//  Internal support routine
//

VOID
FatSetFatRun (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG StartingFatIndex,
    IN ULONG ClusterCount,
    IN BOOLEAN ChainTogether
    )

/*++

Routine Description:

    This routine sets a continuous run of clusters in the fat.  If ChainTogether
    is TRUE, then the clusters are linked together as in normal Fat fasion,
    with the last cluster receiving FAT_CLUSTER_LAST.  If ChainTogether is
    FALSE, all the entries are set to FAT_CLUSTER_AVAILABLE, effectively
    freeing all the clusters in the run.

Arguments:

    Vcb - Supplies the Vcb to examine, yields 12/16 bit info, etc.

    StartingFatIndex - Supplies the destination fat index.

    ClusterCount - Supplies the number of contiguous clusters to work on.

    ChainTogether - Tells us whether to fill the entries with links, or
                    FAT_CLUSTER_AVAILABLE


Return Value:

    VOID

--*/

{
#define MAXCOUNTCLUS 0x10000
#define COUNTSAVEDBCBS ((MAXCOUNTCLUS * sizeof(FAT_ENTRY) / PAGE_SIZE) + 2)
    PBCB SavedBcbs[COUNTSAVEDBCBS][2];

    ULONG SectorSize;
    ULONG Cluster;

    LBO StartSectorLbo;
    LBO FinalSectorLbo;
    LBO Lbo;

    PVOID PinnedFat;

    ULONG StartingPage;

    BOOLEAN ReleaseMutex = FALSE;

    ULONG SavedStartingFatIndex = StartingFatIndex;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatSetFatRun\n", 0);
    DebugTrace( 0, Dbg, "  Vcb              = %8lx\n", Vcb);
    DebugTrace( 0, Dbg, "  StartingFatIndex = %8x\n", StartingFatIndex);
    DebugTrace( 0, Dbg, "  ClusterCount     = %8lx\n", ClusterCount);
    DebugTrace( 0, Dbg, "  ChainTogether    = %s\n", ChainTogether ? "TRUE":"FALSE");

    //
    //  Make sure they gave us a valid fat run.
    //

    FatVerifyIndexIsValid(IrpContext, Vcb, StartingFatIndex);
    FatVerifyIndexIsValid(IrpContext, Vcb, StartingFatIndex + ClusterCount - 1);

    //
    //  Check special case
    //

    if (ClusterCount == 0) {

        DebugTrace(-1, Dbg, "FatSetFatRun -> (VOID)\n", 0);
        return;
    }

    //
    //  Set Sector Size
    //

    SectorSize = 1 << Vcb->AllocationSupport.LogOfBytesPerSector;

    //
    //  Case on 12 or 16 bit fats.
    //
    //  In the 12 bit case (mostly floppies) we always have the whole fat
    //  (max 6k bytes) pinned during allocation operations.  This is possibly
    //  a wee bit slower, but saves headaches over fat entries with 8 bits
    //  on one page, and 4 bits on the next.
    //
    //  In the 16 bit case we only read one page at a time, as needed.
    //

    //
    //  DEAL WITH 12 BIT CASE
    //

    try {

        if (Vcb->AllocationSupport.FatIndexBitSize == 12) {

            StartingPage = 0;

            //
            //  We read in the entire fat.  Note that using prepare write marks
            //  the bcb pre-dirty, so we don't have to do it explicitly.
            //

            RtlZeroMemory( &SavedBcbs[0][0], 2 * sizeof(PBCB) * 2);

            FatPrepareWriteVolumeFile( IrpContext,
                                       Vcb,
                                       FatReservedBytes( &Vcb->Bpb ),
                                       FatBytesPerFat( &Vcb->Bpb ),
                                       &SavedBcbs[0][0],
                                       &PinnedFat,
                                       TRUE,
                                       FALSE );

            //
            //  Mark the affected sectors dirty.  Note that FinalSectorLbo is
            //  the Lbo of the END of the entry (Thus * 3 + 2).  This makes sure
            //  we catch the case of a dirty fat entry straddling a sector boundry.
            //
            //  Note that if the first AddMcbEntry succeeds, all following ones
            //  will simply coalese, and thus also succeed.
            //

            StartSectorLbo = (FatReservedBytes( &Vcb->Bpb ) + StartingFatIndex * 3 / 2)
                             & ~(SectorSize - 1);

            FinalSectorLbo = (FatReservedBytes( &Vcb->Bpb ) + ((StartingFatIndex +
                             ClusterCount) * 3 + 2) / 2) & ~(SectorSize - 1);

            for (Lbo = StartSectorLbo; Lbo <= FinalSectorLbo; Lbo += SectorSize) {

                FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb, (VBO) Lbo, Lbo, SectorSize );
            }

            //
            //  Store the entries into the fat; we need a little
            //  synchonization here and can't use a spinlock since the bytes
            //  might not be resident.
            //

            FatLockFreeClusterBitMap( Vcb );
            ReleaseMutex = TRUE;

            for (Cluster = StartingFatIndex;
                 Cluster < StartingFatIndex + ClusterCount - 1;
                 Cluster++) {

                FatSet12BitEntry( PinnedFat,
                                  Cluster,
                                  ChainTogether ? Cluster + 1 : FAT_CLUSTER_AVAILABLE );
            }

            //
            //  Save the last entry
            //

            FatSet12BitEntry( PinnedFat,
                              Cluster,
                              ChainTogether ?
                              FAT_CLUSTER_LAST & 0xfff : FAT_CLUSTER_AVAILABLE );

            FatUnlockFreeClusterBitMap( Vcb );
            ReleaseMutex = FALSE;

        } else if (Vcb->AllocationSupport.FatIndexBitSize == 32) {

            //
            //  DEAL WITH 32 BIT CASE
            //

            for (;;) {

                VBO StartOffsetInVolume;
                VBO FinalOffsetInVolume;

                ULONG Page;
                ULONG FinalCluster;
                PULONG FatEntry;
                ULONG ClusterCountThisRun;

                StartOffsetInVolume = FatReservedBytes(&Vcb->Bpb) +
                                            StartingFatIndex * sizeof(FAT_ENTRY);

                if (ClusterCount > MAXCOUNTCLUS) {
                    ClusterCountThisRun = MAXCOUNTCLUS;
                } else {
                    ClusterCountThisRun = ClusterCount;
                }

                FinalOffsetInVolume = StartOffsetInVolume +
                                            (ClusterCountThisRun -  1) * sizeof(FAT_ENTRY);

                StartingPage = StartOffsetInVolume / PAGE_SIZE;

                {
                    ULONG NumberOfPages;
                    ULONG Offset;

                    NumberOfPages = (FinalOffsetInVolume / PAGE_SIZE) -
                                    (StartOffsetInVolume / PAGE_SIZE) + 1;

                    RtlZeroMemory( &SavedBcbs[0][0], (NumberOfPages + 1) * sizeof(PBCB) * 2 );

                    for ( Page = 0, Offset = StartOffsetInVolume & ~(PAGE_SIZE - 1);
                          Page < NumberOfPages;
                          Page++, Offset += PAGE_SIZE ) {

                        FatPrepareWriteVolumeFile( IrpContext,
                                                   Vcb,
                                                   Offset,
                                                   PAGE_SIZE,
                                                   &SavedBcbs[Page][0],
                                                   (PVOID *)&SavedBcbs[Page][1],
                                                   TRUE,
                                                   FALSE );

                        if (Page == 0) {

                            FatEntry = (PULONG)((PUCHAR)SavedBcbs[0][1] +
                                                (StartOffsetInVolume % PAGE_SIZE));
                        }
                    }
                }

                //
                //  Mark the run dirty
                //

                StartSectorLbo = StartOffsetInVolume & ~(SectorSize - 1);
                FinalSectorLbo = FinalOffsetInVolume & ~(SectorSize - 1);

                for (Lbo = StartSectorLbo; Lbo <= FinalSectorLbo; Lbo += SectorSize) {

                    FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb, (VBO)Lbo, Lbo, SectorSize );
                }

                //
                //  Store the entries
                //
                //  We need extra synchronization here for broken architectures
                //  like the ALPHA that don't support atomic 16 bit writes.
                //

#ifdef ALPHA
                FatLockFreeClusterBitMap( Vcb );
                ReleaseMutex = TRUE;
#endif // ALPHA

                FinalCluster = StartingFatIndex + ClusterCountThisRun - 1;
                Page = 0;

                for (Cluster = StartingFatIndex;
                     Cluster <= FinalCluster;
                     Cluster++, FatEntry++) {

                    //
                    //  If we just crossed a page boundry (as opposed to starting
                    //  on one), update our idea of FatEntry.

                    if ( (((ULONG_PTR)FatEntry & (PAGE_SIZE-1)) == 0) &&
                         (Cluster != StartingFatIndex) ) {

                        Page += 1;
                        FatEntry = (PULONG)SavedBcbs[Page][1];
                    }

                    *FatEntry = ChainTogether ? (FAT_ENTRY)(Cluster + 1) :
                                                FAT_CLUSTER_AVAILABLE;
                }

                //
                //  Fix up the last entry if we were chaining together
                //

                if ((ClusterCount <= MAXCOUNTCLUS) &&
                    ChainTogether ) {

                    *(FatEntry-1) = FAT_CLUSTER_LAST;
                }

#ifdef ALPHA
                FatUnlockFreeClusterBitMap( Vcb );
                ReleaseMutex = FALSE;
#endif // ALPHA

                {
                    ULONG i = 0;
                    //
                    //  Unpin the Bcbs
                    //

                    while ( SavedBcbs[i][0] != NULL ) {

                        FatUnpinBcb( IrpContext, SavedBcbs[i][0] );
                        SavedBcbs[i][0] = NULL;

                        i += 1;
                    }
                }

                if (ClusterCount <= MAXCOUNTCLUS) {

                    break;

                } else {

                    StartingFatIndex += MAXCOUNTCLUS;
                    ClusterCount -= MAXCOUNTCLUS;
                }
            }

        } else {

            //
            //  DEAL WITH 16 BIT CASE
            //

            VBO StartOffsetInVolume;
            VBO FinalOffsetInVolume;

            ULONG Page;
            ULONG FinalCluster;
            PUSHORT FatEntry;

            StartOffsetInVolume = FatReservedBytes(&Vcb->Bpb) +
                                        StartingFatIndex * sizeof(USHORT);

            FinalOffsetInVolume = StartOffsetInVolume +
                                        (ClusterCount - 1) * sizeof(USHORT);

            StartingPage = StartOffsetInVolume / PAGE_SIZE;

            //
            //  Read in one page of fat at a time.  We cannot read in the
            //  all of the fat we need because of cache manager limitations.
            //
            //  SavedBcb was initialized to be able to hold the largest
            //  possible number of pages in a fat plus and extra one to
            //  accomadate the boot sector, plus one more to make sure there
            //  is enough room for the RtlZeroMemory below that needs the mark
            //  the first Bcb after all the ones we will use as an end marker.
            //

            {
                ULONG NumberOfPages;
                ULONG Offset;

                NumberOfPages = (FinalOffsetInVolume / PAGE_SIZE) -
                                (StartOffsetInVolume / PAGE_SIZE) + 1;

                RtlZeroMemory( &SavedBcbs[0][0], (NumberOfPages + 1) * sizeof(PBCB) * 2 );

                for ( Page = 0, Offset = StartOffsetInVolume & ~(PAGE_SIZE - 1);
                      Page < NumberOfPages;
                      Page++, Offset += PAGE_SIZE ) {

                    FatPrepareWriteVolumeFile( IrpContext,
                                               Vcb,
                                               Offset,
                                               PAGE_SIZE,
                                               &SavedBcbs[Page][0],
                                               (PVOID *)&SavedBcbs[Page][1],
                                               TRUE,
                                               FALSE );

                    if (Page == 0) {

                        FatEntry = (PUSHORT)((PUCHAR)SavedBcbs[0][1] +
                                            (StartOffsetInVolume % PAGE_SIZE));
                    }
                }
            }

            //
            //  Mark the run dirty
            //

            StartSectorLbo = StartOffsetInVolume & ~(SectorSize - 1);
            FinalSectorLbo = FinalOffsetInVolume & ~(SectorSize - 1);

            for (Lbo = StartSectorLbo; Lbo <= FinalSectorLbo; Lbo += SectorSize) {

                FatAddMcbEntry( Vcb, &Vcb->DirtyFatMcb, (VBO) Lbo, Lbo, SectorSize );
            }

            //
            //  Store the entries
            //
            //  We need extra synchronization here for broken architectures
            //  like the ALPHA that don't support atomic 16 bit writes.
            //

#ifdef ALPHA
            FatLockFreeClusterBitMap( Vcb );
            ReleaseMutex = TRUE;
#endif // ALPHA

            FinalCluster = StartingFatIndex + ClusterCount - 1;
            Page = 0;

            for (Cluster = StartingFatIndex;
                 Cluster <= FinalCluster;
                 Cluster++, FatEntry++) {

                //
                //  If we just crossed a page boundry (as opposed to starting
                //  on one), update our idea of FatEntry.

                if ( (((ULONG_PTR)FatEntry & (PAGE_SIZE-1)) == 0) &&
                     (Cluster != StartingFatIndex) ) {

                    Page += 1;
                    FatEntry = (PUSHORT)SavedBcbs[Page][1];
                }

                *FatEntry = (USHORT) (ChainTogether ? (FAT_ENTRY)(Cluster + 1) :
                                                      FAT_CLUSTER_AVAILABLE);
            }

            //
            //  Fix up the last entry if we were chaining together
            //

            if ( ChainTogether ) {

                *(FatEntry-1) = (USHORT)FAT_CLUSTER_LAST;
            }
#ifdef ALPHA
            FatUnlockFreeClusterBitMap( Vcb );
            ReleaseMutex = FALSE;
#endif // ALPHA
        }

    } finally {

        ULONG i = 0;

        DebugUnwind( FatSetFatRun );

        //
        //  If we still somehow have the Mutex, release it.
        //

        if (ReleaseMutex) {

            ASSERT( AbnormalTermination() );

            FatUnlockFreeClusterBitMap( Vcb );
        }

        //
        //  Unpin the Bcbs
        //

        while ( SavedBcbs[i][0] != NULL ) {

            FatUnpinBcb( IrpContext, SavedBcbs[i][0] );

            i += 1;
        }

        //
        //  At this point nothing in this finally clause should have raised.
        //  So, now comes the unsafe (sigh) stuff.
        //

        if ( AbnormalTermination() &&
            (Vcb->AllocationSupport.FatIndexBitSize == 32) ) {

            //
            //  Fat32 unwind
            //
            //  This case is more complex because the FAT12 and FAT16 cases
            //  pin all the needed FAT pages (128K max), after which it
            //  can't fail, before changing any FAT entries.  In the Fat32
            //  case, it may not be practical to pin all the needed FAT
            //  pages, because that could span many megabytes.  So Fat32
            //  attacks in chunks, and if a failure occurs once the first
            //  chunk has been updated, we have to back out the updates.
            //
            //  The unwind consists of walking back over each FAT entry we
            //  have changed, setting it back to the previous value.  Note
            //  that the previous value with either be FAT_CLUSTER_AVAILABLE
            //  (if ChainTogether==TRUE) or a simple link to the successor
            //  (if ChainTogether==FALSE).
            //
            //  We concede that any one of these calls could fail too; our
            //  objective is to make this case no more likely than the case
            //  for a file consisting of multiple disjoint runs.
            //

            while ( StartingFatIndex > SavedStartingFatIndex ) {

                StartingFatIndex--;

                FatSetFatEntry( IrpContext, Vcb, StartingFatIndex,
                    ChainTogether ?
                        StartingFatIndex + 1 : FAT_CLUSTER_AVAILABLE );
            }
        }

        DebugTrace(-1, Dbg, "FatSetFatRun -> (VOID)\n", 0);
    }

    return;
}


//
//  Internal support routine
//

UCHAR
FatLogOf (
    IN ULONG Value
    )

/*++

Routine Description:

    This routine just computes the base 2 log of an integer.  It is only used
    on objects that are know to be powers of two.

Arguments:

    Value - The value to take the base 2 log of.

Return Value:

    UCHAR - The base 2 log of Value.

--*/

{
    UCHAR Log = 0;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "LogOf\n", 0);
    DebugTrace( 0, Dbg, "  Value = %8lx\n", Value);

    //
    //  Knock bits off until we we get a one at position 0
    //

    while ( (Value & 0xfffffffe) != 0 ) {

        Log++;
        Value >>= 1;
    }

    //
    //  If there was more than one bit set, the file system messed up,
    //  Bug Check.
    //

    if (Value != 0x1) {

        DebugTrace( 0, Dbg, "Received non power of 2.\n", 0);

        FatBugCheck( Value, Log, 0 );
    }

    DebugTrace(-1, Dbg, "LogOf -> %8lx\n", Log);

    return Log;
}


VOID
FatExamineFatEntries(
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG StartIndex OPTIONAL,
    IN ULONG EndIndex OPTIONAL,
    IN BOOLEAN SetupWindows,
    IN PFAT_WINDOW SwitchToWindow OPTIONAL,
    IN PULONG BitMapBuffer OPTIONAL
    )
/*++

Routine Description:

    This routine handles scanning a segment of the FAT into in-memory structures.

    There are three fundamental cases, with variations depending on the FAT type:

    1) During volume setup, FatSetupAllocations

        1a) for FAT12/16, read the FAT into our free clusterbitmap
        1b) for FAT32, perform the initial scan for window free cluster counts

    2) Switching FAT32 windows on the fly during system operation

    3) Reading arbitrary segments of the FAT for the purposes of the GetVolumeBitmap
        call (only for FAT32)

    There really is too much going on in here. At some point this should be
    substantially rewritten.

Arguments:

    Vcb - Supplies the volume involved

    StartIndex - Supplies the starting cluster, ignored if SwitchToWindow supplied

    EndIndex - Supplies the ending cluster, ignored if SwitchToWindow supplied

    SetupWindows - Indicates if we are doing the initial FAT32 scan

    SwitchToWindow - Supplies the FAT window we are examining and will switch to

    BitMapBuffer - Supplies a specific bitmap to fill in, if not supplied we fill
        in the volume free cluster bitmap if !SetupWindows

Return Value:

    None.  Lots of side effects.

--*/
{
    ULONG FatIndexBitSize;
    ULONG Page;
    ULONG Offset;
    ULONG FatIndex;
    FAT_ENTRY FatEntry = FAT_CLUSTER_AVAILABLE;
    FAT_ENTRY FirstFatEntry = FAT_CLUSTER_AVAILABLE;
    PUSHORT FatBuffer;
    PVOID pv;
    PBCB Bcb;
    ULONG EntriesPerWindow;
    ULONG BitIndex;

    ULONG ClustersThisRun;
    ULONG StartIndexOfThisRun;

    PULONG FreeClusterCount = NULL;

    PFAT_WINDOW CurrentWindow = NULL;

    PVOID NewBitMapBuffer = NULL;
    PRTL_BITMAP BitMap = NULL;
    RTL_BITMAP PrivateBitMap;

    enum RunType {
        FreeClusters,
        AllocatedClusters,
        UnknownClusters
    } CurrentRun;

    PAGED_CODE();

    //
    //  Now assert correct usage.
    //

    FatIndexBitSize = Vcb->AllocationSupport.FatIndexBitSize;

    ASSERT( !(SetupWindows && (SwitchToWindow || BitMapBuffer)));
    ASSERT( !(SetupWindows && FatIndexBitSize != 32));

    if (Vcb->NumberOfWindows > 1) {

        //
        //  FAT32: Calculate the number of FAT entries covered by a window.  This is
        //  equal to the number of bits in the freespace bitmap,  the size of which 
        //  is hardcoded.
        //
        
        EntriesPerWindow = MAX_CLUSTER_BITMAP_SIZE;
        
    } else {
    
        EntriesPerWindow = Vcb->AllocationSupport.NumberOfClusters;
    }

    //
    //  We will also fill in the cumulative count of free clusters for
    //  the entire volume.  If this is not appropriate, NULL it out
    //  shortly.
    //

    FreeClusterCount = &Vcb->AllocationSupport.NumberOfFreeClusters;

    if (SetupWindows) {

        ASSERT(BitMapBuffer == NULL);

        //
        //  In this case we're just supposed to scan the fat and set up
        //  the information regarding where the buckets fall and how many
        //  free clusters are in each.
        //
        //  It is fine to monkey with the real windows, we must be able
        //  to do this to activate the volume.
        //

        BitMap = NULL;

        CurrentWindow = &Vcb->Windows[0];
        CurrentWindow->FirstCluster = StartIndex;
        CurrentWindow->ClustersFree = 0;

        //
        //  We always wish to calculate total free clusters when
        //  setting up the FAT windows.
        //

    } else if (BitMapBuffer == NULL) {

        //
        //  We will be filling in the free cluster bitmap for the volume.
        //  Careful, we can raise out of here and be hopelessly hosed if
        //  we built this up in the main bitmap/window itself.
        //
        //  For simplicity's sake, we'll do the swap for everyone. FAT32
        //  provokes the need since we can't tolerate partial results
        //  when switching windows.
        //

        ASSERT( SwitchToWindow );

        CurrentWindow = SwitchToWindow;
        StartIndex = CurrentWindow->FirstCluster;
        EndIndex = CurrentWindow->LastCluster;

        BitMap = &PrivateBitMap;
        NewBitMapBuffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                    (EntriesPerWindow + 7) / 8,
                                                    TAG_FAT_BITMAP );

        RtlInitializeBitMap( &PrivateBitMap,
                             NewBitMapBuffer,
                             EndIndex - StartIndex + 1);

        if (FatIndexBitSize == 32) {

            //
            //  We do not wish count total clusters here.
            //

            FreeClusterCount = NULL;

        }

    } else {

        BitMap = &PrivateBitMap;
        RtlInitializeBitMap(&PrivateBitMap,
                            BitMapBuffer,
                            EndIndex - StartIndex + 1);

        //
        //  We do not count total clusters here.
        //

        FreeClusterCount = NULL;
    }

    //
    //  Now, our start index better be in the file heap.
    //

    ASSERT( StartIndex >= 2 );

    //
    //  Pick up the initial chunk of the FAT and first entry.
    //

    if (FatIndexBitSize == 12) {

        //
        //  We read in the entire fat in the 12 bit case.
        //

        FatReadVolumeFile( IrpContext,
                           Vcb,
                           FatReservedBytes( &Vcb->Bpb ),
                           FatBytesPerFat( &Vcb->Bpb ),
                           &Bcb,
                           (PVOID *)&FatBuffer );

        FatLookup12BitEntry(FatBuffer, 0, &FirstFatEntry);

    } else {

        //
        //  Read in one page of fat at a time.  We cannot read in the
        //  all of the fat we need because of cache manager limitations.
        //

        ULONG BytesPerEntry = FatIndexBitSize >> 3;
        ULONG EntriesPerPage = PAGE_SIZE / BytesPerEntry;

        Page = (FatReservedBytes(&Vcb->Bpb) + StartIndex * BytesPerEntry) / PAGE_SIZE;

        Offset = Page * PAGE_SIZE;

        FatReadVolumeFile( IrpContext,
                           Vcb,
                           Offset,
                           PAGE_SIZE,
                           &Bcb,
                           &pv);

        if (FatIndexBitSize == 32) {


            FatBuffer = (PUSHORT)((PUCHAR)pv +
                        (FatReservedBytes(&Vcb->Bpb) + StartIndex * BytesPerEntry) %
                             PAGE_SIZE);

            FirstFatEntry = *((PULONG)FatBuffer);
            FirstFatEntry = FirstFatEntry & FAT32_ENTRY_MASK;

        } else {

            FatBuffer = (PUSHORT)((PUCHAR)pv +
                        FatReservedBytes(&Vcb->Bpb) % PAGE_SIZE) + 2;

            FirstFatEntry = *FatBuffer;
        }

    }

    CurrentRun = (FirstFatEntry == FAT_CLUSTER_AVAILABLE) ?
                 FreeClusters : AllocatedClusters;

    StartIndexOfThisRun = StartIndex;

    try {

        for (FatIndex = StartIndex; FatIndex <= EndIndex; FatIndex++) {


            if (FatIndexBitSize == 12) {

                FatLookup12BitEntry(FatBuffer, FatIndex, &FatEntry);

            } else {

                //
                //  If we are setting up the FAT32 windows and have stepped into a new
                //  bucket, finalize this one and move forward.
                //

                if (SetupWindows &&
                    FatIndex > StartIndex &&
                    (FatIndex - 2) % EntriesPerWindow == 0) {

                    CurrentWindow->LastCluster = FatIndex - 1;

                    if (CurrentRun == FreeClusters) {

                        //
                        //  We must be counting clusters in order to modify the
                        //  contents of the window.
                        //

                        ASSERT( FreeClusterCount );


                        ClustersThisRun = FatIndex - StartIndexOfThisRun;
                        CurrentWindow->ClustersFree += ClustersThisRun;

                        if (FreeClusterCount) {
                            *FreeClusterCount += ClustersThisRun;
                        }

                    } else {

                        ASSERT(CurrentRun == AllocatedClusters);

                        ClustersThisRun = FatIndex - StartIndexOfThisRun;
                    }

                    StartIndexOfThisRun = FatIndex;
                    CurrentRun = UnknownClusters;

                    CurrentWindow++;
                    CurrentWindow->ClustersFree = 0;
                    CurrentWindow->FirstCluster = FatIndex;
                }

                //
                //  If we just stepped onto a new page, grab a new pointer.
                //

                if (((ULONG_PTR)FatBuffer & (PAGE_SIZE - 1)) == 0) {

                    FatUnpinBcb( IrpContext, Bcb );

                    Page++;
                    Offset += PAGE_SIZE;

                    FatReadVolumeFile( IrpContext,
                                       Vcb,
                                       Offset,
                                       PAGE_SIZE,
                                       &Bcb,
                                       &pv );

                    FatBuffer = (PUSHORT)pv;
                }

                if (FatIndexBitSize == 32) {

                    FatEntry = *((PULONG)FatBuffer)++;
                    FatEntry = FatEntry & FAT32_ENTRY_MASK;

                } else {

                    FatEntry = *FatBuffer;
                    FatBuffer += 1;
                }
            }

            if (CurrentRun == UnknownClusters) {

                CurrentRun = (FatEntry == FAT_CLUSTER_AVAILABLE) ?
                              FreeClusters : AllocatedClusters;
            }

            //
            //  Are we switching from a free run to an allocated run?
            //

            if (CurrentRun == FreeClusters &&
                FatEntry != FAT_CLUSTER_AVAILABLE) {

                ClustersThisRun = FatIndex - StartIndexOfThisRun;

                if (FreeClusterCount) {

                    *FreeClusterCount += ClustersThisRun;
                    CurrentWindow->ClustersFree += ClustersThisRun;
                }

                if (BitMap) {

                    RtlClearBits( BitMap,
                                  StartIndexOfThisRun - StartIndex,
                                  ClustersThisRun );
                }

                CurrentRun = AllocatedClusters;
                StartIndexOfThisRun = FatIndex;
            }

            //
            //  Are we switching from an allocated run to a free run?
            //

            if (CurrentRun == AllocatedClusters &&
                FatEntry == FAT_CLUSTER_AVAILABLE) {

                ClustersThisRun = FatIndex - StartIndexOfThisRun;

                if (BitMap) {

                    RtlSetBits( BitMap,
                                StartIndexOfThisRun - StartIndex,
                                ClustersThisRun );
                }

                CurrentRun = FreeClusters;
                StartIndexOfThisRun = FatIndex;
            }
        }

        //
        //  Now we have to record the final run we encountered
        //

        ClustersThisRun = FatIndex - StartIndexOfThisRun;

        if (CurrentRun == FreeClusters) {

            if (FreeClusterCount) {

                *FreeClusterCount += ClustersThisRun;
                CurrentWindow->ClustersFree += ClustersThisRun;
            }

            if (BitMap) {

                RtlClearBits( BitMap,
                              StartIndexOfThisRun - StartIndex,
                              ClustersThisRun );
            }

        } else {

            if (BitMap) {

                RtlSetBits( BitMap,
                            StartIndexOfThisRun - StartIndex,
                            ClustersThisRun );
            }
        }

        //
        //  And finish the last window if we are in setup.
        //

        if (SetupWindows) {

            CurrentWindow->LastCluster = FatIndex - 1;
        }

        //
        //  Now switch the active window if required.  We've succesfully gotten everything
        //  nailed down.
        //
        //  If we were tracking the free cluster count, this means we should update the
        //  window.  This is the case of FAT12/16 initialization.
        //

        if (SwitchToWindow) {

            if (Vcb->FreeClusterBitMap.Buffer) {

                ExFreePool( Vcb->FreeClusterBitMap.Buffer );
            }

            RtlInitializeBitMap( &Vcb->FreeClusterBitMap,
                                 NewBitMapBuffer,
                                 EndIndex - StartIndex + 1 );

            NewBitMapBuffer = NULL;

            Vcb->CurrentWindow = SwitchToWindow;
            Vcb->ClusterHint = -1;

            if (FreeClusterCount) {

                ASSERT( !SetupWindows );
                ASSERT( FatIndexBitSize != 32 );

                Vcb->CurrentWindow->ClustersFree = *FreeClusterCount;
            }
        }

        //
        //  Make sure plausible things occured ...
        //

        if (!SetupWindows && BitMapBuffer == NULL) {

            ASSERT_CURRENT_WINDOW_GOOD( Vcb );
        }

        ASSERT(Vcb->AllocationSupport.NumberOfFreeClusters <= Vcb->AllocationSupport.NumberOfClusters);

    } finally {

        //
        //  Unpin the last bcb and drop the temporary bitmap buffer if it exists.
        //

        FatUnpinBcb( IrpContext, Bcb);

        if (NewBitMapBuffer) {

            ExFreePool( NewBitMapBuffer );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fastfat\cleanup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Cleanup.c

Abstract:

    This module implements the File Cleanup routine for Fat called by the
    dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_CLEANUP)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLEANUP)

//
//  The following little routine exists solely because it need a spin lock.
//

VOID
FatAutoUnlock (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCommonCleanup)
#pragma alloc_text(PAGE, FatFsdCleanup)
#endif


NTSTATUS
FatFsdCleanup (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of closing down a handle to a
    file object.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file being Cleanup exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS
    //

    if ( FatDeviceIsFatFsdo( VolumeDeviceObject))  {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FILE_OPENED;

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );

        return STATUS_SUCCESS;
    }

    DebugTrace(+1, Dbg, "FatFsdCleanup\n", 0);

    //
    //  Call the common Cleanup routine, with blocking allowed.
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, TRUE );

        Status = FatCommonCleanup( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdCleanup -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


NTSTATUS
FatCommonCleanup (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for cleanup of a file/directory called by both
    the fsd and fsp threads.

    Cleanup is invoked whenever the last handle to a file object is closed.
    This is different than the Close operation which is invoked when the last
    reference to a file object is deleted.

    The function of cleanup is to essentially "cleanup" the file/directory
    after a user is done with it.  The Fcb/Dcb remains around (because MM
    still has the file object referenced) but is now available for another
    user to open (i.e., as far as the user is concerned the is now closed).

    See close for a more complete description of what close does.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN SendUnlockNotification = FALSE;

    PSHARE_ACCESS ShareAccess;

    PLARGE_INTEGER TruncateSize = NULL;
    LARGE_INTEGER LocalTruncateSize;

    BOOLEAN AcquiredVcb = FALSE;
    BOOLEAN AcquiredFcb = FALSE;
    
    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatCommonCleanup\n", 0);
    DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "->FileObject  = %08lx\n", IrpSp->FileObject);

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb );

    //
    //  Special case the unopened file object.  This will occur only when
    //  we are initializing Vcb and IoCreateStreamFileObject is being
    //  called.
    //

    if (TypeOfOpen == UnopenedFileObject) {

        DebugTrace(0, Dbg, "Unopened File Object\n", 0);

        FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

        DebugTrace(-1, Dbg, "FatCommonCleanup -> STATUS_SUCCESS\n", 0);
        return STATUS_SUCCESS;
    }

    //
    //  If this is not our first time through (for whatever reason)
    //  only see if we have to flush the file.
    //

    if (FlagOn( FileObject->Flags, FO_CLEANUP_COMPLETE )) {

        if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH) &&
            FlagOn(FileObject->Flags, FO_FILE_MODIFIED) &&
            !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED) &&
            (TypeOfOpen == UserFileOpen)) {

            //
            //  Flush the file.
            //

            Status = FatFlushFile( IrpContext, Fcb, Flush );

            if (!NT_SUCCESS(Status)) {

                FatNormalizeAndRaiseStatus( IrpContext, Status );
            }
        }

        FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

        DebugTrace(-1, Dbg, "FatCommonCleanup -> STATUS_SUCCESS\n", 0);
        return STATUS_SUCCESS;
    }

    //
    //  If we call change the allocation or call CcUninitialize,
    //  we have to take the Fcb exclusive
    //

    if ((TypeOfOpen == UserFileOpen) || (TypeOfOpen == UserDirectoryOpen)) {

        ASSERT( Fcb != NULL );
    
        (VOID)FatAcquireExclusiveFcb( IrpContext, Fcb );

        AcquiredFcb = TRUE;

        //
        //  Do a check here if this was a DELETE_ON_CLOSE FileObject, and
        //  set the Fcb flag appropriately.
        //

        if (FlagOn(Ccb->Flags, CCB_FLAG_DELETE_ON_CLOSE)) {

            ASSERT( NodeType(Fcb) != FAT_NTC_ROOT_DCB );

            SetFlag(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE);

            //
            //  Report this to the dir notify package for a directory.
            //

            if (TypeOfOpen == UserDirectoryOpen) {

                FsRtlNotifyFullChangeDirectory( Vcb->NotifySync,
                                                &Vcb->DirNotifyList,
                                                FileObject->FsContext,
                                                NULL,
                                                FALSE,
                                                FALSE,
                                                0,
                                                NULL,
                                                NULL,
                                                NULL );
            }
        }

        //
        //  Now if we may delete the file, drop the Fcb and acquire the Vcb
        //  first.  Note that while we own the Fcb exclusive, a file cannot
        //  become DELETE_ON_CLOSE and cannot be opened via CommonCreate.
        //

        if ((Fcb->UncleanCount == 1) &&
            FlagOn(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE) &&
            (Fcb->FcbCondition != FcbBad) &&
            !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED)) {

            FatReleaseFcb( IrpContext, Fcb );
            AcquiredFcb = FALSE;

            (VOID)FatAcquireExclusiveVcb( IrpContext, Vcb );
            AcquiredVcb = TRUE;

            (VOID)FatAcquireExclusiveFcb( IrpContext, Fcb );
            AcquiredFcb = TRUE;
        }
    }

    //
    //  For user DASD cleanups, grab the Vcb exclusive.
    //

    if (TypeOfOpen == UserVolumeOpen) {

        (VOID)FatAcquireExclusiveVcb( IrpContext, Vcb );
        AcquiredVcb = TRUE;
    }

    //
    //  Complete any Notify Irps on this file handle.
    //

    if (TypeOfOpen == UserDirectoryOpen) {

        FsRtlNotifyCleanup( Vcb->NotifySync,
                            &Vcb->DirNotifyList,
                            Ccb );
    }

    //
    //  Determine the Fcb state, Good or Bad, for better or for worse.
    //
    //  We can only read the volume file if VcbCondition is good.
    //

    if ( Fcb != NULL) {

        //
        //  Stop any raises from FatVerifyFcb, unless it is REAL bad.
        //

        try {

            try {

                FatVerifyFcb( IrpContext, Fcb );

            } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

                  FatResetExceptionState( IrpContext );
            }

        } finally {

            if ( AbnormalTermination() ) {

                //
                //  We will be raising out of here.
                //

                if (AcquiredFcb) { FatReleaseFcb( IrpContext, Fcb ); }
                if (AcquiredVcb) { FatReleaseVcb( IrpContext, Vcb ); }
            }
        }
    }

    try {

        //
        //  Case on the type of open that we are trying to cleanup.
        //  For all cases we need to set the share access to point to the
        //  share access variable (if there is one). After the switch
        //  we then remove the share access and complete the Irp.
        //  In the case of UserFileOpen we actually have a lot more work
        //  to do and we have the FsdLockControl complete the Irp for us.
        //

        switch (TypeOfOpen) {

        case DirectoryFile:
        case VirtualVolumeFile:

            DebugTrace(0, Dbg, "Cleanup VirtualVolumeFile/DirectoryFile\n", 0);

            ShareAccess = NULL;

            break;

        case UserVolumeOpen:

            DebugTrace(0, Dbg, "Cleanup UserVolumeOpen\n", 0);

            if (FlagOn( Ccb->Flags, CCB_FLAG_COMPLETE_DISMOUNT )) {

                FatCheckForDismount( IrpContext, Vcb, TRUE );
            
            //
            //  If this handle had write access, and actually wrote something,
            //  flush the device buffers, and then set the verify bit now
            //  just to be safe (in case there is no dismount).
            //

            } else if (FileObject->WriteAccess &&
                       FlagOn(FileObject->Flags, FO_FILE_MODIFIED)) {

                (VOID)FatHijackIrpAndFlushDevice( IrpContext,
                                                  Irp,
                                                  Vcb->TargetDeviceObject );

                SetFlag(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME);
            }

            //
            //  If the volume is locked by this file object then release
            //  the volume and send notification.
            //

            if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_LOCKED) &&
                (Vcb->FileObjectWithVcbLocked == FileObject)) {

                FatAutoUnlock( IrpContext, Vcb );
                SendUnlockNotification = TRUE;
            }

            ShareAccess = &Vcb->ShareAccess;

            break;

        case EaFile:

            DebugTrace(0, Dbg, "Cleanup EaFileObject\n", 0);

            ShareAccess = NULL;

            break;

        case UserDirectoryOpen:

            DebugTrace(0, Dbg, "Cleanup UserDirectoryOpen\n", 0);

            ShareAccess = &Fcb->ShareAccess;

            //
            //  Determine here if we should try do delayed close.
            //

            if ((Fcb->UncleanCount == 1) &&
                (Fcb->OpenCount == 1) &&
                (Fcb->Specific.Dcb.DirectoryFileOpenCount == 0) &&
                !FlagOn(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE) &&
                Fcb->FcbCondition == FcbGood) {

                //
                //  Delay our close.
                //

                SetFlag( Fcb->FcbState, FCB_STATE_DELAY_CLOSE );
            }

            FatUpdateDirentFromFcb( IrpContext, FileObject, Fcb, Ccb );

            //
            //  If the directory has a unclean count of 1 then we know
            //  that this is the last handle for the file object.  If
            //  we are supposed to delete it, do so.
            //

            if ((Fcb->UncleanCount == 1) &&
                (NodeType(Fcb) == FAT_NTC_DCB) &&
                (FlagOn(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE)) &&
                (Fcb->FcbCondition != FcbBad) &&
                !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED)) {

                if (!FatIsDirectoryEmpty(IrpContext, Fcb)) {

                    //
                    //  If there are files in the directory at this point,
                    //  forget that we were trying to delete it.
                    //

                    ClearFlag( Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE );

                } else {

                    //
                    //  Even if something goes wrong, we cannot turn back!
                    //
        
                    try {
        
                        DELETE_CONTEXT DeleteContext;
        
                        //
                        //  Before truncating file allocation remember this
                        //  info for FatDeleteDirent.
                        //
        
                        DeleteContext.FileSize = Fcb->Header.FileSize.LowPart;
                        DeleteContext.FirstClusterOfFile = Fcb->FirstClusterOfFile;
        
                        //
                        //  Synchronize here with paging IO
                        //
        
                        (VOID)ExAcquireResourceExclusiveLite( Fcb->Header.PagingIoResource,
                                                          TRUE );
        
                        Fcb->Header.FileSize.LowPart = 0;
        
                        ExReleaseResourceLite( Fcb->Header.PagingIoResource );
        
                        if (Vcb->VcbCondition == VcbGood) {
        
                            //
                            //  Truncate the file allocation down to zero
                            //
        
                            DebugTrace(0, Dbg, "Delete File allocation\n", 0);
        
                            FatTruncateFileAllocation( IrpContext, Fcb, 0 );

                            if (Fcb->Header.AllocationSize.LowPart == 0) {
        
                                //
                                //  Tunnel and remove the dirent for the directory
                                //
            
                                DebugTrace(0, Dbg, "Delete the directory dirent\n", 0);
            
                                FatTunnelFcbOrDcb( Fcb, NULL );
    
                                FatDeleteDirent( IrpContext, Fcb, &DeleteContext, TRUE );
            
                                //
                                //  Report that we have removed an entry.
                                //
        
                                FatNotifyReportChange( IrpContext,
                                                       Vcb,
                                                       Fcb,
                                                       FILE_NOTIFY_CHANGE_DIR_NAME,
                                                       FILE_ACTION_REMOVED );
                            }
                        }

                    } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                              EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {
    
                          FatResetExceptionState( IrpContext );
                    }

                    //
                    //  Remove the entry from the name table.
                    //  This will ensure that
                    //  we will not collide with the Dcb if the user wants
                    //  to recreate the same file over again before we
                    //  get a close irp.
                    //
    
                    FatRemoveNames( IrpContext, Fcb );
                }
            }

            //
            //  Decrement the unclean count.
            //

            ASSERT( Fcb->UncleanCount != 0 );
            Fcb->UncleanCount -= 1;

            break;

        case UserFileOpen:

            DebugTrace(0, Dbg, "Cleanup UserFileOpen\n", 0);

            ShareAccess = &Fcb->ShareAccess;

            //
            //  Determine here if we should do a delayed close.
            //

            if ((FileObject->SectionObjectPointer->DataSectionObject == NULL) &&
                (FileObject->SectionObjectPointer->ImageSectionObject == NULL) &&
                (Fcb->UncleanCount == 1) &&
                (Fcb->OpenCount == 1) &&
                !FlagOn(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE) &&
                Fcb->FcbCondition == FcbGood) {

                //
                //  Delay our close.
                //

                SetFlag( Fcb->FcbState, FCB_STATE_DELAY_CLOSE );
            }

            //
            //  Unlock all outstanding file locks.
            //

            (VOID) FsRtlFastUnlockAll( &Fcb->Specific.Fcb.FileLock,
                                       FileObject,
                                       IoGetRequestorProcess( Irp ),
                                       NULL );

            //
            //  We can proceed with on-disk updates only if the volume is mounted.
            //  Remember that we toss all sections in the failed-verify and dismount
            //  cases.
            //
            
            if (Vcb->VcbCondition == VcbGood) {
                
                if (Fcb->FcbCondition != FcbBad) {
                    
                    FatUpdateDirentFromFcb( IrpContext, FileObject, Fcb, Ccb );
                }
    
                //
                //  If the file has a unclean count of 1 then we know
                //  that this is the last handle for the file object.
                //
    
                if ( (Fcb->UncleanCount == 1) && (Fcb->FcbCondition != FcbBad) ) {
    
                    DELETE_CONTEXT DeleteContext;
    
                    //
                    //  Check if we should be deleting the file.  The
                    //  delete operation really deletes the file but
                    //  keeps the Fcb around for close to do away with.
                    //
    
                    if (FlagOn(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE) &&
                        !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED)) {
    
                        //
                        //  Before truncating file allocation remember this
                        //  info for FatDeleteDirent.
                        //
    
                        DeleteContext.FileSize = Fcb->Header.FileSize.LowPart;
                        DeleteContext.FirstClusterOfFile = Fcb->FirstClusterOfFile;
    
                        DebugTrace(0, Dbg, "Delete File allocation\n", 0);
    
                        //
                        //  Synchronize here with paging IO
                        //
    
                        (VOID)ExAcquireResourceExclusiveLite( Fcb->Header.PagingIoResource,
                                                          TRUE );
    
                        Fcb->Header.FileSize.LowPart = 0;
                        Fcb->Header.ValidDataLength.LowPart = 0;
                        Fcb->ValidDataToDisk = 0;
    
                        ExReleaseResourceLite( Fcb->Header.PagingIoResource );
    
                        try {
    
                            FatSetFileSizeInDirent( IrpContext, Fcb, NULL );
    
                        } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                                  EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {
    
                              FatResetExceptionState( IrpContext );
                        }
    
                        Fcb->FcbState |= FCB_STATE_TRUNCATE_ON_CLOSE;
    
                    } else {
    
                        //
                        //  We must zero between ValidDataLength and FileSize
                        //
    
                        if (!FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE) &&
                            (Fcb->Header.ValidDataLength.LowPart < Fcb->Header.FileSize.LowPart)) {
    
                            ULONG ValidDataLength;
    
                            ValidDataLength = Fcb->Header.ValidDataLength.LowPart;
    
                            if (ValidDataLength < Fcb->ValidDataToDisk) {
                                ValidDataLength = Fcb->ValidDataToDisk;
                            }
    
                            //
                            //  Recheck, VDD can be >= FS
                            //
                            
                            if (ValidDataLength < Fcb->Header.FileSize.LowPart) {
                                
                                try {

                                    (VOID)FatZeroData( IrpContext,
                                                       Vcb,
                                                       FileObject,
                                                       ValidDataLength,
                                                       Fcb->Header.FileSize.LowPart -
                                                       ValidDataLength );

                                    //
                                    //  Since we just zeroed this, we can now bump
                                    //  up VDL in the Fcb.
                                    //

                                    Fcb->ValidDataToDisk =
                                    Fcb->Header.ValidDataLength.LowPart =
                                    Fcb->Header.FileSize.LowPart;

                                    //
                                    //  We inform Cc of the motion so that the cache map is updated.
                                    //  This prevents optimized zero-page faults in case the cache
                                    //  structures are re-used for another handle before they are torn
                                    //  down by our soon-to-occur uninitialize. If they were, a noncached
                                    //  producer could write into the region we just zeroed and Cc would
                                    //  be none the wiser, then our async cached reader comes in and takes
                                    //  the optimized path, and we get bad (zero) data.
                                    //
                                    //  If this was memory mapped, we don't have to (can't) tell Cc, it'll
                                    //  figure it out when a cached handle is opened.
                                    //

                                    if (CcIsFileCached( FileObject )) {
                                        CcSetFileSizes( FileObject, (PCC_FILE_SIZES)&Fcb->Header.AllocationSize );
                                    }

                                } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                                          EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

                                      FatResetExceptionState( IrpContext );
                                }
                            }
                        }
                    }
    
                    //
                    //  See if we are supposed to truncate the file on the last
                    //  close.  If we cannot wait we'll ship this off to the fsp
                    //
    
                    try {
    
                        if (FlagOn(Fcb->FcbState, FCB_STATE_TRUNCATE_ON_CLOSE)) {
    
                            DebugTrace(0, Dbg, "truncate file allocation\n", 0);
    
                            if (Vcb->VcbCondition == VcbGood) {
    
                                FatTruncateFileAllocation( IrpContext,
                                                           Fcb,
                                                           Fcb->Header.FileSize.LowPart );
                            }
    
                            //
                            //  We also have to get rid of the Cache Map because
                            //  this is the only way we have of trashing the
                            //  truncated pages.
                            //
    
                            LocalTruncateSize = Fcb->Header.FileSize;
                            TruncateSize = &LocalTruncateSize;
    
                            //
                            //  Mark the Fcb as having now been truncated, just incase
                            //  we have to reship this off to the fsp.
                            //
    
                            Fcb->FcbState &= ~FCB_STATE_TRUNCATE_ON_CLOSE;
                        }
    
                        //
                        //  Now check again if we are to delete the file and if
                        //  so then we remove the file from the disk.
                        //
    
                        if (FlagOn(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE) &&
                            Fcb->Header.AllocationSize.LowPart == 0) {
    
                            DebugTrace(0, Dbg, "Delete File\n", 0);
    
                            //
                            //  Now tunnel and delete the dirent
                            //
    
                            FatTunnelFcbOrDcb( Fcb, Ccb );
    
                            FatDeleteDirent( IrpContext, Fcb, &DeleteContext, TRUE );
    
                            //
                            //  Report that we have removed an entry.
                            //
    
                            FatNotifyReportChange( IrpContext,
                                                   Vcb,
                                                   Fcb,
                                                   FILE_NOTIFY_CHANGE_FILE_NAME,
                                                   FILE_ACTION_REMOVED );
                        }
    
                    } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                              EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {
    
                          FatResetExceptionState( IrpContext );
                    }
    
                    if (FlagOn(Fcb->FcbState, FCB_STATE_DELETE_ON_CLOSE)) {
    
                        //
                        //  Remove the entry from the splay table. This will
                        //  ensure that we will not collide with the Fcb if the
                        //  user wants to recreate the same file over again
                        //  before we get a close irp.
                        //
                        //  Note that we remove the name even if we couldn't
                        //  truncate the allocation and remove the dirent above.
                        //
    
                        FatRemoveNames( IrpContext, Fcb );
                    }
                }
            }
            
            //
            //  We've just finished everything associated with an unclean
            //  fcb so now decrement the unclean count before releasing
            //  the resource.
            //

            ASSERT( Fcb->UncleanCount != 0 );
            Fcb->UncleanCount -= 1;
            if (!FlagOn( FileObject->Flags, FO_CACHE_SUPPORTED )) {
                ASSERT( Fcb->NonCachedUncleanCount != 0 );
                Fcb->NonCachedUncleanCount -= 1;
            }

            //
            //  If this was the last cached open, and there are open
            //  non-cached handles, attempt a flush and purge operation
            //  to avoid cache coherency overhead from these non-cached
            //  handles later.  We ignore any I/O errors from the flush.
            //

            if (FlagOn( FileObject->Flags, FO_CACHE_SUPPORTED ) &&
                (Fcb->NonCachedUncleanCount != 0) &&
                (Fcb->NonCachedUncleanCount == Fcb->UncleanCount) &&
                (Fcb->NonPaged->SectionObjectPointers.DataSectionObject != NULL)) {

                CcFlushCache( &Fcb->NonPaged->SectionObjectPointers, NULL, 0, NULL );
            
                //
                //  Grab and release PagingIo to serialize ourselves with the lazy writer.
                //  This will work to ensure that all IO has completed on the cached
                //  data and we will succesfully tear away the cache section.
                //
                
                ExAcquireResourceExclusiveLite( Fcb->Header.PagingIoResource, TRUE);
                ExReleaseResourceLite( Fcb->Header.PagingIoResource );

                CcPurgeCacheSection( &Fcb->NonPaged->SectionObjectPointers,
                                     NULL,
                                     0,
                                     FALSE );
            }

            //
            //  If the file is invalid, hint to the cache that we should throw everything out.
            //
            
            if ( Fcb->FcbCondition == FcbBad ) {

                TruncateSize = &FatLargeZero;
            }

            //
            //  Cleanup the cache map
            //

            CcUninitializeCacheMap( FileObject, TruncateSize, NULL );

            break;

        default:

            FatBugCheck( TypeOfOpen, 0, 0 );
        }

        //
        //  We must clean up the share access at this time, since we may not
        //  get a Close call for awhile if the file was mapped through this
        //  File Object.
        //

        if (ShareAccess != NULL) {

            DebugTrace(0, Dbg, "Cleanup the Share access\n", 0);
            IoRemoveShareAccess( FileObject, ShareAccess );
        }

        if (TypeOfOpen == UserFileOpen) {

            //
            //  Coordinate the cleanup operation with the oplock state.
            //  Cleanup operations can always cleanup immediately.
            //

            FsRtlCheckOplock( &Fcb->Specific.Fcb.Oplock,
                              Irp,
                              IrpContext,
                              NULL,
                              NULL );

            Fcb->Header.IsFastIoPossible = FatIsFastIoPossible( Fcb );
        }

        //
        //  First set the FO_CLEANUP_COMPLETE flag.
        //

        SetFlag( FileObject->Flags, FO_CLEANUP_COMPLETE );

        Status = STATUS_SUCCESS;

        //
        //  Now unpin any repinned Bcbs.
        //

        FatUnpinRepinnedBcbs( IrpContext );

        //
        //  If this was deferred flush media, flush the volume.
        //  We used to do this in lieu of write through for all removable
        //  media.
        //

        if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH) &&
            !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED))  {

            //
            //  Flush the file.
            //

            if ((TypeOfOpen == UserFileOpen) && 
                FlagOn(FileObject->Flags, FO_FILE_MODIFIED)) {

                Status = FatFlushFile( IrpContext, Fcb, Flush );
            }

            //
            //  If that worked ok,  then see if we should flush the FAT as well.
            //

            if (NT_SUCCESS(Status) && Fcb && !FatIsFat12( Vcb) && 
                FlagOn( Fcb->FcbState, FCB_STATE_FLUSH_FAT)) {

                Status = FatFlushFat( IrpContext, Vcb);
            }

            if (!NT_SUCCESS(Status)) {

                FatNormalizeAndRaiseStatus( IrpContext, Status );
            }
        }

    } finally {

        DebugUnwind( FatCommonCleanup );

        if (AcquiredFcb) { FatReleaseFcb( IrpContext, Fcb ); }
        if (AcquiredVcb) { FatReleaseVcb( IrpContext, Vcb ); }

        if (SendUnlockNotification) {
            
            FsRtlNotifyVolumeEvent( FileObject, FSRTL_VOLUME_UNLOCK );
        }

        //
        //  If this is a normal termination then complete the request
        //

        if (!AbnormalTermination()) {

            FatCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace(-1, Dbg, "FatCommonCleanup -> %08lx\n", Status);
    }

    return Status;
}

VOID
FatAutoUnlock (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )
{
    KIRQL SavedIrql;

    //
    //  Unlock the volume.
    //

    IoAcquireVpbSpinLock( &SavedIrql );

    ClearFlag( Vcb->Vpb->Flags, VPB_LOCKED );

    Vcb->VcbState &= ~VCB_STATE_FLAG_LOCKED;
    Vcb->FileObjectWithVcbLocked = NULL;

    IoReleaseVpbSpinLock( SavedIrql );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fastfat\cachesup.c ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    cache.c

Abstract:

    This module implements the cache management routines for the Fat
    FSD and FSP, by calling the Common Cache Manager.

// @@BEGIN_DDKSPLIT

Author:

    Tom Miller      [TomM]      26-Jan-1990

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_CACHESUP)

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CACHESUP)

#if DBG

BOOLEAN
FatIsCurrentOperationSynchedForDcbTeardown (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb
    );

#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCloseEaFile)
#pragma alloc_text(PAGE, FatCompleteMdl)
#pragma alloc_text(PAGE, FatOpenDirectoryFile)
#pragma alloc_text(PAGE, FatOpenEaFile)
#pragma alloc_text(PAGE, FatPinMappedData)
#pragma alloc_text(PAGE, FatPrepareWriteDirectoryFile)
#pragma alloc_text(PAGE, FatPrepareWriteVolumeFile)
#pragma alloc_text(PAGE, FatReadDirectoryFile)
#pragma alloc_text(PAGE, FatReadVolumeFile)
#pragma alloc_text(PAGE, FatRepinBcb)
#pragma alloc_text(PAGE, FatSyncUninitializeCacheMap)
#pragma alloc_text(PAGE, FatUnpinRepinnedBcbs)
#pragma alloc_text(PAGE, FatZeroData)
#if DBG
#pragma alloc_text(PAGE, FatIsCurrentOperationSynchedForDcbTeardown)
#endif
#endif


VOID
FatReadVolumeFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine is called when the specified range of sectors is to be
    read into the cache.  In fat, the volume file only contains the boot
    sector, reserved sectors, and the "fat(s)."  Thus the volume file is
    of fixed size and only extends up to (but not not including) the root
    directory entry, and will never move or change size.

    The fat volume file is also peculiar in that, since it starts at the
    logical beginning of the disk, Vbo == Lbo.

Arguments:

    Vcb - Pointer to the VCB for the volume

    StartingVbo - The virtual offset of the first desired byte

    ByteCount - Number of bytes desired

    Bcb - Returns a pointer to the BCB which is valid until unpinned

    Buffer - Returns a pointer to the sectors, which is valid until unpinned

--*/

{
    LARGE_INTEGER Vbo;

    PAGED_CODE();

    //
    //  Check to see that all references are within the Bios Parameter Block
    //  or the fat(s).  A special case is made when StartingVbo == 0 at
    //  mounting time since we do not know how big the fat is.
    //

    ASSERT( ((StartingVbo == 0) || ((StartingVbo + ByteCount) <= (ULONG)
            (FatRootDirectoryLbo( &Vcb->Bpb ) + PAGE_SIZE))));

    DebugTrace(+1, Dbg, "FatReadVolumeFile\n", 0);
    DebugTrace( 0, Dbg, "Vcb         = %08lx\n", Vcb);
    DebugTrace( 0, Dbg, "StartingVbo = %08lx\n", StartingVbo);
    DebugTrace( 0, Dbg, "ByteCount   = %08lx\n", ByteCount);

    //
    //  Call the Cache manager to attempt the transfer.
    //

    Vbo.QuadPart = StartingVbo;

    if (!CcMapData( Vcb->VirtualVolumeFile,
                    &Vbo,
                    ByteCount,
                    BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT),
                    Bcb,
                    Buffer )) {

        ASSERT( !FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) );

        //
        // Could not read the data without waiting (cache miss).
        //

        FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
    }

    DbgDoit( IrpContext->PinCount += 1 )

    DebugTrace(-1, Dbg, "FatReadVolumeFile -> VOID, *BCB = %08lx\n", *Bcb);

    return;
}


VOID
FatPrepareWriteVolumeFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer,
    IN BOOLEAN Reversible,
    IN BOOLEAN Zero
    )

/*++

Routine Description:

    This routine first looks to see if the specified range of sectors,
    is already in the cache.  If so, it increments the BCB PinCount,
    sets the BCB dirty, and returns with the location of the sectors.

    If the sectors are not in the cache and Wait is TRUE, it finds a
    free BCB (potentially causing a flush), and clears out the entire
    buffer.  Once this is done, it increments the BCB PinCount, sets the
    BCB dirty, and returns with the location of the sectors.

    If the sectors are not in the cache and Wait is FALSE, this routine
    raises STATUS_CANT_WAIT.

Arguments:

    Vcb - Pointer to the VCB for the volume

    StartingVbo - The virtual offset of the first byte to be written

    ByteCount - Number of bytes to be written

    Bcb - Returns a pointer to the BCB which is valid until unpinned

    Buffer - Returns a pointer to the sectors, which is valid until unpinned

    Reversible - Supplies TRUE if the specified range of modification should
        be repinned so that the operation can be reversed in a controlled
        fashion if errors are encountered.
    
    Zero - Supplies TRUE if the specified range of bytes should be zeroed

--*/

{
    LARGE_INTEGER Vbo;

    PAGED_CODE();
    
    //
    //  Check to see that all references are within the Bios Parameter Block
    //  or the fat(s).
    //

    ASSERT( ((StartingVbo + ByteCount) <= (ULONG)
            (FatRootDirectoryLbo( &Vcb->Bpb ))));

    DebugTrace(+1, Dbg, "FatPrepareWriteVolumeFile\n", 0);
    DebugTrace( 0, Dbg, "Vcb         = %08lx\n", Vcb);
    DebugTrace( 0, Dbg, "StartingVbo = %08lx\n", (ULONG)StartingVbo);
    DebugTrace( 0, Dbg, "ByteCount   = %08lx\n", ByteCount);
    DebugTrace( 0, Dbg, "Zero        = %08lx\n", Zero);

    //
    //  Call the Cache manager to attempt the transfer.
    //

    Vbo.QuadPart = StartingVbo;

    if (!CcPinRead( Vcb->VirtualVolumeFile,
                    &Vbo,
                    ByteCount,
                    BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT),
                    Bcb,
                    Buffer )) {

        ASSERT( !FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) );

        //
        // Could not read the data without waiting (cache miss).
        //

        FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
    }

    //
    //  This keeps the data pinned until we complete the request
    //  and writes the dirty bit through to the disk.
    //

    DbgDoit( IrpContext->PinCount += 1 )

    try {

        if (Zero) {
            
            RtlZeroMemory( *Buffer, ByteCount );
        }

        FatSetDirtyBcb( IrpContext, *Bcb, Vcb, Reversible );

    } finally {

        if (AbnormalTermination()) {

            FatUnpinBcb(IrpContext, *Bcb);
        }
    }

    DebugTrace(-1, Dbg, "FatPrepareWriteVolumeFile -> VOID, *Bcb = %08lx\n", *Bcb);

    return;
}


VOID
FatReadDirectoryFile (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    IN BOOLEAN Pin,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer,
    OUT PNTSTATUS Status
    )

/*++

Routine Description:

    This routine is called when the specified range of sectors is to be
    read into the cache.  If the desired range falls beyond the current
    cache mapping, the fat will be searched, and if the desired range can
    be satisfied, the cache mapping will be extended and the MCB updated
    accordingly.

Arguments:

    Dcb - Pointer to the DCB for the directory

    StartingVbo - The virtual offset of the first desired byte

    ByteCount - Number of bytes desired

    Pin - Tells us if we should pin instead of just mapping.

    Bcb - Returns a pointer to the BCB which is valid until unpinned

    Buffer - Returns a pointer to the sectors, which is valid until unpinned

    Status - Returns the status of the operation.

--*/

{
    LARGE_INTEGER Vbo;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatReadDirectoryFile\n", 0);
    DebugTrace( 0, Dbg, "Dcb         = %08lx\n", Dcb);
    DebugTrace( 0, Dbg, "StartingVbo = %08lx\n", StartingVbo);
    DebugTrace( 0, Dbg, "ByteCount   = %08lx\n", ByteCount);

    //
    //  Check for the zero case
    //

    if (ByteCount == 0) {

        DebugTrace(0, Dbg, "Nothing to read\n", 0);

        *Bcb = NULL;
        *Buffer = NULL;
        *Status = STATUS_SUCCESS;

        DebugTrace(-1, Dbg, "FatReadDirectoryFile -> VOID\n", 0);
        return;
    }

    //
    //  If we need to create a directory file and initialize the
    //  cachemap, do so.
    //

    FatOpenDirectoryFile( IrpContext, Dcb );

    //
    //  Now if the transfer is beyond the allocation size return EOF.
    //

    if (StartingVbo >= Dcb->Header.AllocationSize.LowPart) {

        DebugTrace(0, Dbg, "End of file read for directory\n", 0);

        *Bcb = NULL;
        *Buffer = NULL;
        *Status = STATUS_END_OF_FILE;

        DebugTrace(-1, Dbg, "FatReadDirectoryFile -> VOID\n", 0);
        return;
    }

    //
    // If the caller is trying to read past the EOF, truncate the
    // read.
    //

    ByteCount = (Dcb->Header.AllocationSize.LowPart - StartingVbo < ByteCount) ?
                 Dcb->Header.AllocationSize.LowPart - StartingVbo : ByteCount;

    ASSERT( ByteCount != 0 );

    //
    //  Call the Cache manager to attempt the transfer.
    //

    Vbo.QuadPart = StartingVbo;

    if (Pin ?

        !CcPinRead( Dcb->Specific.Dcb.DirectoryFile,
                    &Vbo,
                    ByteCount,
                    BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT),
                    Bcb,
                    Buffer )
        :

        !CcMapData( Dcb->Specific.Dcb.DirectoryFile,
                    &Vbo,
                    ByteCount,
                    BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT),
                    Bcb,
                    Buffer ) ) {

        //
        // Could not read the data without waiting (cache miss).
        //

        *Bcb = NULL;
        *Buffer = NULL;
        FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
    }

    DbgDoit( IrpContext->PinCount += 1 )

    *Status = STATUS_SUCCESS;

    DebugTrace(-1, Dbg, "FatReadDirectoryFile -> VOID, *BCB = %08lx\n", *Bcb);

    return;
}


VOID
FatPrepareWriteDirectoryFile (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    OUT PBCB *Bcb,
    OUT PVOID *Buffer,
    IN BOOLEAN Zero,
    IN BOOLEAN Reversible,
    OUT PNTSTATUS Status
    )

/*++

Routine Description:

    This routine first looks to see if the specified range of sectors
    is already in the cache.  If so, it increments the BCB PinCount,
    sets the BCB dirty, and returns TRUE with the location of the sectors.

    The IrpContext->Flags .. Wait == TRUE/FALSE actions of this routine are identical to
    FatPrepareWriteVolumeFile() above.

Arguments:

    Dcb - Pointer to the DCB for the directory

    StartingVbo - The virtual offset of the first byte to be written

    ByteCount - Number of bytes to be written

    Bcb - Returns a pointer to the BCB which is valid until unpinned

    Buffer - Returns a pointer to the sectors, which is valid until unpinned

    Zero - Supplies TRUE if the specified range of bytes should be zeroed
    
    Reversible - Supplies TRUE if the specified range of modification should
        be repinned so that the operation can be reversed in a controlled
        fashion if errors are encountered.
    
    Status - Returns the status of the operation.

--*/

{
    LARGE_INTEGER Vbo;
    ULONG InitialAllocation;
    BOOLEAN UnwindWeAllocatedDiskSpace = FALSE;
    ULONG ClusterSize;

    PVOID LocalBuffer;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatPrepareWriteDirectoryFile\n", 0);
    DebugTrace( 0, Dbg, "Dcb         = %08lx\n", Dcb);
    DebugTrace( 0, Dbg, "StartingVbo = %08lx\n", (ULONG)StartingVbo);
    DebugTrace( 0, Dbg, "ByteCount   = %08lx\n", ByteCount);
    DebugTrace( 0, Dbg, "Zero        = %08lx\n", Zero);

    *Bcb = NULL;
    *Buffer = NULL;

    //
    //  If we need to create a directory file and initialize the
    //  cachemap, do so.
    //

    FatOpenDirectoryFile( IrpContext, Dcb );

    //
    //  If the transfer is beyond the allocation size we need to
    //  extend the directory's allocation.  The call to
    //  AddFileAllocation will raise a condition if
    //  it runs out of disk space.  Note that the root directory
    //  cannot be extended.
    //

    Vbo.QuadPart = StartingVbo;

    try {

        if (StartingVbo + ByteCount > Dcb->Header.AllocationSize.LowPart) {

            if (NodeType(Dcb) == FAT_NTC_ROOT_DCB &&
                !FatIsFat32(Dcb->Vcb)) {

                FatRaiseStatus( IrpContext, STATUS_DISK_FULL );
            }

            DebugTrace(0, Dbg, "Try extending normal directory\n", 0);

            InitialAllocation = Dcb->Header.AllocationSize.LowPart;

            FatAddFileAllocation( IrpContext,
                                  Dcb,
                                  Dcb->Specific.Dcb.DirectoryFile,
                                  StartingVbo + ByteCount );

            UnwindWeAllocatedDiskSpace = TRUE;

            //
            //  Inform the cache manager of the new allocation
            //

            Dcb->Header.FileSize.LowPart =
                Dcb->Header.AllocationSize.LowPart;

            CcSetFileSizes( Dcb->Specific.Dcb.DirectoryFile,
                            (PCC_FILE_SIZES)&Dcb->Header.AllocationSize );

            //
            //  Set up the Bitmap buffer if it is not big enough already
            //

            FatCheckFreeDirentBitmap( IrpContext, Dcb );

            //
            //  The newly allocated clusters should be zeroed starting at
            //  the previous allocation size
            //

            Zero = TRUE;
            Vbo.QuadPart = InitialAllocation;
            ByteCount = Dcb->Header.AllocationSize.LowPart - InitialAllocation;
        }

        //
        // Call the Cache Manager to attempt the transfer, going one cluster
        // at a time to avoid pinning across a page boundary.
        //

        ClusterSize =
            1 << Dcb->Vcb->AllocationSupport.LogOfBytesPerCluster;

        while (ByteCount > 0) {

            ULONG BytesToPin;

            *Bcb = NULL;

            if (ByteCount > ClusterSize) {
                BytesToPin = ClusterSize;
            } else {
                BytesToPin = ByteCount;
            }

            ASSERT( (Vbo.QuadPart / ClusterSize) ==
                    (Vbo.QuadPart + BytesToPin - 1)/ClusterSize );

            if (!CcPinRead( Dcb->Specific.Dcb.DirectoryFile,
                            &Vbo,
                            BytesToPin,
                            BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT),
                            Bcb,
                            &LocalBuffer )) {
    
                //
                // Could not read the data without waiting (cache miss).
                //

                FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
            }

            //
            //  Update our caller with the beginning of their request.
            //
            
            if (*Buffer == NULL) {

                *Buffer = LocalBuffer;
            }

            DbgDoit( IrpContext->PinCount += 1 )

            if (Zero) {
                
                //
                //  We set this guy dirty right now so that we can raise CANT_WAIT when
                //  it needs to be done.  It'd be beautiful if we could noop the read IO
                //  since we know we don't care about it.
                //
                
                RtlZeroMemory( LocalBuffer, BytesToPin );
                CcSetDirtyPinnedData( *Bcb, NULL );
            }

            ByteCount -= BytesToPin;
            Vbo.QuadPart += BytesToPin;


            if (ByteCount > 0) {

                FatUnpinBcb( IrpContext, *Bcb );
            }
        }

        //
        //  This lets us get the data pinned until we complete the request
        //  and writes the dirty bit through to the disk.
        //

        FatSetDirtyBcb( IrpContext, *Bcb, Dcb->Vcb, Reversible );

        *Status = STATUS_SUCCESS;

    } finally {

        DebugUnwind( FatPrepareWriteDirectoryFile );

        if (AbnormalTermination()) {

            //
            //  These steps are carefully arranged - FatTruncateFileAllocation can raise.
            //  Make sure we unpin the buffer.  If FTFA raises, the effect should be benign.
            //
            
            FatUnpinBcb(IrpContext, *Bcb);
            
            if (UnwindWeAllocatedDiskSpace == TRUE) {

                //
                //  Inform the cache manager of the change.
                //

                FatTruncateFileAllocation( IrpContext, Dcb, InitialAllocation );

                Dcb->Header.FileSize.LowPart =
                    Dcb->Header.AllocationSize.LowPart;

                CcSetFileSizes( Dcb->Specific.Dcb.DirectoryFile,
                                (PCC_FILE_SIZES)&Dcb->Header.AllocationSize );
            }
        }

        DebugTrace(-1, Dbg, "FatPrepareWriteDirectoryFile -> (VOID), *Bcb = %08lx\n", *Bcb);
    }

    return;
}


#if DBG
BOOLEAN FatDisableParentCheck = 0;

BOOLEAN
FatIsCurrentOperationSynchedForDcbTeardown (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb
    )
{
    PIRP Irp = IrpContext->OriginatingIrp;
    PIO_STACK_LOCATION Stack = IoGetCurrentIrpStackLocation( Irp ) ;
    PFILE_OBJECT FileObject = Stack->FileObject;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PFILE_OBJECT ToCheck[3];
    ULONG Index = 0;

    PAGED_CODE();
    
    //
    //  While mounting, we're OK without having to own anything.
    //
    
    if (Stack->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
        Stack->MinorFunction == IRP_MN_MOUNT_VOLUME) {

        return TRUE;
    }
    
    //
    //  With the Vcb held, the close path is blocked out.
    //
    
    if (ExIsResourceAcquiredSharedLite( &Dcb->Vcb->Resource ) ||
        ExIsResourceAcquiredExclusiveLite( &Dcb->Vcb->Resource )) {

        return TRUE;
    }
    
    //
    //  Accept this assertion at face value.  It comes from GetDirentForFcbOrDcb,
    //  and is reliable.
    //
    
    if (FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_PARENT_BY_CHILD )) {

        return TRUE;
    }

    //
    //  Determine which fileobjects are around on this operation.
    //

    if (Stack->MajorFunction == IRP_MJ_SET_INFORMATION &&
        Stack->Parameters.SetFile.FileObject) {

        ToCheck[Index++] = Stack->Parameters.SetFile.FileObject;
    }

    if (Stack->FileObject) {
        
        ToCheck[Index++] = Stack->FileObject;
    }

    ToCheck[Index] = NULL;
    
    //
    //  If the fileobjects we have are for this dcb or a child of it, we are
    //  also guaranteed that this dcb isn't going anywhere (even without
    //  the Vcb).
    //
    
    for (Index = 0; ToCheck[Index] != NULL; Index++) {
    
        (VOID) FatDecodeFileObject( ToCheck[Index], &Vcb, &Fcb, &Ccb );

        while ( Fcb ) {
    
            if (Fcb == Dcb) {
    
                return TRUE;
            }
    
            Fcb = Fcb->ParentDcb;
        }
    }

    return FatDisableParentCheck;
}
#endif // DBG

VOID
FatOpenDirectoryFile (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb
    )

/*++

Routine Description:

    This routine opens a new directory file if one is not already open.

Arguments:

    Dcb - Pointer to the DCB for the directory

Return Value:

    None.

--*/

{
    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatOpenDirectoryFile\n", 0);
    DebugTrace( 0, Dbg, "Dcb = %08lx\n", Dcb);

    //
    //  If we don't have some hold on this Dcb (there are several ways), there is nothing
    //  to prevent child files from closing and tearing this branch of the tree down in the
    //  midst of our slapping this reference onto it.
    //
    //  I really wish we had a proper Fcb synchronization model (like CDFS/UDFS/NTFS).
    //
    
    ASSERT( FatIsCurrentOperationSynchedForDcbTeardown( IrpContext, Dcb ));

    //
    //  If we haven't yet set the correct AllocationSize, do so.
    //

    if (Dcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT) {

        FatLookupFileAllocationSize( IrpContext, Dcb );

        Dcb->Header.FileSize.LowPart =
        Dcb->Header.AllocationSize.LowPart;
    }

    //
    //  Setup the Bitmap buffer if it is not big enough already
    //

    FatCheckFreeDirentBitmap( IrpContext, Dcb );

    //
    //  Check if we need to create a directory file.
    //
    //  We first do a spot check and then synchronize and check again.
    //

    if (Dcb->Specific.Dcb.DirectoryFile == NULL) {

        PFILE_OBJECT DirectoryFileObject = NULL;

        FatAcquireDirectoryFileMutex( Dcb->Vcb );

        try {

            if (Dcb->Specific.Dcb.DirectoryFile == NULL) {

                PDEVICE_OBJECT RealDevice;

                //
                //  Create the special file object for the directory file, and set
                //  up its pointers back to the Dcb and the section object pointer.
                //  Note that setting the DirectoryFile pointer in the Dcb has
                //  to be the last thing done.
                //
                //  Preallocate a close context since we have no Ccb for this object.
                //

                RealDevice = Dcb->Vcb->CurrentDevice;

                DirectoryFileObject = IoCreateStreamFileObject( NULL, RealDevice );
                FatPreallocateCloseContext( Dcb->Vcb);

                FatSetFileObject( DirectoryFileObject,
                                  DirectoryFile,
                                  Dcb,
                                  NULL );

                DirectoryFileObject->SectionObjectPointer = &Dcb->NonPaged->SectionObjectPointers;

                DirectoryFileObject->ReadAccess = TRUE;
                DirectoryFileObject->WriteAccess = TRUE;
                DirectoryFileObject->DeleteAccess = TRUE;

                InterlockedIncrement( &Dcb->Specific.Dcb.DirectoryFileOpenCount );

                Dcb->Specific.Dcb.DirectoryFile = DirectoryFileObject;
                
                //
                //  Indicate we're happy with the fileobject now.
                //

                DirectoryFileObject = NULL;
            }

        } finally {

            FatReleaseDirectoryFileMutex( Dcb->Vcb );

            //
            //  Rip the object up if we couldn't get the close context.
            //
            
            if (DirectoryFileObject) {
                
                ObDereferenceObject( DirectoryFileObject );
            }
        }
    }

    //
    //  Finally check if we need to initialize the Cache Map for the
    //  directory file.  The size of the section we are going to map
    //  the current allocation size for the directory.  Note that the
    //  cache manager will provide syncronization for us.
    //

    if ( Dcb->Specific.Dcb.DirectoryFile->PrivateCacheMap == NULL ) {

        Dcb->Header.ValidDataLength = FatMaxLarge;
        Dcb->ValidDataToDisk = MAXULONG;

        CcInitializeCacheMap( Dcb->Specific.Dcb.DirectoryFile,
                              (PCC_FILE_SIZES)&Dcb->Header.AllocationSize,
                              TRUE,
                              &FatData.CacheManagerNoOpCallbacks,
                              Dcb );
    }

    DebugTrace(-1, Dbg, "FatOpenDirectoryFile -> VOID\n", 0);

    return;
}


PFILE_OBJECT
FatOpenEaFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB EaFcb
    )

/*++

Routine Description:

    This routine opens the Ea file.

Arguments:

    EaFcb - Pointer to the Fcb for the Ea file.

Return Value:

    Pointer to the new file object.

--*/

{
    PFILE_OBJECT EaFileObject = NULL;
    PDEVICE_OBJECT RealDevice;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatOpenEaFile\n", 0);
    DebugTrace( 0, Dbg, "EaFcb = %08lx\n", EaFcb);

    //
    //  Create the special file object for the ea file, and set
    //  up its pointers back to the Fcb and the section object pointer
    //

    RealDevice = EaFcb->Vcb->CurrentDevice;

    EaFileObject = IoCreateStreamFileObject( NULL, RealDevice );

    try {

        FatPreallocateCloseContext( IrpContext->Vcb);

        FatSetFileObject( EaFileObject,
                          EaFile,
                          EaFcb,
                          NULL );

        EaFileObject->SectionObjectPointer = &EaFcb->NonPaged->SectionObjectPointers;

        EaFileObject->ReadAccess = TRUE;
        EaFileObject->WriteAccess = TRUE;

        //
        //  Finally check if we need to initialize the Cache Map for the
        //  ea file.  The size of the section we are going to map
        //  the current allocation size for the Fcb.
        //

        EaFcb->Header.ValidDataLength = FatMaxLarge;

        CcInitializeCacheMap( EaFileObject,
                              (PCC_FILE_SIZES)&EaFcb->Header.AllocationSize,
                              TRUE,
                              &FatData.CacheManagerCallbacks,
                              EaFcb );

        CcSetAdditionalCacheAttributes( EaFileObject, TRUE, TRUE );
    
    } finally {

        //
        //  Drop the fileobject if we're raising.  Two cases: couldn't get
        //  the close context, and it is still an UnopenedFileObject, or
        //  we lost trying to build the cache map - in which case we're
        //  OK for the close context if we have to.
        //
        
        if (AbnormalTermination()) {
            
            ObDereferenceObject( EaFileObject );
        }
    }

    DebugTrace(-1, Dbg, "FatOpenEaFile -> %08lx\n", EaFileObject);

    UNREFERENCED_PARAMETER( IrpContext );

    return EaFileObject;
}


VOID
FatCloseEaFile (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN BOOLEAN FlushFirst
    )

/*++

Routine Description:

    This routine shuts down the ea file.  Usually this is required when the volume
    begins to leave the system: after verify, dismount, deletion, pnp.
    
Arguments:

    Vcb - the volume to close the ea file on
    
    FlushFirst - whether the file should be flushed
    
Return Value:

    None. As a side effect, the EA fileobject in the Vcb is cleared.
    
    Caller must have the Vcb exclusive.
    
--*/

{
    PFILE_OBJECT EaFileObject = Vcb->VirtualEaFile;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatCloseEaFile\n", 0);
    DebugTrace( 0, Dbg, "Vcb = %08lx\n", Vcb);

    ASSERT( FatVcbAcquiredExclusive(IrpContext, Vcb) );

    if (EaFileObject != NULL) {

        EaFileObject = Vcb->VirtualEaFile;

        if (FlushFirst) {

            CcFlushCache( Vcb->VirtualEaFile->SectionObjectPointer, NULL, 0, NULL );
        }

        Vcb->VirtualEaFile = NULL;

        //
        //  Empty the Mcb for the Ea file.
        //

        FatRemoveMcbEntry( Vcb, &Vcb->EaFcb->Mcb, 0, 0xFFFFFFFF );

        //
        //  Set the file object type to unopened file object
        //  and dereference it.
        //

        FatSetFileObject( EaFileObject,
                          UnopenedFileObject,
                          NULL,
                          NULL );

        FatSyncUninitializeCacheMap( IrpContext, EaFileObject );

        ObDereferenceObject( EaFileObject );
        
        ExFreePool( FatAllocateCloseContext( Vcb));
    }
    
    DebugTrace(-1, Dbg, "FatCloseEaFile -> %08lx\n", EaFileObject);
}


VOID
FatSetDirtyBcb (
    IN PIRP_CONTEXT IrpContext,
    IN PBCB Bcb,
    IN PVCB Vcb OPTIONAL,
    IN BOOLEAN Reversible
    )

/*++

Routine Description:

    This routine saves a reference to the bcb in the irp context and
    sets the bcb dirty.  This will have the affect of keeping the page in
    memory until we complete the request

    In addition, a DPC is set to fire in 5 seconds (or if one is pending,
    pushed back 5 seconds) to mark the volume clean.

Arguments:

    Bcb - Supplies the Bcb being set dirty
    
    Vcb - Supplies the volume being marked dirty
    
    Reversible - Supplies TRUE if the specified range of bcb should be repinned
        so that the changes can be reversed in a controlled fashion if errors
        are encountered.
    
Return Value:

    None.

--*/

{
    DebugTrace(+1, Dbg, "FatSetDirtyBcb\n", 0 );
    DebugTrace( 0, Dbg, "IrpContext = %08lx\n", IrpContext );
    DebugTrace( 0, Dbg, "Bcb        = %08lx\n", Bcb );
    DebugTrace( 0, Dbg, "Vcb        = %08lx\n", Vcb );

    //
    //  Repin the bcb as required
    //

    if (Reversible) {
    
        FatRepinBcb( IrpContext, Bcb );
    }

    //
    //  Set the bcb dirty
    //

    CcSetDirtyPinnedData( Bcb, NULL );

    //
    //  If volume dirtying isn't disabled for this operation (for
    //  instance, when we're changing the dirty state), set the
    //  volume dirty if we were given a Vcb that we want to perform
    //  clean volume processing on, and return.
    //
    //  As a historical note, we used to key off of the old floppy
    //  (now deferred flush) bit to disable dirtying behavior.  Since
    //  hotpluggable media can still be yanked while operations are
    //  in flight, recognize that its really the case that FAT12
    //  doesn't have the dirty bit.
    //

    if ( !FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_DIRTY) &&
         ARGUMENT_PRESENT(Vcb) &&
         !FatIsFat12(Vcb)) {

        KIRQL SavedIrql;

        BOOLEAN SetTimer;

        LARGE_INTEGER TimeSincePreviousCall;
        LARGE_INTEGER CurrentTime;

        //
        //  "Borrow" the irp context spinlock.
        //

        KeQuerySystemTime( &CurrentTime );

        KeAcquireSpinLock( &FatData.GeneralSpinLock, &SavedIrql );

        TimeSincePreviousCall.QuadPart =
                CurrentTime.QuadPart - Vcb->LastFatMarkVolumeDirtyCall.QuadPart;

        //
        //  If more than one second has elapsed since the prior call
        //  to here, bump the timer up again and see if we need to
        //  physically mark the volume dirty.
        //

        if ( (TimeSincePreviousCall.HighPart != 0) ||
             (TimeSincePreviousCall.LowPart > (1000 * 1000 * 10)) ) {

            SetTimer = TRUE;

        } else {

            SetTimer = FALSE;
        }

        KeReleaseSpinLock( &FatData.GeneralSpinLock, SavedIrql );

        if ( SetTimer ) {

            LARGE_INTEGER CleanVolumeTimer;

            //
            //  We use a shorter volume clean timer for hot plug volumes.
            //
            
            CleanVolumeTimer.QuadPart = FlagOn( Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH)
                                           ? (LONG)-1500*1000*10
                                           : (LONG)-8*1000*1000*10;

            (VOID)KeCancelTimer( &Vcb->CleanVolumeTimer );
            (VOID)KeRemoveQueueDpc( &Vcb->CleanVolumeDpc );

            //
            //  We have now synchronized with anybody clearing the dirty
            //  flag, so we can now see if we really have to actually write
            //  out the physical bit.
            //

            if ( !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY) ) {

                //
                //  We want to really mark the volume dirty now.
                //

                if (!FlagOn(Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY)) {

                    FatMarkVolume( IrpContext, Vcb, VolumeDirty );
                }

                SetFlag( Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY );

                //
                //  Lock the volume if it is removable.
                //

                if (FlagOn( Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA)) {

                    FatToggleMediaEjectDisable( IrpContext, Vcb, TRUE );
                }
            }

            KeAcquireSpinLock( &FatData.GeneralSpinLock, &SavedIrql );

            KeQuerySystemTime( &Vcb->LastFatMarkVolumeDirtyCall );

            KeReleaseSpinLock( &FatData.GeneralSpinLock, SavedIrql );

            KeSetTimer( &Vcb->CleanVolumeTimer,
                        CleanVolumeTimer,
                        &Vcb->CleanVolumeDpc );
        }
    }

    DebugTrace(-1, Dbg, "FatSetDirtyBcb -> VOID\n", 0 );
}


VOID
FatRepinBcb (
    IN PIRP_CONTEXT IrpContext,
    IN PBCB Bcb
    )

/*++

Routine Description:

    This routine saves a reference to the bcb in the irp context. This will
    have the affect of keeping the page in memory until we complete the
    request

Arguments:

    Bcb - Supplies the Bcb being referenced

Return Value:

    None.

--*/

{
    PREPINNED_BCBS Repinned;
    ULONG i;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatRepinBcb\n", 0 );
    DebugTrace( 0, Dbg, "IrpContext = %08lx\n", IrpContext );
    DebugTrace( 0, Dbg, "Bcb        = %08lx\n", Bcb );

    //
    //  The algorithm is to search the list of repinned records until
    //  we either find a match for the bcb or we find a null slot.
    //

    Repinned = &IrpContext->Repinned;

    while (TRUE) {

        //
        //  For every entry in the repinned record check if the bcb's
        //  match or if the entry is null.  If the bcb's match then
        //  we've done because we've already repinned this bcb, if
        //  the entry is null then we know, because it's densely packed,
        //  that the bcb is not in the list so add it to the repinned
        //  record and repin it.
        //

        for (i = 0; i < REPINNED_BCBS_ARRAY_SIZE; i += 1) {

            if (Repinned->Bcb[i] == Bcb) {

                DebugTrace(-1, Dbg, "FatRepinBcb -> VOID\n", 0 );
                return;
            }

            if (Repinned->Bcb[i] == NULL) {

                Repinned->Bcb[i] = Bcb;
                CcRepinBcb( Bcb );

                DebugTrace(-1, Dbg, "FatRepinBcb -> VOID\n", 0 );
                return;
            }
        }

        //
        //  We finished checking one repinned record so now locate the next
        //  repinned record,  If there isn't one then allocate and zero out
        //  a new one.
        //

        if (Repinned->Next == NULL) {

            Repinned->Next = FsRtlAllocatePoolWithTag( PagedPool,
                                                       sizeof(REPINNED_BCBS),
                                                       TAG_REPINNED_BCB );

            RtlZeroMemory( Repinned->Next, sizeof(REPINNED_BCBS) );
        }

        Repinned = Repinned->Next;
    }
}


VOID
FatUnpinRepinnedBcbs (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine frees all of the repinned bcbs, stored in an IRP context.

Arguments:

Return Value:

    None.

--*/

{
    IO_STATUS_BLOCK RaiseIosb;
    PREPINNED_BCBS Repinned;
    BOOLEAN WriteThroughToDisk;
    PFILE_OBJECT FileObject = NULL;
    BOOLEAN ForceVerify = FALSE;
    ULONG i;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatUnpinRepinnedBcbs\n", 0 );
    DebugTrace( 0, Dbg, "IrpContext = %08lx\n", IrpContext );

    //
    //  The algorithm for this procedure is to scan the entire list of
    //  repinned records unpinning any repinned bcbs.  We start off
    //  with the first record in the irp context, and while there is a
    //  record to scan we do the following loop.
    //

    Repinned = &IrpContext->Repinned;
    RaiseIosb.Status = STATUS_SUCCESS;

    //
    //  If the request is write through or the media is deferred flush,
    //  unpin the bcb's write through.
    //

    WriteThroughToDisk = (BOOLEAN) (!FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_WRITE_THROUGH) &&
                                    IrpContext->Vcb != NULL &&
                                    (FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_THROUGH) ||
                                     FlagOn(IrpContext->Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH)));

    while (Repinned != NULL) {

        //
        //  For every non-null entry in the repinned record unpin the
        //  repinned entry.
        //
        //  If the this is removable media (therefore all requests write-
        //  through) and the write fails, purge the cache so that we throw
        //  away the modifications as we will be returning an error to the
        //  user.
        //

        for (i = 0; i < REPINNED_BCBS_ARRAY_SIZE; i += 1) {

            if (Repinned->Bcb[i] != NULL) {

                IO_STATUS_BLOCK Iosb;

                if (WriteThroughToDisk && 
                    FlagOn(IrpContext->Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH)) {

                    FileObject = CcGetFileObjectFromBcb( Repinned->Bcb[i] );
                }

                CcUnpinRepinnedBcb( Repinned->Bcb[i],
                                    WriteThroughToDisk,
                                    &Iosb );

                if ( !NT_SUCCESS(Iosb.Status) ) {

                    if (RaiseIosb.Status == STATUS_SUCCESS) {

                        RaiseIosb = Iosb;
                    }

                    //
                    //  If this was a writethrough device, purge the cache,
                    //  except for Irp major codes that either don't handle
                    //  the error paths correctly or are simple victims like
                    //  cleanup.c.
                    //

                    if (FileObject &&
                        (IrpContext->MajorFunction != IRP_MJ_CLEANUP) &&
                        (IrpContext->MajorFunction != IRP_MJ_FLUSH_BUFFERS) &&
                        (IrpContext->MajorFunction != IRP_MJ_SET_INFORMATION)) {

                        //
                        //  The call to CcPurgeCacheSection() below will
                        //  purge the entire file from memory.  It will also
                        //  block until all the file's BCB's are pinned.
                        //
                        //  We end up in a deadlock situation of there
                        //  are any other pinned BCB's in this IRP context
                        //  so the first thing we do is search the list
                        //  for BCB's pinned in the same file and unpin
                        //  them.
                        //
                        //  We are probably not going to lose data because
                        //  it's safe to assume that all flushes will
                        //  fail after the first one fails.
                        //

                        ULONG j;

                        for (j = i + 1; j < REPINNED_BCBS_ARRAY_SIZE; j++) {

                            if (Repinned->Bcb[j] != NULL) {
                                
                                if (CcGetFileObjectFromBcb( Repinned->Bcb[j] ) == FileObject) {

                                    CcUnpinRepinnedBcb( Repinned->Bcb[j],
                                                        FALSE,
                                                        &Iosb );
                    
                                    Repinned->Bcb[j] = NULL;
                                }
                            }
                        }
                        
                        CcPurgeCacheSection( FileObject->SectionObjectPointer,
                                             NULL,
                                             0,
                                             FALSE );

                        //
                        //  Force a verify operation here since who knows
                        //  what state things are in.
                        //

                        ForceVerify = TRUE;
                    }
                }

                Repinned->Bcb[i] = NULL;

            }
        }

        //
        //  Now find the next repinned record in the list, and possibly
        //  delete the one we've just processed.
        //

        if (Repinned != &IrpContext->Repinned) {

            PREPINNED_BCBS Saved;

            Saved = Repinned->Next;
            ExFreePool( Repinned );
            Repinned = Saved;

        } else {

            Repinned = Repinned->Next;
            IrpContext->Repinned.Next = NULL;
        }
    }

    //
    //  Now if we weren't completely successful in the our unpin
    //  then raise the iosb we got
    //

    if (!NT_SUCCESS(RaiseIosb.Status)) {

        if (ForceVerify && FileObject) {

            SetFlag(FileObject->DeviceObject->Flags, DO_VERIFY_VOLUME);

            IoSetHardErrorOrVerifyDevice( IrpContext->OriginatingIrp,
                                          FileObject->DeviceObject );
        }

        if (!FlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_RAISE )) {
            
            IrpContext->OriginatingIrp->IoStatus = RaiseIosb;
            FatNormalizeAndRaiseStatus( IrpContext, RaiseIosb.Status );
        }
    }

    DebugTrace(-1, Dbg, "FatUnpinRepinnedBcbs -> VOID\n", 0 );

    return;
}


FINISHED
FatZeroData (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_OBJECT FileObject,
    IN ULONG StartingZero,
    IN ULONG ByteCount
    )

/*++

    **** Temporary function - Remove when CcZeroData is capable of handling
    non sector aligned requests.

--*/
{
    LARGE_INTEGER ZeroStart = {0,0};
    LARGE_INTEGER BeyondZeroEnd = {0,0};

    ULONG SectorSize;

    BOOLEAN Finished;

    PAGED_CODE();
    
    SectorSize = (ULONG)Vcb->Bpb.BytesPerSector;

    ZeroStart.LowPart = (StartingZero + (SectorSize - 1)) & ~(SectorSize - 1);

    //
    //  Detect overflow if we were asked to zero in the last sector of the file,
    //  which must be "zeroed" already (or we're in trouble).
    //
    
    if (StartingZero != 0 && ZeroStart.LowPart == 0) {
        
        return TRUE;
    }

    //
    //  Note that BeyondZeroEnd can take the value 4gb.
    //
    
    BeyondZeroEnd.QuadPart = ((ULONGLONG) StartingZero + ByteCount + (SectorSize - 1))
                             & (~((LONGLONG) SectorSize - 1));

    //
    //  If we were called to just zero part of a sector we are in trouble.
    //
    
    if ( ZeroStart.QuadPart == BeyondZeroEnd.QuadPart ) {

        return TRUE;
    }

    Finished = CcZeroData( FileObject,
                           &ZeroStart,
                           &BeyondZeroEnd,
                           BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) );

    return Finished;
}


NTSTATUS
FatCompleteMdl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the function of completing Mdl read and write
    requests.  It should be called only from FatFsdRead and FatFsdWrite.

Arguments:

    Irp - Supplies the originating Irp.

Return Value:

    NTSTATUS - Will always be STATUS_PENDING or STATUS_SUCCESS.

--*/

{
    PFILE_OBJECT FileObject;
    PIO_STACK_LOCATION IrpSp;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatCompleteMdl\n", 0 );
    DebugTrace( 0, Dbg, "IrpContext = %08lx\n", IrpContext );
    DebugTrace( 0, Dbg, "Irp        = %08lx\n", Irp );

    //
    // Do completion processing.
    //

    FileObject = IoGetCurrentIrpStackLocation( Irp )->FileObject;

    switch( IrpContext->MajorFunction ) {

    case IRP_MJ_READ:

        CcMdlReadComplete( FileObject, Irp->MdlAddress );
        break;

    case IRP_MJ_WRITE:

        IrpSp = IoGetCurrentIrpStackLocation( Irp );

        ASSERT( FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT ));

        CcMdlWriteComplete( FileObject, &IrpSp->Parameters.Write.ByteOffset, Irp->MdlAddress );

        Irp->IoStatus.Status = STATUS_SUCCESS;

        break;

    default:

        DebugTrace( DEBUG_TRACE_ERROR, 0, "Illegal Mdl Complete.\n", 0);
        FatBugCheck( IrpContext->MajorFunction, 0, 0 );
    }

    //
    // Mdl is now deallocated.
    //

    Irp->MdlAddress = NULL;

    //
    // Complete the request and exit right away.
    //

    FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );

    DebugTrace(-1, Dbg, "FatCompleteMdl -> STATUS_SUCCESS\n", 0 );

    return STATUS_SUCCESS;
}

VOID
FatSyncUninitializeCacheMap (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject
    )

/*++

Routine Description:

    The routine performs a CcUnitializeCacheMap to LargeZero synchronously.  That
    is it waits on the Cc event.  This call is useful when we want to be certain
    when a close will actually some in.

Return Value:

    None.

--*/

{
    CACHE_UNINITIALIZE_EVENT UninitializeCompleteEvent;
    NTSTATUS WaitStatus;

    PAGED_CODE();
    
    KeInitializeEvent( &UninitializeCompleteEvent.Event,
                       SynchronizationEvent,
                       FALSE);

    CcUninitializeCacheMap( FileObject,
                            &FatLargeZero,
                            &UninitializeCompleteEvent );

    //
    //  Now wait for the cache manager to finish purging the file.
    //  This will garentee that Mm gets the purge before we
    //  delete the Vcb.
    //

    WaitStatus = KeWaitForSingleObject( &UninitializeCompleteEvent.Event,
                                        Executive,
                                        KernelMode,
                                        FALSE,
                                        NULL);

    ASSERT(WaitStatus == STATUS_SUCCESS);
}

VOID
FatPinMappedData (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN VBO StartingVbo,
    IN ULONG ByteCount,
    OUT PBCB *Bcb
    )

/*++

Routine Description:

    This routine pins data that was previously mapped before setting it dirty.

Arguments:

    Dcb - Pointer to the DCB for the directory

    StartingVbo - The virtual offset of the first desired byte

    ByteCount - Number of bytes desired

    Bcb - Returns a pointer to the BCB which is valid until unpinned

--*/

{
    LARGE_INTEGER Vbo;

    PAGED_CODE();
    
    DebugTrace(+1, Dbg, "FatPinMappedData\n", 0);
    DebugTrace( 0, Dbg, "Dcb         = %08lx\n", Dcb);
    DebugTrace( 0, Dbg, "StartingVbo = %08lx\n", StartingVbo);
    DebugTrace( 0, Dbg, "ByteCount   = %08lx\n", ByteCount);

    //
    //  Call the Cache manager to perform the operation.
    //

    Vbo.QuadPart = StartingVbo;

    if (!CcPinMappedData( Dcb->Specific.Dcb.DirectoryFile,
                          &Vbo,
                          ByteCount,
                          BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT),
                          Bcb )) {

        //
        // Could not pin the data without waiting (cache miss).
        //

        FatRaiseStatus( IrpContext, STATUS_CANT_WAIT );
    }

    DebugTrace(-1, Dbg, "FatReadDirectoryFile -> VOID, *BCB = %08lx\n", *Bcb);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fastfat\close.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Close.c

Abstract:

    This module implements the File Close routine for Fat called by the
    dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_CLOSE)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_CLOSE)

ULONG FatMaxDelayedCloseCount;


#define FatAcquireCloseMutex() {                        \
    ASSERT(KeAreApcsDisabled());                        \
    ExAcquireFastMutexUnsafe( &FatCloseQueueMutex );    \
}

#define FatReleaseCloseMutex() {                        \
    ASSERT(KeAreApcsDisabled());                        \
    ExReleaseFastMutexUnsafe( &FatCloseQueueMutex );    \
}

//
//  Local procedure prototypes
//

VOID
FatQueueClose (
    IN PCLOSE_CONTEXT CloseContext,
    IN BOOLEAN DelayClose
    );

PCLOSE_CONTEXT
FatRemoveClose (
    PVCB Vcb OPTIONAL,
    PVCB LastVcbHint OPTIONAL
    );

VOID
FatCloseWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatFsdClose)
#pragma alloc_text(PAGE, FatFspClose)
#pragma alloc_text(PAGE, FatCommonClose)
#pragma alloc_text(PAGE, FatCloseWorker)
#endif


NTSTATUS
FatFsdClose (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Close.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;
    TYPE_OF_OPEN TypeOfOpen;

    BOOLEAN TopLevel;

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS
    //

    if (FatDeviceIsFatFsdo( VolumeDeviceObject))  {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FILE_OPENED;

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );

        return STATUS_SUCCESS;
    }

    DebugTrace(+1, Dbg, "FatFsdClose\n", 0);

    //
    //  Call the common Close routine
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    //
    //  Get a pointer to the current stack location and the file object
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    FileObject = IrpSp->FileObject;

    //
    //  Decode the file object and set the read-only bit in the Ccb.
    //

    TypeOfOpen = FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb );

    if (Ccb && IsFileObjectReadOnly(FileObject)) {

        SetFlag( Ccb->Flags, CCB_FLAG_READ_ONLY );
    }

    try {

        PCLOSE_CONTEXT CloseContext = NULL;

        //
        //  If we are top level, WAIT can be TRUE, otherwise make it FALSE
        //  to avoid deadlocks, unless this is a top
        //  level request not originating from the system process.
        //

        BOOLEAN Wait = TopLevel && (PsGetCurrentProcess() != FatData.OurProcess);
        BOOLEAN VolumeTornDown = FALSE;

        //
        //  Call the common Close routine if we are not delaying this close.
        //

        if ((((TypeOfOpen == UserFileOpen) ||
              (TypeOfOpen == UserDirectoryOpen)) &&
             FlagOn(Fcb->FcbState, FCB_STATE_DELAY_CLOSE) &&
             !FatData.ShutdownStarted) ||
            (FatCommonClose(Vcb, Fcb, Ccb, TypeOfOpen, Wait, &VolumeTornDown) == STATUS_PENDING)) {

            //
            //  Metadata streams have had close contexts preallocated.
            //

            if (TypeOfOpen == VirtualVolumeFile) {
                
                ASSERT( Vcb->CloseContext != NULL );
                CloseContext = Vcb->CloseContext;
                Vcb->CloseContext = NULL;
                CloseContext->Free = TRUE;
            }
            else if ((TypeOfOpen == DirectoryFile) || (TypeOfOpen == EaFile)) {

                CloseContext = FatAllocateCloseContext( Vcb);
                ASSERT( CloseContext != NULL );
                CloseContext->Free = TRUE;

            } else {

                //
                //  Free up any query template strings before using the close context fields,
                //  which overlap (union)
                //

                FatDeallocateCcbStrings( Ccb );

                CloseContext = &Ccb->CloseContext;
                CloseContext->Free = FALSE;
                
                SetFlag( Ccb->Flags, CCB_FLAG_CLOSE_CONTEXT );
            }

            //
            //  If the status is pending, then let's get the information we
            //  need into the close context we already have bagged, complete
            //  the request, and post it.  It is important we allocate nothing
            //  in the close path.
            //

            CloseContext->Vcb = Vcb;
            CloseContext->Fcb = Fcb;
            CloseContext->TypeOfOpen = TypeOfOpen;

            //
            //  Send it off, either to an ExWorkerThread or to the async
            //  close list.
            //

            FatQueueClose( CloseContext,
                           (BOOLEAN)(Fcb && FlagOn(Fcb->FcbState, FCB_STATE_DELAY_CLOSE)));
        } else {
            
            //
            //  The close proceeded synchronously, so for the metadata objects we
            //  can now drop the close context we preallocated.
            //
            
            if ((TypeOfOpen == VirtualVolumeFile) ||
                (TypeOfOpen == DirectoryFile) ||
                (TypeOfOpen == EaFile)) {

                if (TypeOfOpen == VirtualVolumeFile) {

                    ASSERT( !VolumeTornDown);
                    CloseContext = Vcb->CloseContext;   
                    Vcb->CloseContext = NULL;
                }
                else {

                    CloseContext = FatAllocateCloseContext( VolumeTornDown ? NULL : Vcb);
                }
                
                ASSERT( CloseContext != NULL );
                ExFreePool( CloseContext );
            }
        }

        FatCompleteRequest( FatNull, Irp, Status );

    } 
    except(FatExceptionFilter( NULL, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with the 
        //  error status that we get back from the execption code.
        //

        Status = FatProcessException( NULL, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdClose -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}

VOID
FatCloseWorker (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is a shim between the IO worker package and FatFspClose.

Arguments:

    DeviceObject - Registration device object, unused
    Context - Context value, unused

Return Value:

    None.

--*/
{
    FsRtlEnterFileSystem();
    
    FatFspClose (Context);
    
    FsRtlExitFileSystem();
}


VOID
FatFspClose (
    IN PVCB Vcb OPTIONAL
    )

/*++

Routine Description:

    This routine implements the FSP part of Close.

Arguments:

    Vcb - If present, tells us to only close file objects opened on the
        specified volume.

Return Value:

    None.

--*/

{
    PCLOSE_CONTEXT CloseContext;
    PVCB CurrentVcb = NULL;
    PVCB LastVcb = NULL;
    BOOLEAN FreeContext;

    ULONG LoopsWithVcbHeld;
    
    DebugTrace(+1, Dbg, "FatFspClose\n", 0);

    //
    //  Set the top level IRP for the true FSP operation.
    //
    
    if (!ARGUMENT_PRESENT( Vcb )) {
        
        IoSetTopLevelIrp( (PIRP)FSRTL_FSP_TOP_LEVEL_IRP );
    }
    
    while (CloseContext = FatRemoveClose(Vcb, LastVcb)) {

        //
        //  If we are in the FSP (i.e. Vcb == NULL), then try to keep ahead of
        //  creates by doing several closes with one acquisition of the Vcb.
        //
        //  Note that we cannot be holding the Vcb on entry to FatCommonClose
        //  if this is last close as we will try to acquire FatData, and
        //  worse the volume (and therefore the Vcb) may go away.
        //

        if (!ARGUMENT_PRESENT(Vcb)) {
             
            if (!FatData.ShutdownStarted) {

                if (CloseContext->Vcb != CurrentVcb) {

                    LoopsWithVcbHeld = 0;

                    //
                    //  Release a previously held Vcb, if any.
                    //

                    if (CurrentVcb != NULL) {

                        ExReleaseResourceLite( &CurrentVcb->Resource);
                    }

                    //
                    //  Get the new Vcb.
                    //

                    CurrentVcb = CloseContext->Vcb;
                    (VOID)ExAcquireResourceExclusiveLite( &CurrentVcb->Resource, TRUE );

                } else {

                    //
                    //  Share the resource occasionally if we seem to be finding a lot
                    //  of closes for a single volume.
                    //

                    if (++LoopsWithVcbHeld >= 20) {

                        if (ExGetSharedWaiterCount( &CurrentVcb->Resource ) +
                            ExGetExclusiveWaiterCount( &CurrentVcb->Resource )) {

                            ExReleaseResourceLite( &CurrentVcb->Resource);
                            (VOID)ExAcquireResourceExclusiveLite( &CurrentVcb->Resource, TRUE );
                        }

                        LoopsWithVcbHeld = 0;
                    }
                }

                //
                //  Now check the Open count.  We may be about to delete this volume!
                //
                //  The test below must be <= 1 because there could still be outstanding
                //  stream references on this VCB that are not counted in the OpenFileCount.
                //  For example if there are no open files OpenFileCount could be zero and we would
                //  not release the resource here.  The call to FatCommonClose() below may cause
                //  the VCB to be torn down and we will try to release memory we don't
                //  own later.
                //

                if (CurrentVcb->OpenFileCount <= 1) {

                    ExReleaseResourceLite( &CurrentVcb->Resource);
                    CurrentVcb = NULL;
                }
            //
            //  If shutdown has started while processing our list, drop the
            //  current Vcb resource.
            //

            } else if (CurrentVcb != NULL) {

                ExReleaseResourceLite( &CurrentVcb->Resource);
                CurrentVcb = NULL;
            }
        }

        LastVcb = CurrentVcb;

        //
        //  Call the common Close routine.  Protected in a try {} except {}
        //

        try {

            //
            //  The close context either is in the CCB, automatically freed,
            //  or was from pool for a metadata fileobject, CCB is NULL, and
            //  we'll need to free it.
            //

            FreeContext = CloseContext->Free;

            (VOID)FatCommonClose( CloseContext->Vcb,
                                  CloseContext->Fcb,
                                  (FreeContext ? NULL :
                                                 CONTAINING_RECORD( CloseContext, CCB, CloseContext)),
                                  CloseContext->TypeOfOpen,
                                  TRUE,
                                  NULL );

        } except(FatExceptionFilter( NULL, GetExceptionInformation() )) {

            //
            //  Ignore anything we expect.
            //

            NOTHING;
        }

        //
        //  Drop the context if it came from pool.
        //
        
        if (FreeContext) {

            ExFreePool( CloseContext );
        }
    }

    //
    //  Release a previously held Vcb, if any.
    //

    if (CurrentVcb != NULL) {

        ExReleaseResourceLite( &CurrentVcb->Resource);
    }

    //
    //  Clean up the top level IRP hint if we owned it.
    //
    
    if (!ARGUMENT_PRESENT( Vcb )) {
        
        IoSetTopLevelIrp( NULL );
    }
    
    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFspClose -> NULL\n", 0);
}


VOID
FatQueueClose (
    IN PCLOSE_CONTEXT CloseContext,
    IN BOOLEAN DelayClose
    )

/*++

Routine Description:

    Enqueue a deferred close to one of the two delayed close queues.

Arguments:

    CloseContext - a close context to enqueue for the delayed close thread.
    
    DelayClose - whether this should go on the delayed close queue (unreferenced
        objects).

Return Value:

    None.

--*/

{
    BOOLEAN StartWorker = FALSE;

    FatAcquireCloseMutex();

    if (DelayClose) {

        InsertTailList( &FatData.DelayedCloseList,
                        &CloseContext->GlobalLinks );
        InsertTailList( &CloseContext->Vcb->DelayedCloseList,
                        &CloseContext->VcbLinks );

        FatData.DelayedCloseCount += 1;

        if ((FatData.DelayedCloseCount > FatMaxDelayedCloseCount) &&
            !FatData.AsyncCloseActive) {

            FatData.AsyncCloseActive = TRUE;
            StartWorker = TRUE;
        }

    } else {

        InsertTailList( &FatData.AsyncCloseList,
                        &CloseContext->GlobalLinks );
        InsertTailList( &CloseContext->Vcb->AsyncCloseList,
                        &CloseContext->VcbLinks );

        FatData.AsyncCloseCount += 1;

        if (!FatData.AsyncCloseActive) {

            FatData.AsyncCloseActive = TRUE;
            StartWorker = TRUE;
        }
    }

    FatReleaseCloseMutex();

    if (StartWorker) {

        IoQueueWorkItem( FatData.FatCloseItem, FatCloseWorker, CriticalWorkQueue, NULL );
    }
}


PCLOSE_CONTEXT
FatRemoveClose (
    PVCB Vcb OPTIONAL,
    PVCB LastVcbHint OPTIONAL
    )

/*++

Routine Description:

    Dequeue a deferred close from one of the two delayed close queues.

Arguments:

    Vcb - if specified, only returns close for this volume.
    
    LastVcbHint - if specified and other starvation avoidance is required by
        the system condition, will attempt to return closes for this volume.

Return Value:

    A close to perform.

--*/

{
    PLIST_ENTRY Entry;
    PCLOSE_CONTEXT CloseContext;
    BOOLEAN WorkerThread;

    FatAcquireCloseMutex();

    //
    //  Remember if this is the worker thread, so we can pull down the active
    //  flag should we run everything out.
    //
    
    WorkerThread = (Vcb == NULL);

    //
    //  If the queues are above the limits by a significant amount, we have
    //  to try hard to pull them down.  To do this, we will aggresively try
    //  to find closes for the last volume the caller looked at.  This will
    //  make sure we fully utilize the acquisition of the volume, which can
    //  be a hugely expensive resource to get (create/close/cleanup use it
    //  exclusively).
    //
    //  Only do this in the delayed close thread.  We will know this is the
    //  case by seeing a NULL mandatory Vcb.
    //

    if (Vcb == NULL && LastVcbHint != NULL) {

        //
        //  Flip over to aggressive at twice the legal limit, and flip it
        //  off at the legal limit.
        //
        
        if (!FatData.HighAsync && FatData.AsyncCloseCount > FatMaxDelayedCloseCount*2) {

            FatData.HighAsync = TRUE;
        
        } else if (FatData.HighAsync && FatData.AsyncCloseCount < FatMaxDelayedCloseCount) {

            FatData.HighAsync = FALSE;
        }
            
        if (!FatData.HighDelayed && FatData.DelayedCloseCount > FatMaxDelayedCloseCount*2) {

            FatData.HighDelayed = TRUE;
        
        } else if (FatData.HighDelayed && FatData.DelayedCloseCount < FatMaxDelayedCloseCount) {

            FatData.HighDelayed = FALSE;
        }

        if (FatData.HighAsync || FatData.HighDelayed) {

            Vcb = LastVcbHint;
        }
    }
        
    //
    //  Do the case when we don't care about which Vcb the close is on.
    //  This is the case when we are in an ExWorkerThread and aren't
    //  under pressure.
    //

    if (Vcb == NULL) {

        AnyClose:

        //
        //  First check the list of async closes.
        //

        if (!IsListEmpty( &FatData.AsyncCloseList )) {

            Entry = RemoveHeadList( &FatData.AsyncCloseList );
            FatData.AsyncCloseCount -= 1;

            CloseContext = CONTAINING_RECORD( Entry,
                                              CLOSE_CONTEXT,
                                              GlobalLinks );

            RemoveEntryList( &CloseContext->VcbLinks );

        //
        //  Do any delayed closes over half the limit, unless shutdown has
        //  started (then kill them all).
        //

        } else if (!IsListEmpty( &FatData.DelayedCloseList ) &&
                   (FatData.DelayedCloseCount > FatMaxDelayedCloseCount/2 ||
                    FatData.ShutdownStarted)) {

            Entry = RemoveHeadList( &FatData.DelayedCloseList );
            FatData.DelayedCloseCount -= 1;

            CloseContext = CONTAINING_RECORD( Entry,
                                              CLOSE_CONTEXT,
                                              GlobalLinks );

            RemoveEntryList( &CloseContext->VcbLinks );

        //
        //  There are no more closes to perform; show that we are done.
        //

        } else {

            CloseContext = NULL;

            if (WorkerThread) {
                
                FatData.AsyncCloseActive = FALSE;
            }
        }

    //
    //  We're running down a specific volume.
    //
    
    } else {


        //
        //  First check the list of async closes.
        //

        if (!IsListEmpty( &Vcb->AsyncCloseList )) {

            Entry = RemoveHeadList( &Vcb->AsyncCloseList );
            FatData.AsyncCloseCount -= 1;

            CloseContext = CONTAINING_RECORD( Entry,
                                              CLOSE_CONTEXT,
                                              VcbLinks );

            RemoveEntryList( &CloseContext->GlobalLinks );

        //
        //  Do any delayed closes.
        //

        } else if (!IsListEmpty( &Vcb->DelayedCloseList )) {

            Entry = RemoveHeadList( &Vcb->DelayedCloseList );
            FatData.DelayedCloseCount -= 1;

            CloseContext = CONTAINING_RECORD( Entry,
                                              CLOSE_CONTEXT,
                                              VcbLinks );
        
            RemoveEntryList( &CloseContext->GlobalLinks );
        
        //
        //  If we were trying to run down the queues but didn't find anything for this
        //  volume, flip over to accept anything and try again.
        //

        } else if (LastVcbHint) {

            goto AnyClose;
        
        //
        //  There are no more closes to perform; show that we are done.
        //

        } else {

            CloseContext = NULL;
        }
    }

    FatReleaseCloseMutex();

    return CloseContext;
}


NTSTATUS
FatCommonClose (
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN PCCB Ccb,
    IN TYPE_OF_OPEN TypeOfOpen,
    IN BOOLEAN Wait,
    IN OPTIONAL PBOOLEAN VolumeTornDown
    )

/*++

Routine Description:

    This is the common routine for closing a file/directory called by both
    the fsd and fsp threads.

    Close is invoked whenever the last reference to a file object is deleted.
    Cleanup is invoked when the last handle to a file object is closed, and
    is called before close.

    The function of close is to completely tear down and remove the fcb/dcb/ccb
    structures associated with the file object.

Arguments:

    Fcb - Supplies the file to process.

    Wait - If this is TRUE we are allowed to block for the Vcb, if FALSE
        then we must try to acquire the Vcb anyway.

    VolumeTornDown - This is really gross.  If we are really in the Fsp, and a 
        volume goes away.  We need some way to NULL out the VolDo variable in
        FspDispatch().

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PDCB ParentDcb;
    BOOLEAN RecursiveClose;
    IRP_CONTEXT IrpContext;

    DebugTrace(+1, Dbg, "FatCommonClose...\n", 0);

    //
    //  Special case the unopened file object
    //

    if (TypeOfOpen == UnopenedFileObject) {

        DebugTrace(0, Dbg, "Close unopened file object\n", 0);

        Status = STATUS_SUCCESS;

        DebugTrace(-1, Dbg, "FatCommonClose -> %08lx\n", Status);
        return Status;
    }

    //
    //  Set up our stack IrpContext.
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );

    IrpContext.NodeTypeCode = FAT_NTC_IRP_CONTEXT;
    IrpContext.NodeByteSize = sizeof( IrpContext );
    IrpContext.MajorFunction = IRP_MJ_CLOSE;
    
    if (Wait) {

        SetFlag( IrpContext.Flags, IRP_CONTEXT_FLAG_WAIT );
    }

    //
    //  Acquire exclusive access to the Vcb and enqueue the irp if we didn't
    //  get access.
    //

    if (!ExAcquireResourceExclusiveLite( &Vcb->Resource, Wait )) {

        return STATUS_PENDING;
    }

    //
    //  The following test makes sure that we don't blow away an Fcb if we
    //  are trying to do a Supersede/Overwrite open above us.  This test
    //  does not apply for the EA file.
    //

    if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_CREATE_IN_PROGRESS) &&
        Vcb->EaFcb != Fcb) {

        ExReleaseResourceLite( &Vcb->Resource );

        return STATUS_PENDING;
    }

    //
    //  Setting the following flag prevents recursive closes of directory file
    //  objects, which are handled in a special case loop.
    //

    if ( FlagOn(Vcb->VcbState, VCB_STATE_FLAG_CLOSE_IN_PROGRESS) ) {

        RecursiveClose = TRUE;

    } else {

        SetFlag(Vcb->VcbState, VCB_STATE_FLAG_CLOSE_IN_PROGRESS);

        RecursiveClose = FALSE;
    }

    //
    //  Synchronize here with other closes regarding volume deletion.  Note
    //  that the Vcb->OpenFileCount can be safely incremented here without
    //  FatData synchronization for the following reasons:
    //
    //  This counter only becomes relevant when (holding a spinlock):
    //
    //      A: The Vcb->OpenFileCount is zero, and
    //      B: The Vpb->Refcount is the residual (2/3 for close/verify)
    //
    //  For A to be true, there can be no more pending closes at this point
    //  in the close code.  For B to be true, in close, there cannot be
    //  a create in process, and thus no verify in process.
    //
    //  Also we only increment the count if this is a top level close.
    //

    if ( !RecursiveClose ) {

        Vcb->OpenFileCount += 1;
    }

    try {

        //
        //  Case on the type of open that we are trying to close.
        //

        switch (TypeOfOpen) {

        case VirtualVolumeFile:

            DebugTrace(0, Dbg, "Close VirtualVolumeFile\n", 0);

            try_return( Status = STATUS_SUCCESS );
            break;

        case UserVolumeOpen:

            DebugTrace(0, Dbg, "Close UserVolumeOpen\n", 0);

            Vcb->DirectAccessOpenCount -= 1;
            Vcb->OpenFileCount -= 1;
            if (FlagOn(Ccb->Flags, CCB_FLAG_READ_ONLY)) { Vcb->ReadOnlyCount -= 1; }

            FatDeleteCcb( &IrpContext, Ccb );

            try_return( Status = STATUS_SUCCESS );
            break;

        case EaFile:

            DebugTrace(0, Dbg, "Close EaFile\n", 0);

            try_return( Status = STATUS_SUCCESS );
            break;

        case DirectoryFile:

            DebugTrace(0, Dbg, "Close DirectoryFile\n", 0);

            InterlockedDecrement( &Fcb->Specific.Dcb.DirectoryFileOpenCount );

            //
            //  If this is a recursive close, just return here.
            //

            if ( RecursiveClose ) {

                try_return( Status = STATUS_SUCCESS );

            } else {

                break;
            }

        case UserDirectoryOpen:
        case UserFileOpen:

            DebugTrace(0, Dbg, "Close UserFileOpen/UserDirectoryOpen\n", 0);

            //
            //  Uninitialize the cache map if we no longer need to use it
            //

            if ((NodeType(Fcb) == FAT_NTC_DCB) &&
                IsListEmpty(&Fcb->Specific.Dcb.ParentDcbQueue) &&
                (Fcb->OpenCount == 1) &&
                (Fcb->Specific.Dcb.DirectoryFile != NULL)) {

                PFILE_OBJECT DirectoryFileObject = Fcb->Specific.Dcb.DirectoryFile;

                DebugTrace(0, Dbg, "Uninitialize the stream file object\n", 0);

                CcUninitializeCacheMap( DirectoryFileObject, NULL, NULL );

                //
                //  Dereference the directory file.  This may cause a close
                //  Irp to be processed, so we need to do this before we destory
                //  the Fcb.
                //

                Fcb->Specific.Dcb.DirectoryFile = NULL;
                ObDereferenceObject( DirectoryFileObject );
            }

            Fcb->OpenCount -= 1;
            Vcb->OpenFileCount -= 1;
            if (FlagOn(Ccb->Flags, CCB_FLAG_READ_ONLY)) { Vcb->ReadOnlyCount -= 1; }

            FatDeleteCcb( &IrpContext, Ccb );

            break;

        default:

            FatBugCheck( TypeOfOpen, 0, 0 );
        }

        //
        //  At this point we've cleaned up any on-disk structure that needs
        //  to be done, and we can now update the in-memory structures.
        //  Now if this is an unreferenced FCB or if it is
        //  an unreferenced DCB (not the root) then we can remove
        //  the fcb and set our ParentDcb to non null.
        //

        if (((NodeType(Fcb) == FAT_NTC_FCB) &&
             (Fcb->OpenCount == 0))

                ||

             ((NodeType(Fcb) == FAT_NTC_DCB) &&
              (IsListEmpty(&Fcb->Specific.Dcb.ParentDcbQueue)) &&
              (Fcb->OpenCount == 0) &&
              (Fcb->Specific.Dcb.DirectoryFileOpenCount == 0))) {

            ParentDcb = Fcb->ParentDcb;

            SetFlag( Vcb->VcbState, VCB_STATE_FLAG_DELETED_FCB );

            FatDeleteFcb( &IrpContext, Fcb );

            //
            //  Uninitialize our parent's cache map if we no longer need
            //  to use it.
            //

            while ((NodeType(ParentDcb) == FAT_NTC_DCB) &&
                   IsListEmpty(&ParentDcb->Specific.Dcb.ParentDcbQueue) &&
                   (ParentDcb->OpenCount == 0) &&
                   (ParentDcb->Specific.Dcb.DirectoryFile != NULL)) {

                PFILE_OBJECT DirectoryFileObject;

                DirectoryFileObject = ParentDcb->Specific.Dcb.DirectoryFile;

                DebugTrace(0, Dbg, "Uninitialize our parent Stream Cache Map\n", 0);

                CcUninitializeCacheMap( DirectoryFileObject, NULL, NULL );

                ParentDcb->Specific.Dcb.DirectoryFile = NULL;

                ObDereferenceObject( DirectoryFileObject );

                //
                //  Now, if the ObDereferenceObject() caused the final close
                //  to come in, then blow away the Fcb and continue up,
                //  otherwise wait for Mm to to dereference its file objects
                //  and stop here..
                //

                if ( ParentDcb->Specific.Dcb.DirectoryFileOpenCount == 0) {

                    PDCB CurrentDcb;

                    CurrentDcb = ParentDcb;
                    ParentDcb = CurrentDcb->ParentDcb;

                    SetFlag( Vcb->VcbState, VCB_STATE_FLAG_DELETED_FCB );

                    FatDeleteFcb( &IrpContext, CurrentDcb );

                } else {

                    break;
                }
            }
        }

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatCommonClose );

        if ( !RecursiveClose ) {

            ClearFlag( Vcb->VcbState, VCB_STATE_FLAG_CLOSE_IN_PROGRESS );
        }

        //
        //  Check if we should delete the volume.  Unfortunately, to correctly
        //  synchronize with verify, we can only unsafely check our own
        //  transition.  This results in a little bit of extra overhead in the
        //  1 -> 0 OpenFileCount transition.
        //
        //  2 is the residual Vpb->RefCount on a volume to be freed.
        //

        //
        //  Here is the deal with releasing the Vcb.  We must be holding the
        //  Vcb when decrementing the Vcb->OpenFileCount.  If we don't this
        //  could cause the decrement to mal-function on an MP system.  But we
        //  want to be holding the Global resource exclusive when decrement
        //  the count so that nobody else will try to dismount the volume.
        //  However, because of locking rules, the Global resource must be
        //  acquired first, which is why we do what we do below.
        //

        if ( !RecursiveClose ) {

            if ( Vcb->OpenFileCount == 1 ) {

                PVPB Vpb = Vcb->Vpb;

                SetFlag( IrpContext.Flags, IRP_CONTEXT_FLAG_WAIT );

                FatReleaseVcb( &IrpContext, Vcb );

                (VOID)FatAcquireExclusiveGlobal( &IrpContext );
                (VOID)FatAcquireExclusiveVcb( &IrpContext, Vcb );

                Vcb->OpenFileCount -= 1;

                FatReleaseVcb( &IrpContext, Vcb );

                //
                //  We can now "safely" check OpenFileCount and VcbCondition.
                //  If they are OK, we will proceed to checking the
                //  Vpb Ref Count in FatCheckForDismount.
                //

                if ( (Vcb->OpenFileCount == 0) &&
                     ((Vcb->VcbCondition == VcbNotMounted) ||
                      (Vcb->VcbCondition == VcbBad) ||
                      FlagOn( Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN )) &&
                     FatCheckForDismount( &IrpContext, Vcb, FALSE ) ) {


                    //
                    //  If this is not the Vpb "attached" to the device, free it.
                    //

                    if ((Vpb->RealDevice->Vpb != Vpb) &&
                        !FlagOn( Vpb->Flags, VPB_PERSISTENT)) {

                        ExFreePool( Vpb );
                    }

                    if (ARGUMENT_PRESENT(VolumeTornDown)) {

                        *VolumeTornDown = TRUE;
                    }
                }

                FatReleaseGlobal( &IrpContext );

            } else {

                Vcb->OpenFileCount -= 1;

                FatReleaseVcb( &IrpContext, Vcb );
            }

        } else {

            FatReleaseVcb( &IrpContext, Vcb );
        }

        DebugTrace(-1, Dbg, "FatCommonClose -> %08lx\n", Status);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\fastfat\create.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Create.c

Abstract:

    This module implements the File Create routine for Fat called by the
    dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_CREATE)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_CREATE)


//
//  Macros for incrementing performance counters.
//

#define CollectCreateHitStatistics(VCB) {                                                \
    PFILE_SYSTEM_STATISTICS Stats = &(VCB)->Statistics[KeGetCurrentProcessorNumber()];   \
    Stats->Fat.CreateHits += 1;                                                          \
}

#define CollectCreateStatistics(VCB,STATUS) {                                            \
    PFILE_SYSTEM_STATISTICS Stats = &(VCB)->Statistics[KeGetCurrentProcessorNumber()];   \
    if ((STATUS) == STATUS_SUCCESS) {                                                    \
        Stats->Fat.SuccessfulCreates += 1;                                               \
    } else {                                                                             \
        Stats->Fat.FailedCreates += 1;                                                   \
    }                                                                                    \
}

LUID FatSecurityPrivilege = { SE_SECURITY_PRIVILEGE, 0 };

//
//  local procedure prototypes
//

IO_STATUS_BLOCK
FatOpenVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateDisposition
    );

IO_STATUS_BLOCK
FatOpenRootDcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateDisposition
    );

IO_STATUS_BLOCK
FatOpenExistingDcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB Dcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateDisposition,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose
    );

IO_STATUS_BLOCK
FatOpenExistingFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PFCB Fcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG AllocationSize,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN ULONG CreateDisposition,
    IN BOOLEAN DeleteOnClose,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN FileNameOpenedDos,
    OUT PBOOLEAN OplockPostIrp
    );

IO_STATUS_BLOCK
FatOpenTargetDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PDCB Dcb,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN BOOLEAN DoesNameExist
    );

IO_STATUS_BLOCK
FatOpenExistingDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN PDIRENT Dirent,
    IN ULONG LfnByteOffset,
    IN ULONG DirentByteOffset,
    IN PUNICODE_STRING Lfn,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG CreateDisposition,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose
    );

IO_STATUS_BLOCK
FatOpenExistingFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN PDIRENT Dirent,
    IN ULONG LfnByteOffset,
    IN ULONG DirentByteOffset,
    IN PUNICODE_STRING Lfn,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG AllocationSize,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN ULONG CreateDisposition,
    IN BOOLEAN IsPagingFile,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose,
    IN BOOLEAN FileNameOpenedDos
    );

IO_STATUS_BLOCK
FatCreateNewDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN POEM_STRING OemName,
    IN PUNICODE_STRING UnicodeName,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose
    );

IO_STATUS_BLOCK
FatCreateNewFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN POEM_STRING OemName,
    IN PUNICODE_STRING UnicodeName,
    IN PACCESS_MASK DesiredAccess,
    IN USHORT ShareAccess,
    IN ULONG AllocationSize,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN PUNICODE_STRING LfnBuffer,
    IN BOOLEAN IsPagingFile,
    IN BOOLEAN NoEaKnowledge,
    IN BOOLEAN DeleteOnClose,
    IN BOOLEAN TemporaryFile
    );

IO_STATUS_BLOCK
FatSupersedeOrOverwriteFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFILE_OBJECT FileObject,
    IN PFCB Fcb,
    IN ULONG AllocationSize,
    IN PFILE_FULL_EA_INFORMATION EaBuffer,
    IN ULONG EaLength,
    IN UCHAR FileAttributes,
    IN ULONG CreateDisposition,
    IN BOOLEAN NoEaKnowledge
    );

NTSTATUS
FatCheckSystemSecurityAccess(
    PIRP_CONTEXT IrpContext
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCheckSystemSecurityAccess)
#pragma alloc_text(PAGE, FatCommonCreate)
#pragma alloc_text(PAGE, FatCreateNewDirectory)
#pragma alloc_text(PAGE, FatCreateNewFile)
#pragma alloc_text(PAGE, FatFsdCreate)
#pragma alloc_text(PAGE, FatOpenExistingDcb)
#pragma alloc_text(PAGE, FatOpenExistingDirectory)
#pragma alloc_text(PAGE, FatOpenExistingFcb)
#pragma alloc_text(PAGE, FatOpenExistingFile)
#pragma alloc_text(PAGE, FatOpenRootDcb)
#pragma alloc_text(PAGE, FatOpenTargetDirectory)
#pragma alloc_text(PAGE, FatOpenVolume)
#pragma alloc_text(PAGE, FatSupersedeOrOverwriteFile)
#pragma alloc_text(PAGE, FatSetFullNameInFcb)
#endif


NTSTATUS
FatFsdCreate (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtCreateFile and NtOpenFile
    API calls.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file/directory exists that we are trying to open/create

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The Fsd status for the Irp

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    //
    //  If we were called with our file system device object instead of a
    //  volume device object, just complete this request with STATUS_SUCCESS
    //

    if ( FatDeviceIsFatFsdo( VolumeDeviceObject))  {

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FILE_OPENED;

        IoCompleteRequest( Irp, IO_DISK_INCREMENT );

        return STATUS_SUCCESS;
    }

    TimerStart(Dbg);

    DebugTrace(+1, Dbg, "FatFsdCreate\n", 0);

    //
    //  Call the common create routine, with block allowed if the operation
    //  is synchronous.
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, TRUE );

        Status = FatCommonCreate( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdCreate -> %08lx\n", Status );

    TimerStop(Dbg,"FatFsdCreate");

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}



NTSTATUS
FatCommonCreate (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for creating/opening a file called by
    both the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - the return status for the operation

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;
    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    PFILE_OBJECT RelatedFileObject;
    UNICODE_STRING FileName;
    ULONG AllocationSize;
    PFILE_FULL_EA_INFORMATION EaBuffer;
    PACCESS_MASK DesiredAccess;
    ULONG Options;
    UCHAR FileAttributes;
    USHORT ShareAccess;
    ULONG EaLength;

    BOOLEAN CreateDirectory;
    BOOLEAN SequentialOnly;
    BOOLEAN NoIntermediateBuffering;
    BOOLEAN OpenDirectory;
    BOOLEAN IsPagingFile;
    BOOLEAN OpenTargetDirectory;
    BOOLEAN DirectoryFile;
    BOOLEAN NonDirectoryFile;
    BOOLEAN NoEaKnowledge;
   